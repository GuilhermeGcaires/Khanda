// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_server.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgPoorNetworkConditions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPoorNetworkConditions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPoorNetworkConditions.detection_type)
    pub detection_type: ::std::option::Option<::protobuf::EnumOrUnknown<EPoorNetworkConditionsType>>,
    // @@protoc_insertion_point(field:dota.CMsgPoorNetworkConditions.players)
    pub players: ::std::vec::Vec<cmsg_poor_network_conditions::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPoorNetworkConditions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPoorNetworkConditions {
    fn default() -> &'a CMsgPoorNetworkConditions {
        <CMsgPoorNetworkConditions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPoorNetworkConditions {
    pub fn new() -> CMsgPoorNetworkConditions {
        ::std::default::Default::default()
    }

    // optional .dota.EPoorNetworkConditionsType detection_type = 1;

    pub fn detection_type(&self) -> EPoorNetworkConditionsType {
        match self.detection_type {
            Some(e) => e.enum_value_or(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None),
            None => EPoorNetworkConditionsType::k_EPoorNetworkConditions_None,
        }
    }

    pub fn clear_detection_type(&mut self) {
        self.detection_type = ::std::option::Option::None;
    }

    pub fn has_detection_type(&self) -> bool {
        self.detection_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detection_type(&mut self, v: EPoorNetworkConditionsType) {
        self.detection_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "detection_type",
            |m: &CMsgPoorNetworkConditions| { &m.detection_type },
            |m: &mut CMsgPoorNetworkConditions| { &mut m.detection_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgPoorNetworkConditions| { &m.players },
            |m: &mut CMsgPoorNetworkConditions| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPoorNetworkConditions>(
            "CMsgPoorNetworkConditions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPoorNetworkConditions {
    const NAME: &'static str = "CMsgPoorNetworkConditions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.detection_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.detection_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.detection_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPoorNetworkConditions {
        CMsgPoorNetworkConditions::new()
    }

    fn clear(&mut self) {
        self.detection_type = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPoorNetworkConditions {
        static instance: CMsgPoorNetworkConditions = CMsgPoorNetworkConditions {
            detection_type: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPoorNetworkConditions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPoorNetworkConditions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPoorNetworkConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPoorNetworkConditions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPoorNetworkConditions`
pub mod cmsg_poor_network_conditions {
    // @@protoc_insertion_point(message:dota.CMsgPoorNetworkConditions.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgPoorNetworkConditions.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPoorNetworkConditions.Player.disconnect_reason)
        pub disconnect_reason: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::network_connection::ENetworkDisconnectionReason>>,
        // @@protoc_insertion_point(field:dota.CMsgPoorNetworkConditions.Player.num_bad_intervals)
        pub num_bad_intervals: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPoorNetworkConditions.Player.peak_loss_pct)
        pub peak_loss_pct: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgPoorNetworkConditions.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional .dota.ENetworkDisconnectionReason disconnect_reason = 2;

        pub fn disconnect_reason(&self) -> super::super::network_connection::ENetworkDisconnectionReason {
            match self.disconnect_reason {
                Some(e) => e.enum_value_or(super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID),
                None => super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID,
            }
        }

        pub fn clear_disconnect_reason(&mut self) {
            self.disconnect_reason = ::std::option::Option::None;
        }

        pub fn has_disconnect_reason(&self) -> bool {
            self.disconnect_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disconnect_reason(&mut self, v: super::super::network_connection::ENetworkDisconnectionReason) {
            self.disconnect_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 num_bad_intervals = 3;

        pub fn num_bad_intervals(&self) -> u32 {
            self.num_bad_intervals.unwrap_or(0)
        }

        pub fn clear_num_bad_intervals(&mut self) {
            self.num_bad_intervals = ::std::option::Option::None;
        }

        pub fn has_num_bad_intervals(&self) -> bool {
            self.num_bad_intervals.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_bad_intervals(&mut self, v: u32) {
            self.num_bad_intervals = ::std::option::Option::Some(v);
        }

        // optional uint32 peak_loss_pct = 4;

        pub fn peak_loss_pct(&self) -> u32 {
            self.peak_loss_pct.unwrap_or(0)
        }

        pub fn clear_peak_loss_pct(&mut self) {
            self.peak_loss_pct = ::std::option::Option::None;
        }

        pub fn has_peak_loss_pct(&self) -> bool {
            self.peak_loss_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_peak_loss_pct(&mut self, v: u32) {
            self.peak_loss_pct = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "disconnect_reason",
                |m: &Player| { &m.disconnect_reason },
                |m: &mut Player| { &mut m.disconnect_reason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_bad_intervals",
                |m: &Player| { &m.num_bad_intervals },
                |m: &mut Player| { &mut m.num_bad_intervals },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "peak_loss_pct",
                |m: &Player| { &m.peak_loss_pct },
                |m: &mut Player| { &mut m.peak_loss_pct },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgPoorNetworkConditions.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.disconnect_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.num_bad_intervals = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.peak_loss_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.disconnect_reason {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.num_bad_intervals {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.peak_loss_pct {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.disconnect_reason {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.num_bad_intervals {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.peak_loss_pct {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.disconnect_reason = ::std::option::Option::None;
            self.num_bad_intervals = ::std::option::Option::None;
            self.peak_loss_pct = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                disconnect_reason: ::std::option::Option::None,
                num_bad_intervals: ::std::option::Option::None,
                peak_loss_pct: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPoorNetworkConditions.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGameserverCrash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameserverCrash {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.game_state)
    pub game_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameState>>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.sentinel_save_time)
    pub sentinel_save_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.server_public_ip_addr)
    pub server_public_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.server_cluster)
    pub server_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.pid)
    pub pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameserverCrash.engine)
    pub engine: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameserverCrash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameserverCrash {
    fn default() -> &'a CMsgGameserverCrash {
        <CMsgGameserverCrash as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameserverCrash {
    pub fn new() -> CMsgGameserverCrash {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 lobby_id = 2;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GameState game_state = 3;

    pub fn game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            None => super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 sentinel_save_time = 4;

    pub fn sentinel_save_time(&self) -> u32 {
        self.sentinel_save_time.unwrap_or(0)
    }

    pub fn clear_sentinel_save_time(&mut self) {
        self.sentinel_save_time = ::std::option::Option::None;
    }

    pub fn has_sentinel_save_time(&self) -> bool {
        self.sentinel_save_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sentinel_save_time(&mut self, v: u32) {
        self.sentinel_save_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 custom_game_id = 11;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_id = 12;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_steam_id = 5;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_public_ip_addr = 6;

    pub fn server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 7;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 server_cluster = 8;

    pub fn server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 pid = 9;

    pub fn pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional uint32 engine = 10;

    pub fn engine(&self) -> u32 {
        self.engine.unwrap_or(0)
    }

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: u32) {
        self.engine = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGameserverCrash| { &m.match_id },
            |m: &mut CMsgGameserverCrash| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgGameserverCrash| { &m.lobby_id },
            |m: &mut CMsgGameserverCrash| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_state",
            |m: &CMsgGameserverCrash| { &m.game_state },
            |m: &mut CMsgGameserverCrash| { &mut m.game_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sentinel_save_time",
            |m: &CMsgGameserverCrash| { &m.sentinel_save_time },
            |m: &mut CMsgGameserverCrash| { &mut m.sentinel_save_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CMsgGameserverCrash| { &m.custom_game_id },
            |m: &mut CMsgGameserverCrash| { &mut m.custom_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_id",
            |m: &CMsgGameserverCrash| { &m.tournament_id },
            |m: &mut CMsgGameserverCrash| { &mut m.tournament_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_steam_id",
            |m: &CMsgGameserverCrash| { &m.server_steam_id },
            |m: &mut CMsgGameserverCrash| { &mut m.server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_public_ip_addr",
            |m: &CMsgGameserverCrash| { &m.server_public_ip_addr },
            |m: &mut CMsgGameserverCrash| { &mut m.server_public_ip_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgGameserverCrash| { &m.server_port },
            |m: &mut CMsgGameserverCrash| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_cluster",
            |m: &CMsgGameserverCrash| { &m.server_cluster },
            |m: &mut CMsgGameserverCrash| { &mut m.server_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pid",
            |m: &CMsgGameserverCrash| { &m.pid },
            |m: &mut CMsgGameserverCrash| { &mut m.pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engine",
            |m: &CMsgGameserverCrash| { &m.engine },
            |m: &mut CMsgGameserverCrash| { &mut m.engine },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameserverCrash>(
            "CMsgGameserverCrash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameserverCrash {
    const NAME: &'static str = "CMsgGameserverCrash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                37 => {
                    self.sentinel_save_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                89 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                96 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                53 => {
                    self.server_public_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.server_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.engine = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.sentinel_save_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.custom_game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.server_public_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.server_cluster {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.engine {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sentinel_save_time {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.engine {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameserverCrash {
        CMsgGameserverCrash::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.game_state = ::std::option::Option::None;
        self.sentinel_save_time = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.server_public_ip_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.server_cluster = ::std::option::Option::None;
        self.pid = ::std::option::Option::None;
        self.engine = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameserverCrash {
        static instance: CMsgGameserverCrash = CMsgGameserverCrash {
            match_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            game_state: ::std::option::Option::None,
            sentinel_save_time: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            server_steam_id: ::std::option::Option::None,
            server_public_ip_addr: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            server_cluster: ::std::option::Option::None,
            pid: ::std::option::Option::None,
            engine: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameserverCrash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameserverCrash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameserverCrash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameserverCrash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgConnectedPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConnectedPlayers {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.connected_players)
    pub connected_players: ::std::vec::Vec<cmsg_connected_players::Player>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.disconnected_players)
    pub disconnected_players: ::std::vec::Vec<cmsg_connected_players::Player>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.game_state)
    pub game_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameState>>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.first_blood_happened)
    pub first_blood_happened: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.poor_network_conditions)
    pub poor_network_conditions: ::protobuf::MessageField<CMsgPoorNetworkConditions>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.send_reason)
    pub send_reason: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_connected_players::SendReason>>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.radiant_kills)
    pub radiant_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.dire_kills)
    pub dire_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.radiant_lead)
    pub radiant_lead: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.building_state)
    pub building_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.player_draft)
    pub player_draft: ::std::vec::Vec<cmsg_connected_players::PlayerDraft>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgConnectedPlayers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConnectedPlayers {
    fn default() -> &'a CMsgConnectedPlayers {
        <CMsgConnectedPlayers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectedPlayers {
    pub fn new() -> CMsgConnectedPlayers {
        ::std::default::Default::default()
    }

    // optional .dota.DOTA_GameState game_state = 2;

    pub fn game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            None => super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool first_blood_happened = 6;

    pub fn first_blood_happened(&self) -> bool {
        self.first_blood_happened.unwrap_or(false)
    }

    pub fn clear_first_blood_happened(&mut self) {
        self.first_blood_happened = ::std::option::Option::None;
    }

    pub fn has_first_blood_happened(&self) -> bool {
        self.first_blood_happened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_happened(&mut self, v: bool) {
        self.first_blood_happened = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgConnectedPlayers.SendReason send_reason = 8;

    pub fn send_reason(&self) -> cmsg_connected_players::SendReason {
        match self.send_reason {
            Some(e) => e.enum_value_or(cmsg_connected_players::SendReason::INVALID),
            None => cmsg_connected_players::SendReason::INVALID,
        }
    }

    pub fn clear_send_reason(&mut self) {
        self.send_reason = ::std::option::Option::None;
    }

    pub fn has_send_reason(&self) -> bool {
        self.send_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_reason(&mut self, v: cmsg_connected_players::SendReason) {
        self.send_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 radiant_kills = 11;

    pub fn radiant_kills(&self) -> u32 {
        self.radiant_kills.unwrap_or(0)
    }

    pub fn clear_radiant_kills(&mut self) {
        self.radiant_kills = ::std::option::Option::None;
    }

    pub fn has_radiant_kills(&self) -> bool {
        self.radiant_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_kills(&mut self, v: u32) {
        self.radiant_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_kills = 12;

    pub fn dire_kills(&self) -> u32 {
        self.dire_kills.unwrap_or(0)
    }

    pub fn clear_dire_kills(&mut self) {
        self.dire_kills = ::std::option::Option::None;
    }

    pub fn has_dire_kills(&self) -> bool {
        self.dire_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_kills(&mut self, v: u32) {
        self.dire_kills = ::std::option::Option::Some(v);
    }

    // optional int32 radiant_lead = 14;

    pub fn radiant_lead(&self) -> i32 {
        self.radiant_lead.unwrap_or(0)
    }

    pub fn clear_radiant_lead(&mut self) {
        self.radiant_lead = ::std::option::Option::None;
    }

    pub fn has_radiant_lead(&self) -> bool {
        self.radiant_lead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_lead(&mut self, v: i32) {
        self.radiant_lead = ::std::option::Option::Some(v);
    }

    // optional uint32 building_state = 15;

    pub fn building_state(&self) -> u32 {
        self.building_state.unwrap_or(0)
    }

    pub fn clear_building_state(&mut self) {
        self.building_state = ::std::option::Option::None;
    }

    pub fn has_building_state(&self) -> bool {
        self.building_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_state(&mut self, v: u32) {
        self.building_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connected_players",
            |m: &CMsgConnectedPlayers| { &m.connected_players },
            |m: &mut CMsgConnectedPlayers| { &mut m.connected_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disconnected_players",
            |m: &CMsgConnectedPlayers| { &m.disconnected_players },
            |m: &mut CMsgConnectedPlayers| { &mut m.disconnected_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_state",
            |m: &CMsgConnectedPlayers| { &m.game_state },
            |m: &mut CMsgConnectedPlayers| { &mut m.game_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_blood_happened",
            |m: &CMsgConnectedPlayers| { &m.first_blood_happened },
            |m: &mut CMsgConnectedPlayers| { &mut m.first_blood_happened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoorNetworkConditions>(
            "poor_network_conditions",
            |m: &CMsgConnectedPlayers| { &m.poor_network_conditions },
            |m: &mut CMsgConnectedPlayers| { &mut m.poor_network_conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_reason",
            |m: &CMsgConnectedPlayers| { &m.send_reason },
            |m: &mut CMsgConnectedPlayers| { &mut m.send_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_kills",
            |m: &CMsgConnectedPlayers| { &m.radiant_kills },
            |m: &mut CMsgConnectedPlayers| { &mut m.radiant_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_kills",
            |m: &CMsgConnectedPlayers| { &m.dire_kills },
            |m: &mut CMsgConnectedPlayers| { &mut m.dire_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_lead",
            |m: &CMsgConnectedPlayers| { &m.radiant_lead },
            |m: &mut CMsgConnectedPlayers| { &mut m.radiant_lead },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "building_state",
            |m: &CMsgConnectedPlayers| { &m.building_state },
            |m: &mut CMsgConnectedPlayers| { &mut m.building_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_draft",
            |m: &CMsgConnectedPlayers| { &m.player_draft },
            |m: &mut CMsgConnectedPlayers| { &mut m.player_draft },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConnectedPlayers>(
            "CMsgConnectedPlayers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConnectedPlayers {
    const NAME: &'static str = "CMsgConnectedPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connected_players.push(is.read_message()?);
                },
                58 => {
                    self.disconnected_players.push(is.read_message()?);
                },
                16 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.first_blood_happened = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.poor_network_conditions)?;
                },
                64 => {
                    self.send_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.radiant_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.dire_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.radiant_lead = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.building_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                130 => {
                    self.player_draft.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.connected_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.disconnected_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.first_blood_happened {
            my_size += 1 + 1;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.send_reason {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.radiant_kills {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.dire_kills {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.radiant_lead {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.building_state {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        for value in &self.player_draft {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.connected_players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.disconnected_players {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.game_state {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.first_blood_happened {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.send_reason {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radiant_kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.dire_kills {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.radiant_lead {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.building_state {
            os.write_uint32(15, v)?;
        }
        for v in &self.player_draft {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConnectedPlayers {
        CMsgConnectedPlayers::new()
    }

    fn clear(&mut self) {
        self.connected_players.clear();
        self.disconnected_players.clear();
        self.game_state = ::std::option::Option::None;
        self.first_blood_happened = ::std::option::Option::None;
        self.poor_network_conditions.clear();
        self.send_reason = ::std::option::Option::None;
        self.radiant_kills = ::std::option::Option::None;
        self.dire_kills = ::std::option::Option::None;
        self.radiant_lead = ::std::option::Option::None;
        self.building_state = ::std::option::Option::None;
        self.player_draft.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConnectedPlayers {
        static instance: CMsgConnectedPlayers = CMsgConnectedPlayers {
            connected_players: ::std::vec::Vec::new(),
            disconnected_players: ::std::vec::Vec::new(),
            game_state: ::std::option::Option::None,
            first_blood_happened: ::std::option::Option::None,
            poor_network_conditions: ::protobuf::MessageField::none(),
            send_reason: ::std::option::Option::None,
            radiant_kills: ::std::option::Option::None,
            dire_kills: ::std::option::Option::None,
            radiant_lead: ::std::option::Option::None,
            building_state: ::std::option::Option::None,
            player_draft: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConnectedPlayers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConnectedPlayers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConnectedPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectedPlayers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgConnectedPlayers`
pub mod cmsg_connected_players {
    // @@protoc_insertion_point(message:dota.CMsgConnectedPlayers.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.Player.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.Player.leaver_state)
        pub leaver_state: ::protobuf::MessageField<super::super::dota_gcmessages_common_match_management::CMsgLeaverState>,
        // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.Player.disconnect_reason)
        pub disconnect_reason: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::network_connection::ENetworkDisconnectionReason>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgConnectedPlayers.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 2;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional .dota.ENetworkDisconnectionReason disconnect_reason = 4;

        pub fn disconnect_reason(&self) -> super::super::network_connection::ENetworkDisconnectionReason {
            match self.disconnect_reason {
                Some(e) => e.enum_value_or(super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID),
                None => super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID,
            }
        }

        pub fn clear_disconnect_reason(&mut self) {
            self.disconnect_reason = ::std::option::Option::None;
        }

        pub fn has_disconnect_reason(&self) -> bool {
            self.disconnect_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disconnect_reason(&mut self, v: super::super::network_connection::ENetworkDisconnectionReason) {
            self.disconnect_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Player| { &m.hero_id },
                |m: &mut Player| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::dota_gcmessages_common_match_management::CMsgLeaverState>(
                "leaver_state",
                |m: &Player| { &m.leaver_state },
                |m: &mut Player| { &mut m.leaver_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "disconnect_reason",
                |m: &Player| { &m.disconnect_reason },
                |m: &mut Player| { &mut m.disconnect_reason },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgConnectedPlayers.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.leaver_state)?;
                    },
                    32 => {
                        self.disconnect_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.leaver_state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.disconnect_reason {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.leaver_state.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.disconnect_reason {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.leaver_state.clear();
            self.disconnect_reason = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                leaver_state: ::protobuf::MessageField::none(),
                disconnect_reason: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgConnectedPlayers.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgConnectedPlayers.PlayerDraft)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerDraft {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.PlayerDraft.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.PlayerDraft.team)
        pub team: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::DOTA_GC_TEAM>>,
        // @@protoc_insertion_point(field:dota.CMsgConnectedPlayers.PlayerDraft.team_slot)
        pub team_slot: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgConnectedPlayers.PlayerDraft.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerDraft {
        fn default() -> &'a PlayerDraft {
            <PlayerDraft as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerDraft {
        pub fn new() -> PlayerDraft {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional .dota.DOTA_GC_TEAM team = 2;

        pub fn team(&self) -> super::super::dota_shared_enums::DOTA_GC_TEAM {
            match self.team {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: super::super::dota_shared_enums::DOTA_GC_TEAM) {
            self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional int32 team_slot = 3;

        pub fn team_slot(&self) -> i32 {
            self.team_slot.unwrap_or(0)
        }

        pub fn clear_team_slot(&mut self) {
            self.team_slot = ::std::option::Option::None;
        }

        pub fn has_team_slot(&self) -> bool {
            self.team_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_slot(&mut self, v: i32) {
            self.team_slot = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &PlayerDraft| { &m.steam_id },
                |m: &mut PlayerDraft| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &PlayerDraft| { &m.team },
                |m: &mut PlayerDraft| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_slot",
                |m: &PlayerDraft| { &m.team_slot },
                |m: &mut PlayerDraft| { &mut m.team_slot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerDraft>(
                "CMsgConnectedPlayers.PlayerDraft",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerDraft {
        const NAME: &'static str = "PlayerDraft";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.team_slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.team_slot {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.team {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.team_slot {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerDraft {
            PlayerDraft::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.team_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerDraft {
            static instance: PlayerDraft = PlayerDraft {
                steam_id: ::std::option::Option::None,
                team: ::std::option::Option::None,
                team_slot: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerDraft {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgConnectedPlayers.PlayerDraft").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerDraft {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerDraft {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgConnectedPlayers.SendReason)
    pub enum SendReason {
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.HEARTBEAT)
        HEARTBEAT = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.GAME_STATE)
        GAME_STATE = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.FIRST_BLOOD)
        FIRST_BLOOD = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.PLAYER_CONNECTED)
        PLAYER_CONNECTED = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.PLAYER_HERO)
        PLAYER_HERO = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.PLAYER_DISCONNECTED_CONSEQUENCES)
        PLAYER_DISCONNECTED_CONSEQUENCES = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.PLAYER_DISCONNECTED_NOCONSEQUENCES)
        PLAYER_DISCONNECTED_NOCONSEQUENCES = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.GAMESTATE_TIMEOUT)
        GAMESTATE_TIMEOUT = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.MASS_DISCONNECT)
        MASS_DISCONNECT = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.KILLS)
        KILLS = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgConnectedPlayers.SendReason.BUILDING_STATE)
        BUILDING_STATE = 14,
    }

    impl ::protobuf::Enum for SendReason {
        const NAME: &'static str = "SendReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SendReason> {
            match value {
                0 => ::std::option::Option::Some(SendReason::INVALID),
                1 => ::std::option::Option::Some(SendReason::HEARTBEAT),
                2 => ::std::option::Option::Some(SendReason::GAME_STATE),
                3 => ::std::option::Option::Some(SendReason::FIRST_BLOOD),
                4 => ::std::option::Option::Some(SendReason::PLAYER_CONNECTED),
                5 => ::std::option::Option::Some(SendReason::PLAYER_HERO),
                6 => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_CONSEQUENCES),
                7 => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES),
                10 => ::std::option::Option::Some(SendReason::GAMESTATE_TIMEOUT),
                11 => ::std::option::Option::Some(SendReason::MASS_DISCONNECT),
                13 => ::std::option::Option::Some(SendReason::KILLS),
                14 => ::std::option::Option::Some(SendReason::BUILDING_STATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SendReason> {
            match str {
                "INVALID" => ::std::option::Option::Some(SendReason::INVALID),
                "HEARTBEAT" => ::std::option::Option::Some(SendReason::HEARTBEAT),
                "GAME_STATE" => ::std::option::Option::Some(SendReason::GAME_STATE),
                "FIRST_BLOOD" => ::std::option::Option::Some(SendReason::FIRST_BLOOD),
                "PLAYER_CONNECTED" => ::std::option::Option::Some(SendReason::PLAYER_CONNECTED),
                "PLAYER_HERO" => ::std::option::Option::Some(SendReason::PLAYER_HERO),
                "PLAYER_DISCONNECTED_CONSEQUENCES" => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_CONSEQUENCES),
                "PLAYER_DISCONNECTED_NOCONSEQUENCES" => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES),
                "GAMESTATE_TIMEOUT" => ::std::option::Option::Some(SendReason::GAMESTATE_TIMEOUT),
                "MASS_DISCONNECT" => ::std::option::Option::Some(SendReason::MASS_DISCONNECT),
                "KILLS" => ::std::option::Option::Some(SendReason::KILLS),
                "BUILDING_STATE" => ::std::option::Option::Some(SendReason::BUILDING_STATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SendReason] = &[
            SendReason::INVALID,
            SendReason::HEARTBEAT,
            SendReason::GAME_STATE,
            SendReason::FIRST_BLOOD,
            SendReason::PLAYER_CONNECTED,
            SendReason::PLAYER_HERO,
            SendReason::PLAYER_DISCONNECTED_CONSEQUENCES,
            SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES,
            SendReason::GAMESTATE_TIMEOUT,
            SendReason::MASS_DISCONNECT,
            SendReason::KILLS,
            SendReason::BUILDING_STATE,
        ];
    }

    impl ::protobuf::EnumFull for SendReason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgConnectedPlayers.SendReason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                SendReason::INVALID => 0,
                SendReason::HEARTBEAT => 1,
                SendReason::GAME_STATE => 2,
                SendReason::FIRST_BLOOD => 3,
                SendReason::PLAYER_CONNECTED => 4,
                SendReason::PLAYER_HERO => 5,
                SendReason::PLAYER_DISCONNECTED_CONSEQUENCES => 6,
                SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES => 7,
                SendReason::GAMESTATE_TIMEOUT => 8,
                SendReason::MASS_DISCONNECT => 9,
                SendReason::KILLS => 10,
                SendReason::BUILDING_STATE => 11,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SendReason {
        fn default() -> Self {
            SendReason::INVALID
        }
    }

    impl SendReason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SendReason>("CMsgConnectedPlayers.SendReason")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGameServerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_public_ip_addr)
    pub server_public_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_private_ip_addr)
    pub server_private_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_tv_port)
    pub server_tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.assigned_server_tv_port)
    pub assigned_server_tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.legacy_server_steamdatagram_address)
    pub legacy_server_steamdatagram_address: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_key)
    pub server_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_hibernation)
    pub server_hibernation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_type)
    pub server_type: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_game_server_info::ServerType>>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_loadavg)
    pub server_loadavg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_tv_broadcast_time)
    pub server_tv_broadcast_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_game_time)
    pub server_game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_relay_connected_steam_id)
    pub server_relay_connected_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.relay_slots_max)
    pub relay_slots_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.relays_connected)
    pub relays_connected: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.relay_clients_connected)
    pub relay_clients_connected: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.relayed_game_server_steam_id)
    pub relayed_game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.parent_relay_count)
    pub parent_relay_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.tv_secret_code)
    pub tv_secret_code: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.server_cluster)
    pub server_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.allow_custom_games)
    pub allow_custom_games: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_game_server_info::CustomGames>>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.build_version)
    pub build_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.tf_server_count)
    pub tf_server_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.srcds_instance)
    pub srcds_instance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.dev_force_server_type)
    pub dev_force_server_type: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerInfo.is_recording_match_training_data)
    pub is_recording_match_training_data: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameServerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerInfo {
    fn default() -> &'a CMsgGameServerInfo {
        <CMsgGameServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerInfo {
    pub fn new() -> CMsgGameServerInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 server_public_ip_addr = 1;

    pub fn server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_private_ip_addr = 2;

    pub fn server_private_ip_addr(&self) -> u32 {
        self.server_private_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_private_ip_addr(&mut self) {
        self.server_private_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_private_ip_addr(&self) -> bool {
        self.server_private_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_private_ip_addr(&mut self, v: u32) {
        self.server_private_ip_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 3;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 server_tv_port = 4;

    pub fn server_tv_port(&self) -> u32 {
        self.server_tv_port.unwrap_or(0)
    }

    pub fn clear_server_tv_port(&mut self) {
        self.server_tv_port = ::std::option::Option::None;
    }

    pub fn has_server_tv_port(&self) -> bool {
        self.server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_port(&mut self, v: u32) {
        self.server_tv_port = ::std::option::Option::Some(v);
    }

    // optional uint32 assigned_server_tv_port = 22;

    pub fn assigned_server_tv_port(&self) -> u32 {
        self.assigned_server_tv_port.unwrap_or(0)
    }

    pub fn clear_assigned_server_tv_port(&mut self) {
        self.assigned_server_tv_port = ::std::option::Option::None;
    }

    pub fn has_assigned_server_tv_port(&self) -> bool {
        self.assigned_server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned_server_tv_port(&mut self, v: u32) {
        self.assigned_server_tv_port = ::std::option::Option::Some(v);
    }

    // optional bytes legacy_server_steamdatagram_address = 27;

    pub fn legacy_server_steamdatagram_address(&self) -> &[u8] {
        match self.legacy_server_steamdatagram_address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_legacy_server_steamdatagram_address(&mut self) {
        self.legacy_server_steamdatagram_address = ::std::option::Option::None;
    }

    pub fn has_legacy_server_steamdatagram_address(&self) -> bool {
        self.legacy_server_steamdatagram_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_server_steamdatagram_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacy_server_steamdatagram_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_server_steamdatagram_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacy_server_steamdatagram_address.is_none() {
            self.legacy_server_steamdatagram_address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.legacy_server_steamdatagram_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_server_steamdatagram_address(&mut self) -> ::std::vec::Vec<u8> {
        self.legacy_server_steamdatagram_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string server_key = 5;

    pub fn server_key(&self) -> &str {
        match self.server_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_key(&mut self) {
        self.server_key = ::std::option::Option::None;
    }

    pub fn has_server_key(&self) -> bool {
        self.server_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_key(&mut self, v: ::std::string::String) {
        self.server_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_key(&mut self) -> &mut ::std::string::String {
        if self.server_key.is_none() {
            self.server_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_key(&mut self) -> ::std::string::String {
        self.server_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool server_hibernation = 6;

    pub fn server_hibernation(&self) -> bool {
        self.server_hibernation.unwrap_or(false)
    }

    pub fn clear_server_hibernation(&mut self) {
        self.server_hibernation = ::std::option::Option::None;
    }

    pub fn has_server_hibernation(&self) -> bool {
        self.server_hibernation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_hibernation(&mut self, v: bool) {
        self.server_hibernation = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgGameServerInfo.ServerType server_type = 7;

    pub fn server_type(&self) -> cmsg_game_server_info::ServerType {
        match self.server_type {
            Some(e) => e.enum_value_or(cmsg_game_server_info::ServerType::UNSPECIFIED),
            None => cmsg_game_server_info::ServerType::UNSPECIFIED,
        }
    }

    pub fn clear_server_type(&mut self) {
        self.server_type = ::std::option::Option::None;
    }

    pub fn has_server_type(&self) -> bool {
        self.server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type(&mut self, v: cmsg_game_server_info::ServerType) {
        self.server_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 server_region = 8;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional float server_loadavg = 9;

    pub fn server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }

    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    // optional float server_tv_broadcast_time = 10;

    pub fn server_tv_broadcast_time(&self) -> f32 {
        self.server_tv_broadcast_time.unwrap_or(0.)
    }

    pub fn clear_server_tv_broadcast_time(&mut self) {
        self.server_tv_broadcast_time = ::std::option::Option::None;
    }

    pub fn has_server_tv_broadcast_time(&self) -> bool {
        self.server_tv_broadcast_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_broadcast_time(&mut self, v: f32) {
        self.server_tv_broadcast_time = ::std::option::Option::Some(v);
    }

    // optional float server_game_time = 11;

    pub fn server_game_time(&self) -> f32 {
        self.server_game_time.unwrap_or(0.)
    }

    pub fn clear_server_game_time(&mut self) {
        self.server_game_time = ::std::option::Option::None;
    }

    pub fn has_server_game_time(&self) -> bool {
        self.server_game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_game_time(&mut self, v: f32) {
        self.server_game_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_relay_connected_steam_id = 12;

    pub fn server_relay_connected_steam_id(&self) -> u64 {
        self.server_relay_connected_steam_id.unwrap_or(0)
    }

    pub fn clear_server_relay_connected_steam_id(&mut self) {
        self.server_relay_connected_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_relay_connected_steam_id(&self) -> bool {
        self.server_relay_connected_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_relay_connected_steam_id(&mut self, v: u64) {
        self.server_relay_connected_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_slots_max = 13;

    pub fn relay_slots_max(&self) -> u32 {
        self.relay_slots_max.unwrap_or(0)
    }

    pub fn clear_relay_slots_max(&mut self) {
        self.relay_slots_max = ::std::option::Option::None;
    }

    pub fn has_relay_slots_max(&self) -> bool {
        self.relay_slots_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_slots_max(&mut self, v: u32) {
        self.relay_slots_max = ::std::option::Option::Some(v);
    }

    // optional int32 relays_connected = 14;

    pub fn relays_connected(&self) -> i32 {
        self.relays_connected.unwrap_or(0)
    }

    pub fn clear_relays_connected(&mut self) {
        self.relays_connected = ::std::option::Option::None;
    }

    pub fn has_relays_connected(&self) -> bool {
        self.relays_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relays_connected(&mut self, v: i32) {
        self.relays_connected = ::std::option::Option::Some(v);
    }

    // optional int32 relay_clients_connected = 15;

    pub fn relay_clients_connected(&self) -> i32 {
        self.relay_clients_connected.unwrap_or(0)
    }

    pub fn clear_relay_clients_connected(&mut self) {
        self.relay_clients_connected = ::std::option::Option::None;
    }

    pub fn has_relay_clients_connected(&self) -> bool {
        self.relay_clients_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_clients_connected(&mut self, v: i32) {
        self.relay_clients_connected = ::std::option::Option::Some(v);
    }

    // optional fixed64 relayed_game_server_steam_id = 16;

    pub fn relayed_game_server_steam_id(&self) -> u64 {
        self.relayed_game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_relayed_game_server_steam_id(&mut self) {
        self.relayed_game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_relayed_game_server_steam_id(&self) -> bool {
        self.relayed_game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relayed_game_server_steam_id(&mut self, v: u64) {
        self.relayed_game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_relay_count = 17;

    pub fn parent_relay_count(&self) -> u32 {
        self.parent_relay_count.unwrap_or(0)
    }

    pub fn clear_parent_relay_count(&mut self) {
        self.parent_relay_count = ::std::option::Option::None;
    }

    pub fn has_parent_relay_count(&self) -> bool {
        self.parent_relay_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_relay_count(&mut self, v: u32) {
        self.parent_relay_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 tv_secret_code = 18;

    pub fn tv_secret_code(&self) -> u64 {
        self.tv_secret_code.unwrap_or(0)
    }

    pub fn clear_tv_secret_code(&mut self) {
        self.tv_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_secret_code(&self) -> bool {
        self.tv_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_secret_code(&mut self, v: u64) {
        self.tv_secret_code = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 19;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 server_cluster = 20;

    pub fn server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgGameServerInfo.CustomGames allow_custom_games = 23;

    pub fn allow_custom_games(&self) -> cmsg_game_server_info::CustomGames {
        match self.allow_custom_games {
            Some(e) => e.enum_value_or(cmsg_game_server_info::CustomGames::BOTH),
            None => cmsg_game_server_info::CustomGames::BOTH,
        }
    }

    pub fn clear_allow_custom_games(&mut self) {
        self.allow_custom_games = ::std::option::Option::None;
    }

    pub fn has_allow_custom_games(&self) -> bool {
        self.allow_custom_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_custom_games(&mut self, v: cmsg_game_server_info::CustomGames) {
        self.allow_custom_games = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 build_version = 24;

    pub fn build_version(&self) -> u32 {
        self.build_version.unwrap_or(0)
    }

    pub fn clear_build_version(&mut self) {
        self.build_version = ::std::option::Option::None;
    }

    pub fn has_build_version(&self) -> bool {
        self.build_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_version(&mut self, v: u32) {
        self.build_version = ::std::option::Option::Some(v);
    }

    // optional uint32 tf_server_count = 25;

    pub fn tf_server_count(&self) -> u32 {
        self.tf_server_count.unwrap_or(0)
    }

    pub fn clear_tf_server_count(&mut self) {
        self.tf_server_count = ::std::option::Option::None;
    }

    pub fn has_tf_server_count(&self) -> bool {
        self.tf_server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tf_server_count(&mut self, v: u32) {
        self.tf_server_count = ::std::option::Option::Some(v);
    }

    // optional uint32 srcds_instance = 26;

    pub fn srcds_instance(&self) -> u32 {
        self.srcds_instance.unwrap_or(0)
    }

    pub fn clear_srcds_instance(&mut self) {
        self.srcds_instance = ::std::option::Option::None;
    }

    pub fn has_srcds_instance(&self) -> bool {
        self.srcds_instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcds_instance(&mut self, v: u32) {
        self.srcds_instance = ::std::option::Option::Some(v);
    }

    // optional bool dev_force_server_type = 28;

    pub fn dev_force_server_type(&self) -> bool {
        self.dev_force_server_type.unwrap_or(false)
    }

    pub fn clear_dev_force_server_type(&mut self) {
        self.dev_force_server_type = ::std::option::Option::None;
    }

    pub fn has_dev_force_server_type(&self) -> bool {
        self.dev_force_server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dev_force_server_type(&mut self, v: bool) {
        self.dev_force_server_type = ::std::option::Option::Some(v);
    }

    // optional bool is_recording_match_training_data = 29;

    pub fn is_recording_match_training_data(&self) -> bool {
        self.is_recording_match_training_data.unwrap_or(false)
    }

    pub fn clear_is_recording_match_training_data(&mut self) {
        self.is_recording_match_training_data = ::std::option::Option::None;
    }

    pub fn has_is_recording_match_training_data(&self) -> bool {
        self.is_recording_match_training_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_recording_match_training_data(&mut self, v: bool) {
        self.is_recording_match_training_data = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_public_ip_addr",
            |m: &CMsgGameServerInfo| { &m.server_public_ip_addr },
            |m: &mut CMsgGameServerInfo| { &mut m.server_public_ip_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_private_ip_addr",
            |m: &CMsgGameServerInfo| { &m.server_private_ip_addr },
            |m: &mut CMsgGameServerInfo| { &mut m.server_private_ip_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgGameServerInfo| { &m.server_port },
            |m: &mut CMsgGameServerInfo| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tv_port",
            |m: &CMsgGameServerInfo| { &m.server_tv_port },
            |m: &mut CMsgGameServerInfo| { &mut m.server_tv_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assigned_server_tv_port",
            |m: &CMsgGameServerInfo| { &m.assigned_server_tv_port },
            |m: &mut CMsgGameServerInfo| { &mut m.assigned_server_tv_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_server_steamdatagram_address",
            |m: &CMsgGameServerInfo| { &m.legacy_server_steamdatagram_address },
            |m: &mut CMsgGameServerInfo| { &mut m.legacy_server_steamdatagram_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_key",
            |m: &CMsgGameServerInfo| { &m.server_key },
            |m: &mut CMsgGameServerInfo| { &mut m.server_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_hibernation",
            |m: &CMsgGameServerInfo| { &m.server_hibernation },
            |m: &mut CMsgGameServerInfo| { &mut m.server_hibernation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_type",
            |m: &CMsgGameServerInfo| { &m.server_type },
            |m: &mut CMsgGameServerInfo| { &mut m.server_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgGameServerInfo| { &m.server_region },
            |m: &mut CMsgGameServerInfo| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_loadavg",
            |m: &CMsgGameServerInfo| { &m.server_loadavg },
            |m: &mut CMsgGameServerInfo| { &mut m.server_loadavg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tv_broadcast_time",
            |m: &CMsgGameServerInfo| { &m.server_tv_broadcast_time },
            |m: &mut CMsgGameServerInfo| { &mut m.server_tv_broadcast_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_game_time",
            |m: &CMsgGameServerInfo| { &m.server_game_time },
            |m: &mut CMsgGameServerInfo| { &mut m.server_game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_relay_connected_steam_id",
            |m: &CMsgGameServerInfo| { &m.server_relay_connected_steam_id },
            |m: &mut CMsgGameServerInfo| { &mut m.server_relay_connected_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_slots_max",
            |m: &CMsgGameServerInfo| { &m.relay_slots_max },
            |m: &mut CMsgGameServerInfo| { &mut m.relay_slots_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relays_connected",
            |m: &CMsgGameServerInfo| { &m.relays_connected },
            |m: &mut CMsgGameServerInfo| { &mut m.relays_connected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_clients_connected",
            |m: &CMsgGameServerInfo| { &m.relay_clients_connected },
            |m: &mut CMsgGameServerInfo| { &mut m.relay_clients_connected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relayed_game_server_steam_id",
            |m: &CMsgGameServerInfo| { &m.relayed_game_server_steam_id },
            |m: &mut CMsgGameServerInfo| { &mut m.relayed_game_server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_relay_count",
            |m: &CMsgGameServerInfo| { &m.parent_relay_count },
            |m: &mut CMsgGameServerInfo| { &mut m.parent_relay_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_secret_code",
            |m: &CMsgGameServerInfo| { &m.tv_secret_code },
            |m: &mut CMsgGameServerInfo| { &mut m.tv_secret_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGameServerInfo| { &m.server_version },
            |m: &mut CMsgGameServerInfo| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_cluster",
            |m: &CMsgGameServerInfo| { &m.server_cluster },
            |m: &mut CMsgGameServerInfo| { &mut m.server_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_custom_games",
            |m: &CMsgGameServerInfo| { &m.allow_custom_games },
            |m: &mut CMsgGameServerInfo| { &mut m.allow_custom_games },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_version",
            |m: &CMsgGameServerInfo| { &m.build_version },
            |m: &mut CMsgGameServerInfo| { &mut m.build_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tf_server_count",
            |m: &CMsgGameServerInfo| { &m.tf_server_count },
            |m: &mut CMsgGameServerInfo| { &mut m.tf_server_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "srcds_instance",
            |m: &CMsgGameServerInfo| { &m.srcds_instance },
            |m: &mut CMsgGameServerInfo| { &mut m.srcds_instance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dev_force_server_type",
            |m: &CMsgGameServerInfo| { &m.dev_force_server_type },
            |m: &mut CMsgGameServerInfo| { &mut m.dev_force_server_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_recording_match_training_data",
            |m: &CMsgGameServerInfo| { &m.is_recording_match_training_data },
            |m: &mut CMsgGameServerInfo| { &mut m.is_recording_match_training_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerInfo>(
            "CMsgGameServerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerInfo {
    const NAME: &'static str = "CMsgGameServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.server_public_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.server_private_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.server_tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.assigned_server_tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                218 => {
                    self.legacy_server_steamdatagram_address = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.server_key = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.server_hibernation = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.server_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.server_loadavg = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.server_tv_broadcast_time = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.server_game_time = ::std::option::Option::Some(is.read_float()?);
                },
                97 => {
                    self.server_relay_connected_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                104 => {
                    self.relay_slots_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.relays_connected = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.relay_clients_connected = ::std::option::Option::Some(is.read_int32()?);
                },
                129 => {
                    self.relayed_game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                136 => {
                    self.parent_relay_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                145 => {
                    self.tv_secret_code = ::std::option::Option::Some(is.read_fixed64()?);
                },
                152 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.server_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.allow_custom_games = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                192 => {
                    self.build_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.tf_server_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.srcds_instance = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.dev_force_server_type = ::std::option::Option::Some(is.read_bool()?);
                },
                232 => {
                    self.is_recording_match_training_data = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_public_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_private_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_tv_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.assigned_server_tv_port {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.legacy_server_steamdatagram_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(27, &v);
        }
        if let Some(v) = self.server_key.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.server_hibernation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_type {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.relay_slots_max {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.relays_connected {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.relay_clients_connected {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            my_size += 2 + 8;
        }
        if let Some(v) = self.parent_relay_count {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.tv_secret_code {
            my_size += 2 + 8;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.server_cluster {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.allow_custom_games {
            my_size += ::protobuf::rt::int32_size(23, v.value());
        }
        if let Some(v) = self.build_version {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.tf_server_count {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.srcds_instance {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.dev_force_server_type {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_recording_match_training_data {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_private_ip_addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_tv_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.assigned_server_tv_port {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.legacy_server_steamdatagram_address.as_ref() {
            os.write_bytes(27, v)?;
        }
        if let Some(v) = self.server_key.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.server_hibernation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.server_type {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_game_time {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.relay_slots_max {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.relays_connected {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.relay_clients_connected {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            os.write_fixed64(16, v)?;
        }
        if let Some(v) = self.parent_relay_count {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_secret_code {
            os.write_fixed64(18, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.allow_custom_games {
            os.write_enum(23, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.build_version {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.tf_server_count {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.srcds_instance {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.dev_force_server_type {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.is_recording_match_training_data {
            os.write_bool(29, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerInfo {
        CMsgGameServerInfo::new()
    }

    fn clear(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
        self.server_private_ip_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.server_tv_port = ::std::option::Option::None;
        self.assigned_server_tv_port = ::std::option::Option::None;
        self.legacy_server_steamdatagram_address = ::std::option::Option::None;
        self.server_key = ::std::option::Option::None;
        self.server_hibernation = ::std::option::Option::None;
        self.server_type = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.server_loadavg = ::std::option::Option::None;
        self.server_tv_broadcast_time = ::std::option::Option::None;
        self.server_game_time = ::std::option::Option::None;
        self.server_relay_connected_steam_id = ::std::option::Option::None;
        self.relay_slots_max = ::std::option::Option::None;
        self.relays_connected = ::std::option::Option::None;
        self.relay_clients_connected = ::std::option::Option::None;
        self.relayed_game_server_steam_id = ::std::option::Option::None;
        self.parent_relay_count = ::std::option::Option::None;
        self.tv_secret_code = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.server_cluster = ::std::option::Option::None;
        self.allow_custom_games = ::std::option::Option::None;
        self.build_version = ::std::option::Option::None;
        self.tf_server_count = ::std::option::Option::None;
        self.srcds_instance = ::std::option::Option::None;
        self.dev_force_server_type = ::std::option::Option::None;
        self.is_recording_match_training_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerInfo {
        static instance: CMsgGameServerInfo = CMsgGameServerInfo {
            server_public_ip_addr: ::std::option::Option::None,
            server_private_ip_addr: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            server_tv_port: ::std::option::Option::None,
            assigned_server_tv_port: ::std::option::Option::None,
            legacy_server_steamdatagram_address: ::std::option::Option::None,
            server_key: ::std::option::Option::None,
            server_hibernation: ::std::option::Option::None,
            server_type: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            server_loadavg: ::std::option::Option::None,
            server_tv_broadcast_time: ::std::option::Option::None,
            server_game_time: ::std::option::Option::None,
            server_relay_connected_steam_id: ::std::option::Option::None,
            relay_slots_max: ::std::option::Option::None,
            relays_connected: ::std::option::Option::None,
            relay_clients_connected: ::std::option::Option::None,
            relayed_game_server_steam_id: ::std::option::Option::None,
            parent_relay_count: ::std::option::Option::None,
            tv_secret_code: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            server_cluster: ::std::option::Option::None,
            allow_custom_games: ::std::option::Option::None,
            build_version: ::std::option::Option::None,
            tf_server_count: ::std::option::Option::None,
            srcds_instance: ::std::option::Option::None,
            dev_force_server_type: ::std::option::Option::None,
            is_recording_match_training_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameServerInfo`
pub mod cmsg_game_server_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgGameServerInfo.ServerType)
    pub enum ServerType {
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.ServerType.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.ServerType.GAME)
        GAME = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.ServerType.PROXY)
        PROXY = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.ServerType.TENSORFLOW)
        TENSORFLOW = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.ServerType.DOTA_ONLY)
        DOTA_ONLY = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.ServerType.CUSTOM_GAME_ONLY)
        CUSTOM_GAME_ONLY = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.ServerType.EVENT_GAME_ONLY)
        EVENT_GAME_ONLY = 6,
    }

    impl ::protobuf::Enum for ServerType {
        const NAME: &'static str = "ServerType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ServerType> {
            match value {
                0 => ::std::option::Option::Some(ServerType::UNSPECIFIED),
                1 => ::std::option::Option::Some(ServerType::GAME),
                2 => ::std::option::Option::Some(ServerType::PROXY),
                3 => ::std::option::Option::Some(ServerType::TENSORFLOW),
                4 => ::std::option::Option::Some(ServerType::DOTA_ONLY),
                5 => ::std::option::Option::Some(ServerType::CUSTOM_GAME_ONLY),
                6 => ::std::option::Option::Some(ServerType::EVENT_GAME_ONLY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ServerType> {
            match str {
                "UNSPECIFIED" => ::std::option::Option::Some(ServerType::UNSPECIFIED),
                "GAME" => ::std::option::Option::Some(ServerType::GAME),
                "PROXY" => ::std::option::Option::Some(ServerType::PROXY),
                "TENSORFLOW" => ::std::option::Option::Some(ServerType::TENSORFLOW),
                "DOTA_ONLY" => ::std::option::Option::Some(ServerType::DOTA_ONLY),
                "CUSTOM_GAME_ONLY" => ::std::option::Option::Some(ServerType::CUSTOM_GAME_ONLY),
                "EVENT_GAME_ONLY" => ::std::option::Option::Some(ServerType::EVENT_GAME_ONLY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ServerType] = &[
            ServerType::UNSPECIFIED,
            ServerType::GAME,
            ServerType::PROXY,
            ServerType::TENSORFLOW,
            ServerType::DOTA_ONLY,
            ServerType::CUSTOM_GAME_ONLY,
            ServerType::EVENT_GAME_ONLY,
        ];
    }

    impl ::protobuf::EnumFull for ServerType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGameServerInfo.ServerType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ServerType {
        fn default() -> Self {
            ServerType::UNSPECIFIED
        }
    }

    impl ServerType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ServerType>("CMsgGameServerInfo.ServerType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgGameServerInfo.CustomGames)
    pub enum CustomGames {
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.CustomGames.BOTH)
        BOTH = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.CustomGames.NONE)
        NONE = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.CustomGames.ONLY)
        ONLY = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerInfo.CustomGames.EVENT)
        EVENT = 3,
    }

    impl ::protobuf::Enum for CustomGames {
        const NAME: &'static str = "CustomGames";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CustomGames> {
            match value {
                0 => ::std::option::Option::Some(CustomGames::BOTH),
                1 => ::std::option::Option::Some(CustomGames::NONE),
                2 => ::std::option::Option::Some(CustomGames::ONLY),
                3 => ::std::option::Option::Some(CustomGames::EVENT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<CustomGames> {
            match str {
                "BOTH" => ::std::option::Option::Some(CustomGames::BOTH),
                "NONE" => ::std::option::Option::Some(CustomGames::NONE),
                "ONLY" => ::std::option::Option::Some(CustomGames::ONLY),
                "EVENT" => ::std::option::Option::Some(CustomGames::EVENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CustomGames] = &[
            CustomGames::BOTH,
            CustomGames::NONE,
            CustomGames::ONLY,
            CustomGames::EVENT,
        ];
    }

    impl ::protobuf::EnumFull for CustomGames {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGameServerInfo.CustomGames").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CustomGames {
        fn default() -> Self {
            CustomGames::BOTH
        }
    }

    impl CustomGames {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CustomGames>("CMsgGameServerInfo.CustomGames")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgLeaverDetected)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaverDetected {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLeaverDetected.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgLeaverDetected.leaver_status)
    pub leaver_status: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALeaverStatus_t>>,
    // @@protoc_insertion_point(field:dota.CMsgLeaverDetected.leaver_state)
    pub leaver_state: ::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMsgLeaverState>,
    // @@protoc_insertion_point(field:dota.CMsgLeaverDetected.server_cluster)
    pub server_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLeaverDetected.disconnect_reason)
    pub disconnect_reason: ::std::option::Option<::protobuf::EnumOrUnknown<super::network_connection::ENetworkDisconnectionReason>>,
    // @@protoc_insertion_point(field:dota.CMsgLeaverDetected.poor_network_conditions)
    pub poor_network_conditions: ::protobuf::MessageField<CMsgPoorNetworkConditions>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLeaverDetected.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaverDetected {
    fn default() -> &'a CMsgLeaverDetected {
        <CMsgLeaverDetected as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaverDetected {
    pub fn new() -> CMsgLeaverDetected {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTALeaverStatus_t leaver_status = 2;

    pub fn leaver_status(&self) -> super::dota_shared_enums::DOTALeaverStatus_t {
        match self.leaver_status {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            None => super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE,
        }
    }

    pub fn clear_leaver_status(&mut self) {
        self.leaver_status = ::std::option::Option::None;
    }

    pub fn has_leaver_status(&self) -> bool {
        self.leaver_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_status(&mut self, v: super::dota_shared_enums::DOTALeaverStatus_t) {
        self.leaver_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 server_cluster = 5;

    pub fn server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    // optional .dota.ENetworkDisconnectionReason disconnect_reason = 6;

    pub fn disconnect_reason(&self) -> super::network_connection::ENetworkDisconnectionReason {
        match self.disconnect_reason {
            Some(e) => e.enum_value_or(super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID),
            None => super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID,
        }
    }

    pub fn clear_disconnect_reason(&mut self) {
        self.disconnect_reason = ::std::option::Option::None;
    }

    pub fn has_disconnect_reason(&self) -> bool {
        self.disconnect_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disconnect_reason(&mut self, v: super::network_connection::ENetworkDisconnectionReason) {
        self.disconnect_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgLeaverDetected| { &m.steam_id },
            |m: &mut CMsgLeaverDetected| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaver_status",
            |m: &CMsgLeaverDetected| { &m.leaver_status },
            |m: &mut CMsgLeaverDetected| { &mut m.leaver_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common_match_management::CMsgLeaverState>(
            "leaver_state",
            |m: &CMsgLeaverDetected| { &m.leaver_state },
            |m: &mut CMsgLeaverDetected| { &mut m.leaver_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_cluster",
            |m: &CMsgLeaverDetected| { &m.server_cluster },
            |m: &mut CMsgLeaverDetected| { &mut m.server_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disconnect_reason",
            |m: &CMsgLeaverDetected| { &m.disconnect_reason },
            |m: &mut CMsgLeaverDetected| { &mut m.disconnect_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoorNetworkConditions>(
            "poor_network_conditions",
            |m: &CMsgLeaverDetected| { &m.poor_network_conditions },
            |m: &mut CMsgLeaverDetected| { &mut m.poor_network_conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLeaverDetected>(
            "CMsgLeaverDetected",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLeaverDetected {
    const NAME: &'static str = "CMsgLeaverDetected";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.leaver_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leaver_state)?;
                },
                40 => {
                    self.server_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.disconnect_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.poor_network_conditions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.leaver_status {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.leaver_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_cluster {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.disconnect_reason {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.leaver_status {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.leaver_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.disconnect_reason {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaverDetected {
        CMsgLeaverDetected::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.leaver_status = ::std::option::Option::None;
        self.leaver_state.clear();
        self.server_cluster = ::std::option::Option::None;
        self.disconnect_reason = ::std::option::Option::None;
        self.poor_network_conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaverDetected {
        static instance: CMsgLeaverDetected = CMsgLeaverDetected {
            steam_id: ::std::option::Option::None,
            leaver_status: ::std::option::Option::None,
            leaver_state: ::protobuf::MessageField::none(),
            server_cluster: ::std::option::Option::None,
            disconnect_reason: ::std::option::Option::None,
            poor_network_conditions: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLeaverDetected {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLeaverDetected").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLeaverDetected {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaverDetected {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLeaverDetectedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaverDetectedResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLeaverDetectedResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLeaverDetectedResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaverDetectedResponse {
    fn default() -> &'a CMsgLeaverDetectedResponse {
        <CMsgLeaverDetectedResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaverDetectedResponse {
    pub fn new() -> CMsgLeaverDetectedResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgLeaverDetectedResponse| { &m.result },
            |m: &mut CMsgLeaverDetectedResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLeaverDetectedResponse>(
            "CMsgLeaverDetectedResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLeaverDetectedResponse {
    const NAME: &'static str = "CMsgLeaverDetectedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaverDetectedResponse {
        CMsgLeaverDetectedResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaverDetectedResponse {
        static instance: CMsgLeaverDetectedResponse = CMsgLeaverDetectedResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLeaverDetectedResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLeaverDetectedResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLeaverDetectedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaverDetectedResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAFantasyFinalPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyFinalPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyFinalPlayerStats.stats)
    pub stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyFinalPlayerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyFinalPlayerStats {
    fn default() -> &'a CMsgDOTAFantasyFinalPlayerStats {
        <CMsgDOTAFantasyFinalPlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyFinalPlayerStats {
    pub fn new() -> CMsgDOTAFantasyFinalPlayerStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMsgDOTAFantasyFinalPlayerStats| { &m.stats },
            |m: &mut CMsgDOTAFantasyFinalPlayerStats| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAFantasyFinalPlayerStats>(
            "CMsgDOTAFantasyFinalPlayerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyFinalPlayerStats {
    const NAME: &'static str = "CMsgDOTAFantasyFinalPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyFinalPlayerStats {
        CMsgDOTAFantasyFinalPlayerStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyFinalPlayerStats {
        static instance: CMsgDOTAFantasyFinalPlayerStats = CMsgDOTAFantasyFinalPlayerStats {
            stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAFantasyFinalPlayerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyFinalPlayerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAFantasyFinalPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyFinalPlayerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAFantasyLivePlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyLivePlayerStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyLivePlayerStats.stats)
    pub stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyLivePlayerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyLivePlayerStats {
    fn default() -> &'a CMsgDOTAFantasyLivePlayerStats {
        <CMsgDOTAFantasyLivePlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyLivePlayerStats {
    pub fn new() -> CMsgDOTAFantasyLivePlayerStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMsgDOTAFantasyLivePlayerStats| { &m.stats },
            |m: &mut CMsgDOTAFantasyLivePlayerStats| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAFantasyLivePlayerStats>(
            "CMsgDOTAFantasyLivePlayerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLivePlayerStats {
    const NAME: &'static str = "CMsgDOTAFantasyLivePlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyLivePlayerStats {
        CMsgDOTAFantasyLivePlayerStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyLivePlayerStats {
        static instance: CMsgDOTAFantasyLivePlayerStats = CMsgDOTAFantasyLivePlayerStats {
            stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAFantasyLivePlayerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyLivePlayerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAFantasyLivePlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLivePlayerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRealtimeStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRealtimeStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRealtimeStats.delayed)
    pub delayed: ::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRealtimeStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRealtimeStats {
    fn default() -> &'a CMsgServerToGCRealtimeStats {
        <CMsgServerToGCRealtimeStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRealtimeStats {
    pub fn new() -> CMsgServerToGCRealtimeStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse>(
            "delayed",
            |m: &CMsgServerToGCRealtimeStats| { &m.delayed },
            |m: &mut CMsgServerToGCRealtimeStats| { &mut m.delayed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRealtimeStats>(
            "CMsgServerToGCRealtimeStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRealtimeStats {
    const NAME: &'static str = "CMsgServerToGCRealtimeStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.delayed)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delayed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.delayed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRealtimeStats {
        CMsgServerToGCRealtimeStats::new()
    }

    fn clear(&mut self) {
        self.delayed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRealtimeStats {
        static instance: CMsgServerToGCRealtimeStats = CMsgServerToGCRealtimeStats {
            delayed: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRealtimeStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRealtimeStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRealtimeStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRealtimeStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerRealtimeStatsStartStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerRealtimeStatsStartStop {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerRealtimeStatsStartStop.delayed)
    pub delayed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerRealtimeStatsStartStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerRealtimeStatsStartStop {
    fn default() -> &'a CMsgGCToServerRealtimeStatsStartStop {
        <CMsgGCToServerRealtimeStatsStartStop as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerRealtimeStatsStartStop {
    pub fn new() -> CMsgGCToServerRealtimeStatsStartStop {
        ::std::default::Default::default()
    }

    // optional bool delayed = 1;

    pub fn delayed(&self) -> bool {
        self.delayed.unwrap_or(false)
    }

    pub fn clear_delayed(&mut self) {
        self.delayed = ::std::option::Option::None;
    }

    pub fn has_delayed(&self) -> bool {
        self.delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delayed(&mut self, v: bool) {
        self.delayed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delayed",
            |m: &CMsgGCToServerRealtimeStatsStartStop| { &m.delayed },
            |m: &mut CMsgGCToServerRealtimeStatsStartStop| { &mut m.delayed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerRealtimeStatsStartStop>(
            "CMsgGCToServerRealtimeStatsStartStop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerRealtimeStatsStartStop {
    const NAME: &'static str = "CMsgGCToServerRealtimeStatsStartStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.delayed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delayed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.delayed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerRealtimeStatsStartStop {
        CMsgGCToServerRealtimeStatsStartStop::new()
    }

    fn clear(&mut self) {
        self.delayed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerRealtimeStatsStartStop {
        static instance: CMsgGCToServerRealtimeStatsStartStop = CMsgGCToServerRealtimeStatsStartStop {
            delayed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerRealtimeStatsStartStop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerRealtimeStatsStartStop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerRealtimeStatsStartStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerRealtimeStatsStartStop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerUpdateSteamBroadcasting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerUpdateSteamBroadcasting {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerUpdateSteamBroadcasting.active)
    pub active: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerUpdateSteamBroadcasting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerUpdateSteamBroadcasting {
    fn default() -> &'a CMsgGCToServerUpdateSteamBroadcasting {
        <CMsgGCToServerUpdateSteamBroadcasting as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerUpdateSteamBroadcasting {
    pub fn new() -> CMsgGCToServerUpdateSteamBroadcasting {
        ::std::default::Default::default()
    }

    // optional bool active = 1;

    pub fn active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active",
            |m: &CMsgGCToServerUpdateSteamBroadcasting| { &m.active },
            |m: &mut CMsgGCToServerUpdateSteamBroadcasting| { &mut m.active },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerUpdateSteamBroadcasting>(
            "CMsgGCToServerUpdateSteamBroadcasting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerUpdateSteamBroadcasting {
    const NAME: &'static str = "CMsgGCToServerUpdateSteamBroadcasting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.active = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.active {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.active {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerUpdateSteamBroadcasting {
        CMsgGCToServerUpdateSteamBroadcasting::new()
    }

    fn clear(&mut self) {
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerUpdateSteamBroadcasting {
        static instance: CMsgGCToServerUpdateSteamBroadcasting = CMsgGCToServerUpdateSteamBroadcasting {
            active: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerUpdateSteamBroadcasting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerUpdateSteamBroadcasting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerUpdateSteamBroadcasting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerUpdateSteamBroadcasting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSignOutGameplayStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutGameplayStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.teams)
    pub teams: ::std::vec::Vec<cmsg_sign_out_gameplay_stats::CTeam>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutGameplayStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutGameplayStats {
    fn default() -> &'a CMsgSignOutGameplayStats {
        <CMsgSignOutGameplayStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutGameplayStats {
    pub fn new() -> CMsgSignOutGameplayStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CMsgSignOutGameplayStats| { &m.teams },
            |m: &mut CMsgSignOutGameplayStats| { &mut m.teams },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutGameplayStats>(
            "CMsgSignOutGameplayStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutGameplayStats {
    const NAME: &'static str = "CMsgSignOutGameplayStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.teams.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutGameplayStats {
        CMsgSignOutGameplayStats::new()
    }

    fn clear(&mut self) {
        self.teams.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutGameplayStats {
        static instance: CMsgSignOutGameplayStats = CMsgSignOutGameplayStats {
            teams: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutGameplayStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutGameplayStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutGameplayStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutGameplayStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutGameplayStats`
pub mod cmsg_sign_out_gameplay_stats {
    // @@protoc_insertion_point(message:dota.CMsgSignOutGameplayStats.CPlayer)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CPlayer {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CPlayer.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CPlayer.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CPlayer.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CPlayer.timed_player_stats)
        pub timed_player_stats: ::std::vec::Vec<super::super::dota_gcmessages_common::CMatchPlayerTimedStats>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutGameplayStats.CPlayer.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CPlayer {
        fn default() -> &'a CPlayer {
            <CPlayer as ::protobuf::Message>::default_instance()
        }
    }

    impl CPlayer {
        pub fn new() -> CPlayer {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 2;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 3;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &CPlayer| { &m.steam_id },
                |m: &mut CPlayer| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_slot",
                |m: &CPlayer| { &m.player_slot },
                |m: &mut CPlayer| { &mut m.player_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &CPlayer| { &m.hero_id },
                |m: &mut CPlayer| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "timed_player_stats",
                |m: &CPlayer| { &m.timed_player_stats },
                |m: &mut CPlayer| { &mut m.timed_player_stats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPlayer>(
                "CMsgSignOutGameplayStats.CPlayer",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CPlayer {
        const NAME: &'static str = "CPlayer";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.timed_player_stats.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.player_slot {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.timed_player_stats {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.player_slot {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(3, v)?;
            }
            for v in &self.timed_player_stats {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CPlayer {
            CPlayer::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.player_slot = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.timed_player_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CPlayer {
            static instance: CPlayer = CPlayer {
                steam_id: ::std::option::Option::None,
                player_slot: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                timed_player_stats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CPlayer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutGameplayStats.CPlayer").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CPlayer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CPlayer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgSignOutGameplayStats.CTeam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CTeam {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CTeam.is_winning_team)
        pub is_winning_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CTeam.is_radiant_team)
        pub is_radiant_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CTeam.timed_team_stats)
        pub timed_team_stats: ::std::vec::Vec<super::super::dota_gcmessages_common::CMatchTeamTimedStats>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGameplayStats.CTeam.players)
        pub players: ::std::vec::Vec<CPlayer>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutGameplayStats.CTeam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CTeam {
        fn default() -> &'a CTeam {
            <CTeam as ::protobuf::Message>::default_instance()
        }
    }

    impl CTeam {
        pub fn new() -> CTeam {
            ::std::default::Default::default()
        }

        // optional bool is_winning_team = 1;

        pub fn is_winning_team(&self) -> bool {
            self.is_winning_team.unwrap_or(false)
        }

        pub fn clear_is_winning_team(&mut self) {
            self.is_winning_team = ::std::option::Option::None;
        }

        pub fn has_is_winning_team(&self) -> bool {
            self.is_winning_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_winning_team(&mut self, v: bool) {
            self.is_winning_team = ::std::option::Option::Some(v);
        }

        // optional bool is_radiant_team = 2;

        pub fn is_radiant_team(&self) -> bool {
            self.is_radiant_team.unwrap_or(false)
        }

        pub fn clear_is_radiant_team(&mut self) {
            self.is_radiant_team = ::std::option::Option::None;
        }

        pub fn has_is_radiant_team(&self) -> bool {
            self.is_radiant_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_radiant_team(&mut self, v: bool) {
            self.is_radiant_team = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_winning_team",
                |m: &CTeam| { &m.is_winning_team },
                |m: &mut CTeam| { &mut m.is_winning_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_radiant_team",
                |m: &CTeam| { &m.is_radiant_team },
                |m: &mut CTeam| { &mut m.is_radiant_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "timed_team_stats",
                |m: &CTeam| { &m.timed_team_stats },
                |m: &mut CTeam| { &mut m.timed_team_stats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "players",
                |m: &CTeam| { &m.players },
                |m: &mut CTeam| { &mut m.players },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTeam>(
                "CMsgSignOutGameplayStats.CTeam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CTeam {
        const NAME: &'static str = "CTeam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.is_winning_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.is_radiant_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.timed_team_stats.push(is.read_message()?);
                    },
                    34 => {
                        self.players.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.is_winning_team {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_radiant_team {
                my_size += 1 + 1;
            }
            for value in &self.timed_team_stats {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.is_winning_team {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.is_radiant_team {
                os.write_bool(2, v)?;
            }
            for v in &self.timed_team_stats {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.players {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CTeam {
            CTeam::new()
        }

        fn clear(&mut self) {
            self.is_winning_team = ::std::option::Option::None;
            self.is_radiant_team = ::std::option::Option::None;
            self.timed_team_stats.clear();
            self.players.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CTeam {
            static instance: CTeam = CTeam {
                is_winning_team: ::std::option::Option::None,
                is_radiant_team: ::std::option::Option::None,
                timed_team_stats: ::std::vec::Vec::new(),
                players: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CTeam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutGameplayStats.CTeam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CTeam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CTeam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOut {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.good_guys_win)
    pub good_guys_win: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.date)
    pub date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.teams)
    pub teams: ::std::vec::Vec<cmsg_game_match_sign_out::CTeam>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.tower_status)
    pub tower_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.barracks_status)
    pub barracks_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.cluster)
    pub cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.server_addr)
    pub server_addr: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.first_blood_time)
    pub first_blood_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.event_score)
    pub event_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.picks_bans)
    pub picks_bans: ::std::vec::Vec<super::dota_gcmessages_common::CMatchHeroSelectEvent>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.fantasy_stats)
    pub fantasy_stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.player_strange_count_adjustments)
    pub player_strange_count_adjustments: ::std::vec::Vec<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.automatic_surrender)
    pub automatic_surrender: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.poor_network_conditions)
    pub poor_network_conditions: ::protobuf::MessageField<CMsgPoorNetworkConditions>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.additional_msgs)
    pub additional_msgs: ::std::vec::Vec<cmsg_game_match_sign_out::CAdditionalSignoutMsg>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.social_feed_events)
    pub social_feed_events: ::std::vec::Vec<cmsg_game_match_sign_out::CSocialFeedMatchEvent>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.average_networth_delta)
    pub average_networth_delta: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.custom_game_data)
    pub custom_game_data: ::protobuf::MessageField<cmsg_game_match_sign_out::CCustomGameData>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.match_flags)
    pub match_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.team_scores)
    pub team_scores: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.pre_game_duration)
    pub pre_game_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.event_game_leaderboard_entries)
    pub event_game_leaderboard_entries: ::std::vec::Vec<cmsg_game_match_sign_out::EventGameLeaderboardEntry>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.ward_placements)
    pub ward_placements: ::std::vec::Vec<cmsg_game_match_sign_out::WardPlacement>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.gameplay_stats)
    pub gameplay_stats: ::protobuf::MessageField<CMsgSignOutGameplayStats>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.extra_messages)
    pub extra_messages: ::std::vec::Vec<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.training_data_recorded)
    pub training_data_recorded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.winning_team)
    pub winning_team: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.normalized_win_probability_diff)
    pub normalized_win_probability_diff: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOut {
    fn default() -> &'a CMsgGameMatchSignOut {
        <CMsgGameMatchSignOut as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOut {
    pub fn new() -> CMsgGameMatchSignOut {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 2;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool good_guys_win = 3;

    pub fn good_guys_win(&self) -> bool {
        self.good_guys_win.unwrap_or(false)
    }

    pub fn clear_good_guys_win(&mut self) {
        self.good_guys_win = ::std::option::Option::None;
    }

    pub fn has_good_guys_win(&self) -> bool {
        self.good_guys_win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good_guys_win(&mut self, v: bool) {
        self.good_guys_win = ::std::option::Option::Some(v);
    }

    // optional fixed32 date = 4;

    pub fn date(&self) -> u32 {
        self.date.unwrap_or(0)
    }

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u32) {
        self.date = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster = 10;

    pub fn cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    // optional string server_addr = 11;

    pub fn server_addr(&self) -> &str {
        match self.server_addr.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_addr(&mut self) {
        self.server_addr = ::std::option::Option::None;
    }

    pub fn has_server_addr(&self) -> bool {
        self.server_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_addr(&mut self, v: ::std::string::String) {
        self.server_addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_addr(&mut self) -> &mut ::std::string::String {
        if self.server_addr.is_none() {
            self.server_addr = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_addr(&mut self) -> ::std::string::String {
        self.server_addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 first_blood_time = 12;

    pub fn first_blood_time(&self) -> u32 {
        self.first_blood_time.unwrap_or(0)
    }

    pub fn clear_first_blood_time(&mut self) {
        self.first_blood_time = ::std::option::Option::None;
    }

    pub fn has_first_blood_time(&self) -> bool {
        self.first_blood_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_time(&mut self, v: u32) {
        self.first_blood_time = ::std::option::Option::Some(v);
    }

    // optional uint32 event_score = 14;

    pub fn event_score(&self) -> u32 {
        self.event_score.unwrap_or(0)
    }

    pub fn clear_event_score(&mut self) {
        self.event_score = ::std::option::Option::None;
    }

    pub fn has_event_score(&self) -> bool {
        self.event_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_score(&mut self, v: u32) {
        self.event_score = ::std::option::Option::Some(v);
    }

    // optional bool automatic_surrender = 18;

    pub fn automatic_surrender(&self) -> bool {
        self.automatic_surrender.unwrap_or(false)
    }

    pub fn clear_automatic_surrender(&mut self) {
        self.automatic_surrender = ::std::option::Option::None;
    }

    pub fn has_automatic_surrender(&self) -> bool {
        self.automatic_surrender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automatic_surrender(&mut self, v: bool) {
        self.automatic_surrender = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 19;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional sint32 average_networth_delta = 22;

    pub fn average_networth_delta(&self) -> i32 {
        self.average_networth_delta.unwrap_or(0)
    }

    pub fn clear_average_networth_delta(&mut self) {
        self.average_networth_delta = ::std::option::Option::None;
    }

    pub fn has_average_networth_delta(&self) -> bool {
        self.average_networth_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_networth_delta(&mut self, v: i32) {
        self.average_networth_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 match_flags = 38;

    pub fn match_flags(&self) -> u32 {
        self.match_flags.unwrap_or(0)
    }

    pub fn clear_match_flags(&mut self) {
        self.match_flags = ::std::option::Option::None;
    }

    pub fn has_match_flags(&self) -> bool {
        self.match_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_flags(&mut self, v: u32) {
        self.match_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 pre_game_duration = 40;

    pub fn pre_game_duration(&self) -> u32 {
        self.pre_game_duration.unwrap_or(0)
    }

    pub fn clear_pre_game_duration(&mut self) {
        self.pre_game_duration = ::std::option::Option::None;
    }

    pub fn has_pre_game_duration(&self) -> bool {
        self.pre_game_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_game_duration(&mut self, v: u32) {
        self.pre_game_duration = ::std::option::Option::Some(v);
    }

    // optional bool training_data_recorded = 55;

    pub fn training_data_recorded(&self) -> bool {
        self.training_data_recorded.unwrap_or(false)
    }

    pub fn clear_training_data_recorded(&mut self) {
        self.training_data_recorded = ::std::option::Option::None;
    }

    pub fn has_training_data_recorded(&self) -> bool {
        self.training_data_recorded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_training_data_recorded(&mut self, v: bool) {
        self.training_data_recorded = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GC_TEAM winning_team = 56;

    pub fn winning_team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.winning_team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.winning_team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional float normalized_win_probability_diff = 57;

    pub fn normalized_win_probability_diff(&self) -> f32 {
        self.normalized_win_probability_diff.unwrap_or(0.)
    }

    pub fn clear_normalized_win_probability_diff(&mut self) {
        self.normalized_win_probability_diff = ::std::option::Option::None;
    }

    pub fn has_normalized_win_probability_diff(&self) -> bool {
        self.normalized_win_probability_diff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_win_probability_diff(&mut self, v: f32) {
        self.normalized_win_probability_diff = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(31);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGameMatchSignOut| { &m.match_id },
            |m: &mut CMsgGameMatchSignOut| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgGameMatchSignOut| { &m.duration },
            |m: &mut CMsgGameMatchSignOut| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "good_guys_win",
            |m: &CMsgGameMatchSignOut| { &m.good_guys_win },
            |m: &mut CMsgGameMatchSignOut| { &mut m.good_guys_win },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date",
            |m: &CMsgGameMatchSignOut| { &m.date },
            |m: &mut CMsgGameMatchSignOut| { &mut m.date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CMsgGameMatchSignOut| { &m.teams },
            |m: &mut CMsgGameMatchSignOut| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tower_status",
            |m: &CMsgGameMatchSignOut| { &m.tower_status },
            |m: &mut CMsgGameMatchSignOut| { &mut m.tower_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "barracks_status",
            |m: &CMsgGameMatchSignOut| { &m.barracks_status },
            |m: &mut CMsgGameMatchSignOut| { &mut m.barracks_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cluster",
            |m: &CMsgGameMatchSignOut| { &m.cluster },
            |m: &mut CMsgGameMatchSignOut| { &mut m.cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_addr",
            |m: &CMsgGameMatchSignOut| { &m.server_addr },
            |m: &mut CMsgGameMatchSignOut| { &mut m.server_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_blood_time",
            |m: &CMsgGameMatchSignOut| { &m.first_blood_time },
            |m: &mut CMsgGameMatchSignOut| { &mut m.first_blood_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_score",
            |m: &CMsgGameMatchSignOut| { &m.event_score },
            |m: &mut CMsgGameMatchSignOut| { &mut m.event_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "picks_bans",
            |m: &CMsgGameMatchSignOut| { &m.picks_bans },
            |m: &mut CMsgGameMatchSignOut| { &mut m.picks_bans },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fantasy_stats",
            |m: &CMsgGameMatchSignOut| { &m.fantasy_stats },
            |m: &mut CMsgGameMatchSignOut| { &mut m.fantasy_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_strange_count_adjustments",
            |m: &CMsgGameMatchSignOut| { &m.player_strange_count_adjustments },
            |m: &mut CMsgGameMatchSignOut| { &mut m.player_strange_count_adjustments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "automatic_surrender",
            |m: &CMsgGameMatchSignOut| { &m.automatic_surrender },
            |m: &mut CMsgGameMatchSignOut| { &mut m.automatic_surrender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGameMatchSignOut| { &m.server_version },
            |m: &mut CMsgGameMatchSignOut| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoorNetworkConditions>(
            "poor_network_conditions",
            |m: &CMsgGameMatchSignOut| { &m.poor_network_conditions },
            |m: &mut CMsgGameMatchSignOut| { &mut m.poor_network_conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_msgs",
            |m: &CMsgGameMatchSignOut| { &m.additional_msgs },
            |m: &mut CMsgGameMatchSignOut| { &mut m.additional_msgs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "social_feed_events",
            |m: &CMsgGameMatchSignOut| { &m.social_feed_events },
            |m: &mut CMsgGameMatchSignOut| { &mut m.social_feed_events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_networth_delta",
            |m: &CMsgGameMatchSignOut| { &m.average_networth_delta },
            |m: &mut CMsgGameMatchSignOut| { &mut m.average_networth_delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_game_match_sign_out::CCustomGameData>(
            "custom_game_data",
            |m: &CMsgGameMatchSignOut| { &m.custom_game_data },
            |m: &mut CMsgGameMatchSignOut| { &mut m.custom_game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_flags",
            |m: &CMsgGameMatchSignOut| { &m.match_flags },
            |m: &mut CMsgGameMatchSignOut| { &mut m.match_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_scores",
            |m: &CMsgGameMatchSignOut| { &m.team_scores },
            |m: &mut CMsgGameMatchSignOut| { &mut m.team_scores },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pre_game_duration",
            |m: &CMsgGameMatchSignOut| { &m.pre_game_duration },
            |m: &mut CMsgGameMatchSignOut| { &mut m.pre_game_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_game_leaderboard_entries",
            |m: &CMsgGameMatchSignOut| { &m.event_game_leaderboard_entries },
            |m: &mut CMsgGameMatchSignOut| { &mut m.event_game_leaderboard_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ward_placements",
            |m: &CMsgGameMatchSignOut| { &m.ward_placements },
            |m: &mut CMsgGameMatchSignOut| { &mut m.ward_placements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSignOutGameplayStats>(
            "gameplay_stats",
            |m: &CMsgGameMatchSignOut| { &m.gameplay_stats },
            |m: &mut CMsgGameMatchSignOut| { &mut m.gameplay_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extra_messages",
            |m: &CMsgGameMatchSignOut| { &m.extra_messages },
            |m: &mut CMsgGameMatchSignOut| { &mut m.extra_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "training_data_recorded",
            |m: &CMsgGameMatchSignOut| { &m.training_data_recorded },
            |m: &mut CMsgGameMatchSignOut| { &mut m.training_data_recorded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "winning_team",
            |m: &CMsgGameMatchSignOut| { &m.winning_team },
            |m: &mut CMsgGameMatchSignOut| { &mut m.winning_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "normalized_win_probability_diff",
            |m: &CMsgGameMatchSignOut| { &m.normalized_win_probability_diff },
            |m: &mut CMsgGameMatchSignOut| { &mut m.normalized_win_probability_diff },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameMatchSignOut>(
            "CMsgGameMatchSignOut",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut {
    const NAME: &'static str = "CMsgGameMatchSignOut";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.good_guys_win = ::std::option::Option::Some(is.read_bool()?);
                },
                37 => {
                    self.date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                50 => {
                    self.teams.push(is.read_message()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.tower_status)?;
                },
                64 => {
                    self.tower_status.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.barracks_status)?;
                },
                72 => {
                    self.barracks_status.push(is.read_uint32()?);
                },
                80 => {
                    self.cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.server_addr = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.first_blood_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.event_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.picks_bans.push(is.read_message()?);
                },
                330 => {
                    self.fantasy_stats.push(is.read_message()?);
                },
                138 => {
                    self.player_strange_count_adjustments.push(is.read_message()?);
                },
                144 => {
                    self.automatic_surrender = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                282 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.poor_network_conditions)?;
                },
                162 => {
                    self.additional_msgs.push(is.read_message()?);
                },
                290 => {
                    self.social_feed_events.push(is.read_message()?);
                },
                176 => {
                    self.average_networth_delta = ::std::option::Option::Some(is.read_sint32()?);
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                },
                304 => {
                    self.match_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                314 => {
                    is.read_repeated_packed_uint32_into(&mut self.team_scores)?;
                },
                312 => {
                    self.team_scores.push(is.read_uint32()?);
                },
                320 => {
                    self.pre_game_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                338 => {
                    self.event_game_leaderboard_entries.push(is.read_message()?);
                },
                346 => {
                    self.ward_placements.push(is.read_message()?);
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gameplay_stats)?;
                },
                434 => {
                    self.extra_messages.push(is.read_message()?);
                },
                440 => {
                    self.training_data_recorded = ::std::option::Option::Some(is.read_bool()?);
                },
                448 => {
                    self.winning_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                461 => {
                    self.normalized_win_probability_diff = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.good_guys_win {
            my_size += 1 + 1;
        }
        if let Some(v) = self.date {
            my_size += 1 + 4;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tower_status {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.barracks_status {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.cluster {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.server_addr.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.first_blood_time {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.event_score {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fantasy_stats {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.player_strange_count_adjustments {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.automatic_surrender {
            my_size += 2 + 1;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_msgs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.social_feed_events {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.average_networth_delta {
            my_size += ::protobuf::rt::sint32_size(22, v);
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_flags {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        for value in &self.team_scores {
            my_size += ::protobuf::rt::uint32_size(39, *value);
        };
        if let Some(v) = self.pre_game_duration {
            my_size += ::protobuf::rt::uint32_size(40, v);
        }
        for value in &self.event_game_leaderboard_entries {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ward_placements {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gameplay_stats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.extra_messages {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.training_data_recorded {
            my_size += 2 + 1;
        }
        if let Some(v) = self.winning_team {
            my_size += ::protobuf::rt::int32_size(56, v.value());
        }
        if let Some(v) = self.normalized_win_probability_diff {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.good_guys_win {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.date {
            os.write_fixed32(4, v)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.tower_status {
            os.write_uint32(8, *v)?;
        };
        for v in &self.barracks_status {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.cluster {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.server_addr.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.first_blood_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.event_score {
            os.write_uint32(14, v)?;
        }
        for v in &self.picks_bans {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.fantasy_stats {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        for v in &self.player_strange_count_adjustments {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.automatic_surrender {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        for v in &self.additional_msgs {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.social_feed_events {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        };
        if let Some(v) = self.average_networth_delta {
            os.write_sint32(22, v)?;
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.match_flags {
            os.write_uint32(38, v)?;
        }
        for v in &self.team_scores {
            os.write_uint32(39, *v)?;
        };
        if let Some(v) = self.pre_game_duration {
            os.write_uint32(40, v)?;
        }
        for v in &self.event_game_leaderboard_entries {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        for v in &self.ward_placements {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        };
        if let Some(v) = self.gameplay_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        for v in &self.extra_messages {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        };
        if let Some(v) = self.training_data_recorded {
            os.write_bool(55, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_enum(56, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.normalized_win_probability_diff {
            os.write_float(57, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOut {
        CMsgGameMatchSignOut::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.good_guys_win = ::std::option::Option::None;
        self.date = ::std::option::Option::None;
        self.teams.clear();
        self.tower_status.clear();
        self.barracks_status.clear();
        self.cluster = ::std::option::Option::None;
        self.server_addr = ::std::option::Option::None;
        self.first_blood_time = ::std::option::Option::None;
        self.event_score = ::std::option::Option::None;
        self.picks_bans.clear();
        self.fantasy_stats.clear();
        self.player_strange_count_adjustments.clear();
        self.automatic_surrender = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.poor_network_conditions.clear();
        self.additional_msgs.clear();
        self.social_feed_events.clear();
        self.average_networth_delta = ::std::option::Option::None;
        self.custom_game_data.clear();
        self.match_flags = ::std::option::Option::None;
        self.team_scores.clear();
        self.pre_game_duration = ::std::option::Option::None;
        self.event_game_leaderboard_entries.clear();
        self.ward_placements.clear();
        self.gameplay_stats.clear();
        self.extra_messages.clear();
        self.training_data_recorded = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.normalized_win_probability_diff = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOut {
        static instance: CMsgGameMatchSignOut = CMsgGameMatchSignOut {
            match_id: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            good_guys_win: ::std::option::Option::None,
            date: ::std::option::Option::None,
            teams: ::std::vec::Vec::new(),
            tower_status: ::std::vec::Vec::new(),
            barracks_status: ::std::vec::Vec::new(),
            cluster: ::std::option::Option::None,
            server_addr: ::std::option::Option::None,
            first_blood_time: ::std::option::Option::None,
            event_score: ::std::option::Option::None,
            picks_bans: ::std::vec::Vec::new(),
            fantasy_stats: ::std::vec::Vec::new(),
            player_strange_count_adjustments: ::std::vec::Vec::new(),
            automatic_surrender: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            poor_network_conditions: ::protobuf::MessageField::none(),
            additional_msgs: ::std::vec::Vec::new(),
            social_feed_events: ::std::vec::Vec::new(),
            average_networth_delta: ::std::option::Option::None,
            custom_game_data: ::protobuf::MessageField::none(),
            match_flags: ::std::option::Option::None,
            team_scores: ::std::vec::Vec::new(),
            pre_game_duration: ::std::option::Option::None,
            event_game_leaderboard_entries: ::std::vec::Vec::new(),
            ward_placements: ::std::vec::Vec::new(),
            gameplay_stats: ::protobuf::MessageField::none(),
            extra_messages: ::std::vec::Vec::new(),
            training_data_recorded: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            normalized_win_probability_diff: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameMatchSignOut {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameMatchSignOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameMatchSignOut`
pub mod cmsg_game_match_sign_out {
    // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.CTeam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CTeam {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.players)
        pub players: ::std::vec::Vec<cteam::CPlayer>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.CTeam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CTeam {
        fn default() -> &'a CTeam {
            <CTeam as ::protobuf::Message>::default_instance()
        }
    }

    impl CTeam {
        pub fn new() -> CTeam {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "players",
                |m: &CTeam| { &m.players },
                |m: &mut CTeam| { &mut m.players },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTeam>(
                "CMsgGameMatchSignOut.CTeam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CTeam {
        const NAME: &'static str = "CTeam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.players.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.players {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CTeam {
            CTeam::new()
        }

        fn clear(&mut self) {
            self.players.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CTeam {
            static instance: CTeam = CTeam {
                players: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CTeam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.CTeam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CTeam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CTeam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CTeam`
    pub mod cteam {
        // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.CTeam.CPlayer)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CPlayer {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.steam_id)
            pub steam_id: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_id)
            pub hero_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.items)
            pub items: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.item_purchase_times)
            pub item_purchase_times: ::std::vec::Vec<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.gold)
            pub gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.kills)
            pub kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.deaths)
            pub deaths: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.assists)
            pub assists: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.leaver_status)
            pub leaver_status: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.last_hits)
            pub last_hits: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.denies)
            pub denies: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.gold_per_min)
            pub gold_per_min: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.xp_per_minute)
            pub xp_per_minute: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.gold_spent)
            pub gold_spent: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.level)
            pub level: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.scaled_hero_damage)
            pub scaled_hero_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.scaled_tower_damage)
            pub scaled_tower_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.scaled_hero_healing)
            pub scaled_hero_healing: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.time_last_seen)
            pub time_last_seen: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.support_ability_value)
            pub support_ability_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.party_id)
            pub party_id: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.claimed_farm_gold)
            pub claimed_farm_gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.support_gold)
            pub support_gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.claimed_denies)
            pub claimed_denies: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.claimed_misses)
            pub claimed_misses: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.misses)
            pub misses: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.net_worth)
            pub net_worth: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_damage)
            pub hero_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.tower_damage)
            pub tower_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_healing)
            pub hero_healing: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.ability_upgrades)
            pub ability_upgrades: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.additional_units_inventory)
            pub additional_units_inventory: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMatchAdditionalUnitInventory>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.permanent_buffs)
            pub permanent_buffs: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMatchPlayerPermanentBuff>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.custom_game_data)
            pub custom_game_data: ::protobuf::MessageField<cplayer::CCustomGameData>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.match_player_flags)
            pub match_player_flags: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.talent_ability_ids)
            pub talent_ability_ids: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_pick_order)
            pub hero_pick_order: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_was_randomed)
            pub hero_was_randomed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_was_dota_plus_suggestion)
            pub hero_was_dota_plus_suggestion: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.lane)
            pub lane: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.is_using_plus_guide)
            pub is_using_plus_guide: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_damage_received)
            pub hero_damage_received: ::std::vec::Vec<cplayer::HeroDamageReceived>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.hero_damage_dealt)
            pub hero_damage_dealt: ::std::vec::Vec<cplayer::HeroDamageReceived>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.seconds_dead)
            pub seconds_dead: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.gold_lost_to_death)
            pub gold_lost_to_death: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.command_count)
            pub command_count: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.mouse_click_cast_command_count)
            pub mouse_click_cast_command_count: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.teleports_used)
            pub teleports_used: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.cavern_crawl_preferred_map_variant)
            pub cavern_crawl_preferred_map_variant: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.bounty_runes)
            pub bounty_runes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.outposts_captured)
            pub outposts_captured: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.dewards)
            pub dewards: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.wards_placed)
            pub wards_placed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.camps_stacked)
            pub camps_stacked: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.predicted_position)
            pub predicted_position: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.lane_outcomes)
            pub lane_outcomes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.friendly_t1_destroyed_time)
            pub friendly_t1_destroyed_time: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.enemy_t1_destroyed_time)
            pub enemy_t1_destroyed_time: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.friendly_roshan_kills)
            pub friendly_roshan_kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.enemy_roshan_kills)
            pub enemy_roshan_kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.power_runes)
            pub power_runes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.water_runes)
            pub water_runes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.stun_duration)
            pub stun_duration: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.team_number)
            pub team_number: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::DOTA_GC_TEAM>>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.team_slot)
            pub team_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.time_purchased_shard)
            pub time_purchased_shard: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.time_purchased_aghs)
            pub time_purchased_aghs: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.ability_draft_abilities)
            pub ability_draft_abilities: ::std::vec::Vec<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CPlayer {
            fn default() -> &'a CPlayer {
                <CPlayer as ::protobuf::Message>::default_instance()
            }
        }

        impl CPlayer {
            pub fn new() -> CPlayer {
                ::std::default::Default::default()
            }

            // optional fixed64 steam_id = 1;

            pub fn steam_id(&self) -> u64 {
                self.steam_id.unwrap_or(0)
            }

            pub fn clear_steam_id(&mut self) {
                self.steam_id = ::std::option::Option::None;
            }

            pub fn has_steam_id(&self) -> bool {
                self.steam_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_steam_id(&mut self, v: u64) {
                self.steam_id = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_id = 3;

            pub fn hero_id(&self) -> u32 {
                self.hero_id.unwrap_or(0)
            }

            pub fn clear_hero_id(&mut self) {
                self.hero_id = ::std::option::Option::None;
            }

            pub fn has_hero_id(&self) -> bool {
                self.hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_id(&mut self, v: u32) {
                self.hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 gold = 5;

            pub fn gold(&self) -> u32 {
                self.gold.unwrap_or(0)
            }

            pub fn clear_gold(&mut self) {
                self.gold = ::std::option::Option::None;
            }

            pub fn has_gold(&self) -> bool {
                self.gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold(&mut self, v: u32) {
                self.gold = ::std::option::Option::Some(v);
            }

            // optional uint32 kills = 6;

            pub fn kills(&self) -> u32 {
                self.kills.unwrap_or(0)
            }

            pub fn clear_kills(&mut self) {
                self.kills = ::std::option::Option::None;
            }

            pub fn has_kills(&self) -> bool {
                self.kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kills(&mut self, v: u32) {
                self.kills = ::std::option::Option::Some(v);
            }

            // optional uint32 deaths = 7;

            pub fn deaths(&self) -> u32 {
                self.deaths.unwrap_or(0)
            }

            pub fn clear_deaths(&mut self) {
                self.deaths = ::std::option::Option::None;
            }

            pub fn has_deaths(&self) -> bool {
                self.deaths.is_some()
            }

            // Param is passed by value, moved
            pub fn set_deaths(&mut self, v: u32) {
                self.deaths = ::std::option::Option::Some(v);
            }

            // optional uint32 assists = 8;

            pub fn assists(&self) -> u32 {
                self.assists.unwrap_or(0)
            }

            pub fn clear_assists(&mut self) {
                self.assists = ::std::option::Option::None;
            }

            pub fn has_assists(&self) -> bool {
                self.assists.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assists(&mut self, v: u32) {
                self.assists = ::std::option::Option::Some(v);
            }

            // optional uint32 leaver_status = 9;

            pub fn leaver_status(&self) -> u32 {
                self.leaver_status.unwrap_or(0)
            }

            pub fn clear_leaver_status(&mut self) {
                self.leaver_status = ::std::option::Option::None;
            }

            pub fn has_leaver_status(&self) -> bool {
                self.leaver_status.is_some()
            }

            // Param is passed by value, moved
            pub fn set_leaver_status(&mut self, v: u32) {
                self.leaver_status = ::std::option::Option::Some(v);
            }

            // optional uint32 last_hits = 10;

            pub fn last_hits(&self) -> u32 {
                self.last_hits.unwrap_or(0)
            }

            pub fn clear_last_hits(&mut self) {
                self.last_hits = ::std::option::Option::None;
            }

            pub fn has_last_hits(&self) -> bool {
                self.last_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_last_hits(&mut self, v: u32) {
                self.last_hits = ::std::option::Option::Some(v);
            }

            // optional uint32 denies = 11;

            pub fn denies(&self) -> u32 {
                self.denies.unwrap_or(0)
            }

            pub fn clear_denies(&mut self) {
                self.denies = ::std::option::Option::None;
            }

            pub fn has_denies(&self) -> bool {
                self.denies.is_some()
            }

            // Param is passed by value, moved
            pub fn set_denies(&mut self, v: u32) {
                self.denies = ::std::option::Option::Some(v);
            }

            // optional uint32 gold_per_min = 12;

            pub fn gold_per_min(&self) -> u32 {
                self.gold_per_min.unwrap_or(0)
            }

            pub fn clear_gold_per_min(&mut self) {
                self.gold_per_min = ::std::option::Option::None;
            }

            pub fn has_gold_per_min(&self) -> bool {
                self.gold_per_min.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_per_min(&mut self, v: u32) {
                self.gold_per_min = ::std::option::Option::Some(v);
            }

            // optional uint32 xp_per_minute = 13;

            pub fn xp_per_minute(&self) -> u32 {
                self.xp_per_minute.unwrap_or(0)
            }

            pub fn clear_xp_per_minute(&mut self) {
                self.xp_per_minute = ::std::option::Option::None;
            }

            pub fn has_xp_per_minute(&self) -> bool {
                self.xp_per_minute.is_some()
            }

            // Param is passed by value, moved
            pub fn set_xp_per_minute(&mut self, v: u32) {
                self.xp_per_minute = ::std::option::Option::Some(v);
            }

            // optional uint32 gold_spent = 14;

            pub fn gold_spent(&self) -> u32 {
                self.gold_spent.unwrap_or(0)
            }

            pub fn clear_gold_spent(&mut self) {
                self.gold_spent = ::std::option::Option::None;
            }

            pub fn has_gold_spent(&self) -> bool {
                self.gold_spent.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_spent(&mut self, v: u32) {
                self.gold_spent = ::std::option::Option::Some(v);
            }

            // optional uint32 level = 15;

            pub fn level(&self) -> u32 {
                self.level.unwrap_or(0)
            }

            pub fn clear_level(&mut self) {
                self.level = ::std::option::Option::None;
            }

            pub fn has_level(&self) -> bool {
                self.level.is_some()
            }

            // Param is passed by value, moved
            pub fn set_level(&mut self, v: u32) {
                self.level = ::std::option::Option::Some(v);
            }

            // optional uint32 scaled_hero_damage = 16;

            pub fn scaled_hero_damage(&self) -> u32 {
                self.scaled_hero_damage.unwrap_or(0)
            }

            pub fn clear_scaled_hero_damage(&mut self) {
                self.scaled_hero_damage = ::std::option::Option::None;
            }

            pub fn has_scaled_hero_damage(&self) -> bool {
                self.scaled_hero_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_scaled_hero_damage(&mut self, v: u32) {
                self.scaled_hero_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 scaled_tower_damage = 17;

            pub fn scaled_tower_damage(&self) -> u32 {
                self.scaled_tower_damage.unwrap_or(0)
            }

            pub fn clear_scaled_tower_damage(&mut self) {
                self.scaled_tower_damage = ::std::option::Option::None;
            }

            pub fn has_scaled_tower_damage(&self) -> bool {
                self.scaled_tower_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_scaled_tower_damage(&mut self, v: u32) {
                self.scaled_tower_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 scaled_hero_healing = 18;

            pub fn scaled_hero_healing(&self) -> u32 {
                self.scaled_hero_healing.unwrap_or(0)
            }

            pub fn clear_scaled_hero_healing(&mut self) {
                self.scaled_hero_healing = ::std::option::Option::None;
            }

            pub fn has_scaled_hero_healing(&self) -> bool {
                self.scaled_hero_healing.is_some()
            }

            // Param is passed by value, moved
            pub fn set_scaled_hero_healing(&mut self, v: u32) {
                self.scaled_hero_healing = ::std::option::Option::Some(v);
            }

            // optional uint32 time_last_seen = 19;

            pub fn time_last_seen(&self) -> u32 {
                self.time_last_seen.unwrap_or(0)
            }

            pub fn clear_time_last_seen(&mut self) {
                self.time_last_seen = ::std::option::Option::None;
            }

            pub fn has_time_last_seen(&self) -> bool {
                self.time_last_seen.is_some()
            }

            // Param is passed by value, moved
            pub fn set_time_last_seen(&mut self, v: u32) {
                self.time_last_seen = ::std::option::Option::Some(v);
            }

            // optional uint32 support_ability_value = 20;

            pub fn support_ability_value(&self) -> u32 {
                self.support_ability_value.unwrap_or(0)
            }

            pub fn clear_support_ability_value(&mut self) {
                self.support_ability_value = ::std::option::Option::None;
            }

            pub fn has_support_ability_value(&self) -> bool {
                self.support_ability_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_ability_value(&mut self, v: u32) {
                self.support_ability_value = ::std::option::Option::Some(v);
            }

            // optional uint64 party_id = 21;

            pub fn party_id(&self) -> u64 {
                self.party_id.unwrap_or(0)
            }

            pub fn clear_party_id(&mut self) {
                self.party_id = ::std::option::Option::None;
            }

            pub fn has_party_id(&self) -> bool {
                self.party_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_party_id(&mut self, v: u64) {
                self.party_id = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_farm_gold = 27;

            pub fn claimed_farm_gold(&self) -> u32 {
                self.claimed_farm_gold.unwrap_or(0)
            }

            pub fn clear_claimed_farm_gold(&mut self) {
                self.claimed_farm_gold = ::std::option::Option::None;
            }

            pub fn has_claimed_farm_gold(&self) -> bool {
                self.claimed_farm_gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_farm_gold(&mut self, v: u32) {
                self.claimed_farm_gold = ::std::option::Option::Some(v);
            }

            // optional uint32 support_gold = 28;

            pub fn support_gold(&self) -> u32 {
                self.support_gold.unwrap_or(0)
            }

            pub fn clear_support_gold(&mut self) {
                self.support_gold = ::std::option::Option::None;
            }

            pub fn has_support_gold(&self) -> bool {
                self.support_gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_gold(&mut self, v: u32) {
                self.support_gold = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_denies = 29;

            pub fn claimed_denies(&self) -> u32 {
                self.claimed_denies.unwrap_or(0)
            }

            pub fn clear_claimed_denies(&mut self) {
                self.claimed_denies = ::std::option::Option::None;
            }

            pub fn has_claimed_denies(&self) -> bool {
                self.claimed_denies.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_denies(&mut self, v: u32) {
                self.claimed_denies = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_misses = 30;

            pub fn claimed_misses(&self) -> u32 {
                self.claimed_misses.unwrap_or(0)
            }

            pub fn clear_claimed_misses(&mut self) {
                self.claimed_misses = ::std::option::Option::None;
            }

            pub fn has_claimed_misses(&self) -> bool {
                self.claimed_misses.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_misses(&mut self, v: u32) {
                self.claimed_misses = ::std::option::Option::Some(v);
            }

            // optional uint32 misses = 31;

            pub fn misses(&self) -> u32 {
                self.misses.unwrap_or(0)
            }

            pub fn clear_misses(&mut self) {
                self.misses = ::std::option::Option::None;
            }

            pub fn has_misses(&self) -> bool {
                self.misses.is_some()
            }

            // Param is passed by value, moved
            pub fn set_misses(&mut self, v: u32) {
                self.misses = ::std::option::Option::Some(v);
            }

            // optional uint32 net_worth = 34;

            pub fn net_worth(&self) -> u32 {
                self.net_worth.unwrap_or(0)
            }

            pub fn clear_net_worth(&mut self) {
                self.net_worth = ::std::option::Option::None;
            }

            pub fn has_net_worth(&self) -> bool {
                self.net_worth.is_some()
            }

            // Param is passed by value, moved
            pub fn set_net_worth(&mut self, v: u32) {
                self.net_worth = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_damage = 37;

            pub fn hero_damage(&self) -> u32 {
                self.hero_damage.unwrap_or(0)
            }

            pub fn clear_hero_damage(&mut self) {
                self.hero_damage = ::std::option::Option::None;
            }

            pub fn has_hero_damage(&self) -> bool {
                self.hero_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_damage(&mut self, v: u32) {
                self.hero_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 tower_damage = 38;

            pub fn tower_damage(&self) -> u32 {
                self.tower_damage.unwrap_or(0)
            }

            pub fn clear_tower_damage(&mut self) {
                self.tower_damage = ::std::option::Option::None;
            }

            pub fn has_tower_damage(&self) -> bool {
                self.tower_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_tower_damage(&mut self, v: u32) {
                self.tower_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_healing = 39;

            pub fn hero_healing(&self) -> u32 {
                self.hero_healing.unwrap_or(0)
            }

            pub fn clear_hero_healing(&mut self) {
                self.hero_healing = ::std::option::Option::None;
            }

            pub fn has_hero_healing(&self) -> bool {
                self.hero_healing.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_healing(&mut self, v: u32) {
                self.hero_healing = ::std::option::Option::Some(v);
            }

            // optional uint32 match_player_flags = 36;

            pub fn match_player_flags(&self) -> u32 {
                self.match_player_flags.unwrap_or(0)
            }

            pub fn clear_match_player_flags(&mut self) {
                self.match_player_flags = ::std::option::Option::None;
            }

            pub fn has_match_player_flags(&self) -> bool {
                self.match_player_flags.is_some()
            }

            // Param is passed by value, moved
            pub fn set_match_player_flags(&mut self, v: u32) {
                self.match_player_flags = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_pick_order = 42;

            pub fn hero_pick_order(&self) -> u32 {
                self.hero_pick_order.unwrap_or(0)
            }

            pub fn clear_hero_pick_order(&mut self) {
                self.hero_pick_order = ::std::option::Option::None;
            }

            pub fn has_hero_pick_order(&self) -> bool {
                self.hero_pick_order.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_pick_order(&mut self, v: u32) {
                self.hero_pick_order = ::std::option::Option::Some(v);
            }

            // optional bool hero_was_randomed = 43;

            pub fn hero_was_randomed(&self) -> bool {
                self.hero_was_randomed.unwrap_or(false)
            }

            pub fn clear_hero_was_randomed(&mut self) {
                self.hero_was_randomed = ::std::option::Option::None;
            }

            pub fn has_hero_was_randomed(&self) -> bool {
                self.hero_was_randomed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_was_randomed(&mut self, v: bool) {
                self.hero_was_randomed = ::std::option::Option::Some(v);
            }

            // optional bool hero_was_dota_plus_suggestion = 50;

            pub fn hero_was_dota_plus_suggestion(&self) -> bool {
                self.hero_was_dota_plus_suggestion.unwrap_or(false)
            }

            pub fn clear_hero_was_dota_plus_suggestion(&mut self) {
                self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
            }

            pub fn has_hero_was_dota_plus_suggestion(&self) -> bool {
                self.hero_was_dota_plus_suggestion.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_was_dota_plus_suggestion(&mut self, v: bool) {
                self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(v);
            }

            // optional uint32 lane = 45;

            pub fn lane(&self) -> u32 {
                self.lane.unwrap_or(0)
            }

            pub fn clear_lane(&mut self) {
                self.lane = ::std::option::Option::None;
            }

            pub fn has_lane(&self) -> bool {
                self.lane.is_some()
            }

            // Param is passed by value, moved
            pub fn set_lane(&mut self, v: u32) {
                self.lane = ::std::option::Option::Some(v);
            }

            // optional bool is_using_plus_guide = 47;

            pub fn is_using_plus_guide(&self) -> bool {
                self.is_using_plus_guide.unwrap_or(false)
            }

            pub fn clear_is_using_plus_guide(&mut self) {
                self.is_using_plus_guide = ::std::option::Option::None;
            }

            pub fn has_is_using_plus_guide(&self) -> bool {
                self.is_using_plus_guide.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_using_plus_guide(&mut self, v: bool) {
                self.is_using_plus_guide = ::std::option::Option::Some(v);
            }

            // optional uint32 seconds_dead = 51;

            pub fn seconds_dead(&self) -> u32 {
                self.seconds_dead.unwrap_or(0)
            }

            pub fn clear_seconds_dead(&mut self) {
                self.seconds_dead = ::std::option::Option::None;
            }

            pub fn has_seconds_dead(&self) -> bool {
                self.seconds_dead.is_some()
            }

            // Param is passed by value, moved
            pub fn set_seconds_dead(&mut self, v: u32) {
                self.seconds_dead = ::std::option::Option::Some(v);
            }

            // optional uint32 gold_lost_to_death = 52;

            pub fn gold_lost_to_death(&self) -> u32 {
                self.gold_lost_to_death.unwrap_or(0)
            }

            pub fn clear_gold_lost_to_death(&mut self) {
                self.gold_lost_to_death = ::std::option::Option::None;
            }

            pub fn has_gold_lost_to_death(&self) -> bool {
                self.gold_lost_to_death.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_lost_to_death(&mut self, v: u32) {
                self.gold_lost_to_death = ::std::option::Option::Some(v);
            }

            // optional uint32 command_count = 53;

            pub fn command_count(&self) -> u32 {
                self.command_count.unwrap_or(0)
            }

            pub fn clear_command_count(&mut self) {
                self.command_count = ::std::option::Option::None;
            }

            pub fn has_command_count(&self) -> bool {
                self.command_count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_command_count(&mut self, v: u32) {
                self.command_count = ::std::option::Option::Some(v);
            }

            // optional uint32 mouse_click_cast_command_count = 54;

            pub fn mouse_click_cast_command_count(&self) -> u32 {
                self.mouse_click_cast_command_count.unwrap_or(0)
            }

            pub fn clear_mouse_click_cast_command_count(&mut self) {
                self.mouse_click_cast_command_count = ::std::option::Option::None;
            }

            pub fn has_mouse_click_cast_command_count(&self) -> bool {
                self.mouse_click_cast_command_count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_mouse_click_cast_command_count(&mut self, v: u32) {
                self.mouse_click_cast_command_count = ::std::option::Option::Some(v);
            }

            // optional uint32 teleports_used = 55;

            pub fn teleports_used(&self) -> u32 {
                self.teleports_used.unwrap_or(0)
            }

            pub fn clear_teleports_used(&mut self) {
                self.teleports_used = ::std::option::Option::None;
            }

            pub fn has_teleports_used(&self) -> bool {
                self.teleports_used.is_some()
            }

            // Param is passed by value, moved
            pub fn set_teleports_used(&mut self, v: u32) {
                self.teleports_used = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_crawl_preferred_map_variant = 56;

            pub fn cavern_crawl_preferred_map_variant(&self) -> u32 {
                self.cavern_crawl_preferred_map_variant.unwrap_or(0)
            }

            pub fn clear_cavern_crawl_preferred_map_variant(&mut self) {
                self.cavern_crawl_preferred_map_variant = ::std::option::Option::None;
            }

            pub fn has_cavern_crawl_preferred_map_variant(&self) -> bool {
                self.cavern_crawl_preferred_map_variant.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_crawl_preferred_map_variant(&mut self, v: u32) {
                self.cavern_crawl_preferred_map_variant = ::std::option::Option::Some(v);
            }

            // optional uint32 bounty_runes = 57;

            pub fn bounty_runes(&self) -> u32 {
                self.bounty_runes.unwrap_or(0)
            }

            pub fn clear_bounty_runes(&mut self) {
                self.bounty_runes = ::std::option::Option::None;
            }

            pub fn has_bounty_runes(&self) -> bool {
                self.bounty_runes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_bounty_runes(&mut self, v: u32) {
                self.bounty_runes = ::std::option::Option::Some(v);
            }

            // optional uint32 outposts_captured = 58;

            pub fn outposts_captured(&self) -> u32 {
                self.outposts_captured.unwrap_or(0)
            }

            pub fn clear_outposts_captured(&mut self) {
                self.outposts_captured = ::std::option::Option::None;
            }

            pub fn has_outposts_captured(&self) -> bool {
                self.outposts_captured.is_some()
            }

            // Param is passed by value, moved
            pub fn set_outposts_captured(&mut self, v: u32) {
                self.outposts_captured = ::std::option::Option::Some(v);
            }

            // optional uint32 dewards = 59;

            pub fn dewards(&self) -> u32 {
                self.dewards.unwrap_or(0)
            }

            pub fn clear_dewards(&mut self) {
                self.dewards = ::std::option::Option::None;
            }

            pub fn has_dewards(&self) -> bool {
                self.dewards.is_some()
            }

            // Param is passed by value, moved
            pub fn set_dewards(&mut self, v: u32) {
                self.dewards = ::std::option::Option::Some(v);
            }

            // optional uint32 wards_placed = 60;

            pub fn wards_placed(&self) -> u32 {
                self.wards_placed.unwrap_or(0)
            }

            pub fn clear_wards_placed(&mut self) {
                self.wards_placed = ::std::option::Option::None;
            }

            pub fn has_wards_placed(&self) -> bool {
                self.wards_placed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wards_placed(&mut self, v: u32) {
                self.wards_placed = ::std::option::Option::Some(v);
            }

            // optional uint32 camps_stacked = 61;

            pub fn camps_stacked(&self) -> u32 {
                self.camps_stacked.unwrap_or(0)
            }

            pub fn clear_camps_stacked(&mut self) {
                self.camps_stacked = ::std::option::Option::None;
            }

            pub fn has_camps_stacked(&self) -> bool {
                self.camps_stacked.is_some()
            }

            // Param is passed by value, moved
            pub fn set_camps_stacked(&mut self, v: u32) {
                self.camps_stacked = ::std::option::Option::Some(v);
            }

            // optional uint32 player_slot = 62;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 predicted_position = 66;

            pub fn predicted_position(&self) -> u32 {
                self.predicted_position.unwrap_or(0)
            }

            pub fn clear_predicted_position(&mut self) {
                self.predicted_position = ::std::option::Option::None;
            }

            pub fn has_predicted_position(&self) -> bool {
                self.predicted_position.is_some()
            }

            // Param is passed by value, moved
            pub fn set_predicted_position(&mut self, v: u32) {
                self.predicted_position = ::std::option::Option::Some(v);
            }

            // optional uint32 lane_outcomes = 67;

            pub fn lane_outcomes(&self) -> u32 {
                self.lane_outcomes.unwrap_or(0)
            }

            pub fn clear_lane_outcomes(&mut self) {
                self.lane_outcomes = ::std::option::Option::None;
            }

            pub fn has_lane_outcomes(&self) -> bool {
                self.lane_outcomes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_lane_outcomes(&mut self, v: u32) {
                self.lane_outcomes = ::std::option::Option::Some(v);
            }

            // optional uint32 friendly_t1_destroyed_time = 68;

            pub fn friendly_t1_destroyed_time(&self) -> u32 {
                self.friendly_t1_destroyed_time.unwrap_or(0)
            }

            pub fn clear_friendly_t1_destroyed_time(&mut self) {
                self.friendly_t1_destroyed_time = ::std::option::Option::None;
            }

            pub fn has_friendly_t1_destroyed_time(&self) -> bool {
                self.friendly_t1_destroyed_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_friendly_t1_destroyed_time(&mut self, v: u32) {
                self.friendly_t1_destroyed_time = ::std::option::Option::Some(v);
            }

            // optional uint32 enemy_t1_destroyed_time = 69;

            pub fn enemy_t1_destroyed_time(&self) -> u32 {
                self.enemy_t1_destroyed_time.unwrap_or(0)
            }

            pub fn clear_enemy_t1_destroyed_time(&mut self) {
                self.enemy_t1_destroyed_time = ::std::option::Option::None;
            }

            pub fn has_enemy_t1_destroyed_time(&self) -> bool {
                self.enemy_t1_destroyed_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_enemy_t1_destroyed_time(&mut self, v: u32) {
                self.enemy_t1_destroyed_time = ::std::option::Option::Some(v);
            }

            // optional uint32 friendly_roshan_kills = 70;

            pub fn friendly_roshan_kills(&self) -> u32 {
                self.friendly_roshan_kills.unwrap_or(0)
            }

            pub fn clear_friendly_roshan_kills(&mut self) {
                self.friendly_roshan_kills = ::std::option::Option::None;
            }

            pub fn has_friendly_roshan_kills(&self) -> bool {
                self.friendly_roshan_kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_friendly_roshan_kills(&mut self, v: u32) {
                self.friendly_roshan_kills = ::std::option::Option::Some(v);
            }

            // optional uint32 enemy_roshan_kills = 71;

            pub fn enemy_roshan_kills(&self) -> u32 {
                self.enemy_roshan_kills.unwrap_or(0)
            }

            pub fn clear_enemy_roshan_kills(&mut self) {
                self.enemy_roshan_kills = ::std::option::Option::None;
            }

            pub fn has_enemy_roshan_kills(&self) -> bool {
                self.enemy_roshan_kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_enemy_roshan_kills(&mut self, v: u32) {
                self.enemy_roshan_kills = ::std::option::Option::Some(v);
            }

            // optional uint32 power_runes = 72;

            pub fn power_runes(&self) -> u32 {
                self.power_runes.unwrap_or(0)
            }

            pub fn clear_power_runes(&mut self) {
                self.power_runes = ::std::option::Option::None;
            }

            pub fn has_power_runes(&self) -> bool {
                self.power_runes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_power_runes(&mut self, v: u32) {
                self.power_runes = ::std::option::Option::Some(v);
            }

            // optional uint32 water_runes = 73;

            pub fn water_runes(&self) -> u32 {
                self.water_runes.unwrap_or(0)
            }

            pub fn clear_water_runes(&mut self) {
                self.water_runes = ::std::option::Option::None;
            }

            pub fn has_water_runes(&self) -> bool {
                self.water_runes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_water_runes(&mut self, v: u32) {
                self.water_runes = ::std::option::Option::Some(v);
            }

            // optional float stun_duration = 74;

            pub fn stun_duration(&self) -> f32 {
                self.stun_duration.unwrap_or(0.)
            }

            pub fn clear_stun_duration(&mut self) {
                self.stun_duration = ::std::option::Option::None;
            }

            pub fn has_stun_duration(&self) -> bool {
                self.stun_duration.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stun_duration(&mut self, v: f32) {
                self.stun_duration = ::std::option::Option::Some(v);
            }

            // optional .dota.DOTA_GC_TEAM team_number = 75;

            pub fn team_number(&self) -> super::super::super::dota_shared_enums::DOTA_GC_TEAM {
                match self.team_number {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                    None => super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
                }
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: super::super::super::dota_shared_enums::DOTA_GC_TEAM) {
                self.team_number = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 team_slot = 76;

            pub fn team_slot(&self) -> u32 {
                self.team_slot.unwrap_or(0)
            }

            pub fn clear_team_slot(&mut self) {
                self.team_slot = ::std::option::Option::None;
            }

            pub fn has_team_slot(&self) -> bool {
                self.team_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_slot(&mut self, v: u32) {
                self.team_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 time_purchased_shard = 77;

            pub fn time_purchased_shard(&self) -> u32 {
                self.time_purchased_shard.unwrap_or(0)
            }

            pub fn clear_time_purchased_shard(&mut self) {
                self.time_purchased_shard = ::std::option::Option::None;
            }

            pub fn has_time_purchased_shard(&self) -> bool {
                self.time_purchased_shard.is_some()
            }

            // Param is passed by value, moved
            pub fn set_time_purchased_shard(&mut self, v: u32) {
                self.time_purchased_shard = ::std::option::Option::Some(v);
            }

            // optional uint32 time_purchased_aghs = 78;

            pub fn time_purchased_aghs(&self) -> u32 {
                self.time_purchased_aghs.unwrap_or(0)
            }

            pub fn clear_time_purchased_aghs(&mut self) {
                self.time_purchased_aghs = ::std::option::Option::None;
            }

            pub fn has_time_purchased_aghs(&self) -> bool {
                self.time_purchased_aghs.is_some()
            }

            // Param is passed by value, moved
            pub fn set_time_purchased_aghs(&mut self, v: u32) {
                self.time_purchased_aghs = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(69);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "steam_id",
                    |m: &CPlayer| { &m.steam_id },
                    |m: &mut CPlayer| { &mut m.steam_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_id",
                    |m: &CPlayer| { &m.hero_id },
                    |m: &mut CPlayer| { &mut m.hero_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "items",
                    |m: &CPlayer| { &m.items },
                    |m: &mut CPlayer| { &mut m.items },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "item_purchase_times",
                    |m: &CPlayer| { &m.item_purchase_times },
                    |m: &mut CPlayer| { &mut m.item_purchase_times },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "gold",
                    |m: &CPlayer| { &m.gold },
                    |m: &mut CPlayer| { &mut m.gold },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "kills",
                    |m: &CPlayer| { &m.kills },
                    |m: &mut CPlayer| { &mut m.kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "deaths",
                    |m: &CPlayer| { &m.deaths },
                    |m: &mut CPlayer| { &mut m.deaths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "assists",
                    |m: &CPlayer| { &m.assists },
                    |m: &mut CPlayer| { &mut m.assists },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "leaver_status",
                    |m: &CPlayer| { &m.leaver_status },
                    |m: &mut CPlayer| { &mut m.leaver_status },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "last_hits",
                    |m: &CPlayer| { &m.last_hits },
                    |m: &mut CPlayer| { &mut m.last_hits },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "denies",
                    |m: &CPlayer| { &m.denies },
                    |m: &mut CPlayer| { &mut m.denies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "gold_per_min",
                    |m: &CPlayer| { &m.gold_per_min },
                    |m: &mut CPlayer| { &mut m.gold_per_min },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "xp_per_minute",
                    |m: &CPlayer| { &m.xp_per_minute },
                    |m: &mut CPlayer| { &mut m.xp_per_minute },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "gold_spent",
                    |m: &CPlayer| { &m.gold_spent },
                    |m: &mut CPlayer| { &mut m.gold_spent },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "level",
                    |m: &CPlayer| { &m.level },
                    |m: &mut CPlayer| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "scaled_hero_damage",
                    |m: &CPlayer| { &m.scaled_hero_damage },
                    |m: &mut CPlayer| { &mut m.scaled_hero_damage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "scaled_tower_damage",
                    |m: &CPlayer| { &m.scaled_tower_damage },
                    |m: &mut CPlayer| { &mut m.scaled_tower_damage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "scaled_hero_healing",
                    |m: &CPlayer| { &m.scaled_hero_healing },
                    |m: &mut CPlayer| { &mut m.scaled_hero_healing },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "time_last_seen",
                    |m: &CPlayer| { &m.time_last_seen },
                    |m: &mut CPlayer| { &mut m.time_last_seen },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "support_ability_value",
                    |m: &CPlayer| { &m.support_ability_value },
                    |m: &mut CPlayer| { &mut m.support_ability_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "party_id",
                    |m: &CPlayer| { &m.party_id },
                    |m: &mut CPlayer| { &mut m.party_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "claimed_farm_gold",
                    |m: &CPlayer| { &m.claimed_farm_gold },
                    |m: &mut CPlayer| { &mut m.claimed_farm_gold },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "support_gold",
                    |m: &CPlayer| { &m.support_gold },
                    |m: &mut CPlayer| { &mut m.support_gold },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "claimed_denies",
                    |m: &CPlayer| { &m.claimed_denies },
                    |m: &mut CPlayer| { &mut m.claimed_denies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "claimed_misses",
                    |m: &CPlayer| { &m.claimed_misses },
                    |m: &mut CPlayer| { &mut m.claimed_misses },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "misses",
                    |m: &CPlayer| { &m.misses },
                    |m: &mut CPlayer| { &mut m.misses },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "net_worth",
                    |m: &CPlayer| { &m.net_worth },
                    |m: &mut CPlayer| { &mut m.net_worth },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_damage",
                    |m: &CPlayer| { &m.hero_damage },
                    |m: &mut CPlayer| { &mut m.hero_damage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "tower_damage",
                    |m: &CPlayer| { &m.tower_damage },
                    |m: &mut CPlayer| { &mut m.tower_damage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_healing",
                    |m: &CPlayer| { &m.hero_healing },
                    |m: &mut CPlayer| { &mut m.hero_healing },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "ability_upgrades",
                    |m: &CPlayer| { &m.ability_upgrades },
                    |m: &mut CPlayer| { &mut m.ability_upgrades },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "additional_units_inventory",
                    |m: &CPlayer| { &m.additional_units_inventory },
                    |m: &mut CPlayer| { &mut m.additional_units_inventory },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "permanent_buffs",
                    |m: &CPlayer| { &m.permanent_buffs },
                    |m: &mut CPlayer| { &mut m.permanent_buffs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cplayer::CCustomGameData>(
                    "custom_game_data",
                    |m: &CPlayer| { &m.custom_game_data },
                    |m: &mut CPlayer| { &mut m.custom_game_data },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "match_player_flags",
                    |m: &CPlayer| { &m.match_player_flags },
                    |m: &mut CPlayer| { &mut m.match_player_flags },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "talent_ability_ids",
                    |m: &CPlayer| { &m.talent_ability_ids },
                    |m: &mut CPlayer| { &mut m.talent_ability_ids },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_pick_order",
                    |m: &CPlayer| { &m.hero_pick_order },
                    |m: &mut CPlayer| { &mut m.hero_pick_order },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_was_randomed",
                    |m: &CPlayer| { &m.hero_was_randomed },
                    |m: &mut CPlayer| { &mut m.hero_was_randomed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_was_dota_plus_suggestion",
                    |m: &CPlayer| { &m.hero_was_dota_plus_suggestion },
                    |m: &mut CPlayer| { &mut m.hero_was_dota_plus_suggestion },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "lane",
                    |m: &CPlayer| { &m.lane },
                    |m: &mut CPlayer| { &mut m.lane },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_using_plus_guide",
                    |m: &CPlayer| { &m.is_using_plus_guide },
                    |m: &mut CPlayer| { &mut m.is_using_plus_guide },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hero_damage_received",
                    |m: &CPlayer| { &m.hero_damage_received },
                    |m: &mut CPlayer| { &mut m.hero_damage_received },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hero_damage_dealt",
                    |m: &CPlayer| { &m.hero_damage_dealt },
                    |m: &mut CPlayer| { &mut m.hero_damage_dealt },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "seconds_dead",
                    |m: &CPlayer| { &m.seconds_dead },
                    |m: &mut CPlayer| { &mut m.seconds_dead },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "gold_lost_to_death",
                    |m: &CPlayer| { &m.gold_lost_to_death },
                    |m: &mut CPlayer| { &mut m.gold_lost_to_death },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "command_count",
                    |m: &CPlayer| { &m.command_count },
                    |m: &mut CPlayer| { &mut m.command_count },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "mouse_click_cast_command_count",
                    |m: &CPlayer| { &m.mouse_click_cast_command_count },
                    |m: &mut CPlayer| { &mut m.mouse_click_cast_command_count },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "teleports_used",
                    |m: &CPlayer| { &m.teleports_used },
                    |m: &mut CPlayer| { &mut m.teleports_used },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "cavern_crawl_preferred_map_variant",
                    |m: &CPlayer| { &m.cavern_crawl_preferred_map_variant },
                    |m: &mut CPlayer| { &mut m.cavern_crawl_preferred_map_variant },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "bounty_runes",
                    |m: &CPlayer| { &m.bounty_runes },
                    |m: &mut CPlayer| { &mut m.bounty_runes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "outposts_captured",
                    |m: &CPlayer| { &m.outposts_captured },
                    |m: &mut CPlayer| { &mut m.outposts_captured },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "dewards",
                    |m: &CPlayer| { &m.dewards },
                    |m: &mut CPlayer| { &mut m.dewards },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "wards_placed",
                    |m: &CPlayer| { &m.wards_placed },
                    |m: &mut CPlayer| { &mut m.wards_placed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "camps_stacked",
                    |m: &CPlayer| { &m.camps_stacked },
                    |m: &mut CPlayer| { &mut m.camps_stacked },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "player_slot",
                    |m: &CPlayer| { &m.player_slot },
                    |m: &mut CPlayer| { &mut m.player_slot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "predicted_position",
                    |m: &CPlayer| { &m.predicted_position },
                    |m: &mut CPlayer| { &mut m.predicted_position },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "lane_outcomes",
                    |m: &CPlayer| { &m.lane_outcomes },
                    |m: &mut CPlayer| { &mut m.lane_outcomes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "friendly_t1_destroyed_time",
                    |m: &CPlayer| { &m.friendly_t1_destroyed_time },
                    |m: &mut CPlayer| { &mut m.friendly_t1_destroyed_time },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "enemy_t1_destroyed_time",
                    |m: &CPlayer| { &m.enemy_t1_destroyed_time },
                    |m: &mut CPlayer| { &mut m.enemy_t1_destroyed_time },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "friendly_roshan_kills",
                    |m: &CPlayer| { &m.friendly_roshan_kills },
                    |m: &mut CPlayer| { &mut m.friendly_roshan_kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "enemy_roshan_kills",
                    |m: &CPlayer| { &m.enemy_roshan_kills },
                    |m: &mut CPlayer| { &mut m.enemy_roshan_kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "power_runes",
                    |m: &CPlayer| { &m.power_runes },
                    |m: &mut CPlayer| { &mut m.power_runes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "water_runes",
                    |m: &CPlayer| { &m.water_runes },
                    |m: &mut CPlayer| { &mut m.water_runes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "stun_duration",
                    |m: &CPlayer| { &m.stun_duration },
                    |m: &mut CPlayer| { &mut m.stun_duration },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_number",
                    |m: &CPlayer| { &m.team_number },
                    |m: &mut CPlayer| { &mut m.team_number },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_slot",
                    |m: &CPlayer| { &m.team_slot },
                    |m: &mut CPlayer| { &mut m.team_slot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "time_purchased_shard",
                    |m: &CPlayer| { &m.time_purchased_shard },
                    |m: &mut CPlayer| { &mut m.time_purchased_shard },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "time_purchased_aghs",
                    |m: &CPlayer| { &m.time_purchased_aghs },
                    |m: &mut CPlayer| { &mut m.time_purchased_aghs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "ability_draft_abilities",
                    |m: &CPlayer| { &m.ability_draft_abilities },
                    |m: &mut CPlayer| { &mut m.ability_draft_abilities },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPlayer>(
                    "CMsgGameMatchSignOut.CTeam.CPlayer",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CPlayer {
            const NAME: &'static str = "CPlayer";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        9 => {
                            self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                        },
                        24 => {
                            self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        34 => {
                            is.read_repeated_packed_int32_into(&mut self.items)?;
                        },
                        32 => {
                            self.items.push(is.read_int32()?);
                        },
                        506 => {
                            is.read_repeated_packed_uint32_into(&mut self.item_purchase_times)?;
                        },
                        504 => {
                            self.item_purchase_times.push(is.read_uint32()?);
                        },
                        40 => {
                            self.gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        56 => {
                            self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.assists = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.leaver_status = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        80 => {
                            self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        88 => {
                            self.denies = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        96 => {
                            self.gold_per_min = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        104 => {
                            self.xp_per_minute = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        112 => {
                            self.gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        120 => {
                            self.level = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        128 => {
                            self.scaled_hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        136 => {
                            self.scaled_tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        144 => {
                            self.scaled_hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        152 => {
                            self.time_last_seen = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        160 => {
                            self.support_ability_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        168 => {
                            self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        216 => {
                            self.claimed_farm_gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        224 => {
                            self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        232 => {
                            self.claimed_denies = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        240 => {
                            self.claimed_misses = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        248 => {
                            self.misses = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        272 => {
                            self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        296 => {
                            self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        304 => {
                            self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        312 => {
                            self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        258 => {
                            self.ability_upgrades.push(is.read_message()?);
                        },
                        266 => {
                            self.additional_units_inventory.push(is.read_message()?);
                        },
                        322 => {
                            self.permanent_buffs.push(is.read_message()?);
                        },
                        282 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                        },
                        288 => {
                            self.match_player_flags = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        330 => {
                            is.read_repeated_packed_int32_into(&mut self.talent_ability_ids)?;
                        },
                        328 => {
                            self.talent_ability_ids.push(is.read_int32()?);
                        },
                        336 => {
                            self.hero_pick_order = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        344 => {
                            self.hero_was_randomed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        400 => {
                            self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(is.read_bool()?);
                        },
                        360 => {
                            self.lane = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        376 => {
                            self.is_using_plus_guide = ::std::option::Option::Some(is.read_bool()?);
                        },
                        386 => {
                            self.hero_damage_received.push(is.read_message()?);
                        },
                        514 => {
                            self.hero_damage_dealt.push(is.read_message()?);
                        },
                        408 => {
                            self.seconds_dead = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        416 => {
                            self.gold_lost_to_death = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        424 => {
                            self.command_count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        432 => {
                            self.mouse_click_cast_command_count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        440 => {
                            self.teleports_used = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        448 => {
                            self.cavern_crawl_preferred_map_variant = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        456 => {
                            self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        464 => {
                            self.outposts_captured = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        472 => {
                            self.dewards = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        480 => {
                            self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        488 => {
                            self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        496 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        528 => {
                            self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        536 => {
                            self.lane_outcomes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        544 => {
                            self.friendly_t1_destroyed_time = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        552 => {
                            self.enemy_t1_destroyed_time = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        560 => {
                            self.friendly_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        568 => {
                            self.enemy_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        576 => {
                            self.power_runes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        584 => {
                            self.water_runes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        597 => {
                            self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                        },
                        600 => {
                            self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        608 => {
                            self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        616 => {
                            self.time_purchased_shard = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        624 => {
                            self.time_purchased_aghs = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        634 => {
                            is.read_repeated_packed_int32_into(&mut self.ability_draft_abilities)?;
                        },
                        632 => {
                            self.ability_draft_abilities.push(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.steam_id {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.hero_id {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                for value in &self.items {
                    my_size += ::protobuf::rt::int32_size(4, *value);
                };
                for value in &self.item_purchase_times {
                    my_size += ::protobuf::rt::uint32_size(63, *value);
                };
                if let Some(v) = self.gold {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.kills {
                    my_size += ::protobuf::rt::uint32_size(6, v);
                }
                if let Some(v) = self.deaths {
                    my_size += ::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.assists {
                    my_size += ::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.leaver_status {
                    my_size += ::protobuf::rt::uint32_size(9, v);
                }
                if let Some(v) = self.last_hits {
                    my_size += ::protobuf::rt::uint32_size(10, v);
                }
                if let Some(v) = self.denies {
                    my_size += ::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.gold_per_min {
                    my_size += ::protobuf::rt::uint32_size(12, v);
                }
                if let Some(v) = self.xp_per_minute {
                    my_size += ::protobuf::rt::uint32_size(13, v);
                }
                if let Some(v) = self.gold_spent {
                    my_size += ::protobuf::rt::uint32_size(14, v);
                }
                if let Some(v) = self.level {
                    my_size += ::protobuf::rt::uint32_size(15, v);
                }
                if let Some(v) = self.scaled_hero_damage {
                    my_size += ::protobuf::rt::uint32_size(16, v);
                }
                if let Some(v) = self.scaled_tower_damage {
                    my_size += ::protobuf::rt::uint32_size(17, v);
                }
                if let Some(v) = self.scaled_hero_healing {
                    my_size += ::protobuf::rt::uint32_size(18, v);
                }
                if let Some(v) = self.time_last_seen {
                    my_size += ::protobuf::rt::uint32_size(19, v);
                }
                if let Some(v) = self.support_ability_value {
                    my_size += ::protobuf::rt::uint32_size(20, v);
                }
                if let Some(v) = self.party_id {
                    my_size += ::protobuf::rt::uint64_size(21, v);
                }
                if let Some(v) = self.claimed_farm_gold {
                    my_size += ::protobuf::rt::uint32_size(27, v);
                }
                if let Some(v) = self.support_gold {
                    my_size += ::protobuf::rt::uint32_size(28, v);
                }
                if let Some(v) = self.claimed_denies {
                    my_size += ::protobuf::rt::uint32_size(29, v);
                }
                if let Some(v) = self.claimed_misses {
                    my_size += ::protobuf::rt::uint32_size(30, v);
                }
                if let Some(v) = self.misses {
                    my_size += ::protobuf::rt::uint32_size(31, v);
                }
                if let Some(v) = self.net_worth {
                    my_size += ::protobuf::rt::uint32_size(34, v);
                }
                if let Some(v) = self.hero_damage {
                    my_size += ::protobuf::rt::uint32_size(37, v);
                }
                if let Some(v) = self.tower_damage {
                    my_size += ::protobuf::rt::uint32_size(38, v);
                }
                if let Some(v) = self.hero_healing {
                    my_size += ::protobuf::rt::uint32_size(39, v);
                }
                for value in &self.ability_upgrades {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.additional_units_inventory {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.permanent_buffs {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.custom_game_data.as_ref() {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.match_player_flags {
                    my_size += ::protobuf::rt::uint32_size(36, v);
                }
                for value in &self.talent_ability_ids {
                    my_size += ::protobuf::rt::int32_size(41, *value);
                };
                if let Some(v) = self.hero_pick_order {
                    my_size += ::protobuf::rt::uint32_size(42, v);
                }
                if let Some(v) = self.hero_was_randomed {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.hero_was_dota_plus_suggestion {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.lane {
                    my_size += ::protobuf::rt::uint32_size(45, v);
                }
                if let Some(v) = self.is_using_plus_guide {
                    my_size += 2 + 1;
                }
                for value in &self.hero_damage_received {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.hero_damage_dealt {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.seconds_dead {
                    my_size += ::protobuf::rt::uint32_size(51, v);
                }
                if let Some(v) = self.gold_lost_to_death {
                    my_size += ::protobuf::rt::uint32_size(52, v);
                }
                if let Some(v) = self.command_count {
                    my_size += ::protobuf::rt::uint32_size(53, v);
                }
                if let Some(v) = self.mouse_click_cast_command_count {
                    my_size += ::protobuf::rt::uint32_size(54, v);
                }
                if let Some(v) = self.teleports_used {
                    my_size += ::protobuf::rt::uint32_size(55, v);
                }
                if let Some(v) = self.cavern_crawl_preferred_map_variant {
                    my_size += ::protobuf::rt::uint32_size(56, v);
                }
                if let Some(v) = self.bounty_runes {
                    my_size += ::protobuf::rt::uint32_size(57, v);
                }
                if let Some(v) = self.outposts_captured {
                    my_size += ::protobuf::rt::uint32_size(58, v);
                }
                if let Some(v) = self.dewards {
                    my_size += ::protobuf::rt::uint32_size(59, v);
                }
                if let Some(v) = self.wards_placed {
                    my_size += ::protobuf::rt::uint32_size(60, v);
                }
                if let Some(v) = self.camps_stacked {
                    my_size += ::protobuf::rt::uint32_size(61, v);
                }
                if let Some(v) = self.player_slot {
                    my_size += ::protobuf::rt::uint32_size(62, v);
                }
                if let Some(v) = self.predicted_position {
                    my_size += ::protobuf::rt::uint32_size(66, v);
                }
                if let Some(v) = self.lane_outcomes {
                    my_size += ::protobuf::rt::uint32_size(67, v);
                }
                if let Some(v) = self.friendly_t1_destroyed_time {
                    my_size += ::protobuf::rt::uint32_size(68, v);
                }
                if let Some(v) = self.enemy_t1_destroyed_time {
                    my_size += ::protobuf::rt::uint32_size(69, v);
                }
                if let Some(v) = self.friendly_roshan_kills {
                    my_size += ::protobuf::rt::uint32_size(70, v);
                }
                if let Some(v) = self.enemy_roshan_kills {
                    my_size += ::protobuf::rt::uint32_size(71, v);
                }
                if let Some(v) = self.power_runes {
                    my_size += ::protobuf::rt::uint32_size(72, v);
                }
                if let Some(v) = self.water_runes {
                    my_size += ::protobuf::rt::uint32_size(73, v);
                }
                if let Some(v) = self.stun_duration {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.team_number {
                    my_size += ::protobuf::rt::int32_size(75, v.value());
                }
                if let Some(v) = self.team_slot {
                    my_size += ::protobuf::rt::uint32_size(76, v);
                }
                if let Some(v) = self.time_purchased_shard {
                    my_size += ::protobuf::rt::uint32_size(77, v);
                }
                if let Some(v) = self.time_purchased_aghs {
                    my_size += ::protobuf::rt::uint32_size(78, v);
                }
                for value in &self.ability_draft_abilities {
                    my_size += ::protobuf::rt::int32_size(79, *value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.steam_id {
                    os.write_fixed64(1, v)?;
                }
                if let Some(v) = self.hero_id {
                    os.write_uint32(3, v)?;
                }
                for v in &self.items {
                    os.write_int32(4, *v)?;
                };
                for v in &self.item_purchase_times {
                    os.write_uint32(63, *v)?;
                };
                if let Some(v) = self.gold {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.kills {
                    os.write_uint32(6, v)?;
                }
                if let Some(v) = self.deaths {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.assists {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.leaver_status {
                    os.write_uint32(9, v)?;
                }
                if let Some(v) = self.last_hits {
                    os.write_uint32(10, v)?;
                }
                if let Some(v) = self.denies {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.gold_per_min {
                    os.write_uint32(12, v)?;
                }
                if let Some(v) = self.xp_per_minute {
                    os.write_uint32(13, v)?;
                }
                if let Some(v) = self.gold_spent {
                    os.write_uint32(14, v)?;
                }
                if let Some(v) = self.level {
                    os.write_uint32(15, v)?;
                }
                if let Some(v) = self.scaled_hero_damage {
                    os.write_uint32(16, v)?;
                }
                if let Some(v) = self.scaled_tower_damage {
                    os.write_uint32(17, v)?;
                }
                if let Some(v) = self.scaled_hero_healing {
                    os.write_uint32(18, v)?;
                }
                if let Some(v) = self.time_last_seen {
                    os.write_uint32(19, v)?;
                }
                if let Some(v) = self.support_ability_value {
                    os.write_uint32(20, v)?;
                }
                if let Some(v) = self.party_id {
                    os.write_uint64(21, v)?;
                }
                if let Some(v) = self.claimed_farm_gold {
                    os.write_uint32(27, v)?;
                }
                if let Some(v) = self.support_gold {
                    os.write_uint32(28, v)?;
                }
                if let Some(v) = self.claimed_denies {
                    os.write_uint32(29, v)?;
                }
                if let Some(v) = self.claimed_misses {
                    os.write_uint32(30, v)?;
                }
                if let Some(v) = self.misses {
                    os.write_uint32(31, v)?;
                }
                if let Some(v) = self.net_worth {
                    os.write_uint32(34, v)?;
                }
                if let Some(v) = self.hero_damage {
                    os.write_uint32(37, v)?;
                }
                if let Some(v) = self.tower_damage {
                    os.write_uint32(38, v)?;
                }
                if let Some(v) = self.hero_healing {
                    os.write_uint32(39, v)?;
                }
                for v in &self.ability_upgrades {
                    ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
                };
                for v in &self.additional_units_inventory {
                    ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
                };
                for v in &self.permanent_buffs {
                    ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
                };
                if let Some(v) = self.custom_game_data.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
                }
                if let Some(v) = self.match_player_flags {
                    os.write_uint32(36, v)?;
                }
                for v in &self.talent_ability_ids {
                    os.write_int32(41, *v)?;
                };
                if let Some(v) = self.hero_pick_order {
                    os.write_uint32(42, v)?;
                }
                if let Some(v) = self.hero_was_randomed {
                    os.write_bool(43, v)?;
                }
                if let Some(v) = self.hero_was_dota_plus_suggestion {
                    os.write_bool(50, v)?;
                }
                if let Some(v) = self.lane {
                    os.write_uint32(45, v)?;
                }
                if let Some(v) = self.is_using_plus_guide {
                    os.write_bool(47, v)?;
                }
                for v in &self.hero_damage_received {
                    ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
                };
                for v in &self.hero_damage_dealt {
                    ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
                };
                if let Some(v) = self.seconds_dead {
                    os.write_uint32(51, v)?;
                }
                if let Some(v) = self.gold_lost_to_death {
                    os.write_uint32(52, v)?;
                }
                if let Some(v) = self.command_count {
                    os.write_uint32(53, v)?;
                }
                if let Some(v) = self.mouse_click_cast_command_count {
                    os.write_uint32(54, v)?;
                }
                if let Some(v) = self.teleports_used {
                    os.write_uint32(55, v)?;
                }
                if let Some(v) = self.cavern_crawl_preferred_map_variant {
                    os.write_uint32(56, v)?;
                }
                if let Some(v) = self.bounty_runes {
                    os.write_uint32(57, v)?;
                }
                if let Some(v) = self.outposts_captured {
                    os.write_uint32(58, v)?;
                }
                if let Some(v) = self.dewards {
                    os.write_uint32(59, v)?;
                }
                if let Some(v) = self.wards_placed {
                    os.write_uint32(60, v)?;
                }
                if let Some(v) = self.camps_stacked {
                    os.write_uint32(61, v)?;
                }
                if let Some(v) = self.player_slot {
                    os.write_uint32(62, v)?;
                }
                if let Some(v) = self.predicted_position {
                    os.write_uint32(66, v)?;
                }
                if let Some(v) = self.lane_outcomes {
                    os.write_uint32(67, v)?;
                }
                if let Some(v) = self.friendly_t1_destroyed_time {
                    os.write_uint32(68, v)?;
                }
                if let Some(v) = self.enemy_t1_destroyed_time {
                    os.write_uint32(69, v)?;
                }
                if let Some(v) = self.friendly_roshan_kills {
                    os.write_uint32(70, v)?;
                }
                if let Some(v) = self.enemy_roshan_kills {
                    os.write_uint32(71, v)?;
                }
                if let Some(v) = self.power_runes {
                    os.write_uint32(72, v)?;
                }
                if let Some(v) = self.water_runes {
                    os.write_uint32(73, v)?;
                }
                if let Some(v) = self.stun_duration {
                    os.write_float(74, v)?;
                }
                if let Some(v) = self.team_number {
                    os.write_enum(75, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.team_slot {
                    os.write_uint32(76, v)?;
                }
                if let Some(v) = self.time_purchased_shard {
                    os.write_uint32(77, v)?;
                }
                if let Some(v) = self.time_purchased_aghs {
                    os.write_uint32(78, v)?;
                }
                for v in &self.ability_draft_abilities {
                    os.write_int32(79, *v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CPlayer {
                CPlayer::new()
            }

            fn clear(&mut self) {
                self.steam_id = ::std::option::Option::None;
                self.hero_id = ::std::option::Option::None;
                self.items.clear();
                self.item_purchase_times.clear();
                self.gold = ::std::option::Option::None;
                self.kills = ::std::option::Option::None;
                self.deaths = ::std::option::Option::None;
                self.assists = ::std::option::Option::None;
                self.leaver_status = ::std::option::Option::None;
                self.last_hits = ::std::option::Option::None;
                self.denies = ::std::option::Option::None;
                self.gold_per_min = ::std::option::Option::None;
                self.xp_per_minute = ::std::option::Option::None;
                self.gold_spent = ::std::option::Option::None;
                self.level = ::std::option::Option::None;
                self.scaled_hero_damage = ::std::option::Option::None;
                self.scaled_tower_damage = ::std::option::Option::None;
                self.scaled_hero_healing = ::std::option::Option::None;
                self.time_last_seen = ::std::option::Option::None;
                self.support_ability_value = ::std::option::Option::None;
                self.party_id = ::std::option::Option::None;
                self.claimed_farm_gold = ::std::option::Option::None;
                self.support_gold = ::std::option::Option::None;
                self.claimed_denies = ::std::option::Option::None;
                self.claimed_misses = ::std::option::Option::None;
                self.misses = ::std::option::Option::None;
                self.net_worth = ::std::option::Option::None;
                self.hero_damage = ::std::option::Option::None;
                self.tower_damage = ::std::option::Option::None;
                self.hero_healing = ::std::option::Option::None;
                self.ability_upgrades.clear();
                self.additional_units_inventory.clear();
                self.permanent_buffs.clear();
                self.custom_game_data.clear();
                self.match_player_flags = ::std::option::Option::None;
                self.talent_ability_ids.clear();
                self.hero_pick_order = ::std::option::Option::None;
                self.hero_was_randomed = ::std::option::Option::None;
                self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
                self.lane = ::std::option::Option::None;
                self.is_using_plus_guide = ::std::option::Option::None;
                self.hero_damage_received.clear();
                self.hero_damage_dealt.clear();
                self.seconds_dead = ::std::option::Option::None;
                self.gold_lost_to_death = ::std::option::Option::None;
                self.command_count = ::std::option::Option::None;
                self.mouse_click_cast_command_count = ::std::option::Option::None;
                self.teleports_used = ::std::option::Option::None;
                self.cavern_crawl_preferred_map_variant = ::std::option::Option::None;
                self.bounty_runes = ::std::option::Option::None;
                self.outposts_captured = ::std::option::Option::None;
                self.dewards = ::std::option::Option::None;
                self.wards_placed = ::std::option::Option::None;
                self.camps_stacked = ::std::option::Option::None;
                self.player_slot = ::std::option::Option::None;
                self.predicted_position = ::std::option::Option::None;
                self.lane_outcomes = ::std::option::Option::None;
                self.friendly_t1_destroyed_time = ::std::option::Option::None;
                self.enemy_t1_destroyed_time = ::std::option::Option::None;
                self.friendly_roshan_kills = ::std::option::Option::None;
                self.enemy_roshan_kills = ::std::option::Option::None;
                self.power_runes = ::std::option::Option::None;
                self.water_runes = ::std::option::Option::None;
                self.stun_duration = ::std::option::Option::None;
                self.team_number = ::std::option::Option::None;
                self.team_slot = ::std::option::Option::None;
                self.time_purchased_shard = ::std::option::Option::None;
                self.time_purchased_aghs = ::std::option::Option::None;
                self.ability_draft_abilities.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CPlayer {
                static instance: CPlayer = CPlayer {
                    steam_id: ::std::option::Option::None,
                    hero_id: ::std::option::Option::None,
                    items: ::std::vec::Vec::new(),
                    item_purchase_times: ::std::vec::Vec::new(),
                    gold: ::std::option::Option::None,
                    kills: ::std::option::Option::None,
                    deaths: ::std::option::Option::None,
                    assists: ::std::option::Option::None,
                    leaver_status: ::std::option::Option::None,
                    last_hits: ::std::option::Option::None,
                    denies: ::std::option::Option::None,
                    gold_per_min: ::std::option::Option::None,
                    xp_per_minute: ::std::option::Option::None,
                    gold_spent: ::std::option::Option::None,
                    level: ::std::option::Option::None,
                    scaled_hero_damage: ::std::option::Option::None,
                    scaled_tower_damage: ::std::option::Option::None,
                    scaled_hero_healing: ::std::option::Option::None,
                    time_last_seen: ::std::option::Option::None,
                    support_ability_value: ::std::option::Option::None,
                    party_id: ::std::option::Option::None,
                    claimed_farm_gold: ::std::option::Option::None,
                    support_gold: ::std::option::Option::None,
                    claimed_denies: ::std::option::Option::None,
                    claimed_misses: ::std::option::Option::None,
                    misses: ::std::option::Option::None,
                    net_worth: ::std::option::Option::None,
                    hero_damage: ::std::option::Option::None,
                    tower_damage: ::std::option::Option::None,
                    hero_healing: ::std::option::Option::None,
                    ability_upgrades: ::std::vec::Vec::new(),
                    additional_units_inventory: ::std::vec::Vec::new(),
                    permanent_buffs: ::std::vec::Vec::new(),
                    custom_game_data: ::protobuf::MessageField::none(),
                    match_player_flags: ::std::option::Option::None,
                    talent_ability_ids: ::std::vec::Vec::new(),
                    hero_pick_order: ::std::option::Option::None,
                    hero_was_randomed: ::std::option::Option::None,
                    hero_was_dota_plus_suggestion: ::std::option::Option::None,
                    lane: ::std::option::Option::None,
                    is_using_plus_guide: ::std::option::Option::None,
                    hero_damage_received: ::std::vec::Vec::new(),
                    hero_damage_dealt: ::std::vec::Vec::new(),
                    seconds_dead: ::std::option::Option::None,
                    gold_lost_to_death: ::std::option::Option::None,
                    command_count: ::std::option::Option::None,
                    mouse_click_cast_command_count: ::std::option::Option::None,
                    teleports_used: ::std::option::Option::None,
                    cavern_crawl_preferred_map_variant: ::std::option::Option::None,
                    bounty_runes: ::std::option::Option::None,
                    outposts_captured: ::std::option::Option::None,
                    dewards: ::std::option::Option::None,
                    wards_placed: ::std::option::Option::None,
                    camps_stacked: ::std::option::Option::None,
                    player_slot: ::std::option::Option::None,
                    predicted_position: ::std::option::Option::None,
                    lane_outcomes: ::std::option::Option::None,
                    friendly_t1_destroyed_time: ::std::option::Option::None,
                    enemy_t1_destroyed_time: ::std::option::Option::None,
                    friendly_roshan_kills: ::std::option::Option::None,
                    enemy_roshan_kills: ::std::option::Option::None,
                    power_runes: ::std::option::Option::None,
                    water_runes: ::std::option::Option::None,
                    stun_duration: ::std::option::Option::None,
                    team_number: ::std::option::Option::None,
                    team_slot: ::std::option::Option::None,
                    time_purchased_shard: ::std::option::Option::None,
                    time_purchased_aghs: ::std::option::Option::None,
                    ability_draft_abilities: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CPlayer {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.CTeam.CPlayer").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CPlayer {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CPlayer {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `CPlayer`
        pub mod cplayer {
            // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct CCustomGameData {
                // message fields
                // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData.dota_team)
                pub dota_team: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData.winner)
                pub winner: ::std::option::Option<bool>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a CCustomGameData {
                fn default() -> &'a CCustomGameData {
                    <CCustomGameData as ::protobuf::Message>::default_instance()
                }
            }

            impl CCustomGameData {
                pub fn new() -> CCustomGameData {
                    ::std::default::Default::default()
                }

                // optional uint32 dota_team = 1;

                pub fn dota_team(&self) -> u32 {
                    self.dota_team.unwrap_or(0)
                }

                pub fn clear_dota_team(&mut self) {
                    self.dota_team = ::std::option::Option::None;
                }

                pub fn has_dota_team(&self) -> bool {
                    self.dota_team.is_some()
                }

                // Param is passed by value, moved
                pub fn set_dota_team(&mut self, v: u32) {
                    self.dota_team = ::std::option::Option::Some(v);
                }

                // optional bool winner = 2;

                pub fn winner(&self) -> bool {
                    self.winner.unwrap_or(false)
                }

                pub fn clear_winner(&mut self) {
                    self.winner = ::std::option::Option::None;
                }

                pub fn has_winner(&self) -> bool {
                    self.winner.is_some()
                }

                // Param is passed by value, moved
                pub fn set_winner(&mut self, v: bool) {
                    self.winner = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(2);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "dota_team",
                        |m: &CCustomGameData| { &m.dota_team },
                        |m: &mut CCustomGameData| { &mut m.dota_team },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "winner",
                        |m: &CCustomGameData| { &m.winner },
                        |m: &mut CCustomGameData| { &mut m.winner },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCustomGameData>(
                        "CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for CCustomGameData {
                const NAME: &'static str = "CCustomGameData";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.winner = ::std::option::Option::Some(is.read_bool()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.dota_team {
                        my_size += ::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.winner {
                        my_size += 1 + 1;
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.dota_team {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.winner {
                        os.write_bool(2, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> CCustomGameData {
                    CCustomGameData::new()
                }

                fn clear(&mut self) {
                    self.dota_team = ::std::option::Option::None;
                    self.winner = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static CCustomGameData {
                    static instance: CCustomGameData = CCustomGameData {
                        dota_team: ::std::option::Option::None,
                        winner: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for CCustomGameData {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for CCustomGameData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for CCustomGameData {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct HeroDamageReceived {
                // message fields
                // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.pre_reduction)
                pub pre_reduction: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.post_reduction)
                pub post_reduction: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.damage_type)
                pub damage_type: ::std::option::Option<::protobuf::EnumOrUnknown<HeroDamageType>>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a HeroDamageReceived {
                fn default() -> &'a HeroDamageReceived {
                    <HeroDamageReceived as ::protobuf::Message>::default_instance()
                }
            }

            impl HeroDamageReceived {
                pub fn new() -> HeroDamageReceived {
                    ::std::default::Default::default()
                }

                // optional uint32 pre_reduction = 1;

                pub fn pre_reduction(&self) -> u32 {
                    self.pre_reduction.unwrap_or(0)
                }

                pub fn clear_pre_reduction(&mut self) {
                    self.pre_reduction = ::std::option::Option::None;
                }

                pub fn has_pre_reduction(&self) -> bool {
                    self.pre_reduction.is_some()
                }

                // Param is passed by value, moved
                pub fn set_pre_reduction(&mut self, v: u32) {
                    self.pre_reduction = ::std::option::Option::Some(v);
                }

                // optional uint32 post_reduction = 2;

                pub fn post_reduction(&self) -> u32 {
                    self.post_reduction.unwrap_or(0)
                }

                pub fn clear_post_reduction(&mut self) {
                    self.post_reduction = ::std::option::Option::None;
                }

                pub fn has_post_reduction(&self) -> bool {
                    self.post_reduction.is_some()
                }

                // Param is passed by value, moved
                pub fn set_post_reduction(&mut self, v: u32) {
                    self.post_reduction = ::std::option::Option::Some(v);
                }

                // optional .dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType damage_type = 3;

                pub fn damage_type(&self) -> HeroDamageType {
                    match self.damage_type {
                        Some(e) => e.enum_value_or(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                        None => HeroDamageType::HERO_DAMAGE_PHYSICAL,
                    }
                }

                pub fn clear_damage_type(&mut self) {
                    self.damage_type = ::std::option::Option::None;
                }

                pub fn has_damage_type(&self) -> bool {
                    self.damage_type.is_some()
                }

                // Param is passed by value, moved
                pub fn set_damage_type(&mut self, v: HeroDamageType) {
                    self.damage_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(3);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "pre_reduction",
                        |m: &HeroDamageReceived| { &m.pre_reduction },
                        |m: &mut HeroDamageReceived| { &mut m.pre_reduction },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "post_reduction",
                        |m: &HeroDamageReceived| { &m.post_reduction },
                        |m: &mut HeroDamageReceived| { &mut m.post_reduction },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "damage_type",
                        |m: &HeroDamageReceived| { &m.damage_type },
                        |m: &mut HeroDamageReceived| { &mut m.damage_type },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroDamageReceived>(
                        "CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for HeroDamageReceived {
                const NAME: &'static str = "HeroDamageReceived";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.pre_reduction = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.post_reduction = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.damage_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.pre_reduction {
                        my_size += ::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.post_reduction {
                        my_size += ::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.damage_type {
                        my_size += ::protobuf::rt::int32_size(3, v.value());
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.pre_reduction {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.post_reduction {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.damage_type {
                        os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> HeroDamageReceived {
                    HeroDamageReceived::new()
                }

                fn clear(&mut self) {
                    self.pre_reduction = ::std::option::Option::None;
                    self.post_reduction = ::std::option::Option::None;
                    self.damage_type = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static HeroDamageReceived {
                    static instance: HeroDamageReceived = HeroDamageReceived {
                        pre_reduction: ::std::option::Option::None,
                        post_reduction: ::std::option::Option::None,
                        damage_type: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for HeroDamageReceived {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for HeroDamageReceived {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for HeroDamageReceived {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType)
            pub enum HeroDamageType {
                // @@protoc_insertion_point(enum_value:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType.HERO_DAMAGE_PHYSICAL)
                HERO_DAMAGE_PHYSICAL = 0,
                // @@protoc_insertion_point(enum_value:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType.HERO_DAMAGE_MAGICAL)
                HERO_DAMAGE_MAGICAL = 1,
                // @@protoc_insertion_point(enum_value:dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType.HERO_DAMAGE_PURE)
                HERO_DAMAGE_PURE = 2,
            }

            impl ::protobuf::Enum for HeroDamageType {
                const NAME: &'static str = "HeroDamageType";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<HeroDamageType> {
                    match value {
                        0 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                        1 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                        2 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<HeroDamageType> {
                    match str {
                        "HERO_DAMAGE_PHYSICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                        "HERO_DAMAGE_MAGICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                        "HERO_DAMAGE_PURE" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [HeroDamageType] = &[
                    HeroDamageType::HERO_DAMAGE_PHYSICAL,
                    HeroDamageType::HERO_DAMAGE_MAGICAL,
                    HeroDamageType::HERO_DAMAGE_PURE,
                ];
            }

            impl ::protobuf::EnumFull for HeroDamageType {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for HeroDamageType {
                fn default() -> Self {
                    HeroDamageType::HERO_DAMAGE_PHYSICAL
                }
            }

            impl HeroDamageType {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HeroDamageType>("CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType")
                }
            }
        }
    }

    // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.CAdditionalSignoutMsg)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CAdditionalSignoutMsg {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CAdditionalSignoutMsg.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CAdditionalSignoutMsg.contents)
        pub contents: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.CAdditionalSignoutMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CAdditionalSignoutMsg {
        fn default() -> &'a CAdditionalSignoutMsg {
            <CAdditionalSignoutMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl CAdditionalSignoutMsg {
        pub fn new() -> CAdditionalSignoutMsg {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional bytes contents = 2;

        pub fn contents(&self) -> &[u8] {
            match self.contents.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_contents(&mut self) {
            self.contents = ::std::option::Option::None;
        }

        pub fn has_contents(&self) -> bool {
            self.contents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
            self.contents = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.contents.is_none() {
                self.contents = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.contents.as_mut().unwrap()
        }

        // Take field
        pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
            self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &CAdditionalSignoutMsg| { &m.id },
                |m: &mut CAdditionalSignoutMsg| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "contents",
                |m: &CAdditionalSignoutMsg| { &m.contents },
                |m: &mut CAdditionalSignoutMsg| { &mut m.contents },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAdditionalSignoutMsg>(
                "CMsgGameMatchSignOut.CAdditionalSignoutMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CAdditionalSignoutMsg {
        const NAME: &'static str = "CAdditionalSignoutMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.contents = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.contents.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.contents.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CAdditionalSignoutMsg {
            CAdditionalSignoutMsg::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.contents = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CAdditionalSignoutMsg {
            static instance: CAdditionalSignoutMsg = CAdditionalSignoutMsg {
                id: ::std::option::Option::None,
                contents: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CAdditionalSignoutMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.CAdditionalSignoutMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CAdditionalSignoutMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CAdditionalSignoutMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.CSocialFeedMatchEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CSocialFeedMatchEvent {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CSocialFeedMatchEvent.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CSocialFeedMatchEvent.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CSocialFeedMatchEvent.event_type)
        pub event_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CSocialFeedMatchEvent.game_time)
        pub game_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CSocialFeedMatchEvent.replay_time)
        pub replay_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.CSocialFeedMatchEvent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CSocialFeedMatchEvent {
        fn default() -> &'a CSocialFeedMatchEvent {
            <CSocialFeedMatchEvent as ::protobuf::Message>::default_instance()
        }
    }

    impl CSocialFeedMatchEvent {
        pub fn new() -> CSocialFeedMatchEvent {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 event_type = 3;

        pub fn event_type(&self) -> u32 {
            self.event_type.unwrap_or(0)
        }

        pub fn clear_event_type(&mut self) {
            self.event_type = ::std::option::Option::None;
        }

        pub fn has_event_type(&self) -> bool {
            self.event_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_type(&mut self, v: u32) {
            self.event_type = ::std::option::Option::Some(v);
        }

        // optional int32 game_time = 4;

        pub fn game_time(&self) -> i32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: i32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 replay_time = 5;

        pub fn replay_time(&self) -> u32 {
            self.replay_time.unwrap_or(0)
        }

        pub fn clear_replay_time(&mut self) {
            self.replay_time = ::std::option::Option::None;
        }

        pub fn has_replay_time(&self) -> bool {
            self.replay_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_replay_time(&mut self, v: u32) {
            self.replay_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &CSocialFeedMatchEvent| { &m.account_id },
                |m: &mut CSocialFeedMatchEvent| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &CSocialFeedMatchEvent| { &m.timestamp },
                |m: &mut CSocialFeedMatchEvent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_type",
                |m: &CSocialFeedMatchEvent| { &m.event_type },
                |m: &mut CSocialFeedMatchEvent| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_time",
                |m: &CSocialFeedMatchEvent| { &m.game_time },
                |m: &mut CSocialFeedMatchEvent| { &mut m.game_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "replay_time",
                |m: &CSocialFeedMatchEvent| { &m.replay_time },
                |m: &mut CSocialFeedMatchEvent| { &mut m.replay_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSocialFeedMatchEvent>(
                "CMsgGameMatchSignOut.CSocialFeedMatchEvent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CSocialFeedMatchEvent {
        const NAME: &'static str = "CSocialFeedMatchEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.replay_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.event_type {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.replay_time {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.event_type {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.replay_time {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CSocialFeedMatchEvent {
            CSocialFeedMatchEvent::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.event_type = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.replay_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CSocialFeedMatchEvent {
            static instance: CSocialFeedMatchEvent = CSocialFeedMatchEvent {
                account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                event_type: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                replay_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CSocialFeedMatchEvent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.CSocialFeedMatchEvent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CSocialFeedMatchEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CSocialFeedMatchEvent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.CCustomGameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CCustomGameData {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.CCustomGameData.publish_timestamp)
        pub publish_timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.CCustomGameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CCustomGameData {
        fn default() -> &'a CCustomGameData {
            <CCustomGameData as ::protobuf::Message>::default_instance()
        }
    }

    impl CCustomGameData {
        pub fn new() -> CCustomGameData {
            ::std::default::Default::default()
        }

        // optional uint32 publish_timestamp = 1;

        pub fn publish_timestamp(&self) -> u32 {
            self.publish_timestamp.unwrap_or(0)
        }

        pub fn clear_publish_timestamp(&mut self) {
            self.publish_timestamp = ::std::option::Option::None;
        }

        pub fn has_publish_timestamp(&self) -> bool {
            self.publish_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_publish_timestamp(&mut self, v: u32) {
            self.publish_timestamp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "publish_timestamp",
                |m: &CCustomGameData| { &m.publish_timestamp },
                |m: &mut CCustomGameData| { &mut m.publish_timestamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCustomGameData>(
                "CMsgGameMatchSignOut.CCustomGameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CCustomGameData {
        const NAME: &'static str = "CCustomGameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.publish_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.publish_timestamp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.publish_timestamp {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CCustomGameData {
            CCustomGameData::new()
        }

        fn clear(&mut self) {
            self.publish_timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CCustomGameData {
            static instance: CCustomGameData = CCustomGameData {
                publish_timestamp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CCustomGameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.CCustomGameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CCustomGameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CCustomGameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventGameLeaderboardEntry {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.name_suffix)
        pub name_suffix: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.score)
        pub score: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_1)
        pub extra_data_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_2)
        pub extra_data_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_3)
        pub extra_data_3: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_4)
        pub extra_data_4: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_5)
        pub extra_data_5: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.EventGameLeaderboardEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventGameLeaderboardEntry {
        fn default() -> &'a EventGameLeaderboardEntry {
            <EventGameLeaderboardEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl EventGameLeaderboardEntry {
        pub fn new() -> EventGameLeaderboardEntry {
            ::std::default::Default::default()
        }

        // optional string name_suffix = 1;

        pub fn name_suffix(&self) -> &str {
            match self.name_suffix.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_suffix(&mut self) {
            self.name_suffix = ::std::option::Option::None;
        }

        pub fn has_name_suffix(&self) -> bool {
            self.name_suffix.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_suffix(&mut self, v: ::std::string::String) {
            self.name_suffix = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_suffix(&mut self) -> &mut ::std::string::String {
            if self.name_suffix.is_none() {
                self.name_suffix = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_suffix.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_suffix(&mut self) -> ::std::string::String {
            self.name_suffix.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 score = 2;

        pub fn score(&self) -> i32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: i32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_1 = 3;

        pub fn extra_data_1(&self) -> u32 {
            self.extra_data_1.unwrap_or(0)
        }

        pub fn clear_extra_data_1(&mut self) {
            self.extra_data_1 = ::std::option::Option::None;
        }

        pub fn has_extra_data_1(&self) -> bool {
            self.extra_data_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_1(&mut self, v: u32) {
            self.extra_data_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_2 = 4;

        pub fn extra_data_2(&self) -> u32 {
            self.extra_data_2.unwrap_or(0)
        }

        pub fn clear_extra_data_2(&mut self) {
            self.extra_data_2 = ::std::option::Option::None;
        }

        pub fn has_extra_data_2(&self) -> bool {
            self.extra_data_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_2(&mut self, v: u32) {
            self.extra_data_2 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_3 = 5;

        pub fn extra_data_3(&self) -> u32 {
            self.extra_data_3.unwrap_or(0)
        }

        pub fn clear_extra_data_3(&mut self) {
            self.extra_data_3 = ::std::option::Option::None;
        }

        pub fn has_extra_data_3(&self) -> bool {
            self.extra_data_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_3(&mut self, v: u32) {
            self.extra_data_3 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_4 = 6;

        pub fn extra_data_4(&self) -> u32 {
            self.extra_data_4.unwrap_or(0)
        }

        pub fn clear_extra_data_4(&mut self) {
            self.extra_data_4 = ::std::option::Option::None;
        }

        pub fn has_extra_data_4(&self) -> bool {
            self.extra_data_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_4(&mut self, v: u32) {
            self.extra_data_4 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_5 = 7;

        pub fn extra_data_5(&self) -> u32 {
            self.extra_data_5.unwrap_or(0)
        }

        pub fn clear_extra_data_5(&mut self) {
            self.extra_data_5 = ::std::option::Option::None;
        }

        pub fn has_extra_data_5(&self) -> bool {
            self.extra_data_5.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_5(&mut self, v: u32) {
            self.extra_data_5 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_suffix",
                |m: &EventGameLeaderboardEntry| { &m.name_suffix },
                |m: &mut EventGameLeaderboardEntry| { &mut m.name_suffix },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &EventGameLeaderboardEntry| { &m.score },
                |m: &mut EventGameLeaderboardEntry| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extra_data_1",
                |m: &EventGameLeaderboardEntry| { &m.extra_data_1 },
                |m: &mut EventGameLeaderboardEntry| { &mut m.extra_data_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extra_data_2",
                |m: &EventGameLeaderboardEntry| { &m.extra_data_2 },
                |m: &mut EventGameLeaderboardEntry| { &mut m.extra_data_2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extra_data_3",
                |m: &EventGameLeaderboardEntry| { &m.extra_data_3 },
                |m: &mut EventGameLeaderboardEntry| { &mut m.extra_data_3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extra_data_4",
                |m: &EventGameLeaderboardEntry| { &m.extra_data_4 },
                |m: &mut EventGameLeaderboardEntry| { &mut m.extra_data_4 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extra_data_5",
                |m: &EventGameLeaderboardEntry| { &m.extra_data_5 },
                |m: &mut EventGameLeaderboardEntry| { &mut m.extra_data_5 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventGameLeaderboardEntry>(
                "CMsgGameMatchSignOut.EventGameLeaderboardEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EventGameLeaderboardEntry {
        const NAME: &'static str = "EventGameLeaderboardEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name_suffix = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.extra_data_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.extra_data_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.extra_data_3 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.extra_data_4 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.extra_data_5 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name_suffix.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.extra_data_1 {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.extra_data_2 {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.extra_data_3 {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.extra_data_4 {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.extra_data_5 {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name_suffix.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.extra_data_1 {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.extra_data_2 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.extra_data_3 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.extra_data_4 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.extra_data_5 {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventGameLeaderboardEntry {
            EventGameLeaderboardEntry::new()
        }

        fn clear(&mut self) {
            self.name_suffix = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.extra_data_1 = ::std::option::Option::None;
            self.extra_data_2 = ::std::option::Option::None;
            self.extra_data_3 = ::std::option::Option::None;
            self.extra_data_4 = ::std::option::Option::None;
            self.extra_data_5 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventGameLeaderboardEntry {
            static instance: EventGameLeaderboardEntry = EventGameLeaderboardEntry {
                name_suffix: ::std::option::Option::None,
                score: ::std::option::Option::None,
                extra_data_1: ::std::option::Option::None,
                extra_data_2: ::std::option::Option::None,
                extra_data_3: ::std::option::Option::None,
                extra_data_4: ::std::option::Option::None,
                extra_data_5: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EventGameLeaderboardEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.EventGameLeaderboardEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EventGameLeaderboardEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EventGameLeaderboardEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgGameMatchSignOut.WardPlacement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WardPlacement {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.placed_time)
        pub placed_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.building_state)
        pub building_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.creep_state)
        pub creep_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.roshan_alive)
        pub roshan_alive: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.position_x)
        pub position_x: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOut.WardPlacement.position_y)
        pub position_y: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOut.WardPlacement.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WardPlacement {
        fn default() -> &'a WardPlacement {
            <WardPlacement as ::protobuf::Message>::default_instance()
        }
    }

    impl WardPlacement {
        pub fn new() -> WardPlacement {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 placed_time = 3;

        pub fn placed_time(&self) -> u32 {
            self.placed_time.unwrap_or(0)
        }

        pub fn clear_placed_time(&mut self) {
            self.placed_time = ::std::option::Option::None;
        }

        pub fn has_placed_time(&self) -> bool {
            self.placed_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_placed_time(&mut self, v: u32) {
            self.placed_time = ::std::option::Option::Some(v);
        }

        // optional uint32 building_state = 4;

        pub fn building_state(&self) -> u32 {
            self.building_state.unwrap_or(0)
        }

        pub fn clear_building_state(&mut self) {
            self.building_state = ::std::option::Option::None;
        }

        pub fn has_building_state(&self) -> bool {
            self.building_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_building_state(&mut self, v: u32) {
            self.building_state = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_state = 5;

        pub fn creep_state(&self) -> u32 {
            self.creep_state.unwrap_or(0)
        }

        pub fn clear_creep_state(&mut self) {
            self.creep_state = ::std::option::Option::None;
        }

        pub fn has_creep_state(&self) -> bool {
            self.creep_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_state(&mut self, v: u32) {
            self.creep_state = ::std::option::Option::Some(v);
        }

        // optional bool roshan_alive = 6;

        pub fn roshan_alive(&self) -> bool {
            self.roshan_alive.unwrap_or(false)
        }

        pub fn clear_roshan_alive(&mut self) {
            self.roshan_alive = ::std::option::Option::None;
        }

        pub fn has_roshan_alive(&self) -> bool {
            self.roshan_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan_alive(&mut self, v: bool) {
            self.roshan_alive = ::std::option::Option::Some(v);
        }

        // optional uint32 position_x = 7;

        pub fn position_x(&self) -> u32 {
            self.position_x.unwrap_or(0)
        }

        pub fn clear_position_x(&mut self) {
            self.position_x = ::std::option::Option::None;
        }

        pub fn has_position_x(&self) -> bool {
            self.position_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_x(&mut self, v: u32) {
            self.position_x = ::std::option::Option::Some(v);
        }

        // optional uint32 position_y = 8;

        pub fn position_y(&self) -> u32 {
            self.position_y.unwrap_or(0)
        }

        pub fn clear_position_y(&mut self) {
            self.position_y = ::std::option::Option::None;
        }

        pub fn has_position_y(&self) -> bool {
            self.position_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_y(&mut self, v: u32) {
            self.position_y = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &WardPlacement| { &m.player_id },
                |m: &mut WardPlacement| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &WardPlacement| { &m.team_id },
                |m: &mut WardPlacement| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "placed_time",
                |m: &WardPlacement| { &m.placed_time },
                |m: &mut WardPlacement| { &mut m.placed_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "building_state",
                |m: &WardPlacement| { &m.building_state },
                |m: &mut WardPlacement| { &mut m.building_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_state",
                |m: &WardPlacement| { &m.creep_state },
                |m: &mut WardPlacement| { &mut m.creep_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "roshan_alive",
                |m: &WardPlacement| { &m.roshan_alive },
                |m: &mut WardPlacement| { &mut m.roshan_alive },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position_x",
                |m: &WardPlacement| { &m.position_x },
                |m: &mut WardPlacement| { &mut m.position_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position_y",
                |m: &WardPlacement| { &m.position_y },
                |m: &mut WardPlacement| { &mut m.position_y },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WardPlacement>(
                "CMsgGameMatchSignOut.WardPlacement",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WardPlacement {
        const NAME: &'static str = "WardPlacement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.placed_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.building_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.creep_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.roshan_alive = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.position_x = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.position_y = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.placed_time {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.building_state {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.creep_state {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.roshan_alive {
                my_size += 1 + 1;
            }
            if let Some(v) = self.position_x {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.position_y {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.placed_time {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.building_state {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.creep_state {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.roshan_alive {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.position_x {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.position_y {
                os.write_uint32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WardPlacement {
            WardPlacement::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.placed_time = ::std::option::Option::None;
            self.building_state = ::std::option::Option::None;
            self.creep_state = ::std::option::Option::None;
            self.roshan_alive = ::std::option::Option::None;
            self.position_x = ::std::option::Option::None;
            self.position_y = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WardPlacement {
            static instance: WardPlacement = WardPlacement {
                player_id: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                placed_time: ::std::option::Option::None,
                building_state: ::std::option::Option::None,
                creep_state: ::std::option::Option::None,
                roshan_alive: ::std::option::Option::None,
                position_x: ::std::option::Option::None,
                position_y: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WardPlacement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOut.WardPlacement").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WardPlacement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WardPlacement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutDraftInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutDraftInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutDraftInfo.radiant_captain_account_id)
    pub radiant_captain_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutDraftInfo.dire_captain_account_id)
    pub dire_captain_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutDraftInfo.picks_bans)
    pub picks_bans: ::std::vec::Vec<super::dota_gcmessages_common::CMatchHeroSelectEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutDraftInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutDraftInfo {
    fn default() -> &'a CMsgSignOutDraftInfo {
        <CMsgSignOutDraftInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutDraftInfo {
    pub fn new() -> CMsgSignOutDraftInfo {
        ::std::default::Default::default()
    }

    // optional uint32 radiant_captain_account_id = 1;

    pub fn radiant_captain_account_id(&self) -> u32 {
        self.radiant_captain_account_id.unwrap_or(0)
    }

    pub fn clear_radiant_captain_account_id(&mut self) {
        self.radiant_captain_account_id = ::std::option::Option::None;
    }

    pub fn has_radiant_captain_account_id(&self) -> bool {
        self.radiant_captain_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_captain_account_id(&mut self, v: u32) {
        self.radiant_captain_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_captain_account_id = 2;

    pub fn dire_captain_account_id(&self) -> u32 {
        self.dire_captain_account_id.unwrap_or(0)
    }

    pub fn clear_dire_captain_account_id(&mut self) {
        self.dire_captain_account_id = ::std::option::Option::None;
    }

    pub fn has_dire_captain_account_id(&self) -> bool {
        self.dire_captain_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_captain_account_id(&mut self, v: u32) {
        self.dire_captain_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_captain_account_id",
            |m: &CMsgSignOutDraftInfo| { &m.radiant_captain_account_id },
            |m: &mut CMsgSignOutDraftInfo| { &mut m.radiant_captain_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_captain_account_id",
            |m: &CMsgSignOutDraftInfo| { &m.dire_captain_account_id },
            |m: &mut CMsgSignOutDraftInfo| { &mut m.dire_captain_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "picks_bans",
            |m: &CMsgSignOutDraftInfo| { &m.picks_bans },
            |m: &mut CMsgSignOutDraftInfo| { &mut m.picks_bans },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutDraftInfo>(
            "CMsgSignOutDraftInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutDraftInfo {
    const NAME: &'static str = "CMsgSignOutDraftInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radiant_captain_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.dire_captain_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.picks_bans.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radiant_captain_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dire_captain_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radiant_captain_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dire_captain_account_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.picks_bans {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutDraftInfo {
        CMsgSignOutDraftInfo::new()
    }

    fn clear(&mut self) {
        self.radiant_captain_account_id = ::std::option::Option::None;
        self.dire_captain_account_id = ::std::option::Option::None;
        self.picks_bans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutDraftInfo {
        static instance: CMsgSignOutDraftInfo = CMsgSignOutDraftInfo {
            radiant_captain_account_id: ::std::option::Option::None,
            dire_captain_account_id: ::std::option::Option::None,
            picks_bans: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutDraftInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutDraftInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutDraftInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutDraftInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSignOutBotInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutBotInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutBotInfo.allow_cheats)
    pub allow_cheats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutBotInfo.bot_difficulty_radiant)
    pub bot_difficulty_radiant: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutBotInfo.created_lobby)
    pub created_lobby: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutBotInfo.bot_difficulty_dire)
    pub bot_difficulty_dire: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutBotInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutBotInfo {
    fn default() -> &'a CMsgSignOutBotInfo {
        <CMsgSignOutBotInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutBotInfo {
    pub fn new() -> CMsgSignOutBotInfo {
        ::std::default::Default::default()
    }

    // optional bool allow_cheats = 1;

    pub fn allow_cheats(&self) -> bool {
        self.allow_cheats.unwrap_or(false)
    }

    pub fn clear_allow_cheats(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
    }

    pub fn has_allow_cheats(&self) -> bool {
        self.allow_cheats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheats(&mut self, v: bool) {
        self.allow_cheats = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTABotDifficulty bot_difficulty_radiant = 2;

    pub fn bot_difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_radiant(&mut self) {
        self.bot_difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_radiant(&self) -> bool {
        self.bot_difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_radiant = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool created_lobby = 3;

    pub fn created_lobby(&self) -> bool {
        self.created_lobby.unwrap_or(false)
    }

    pub fn clear_created_lobby(&mut self) {
        self.created_lobby = ::std::option::Option::None;
    }

    pub fn has_created_lobby(&self) -> bool {
        self.created_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_lobby(&mut self, v: bool) {
        self.created_lobby = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTABotDifficulty bot_difficulty_dire = 5;

    pub fn bot_difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_dire(&mut self) {
        self.bot_difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_dire(&self) -> bool {
        self.bot_difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_dire = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_cheats",
            |m: &CMsgSignOutBotInfo| { &m.allow_cheats },
            |m: &mut CMsgSignOutBotInfo| { &mut m.allow_cheats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty_radiant",
            |m: &CMsgSignOutBotInfo| { &m.bot_difficulty_radiant },
            |m: &mut CMsgSignOutBotInfo| { &mut m.bot_difficulty_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "created_lobby",
            |m: &CMsgSignOutBotInfo| { &m.created_lobby },
            |m: &mut CMsgSignOutBotInfo| { &mut m.created_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty_dire",
            |m: &CMsgSignOutBotInfo| { &m.bot_difficulty_dire },
            |m: &mut CMsgSignOutBotInfo| { &mut m.bot_difficulty_dire },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutBotInfo>(
            "CMsgSignOutBotInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutBotInfo {
    const NAME: &'static str = "CMsgSignOutBotInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allow_cheats = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bot_difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.created_lobby = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.bot_difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allow_cheats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.created_lobby {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bot_difficulty_dire {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allow_cheats {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.created_lobby {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bot_difficulty_dire {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutBotInfo {
        CMsgSignOutBotInfo::new()
    }

    fn clear(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
        self.bot_difficulty_radiant = ::std::option::Option::None;
        self.created_lobby = ::std::option::Option::None;
        self.bot_difficulty_dire = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutBotInfo {
        static instance: CMsgSignOutBotInfo = CMsgSignOutBotInfo {
            allow_cheats: ::std::option::Option::None,
            bot_difficulty_radiant: ::std::option::Option::None,
            created_lobby: ::std::option::Option::None,
            bot_difficulty_dire: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutBotInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutBotInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutBotInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutBotInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSignOutTextMuteInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutTextMuteInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutTextMuteInfo.text_mute_messages)
    pub text_mute_messages: ::std::vec::Vec<cmsg_sign_out_text_mute_info::TextMuteMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutTextMuteInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutTextMuteInfo {
    fn default() -> &'a CMsgSignOutTextMuteInfo {
        <CMsgSignOutTextMuteInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutTextMuteInfo {
    pub fn new() -> CMsgSignOutTextMuteInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "text_mute_messages",
            |m: &CMsgSignOutTextMuteInfo| { &m.text_mute_messages },
            |m: &mut CMsgSignOutTextMuteInfo| { &mut m.text_mute_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutTextMuteInfo>(
            "CMsgSignOutTextMuteInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutTextMuteInfo {
    const NAME: &'static str = "CMsgSignOutTextMuteInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text_mute_messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.text_mute_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.text_mute_messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutTextMuteInfo {
        CMsgSignOutTextMuteInfo::new()
    }

    fn clear(&mut self) {
        self.text_mute_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutTextMuteInfo {
        static instance: CMsgSignOutTextMuteInfo = CMsgSignOutTextMuteInfo {
            text_mute_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutTextMuteInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutTextMuteInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutTextMuteInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutTextMuteInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutTextMuteInfo`
pub mod cmsg_sign_out_text_mute_info {
    // @@protoc_insertion_point(message:dota.CMsgSignOutTextMuteInfo.TextMuteMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextMuteMessage {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutTextMuteInfo.TextMuteMessage.region)
        pub region: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutTextMuteInfo.TextMuteMessage.caused_text_mute)
        pub caused_text_mute: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutTextMuteInfo.TextMuteMessage.chat_message)
        pub chat_message: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutTextMuteInfo.TextMuteMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextMuteMessage {
        fn default() -> &'a TextMuteMessage {
            <TextMuteMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl TextMuteMessage {
        pub fn new() -> TextMuteMessage {
            ::std::default::Default::default()
        }

        // optional uint32 region = 1;

        pub fn region(&self) -> u32 {
            self.region.unwrap_or(0)
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: u32) {
            self.region = ::std::option::Option::Some(v);
        }

        // optional bool caused_text_mute = 2;

        pub fn caused_text_mute(&self) -> bool {
            self.caused_text_mute.unwrap_or(false)
        }

        pub fn clear_caused_text_mute(&mut self) {
            self.caused_text_mute = ::std::option::Option::None;
        }

        pub fn has_caused_text_mute(&self) -> bool {
            self.caused_text_mute.is_some()
        }

        // Param is passed by value, moved
        pub fn set_caused_text_mute(&mut self, v: bool) {
            self.caused_text_mute = ::std::option::Option::Some(v);
        }

        // optional string chat_message = 3;

        pub fn chat_message(&self) -> &str {
            match self.chat_message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_chat_message(&mut self) {
            self.chat_message = ::std::option::Option::None;
        }

        pub fn has_chat_message(&self) -> bool {
            self.chat_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_message(&mut self, v: ::std::string::String) {
            self.chat_message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_chat_message(&mut self) -> &mut ::std::string::String {
            if self.chat_message.is_none() {
                self.chat_message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.chat_message.as_mut().unwrap()
        }

        // Take field
        pub fn take_chat_message(&mut self) -> ::std::string::String {
            self.chat_message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region",
                |m: &TextMuteMessage| { &m.region },
                |m: &mut TextMuteMessage| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "caused_text_mute",
                |m: &TextMuteMessage| { &m.caused_text_mute },
                |m: &mut TextMuteMessage| { &mut m.caused_text_mute },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_message",
                |m: &TextMuteMessage| { &m.chat_message },
                |m: &mut TextMuteMessage| { &mut m.chat_message },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextMuteMessage>(
                "CMsgSignOutTextMuteInfo.TextMuteMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextMuteMessage {
        const NAME: &'static str = "TextMuteMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.region = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.caused_text_mute = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.chat_message = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.region {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.caused_text_mute {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_message.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.region {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.caused_text_mute {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.chat_message.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextMuteMessage {
            TextMuteMessage::new()
        }

        fn clear(&mut self) {
            self.region = ::std::option::Option::None;
            self.caused_text_mute = ::std::option::Option::None;
            self.chat_message = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextMuteMessage {
            static instance: TextMuteMessage = TextMuteMessage {
                region: ::std::option::Option::None,
                caused_text_mute: ::std::option::Option::None,
                chat_message: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextMuteMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutTextMuteInfo.TextMuteMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextMuteMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextMuteMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.account_id)
    pub account_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.rampages)
    pub rampages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.triple_kills)
    pub triple_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.first_blood_claimed)
    pub first_blood_claimed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.first_blood_given)
    pub first_blood_given: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.couriers_killed)
    pub couriers_killed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.aegises_snatched)
    pub aegises_snatched: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.cheeses_eaten)
    pub cheeses_eaten: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.creeps_stacked)
    pub creeps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.fight_score)
    pub fight_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.farm_score)
    pub farm_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.support_score)
    pub support_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.push_score)
    pub push_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.denies)
    pub denies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.gpm)
    pub gpm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.xppm)
    pub xppm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.net_worth)
    pub net_worth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.damage)
    pub damage: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.heals)
    pub heals: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.rapiers_purchased)
    pub rapiers_purchased: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.observer_wards_placed)
    pub observer_wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.wards_destroyed)
    pub wards_destroyed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutPlayerStats.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutPlayerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutPlayerStats {
    fn default() -> &'a CMsgSignOutPlayerStats {
        <CMsgSignOutPlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutPlayerStats {
    pub fn new() -> CMsgSignOutPlayerStats {
        ::std::default::Default::default()
    }

    // optional int32 account_id = 1;

    pub fn account_id(&self) -> i32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: i32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 3;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 4;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rampages = 5;

    pub fn rampages(&self) -> u32 {
        self.rampages.unwrap_or(0)
    }

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: u32) {
        self.rampages = ::std::option::Option::Some(v);
    }

    // optional uint32 triple_kills = 6;

    pub fn triple_kills(&self) -> u32 {
        self.triple_kills.unwrap_or(0)
    }

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: u32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_claimed = 7;

    pub fn first_blood_claimed(&self) -> u32 {
        self.first_blood_claimed.unwrap_or(0)
    }

    pub fn clear_first_blood_claimed(&mut self) {
        self.first_blood_claimed = ::std::option::Option::None;
    }

    pub fn has_first_blood_claimed(&self) -> bool {
        self.first_blood_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_claimed(&mut self, v: u32) {
        self.first_blood_claimed = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_given = 8;

    pub fn first_blood_given(&self) -> u32 {
        self.first_blood_given.unwrap_or(0)
    }

    pub fn clear_first_blood_given(&mut self) {
        self.first_blood_given = ::std::option::Option::None;
    }

    pub fn has_first_blood_given(&self) -> bool {
        self.first_blood_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_given(&mut self, v: u32) {
        self.first_blood_given = ::std::option::Option::Some(v);
    }

    // optional uint32 couriers_killed = 9;

    pub fn couriers_killed(&self) -> u32 {
        self.couriers_killed.unwrap_or(0)
    }

    pub fn clear_couriers_killed(&mut self) {
        self.couriers_killed = ::std::option::Option::None;
    }

    pub fn has_couriers_killed(&self) -> bool {
        self.couriers_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_couriers_killed(&mut self, v: u32) {
        self.couriers_killed = ::std::option::Option::Some(v);
    }

    // optional uint32 aegises_snatched = 10;

    pub fn aegises_snatched(&self) -> u32 {
        self.aegises_snatched.unwrap_or(0)
    }

    pub fn clear_aegises_snatched(&mut self) {
        self.aegises_snatched = ::std::option::Option::None;
    }

    pub fn has_aegises_snatched(&self) -> bool {
        self.aegises_snatched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aegises_snatched(&mut self, v: u32) {
        self.aegises_snatched = ::std::option::Option::Some(v);
    }

    // optional uint32 cheeses_eaten = 11;

    pub fn cheeses_eaten(&self) -> u32 {
        self.cheeses_eaten.unwrap_or(0)
    }

    pub fn clear_cheeses_eaten(&mut self) {
        self.cheeses_eaten = ::std::option::Option::None;
    }

    pub fn has_cheeses_eaten(&self) -> bool {
        self.cheeses_eaten.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheeses_eaten(&mut self, v: u32) {
        self.cheeses_eaten = ::std::option::Option::Some(v);
    }

    // optional uint32 creeps_stacked = 12;

    pub fn creeps_stacked(&self) -> u32 {
        self.creeps_stacked.unwrap_or(0)
    }

    pub fn clear_creeps_stacked(&mut self) {
        self.creeps_stacked = ::std::option::Option::None;
    }

    pub fn has_creeps_stacked(&self) -> bool {
        self.creeps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creeps_stacked(&mut self, v: u32) {
        self.creeps_stacked = ::std::option::Option::Some(v);
    }

    // optional float fight_score = 13;

    pub fn fight_score(&self) -> f32 {
        self.fight_score.unwrap_or(0.)
    }

    pub fn clear_fight_score(&mut self) {
        self.fight_score = ::std::option::Option::None;
    }

    pub fn has_fight_score(&self) -> bool {
        self.fight_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fight_score(&mut self, v: f32) {
        self.fight_score = ::std::option::Option::Some(v);
    }

    // optional float farm_score = 14;

    pub fn farm_score(&self) -> f32 {
        self.farm_score.unwrap_or(0.)
    }

    pub fn clear_farm_score(&mut self) {
        self.farm_score = ::std::option::Option::None;
    }

    pub fn has_farm_score(&self) -> bool {
        self.farm_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_farm_score(&mut self, v: f32) {
        self.farm_score = ::std::option::Option::Some(v);
    }

    // optional float support_score = 15;

    pub fn support_score(&self) -> f32 {
        self.support_score.unwrap_or(0.)
    }

    pub fn clear_support_score(&mut self) {
        self.support_score = ::std::option::Option::None;
    }

    pub fn has_support_score(&self) -> bool {
        self.support_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_score(&mut self, v: f32) {
        self.support_score = ::std::option::Option::Some(v);
    }

    // optional float push_score = 16;

    pub fn push_score(&self) -> f32 {
        self.push_score.unwrap_or(0.)
    }

    pub fn clear_push_score(&mut self) {
        self.push_score = ::std::option::Option::None;
    }

    pub fn has_push_score(&self) -> bool {
        self.push_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_score(&mut self, v: f32) {
        self.push_score = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 17;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 18;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 19;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 20;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 denies = 21;

    pub fn denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional float gpm = 22;

    pub fn gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional float xppm = 23;

    pub fn xppm(&self) -> f32 {
        self.xppm.unwrap_or(0.)
    }

    pub fn clear_xppm(&mut self) {
        self.xppm = ::std::option::Option::None;
    }

    pub fn has_xppm(&self) -> bool {
        self.xppm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xppm(&mut self, v: f32) {
        self.xppm = ::std::option::Option::Some(v);
    }

    // optional float net_worth = 24;

    pub fn net_worth(&self) -> f32 {
        self.net_worth.unwrap_or(0.)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: f32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional float damage = 25;

    pub fn damage(&self) -> f32 {
        self.damage.unwrap_or(0.)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: f32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional float heals = 26;

    pub fn heals(&self) -> f32 {
        self.heals.unwrap_or(0.)
    }

    pub fn clear_heals(&mut self) {
        self.heals = ::std::option::Option::None;
    }

    pub fn has_heals(&self) -> bool {
        self.heals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heals(&mut self, v: f32) {
        self.heals = ::std::option::Option::Some(v);
    }

    // optional uint32 rapiers_purchased = 27;

    pub fn rapiers_purchased(&self) -> u32 {
        self.rapiers_purchased.unwrap_or(0)
    }

    pub fn clear_rapiers_purchased(&mut self) {
        self.rapiers_purchased = ::std::option::Option::None;
    }

    pub fn has_rapiers_purchased(&self) -> bool {
        self.rapiers_purchased.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rapiers_purchased(&mut self, v: u32) {
        self.rapiers_purchased = ::std::option::Option::Some(v);
    }

    // optional uint32 observer_wards_placed = 28;

    pub fn observer_wards_placed(&self) -> u32 {
        self.observer_wards_placed.unwrap_or(0)
    }

    pub fn clear_observer_wards_placed(&mut self) {
        self.observer_wards_placed = ::std::option::Option::None;
    }

    pub fn has_observer_wards_placed(&self) -> bool {
        self.observer_wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_wards_placed(&mut self, v: u32) {
        self.observer_wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_destroyed = 29;

    pub fn wards_destroyed(&self) -> u32 {
        self.wards_destroyed.unwrap_or(0)
    }

    pub fn clear_wards_destroyed(&mut self) {
        self.wards_destroyed = ::std::option::Option::None;
    }

    pub fn has_wards_destroyed(&self) -> bool {
        self.wards_destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_destroyed(&mut self, v: u32) {
        self.wards_destroyed = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 30;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(30);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgSignOutPlayerStats| { &m.account_id },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgSignOutPlayerStats| { &m.match_id },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CMsgSignOutPlayerStats| { &m.rank },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgSignOutPlayerStats| { &m.hero_id },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rampages",
            |m: &CMsgSignOutPlayerStats| { &m.rampages },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.rampages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "triple_kills",
            |m: &CMsgSignOutPlayerStats| { &m.triple_kills },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.triple_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_blood_claimed",
            |m: &CMsgSignOutPlayerStats| { &m.first_blood_claimed },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.first_blood_claimed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_blood_given",
            |m: &CMsgSignOutPlayerStats| { &m.first_blood_given },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.first_blood_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "couriers_killed",
            |m: &CMsgSignOutPlayerStats| { &m.couriers_killed },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.couriers_killed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aegises_snatched",
            |m: &CMsgSignOutPlayerStats| { &m.aegises_snatched },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.aegises_snatched },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheeses_eaten",
            |m: &CMsgSignOutPlayerStats| { &m.cheeses_eaten },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.cheeses_eaten },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creeps_stacked",
            |m: &CMsgSignOutPlayerStats| { &m.creeps_stacked },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.creeps_stacked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fight_score",
            |m: &CMsgSignOutPlayerStats| { &m.fight_score },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.fight_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "farm_score",
            |m: &CMsgSignOutPlayerStats| { &m.farm_score },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.farm_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support_score",
            |m: &CMsgSignOutPlayerStats| { &m.support_score },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.support_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "push_score",
            |m: &CMsgSignOutPlayerStats| { &m.push_score },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.push_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CMsgSignOutPlayerStats| { &m.kills },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CMsgSignOutPlayerStats| { &m.deaths },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assists",
            |m: &CMsgSignOutPlayerStats| { &m.assists },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.assists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_hits",
            |m: &CMsgSignOutPlayerStats| { &m.last_hits },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.last_hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "denies",
            |m: &CMsgSignOutPlayerStats| { &m.denies },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.denies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpm",
            |m: &CMsgSignOutPlayerStats| { &m.gpm },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.gpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xppm",
            |m: &CMsgSignOutPlayerStats| { &m.xppm },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.xppm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_worth",
            |m: &CMsgSignOutPlayerStats| { &m.net_worth },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.net_worth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage",
            |m: &CMsgSignOutPlayerStats| { &m.damage },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "heals",
            |m: &CMsgSignOutPlayerStats| { &m.heals },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.heals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rapiers_purchased",
            |m: &CMsgSignOutPlayerStats| { &m.rapiers_purchased },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.rapiers_purchased },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observer_wards_placed",
            |m: &CMsgSignOutPlayerStats| { &m.observer_wards_placed },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.observer_wards_placed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wards_destroyed",
            |m: &CMsgSignOutPlayerStats| { &m.wards_destroyed },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.wards_destroyed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgSignOutPlayerStats| { &m.lobby_type },
            |m: &mut CMsgSignOutPlayerStats| { &mut m.lobby_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutPlayerStats>(
            "CMsgSignOutPlayerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutPlayerStats {
    const NAME: &'static str = "CMsgSignOutPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rampages = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.triple_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.first_blood_claimed = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.first_blood_given = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.couriers_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.aegises_snatched = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.cheeses_eaten = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.creeps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.fight_score = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.farm_score = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.support_score = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.push_score = ::std::option::Option::Some(is.read_float()?);
                },
                136 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.denies = ::std::option::Option::Some(is.read_uint32()?);
                },
                181 => {
                    self.gpm = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.xppm = ::std::option::Option::Some(is.read_float()?);
                },
                197 => {
                    self.net_worth = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.damage = ::std::option::Option::Some(is.read_float()?);
                },
                213 => {
                    self.heals = ::std::option::Option::Some(is.read_float()?);
                },
                216 => {
                    self.rapiers_purchased = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.observer_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.wards_destroyed = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rampages {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.triple_kills {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.first_blood_claimed {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.first_blood_given {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.couriers_killed {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.aegises_snatched {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.cheeses_eaten {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.creeps_stacked {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.fight_score {
            my_size += 1 + 4;
        }
        if let Some(v) = self.farm_score {
            my_size += 1 + 4;
        }
        if let Some(v) = self.support_score {
            my_size += 1 + 4;
        }
        if let Some(v) = self.push_score {
            my_size += 2 + 4;
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.denies {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.gpm {
            my_size += 2 + 4;
        }
        if let Some(v) = self.xppm {
            my_size += 2 + 4;
        }
        if let Some(v) = self.net_worth {
            my_size += 2 + 4;
        }
        if let Some(v) = self.damage {
            my_size += 2 + 4;
        }
        if let Some(v) = self.heals {
            my_size += 2 + 4;
        }
        if let Some(v) = self.rapiers_purchased {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.observer_wards_placed {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.wards_destroyed {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.first_blood_claimed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.first_blood_given {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.couriers_killed {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.aegises_snatched {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.cheeses_eaten {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.creeps_stacked {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.fight_score {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.farm_score {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.support_score {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.push_score {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.xppm {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.damage {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.heals {
            os.write_float(26, v)?;
        }
        if let Some(v) = self.rapiers_purchased {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.observer_wards_placed {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.wards_destroyed {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutPlayerStats {
        CMsgSignOutPlayerStats::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.rampages = ::std::option::Option::None;
        self.triple_kills = ::std::option::Option::None;
        self.first_blood_claimed = ::std::option::Option::None;
        self.first_blood_given = ::std::option::Option::None;
        self.couriers_killed = ::std::option::Option::None;
        self.aegises_snatched = ::std::option::Option::None;
        self.cheeses_eaten = ::std::option::Option::None;
        self.creeps_stacked = ::std::option::Option::None;
        self.fight_score = ::std::option::Option::None;
        self.farm_score = ::std::option::Option::None;
        self.support_score = ::std::option::Option::None;
        self.push_score = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.xppm = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.heals = ::std::option::Option::None;
        self.rapiers_purchased = ::std::option::Option::None;
        self.observer_wards_placed = ::std::option::Option::None;
        self.wards_destroyed = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutPlayerStats {
        static instance: CMsgSignOutPlayerStats = CMsgSignOutPlayerStats {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            rampages: ::std::option::Option::None,
            triple_kills: ::std::option::Option::None,
            first_blood_claimed: ::std::option::Option::None,
            first_blood_given: ::std::option::Option::None,
            couriers_killed: ::std::option::Option::None,
            aegises_snatched: ::std::option::Option::None,
            cheeses_eaten: ::std::option::Option::None,
            creeps_stacked: ::std::option::Option::None,
            fight_score: ::std::option::Option::None,
            farm_score: ::std::option::Option::None,
            support_score: ::std::option::Option::None,
            push_score: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            xppm: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            heals: ::std::option::Option::None,
            rapiers_purchased: ::std::option::Option::None,
            observer_wards_placed: ::std::option::Option::None,
            wards_destroyed: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutPlayerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutPlayerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutPlayerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSignOutCommunicationSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutCommunicationSummary {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_communication_summary::PlayerCommunication>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutCommunicationSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutCommunicationSummary {
    fn default() -> &'a CMsgSignOutCommunicationSummary {
        <CMsgSignOutCommunicationSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutCommunicationSummary {
    pub fn new() -> CMsgSignOutCommunicationSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgSignOutCommunicationSummary| { &m.players },
            |m: &mut CMsgSignOutCommunicationSummary| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutCommunicationSummary>(
            "CMsgSignOutCommunicationSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutCommunicationSummary {
    const NAME: &'static str = "CMsgSignOutCommunicationSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutCommunicationSummary {
        CMsgSignOutCommunicationSummary::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutCommunicationSummary {
        static instance: CMsgSignOutCommunicationSummary = CMsgSignOutCommunicationSummary {
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutCommunicationSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutCommunicationSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutCommunicationSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutCommunicationSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutCommunicationSummary`
pub mod cmsg_sign_out_communication_summary {
    // @@protoc_insertion_point(message:dota.CMsgSignOutCommunicationSummary.PlayerCommunication)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCommunication {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.pings)
        pub pings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.max_pings_per_interval)
        pub max_pings_per_interval: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.teammate_pings)
        pub teammate_pings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.max_teammate_pings_per_interval)
        pub max_teammate_pings_per_interval: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.team_chat_messages)
        pub team_chat_messages: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.all_chat_messages)
        pub all_chat_messages: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.chat_wheel_messages)
        pub chat_wheel_messages: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.pauses)
        pub pauses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.unpauses)
        pub unpauses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.lines_drawn)
        pub lines_drawn: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.voice_chat_seconds)
        pub voice_chat_seconds: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.chat_mutes)
        pub chat_mutes: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.voice_mutes)
        pub voice_mutes: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.ping_details)
        pub ping_details: ::std::vec::Vec<player_communication::PingDetail>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.comms_blocks_solo)
        pub comms_blocks_solo: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.comms_blocks_mass)
        pub comms_blocks_mass: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCommunication {
        fn default() -> &'a PlayerCommunication {
            <PlayerCommunication as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCommunication {
        pub fn new() -> PlayerCommunication {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 pings = 2;

        pub fn pings(&self) -> u32 {
            self.pings.unwrap_or(0)
        }

        pub fn clear_pings(&mut self) {
            self.pings = ::std::option::Option::None;
        }

        pub fn has_pings(&self) -> bool {
            self.pings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pings(&mut self, v: u32) {
            self.pings = ::std::option::Option::Some(v);
        }

        // optional uint32 max_pings_per_interval = 3;

        pub fn max_pings_per_interval(&self) -> u32 {
            self.max_pings_per_interval.unwrap_or(0)
        }

        pub fn clear_max_pings_per_interval(&mut self) {
            self.max_pings_per_interval = ::std::option::Option::None;
        }

        pub fn has_max_pings_per_interval(&self) -> bool {
            self.max_pings_per_interval.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_pings_per_interval(&mut self, v: u32) {
            self.max_pings_per_interval = ::std::option::Option::Some(v);
        }

        // optional uint32 teammate_pings = 4;

        pub fn teammate_pings(&self) -> u32 {
            self.teammate_pings.unwrap_or(0)
        }

        pub fn clear_teammate_pings(&mut self) {
            self.teammate_pings = ::std::option::Option::None;
        }

        pub fn has_teammate_pings(&self) -> bool {
            self.teammate_pings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teammate_pings(&mut self, v: u32) {
            self.teammate_pings = ::std::option::Option::Some(v);
        }

        // optional uint32 max_teammate_pings_per_interval = 5;

        pub fn max_teammate_pings_per_interval(&self) -> u32 {
            self.max_teammate_pings_per_interval.unwrap_or(0)
        }

        pub fn clear_max_teammate_pings_per_interval(&mut self) {
            self.max_teammate_pings_per_interval = ::std::option::Option::None;
        }

        pub fn has_max_teammate_pings_per_interval(&self) -> bool {
            self.max_teammate_pings_per_interval.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_teammate_pings_per_interval(&mut self, v: u32) {
            self.max_teammate_pings_per_interval = ::std::option::Option::Some(v);
        }

        // optional uint32 team_chat_messages = 6;

        pub fn team_chat_messages(&self) -> u32 {
            self.team_chat_messages.unwrap_or(0)
        }

        pub fn clear_team_chat_messages(&mut self) {
            self.team_chat_messages = ::std::option::Option::None;
        }

        pub fn has_team_chat_messages(&self) -> bool {
            self.team_chat_messages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_chat_messages(&mut self, v: u32) {
            self.team_chat_messages = ::std::option::Option::Some(v);
        }

        // optional uint32 all_chat_messages = 7;

        pub fn all_chat_messages(&self) -> u32 {
            self.all_chat_messages.unwrap_or(0)
        }

        pub fn clear_all_chat_messages(&mut self) {
            self.all_chat_messages = ::std::option::Option::None;
        }

        pub fn has_all_chat_messages(&self) -> bool {
            self.all_chat_messages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_all_chat_messages(&mut self, v: u32) {
            self.all_chat_messages = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_wheel_messages = 8;

        pub fn chat_wheel_messages(&self) -> u32 {
            self.chat_wheel_messages.unwrap_or(0)
        }

        pub fn clear_chat_wheel_messages(&mut self) {
            self.chat_wheel_messages = ::std::option::Option::None;
        }

        pub fn has_chat_wheel_messages(&self) -> bool {
            self.chat_wheel_messages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_wheel_messages(&mut self, v: u32) {
            self.chat_wheel_messages = ::std::option::Option::Some(v);
        }

        // optional uint32 pauses = 9;

        pub fn pauses(&self) -> u32 {
            self.pauses.unwrap_or(0)
        }

        pub fn clear_pauses(&mut self) {
            self.pauses = ::std::option::Option::None;
        }

        pub fn has_pauses(&self) -> bool {
            self.pauses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pauses(&mut self, v: u32) {
            self.pauses = ::std::option::Option::Some(v);
        }

        // optional uint32 unpauses = 10;

        pub fn unpauses(&self) -> u32 {
            self.unpauses.unwrap_or(0)
        }

        pub fn clear_unpauses(&mut self) {
            self.unpauses = ::std::option::Option::None;
        }

        pub fn has_unpauses(&self) -> bool {
            self.unpauses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unpauses(&mut self, v: u32) {
            self.unpauses = ::std::option::Option::Some(v);
        }

        // optional uint32 lines_drawn = 11;

        pub fn lines_drawn(&self) -> u32 {
            self.lines_drawn.unwrap_or(0)
        }

        pub fn clear_lines_drawn(&mut self) {
            self.lines_drawn = ::std::option::Option::None;
        }

        pub fn has_lines_drawn(&self) -> bool {
            self.lines_drawn.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lines_drawn(&mut self, v: u32) {
            self.lines_drawn = ::std::option::Option::Some(v);
        }

        // optional uint32 voice_chat_seconds = 12;

        pub fn voice_chat_seconds(&self) -> u32 {
            self.voice_chat_seconds.unwrap_or(0)
        }

        pub fn clear_voice_chat_seconds(&mut self) {
            self.voice_chat_seconds = ::std::option::Option::None;
        }

        pub fn has_voice_chat_seconds(&self) -> bool {
            self.voice_chat_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_chat_seconds(&mut self, v: u32) {
            self.voice_chat_seconds = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_mutes = 13;

        pub fn chat_mutes(&self) -> u32 {
            self.chat_mutes.unwrap_or(0)
        }

        pub fn clear_chat_mutes(&mut self) {
            self.chat_mutes = ::std::option::Option::None;
        }

        pub fn has_chat_mutes(&self) -> bool {
            self.chat_mutes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_mutes(&mut self, v: u32) {
            self.chat_mutes = ::std::option::Option::Some(v);
        }

        // optional uint32 voice_mutes = 14;

        pub fn voice_mutes(&self) -> u32 {
            self.voice_mutes.unwrap_or(0)
        }

        pub fn clear_voice_mutes(&mut self) {
            self.voice_mutes = ::std::option::Option::None;
        }

        pub fn has_voice_mutes(&self) -> bool {
            self.voice_mutes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_mutes(&mut self, v: u32) {
            self.voice_mutes = ::std::option::Option::Some(v);
        }

        // optional uint32 comms_blocks_solo = 16;

        pub fn comms_blocks_solo(&self) -> u32 {
            self.comms_blocks_solo.unwrap_or(0)
        }

        pub fn clear_comms_blocks_solo(&mut self) {
            self.comms_blocks_solo = ::std::option::Option::None;
        }

        pub fn has_comms_blocks_solo(&self) -> bool {
            self.comms_blocks_solo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comms_blocks_solo(&mut self, v: u32) {
            self.comms_blocks_solo = ::std::option::Option::Some(v);
        }

        // optional uint32 comms_blocks_mass = 17;

        pub fn comms_blocks_mass(&self) -> u32 {
            self.comms_blocks_mass.unwrap_or(0)
        }

        pub fn clear_comms_blocks_mass(&mut self) {
            self.comms_blocks_mass = ::std::option::Option::None;
        }

        pub fn has_comms_blocks_mass(&self) -> bool {
            self.comms_blocks_mass.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comms_blocks_mass(&mut self, v: u32) {
            self.comms_blocks_mass = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(17);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerCommunication| { &m.account_id },
                |m: &mut PlayerCommunication| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pings",
                |m: &PlayerCommunication| { &m.pings },
                |m: &mut PlayerCommunication| { &mut m.pings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_pings_per_interval",
                |m: &PlayerCommunication| { &m.max_pings_per_interval },
                |m: &mut PlayerCommunication| { &mut m.max_pings_per_interval },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teammate_pings",
                |m: &PlayerCommunication| { &m.teammate_pings },
                |m: &mut PlayerCommunication| { &mut m.teammate_pings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_teammate_pings_per_interval",
                |m: &PlayerCommunication| { &m.max_teammate_pings_per_interval },
                |m: &mut PlayerCommunication| { &mut m.max_teammate_pings_per_interval },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_chat_messages",
                |m: &PlayerCommunication| { &m.team_chat_messages },
                |m: &mut PlayerCommunication| { &mut m.team_chat_messages },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "all_chat_messages",
                |m: &PlayerCommunication| { &m.all_chat_messages },
                |m: &mut PlayerCommunication| { &mut m.all_chat_messages },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_wheel_messages",
                |m: &PlayerCommunication| { &m.chat_wheel_messages },
                |m: &mut PlayerCommunication| { &mut m.chat_wheel_messages },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pauses",
                |m: &PlayerCommunication| { &m.pauses },
                |m: &mut PlayerCommunication| { &mut m.pauses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unpauses",
                |m: &PlayerCommunication| { &m.unpauses },
                |m: &mut PlayerCommunication| { &mut m.unpauses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lines_drawn",
                |m: &PlayerCommunication| { &m.lines_drawn },
                |m: &mut PlayerCommunication| { &mut m.lines_drawn },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_chat_seconds",
                |m: &PlayerCommunication| { &m.voice_chat_seconds },
                |m: &mut PlayerCommunication| { &mut m.voice_chat_seconds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_mutes",
                |m: &PlayerCommunication| { &m.chat_mutes },
                |m: &mut PlayerCommunication| { &mut m.chat_mutes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_mutes",
                |m: &PlayerCommunication| { &m.voice_mutes },
                |m: &mut PlayerCommunication| { &mut m.voice_mutes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "ping_details",
                |m: &PlayerCommunication| { &m.ping_details },
                |m: &mut PlayerCommunication| { &mut m.ping_details },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "comms_blocks_solo",
                |m: &PlayerCommunication| { &m.comms_blocks_solo },
                |m: &mut PlayerCommunication| { &mut m.comms_blocks_solo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "comms_blocks_mass",
                |m: &PlayerCommunication| { &m.comms_blocks_mass },
                |m: &mut PlayerCommunication| { &mut m.comms_blocks_mass },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerCommunication>(
                "CMsgSignOutCommunicationSummary.PlayerCommunication",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerCommunication {
        const NAME: &'static str = "PlayerCommunication";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.pings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.max_pings_per_interval = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.teammate_pings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.max_teammate_pings_per_interval = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.team_chat_messages = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.all_chat_messages = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.chat_wheel_messages = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.pauses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.unpauses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.lines_drawn = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.voice_chat_seconds = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.chat_mutes = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.voice_mutes = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    122 => {
                        self.ping_details.push(is.read_message()?);
                    },
                    128 => {
                        self.comms_blocks_solo = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.comms_blocks_mass = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.pings {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.max_pings_per_interval {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.teammate_pings {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.max_teammate_pings_per_interval {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.team_chat_messages {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.all_chat_messages {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.chat_wheel_messages {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.pauses {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.unpauses {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.lines_drawn {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.voice_chat_seconds {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.chat_mutes {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.voice_mutes {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            for value in &self.ping_details {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.comms_blocks_solo {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.comms_blocks_mass {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.pings {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.max_pings_per_interval {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.teammate_pings {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.max_teammate_pings_per_interval {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.team_chat_messages {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.all_chat_messages {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.chat_wheel_messages {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.pauses {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.unpauses {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.lines_drawn {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.voice_chat_seconds {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.chat_mutes {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.voice_mutes {
                os.write_uint32(14, v)?;
            }
            for v in &self.ping_details {
                ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
            };
            if let Some(v) = self.comms_blocks_solo {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.comms_blocks_mass {
                os.write_uint32(17, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCommunication {
            PlayerCommunication::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.pings = ::std::option::Option::None;
            self.max_pings_per_interval = ::std::option::Option::None;
            self.teammate_pings = ::std::option::Option::None;
            self.max_teammate_pings_per_interval = ::std::option::Option::None;
            self.team_chat_messages = ::std::option::Option::None;
            self.all_chat_messages = ::std::option::Option::None;
            self.chat_wheel_messages = ::std::option::Option::None;
            self.pauses = ::std::option::Option::None;
            self.unpauses = ::std::option::Option::None;
            self.lines_drawn = ::std::option::Option::None;
            self.voice_chat_seconds = ::std::option::Option::None;
            self.chat_mutes = ::std::option::Option::None;
            self.voice_mutes = ::std::option::Option::None;
            self.ping_details.clear();
            self.comms_blocks_solo = ::std::option::Option::None;
            self.comms_blocks_mass = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCommunication {
            static instance: PlayerCommunication = PlayerCommunication {
                account_id: ::std::option::Option::None,
                pings: ::std::option::Option::None,
                max_pings_per_interval: ::std::option::Option::None,
                teammate_pings: ::std::option::Option::None,
                max_teammate_pings_per_interval: ::std::option::Option::None,
                team_chat_messages: ::std::option::Option::None,
                all_chat_messages: ::std::option::Option::None,
                chat_wheel_messages: ::std::option::Option::None,
                pauses: ::std::option::Option::None,
                unpauses: ::std::option::Option::None,
                lines_drawn: ::std::option::Option::None,
                voice_chat_seconds: ::std::option::Option::None,
                chat_mutes: ::std::option::Option::None,
                voice_mutes: ::std::option::Option::None,
                ping_details: ::std::vec::Vec::new(),
                comms_blocks_solo: ::std::option::Option::None,
                comms_blocks_mass: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerCommunication {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutCommunicationSummary.PlayerCommunication").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerCommunication {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerCommunication {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `PlayerCommunication`
    pub mod player_communication {
        // @@protoc_insertion_point(message:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PingDetail {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail.type)
            pub type_: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail.count)
            pub count: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PingDetail {
            fn default() -> &'a PingDetail {
                <PingDetail as ::protobuf::Message>::default_instance()
            }
        }

        impl PingDetail {
            pub fn new() -> PingDetail {
                ::std::default::Default::default()
            }

            // optional uint32 type = 1;

            pub fn type_(&self) -> u32 {
                self.type_.unwrap_or(0)
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: u32) {
                self.type_ = ::std::option::Option::Some(v);
            }

            // optional uint32 count = 2;

            pub fn count(&self) -> u32 {
                self.count.unwrap_or(0)
            }

            pub fn clear_count(&mut self) {
                self.count = ::std::option::Option::None;
            }

            pub fn has_count(&self) -> bool {
                self.count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_count(&mut self, v: u32) {
                self.count = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "type",
                    |m: &PingDetail| { &m.type_ },
                    |m: &mut PingDetail| { &mut m.type_ },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "count",
                    |m: &PingDetail| { &m.count },
                    |m: &mut PingDetail| { &mut m.count },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingDetail>(
                    "CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PingDetail {
            const NAME: &'static str = "PingDetail";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.type_ {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.count {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.type_ {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.count {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PingDetail {
                PingDetail::new()
            }

            fn clear(&mut self) {
                self.type_ = ::std::option::Option::None;
                self.count = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PingDetail {
                static instance: PingDetail = PingDetail {
                    type_: ::std::option::Option::None,
                    count: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for PingDetail {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PingDetail {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PingDetail {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGameMatchSignoutResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignoutResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.replay_salt)
    pub replay_salt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.timed_reward_details)
    pub timed_reward_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CLobbyTimedRewardDetails>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.xp_reward_details)
    pub xp_reward_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CSODOTALobbyMember>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.metadata_private_key)
    pub metadata_private_key: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.match_details)
    pub match_details: ::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.players_metadata)
    pub players_metadata: ::std::vec::Vec<cmsg_game_match_signout_response::PlayerMetadata>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.mvp_data)
    pub mvp_data: ::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMvpData>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.ow_private_key)
    pub ow_private_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.ow_salt)
    pub ow_salt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.ow_replay_id)
    pub ow_replay_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignoutResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignoutResponse {
    fn default() -> &'a CMsgGameMatchSignoutResponse {
        <CMsgGameMatchSignoutResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignoutResponse {
    pub fn new() -> CMsgGameMatchSignoutResponse {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 replay_salt = 2;

    pub fn replay_salt(&self) -> u32 {
        self.replay_salt.unwrap_or(0)
    }

    pub fn clear_replay_salt(&mut self) {
        self.replay_salt = ::std::option::Option::None;
    }

    pub fn has_replay_salt(&self) -> bool {
        self.replay_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_salt(&mut self, v: u32) {
        self.replay_salt = ::std::option::Option::Some(v);
    }

    // optional uint32 leagueid = 5;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional fixed32 metadata_private_key = 7;

    pub fn metadata_private_key(&self) -> u32 {
        self.metadata_private_key.unwrap_or(0)
    }

    pub fn clear_metadata_private_key(&mut self) {
        self.metadata_private_key = ::std::option::Option::None;
    }

    pub fn has_metadata_private_key(&self) -> bool {
        self.metadata_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_private_key(&mut self, v: u32) {
        self.metadata_private_key = ::std::option::Option::Some(v);
    }

    // optional fixed64 ow_private_key = 11;

    pub fn ow_private_key(&self) -> u64 {
        self.ow_private_key.unwrap_or(0)
    }

    pub fn clear_ow_private_key(&mut self) {
        self.ow_private_key = ::std::option::Option::None;
    }

    pub fn has_ow_private_key(&self) -> bool {
        self.ow_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ow_private_key(&mut self, v: u64) {
        self.ow_private_key = ::std::option::Option::Some(v);
    }

    // optional fixed32 ow_salt = 12;

    pub fn ow_salt(&self) -> u32 {
        self.ow_salt.unwrap_or(0)
    }

    pub fn clear_ow_salt(&mut self) {
        self.ow_salt = ::std::option::Option::None;
    }

    pub fn has_ow_salt(&self) -> bool {
        self.ow_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ow_salt(&mut self, v: u32) {
        self.ow_salt = ::std::option::Option::Some(v);
    }

    // optional uint64 ow_replay_id = 13;

    pub fn ow_replay_id(&self) -> u64 {
        self.ow_replay_id.unwrap_or(0)
    }

    pub fn clear_ow_replay_id(&mut self) {
        self.ow_replay_id = ::std::option::Option::None;
    }

    pub fn has_ow_replay_id(&self) -> bool {
        self.ow_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ow_replay_id(&mut self, v: u64) {
        self.ow_replay_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGameMatchSignoutResponse| { &m.match_id },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_salt",
            |m: &CMsgGameMatchSignoutResponse| { &m.replay_salt },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.replay_salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timed_reward_details",
            |m: &CMsgGameMatchSignoutResponse| { &m.timed_reward_details },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.timed_reward_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xp_reward_details",
            |m: &CMsgGameMatchSignoutResponse| { &m.xp_reward_details },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.xp_reward_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leagueid",
            |m: &CMsgGameMatchSignoutResponse| { &m.leagueid },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.leagueid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata_private_key",
            |m: &CMsgGameMatchSignoutResponse| { &m.metadata_private_key },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.metadata_private_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common::CMsgDOTAMatch>(
            "match_details",
            |m: &CMsgGameMatchSignoutResponse| { &m.match_details },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.match_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players_metadata",
            |m: &CMsgGameMatchSignoutResponse| { &m.players_metadata },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.players_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common_match_management::CMvpData>(
            "mvp_data",
            |m: &CMsgGameMatchSignoutResponse| { &m.mvp_data },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.mvp_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ow_private_key",
            |m: &CMsgGameMatchSignoutResponse| { &m.ow_private_key },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.ow_private_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ow_salt",
            |m: &CMsgGameMatchSignoutResponse| { &m.ow_salt },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.ow_salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ow_replay_id",
            |m: &CMsgGameMatchSignoutResponse| { &m.ow_replay_id },
            |m: &mut CMsgGameMatchSignoutResponse| { &mut m.ow_replay_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameMatchSignoutResponse>(
            "CMsgGameMatchSignoutResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameMatchSignoutResponse {
    const NAME: &'static str = "CMsgGameMatchSignoutResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.replay_salt = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.timed_reward_details.push(is.read_message()?);
                },
                34 => {
                    self.xp_reward_details.push(is.read_message()?);
                },
                40 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.metadata_private_key = ::std::option::Option::Some(is.read_fixed32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_details)?;
                },
                74 => {
                    self.players_metadata.push(is.read_message()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mvp_data)?;
                },
                89 => {
                    self.ow_private_key = ::std::option::Option::Some(is.read_fixed64()?);
                },
                101 => {
                    self.ow_salt = ::std::option::Option::Some(is.read_fixed32()?);
                },
                104 => {
                    self.ow_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.replay_salt {
            my_size += 1 + 4;
        }
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.xp_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.metadata_private_key {
            my_size += 1 + 4;
        }
        if let Some(v) = self.match_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.players_metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.mvp_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ow_private_key {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ow_salt {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ow_replay_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.replay_salt {
            os.write_fixed32(2, v)?;
        }
        for v in &self.timed_reward_details {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.xp_reward_details {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.leagueid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.metadata_private_key {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.match_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.players_metadata {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.mvp_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.ow_private_key {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.ow_salt {
            os.write_fixed32(12, v)?;
        }
        if let Some(v) = self.ow_replay_id {
            os.write_uint64(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignoutResponse {
        CMsgGameMatchSignoutResponse::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.replay_salt = ::std::option::Option::None;
        self.timed_reward_details.clear();
        self.xp_reward_details.clear();
        self.leagueid = ::std::option::Option::None;
        self.metadata_private_key = ::std::option::Option::None;
        self.match_details.clear();
        self.players_metadata.clear();
        self.mvp_data.clear();
        self.ow_private_key = ::std::option::Option::None;
        self.ow_salt = ::std::option::Option::None;
        self.ow_replay_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignoutResponse {
        static instance: CMsgGameMatchSignoutResponse = CMsgGameMatchSignoutResponse {
            match_id: ::std::option::Option::None,
            replay_salt: ::std::option::Option::None,
            timed_reward_details: ::std::vec::Vec::new(),
            xp_reward_details: ::std::vec::Vec::new(),
            leagueid: ::std::option::Option::None,
            metadata_private_key: ::std::option::Option::None,
            match_details: ::protobuf::MessageField::none(),
            players_metadata: ::std::vec::Vec::new(),
            mvp_data: ::protobuf::MessageField::none(),
            ow_private_key: ::std::option::Option::None,
            ow_salt: ::std::option::Option::None,
            ow_replay_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameMatchSignoutResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameMatchSignoutResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameMatchSignoutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignoutResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameMatchSignoutResponse`
pub mod cmsg_game_match_signout_response {
    // @@protoc_insertion_point(message:dota.CMsgGameMatchSignoutResponse.PlayerMetadata)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerMetadata {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.avg_kills_x16)
        pub avg_kills_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.avg_deaths_x16)
        pub avg_deaths_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.avg_assists_x16)
        pub avg_assists_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.avg_gpm_x16)
        pub avg_gpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.avg_xpm_x16)
        pub avg_xpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.best_kills_x16)
        pub best_kills_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.best_assists_x16)
        pub best_assists_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.best_gpm_x16)
        pub best_gpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.best_xpm_x16)
        pub best_xpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.win_streak)
        pub win_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.best_win_streak)
        pub best_win_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.games_played)
        pub games_played: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignoutResponse.PlayerMetadata.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerMetadata {
        fn default() -> &'a PlayerMetadata {
            <PlayerMetadata as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerMetadata {
        pub fn new() -> PlayerMetadata {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_kills_x16 = 2;

        pub fn avg_kills_x16(&self) -> u32 {
            self.avg_kills_x16.unwrap_or(0)
        }

        pub fn clear_avg_kills_x16(&mut self) {
            self.avg_kills_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_kills_x16(&self) -> bool {
            self.avg_kills_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_kills_x16(&mut self, v: u32) {
            self.avg_kills_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_deaths_x16 = 3;

        pub fn avg_deaths_x16(&self) -> u32 {
            self.avg_deaths_x16.unwrap_or(0)
        }

        pub fn clear_avg_deaths_x16(&mut self) {
            self.avg_deaths_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_deaths_x16(&self) -> bool {
            self.avg_deaths_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_deaths_x16(&mut self, v: u32) {
            self.avg_deaths_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_assists_x16 = 4;

        pub fn avg_assists_x16(&self) -> u32 {
            self.avg_assists_x16.unwrap_or(0)
        }

        pub fn clear_avg_assists_x16(&mut self) {
            self.avg_assists_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_assists_x16(&self) -> bool {
            self.avg_assists_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_assists_x16(&mut self, v: u32) {
            self.avg_assists_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_gpm_x16 = 5;

        pub fn avg_gpm_x16(&self) -> u32 {
            self.avg_gpm_x16.unwrap_or(0)
        }

        pub fn clear_avg_gpm_x16(&mut self) {
            self.avg_gpm_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_gpm_x16(&self) -> bool {
            self.avg_gpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_gpm_x16(&mut self, v: u32) {
            self.avg_gpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_xpm_x16 = 6;

        pub fn avg_xpm_x16(&self) -> u32 {
            self.avg_xpm_x16.unwrap_or(0)
        }

        pub fn clear_avg_xpm_x16(&mut self) {
            self.avg_xpm_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_xpm_x16(&self) -> bool {
            self.avg_xpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_xpm_x16(&mut self, v: u32) {
            self.avg_xpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_kills_x16 = 7;

        pub fn best_kills_x16(&self) -> u32 {
            self.best_kills_x16.unwrap_or(0)
        }

        pub fn clear_best_kills_x16(&mut self) {
            self.best_kills_x16 = ::std::option::Option::None;
        }

        pub fn has_best_kills_x16(&self) -> bool {
            self.best_kills_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_kills_x16(&mut self, v: u32) {
            self.best_kills_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_assists_x16 = 8;

        pub fn best_assists_x16(&self) -> u32 {
            self.best_assists_x16.unwrap_or(0)
        }

        pub fn clear_best_assists_x16(&mut self) {
            self.best_assists_x16 = ::std::option::Option::None;
        }

        pub fn has_best_assists_x16(&self) -> bool {
            self.best_assists_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_assists_x16(&mut self, v: u32) {
            self.best_assists_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_gpm_x16 = 9;

        pub fn best_gpm_x16(&self) -> u32 {
            self.best_gpm_x16.unwrap_or(0)
        }

        pub fn clear_best_gpm_x16(&mut self) {
            self.best_gpm_x16 = ::std::option::Option::None;
        }

        pub fn has_best_gpm_x16(&self) -> bool {
            self.best_gpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_gpm_x16(&mut self, v: u32) {
            self.best_gpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_xpm_x16 = 10;

        pub fn best_xpm_x16(&self) -> u32 {
            self.best_xpm_x16.unwrap_or(0)
        }

        pub fn clear_best_xpm_x16(&mut self) {
            self.best_xpm_x16 = ::std::option::Option::None;
        }

        pub fn has_best_xpm_x16(&self) -> bool {
            self.best_xpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_xpm_x16(&mut self, v: u32) {
            self.best_xpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 win_streak = 11;

        pub fn win_streak(&self) -> u32 {
            self.win_streak.unwrap_or(0)
        }

        pub fn clear_win_streak(&mut self) {
            self.win_streak = ::std::option::Option::None;
        }

        pub fn has_win_streak(&self) -> bool {
            self.win_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_streak(&mut self, v: u32) {
            self.win_streak = ::std::option::Option::Some(v);
        }

        // optional uint32 best_win_streak = 12;

        pub fn best_win_streak(&self) -> u32 {
            self.best_win_streak.unwrap_or(0)
        }

        pub fn clear_best_win_streak(&mut self) {
            self.best_win_streak = ::std::option::Option::None;
        }

        pub fn has_best_win_streak(&self) -> bool {
            self.best_win_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_win_streak(&mut self, v: u32) {
            self.best_win_streak = ::std::option::Option::Some(v);
        }

        // optional uint32 games_played = 13;

        pub fn games_played(&self) -> u32 {
            self.games_played.unwrap_or(0)
        }

        pub fn clear_games_played(&mut self) {
            self.games_played = ::std::option::Option::None;
        }

        pub fn has_games_played(&self) -> bool {
            self.games_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_games_played(&mut self, v: u32) {
            self.games_played = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &PlayerMetadata| { &m.hero_id },
                |m: &mut PlayerMetadata| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_kills_x16",
                |m: &PlayerMetadata| { &m.avg_kills_x16 },
                |m: &mut PlayerMetadata| { &mut m.avg_kills_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_deaths_x16",
                |m: &PlayerMetadata| { &m.avg_deaths_x16 },
                |m: &mut PlayerMetadata| { &mut m.avg_deaths_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_assists_x16",
                |m: &PlayerMetadata| { &m.avg_assists_x16 },
                |m: &mut PlayerMetadata| { &mut m.avg_assists_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_gpm_x16",
                |m: &PlayerMetadata| { &m.avg_gpm_x16 },
                |m: &mut PlayerMetadata| { &mut m.avg_gpm_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_xpm_x16",
                |m: &PlayerMetadata| { &m.avg_xpm_x16 },
                |m: &mut PlayerMetadata| { &mut m.avg_xpm_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_kills_x16",
                |m: &PlayerMetadata| { &m.best_kills_x16 },
                |m: &mut PlayerMetadata| { &mut m.best_kills_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_assists_x16",
                |m: &PlayerMetadata| { &m.best_assists_x16 },
                |m: &mut PlayerMetadata| { &mut m.best_assists_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_gpm_x16",
                |m: &PlayerMetadata| { &m.best_gpm_x16 },
                |m: &mut PlayerMetadata| { &mut m.best_gpm_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_xpm_x16",
                |m: &PlayerMetadata| { &m.best_xpm_x16 },
                |m: &mut PlayerMetadata| { &mut m.best_xpm_x16 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "win_streak",
                |m: &PlayerMetadata| { &m.win_streak },
                |m: &mut PlayerMetadata| { &mut m.win_streak },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_win_streak",
                |m: &PlayerMetadata| { &m.best_win_streak },
                |m: &mut PlayerMetadata| { &mut m.best_win_streak },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "games_played",
                |m: &PlayerMetadata| { &m.games_played },
                |m: &mut PlayerMetadata| { &mut m.games_played },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerMetadata>(
                "CMsgGameMatchSignoutResponse.PlayerMetadata",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerMetadata {
        const NAME: &'static str = "PlayerMetadata";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.avg_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.avg_deaths_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.avg_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.avg_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.avg_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.best_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.best_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.best_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.best_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.win_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.best_win_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.games_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.avg_kills_x16 {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.avg_deaths_x16 {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.avg_assists_x16 {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.avg_gpm_x16 {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.avg_xpm_x16 {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.best_kills_x16 {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.best_assists_x16 {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.best_gpm_x16 {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.best_xpm_x16 {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.win_streak {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.best_win_streak {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.games_played {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.avg_kills_x16 {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.avg_deaths_x16 {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.avg_assists_x16 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.avg_gpm_x16 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.avg_xpm_x16 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.best_kills_x16 {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.best_assists_x16 {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.best_gpm_x16 {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.best_xpm_x16 {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.win_streak {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.best_win_streak {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.games_played {
                os.write_uint32(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerMetadata {
            PlayerMetadata::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.avg_kills_x16 = ::std::option::Option::None;
            self.avg_deaths_x16 = ::std::option::Option::None;
            self.avg_assists_x16 = ::std::option::Option::None;
            self.avg_gpm_x16 = ::std::option::Option::None;
            self.avg_xpm_x16 = ::std::option::Option::None;
            self.best_kills_x16 = ::std::option::Option::None;
            self.best_assists_x16 = ::std::option::Option::None;
            self.best_gpm_x16 = ::std::option::Option::None;
            self.best_xpm_x16 = ::std::option::Option::None;
            self.win_streak = ::std::option::Option::None;
            self.best_win_streak = ::std::option::Option::None;
            self.games_played = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerMetadata {
            static instance: PlayerMetadata = PlayerMetadata {
                hero_id: ::std::option::Option::None,
                avg_kills_x16: ::std::option::Option::None,
                avg_deaths_x16: ::std::option::Option::None,
                avg_assists_x16: ::std::option::Option::None,
                avg_gpm_x16: ::std::option::Option::None,
                avg_xpm_x16: ::std::option::Option::None,
                best_kills_x16: ::std::option::Option::None,
                best_assists_x16: ::std::option::Option::None,
                best_gpm_x16: ::std::option::Option::None,
                best_xpm_x16: ::std::option::Option::None,
                win_streak: ::std::option::Option::None,
                best_win_streak: ::std::option::Option::None,
                games_played: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerMetadata {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameMatchSignoutResponse.PlayerMetadata").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerMetadata {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerMetadata {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgTimedRewardContainer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTimedRewardContainer {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTimedRewardContainer.timed_reward_details)
    pub timed_reward_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CLobbyTimedRewardDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTimedRewardContainer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTimedRewardContainer {
    fn default() -> &'a CMsgTimedRewardContainer {
        <CMsgTimedRewardContainer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTimedRewardContainer {
    pub fn new() -> CMsgTimedRewardContainer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timed_reward_details",
            |m: &CMsgTimedRewardContainer| { &m.timed_reward_details },
            |m: &mut CMsgTimedRewardContainer| { &mut m.timed_reward_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTimedRewardContainer>(
            "CMsgTimedRewardContainer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTimedRewardContainer {
    const NAME: &'static str = "CMsgTimedRewardContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.timed_reward_details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.timed_reward_details {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTimedRewardContainer {
        CMsgTimedRewardContainer::new()
    }

    fn clear(&mut self) {
        self.timed_reward_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTimedRewardContainer {
        static instance: CMsgTimedRewardContainer = CMsgTimedRewardContainer {
            timed_reward_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTimedRewardContainer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTimedRewardContainer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTimedRewardContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTimedRewardContainer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameMatchSignOutPermissionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutPermissionRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPermissionRequest.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPermissionRequest.local_attempt)
    pub local_attempt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPermissionRequest.total_attempt)
    pub total_attempt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPermissionRequest.seconds_waited)
    pub seconds_waited: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOutPermissionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutPermissionRequest {
    fn default() -> &'a CMsgGameMatchSignOutPermissionRequest {
        <CMsgGameMatchSignOutPermissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutPermissionRequest {
    pub fn new() -> CMsgGameMatchSignOutPermissionRequest {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 1;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 local_attempt = 2;

    pub fn local_attempt(&self) -> u32 {
        self.local_attempt.unwrap_or(0)
    }

    pub fn clear_local_attempt(&mut self) {
        self.local_attempt = ::std::option::Option::None;
    }

    pub fn has_local_attempt(&self) -> bool {
        self.local_attempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_attempt(&mut self, v: u32) {
        self.local_attempt = ::std::option::Option::Some(v);
    }

    // optional uint32 total_attempt = 3;

    pub fn total_attempt(&self) -> u32 {
        self.total_attempt.unwrap_or(0)
    }

    pub fn clear_total_attempt(&mut self) {
        self.total_attempt = ::std::option::Option::None;
    }

    pub fn has_total_attempt(&self) -> bool {
        self.total_attempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_attempt(&mut self, v: u32) {
        self.total_attempt = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_waited = 4;

    pub fn seconds_waited(&self) -> u32 {
        self.seconds_waited.unwrap_or(0)
    }

    pub fn clear_seconds_waited(&mut self) {
        self.seconds_waited = ::std::option::Option::None;
    }

    pub fn has_seconds_waited(&self) -> bool {
        self.seconds_waited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_waited(&mut self, v: u32) {
        self.seconds_waited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGameMatchSignOutPermissionRequest| { &m.server_version },
            |m: &mut CMsgGameMatchSignOutPermissionRequest| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_attempt",
            |m: &CMsgGameMatchSignOutPermissionRequest| { &m.local_attempt },
            |m: &mut CMsgGameMatchSignOutPermissionRequest| { &mut m.local_attempt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_attempt",
            |m: &CMsgGameMatchSignOutPermissionRequest| { &m.total_attempt },
            |m: &mut CMsgGameMatchSignOutPermissionRequest| { &mut m.total_attempt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_waited",
            |m: &CMsgGameMatchSignOutPermissionRequest| { &m.seconds_waited },
            |m: &mut CMsgGameMatchSignOutPermissionRequest| { &mut m.seconds_waited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameMatchSignOutPermissionRequest>(
            "CMsgGameMatchSignOutPermissionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutPermissionRequest {
    const NAME: &'static str = "CMsgGameMatchSignOutPermissionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.local_attempt = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.total_attempt = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.seconds_waited = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.local_attempt {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.total_attempt {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.seconds_waited {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.local_attempt {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_attempt {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seconds_waited {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutPermissionRequest {
        CMsgGameMatchSignOutPermissionRequest::new()
    }

    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.local_attempt = ::std::option::Option::None;
        self.total_attempt = ::std::option::Option::None;
        self.seconds_waited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutPermissionRequest {
        static instance: CMsgGameMatchSignOutPermissionRequest = CMsgGameMatchSignOutPermissionRequest {
            server_version: ::std::option::Option::None,
            local_attempt: ::std::option::Option::None,
            total_attempt: ::std::option::Option::None,
            seconds_waited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameMatchSignOutPermissionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOutPermissionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameMatchSignOutPermissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutPermissionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameMatchSignOutPermissionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutPermissionResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPermissionResponse.permission_granted)
    pub permission_granted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPermissionResponse.abandon_signout)
    pub abandon_signout: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPermissionResponse.retry_delay_seconds)
    pub retry_delay_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOutPermissionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutPermissionResponse {
    fn default() -> &'a CMsgGameMatchSignOutPermissionResponse {
        <CMsgGameMatchSignOutPermissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutPermissionResponse {
    pub fn new() -> CMsgGameMatchSignOutPermissionResponse {
        ::std::default::Default::default()
    }

    // optional bool permission_granted = 1;

    pub fn permission_granted(&self) -> bool {
        self.permission_granted.unwrap_or(false)
    }

    pub fn clear_permission_granted(&mut self) {
        self.permission_granted = ::std::option::Option::None;
    }

    pub fn has_permission_granted(&self) -> bool {
        self.permission_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_granted(&mut self, v: bool) {
        self.permission_granted = ::std::option::Option::Some(v);
    }

    // optional bool abandon_signout = 2;

    pub fn abandon_signout(&self) -> bool {
        self.abandon_signout.unwrap_or(false)
    }

    pub fn clear_abandon_signout(&mut self) {
        self.abandon_signout = ::std::option::Option::None;
    }

    pub fn has_abandon_signout(&self) -> bool {
        self.abandon_signout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon_signout(&mut self, v: bool) {
        self.abandon_signout = ::std::option::Option::Some(v);
    }

    // optional uint32 retry_delay_seconds = 3;

    pub fn retry_delay_seconds(&self) -> u32 {
        self.retry_delay_seconds.unwrap_or(0)
    }

    pub fn clear_retry_delay_seconds(&mut self) {
        self.retry_delay_seconds = ::std::option::Option::None;
    }

    pub fn has_retry_delay_seconds(&self) -> bool {
        self.retry_delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_delay_seconds(&mut self, v: u32) {
        self.retry_delay_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permission_granted",
            |m: &CMsgGameMatchSignOutPermissionResponse| { &m.permission_granted },
            |m: &mut CMsgGameMatchSignOutPermissionResponse| { &mut m.permission_granted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abandon_signout",
            |m: &CMsgGameMatchSignOutPermissionResponse| { &m.abandon_signout },
            |m: &mut CMsgGameMatchSignOutPermissionResponse| { &mut m.abandon_signout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "retry_delay_seconds",
            |m: &CMsgGameMatchSignOutPermissionResponse| { &m.retry_delay_seconds },
            |m: &mut CMsgGameMatchSignOutPermissionResponse| { &mut m.retry_delay_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameMatchSignOutPermissionResponse>(
            "CMsgGameMatchSignOutPermissionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutPermissionResponse {
    const NAME: &'static str = "CMsgGameMatchSignOutPermissionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission_granted = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.abandon_signout = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.retry_delay_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission_granted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.abandon_signout {
            my_size += 1 + 1;
        }
        if let Some(v) = self.retry_delay_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission_granted {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.abandon_signout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.retry_delay_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutPermissionResponse {
        CMsgGameMatchSignOutPermissionResponse::new()
    }

    fn clear(&mut self) {
        self.permission_granted = ::std::option::Option::None;
        self.abandon_signout = ::std::option::Option::None;
        self.retry_delay_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutPermissionResponse {
        static instance: CMsgGameMatchSignOutPermissionResponse = CMsgGameMatchSignOutPermissionResponse {
            permission_granted: ::std::option::Option::None,
            abandon_signout: ::std::option::Option::None,
            retry_delay_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameMatchSignOutPermissionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOutPermissionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameMatchSignOutPermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutPermissionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameMatchSignOutEventGameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutEventGameData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutEventGameData.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutEventGameData.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutEventGameData.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutEventGameData.event_game_data)
    pub event_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutEventGameData.start_time)
    pub start_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOutEventGameData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutEventGameData {
    fn default() -> &'a CMsgGameMatchSignOutEventGameData {
        <CMsgGameMatchSignOutEventGameData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutEventGameData {
    pub fn new() -> CMsgGameMatchSignOutEventGameData {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 3;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes event_game_data = 4;

    pub fn event_game_data(&self) -> &[u8] {
        match self.event_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_event_game_data(&mut self) {
        self.event_game_data = ::std::option::Option::None;
    }

    pub fn has_event_game_data(&self) -> bool {
        self.event_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.event_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.event_game_data.is_none() {
            self.event_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.event_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.event_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 start_time = 5;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGameMatchSignOutEventGameData| { &m.event_id },
            |m: &mut CMsgGameMatchSignOutEventGameData| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &CMsgGameMatchSignOutEventGameData| { &m.game_name },
            |m: &mut CMsgGameMatchSignOutEventGameData| { &mut m.game_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CMsgGameMatchSignOutEventGameData| { &m.map_name },
            |m: &mut CMsgGameMatchSignOutEventGameData| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_game_data",
            |m: &CMsgGameMatchSignOutEventGameData| { &m.event_game_data },
            |m: &mut CMsgGameMatchSignOutEventGameData| { &mut m.event_game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgGameMatchSignOutEventGameData| { &m.start_time },
            |m: &mut CMsgGameMatchSignOutEventGameData| { &mut m.start_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameMatchSignOutEventGameData>(
            "CMsgGameMatchSignOutEventGameData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutEventGameData {
    const NAME: &'static str = "CMsgGameMatchSignOutEventGameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.event_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.event_game_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutEventGameData {
        CMsgGameMatchSignOutEventGameData::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.event_game_data = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutEventGameData {
        static instance: CMsgGameMatchSignOutEventGameData = CMsgGameMatchSignOutEventGameData {
            event_id: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            event_game_data: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameMatchSignOutEventGameData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOutEventGameData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameMatchSignOutEventGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutEventGameData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameMatchSignOutPerfData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutPerfData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_frame_time)
    pub average_frame_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_frame_time)
    pub max_frame_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.server_average_frame_time)
    pub server_average_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.server_max_frame_time)
    pub server_max_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_compute_time)
    pub average_compute_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_compute_time)
    pub max_compute_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_client_tick_time)
    pub average_client_tick_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_client_tick_time)
    pub max_client_tick_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_client_simulate_time)
    pub average_client_simulate_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_client_simulate_time)
    pub max_client_simulate_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_output_time)
    pub average_output_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_output_time)
    pub max_output_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_wait_for_rendering_to_complete_time)
    pub average_wait_for_rendering_to_complete_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_wait_for_rendering_to_complete_time)
    pub max_wait_for_rendering_to_complete_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_swap_time)
    pub average_swap_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_swap_time)
    pub max_swap_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_frame_update_time)
    pub average_frame_update_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_frame_update_time)
    pub max_frame_update_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_idle_time)
    pub average_idle_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_idle_time)
    pub max_idle_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.average_input_processing_time)
    pub average_input_processing_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutPerfData.max_input_processing_time)
    pub max_input_processing_time: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOutPerfData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutPerfData {
    fn default() -> &'a CMsgGameMatchSignOutPerfData {
        <CMsgGameMatchSignOutPerfData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutPerfData {
    pub fn new() -> CMsgGameMatchSignOutPerfData {
        ::std::default::Default::default()
    }

    // optional float server_average_frame_time = 3;

    pub fn server_average_frame_time(&self) -> f32 {
        self.server_average_frame_time.unwrap_or(0.)
    }

    pub fn clear_server_average_frame_time(&mut self) {
        self.server_average_frame_time = ::std::option::Option::None;
    }

    pub fn has_server_average_frame_time(&self) -> bool {
        self.server_average_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_average_frame_time(&mut self, v: f32) {
        self.server_average_frame_time = ::std::option::Option::Some(v);
    }

    // optional float server_max_frame_time = 4;

    pub fn server_max_frame_time(&self) -> f32 {
        self.server_max_frame_time.unwrap_or(0.)
    }

    pub fn clear_server_max_frame_time(&mut self) {
        self.server_max_frame_time = ::std::option::Option::None;
    }

    pub fn has_server_max_frame_time(&self) -> bool {
        self.server_max_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_max_frame_time(&mut self, v: f32) {
        self.server_max_frame_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_frame_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_frame_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_frame_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_frame_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_frame_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_frame_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_average_frame_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.server_average_frame_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.server_average_frame_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_max_frame_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.server_max_frame_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.server_max_frame_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_compute_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_compute_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_compute_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_compute_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_compute_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_compute_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_client_tick_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_client_tick_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_client_tick_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_client_tick_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_client_tick_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_client_tick_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_client_simulate_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_client_simulate_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_client_simulate_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_client_simulate_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_client_simulate_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_client_simulate_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_output_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_output_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_output_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_output_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_output_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_output_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_wait_for_rendering_to_complete_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_wait_for_rendering_to_complete_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_wait_for_rendering_to_complete_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_wait_for_rendering_to_complete_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_wait_for_rendering_to_complete_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_wait_for_rendering_to_complete_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_swap_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_swap_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_swap_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_swap_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_swap_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_swap_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_frame_update_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_frame_update_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_frame_update_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_frame_update_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_frame_update_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_frame_update_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_idle_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_idle_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_idle_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_idle_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_idle_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_idle_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "average_input_processing_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.average_input_processing_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.average_input_processing_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_input_processing_time",
            |m: &CMsgGameMatchSignOutPerfData| { &m.max_input_processing_time },
            |m: &mut CMsgGameMatchSignOutPerfData| { &mut m.max_input_processing_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameMatchSignOutPerfData>(
            "CMsgGameMatchSignOutPerfData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutPerfData {
    const NAME: &'static str = "CMsgGameMatchSignOutPerfData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.average_frame_time)?;
                },
                13 => {
                    self.average_frame_time.push(is.read_float()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.max_frame_time)?;
                },
                21 => {
                    self.max_frame_time.push(is.read_float()?);
                },
                29 => {
                    self.server_average_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.server_max_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_float_into(&mut self.average_compute_time)?;
                },
                45 => {
                    self.average_compute_time.push(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_float_into(&mut self.max_compute_time)?;
                },
                53 => {
                    self.max_compute_time.push(is.read_float()?);
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.average_client_tick_time)?;
                },
                61 => {
                    self.average_client_tick_time.push(is.read_float()?);
                },
                66 => {
                    is.read_repeated_packed_float_into(&mut self.max_client_tick_time)?;
                },
                69 => {
                    self.max_client_tick_time.push(is.read_float()?);
                },
                74 => {
                    is.read_repeated_packed_float_into(&mut self.average_client_simulate_time)?;
                },
                77 => {
                    self.average_client_simulate_time.push(is.read_float()?);
                },
                82 => {
                    is.read_repeated_packed_float_into(&mut self.max_client_simulate_time)?;
                },
                85 => {
                    self.max_client_simulate_time.push(is.read_float()?);
                },
                90 => {
                    is.read_repeated_packed_float_into(&mut self.average_output_time)?;
                },
                93 => {
                    self.average_output_time.push(is.read_float()?);
                },
                98 => {
                    is.read_repeated_packed_float_into(&mut self.max_output_time)?;
                },
                101 => {
                    self.max_output_time.push(is.read_float()?);
                },
                106 => {
                    is.read_repeated_packed_float_into(&mut self.average_wait_for_rendering_to_complete_time)?;
                },
                109 => {
                    self.average_wait_for_rendering_to_complete_time.push(is.read_float()?);
                },
                114 => {
                    is.read_repeated_packed_float_into(&mut self.max_wait_for_rendering_to_complete_time)?;
                },
                117 => {
                    self.max_wait_for_rendering_to_complete_time.push(is.read_float()?);
                },
                122 => {
                    is.read_repeated_packed_float_into(&mut self.average_swap_time)?;
                },
                125 => {
                    self.average_swap_time.push(is.read_float()?);
                },
                130 => {
                    is.read_repeated_packed_float_into(&mut self.max_swap_time)?;
                },
                133 => {
                    self.max_swap_time.push(is.read_float()?);
                },
                138 => {
                    is.read_repeated_packed_float_into(&mut self.average_frame_update_time)?;
                },
                141 => {
                    self.average_frame_update_time.push(is.read_float()?);
                },
                146 => {
                    is.read_repeated_packed_float_into(&mut self.max_frame_update_time)?;
                },
                149 => {
                    self.max_frame_update_time.push(is.read_float()?);
                },
                154 => {
                    is.read_repeated_packed_float_into(&mut self.average_idle_time)?;
                },
                157 => {
                    self.average_idle_time.push(is.read_float()?);
                },
                162 => {
                    is.read_repeated_packed_float_into(&mut self.max_idle_time)?;
                },
                165 => {
                    self.max_idle_time.push(is.read_float()?);
                },
                170 => {
                    is.read_repeated_packed_float_into(&mut self.average_input_processing_time)?;
                },
                173 => {
                    self.average_input_processing_time.push(is.read_float()?);
                },
                178 => {
                    is.read_repeated_packed_float_into(&mut self.max_input_processing_time)?;
                },
                181 => {
                    self.max_input_processing_time.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.average_frame_time.len() as u64;
        my_size += 5 * self.max_frame_time.len() as u64;
        if let Some(v) = self.server_average_frame_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_max_frame_time {
            my_size += 1 + 4;
        }
        my_size += 5 * self.average_compute_time.len() as u64;
        my_size += 5 * self.max_compute_time.len() as u64;
        my_size += 5 * self.average_client_tick_time.len() as u64;
        my_size += 5 * self.max_client_tick_time.len() as u64;
        my_size += 5 * self.average_client_simulate_time.len() as u64;
        my_size += 5 * self.max_client_simulate_time.len() as u64;
        my_size += 5 * self.average_output_time.len() as u64;
        my_size += 5 * self.max_output_time.len() as u64;
        my_size += 5 * self.average_wait_for_rendering_to_complete_time.len() as u64;
        my_size += 5 * self.max_wait_for_rendering_to_complete_time.len() as u64;
        my_size += 5 * self.average_swap_time.len() as u64;
        my_size += 6 * self.max_swap_time.len() as u64;
        my_size += 6 * self.average_frame_update_time.len() as u64;
        my_size += 6 * self.max_frame_update_time.len() as u64;
        my_size += 6 * self.average_idle_time.len() as u64;
        my_size += 6 * self.max_idle_time.len() as u64;
        my_size += 6 * self.average_input_processing_time.len() as u64;
        my_size += 6 * self.max_input_processing_time.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.average_frame_time {
            os.write_float(1, *v)?;
        };
        for v in &self.max_frame_time {
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.server_average_frame_time {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.server_max_frame_time {
            os.write_float(4, v)?;
        }
        for v in &self.average_compute_time {
            os.write_float(5, *v)?;
        };
        for v in &self.max_compute_time {
            os.write_float(6, *v)?;
        };
        for v in &self.average_client_tick_time {
            os.write_float(7, *v)?;
        };
        for v in &self.max_client_tick_time {
            os.write_float(8, *v)?;
        };
        for v in &self.average_client_simulate_time {
            os.write_float(9, *v)?;
        };
        for v in &self.max_client_simulate_time {
            os.write_float(10, *v)?;
        };
        for v in &self.average_output_time {
            os.write_float(11, *v)?;
        };
        for v in &self.max_output_time {
            os.write_float(12, *v)?;
        };
        for v in &self.average_wait_for_rendering_to_complete_time {
            os.write_float(13, *v)?;
        };
        for v in &self.max_wait_for_rendering_to_complete_time {
            os.write_float(14, *v)?;
        };
        for v in &self.average_swap_time {
            os.write_float(15, *v)?;
        };
        for v in &self.max_swap_time {
            os.write_float(16, *v)?;
        };
        for v in &self.average_frame_update_time {
            os.write_float(17, *v)?;
        };
        for v in &self.max_frame_update_time {
            os.write_float(18, *v)?;
        };
        for v in &self.average_idle_time {
            os.write_float(19, *v)?;
        };
        for v in &self.max_idle_time {
            os.write_float(20, *v)?;
        };
        for v in &self.average_input_processing_time {
            os.write_float(21, *v)?;
        };
        for v in &self.max_input_processing_time {
            os.write_float(22, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutPerfData {
        CMsgGameMatchSignOutPerfData::new()
    }

    fn clear(&mut self) {
        self.average_frame_time.clear();
        self.max_frame_time.clear();
        self.server_average_frame_time = ::std::option::Option::None;
        self.server_max_frame_time = ::std::option::Option::None;
        self.average_compute_time.clear();
        self.max_compute_time.clear();
        self.average_client_tick_time.clear();
        self.max_client_tick_time.clear();
        self.average_client_simulate_time.clear();
        self.max_client_simulate_time.clear();
        self.average_output_time.clear();
        self.max_output_time.clear();
        self.average_wait_for_rendering_to_complete_time.clear();
        self.max_wait_for_rendering_to_complete_time.clear();
        self.average_swap_time.clear();
        self.max_swap_time.clear();
        self.average_frame_update_time.clear();
        self.max_frame_update_time.clear();
        self.average_idle_time.clear();
        self.max_idle_time.clear();
        self.average_input_processing_time.clear();
        self.max_input_processing_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutPerfData {
        static instance: CMsgGameMatchSignOutPerfData = CMsgGameMatchSignOutPerfData {
            average_frame_time: ::std::vec::Vec::new(),
            max_frame_time: ::std::vec::Vec::new(),
            server_average_frame_time: ::std::option::Option::None,
            server_max_frame_time: ::std::option::Option::None,
            average_compute_time: ::std::vec::Vec::new(),
            max_compute_time: ::std::vec::Vec::new(),
            average_client_tick_time: ::std::vec::Vec::new(),
            max_client_tick_time: ::std::vec::Vec::new(),
            average_client_simulate_time: ::std::vec::Vec::new(),
            max_client_simulate_time: ::std::vec::Vec::new(),
            average_output_time: ::std::vec::Vec::new(),
            max_output_time: ::std::vec::Vec::new(),
            average_wait_for_rendering_to_complete_time: ::std::vec::Vec::new(),
            max_wait_for_rendering_to_complete_time: ::std::vec::Vec::new(),
            average_swap_time: ::std::vec::Vec::new(),
            max_swap_time: ::std::vec::Vec::new(),
            average_frame_update_time: ::std::vec::Vec::new(),
            max_frame_update_time: ::std::vec::Vec::new(),
            average_idle_time: ::std::vec::Vec::new(),
            max_idle_time: ::std::vec::Vec::new(),
            average_input_processing_time: ::std::vec::Vec::new(),
            max_input_processing_time: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameMatchSignOutPerfData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOutPerfData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameMatchSignOutPerfData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutPerfData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameMatchSignOutBanData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutBanData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutBanData.hero_bans)
    pub hero_bans: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameMatchSignOutBanData.hero_ban_votes)
    pub hero_ban_votes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameMatchSignOutBanData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutBanData {
    fn default() -> &'a CMsgGameMatchSignOutBanData {
        <CMsgGameMatchSignOutBanData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutBanData {
    pub fn new() -> CMsgGameMatchSignOutBanData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_bans",
            |m: &CMsgGameMatchSignOutBanData| { &m.hero_bans },
            |m: &mut CMsgGameMatchSignOutBanData| { &mut m.hero_bans },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_ban_votes",
            |m: &CMsgGameMatchSignOutBanData| { &m.hero_ban_votes },
            |m: &mut CMsgGameMatchSignOutBanData| { &mut m.hero_ban_votes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameMatchSignOutBanData>(
            "CMsgGameMatchSignOutBanData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutBanData {
    const NAME: &'static str = "CMsgGameMatchSignOutBanData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.hero_bans)?;
                },
                8 => {
                    self.hero_bans.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.hero_ban_votes)?;
                },
                16 => {
                    self.hero_ban_votes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_bans {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.hero_ban_votes {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hero_bans {
            os.write_uint32(1, *v)?;
        };
        for v in &self.hero_ban_votes {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutBanData {
        CMsgGameMatchSignOutBanData::new()
    }

    fn clear(&mut self) {
        self.hero_bans.clear();
        self.hero_ban_votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutBanData {
        static instance: CMsgGameMatchSignOutBanData = CMsgGameMatchSignOutBanData {
            hero_bans: ::std::vec::Vec::new(),
            hero_ban_votes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameMatchSignOutBanData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameMatchSignOutBanData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameMatchSignOutBanData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutBanData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTALiveScoreboardUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALiveScoreboardUpdate {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.tournament_game_id)
    pub tournament_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.hltv_delay)
    pub hltv_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.team_good)
    pub team_good: ::protobuf::MessageField<cmsg_dotalive_scoreboard_update::Team>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.team_bad)
    pub team_bad: ::protobuf::MessageField<cmsg_dotalive_scoreboard_update::Team>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.roshan_respawn_timer)
    pub roshan_respawn_timer: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALiveScoreboardUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALiveScoreboardUpdate {
    fn default() -> &'a CMsgDOTALiveScoreboardUpdate {
        <CMsgDOTALiveScoreboardUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALiveScoreboardUpdate {
    pub fn new() -> CMsgDOTALiveScoreboardUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 tournament_id = 1;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_game_id = 2;

    pub fn tournament_game_id(&self) -> u32 {
        self.tournament_game_id.unwrap_or(0)
    }

    pub fn clear_tournament_game_id(&mut self) {
        self.tournament_game_id = ::std::option::Option::None;
    }

    pub fn has_tournament_game_id(&self) -> bool {
        self.tournament_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_game_id(&mut self, v: u32) {
        self.tournament_game_id = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 hltv_delay = 4;

    pub fn hltv_delay(&self) -> i32 {
        self.hltv_delay.unwrap_or(0)
    }

    pub fn clear_hltv_delay(&mut self) {
        self.hltv_delay = ::std::option::Option::None;
    }

    pub fn has_hltv_delay(&self) -> bool {
        self.hltv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_delay(&mut self, v: i32) {
        self.hltv_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 roshan_respawn_timer = 7;

    pub fn roshan_respawn_timer(&self) -> u32 {
        self.roshan_respawn_timer.unwrap_or(0)
    }

    pub fn clear_roshan_respawn_timer(&mut self) {
        self.roshan_respawn_timer = ::std::option::Option::None;
    }

    pub fn has_roshan_respawn_timer(&self) -> bool {
        self.roshan_respawn_timer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_respawn_timer(&mut self, v: u32) {
        self.roshan_respawn_timer = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 8;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 9;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_id",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.tournament_id },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.tournament_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_game_id",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.tournament_game_id },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.tournament_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.duration },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hltv_delay",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.hltv_delay },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.hltv_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotalive_scoreboard_update::Team>(
            "team_good",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.team_good },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.team_good },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotalive_scoreboard_update::Team>(
            "team_bad",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.team_bad },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.team_bad },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roshan_respawn_timer",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.roshan_respawn_timer },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.roshan_respawn_timer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.league_id },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgDOTALiveScoreboardUpdate| { &m.match_id },
            |m: &mut CMsgDOTALiveScoreboardUpdate| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALiveScoreboardUpdate>(
            "CMsgDOTALiveScoreboardUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALiveScoreboardUpdate {
    const NAME: &'static str = "CMsgDOTALiveScoreboardUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tournament_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.hltv_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.team_good)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.team_bad)?;
                },
                56 => {
                    self.roshan_respawn_timer = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tournament_game_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hltv_delay {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.team_good.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.team_bad.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.roshan_respawn_timer {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tournament_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tournament_game_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.hltv_delay {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.team_good.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.team_bad.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.roshan_respawn_timer {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALiveScoreboardUpdate {
        CMsgDOTALiveScoreboardUpdate::new()
    }

    fn clear(&mut self) {
        self.tournament_id = ::std::option::Option::None;
        self.tournament_game_id = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.hltv_delay = ::std::option::Option::None;
        self.team_good.clear();
        self.team_bad.clear();
        self.roshan_respawn_timer = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALiveScoreboardUpdate {
        static instance: CMsgDOTALiveScoreboardUpdate = CMsgDOTALiveScoreboardUpdate {
            tournament_id: ::std::option::Option::None,
            tournament_game_id: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            hltv_delay: ::std::option::Option::None,
            team_good: ::protobuf::MessageField::none(),
            team_bad: ::protobuf::MessageField::none(),
            roshan_respawn_timer: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALiveScoreboardUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALiveScoreboardUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALiveScoreboardUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALiveScoreboardUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALiveScoreboardUpdate`
pub mod cmsg_dotalive_scoreboard_update {
    // @@protoc_insertion_point(message:dota.CMsgDOTALiveScoreboardUpdate.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.players)
        pub players: ::std::vec::Vec<team::Player>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.tower_state)
        pub tower_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.barracks_state)
        pub barracks_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.hero_picks)
        pub hero_picks: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.hero_bans)
        pub hero_bans: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALiveScoreboardUpdate.Team.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 score = 2;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_state = 3;

        pub fn tower_state(&self) -> u32 {
            self.tower_state.unwrap_or(0)
        }

        pub fn clear_tower_state(&mut self) {
            self.tower_state = ::std::option::Option::None;
        }

        pub fn has_tower_state(&self) -> bool {
            self.tower_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_state(&mut self, v: u32) {
            self.tower_state = ::std::option::Option::Some(v);
        }

        // optional uint32 barracks_state = 4;

        pub fn barracks_state(&self) -> u32 {
            self.barracks_state.unwrap_or(0)
        }

        pub fn clear_barracks_state(&mut self) {
            self.barracks_state = ::std::option::Option::None;
        }

        pub fn has_barracks_state(&self) -> bool {
            self.barracks_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_barracks_state(&mut self, v: u32) {
            self.barracks_state = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "players",
                |m: &Team| { &m.players },
                |m: &mut Team| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &Team| { &m.score },
                |m: &mut Team| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_state",
                |m: &Team| { &m.tower_state },
                |m: &mut Team| { &mut m.tower_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "barracks_state",
                |m: &Team| { &m.barracks_state },
                |m: &mut Team| { &mut m.barracks_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hero_picks",
                |m: &Team| { &m.hero_picks },
                |m: &mut Team| { &mut m.hero_picks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hero_bans",
                |m: &Team| { &m.hero_bans },
                |m: &mut Team| { &mut m.hero_bans },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Team>(
                "CMsgDOTALiveScoreboardUpdate.Team",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.players.push(is.read_message()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tower_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.barracks_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        is.read_repeated_packed_uint32_into(&mut self.hero_picks)?;
                    },
                    40 => {
                        self.hero_picks.push(is.read_uint32()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.hero_bans)?;
                    },
                    48 => {
                        self.hero_bans.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tower_state {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.barracks_state {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.hero_picks {
                my_size += ::protobuf::rt::uint32_size(5, *value);
            };
            for value in &self.hero_bans {
                my_size += ::protobuf::rt::uint32_size(6, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.players {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.score {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tower_state {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.barracks_state {
                os.write_uint32(4, v)?;
            }
            for v in &self.hero_picks {
                os.write_uint32(5, *v)?;
            };
            for v in &self.hero_bans {
                os.write_uint32(6, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.players.clear();
            self.score = ::std::option::Option::None;
            self.tower_state = ::std::option::Option::None;
            self.barracks_state = ::std::option::Option::None;
            self.hero_picks.clear();
            self.hero_bans.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                players: ::std::vec::Vec::new(),
                score: ::std::option::Option::None,
                tower_state: ::std::option::Option::None,
                barracks_state: ::std::option::Option::None,
                hero_picks: ::std::vec::Vec::new(),
                hero_bans: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Team {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALiveScoreboardUpdate.Team").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Team {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Team {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Team`
    pub mod team {
        // @@protoc_insertion_point(message:dota.CMsgDOTALiveScoreboardUpdate.Team.Player)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Player {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.player_name)
            pub player_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.hero_name)
            pub hero_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.hero_id)
            pub hero_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.kills)
            pub kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.deaths)
            pub deaths: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.assists)
            pub assists: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.last_hits)
            pub last_hits: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.denies)
            pub denies: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.gold)
            pub gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.level)
            pub level: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.gold_per_min)
            pub gold_per_min: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.xp_per_min)
            pub xp_per_min: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.ultimate_state)
            pub ultimate_state: ::std::option::Option<::protobuf::EnumOrUnknown<player::DOTAUltimateState>>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.ultimate_cooldown)
            pub ultimate_cooldown: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.item0)
            pub item0: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.item1)
            pub item1: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.item2)
            pub item2: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.item3)
            pub item3: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.item4)
            pub item4: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.item5)
            pub item5: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.respawn_timer)
            pub respawn_timer: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.account_id)
            pub account_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.position_x)
            pub position_x: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.position_y)
            pub position_y: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.net_worth)
            pub net_worth: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.abilities)
            pub abilities: ::std::vec::Vec<player::HeroAbility>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Player {
            fn default() -> &'a Player {
                <Player as ::protobuf::Message>::default_instance()
            }
        }

        impl Player {
            pub fn new() -> Player {
                ::std::default::Default::default()
            }

            // optional uint32 player_slot = 1;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional string player_name = 2;

            pub fn player_name(&self) -> &str {
                match self.player_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_player_name(&mut self) {
                self.player_name = ::std::option::Option::None;
            }

            pub fn has_player_name(&self) -> bool {
                self.player_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_name(&mut self, v: ::std::string::String) {
                self.player_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
                if self.player_name.is_none() {
                    self.player_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.player_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_player_name(&mut self) -> ::std::string::String {
                self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string hero_name = 3;

            pub fn hero_name(&self) -> &str {
                match self.hero_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_hero_name(&mut self) {
                self.hero_name = ::std::option::Option::None;
            }

            pub fn has_hero_name(&self) -> bool {
                self.hero_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_name(&mut self, v: ::std::string::String) {
                self.hero_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
                if self.hero_name.is_none() {
                    self.hero_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.hero_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_hero_name(&mut self) -> ::std::string::String {
                self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 hero_id = 4;

            pub fn hero_id(&self) -> u32 {
                self.hero_id.unwrap_or(0)
            }

            pub fn clear_hero_id(&mut self) {
                self.hero_id = ::std::option::Option::None;
            }

            pub fn has_hero_id(&self) -> bool {
                self.hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_id(&mut self, v: u32) {
                self.hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 kills = 5;

            pub fn kills(&self) -> u32 {
                self.kills.unwrap_or(0)
            }

            pub fn clear_kills(&mut self) {
                self.kills = ::std::option::Option::None;
            }

            pub fn has_kills(&self) -> bool {
                self.kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kills(&mut self, v: u32) {
                self.kills = ::std::option::Option::Some(v);
            }

            // optional uint32 deaths = 6;

            pub fn deaths(&self) -> u32 {
                self.deaths.unwrap_or(0)
            }

            pub fn clear_deaths(&mut self) {
                self.deaths = ::std::option::Option::None;
            }

            pub fn has_deaths(&self) -> bool {
                self.deaths.is_some()
            }

            // Param is passed by value, moved
            pub fn set_deaths(&mut self, v: u32) {
                self.deaths = ::std::option::Option::Some(v);
            }

            // optional uint32 assists = 7;

            pub fn assists(&self) -> u32 {
                self.assists.unwrap_or(0)
            }

            pub fn clear_assists(&mut self) {
                self.assists = ::std::option::Option::None;
            }

            pub fn has_assists(&self) -> bool {
                self.assists.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assists(&mut self, v: u32) {
                self.assists = ::std::option::Option::Some(v);
            }

            // optional uint32 last_hits = 8;

            pub fn last_hits(&self) -> u32 {
                self.last_hits.unwrap_or(0)
            }

            pub fn clear_last_hits(&mut self) {
                self.last_hits = ::std::option::Option::None;
            }

            pub fn has_last_hits(&self) -> bool {
                self.last_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_last_hits(&mut self, v: u32) {
                self.last_hits = ::std::option::Option::Some(v);
            }

            // optional uint32 denies = 9;

            pub fn denies(&self) -> u32 {
                self.denies.unwrap_or(0)
            }

            pub fn clear_denies(&mut self) {
                self.denies = ::std::option::Option::None;
            }

            pub fn has_denies(&self) -> bool {
                self.denies.is_some()
            }

            // Param is passed by value, moved
            pub fn set_denies(&mut self, v: u32) {
                self.denies = ::std::option::Option::Some(v);
            }

            // optional uint32 gold = 10;

            pub fn gold(&self) -> u32 {
                self.gold.unwrap_or(0)
            }

            pub fn clear_gold(&mut self) {
                self.gold = ::std::option::Option::None;
            }

            pub fn has_gold(&self) -> bool {
                self.gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold(&mut self, v: u32) {
                self.gold = ::std::option::Option::Some(v);
            }

            // optional uint32 level = 11;

            pub fn level(&self) -> u32 {
                self.level.unwrap_or(0)
            }

            pub fn clear_level(&mut self) {
                self.level = ::std::option::Option::None;
            }

            pub fn has_level(&self) -> bool {
                self.level.is_some()
            }

            // Param is passed by value, moved
            pub fn set_level(&mut self, v: u32) {
                self.level = ::std::option::Option::Some(v);
            }

            // optional float gold_per_min = 12;

            pub fn gold_per_min(&self) -> f32 {
                self.gold_per_min.unwrap_or(0.)
            }

            pub fn clear_gold_per_min(&mut self) {
                self.gold_per_min = ::std::option::Option::None;
            }

            pub fn has_gold_per_min(&self) -> bool {
                self.gold_per_min.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_per_min(&mut self, v: f32) {
                self.gold_per_min = ::std::option::Option::Some(v);
            }

            // optional float xp_per_min = 13;

            pub fn xp_per_min(&self) -> f32 {
                self.xp_per_min.unwrap_or(0.)
            }

            pub fn clear_xp_per_min(&mut self) {
                self.xp_per_min = ::std::option::Option::None;
            }

            pub fn has_xp_per_min(&self) -> bool {
                self.xp_per_min.is_some()
            }

            // Param is passed by value, moved
            pub fn set_xp_per_min(&mut self, v: f32) {
                self.xp_per_min = ::std::option::Option::Some(v);
            }

            // optional .dota.CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState ultimate_state = 14;

            pub fn ultimate_state(&self) -> player::DOTAUltimateState {
                match self.ultimate_state {
                    Some(e) => e.enum_value_or(player::DOTAUltimateState::k_EDOTAUltimateStateNotLearned),
                    None => player::DOTAUltimateState::k_EDOTAUltimateStateNotLearned,
                }
            }

            pub fn clear_ultimate_state(&mut self) {
                self.ultimate_state = ::std::option::Option::None;
            }

            pub fn has_ultimate_state(&self) -> bool {
                self.ultimate_state.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ultimate_state(&mut self, v: player::DOTAUltimateState) {
                self.ultimate_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional float ultimate_cooldown = 15;

            pub fn ultimate_cooldown(&self) -> f32 {
                self.ultimate_cooldown.unwrap_or(0.)
            }

            pub fn clear_ultimate_cooldown(&mut self) {
                self.ultimate_cooldown = ::std::option::Option::None;
            }

            pub fn has_ultimate_cooldown(&self) -> bool {
                self.ultimate_cooldown.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ultimate_cooldown(&mut self, v: f32) {
                self.ultimate_cooldown = ::std::option::Option::Some(v);
            }

            // optional int32 item0 = 16;

            pub fn item0(&self) -> i32 {
                self.item0.unwrap_or(0)
            }

            pub fn clear_item0(&mut self) {
                self.item0 = ::std::option::Option::None;
            }

            pub fn has_item0(&self) -> bool {
                self.item0.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item0(&mut self, v: i32) {
                self.item0 = ::std::option::Option::Some(v);
            }

            // optional int32 item1 = 17;

            pub fn item1(&self) -> i32 {
                self.item1.unwrap_or(0)
            }

            pub fn clear_item1(&mut self) {
                self.item1 = ::std::option::Option::None;
            }

            pub fn has_item1(&self) -> bool {
                self.item1.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item1(&mut self, v: i32) {
                self.item1 = ::std::option::Option::Some(v);
            }

            // optional int32 item2 = 18;

            pub fn item2(&self) -> i32 {
                self.item2.unwrap_or(0)
            }

            pub fn clear_item2(&mut self) {
                self.item2 = ::std::option::Option::None;
            }

            pub fn has_item2(&self) -> bool {
                self.item2.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item2(&mut self, v: i32) {
                self.item2 = ::std::option::Option::Some(v);
            }

            // optional int32 item3 = 19;

            pub fn item3(&self) -> i32 {
                self.item3.unwrap_or(0)
            }

            pub fn clear_item3(&mut self) {
                self.item3 = ::std::option::Option::None;
            }

            pub fn has_item3(&self) -> bool {
                self.item3.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item3(&mut self, v: i32) {
                self.item3 = ::std::option::Option::Some(v);
            }

            // optional int32 item4 = 20;

            pub fn item4(&self) -> i32 {
                self.item4.unwrap_or(0)
            }

            pub fn clear_item4(&mut self) {
                self.item4 = ::std::option::Option::None;
            }

            pub fn has_item4(&self) -> bool {
                self.item4.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item4(&mut self, v: i32) {
                self.item4 = ::std::option::Option::Some(v);
            }

            // optional int32 item5 = 21;

            pub fn item5(&self) -> i32 {
                self.item5.unwrap_or(0)
            }

            pub fn clear_item5(&mut self) {
                self.item5 = ::std::option::Option::None;
            }

            pub fn has_item5(&self) -> bool {
                self.item5.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item5(&mut self, v: i32) {
                self.item5 = ::std::option::Option::Some(v);
            }

            // optional uint32 respawn_timer = 22;

            pub fn respawn_timer(&self) -> u32 {
                self.respawn_timer.unwrap_or(0)
            }

            pub fn clear_respawn_timer(&mut self) {
                self.respawn_timer = ::std::option::Option::None;
            }

            pub fn has_respawn_timer(&self) -> bool {
                self.respawn_timer.is_some()
            }

            // Param is passed by value, moved
            pub fn set_respawn_timer(&mut self, v: u32) {
                self.respawn_timer = ::std::option::Option::Some(v);
            }

            // optional uint32 account_id = 23;

            pub fn account_id(&self) -> u32 {
                self.account_id.unwrap_or(0)
            }

            pub fn clear_account_id(&mut self) {
                self.account_id = ::std::option::Option::None;
            }

            pub fn has_account_id(&self) -> bool {
                self.account_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_account_id(&mut self, v: u32) {
                self.account_id = ::std::option::Option::Some(v);
            }

            // optional float position_x = 24;

            pub fn position_x(&self) -> f32 {
                self.position_x.unwrap_or(0.)
            }

            pub fn clear_position_x(&mut self) {
                self.position_x = ::std::option::Option::None;
            }

            pub fn has_position_x(&self) -> bool {
                self.position_x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_x(&mut self, v: f32) {
                self.position_x = ::std::option::Option::Some(v);
            }

            // optional float position_y = 25;

            pub fn position_y(&self) -> f32 {
                self.position_y.unwrap_or(0.)
            }

            pub fn clear_position_y(&mut self) {
                self.position_y = ::std::option::Option::None;
            }

            pub fn has_position_y(&self) -> bool {
                self.position_y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_y(&mut self, v: f32) {
                self.position_y = ::std::option::Option::Some(v);
            }

            // optional uint32 net_worth = 26;

            pub fn net_worth(&self) -> u32 {
                self.net_worth.unwrap_or(0)
            }

            pub fn clear_net_worth(&mut self) {
                self.net_worth = ::std::option::Option::None;
            }

            pub fn has_net_worth(&self) -> bool {
                self.net_worth.is_some()
            }

            // Param is passed by value, moved
            pub fn set_net_worth(&mut self, v: u32) {
                self.net_worth = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(27);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "player_slot",
                    |m: &Player| { &m.player_slot },
                    |m: &mut Player| { &mut m.player_slot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "player_name",
                    |m: &Player| { &m.player_name },
                    |m: &mut Player| { &mut m.player_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_name",
                    |m: &Player| { &m.hero_name },
                    |m: &mut Player| { &mut m.hero_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_id",
                    |m: &Player| { &m.hero_id },
                    |m: &mut Player| { &mut m.hero_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "kills",
                    |m: &Player| { &m.kills },
                    |m: &mut Player| { &mut m.kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "deaths",
                    |m: &Player| { &m.deaths },
                    |m: &mut Player| { &mut m.deaths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "assists",
                    |m: &Player| { &m.assists },
                    |m: &mut Player| { &mut m.assists },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "last_hits",
                    |m: &Player| { &m.last_hits },
                    |m: &mut Player| { &mut m.last_hits },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "denies",
                    |m: &Player| { &m.denies },
                    |m: &mut Player| { &mut m.denies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "gold",
                    |m: &Player| { &m.gold },
                    |m: &mut Player| { &mut m.gold },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "level",
                    |m: &Player| { &m.level },
                    |m: &mut Player| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "gold_per_min",
                    |m: &Player| { &m.gold_per_min },
                    |m: &mut Player| { &mut m.gold_per_min },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "xp_per_min",
                    |m: &Player| { &m.xp_per_min },
                    |m: &mut Player| { &mut m.xp_per_min },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ultimate_state",
                    |m: &Player| { &m.ultimate_state },
                    |m: &mut Player| { &mut m.ultimate_state },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ultimate_cooldown",
                    |m: &Player| { &m.ultimate_cooldown },
                    |m: &mut Player| { &mut m.ultimate_cooldown },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item0",
                    |m: &Player| { &m.item0 },
                    |m: &mut Player| { &mut m.item0 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item1",
                    |m: &Player| { &m.item1 },
                    |m: &mut Player| { &mut m.item1 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item2",
                    |m: &Player| { &m.item2 },
                    |m: &mut Player| { &mut m.item2 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item3",
                    |m: &Player| { &m.item3 },
                    |m: &mut Player| { &mut m.item3 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item4",
                    |m: &Player| { &m.item4 },
                    |m: &mut Player| { &mut m.item4 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item5",
                    |m: &Player| { &m.item5 },
                    |m: &mut Player| { &mut m.item5 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "respawn_timer",
                    |m: &Player| { &m.respawn_timer },
                    |m: &mut Player| { &mut m.respawn_timer },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "account_id",
                    |m: &Player| { &m.account_id },
                    |m: &mut Player| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "position_x",
                    |m: &Player| { &m.position_x },
                    |m: &mut Player| { &mut m.position_x },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "position_y",
                    |m: &Player| { &m.position_y },
                    |m: &mut Player| { &mut m.position_y },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "net_worth",
                    |m: &Player| { &m.net_worth },
                    |m: &mut Player| { &mut m.net_worth },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "abilities",
                    |m: &Player| { &m.abilities },
                    |m: &mut Player| { &mut m.abilities },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                    "CMsgDOTALiveScoreboardUpdate.Team.Player",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Player {
            const NAME: &'static str = "Player";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.player_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        26 => {
                            self.hero_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        32 => {
                            self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        56 => {
                            self.assists = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.denies = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        80 => {
                            self.gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        88 => {
                            self.level = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        101 => {
                            self.gold_per_min = ::std::option::Option::Some(is.read_float()?);
                        },
                        109 => {
                            self.xp_per_min = ::std::option::Option::Some(is.read_float()?);
                        },
                        112 => {
                            self.ultimate_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        125 => {
                            self.ultimate_cooldown = ::std::option::Option::Some(is.read_float()?);
                        },
                        128 => {
                            self.item0 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        136 => {
                            self.item1 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        144 => {
                            self.item2 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        152 => {
                            self.item3 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        160 => {
                            self.item4 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        168 => {
                            self.item5 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        176 => {
                            self.respawn_timer = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        184 => {
                            self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        197 => {
                            self.position_x = ::std::option::Option::Some(is.read_float()?);
                        },
                        205 => {
                            self.position_y = ::std::option::Option::Some(is.read_float()?);
                        },
                        208 => {
                            self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        218 => {
                            self.abilities.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.player_slot {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.player_name.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                if let Some(v) = self.hero_name.as_ref() {
                    my_size += ::protobuf::rt::string_size(3, &v);
                }
                if let Some(v) = self.hero_id {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.kills {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.deaths {
                    my_size += ::protobuf::rt::uint32_size(6, v);
                }
                if let Some(v) = self.assists {
                    my_size += ::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.last_hits {
                    my_size += ::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.denies {
                    my_size += ::protobuf::rt::uint32_size(9, v);
                }
                if let Some(v) = self.gold {
                    my_size += ::protobuf::rt::uint32_size(10, v);
                }
                if let Some(v) = self.level {
                    my_size += ::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.gold_per_min {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.xp_per_min {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.ultimate_state {
                    my_size += ::protobuf::rt::int32_size(14, v.value());
                }
                if let Some(v) = self.ultimate_cooldown {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.item0 {
                    my_size += ::protobuf::rt::int32_size(16, v);
                }
                if let Some(v) = self.item1 {
                    my_size += ::protobuf::rt::int32_size(17, v);
                }
                if let Some(v) = self.item2 {
                    my_size += ::protobuf::rt::int32_size(18, v);
                }
                if let Some(v) = self.item3 {
                    my_size += ::protobuf::rt::int32_size(19, v);
                }
                if let Some(v) = self.item4 {
                    my_size += ::protobuf::rt::int32_size(20, v);
                }
                if let Some(v) = self.item5 {
                    my_size += ::protobuf::rt::int32_size(21, v);
                }
                if let Some(v) = self.respawn_timer {
                    my_size += ::protobuf::rt::uint32_size(22, v);
                }
                if let Some(v) = self.account_id {
                    my_size += ::protobuf::rt::uint32_size(23, v);
                }
                if let Some(v) = self.position_x {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.position_y {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.net_worth {
                    my_size += ::protobuf::rt::uint32_size(26, v);
                }
                for value in &self.abilities {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.player_slot {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.player_name.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.hero_name.as_ref() {
                    os.write_string(3, v)?;
                }
                if let Some(v) = self.hero_id {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.kills {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.deaths {
                    os.write_uint32(6, v)?;
                }
                if let Some(v) = self.assists {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.last_hits {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.denies {
                    os.write_uint32(9, v)?;
                }
                if let Some(v) = self.gold {
                    os.write_uint32(10, v)?;
                }
                if let Some(v) = self.level {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.gold_per_min {
                    os.write_float(12, v)?;
                }
                if let Some(v) = self.xp_per_min {
                    os.write_float(13, v)?;
                }
                if let Some(v) = self.ultimate_state {
                    os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.ultimate_cooldown {
                    os.write_float(15, v)?;
                }
                if let Some(v) = self.item0 {
                    os.write_int32(16, v)?;
                }
                if let Some(v) = self.item1 {
                    os.write_int32(17, v)?;
                }
                if let Some(v) = self.item2 {
                    os.write_int32(18, v)?;
                }
                if let Some(v) = self.item3 {
                    os.write_int32(19, v)?;
                }
                if let Some(v) = self.item4 {
                    os.write_int32(20, v)?;
                }
                if let Some(v) = self.item5 {
                    os.write_int32(21, v)?;
                }
                if let Some(v) = self.respawn_timer {
                    os.write_uint32(22, v)?;
                }
                if let Some(v) = self.account_id {
                    os.write_uint32(23, v)?;
                }
                if let Some(v) = self.position_x {
                    os.write_float(24, v)?;
                }
                if let Some(v) = self.position_y {
                    os.write_float(25, v)?;
                }
                if let Some(v) = self.net_worth {
                    os.write_uint32(26, v)?;
                }
                for v in &self.abilities {
                    ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Player {
                Player::new()
            }

            fn clear(&mut self) {
                self.player_slot = ::std::option::Option::None;
                self.player_name = ::std::option::Option::None;
                self.hero_name = ::std::option::Option::None;
                self.hero_id = ::std::option::Option::None;
                self.kills = ::std::option::Option::None;
                self.deaths = ::std::option::Option::None;
                self.assists = ::std::option::Option::None;
                self.last_hits = ::std::option::Option::None;
                self.denies = ::std::option::Option::None;
                self.gold = ::std::option::Option::None;
                self.level = ::std::option::Option::None;
                self.gold_per_min = ::std::option::Option::None;
                self.xp_per_min = ::std::option::Option::None;
                self.ultimate_state = ::std::option::Option::None;
                self.ultimate_cooldown = ::std::option::Option::None;
                self.item0 = ::std::option::Option::None;
                self.item1 = ::std::option::Option::None;
                self.item2 = ::std::option::Option::None;
                self.item3 = ::std::option::Option::None;
                self.item4 = ::std::option::Option::None;
                self.item5 = ::std::option::Option::None;
                self.respawn_timer = ::std::option::Option::None;
                self.account_id = ::std::option::Option::None;
                self.position_x = ::std::option::Option::None;
                self.position_y = ::std::option::Option::None;
                self.net_worth = ::std::option::Option::None;
                self.abilities.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Player {
                static instance: Player = Player {
                    player_slot: ::std::option::Option::None,
                    player_name: ::std::option::Option::None,
                    hero_name: ::std::option::Option::None,
                    hero_id: ::std::option::Option::None,
                    kills: ::std::option::Option::None,
                    deaths: ::std::option::Option::None,
                    assists: ::std::option::Option::None,
                    last_hits: ::std::option::Option::None,
                    denies: ::std::option::Option::None,
                    gold: ::std::option::Option::None,
                    level: ::std::option::Option::None,
                    gold_per_min: ::std::option::Option::None,
                    xp_per_min: ::std::option::Option::None,
                    ultimate_state: ::std::option::Option::None,
                    ultimate_cooldown: ::std::option::Option::None,
                    item0: ::std::option::Option::None,
                    item1: ::std::option::Option::None,
                    item2: ::std::option::Option::None,
                    item3: ::std::option::Option::None,
                    item4: ::std::option::Option::None,
                    item5: ::std::option::Option::None,
                    respawn_timer: ::std::option::Option::None,
                    account_id: ::std::option::Option::None,
                    position_x: ::std::option::Option::None,
                    position_y: ::std::option::Option::None,
                    net_worth: ::std::option::Option::None,
                    abilities: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Player {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTALiveScoreboardUpdate.Team.Player").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Player {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Player {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `Player`
        pub mod player {
            // @@protoc_insertion_point(message:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct HeroAbility {
                // message fields
                // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility.ability_id)
                pub ability_id: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility.ability_level)
                pub ability_level: ::std::option::Option<u32>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a HeroAbility {
                fn default() -> &'a HeroAbility {
                    <HeroAbility as ::protobuf::Message>::default_instance()
                }
            }

            impl HeroAbility {
                pub fn new() -> HeroAbility {
                    ::std::default::Default::default()
                }

                // optional int32 ability_id = 1;

                pub fn ability_id(&self) -> i32 {
                    self.ability_id.unwrap_or(0)
                }

                pub fn clear_ability_id(&mut self) {
                    self.ability_id = ::std::option::Option::None;
                }

                pub fn has_ability_id(&self) -> bool {
                    self.ability_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_ability_id(&mut self, v: i32) {
                    self.ability_id = ::std::option::Option::Some(v);
                }

                // optional uint32 ability_level = 2;

                pub fn ability_level(&self) -> u32 {
                    self.ability_level.unwrap_or(0)
                }

                pub fn clear_ability_level(&mut self) {
                    self.ability_level = ::std::option::Option::None;
                }

                pub fn has_ability_level(&self) -> bool {
                    self.ability_level.is_some()
                }

                // Param is passed by value, moved
                pub fn set_ability_level(&mut self, v: u32) {
                    self.ability_level = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(2);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "ability_id",
                        |m: &HeroAbility| { &m.ability_id },
                        |m: &mut HeroAbility| { &mut m.ability_id },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "ability_level",
                        |m: &HeroAbility| { &m.ability_level },
                        |m: &mut HeroAbility| { &mut m.ability_level },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroAbility>(
                        "CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for HeroAbility {
                const NAME: &'static str = "HeroAbility";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                            },
                            16 => {
                                self.ability_level = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.ability_id {
                        my_size += ::protobuf::rt::int32_size(1, v);
                    }
                    if let Some(v) = self.ability_level {
                        my_size += ::protobuf::rt::uint32_size(2, v);
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.ability_id {
                        os.write_int32(1, v)?;
                    }
                    if let Some(v) = self.ability_level {
                        os.write_uint32(2, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> HeroAbility {
                    HeroAbility::new()
                }

                fn clear(&mut self) {
                    self.ability_id = ::std::option::Option::None;
                    self.ability_level = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static HeroAbility {
                    static instance: HeroAbility = HeroAbility {
                        ability_id: ::std::option::Option::None,
                        ability_level: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for HeroAbility {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for HeroAbility {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for HeroAbility {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState)
            pub enum DOTAUltimateState {
                // @@protoc_insertion_point(enum_value:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateNotLearned)
                k_EDOTAUltimateStateNotLearned = 0,
                // @@protoc_insertion_point(enum_value:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateCooldown)
                k_EDOTAUltimateStateCooldown = 1,
                // @@protoc_insertion_point(enum_value:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateNeedsMana)
                k_EDOTAUltimateStateNeedsMana = 2,
                // @@protoc_insertion_point(enum_value:dota.CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateReady)
                k_EDOTAUltimateStateReady = 3,
            }

            impl ::protobuf::Enum for DOTAUltimateState {
                const NAME: &'static str = "DOTAUltimateState";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<DOTAUltimateState> {
                    match value {
                        0 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNotLearned),
                        1 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateCooldown),
                        2 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNeedsMana),
                        3 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateReady),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<DOTAUltimateState> {
                    match str {
                        "k_EDOTAUltimateStateNotLearned" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNotLearned),
                        "k_EDOTAUltimateStateCooldown" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateCooldown),
                        "k_EDOTAUltimateStateNeedsMana" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNeedsMana),
                        "k_EDOTAUltimateStateReady" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateReady),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [DOTAUltimateState] = &[
                    DOTAUltimateState::k_EDOTAUltimateStateNotLearned,
                    DOTAUltimateState::k_EDOTAUltimateStateCooldown,
                    DOTAUltimateState::k_EDOTAUltimateStateNeedsMana,
                    DOTAUltimateState::k_EDOTAUltimateStateReady,
                ];
            }

            impl ::protobuf::EnumFull for DOTAUltimateState {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for DOTAUltimateState {
                fn default() -> Self {
                    DOTAUltimateState::k_EDOTAUltimateStateNotLearned
                }
            }

            impl DOTAUltimateState {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTAUltimateState>("CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState")
                }
            }
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRequestBatchPlayerResources)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestBatchPlayerResources {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResources.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResources.rank_types)
    pub rank_types: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRequestBatchPlayerResources.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestBatchPlayerResources {
    fn default() -> &'a CMsgServerToGCRequestBatchPlayerResources {
        <CMsgServerToGCRequestBatchPlayerResources as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestBatchPlayerResources {
    pub fn new() -> CMsgServerToGCRequestBatchPlayerResources {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgServerToGCRequestBatchPlayerResources| { &m.account_ids },
            |m: &mut CMsgServerToGCRequestBatchPlayerResources| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rank_types",
            |m: &CMsgServerToGCRequestBatchPlayerResources| { &m.rank_types },
            |m: &mut CMsgServerToGCRequestBatchPlayerResources| { &mut m.rank_types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRequestBatchPlayerResources>(
            "CMsgServerToGCRequestBatchPlayerResources",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestBatchPlayerResources {
    const NAME: &'static str = "CMsgServerToGCRequestBatchPlayerResources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.rank_types)?;
                },
                32 => {
                    self.rank_types.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.rank_types {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.rank_types {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestBatchPlayerResources {
        CMsgServerToGCRequestBatchPlayerResources::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.rank_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestBatchPlayerResources {
        static instance: CMsgServerToGCRequestBatchPlayerResources = CMsgServerToGCRequestBatchPlayerResources {
            account_ids: ::std::vec::Vec::new(),
            rank_types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRequestBatchPlayerResources {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRequestBatchPlayerResources").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRequestBatchPlayerResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestBatchPlayerResources {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestBatchPlayerResourcesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.results)
    pub results: ::std::vec::Vec<cmsg_server_to_gcrequest_batch_player_resources_response::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestBatchPlayerResourcesResponse {
    fn default() -> &'a CMsgServerToGCRequestBatchPlayerResourcesResponse {
        <CMsgServerToGCRequestBatchPlayerResourcesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestBatchPlayerResourcesResponse {
    pub fn new() -> CMsgServerToGCRequestBatchPlayerResourcesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CMsgServerToGCRequestBatchPlayerResourcesResponse| { &m.results },
            |m: &mut CMsgServerToGCRequestBatchPlayerResourcesResponse| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRequestBatchPlayerResourcesResponse>(
            "CMsgServerToGCRequestBatchPlayerResourcesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestBatchPlayerResourcesResponse {
    const NAME: &'static str = "CMsgServerToGCRequestBatchPlayerResourcesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestBatchPlayerResourcesResponse {
        CMsgServerToGCRequestBatchPlayerResourcesResponse::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestBatchPlayerResourcesResponse {
        static instance: CMsgServerToGCRequestBatchPlayerResourcesResponse = CMsgServerToGCRequestBatchPlayerResourcesResponse {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRequestBatchPlayerResourcesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRequestBatchPlayerResourcesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRequestBatchPlayerResourcesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestBatchPlayerResourcesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCRequestBatchPlayerResourcesResponse`
pub mod cmsg_server_to_gcrequest_batch_player_resources_response {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.prevent_text_chat)
        pub prevent_text_chat: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.prevent_voice_chat)
        pub prevent_voice_chat: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.rank_calibrated)
        pub rank_calibrated: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.low_priority)
        pub low_priority: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.is_new_player)
        pub is_new_player: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.is_guide_player)
        pub is_guide_player: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional bool prevent_text_chat = 2;

        pub fn prevent_text_chat(&self) -> bool {
            self.prevent_text_chat.unwrap_or(false)
        }

        pub fn clear_prevent_text_chat(&mut self) {
            self.prevent_text_chat = ::std::option::Option::None;
        }

        pub fn has_prevent_text_chat(&self) -> bool {
            self.prevent_text_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prevent_text_chat(&mut self, v: bool) {
            self.prevent_text_chat = ::std::option::Option::Some(v);
        }

        // optional bool prevent_voice_chat = 3;

        pub fn prevent_voice_chat(&self) -> bool {
            self.prevent_voice_chat.unwrap_or(false)
        }

        pub fn clear_prevent_voice_chat(&mut self) {
            self.prevent_voice_chat = ::std::option::Option::None;
        }

        pub fn has_prevent_voice_chat(&self) -> bool {
            self.prevent_voice_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prevent_voice_chat(&mut self, v: bool) {
            self.prevent_voice_chat = ::std::option::Option::Some(v);
        }

        // optional uint32 rank = 4;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional bool rank_calibrated = 5;

        pub fn rank_calibrated(&self) -> bool {
            self.rank_calibrated.unwrap_or(false)
        }

        pub fn clear_rank_calibrated(&mut self) {
            self.rank_calibrated = ::std::option::Option::None;
        }

        pub fn has_rank_calibrated(&self) -> bool {
            self.rank_calibrated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_calibrated(&mut self, v: bool) {
            self.rank_calibrated = ::std::option::Option::Some(v);
        }

        // optional bool low_priority = 6;

        pub fn low_priority(&self) -> bool {
            self.low_priority.unwrap_or(false)
        }

        pub fn clear_low_priority(&mut self) {
            self.low_priority = ::std::option::Option::None;
        }

        pub fn has_low_priority(&self) -> bool {
            self.low_priority.is_some()
        }

        // Param is passed by value, moved
        pub fn set_low_priority(&mut self, v: bool) {
            self.low_priority = ::std::option::Option::Some(v);
        }

        // optional bool is_new_player = 7;

        pub fn is_new_player(&self) -> bool {
            self.is_new_player.unwrap_or(false)
        }

        pub fn clear_is_new_player(&mut self) {
            self.is_new_player = ::std::option::Option::None;
        }

        pub fn has_is_new_player(&self) -> bool {
            self.is_new_player.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_new_player(&mut self, v: bool) {
            self.is_new_player = ::std::option::Option::Some(v);
        }

        // optional bool is_guide_player = 8;

        pub fn is_guide_player(&self) -> bool {
            self.is_guide_player.unwrap_or(false)
        }

        pub fn clear_is_guide_player(&mut self) {
            self.is_guide_player = ::std::option::Option::None;
        }

        pub fn has_is_guide_player(&self) -> bool {
            self.is_guide_player.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_guide_player(&mut self, v: bool) {
            self.is_guide_player = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Result| { &m.account_id },
                |m: &mut Result| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "prevent_text_chat",
                |m: &Result| { &m.prevent_text_chat },
                |m: &mut Result| { &mut m.prevent_text_chat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "prevent_voice_chat",
                |m: &Result| { &m.prevent_voice_chat },
                |m: &mut Result| { &mut m.prevent_voice_chat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank",
                |m: &Result| { &m.rank },
                |m: &mut Result| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_calibrated",
                |m: &Result| { &m.rank_calibrated },
                |m: &mut Result| { &mut m.rank_calibrated },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "low_priority",
                |m: &Result| { &m.low_priority },
                |m: &mut Result| { &mut m.low_priority },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_new_player",
                |m: &Result| { &m.is_new_player },
                |m: &mut Result| { &mut m.is_new_player },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_guide_player",
                |m: &Result| { &m.is_guide_player },
                |m: &mut Result| { &mut m.is_guide_player },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Result>(
                "CMsgServerToGCRequestBatchPlayerResourcesResponse.Result",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.prevent_text_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.prevent_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.rank_calibrated = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.is_new_player = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.is_guide_player = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.prevent_text_chat {
                my_size += 1 + 1;
            }
            if let Some(v) = self.prevent_voice_chat {
                my_size += 1 + 1;
            }
            if let Some(v) = self.rank {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.rank_calibrated {
                my_size += 1 + 1;
            }
            if let Some(v) = self.low_priority {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_new_player {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_guide_player {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.prevent_text_chat {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.prevent_voice_chat {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.rank {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.rank_calibrated {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.low_priority {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.is_new_player {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.is_guide_player {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.prevent_text_chat = ::std::option::Option::None;
            self.prevent_voice_chat = ::std::option::Option::None;
            self.rank = ::std::option::Option::None;
            self.rank_calibrated = ::std::option::Option::None;
            self.low_priority = ::std::option::Option::None;
            self.is_new_player = ::std::option::Option::None;
            self.is_guide_player = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                account_id: ::std::option::Option::None,
                prevent_text_chat: ::std::option::Option::None,
                prevent_voice_chat: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                rank_calibrated: ::std::option::Option::None,
                low_priority: ::std::option::Option::None,
                is_new_player: ::std::option::Option::None,
                is_guide_player: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Result {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCRequestBatchPlayerResourcesResponse.Result").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Result {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Result {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTAPlayerFailedToConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPlayerFailedToConnect {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAPlayerFailedToConnect.failed_loaders)
    pub failed_loaders: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAPlayerFailedToConnect.abandoned_loaders)
    pub abandoned_loaders: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAPlayerFailedToConnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPlayerFailedToConnect {
    fn default() -> &'a CMsgDOTAPlayerFailedToConnect {
        <CMsgDOTAPlayerFailedToConnect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPlayerFailedToConnect {
    pub fn new() -> CMsgDOTAPlayerFailedToConnect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failed_loaders",
            |m: &CMsgDOTAPlayerFailedToConnect| { &m.failed_loaders },
            |m: &mut CMsgDOTAPlayerFailedToConnect| { &mut m.failed_loaders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abandoned_loaders",
            |m: &CMsgDOTAPlayerFailedToConnect| { &m.abandoned_loaders },
            |m: &mut CMsgDOTAPlayerFailedToConnect| { &mut m.abandoned_loaders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAPlayerFailedToConnect>(
            "CMsgDOTAPlayerFailedToConnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAPlayerFailedToConnect {
    const NAME: &'static str = "CMsgDOTAPlayerFailedToConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.failed_loaders)?;
                },
                9 => {
                    self.failed_loaders.push(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.abandoned_loaders)?;
                },
                17 => {
                    self.abandoned_loaders.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.failed_loaders.len() as u64;
        my_size += 9 * self.abandoned_loaders.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.failed_loaders {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.abandoned_loaders {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPlayerFailedToConnect {
        CMsgDOTAPlayerFailedToConnect::new()
    }

    fn clear(&mut self) {
        self.failed_loaders.clear();
        self.abandoned_loaders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPlayerFailedToConnect {
        static instance: CMsgDOTAPlayerFailedToConnect = CMsgDOTAPlayerFailedToConnect {
            failed_loaders: ::std::vec::Vec::new(),
            abandoned_loaders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAPlayerFailedToConnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAPlayerFailedToConnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAPlayerFailedToConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPlayerFailedToConnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToRelayConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToRelayConnect {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToRelayConnect.source_tv_public_addr)
    pub source_tv_public_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToRelayConnect.source_tv_private_addr)
    pub source_tv_private_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToRelayConnect.source_tv_port)
    pub source_tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToRelayConnect.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToRelayConnect.parent_count)
    pub parent_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToRelayConnect.tv_unique_secret_code)
    pub tv_unique_secret_code: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToRelayConnect.source_tv_steamid)
    pub source_tv_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToRelayConnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToRelayConnect {
    fn default() -> &'a CMsgGCToRelayConnect {
        <CMsgGCToRelayConnect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToRelayConnect {
    pub fn new() -> CMsgGCToRelayConnect {
        ::std::default::Default::default()
    }

    // optional uint32 source_tv_public_addr = 1;

    pub fn source_tv_public_addr(&self) -> u32 {
        self.source_tv_public_addr.unwrap_or(0)
    }

    pub fn clear_source_tv_public_addr(&mut self) {
        self.source_tv_public_addr = ::std::option::Option::None;
    }

    pub fn has_source_tv_public_addr(&self) -> bool {
        self.source_tv_public_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_public_addr(&mut self, v: u32) {
        self.source_tv_public_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 source_tv_private_addr = 2;

    pub fn source_tv_private_addr(&self) -> u32 {
        self.source_tv_private_addr.unwrap_or(0)
    }

    pub fn clear_source_tv_private_addr(&mut self) {
        self.source_tv_private_addr = ::std::option::Option::None;
    }

    pub fn has_source_tv_private_addr(&self) -> bool {
        self.source_tv_private_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_private_addr(&mut self, v: u32) {
        self.source_tv_private_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 source_tv_port = 3;

    pub fn source_tv_port(&self) -> u32 {
        self.source_tv_port.unwrap_or(0)
    }

    pub fn clear_source_tv_port(&mut self) {
        self.source_tv_port = ::std::option::Option::None;
    }

    pub fn has_source_tv_port(&self) -> bool {
        self.source_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_port(&mut self, v: u32) {
        self.source_tv_port = ::std::option::Option::Some(v);
    }

    // optional uint64 game_server_steam_id = 4;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_count = 5;

    pub fn parent_count(&self) -> u32 {
        self.parent_count.unwrap_or(0)
    }

    pub fn clear_parent_count(&mut self) {
        self.parent_count = ::std::option::Option::None;
    }

    pub fn has_parent_count(&self) -> bool {
        self.parent_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_count(&mut self, v: u32) {
        self.parent_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 tv_unique_secret_code = 6;

    pub fn tv_unique_secret_code(&self) -> u64 {
        self.tv_unique_secret_code.unwrap_or(0)
    }

    pub fn clear_tv_unique_secret_code(&mut self) {
        self.tv_unique_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_unique_secret_code(&self) -> bool {
        self.tv_unique_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_unique_secret_code(&mut self, v: u64) {
        self.tv_unique_secret_code = ::std::option::Option::Some(v);
    }

    // optional fixed64 source_tv_steamid = 7;

    pub fn source_tv_steamid(&self) -> u64 {
        self.source_tv_steamid.unwrap_or(0)
    }

    pub fn clear_source_tv_steamid(&mut self) {
        self.source_tv_steamid = ::std::option::Option::None;
    }

    pub fn has_source_tv_steamid(&self) -> bool {
        self.source_tv_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_steamid(&mut self, v: u64) {
        self.source_tv_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_tv_public_addr",
            |m: &CMsgGCToRelayConnect| { &m.source_tv_public_addr },
            |m: &mut CMsgGCToRelayConnect| { &mut m.source_tv_public_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_tv_private_addr",
            |m: &CMsgGCToRelayConnect| { &m.source_tv_private_addr },
            |m: &mut CMsgGCToRelayConnect| { &mut m.source_tv_private_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_tv_port",
            |m: &CMsgGCToRelayConnect| { &m.source_tv_port },
            |m: &mut CMsgGCToRelayConnect| { &mut m.source_tv_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_steam_id",
            |m: &CMsgGCToRelayConnect| { &m.game_server_steam_id },
            |m: &mut CMsgGCToRelayConnect| { &mut m.game_server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_count",
            |m: &CMsgGCToRelayConnect| { &m.parent_count },
            |m: &mut CMsgGCToRelayConnect| { &mut m.parent_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_unique_secret_code",
            |m: &CMsgGCToRelayConnect| { &m.tv_unique_secret_code },
            |m: &mut CMsgGCToRelayConnect| { &mut m.tv_unique_secret_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_tv_steamid",
            |m: &CMsgGCToRelayConnect| { &m.source_tv_steamid },
            |m: &mut CMsgGCToRelayConnect| { &mut m.source_tv_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToRelayConnect>(
            "CMsgGCToRelayConnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToRelayConnect {
    const NAME: &'static str = "CMsgGCToRelayConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_tv_public_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.source_tv_private_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.source_tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.parent_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                49 => {
                    self.tv_unique_secret_code = ::std::option::Option::Some(is.read_fixed64()?);
                },
                57 => {
                    self.source_tv_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_tv_public_addr {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.source_tv_private_addr {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.source_tv_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.parent_count {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tv_unique_secret_code {
            my_size += 1 + 8;
        }
        if let Some(v) = self.source_tv_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_tv_public_addr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.source_tv_private_addr {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.source_tv_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.parent_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_unique_secret_code {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.source_tv_steamid {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToRelayConnect {
        CMsgGCToRelayConnect::new()
    }

    fn clear(&mut self) {
        self.source_tv_public_addr = ::std::option::Option::None;
        self.source_tv_private_addr = ::std::option::Option::None;
        self.source_tv_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.parent_count = ::std::option::Option::None;
        self.tv_unique_secret_code = ::std::option::Option::None;
        self.source_tv_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToRelayConnect {
        static instance: CMsgGCToRelayConnect = CMsgGCToRelayConnect {
            source_tv_public_addr: ::std::option::Option::None,
            source_tv_private_addr: ::std::option::Option::None,
            source_tv_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            parent_count: ::std::option::Option::None,
            tv_unique_secret_code: ::std::option::Option::None,
            source_tv_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToRelayConnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToRelayConnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToRelayConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToRelayConnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCGCToLANServerRelayConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGCToLANServerRelayConnect {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCGCToLANServerRelayConnect.relay_steamid)
    pub relay_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCGCToLANServerRelayConnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGCToLANServerRelayConnect {
    fn default() -> &'a CMsgGCGCToLANServerRelayConnect {
        <CMsgGCGCToLANServerRelayConnect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGCToLANServerRelayConnect {
    pub fn new() -> CMsgGCGCToLANServerRelayConnect {
        ::std::default::Default::default()
    }

    // optional fixed64 relay_steamid = 1;

    pub fn relay_steamid(&self) -> u64 {
        self.relay_steamid.unwrap_or(0)
    }

    pub fn clear_relay_steamid(&mut self) {
        self.relay_steamid = ::std::option::Option::None;
    }

    pub fn has_relay_steamid(&self) -> bool {
        self.relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_steamid(&mut self, v: u64) {
        self.relay_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_steamid",
            |m: &CMsgGCGCToLANServerRelayConnect| { &m.relay_steamid },
            |m: &mut CMsgGCGCToLANServerRelayConnect| { &mut m.relay_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCGCToLANServerRelayConnect>(
            "CMsgGCGCToLANServerRelayConnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCGCToLANServerRelayConnect {
    const NAME: &'static str = "CMsgGCGCToLANServerRelayConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.relay_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relay_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.relay_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGCToLANServerRelayConnect {
        CMsgGCGCToLANServerRelayConnect::new()
    }

    fn clear(&mut self) {
        self.relay_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGCToLANServerRelayConnect {
        static instance: CMsgGCGCToLANServerRelayConnect = CMsgGCGCToLANServerRelayConnect {
            relay_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCGCToLANServerRelayConnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCGCToLANServerRelayConnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCGCToLANServerRelayConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGCToLANServerRelayConnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCBanStatusRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCBanStatusRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCBanStatusRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCBanStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBanStatusRequest {
    fn default() -> &'a CMsgGCBanStatusRequest {
        <CMsgGCBanStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBanStatusRequest {
    pub fn new() -> CMsgGCBanStatusRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCBanStatusRequest| { &m.account_id },
            |m: &mut CMsgGCBanStatusRequest| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCBanStatusRequest>(
            "CMsgGCBanStatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCBanStatusRequest {
    const NAME: &'static str = "CMsgGCBanStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBanStatusRequest {
        CMsgGCBanStatusRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBanStatusRequest {
        static instance: CMsgGCBanStatusRequest = CMsgGCBanStatusRequest {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCBanStatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCBanStatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCBanStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBanStatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCBanStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCBanStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCBanStatusResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCBanStatusResponse.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCBanStatusResponse.text_chat_banned)
    pub text_chat_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCBanStatusResponse.voice_chat_banned)
    pub voice_chat_banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCBanStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBanStatusResponse {
    fn default() -> &'a CMsgGCBanStatusResponse {
        <CMsgGCBanStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBanStatusResponse {
    pub fn new() -> CMsgGCBanStatusResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 2;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    // optional bool text_chat_banned = 3;

    pub fn text_chat_banned(&self) -> bool {
        self.text_chat_banned.unwrap_or(false)
    }

    pub fn clear_text_chat_banned(&mut self) {
        self.text_chat_banned = ::std::option::Option::None;
    }

    pub fn has_text_chat_banned(&self) -> bool {
        self.text_chat_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_chat_banned(&mut self, v: bool) {
        self.text_chat_banned = ::std::option::Option::Some(v);
    }

    // optional bool voice_chat_banned = 4;

    pub fn voice_chat_banned(&self) -> bool {
        self.voice_chat_banned.unwrap_or(false)
    }

    pub fn clear_voice_chat_banned(&mut self) {
        self.voice_chat_banned = ::std::option::Option::None;
    }

    pub fn has_voice_chat_banned(&self) -> bool {
        self.voice_chat_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chat_banned(&mut self, v: bool) {
        self.voice_chat_banned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCBanStatusResponse| { &m.result },
            |m: &mut CMsgGCBanStatusResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_priority",
            |m: &CMsgGCBanStatusResponse| { &m.low_priority },
            |m: &mut CMsgGCBanStatusResponse| { &mut m.low_priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_chat_banned",
            |m: &CMsgGCBanStatusResponse| { &m.text_chat_banned },
            |m: &mut CMsgGCBanStatusResponse| { &mut m.text_chat_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_chat_banned",
            |m: &CMsgGCBanStatusResponse| { &m.voice_chat_banned },
            |m: &mut CMsgGCBanStatusResponse| { &mut m.voice_chat_banned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCBanStatusResponse>(
            "CMsgGCBanStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCBanStatusResponse {
    const NAME: &'static str = "CMsgGCBanStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.text_chat_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.voice_chat_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 1 + 1;
        }
        if let Some(v) = self.text_chat_banned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.voice_chat_banned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.text_chat_banned {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.voice_chat_banned {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBanStatusResponse {
        CMsgGCBanStatusResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.text_chat_banned = ::std::option::Option::None;
        self.voice_chat_banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBanStatusResponse {
        static instance: CMsgGCBanStatusResponse = CMsgGCBanStatusResponse {
            result: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            text_chat_banned: ::std::option::Option::None,
            voice_chat_banned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCBanStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCBanStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCBanStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBanStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgTournamentItemEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTournamentItemEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.killer_account_id)
    pub killer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.victim_account_id)
    pub victim_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.event_type)
    pub event_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_gcmessages_common::DOTA_TournamentEvents>>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.tv_delay)
    pub tv_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.dota_time)
    pub dota_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.replay_time)
    pub replay_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.loot_list)
    pub loot_list: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.event_team)
    pub event_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.multi_kill_count)
    pub multi_kill_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.winner_score)
    pub winner_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.loser_score)
    pub loser_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEvent.hero_statues)
    pub hero_statues: ::std::vec::Vec<super::dota_gcmessages_common::CProtoItemHeroStatue>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTournamentItemEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTournamentItemEvent {
    fn default() -> &'a CMsgTournamentItemEvent {
        <CMsgTournamentItemEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTournamentItemEvent {
    pub fn new() -> CMsgTournamentItemEvent {
        ::std::default::Default::default()
    }

    // optional fixed32 killer_account_id = 1;

    pub fn killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }

    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 victim_account_id = 2;

    pub fn victim_account_id(&self) -> u32 {
        self.victim_account_id.unwrap_or(0)
    }

    pub fn clear_victim_account_id(&mut self) {
        self.victim_account_id = ::std::option::Option::None;
    }

    pub fn has_victim_account_id(&self) -> bool {
        self.victim_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_account_id(&mut self, v: u32) {
        self.victim_account_id = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_TournamentEvents event_type = 3;

    pub fn event_type(&self) -> super::dota_gcmessages_common::DOTA_TournamentEvents {
        match self.event_type {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD),
            None => super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::dota_gcmessages_common::DOTA_TournamentEvents) {
        self.event_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 tv_delay = 4;

    pub fn tv_delay(&self) -> i32 {
        self.tv_delay.unwrap_or(0)
    }

    pub fn clear_tv_delay(&mut self) {
        self.tv_delay = ::std::option::Option::None;
    }

    pub fn has_tv_delay(&self) -> bool {
        self.tv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_delay(&mut self, v: i32) {
        self.tv_delay = ::std::option::Option::Some(v);
    }

    // optional int32 dota_time = 5;

    pub fn dota_time(&self) -> i32 {
        self.dota_time.unwrap_or(0)
    }

    pub fn clear_dota_time(&mut self) {
        self.dota_time = ::std::option::Option::None;
    }

    pub fn has_dota_time(&self) -> bool {
        self.dota_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_time(&mut self, v: i32) {
        self.dota_time = ::std::option::Option::Some(v);
    }

    // optional float replay_time = 6;

    pub fn replay_time(&self) -> f32 {
        self.replay_time.unwrap_or(0.)
    }

    pub fn clear_replay_time(&mut self) {
        self.replay_time = ::std::option::Option::None;
    }

    pub fn has_replay_time(&self) -> bool {
        self.replay_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_time(&mut self, v: f32) {
        self.replay_time = ::std::option::Option::Some(v);
    }

    // optional string loot_list = 7;

    pub fn loot_list(&self) -> &str {
        match self.loot_list.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loot_list(&mut self) {
        self.loot_list = ::std::option::Option::None;
    }

    pub fn has_loot_list(&self) -> bool {
        self.loot_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list(&mut self, v: ::std::string::String) {
        self.loot_list = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list(&mut self) -> &mut ::std::string::String {
        if self.loot_list.is_none() {
            self.loot_list = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loot_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list(&mut self) -> ::std::string::String {
        self.loot_list.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 event_team = 8;

    pub fn event_team(&self) -> u32 {
        self.event_team.unwrap_or(0)
    }

    pub fn clear_event_team(&mut self) {
        self.event_team = ::std::option::Option::None;
    }

    pub fn has_event_team(&self) -> bool {
        self.event_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_team(&mut self, v: u32) {
        self.event_team = ::std::option::Option::Some(v);
    }

    // optional uint32 multi_kill_count = 9;

    pub fn multi_kill_count(&self) -> u32 {
        self.multi_kill_count.unwrap_or(0)
    }

    pub fn clear_multi_kill_count(&mut self) {
        self.multi_kill_count = ::std::option::Option::None;
    }

    pub fn has_multi_kill_count(&self) -> bool {
        self.multi_kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multi_kill_count(&mut self, v: u32) {
        self.multi_kill_count = ::std::option::Option::Some(v);
    }

    // optional uint32 winner_score = 10;

    pub fn winner_score(&self) -> u32 {
        self.winner_score.unwrap_or(0)
    }

    pub fn clear_winner_score(&mut self) {
        self.winner_score = ::std::option::Option::None;
    }

    pub fn has_winner_score(&self) -> bool {
        self.winner_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winner_score(&mut self, v: u32) {
        self.winner_score = ::std::option::Option::Some(v);
    }

    // optional uint32 loser_score = 11;

    pub fn loser_score(&self) -> u32 {
        self.loser_score.unwrap_or(0)
    }

    pub fn clear_loser_score(&mut self) {
        self.loser_score = ::std::option::Option::None;
    }

    pub fn has_loser_score(&self) -> bool {
        self.loser_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loser_score(&mut self, v: u32) {
        self.loser_score = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_account_id",
            |m: &CMsgTournamentItemEvent| { &m.killer_account_id },
            |m: &mut CMsgTournamentItemEvent| { &mut m.killer_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_account_id",
            |m: &CMsgTournamentItemEvent| { &m.victim_account_id },
            |m: &mut CMsgTournamentItemEvent| { &mut m.victim_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgTournamentItemEvent| { &m.event_type },
            |m: &mut CMsgTournamentItemEvent| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_delay",
            |m: &CMsgTournamentItemEvent| { &m.tv_delay },
            |m: &mut CMsgTournamentItemEvent| { &mut m.tv_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dota_time",
            |m: &CMsgTournamentItemEvent| { &m.dota_time },
            |m: &mut CMsgTournamentItemEvent| { &mut m.dota_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_time",
            |m: &CMsgTournamentItemEvent| { &m.replay_time },
            |m: &mut CMsgTournamentItemEvent| { &mut m.replay_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loot_list",
            |m: &CMsgTournamentItemEvent| { &m.loot_list },
            |m: &mut CMsgTournamentItemEvent| { &mut m.loot_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_team",
            |m: &CMsgTournamentItemEvent| { &m.event_team },
            |m: &mut CMsgTournamentItemEvent| { &mut m.event_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multi_kill_count",
            |m: &CMsgTournamentItemEvent| { &m.multi_kill_count },
            |m: &mut CMsgTournamentItemEvent| { &mut m.multi_kill_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "winner_score",
            |m: &CMsgTournamentItemEvent| { &m.winner_score },
            |m: &mut CMsgTournamentItemEvent| { &mut m.winner_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loser_score",
            |m: &CMsgTournamentItemEvent| { &m.loser_score },
            |m: &mut CMsgTournamentItemEvent| { &mut m.loser_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_statues",
            |m: &CMsgTournamentItemEvent| { &m.hero_statues },
            |m: &mut CMsgTournamentItemEvent| { &mut m.hero_statues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTournamentItemEvent>(
            "CMsgTournamentItemEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTournamentItemEvent {
    const NAME: &'static str = "CMsgTournamentItemEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.killer_account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.victim_account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.tv_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.dota_time = ::std::option::Option::Some(is.read_int32()?);
                },
                53 => {
                    self.replay_time = ::std::option::Option::Some(is.read_float()?);
                },
                58 => {
                    self.loot_list = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.event_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.multi_kill_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.winner_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.loser_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.hero_statues.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.victim_account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.tv_delay {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.dota_time {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.replay_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.loot_list.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.event_team {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.multi_kill_count {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.winner_score {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.loser_score {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        for value in &self.hero_statues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.killer_account_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.victim_account_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tv_delay {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dota_time {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.replay_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.loot_list.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.event_team {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.multi_kill_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.winner_score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.loser_score {
            os.write_uint32(11, v)?;
        }
        for v in &self.hero_statues {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTournamentItemEvent {
        CMsgTournamentItemEvent::new()
    }

    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.victim_account_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.tv_delay = ::std::option::Option::None;
        self.dota_time = ::std::option::Option::None;
        self.replay_time = ::std::option::Option::None;
        self.loot_list = ::std::option::Option::None;
        self.event_team = ::std::option::Option::None;
        self.multi_kill_count = ::std::option::Option::None;
        self.winner_score = ::std::option::Option::None;
        self.loser_score = ::std::option::Option::None;
        self.hero_statues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTournamentItemEvent {
        static instance: CMsgTournamentItemEvent = CMsgTournamentItemEvent {
            killer_account_id: ::std::option::Option::None,
            victim_account_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            tv_delay: ::std::option::Option::None,
            dota_time: ::std::option::Option::None,
            replay_time: ::std::option::Option::None,
            loot_list: ::std::option::Option::None,
            event_team: ::std::option::Option::None,
            multi_kill_count: ::std::option::Option::None,
            winner_score: ::std::option::Option::None,
            loser_score: ::std::option::Option::None,
            hero_statues: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTournamentItemEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTournamentItemEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTournamentItemEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTournamentItemEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgTournamentItemEventResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTournamentItemEventResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEventResponse.event_type)
    pub event_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_gcmessages_common::DOTA_TournamentEvents>>,
    // @@protoc_insertion_point(field:dota.CMsgTournamentItemEventResponse.viewers_granted)
    pub viewers_granted: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTournamentItemEventResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTournamentItemEventResponse {
    fn default() -> &'a CMsgTournamentItemEventResponse {
        <CMsgTournamentItemEventResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTournamentItemEventResponse {
    pub fn new() -> CMsgTournamentItemEventResponse {
        ::std::default::Default::default()
    }

    // optional .dota.DOTA_TournamentEvents event_type = 1;

    pub fn event_type(&self) -> super::dota_gcmessages_common::DOTA_TournamentEvents {
        match self.event_type {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD),
            None => super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::dota_gcmessages_common::DOTA_TournamentEvents) {
        self.event_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 viewers_granted = 6;

    pub fn viewers_granted(&self) -> u32 {
        self.viewers_granted.unwrap_or(0)
    }

    pub fn clear_viewers_granted(&mut self) {
        self.viewers_granted = ::std::option::Option::None;
    }

    pub fn has_viewers_granted(&self) -> bool {
        self.viewers_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_granted(&mut self, v: u32) {
        self.viewers_granted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgTournamentItemEventResponse| { &m.event_type },
            |m: &mut CMsgTournamentItemEventResponse| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers_granted",
            |m: &CMsgTournamentItemEventResponse| { &m.viewers_granted },
            |m: &mut CMsgTournamentItemEventResponse| { &mut m.viewers_granted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTournamentItemEventResponse>(
            "CMsgTournamentItemEventResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTournamentItemEventResponse {
    const NAME: &'static str = "CMsgTournamentItemEventResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.viewers_granted = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.viewers_granted {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.viewers_granted {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTournamentItemEventResponse {
        CMsgTournamentItemEventResponse::new()
    }

    fn clear(&mut self) {
        self.event_type = ::std::option::Option::None;
        self.viewers_granted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTournamentItemEventResponse {
        static instance: CMsgTournamentItemEventResponse = CMsgTournamentItemEventResponse {
            event_type: ::std::option::Option::None,
            viewers_granted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTournamentItemEventResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTournamentItemEventResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTournamentItemEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTournamentItemEventResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgTeamFanfare)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanfare {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTeamFanfare.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTeamFanfare.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanfare {
    fn default() -> &'a CMsgTeamFanfare {
        <CMsgTeamFanfare as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanfare {
    pub fn new() -> CMsgTeamFanfare {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgTeamFanfare| { &m.match_id },
            |m: &mut CMsgTeamFanfare| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTeamFanfare>(
            "CMsgTeamFanfare",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTeamFanfare {
    const NAME: &'static str = "CMsgTeamFanfare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanfare {
        CMsgTeamFanfare::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanfare {
        static instance: CMsgTeamFanfare = CMsgTeamFanfare {
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTeamFanfare {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTeamFanfare").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTeamFanfare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTeamFanfare {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgResponseTeamFanfare)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResponseTeamFanfare {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgResponseTeamFanfare.fanfare_goodguys)
    pub fanfare_goodguys: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgResponseTeamFanfare.fanfare_badguys)
    pub fanfare_badguys: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgResponseTeamFanfare.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResponseTeamFanfare {
    fn default() -> &'a CMsgResponseTeamFanfare {
        <CMsgResponseTeamFanfare as ::protobuf::Message>::default_instance()
    }
}

impl CMsgResponseTeamFanfare {
    pub fn new() -> CMsgResponseTeamFanfare {
        ::std::default::Default::default()
    }

    // optional uint32 fanfare_goodguys = 1;

    pub fn fanfare_goodguys(&self) -> u32 {
        self.fanfare_goodguys.unwrap_or(0)
    }

    pub fn clear_fanfare_goodguys(&mut self) {
        self.fanfare_goodguys = ::std::option::Option::None;
    }

    pub fn has_fanfare_goodguys(&self) -> bool {
        self.fanfare_goodguys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fanfare_goodguys(&mut self, v: u32) {
        self.fanfare_goodguys = ::std::option::Option::Some(v);
    }

    // optional uint32 fanfare_badguys = 2;

    pub fn fanfare_badguys(&self) -> u32 {
        self.fanfare_badguys.unwrap_or(0)
    }

    pub fn clear_fanfare_badguys(&mut self) {
        self.fanfare_badguys = ::std::option::Option::None;
    }

    pub fn has_fanfare_badguys(&self) -> bool {
        self.fanfare_badguys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fanfare_badguys(&mut self, v: u32) {
        self.fanfare_badguys = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fanfare_goodguys",
            |m: &CMsgResponseTeamFanfare| { &m.fanfare_goodguys },
            |m: &mut CMsgResponseTeamFanfare| { &mut m.fanfare_goodguys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fanfare_badguys",
            |m: &CMsgResponseTeamFanfare| { &m.fanfare_badguys },
            |m: &mut CMsgResponseTeamFanfare| { &mut m.fanfare_badguys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgResponseTeamFanfare>(
            "CMsgResponseTeamFanfare",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgResponseTeamFanfare {
    const NAME: &'static str = "CMsgResponseTeamFanfare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fanfare_goodguys = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fanfare_badguys = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fanfare_goodguys {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fanfare_badguys {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fanfare_goodguys {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fanfare_badguys {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResponseTeamFanfare {
        CMsgResponseTeamFanfare::new()
    }

    fn clear(&mut self) {
        self.fanfare_goodguys = ::std::option::Option::None;
        self.fanfare_badguys = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResponseTeamFanfare {
        static instance: CMsgResponseTeamFanfare = CMsgResponseTeamFanfare {
            fanfare_goodguys: ::std::option::Option::None,
            fanfare_badguys: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgResponseTeamFanfare {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgResponseTeamFanfare").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgResponseTeamFanfare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResponseTeamFanfare {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameServerUploadSaveGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerUploadSaveGame {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameServerUploadSaveGame.game_time)
    pub game_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerUploadSaveGame.save_game_data)
    pub save_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerUploadSaveGame.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameServerUploadSaveGame.player_steam_ids)
    pub player_steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameServerUploadSaveGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerUploadSaveGame {
    fn default() -> &'a CMsgGameServerUploadSaveGame {
        <CMsgGameServerUploadSaveGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerUploadSaveGame {
    pub fn new() -> CMsgGameServerUploadSaveGame {
        ::std::default::Default::default()
    }

    // optional uint32 game_time = 1;

    pub fn game_time(&self) -> u32 {
        self.game_time.unwrap_or(0)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: u32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional bytes save_game_data = 2;

    pub fn save_game_data(&self) -> &[u8] {
        match self.save_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_save_game_data(&mut self) {
        self.save_game_data = ::std::option::Option::None;
    }

    pub fn has_save_game_data(&self) -> bool {
        self.save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_data.is_none() {
            self.save_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_time",
            |m: &CMsgGameServerUploadSaveGame| { &m.game_time },
            |m: &mut CMsgGameServerUploadSaveGame| { &mut m.game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_game_data",
            |m: &CMsgGameServerUploadSaveGame| { &m.save_game_data },
            |m: &mut CMsgGameServerUploadSaveGame| { &mut m.save_game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgGameServerUploadSaveGame| { &m.lobby_id },
            |m: &mut CMsgGameServerUploadSaveGame| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_steam_ids",
            |m: &CMsgGameServerUploadSaveGame| { &m.player_steam_ids },
            |m: &mut CMsgGameServerUploadSaveGame| { &mut m.player_steam_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerUploadSaveGame>(
            "CMsgGameServerUploadSaveGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerUploadSaveGame {
    const NAME: &'static str = "CMsgGameServerUploadSaveGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.save_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.player_steam_ids)?;
                },
                32 => {
                    self.player_steam_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.save_game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.player_steam_ids {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.save_game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        for v in &self.player_steam_ids {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerUploadSaveGame {
        CMsgGameServerUploadSaveGame::new()
    }

    fn clear(&mut self) {
        self.game_time = ::std::option::Option::None;
        self.save_game_data = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.player_steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerUploadSaveGame {
        static instance: CMsgGameServerUploadSaveGame = CMsgGameServerUploadSaveGame {
            game_time: ::std::option::Option::None,
            save_game_data: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            player_steam_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerUploadSaveGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerUploadSaveGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerUploadSaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerUploadSaveGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameServerSaveGameResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerSaveGameResult {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameServerSaveGameResult.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_game_server_save_game_result::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameServerSaveGameResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerSaveGameResult {
    fn default() -> &'a CMsgGameServerSaveGameResult {
        <CMsgGameServerSaveGameResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerSaveGameResult {
    pub fn new() -> CMsgGameServerSaveGameResult {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgGameServerSaveGameResult.Result result = 1;

    pub fn result(&self) -> cmsg_game_server_save_game_result::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_game_server_save_game_result::Result::SaveSuccessful),
            None => cmsg_game_server_save_game_result::Result::SaveSuccessful,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_game_server_save_game_result::Result) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGameServerSaveGameResult| { &m.result },
            |m: &mut CMsgGameServerSaveGameResult| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerSaveGameResult>(
            "CMsgGameServerSaveGameResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerSaveGameResult {
    const NAME: &'static str = "CMsgGameServerSaveGameResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerSaveGameResult {
        CMsgGameServerSaveGameResult::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerSaveGameResult {
        static instance: CMsgGameServerSaveGameResult = CMsgGameServerSaveGameResult {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerSaveGameResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerSaveGameResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerSaveGameResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerSaveGameResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameServerSaveGameResult`
pub mod cmsg_game_server_save_game_result {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgGameServerSaveGameResult.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerSaveGameResult.Result.SaveSuccessful)
        SaveSuccessful = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerSaveGameResult.Result.SessionNotFound)
        SessionNotFound = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerSaveGameResult.Result.DatabaseError)
        DatabaseError = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgGameServerSaveGameResult.Result.TooBig)
        TooBig = 3,
    }

    impl ::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SaveSuccessful),
                1 => ::std::option::Option::Some(Result::SessionNotFound),
                2 => ::std::option::Option::Some(Result::DatabaseError),
                3 => ::std::option::Option::Some(Result::TooBig),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SaveSuccessful" => ::std::option::Option::Some(Result::SaveSuccessful),
                "SessionNotFound" => ::std::option::Option::Some(Result::SessionNotFound),
                "DatabaseError" => ::std::option::Option::Some(Result::DatabaseError),
                "TooBig" => ::std::option::Option::Some(Result::TooBig),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SaveSuccessful,
            Result::SessionNotFound,
            Result::DatabaseError,
            Result::TooBig,
        ];
    }

    impl ::protobuf::EnumFull for Result {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGameServerSaveGameResult.Result").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SaveSuccessful
        }
    }

    impl Result {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Result>("CMsgGameServerSaveGameResult.Result")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGameServerGetLoadGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerGetLoadGame {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameServerGetLoadGame.save_id)
    pub save_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameServerGetLoadGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerGetLoadGame {
    fn default() -> &'a CMsgGameServerGetLoadGame {
        <CMsgGameServerGetLoadGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerGetLoadGame {
    pub fn new() -> CMsgGameServerGetLoadGame {
        ::std::default::Default::default()
    }

    // optional uint32 save_id = 1;

    pub fn save_id(&self) -> u32 {
        self.save_id.unwrap_or(0)
    }

    pub fn clear_save_id(&mut self) {
        self.save_id = ::std::option::Option::None;
    }

    pub fn has_save_id(&self) -> bool {
        self.save_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_id(&mut self, v: u32) {
        self.save_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_id",
            |m: &CMsgGameServerGetLoadGame| { &m.save_id },
            |m: &mut CMsgGameServerGetLoadGame| { &mut m.save_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerGetLoadGame>(
            "CMsgGameServerGetLoadGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerGetLoadGame {
    const NAME: &'static str = "CMsgGameServerGetLoadGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.save_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.save_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.save_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerGetLoadGame {
        CMsgGameServerGetLoadGame::new()
    }

    fn clear(&mut self) {
        self.save_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerGetLoadGame {
        static instance: CMsgGameServerGetLoadGame = CMsgGameServerGetLoadGame {
            save_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerGetLoadGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerGetLoadGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerGetLoadGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerGetLoadGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameServerGetLoadGameResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerGetLoadGameResult {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameServerGetLoadGameResult.save_game_data)
    pub save_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameServerGetLoadGameResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerGetLoadGameResult {
    fn default() -> &'a CMsgGameServerGetLoadGameResult {
        <CMsgGameServerGetLoadGameResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerGetLoadGameResult {
    pub fn new() -> CMsgGameServerGetLoadGameResult {
        ::std::default::Default::default()
    }

    // optional bytes save_game_data = 1;

    pub fn save_game_data(&self) -> &[u8] {
        match self.save_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_save_game_data(&mut self) {
        self.save_game_data = ::std::option::Option::None;
    }

    pub fn has_save_game_data(&self) -> bool {
        self.save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_data.is_none() {
            self.save_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_game_data",
            |m: &CMsgGameServerGetLoadGameResult| { &m.save_game_data },
            |m: &mut CMsgGameServerGetLoadGameResult| { &mut m.save_game_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerGetLoadGameResult>(
            "CMsgGameServerGetLoadGameResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerGetLoadGameResult {
    const NAME: &'static str = "CMsgGameServerGetLoadGameResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.save_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.save_game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.save_game_data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerGetLoadGameResult {
        CMsgGameServerGetLoadGameResult::new()
    }

    fn clear(&mut self) {
        self.save_game_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerGetLoadGameResult {
        static instance: CMsgGameServerGetLoadGameResult = CMsgGameServerGetLoadGameResult {
            save_game_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerGetLoadGameResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerGetLoadGameResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerGetLoadGameResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerGetLoadGameResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAAwardEventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAAwardEventPoints {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.award_points)
    pub award_points: ::std::vec::Vec<cmsg_dotaaward_event_points::AwardPoints>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.audit_action)
    pub audit_action: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAAwardEventPoints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAAwardEventPoints {
    fn default() -> &'a CMsgDOTAAwardEventPoints {
        <CMsgDOTAAwardEventPoints as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAAwardEventPoints {
    pub fn new() -> CMsgDOTAAwardEventPoints {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 4;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 5;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 audit_action = 6;

    pub fn audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "award_points",
            |m: &CMsgDOTAAwardEventPoints| { &m.award_points },
            |m: &mut CMsgDOTAAwardEventPoints| { &mut m.award_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgDOTAAwardEventPoints| { &m.match_id },
            |m: &mut CMsgDOTAAwardEventPoints| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgDOTAAwardEventPoints| { &m.event_id },
            |m: &mut CMsgDOTAAwardEventPoints| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgDOTAAwardEventPoints| { &m.timestamp },
            |m: &mut CMsgDOTAAwardEventPoints| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audit_action",
            |m: &CMsgDOTAAwardEventPoints| { &m.audit_action },
            |m: &mut CMsgDOTAAwardEventPoints| { &mut m.audit_action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAAwardEventPoints>(
            "CMsgDOTAAwardEventPoints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAAwardEventPoints {
    const NAME: &'static str = "CMsgDOTAAwardEventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.award_points.push(is.read_message()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.award_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.audit_action {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.award_points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAAwardEventPoints {
        CMsgDOTAAwardEventPoints::new()
    }

    fn clear(&mut self) {
        self.award_points.clear();
        self.match_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.audit_action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAAwardEventPoints {
        static instance: CMsgDOTAAwardEventPoints = CMsgDOTAAwardEventPoints {
            award_points: ::std::vec::Vec::new(),
            match_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            audit_action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAAwardEventPoints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAAwardEventPoints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAAwardEventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAAwardEventPoints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTAAwardEventPoints`
pub mod cmsg_dotaaward_event_points {
    // @@protoc_insertion_point(message:dota.CMsgDOTAAwardEventPoints.AwardPoints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AwardPoints {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.AwardPoints.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.AwardPoints.points)
        pub points: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.AwardPoints.premium_points)
        pub premium_points: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.AwardPoints.trade_ban_time)
        pub trade_ban_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.AwardPoints.eligible_for_periodic_adjustment)
        pub eligible_for_periodic_adjustment: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAAwardEventPoints.AwardPoints.point_cap_periodic_resource_id)
        pub point_cap_periodic_resource_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAAwardEventPoints.AwardPoints.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AwardPoints {
        fn default() -> &'a AwardPoints {
            <AwardPoints as ::protobuf::Message>::default_instance()
        }
    }

    impl AwardPoints {
        pub fn new() -> AwardPoints {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional int32 points = 2;

        pub fn points(&self) -> i32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: i32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional int32 premium_points = 3;

        pub fn premium_points(&self) -> i32 {
            self.premium_points.unwrap_or(0)
        }

        pub fn clear_premium_points(&mut self) {
            self.premium_points = ::std::option::Option::None;
        }

        pub fn has_premium_points(&self) -> bool {
            self.premium_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_premium_points(&mut self, v: i32) {
            self.premium_points = ::std::option::Option::Some(v);
        }

        // optional uint32 trade_ban_time = 5;

        pub fn trade_ban_time(&self) -> u32 {
            self.trade_ban_time.unwrap_or(0)
        }

        pub fn clear_trade_ban_time(&mut self) {
            self.trade_ban_time = ::std::option::Option::None;
        }

        pub fn has_trade_ban_time(&self) -> bool {
            self.trade_ban_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trade_ban_time(&mut self, v: u32) {
            self.trade_ban_time = ::std::option::Option::Some(v);
        }

        // optional bool eligible_for_periodic_adjustment = 6;

        pub fn eligible_for_periodic_adjustment(&self) -> bool {
            self.eligible_for_periodic_adjustment.unwrap_or(false)
        }

        pub fn clear_eligible_for_periodic_adjustment(&mut self) {
            self.eligible_for_periodic_adjustment = ::std::option::Option::None;
        }

        pub fn has_eligible_for_periodic_adjustment(&self) -> bool {
            self.eligible_for_periodic_adjustment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eligible_for_periodic_adjustment(&mut self, v: bool) {
            self.eligible_for_periodic_adjustment = ::std::option::Option::Some(v);
        }

        // optional uint32 point_cap_periodic_resource_id = 7;

        pub fn point_cap_periodic_resource_id(&self) -> u32 {
            self.point_cap_periodic_resource_id.unwrap_or(0)
        }

        pub fn clear_point_cap_periodic_resource_id(&mut self) {
            self.point_cap_periodic_resource_id = ::std::option::Option::None;
        }

        pub fn has_point_cap_periodic_resource_id(&self) -> bool {
            self.point_cap_periodic_resource_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_point_cap_periodic_resource_id(&mut self, v: u32) {
            self.point_cap_periodic_resource_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &AwardPoints| { &m.account_id },
                |m: &mut AwardPoints| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "points",
                |m: &AwardPoints| { &m.points },
                |m: &mut AwardPoints| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "premium_points",
                |m: &AwardPoints| { &m.premium_points },
                |m: &mut AwardPoints| { &mut m.premium_points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "trade_ban_time",
                |m: &AwardPoints| { &m.trade_ban_time },
                |m: &mut AwardPoints| { &mut m.trade_ban_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eligible_for_periodic_adjustment",
                |m: &AwardPoints| { &m.eligible_for_periodic_adjustment },
                |m: &mut AwardPoints| { &mut m.eligible_for_periodic_adjustment },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "point_cap_periodic_resource_id",
                |m: &AwardPoints| { &m.point_cap_periodic_resource_id },
                |m: &mut AwardPoints| { &mut m.point_cap_periodic_resource_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AwardPoints>(
                "CMsgDOTAAwardEventPoints.AwardPoints",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AwardPoints {
        const NAME: &'static str = "AwardPoints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.points = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.premium_points = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.trade_ban_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.eligible_for_periodic_adjustment = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.point_cap_periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.points {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.premium_points {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.trade_ban_time {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.eligible_for_periodic_adjustment {
                my_size += 1 + 1;
            }
            if let Some(v) = self.point_cap_periodic_resource_id {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.points {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.premium_points {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.trade_ban_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.eligible_for_periodic_adjustment {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.point_cap_periodic_resource_id {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AwardPoints {
            AwardPoints::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.premium_points = ::std::option::Option::None;
            self.trade_ban_time = ::std::option::Option::None;
            self.eligible_for_periodic_adjustment = ::std::option::Option::None;
            self.point_cap_periodic_resource_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AwardPoints {
            static instance: AwardPoints = AwardPoints {
                account_id: ::std::option::Option::None,
                points: ::std::option::Option::None,
                premium_points: ::std::option::Option::None,
                trade_ban_time: ::std::option::Option::None,
                eligible_for_periodic_adjustment: ::std::option::Option::None,
                point_cap_periodic_resource_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AwardPoints {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAAwardEventPoints.AwardPoints").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AwardPoints {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AwardPoints {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerPingRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPingRequest.request_id)
    pub request_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPingRequest.request_time)
    pub request_time: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerPingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerPingRequest {
    fn default() -> &'a CMsgGCToServerPingRequest {
        <CMsgGCToServerPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerPingRequest {
    pub fn new() -> CMsgGCToServerPingRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 request_id = 1;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 request_time = 2;

    pub fn request_time(&self) -> u64 {
        self.request_time.unwrap_or(0)
    }

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: u64) {
        self.request_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCToServerPingRequest| { &m.request_id },
            |m: &mut CMsgGCToServerPingRequest| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_time",
            |m: &CMsgGCToServerPingRequest| { &m.request_time },
            |m: &mut CMsgGCToServerPingRequest| { &mut m.request_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerPingRequest>(
            "CMsgGCToServerPingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerPingRequest {
    const NAME: &'static str = "CMsgGCToServerPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.request_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.request_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.request_time {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerPingRequest {
        CMsgGCToServerPingRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.request_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerPingRequest {
        static instance: CMsgGCToServerPingRequest = CMsgGCToServerPingRequest {
            request_id: ::std::option::Option::None,
            request_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerPingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerPingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerPingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerPingResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPingResponse.request_id)
    pub request_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPingResponse.request_time)
    pub request_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPingResponse.cluster)
    pub cluster: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerPingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerPingResponse {
    fn default() -> &'a CMsgGCToServerPingResponse {
        <CMsgGCToServerPingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerPingResponse {
    pub fn new() -> CMsgGCToServerPingResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 request_id = 1;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 request_time = 2;

    pub fn request_time(&self) -> u64 {
        self.request_time.unwrap_or(0)
    }

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: u64) {
        self.request_time = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster = 3;

    pub fn cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCToServerPingResponse| { &m.request_id },
            |m: &mut CMsgGCToServerPingResponse| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_time",
            |m: &CMsgGCToServerPingResponse| { &m.request_time },
            |m: &mut CMsgGCToServerPingResponse| { &mut m.request_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cluster",
            |m: &CMsgGCToServerPingResponse| { &m.cluster },
            |m: &mut CMsgGCToServerPingResponse| { &mut m.cluster },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerPingResponse>(
            "CMsgGCToServerPingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerPingResponse {
    const NAME: &'static str = "CMsgGCToServerPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.request_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.request_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.request_time {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.cluster {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.cluster {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerPingResponse {
        CMsgGCToServerPingResponse::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.request_time = ::std::option::Option::None;
        self.cluster = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerPingResponse {
        static instance: CMsgGCToServerPingResponse = CMsgGCToServerPingResponse {
            request_id: ::std::option::Option::None,
            request_time: ::std::option::Option::None,
            cluster: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerPingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerPingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCMatchConnectionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchConnectionStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.region_id)
    pub region_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcmatch_connection_stats::Player>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.cluster_id)
    pub cluster_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchConnectionStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchConnectionStats {
    fn default() -> &'a CMsgServerToGCMatchConnectionStats {
        <CMsgServerToGCMatchConnectionStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchConnectionStats {
    pub fn new() -> CMsgServerToGCMatchConnectionStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 region_id = 2;

    pub fn region_id(&self) -> u32 {
        self.region_id.unwrap_or(0)
    }

    pub fn clear_region_id(&mut self) {
        self.region_id = ::std::option::Option::None;
    }

    pub fn has_region_id(&self) -> bool {
        self.region_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u32) {
        self.region_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster_id = 5;

    pub fn cluster_id(&self) -> u32 {
        self.cluster_id.unwrap_or(0)
    }

    pub fn clear_cluster_id(&mut self) {
        self.cluster_id = ::std::option::Option::None;
    }

    pub fn has_cluster_id(&self) -> bool {
        self.cluster_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: u32) {
        self.cluster_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCMatchConnectionStats| { &m.match_id },
            |m: &mut CMsgServerToGCMatchConnectionStats| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_id",
            |m: &CMsgServerToGCMatchConnectionStats| { &m.region_id },
            |m: &mut CMsgServerToGCMatchConnectionStats| { &mut m.region_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgServerToGCMatchConnectionStats| { &m.league_id },
            |m: &mut CMsgServerToGCMatchConnectionStats| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgServerToGCMatchConnectionStats| { &m.players },
            |m: &mut CMsgServerToGCMatchConnectionStats| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cluster_id",
            |m: &CMsgServerToGCMatchConnectionStats| { &m.cluster_id },
            |m: &mut CMsgServerToGCMatchConnectionStats| { &mut m.cluster_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCMatchConnectionStats>(
            "CMsgServerToGCMatchConnectionStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchConnectionStats {
    const NAME: &'static str = "CMsgServerToGCMatchConnectionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.region_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.players.push(is.read_message()?);
                },
                40 => {
                    self.cluster_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.region_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cluster_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.region_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.cluster_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchConnectionStats {
        CMsgServerToGCMatchConnectionStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.region_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.players.clear();
        self.cluster_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchConnectionStats {
        static instance: CMsgServerToGCMatchConnectionStats = CMsgServerToGCMatchConnectionStats {
            match_id: ::std::option::Option::None,
            region_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            cluster_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCMatchConnectionStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchConnectionStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCMatchConnectionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchConnectionStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCMatchConnectionStats`
pub mod cmsg_server_to_gcmatch_connection_stats {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchConnectionStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.Player.ip)
        pub ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.Player.avg_ping_ms)
        pub avg_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.Player.packet_loss)
        pub packet_loss: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.Player.ping_deviation)
        pub ping_deviation: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchConnectionStats.Player.full_resends)
        pub full_resends: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchConnectionStats.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 ip = 2;

        pub fn ip(&self) -> u32 {
            self.ip.unwrap_or(0)
        }

        pub fn clear_ip(&mut self) {
            self.ip = ::std::option::Option::None;
        }

        pub fn has_ip(&self) -> bool {
            self.ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip(&mut self, v: u32) {
            self.ip = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_ping_ms = 3;

        pub fn avg_ping_ms(&self) -> u32 {
            self.avg_ping_ms.unwrap_or(0)
        }

        pub fn clear_avg_ping_ms(&mut self) {
            self.avg_ping_ms = ::std::option::Option::None;
        }

        pub fn has_avg_ping_ms(&self) -> bool {
            self.avg_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_ping_ms(&mut self, v: u32) {
            self.avg_ping_ms = ::std::option::Option::Some(v);
        }

        // optional float packet_loss = 5;

        pub fn packet_loss(&self) -> f32 {
            self.packet_loss.unwrap_or(0.)
        }

        pub fn clear_packet_loss(&mut self) {
            self.packet_loss = ::std::option::Option::None;
        }

        pub fn has_packet_loss(&self) -> bool {
            self.packet_loss.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packet_loss(&mut self, v: f32) {
            self.packet_loss = ::std::option::Option::Some(v);
        }

        // optional float ping_deviation = 6;

        pub fn ping_deviation(&self) -> f32 {
            self.ping_deviation.unwrap_or(0.)
        }

        pub fn clear_ping_deviation(&mut self) {
            self.ping_deviation = ::std::option::Option::None;
        }

        pub fn has_ping_deviation(&self) -> bool {
            self.ping_deviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_deviation(&mut self, v: f32) {
            self.ping_deviation = ::std::option::Option::Some(v);
        }

        // optional uint32 full_resends = 7;

        pub fn full_resends(&self) -> u32 {
            self.full_resends.unwrap_or(0)
        }

        pub fn clear_full_resends(&mut self) {
            self.full_resends = ::std::option::Option::None;
        }

        pub fn has_full_resends(&self) -> bool {
            self.full_resends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_full_resends(&mut self, v: u32) {
            self.full_resends = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ip",
                |m: &Player| { &m.ip },
                |m: &mut Player| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_ping_ms",
                |m: &Player| { &m.avg_ping_ms },
                |m: &mut Player| { &mut m.avg_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packet_loss",
                |m: &Player| { &m.packet_loss },
                |m: &mut Player| { &mut m.packet_loss },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_deviation",
                |m: &Player| { &m.ping_deviation },
                |m: &mut Player| { &mut m.ping_deviation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "full_resends",
                |m: &Player| { &m.full_resends },
                |m: &mut Player| { &mut m.full_resends },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgServerToGCMatchConnectionStats.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.avg_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    45 => {
                        self.packet_loss = ::std::option::Option::Some(is.read_float()?);
                    },
                    53 => {
                        self.ping_deviation = ::std::option::Option::Some(is.read_float()?);
                    },
                    56 => {
                        self.full_resends = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ip {
                my_size += 1 + 4;
            }
            if let Some(v) = self.avg_ping_ms {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.packet_loss {
                my_size += 1 + 4;
            }
            if let Some(v) = self.ping_deviation {
                my_size += 1 + 4;
            }
            if let Some(v) = self.full_resends {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ip {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.avg_ping_ms {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.packet_loss {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.ping_deviation {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.full_resends {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.ip = ::std::option::Option::None;
            self.avg_ping_ms = ::std::option::Option::None;
            self.packet_loss = ::std::option::Option::None;
            self.ping_deviation = ::std::option::Option::None;
            self.full_resends = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                ip: ::std::option::Option::None,
                avg_ping_ms: ::std::option::Option::None,
                packet_loss: ::std::option::Option::None,
                ping_deviation: ::std::option::Option::None,
                full_resends: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchConnectionStats.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerGCUpdateSpectatorCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerGCUpdateSpectatorCount {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerGCUpdateSpectatorCount.spectator_count)
    pub spectator_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerGCUpdateSpectatorCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerGCUpdateSpectatorCount {
    fn default() -> &'a CMsgServerGCUpdateSpectatorCount {
        <CMsgServerGCUpdateSpectatorCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerGCUpdateSpectatorCount {
    pub fn new() -> CMsgServerGCUpdateSpectatorCount {
        ::std::default::Default::default()
    }

    // optional uint32 spectator_count = 1;

    pub fn spectator_count(&self) -> u32 {
        self.spectator_count.unwrap_or(0)
    }

    pub fn clear_spectator_count(&mut self) {
        self.spectator_count = ::std::option::Option::None;
    }

    pub fn has_spectator_count(&self) -> bool {
        self.spectator_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_count(&mut self, v: u32) {
        self.spectator_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectator_count",
            |m: &CMsgServerGCUpdateSpectatorCount| { &m.spectator_count },
            |m: &mut CMsgServerGCUpdateSpectatorCount| { &mut m.spectator_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerGCUpdateSpectatorCount>(
            "CMsgServerGCUpdateSpectatorCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerGCUpdateSpectatorCount {
    const NAME: &'static str = "CMsgServerGCUpdateSpectatorCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spectator_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spectator_count {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spectator_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerGCUpdateSpectatorCount {
        CMsgServerGCUpdateSpectatorCount::new()
    }

    fn clear(&mut self) {
        self.spectator_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerGCUpdateSpectatorCount {
        static instance: CMsgServerGCUpdateSpectatorCount = CMsgServerGCUpdateSpectatorCount {
            spectator_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerGCUpdateSpectatorCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerGCUpdateSpectatorCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerGCUpdateSpectatorCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGCUpdateSpectatorCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSerializedCombatLog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSerializedCombatLog {
    // message fields
    // @@protoc_insertion_point(field:dota.CSerializedCombatLog.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSerializedCombatLog.dictionary)
    pub dictionary: ::protobuf::MessageField<cserialized_combat_log::Dictionary>,
    // @@protoc_insertion_point(field:dota.CSerializedCombatLog.entries)
    pub entries: ::std::vec::Vec<super::dota_shared_enums::CMsgDOTACombatLogEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSerializedCombatLog.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSerializedCombatLog {
    fn default() -> &'a CSerializedCombatLog {
        <CSerializedCombatLog as ::protobuf::Message>::default_instance()
    }
}

impl CSerializedCombatLog {
    pub fn new() -> CSerializedCombatLog {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CSerializedCombatLog| { &m.version },
            |m: &mut CSerializedCombatLog| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cserialized_combat_log::Dictionary>(
            "dictionary",
            |m: &CSerializedCombatLog| { &m.dictionary },
            |m: &mut CSerializedCombatLog| { &mut m.dictionary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CSerializedCombatLog| { &m.entries },
            |m: &mut CSerializedCombatLog| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSerializedCombatLog>(
            "CSerializedCombatLog",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSerializedCombatLog {
    const NAME: &'static str = "CSerializedCombatLog";

    fn is_initialized(&self) -> bool {
        for v in &self.dictionary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dictionary)?;
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dictionary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dictionary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSerializedCombatLog {
        CSerializedCombatLog::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.dictionary.clear();
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSerializedCombatLog {
        static instance: CSerializedCombatLog = CSerializedCombatLog {
            version: ::std::option::Option::None,
            dictionary: ::protobuf::MessageField::none(),
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSerializedCombatLog {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSerializedCombatLog").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSerializedCombatLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSerializedCombatLog {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSerializedCombatLog`
pub mod cserialized_combat_log {
    // @@protoc_insertion_point(message:dota.CSerializedCombatLog.Dictionary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Dictionary {
        // message fields
        // @@protoc_insertion_point(field:dota.CSerializedCombatLog.Dictionary.strings)
        pub strings: ::std::vec::Vec<dictionary::DictString>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CSerializedCombatLog.Dictionary.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Dictionary {
        fn default() -> &'a Dictionary {
            <Dictionary as ::protobuf::Message>::default_instance()
        }
    }

    impl Dictionary {
        pub fn new() -> Dictionary {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "strings",
                |m: &Dictionary| { &m.strings },
                |m: &mut Dictionary| { &mut m.strings },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Dictionary>(
                "CSerializedCombatLog.Dictionary",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Dictionary {
        const NAME: &'static str = "Dictionary";

        fn is_initialized(&self) -> bool {
            for v in &self.strings {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.strings.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.strings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.strings {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Dictionary {
            Dictionary::new()
        }

        fn clear(&mut self) {
            self.strings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Dictionary {
            static instance: Dictionary = Dictionary {
                strings: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Dictionary {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSerializedCombatLog.Dictionary").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Dictionary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Dictionary {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Dictionary`
    pub mod dictionary {
        // @@protoc_insertion_point(message:dota.CSerializedCombatLog.Dictionary.DictString)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DictString {
            // message fields
            // @@protoc_insertion_point(field:dota.CSerializedCombatLog.Dictionary.DictString.id)
            pub id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CSerializedCombatLog.Dictionary.DictString.value)
            pub value: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CSerializedCombatLog.Dictionary.DictString.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DictString {
            fn default() -> &'a DictString {
                <DictString as ::protobuf::Message>::default_instance()
            }
        }

        impl DictString {
            pub fn new() -> DictString {
                ::std::default::Default::default()
            }

            // required uint32 id = 1;

            pub fn id(&self) -> u32 {
                self.id.unwrap_or(0)
            }

            pub fn clear_id(&mut self) {
                self.id = ::std::option::Option::None;
            }

            pub fn has_id(&self) -> bool {
                self.id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_id(&mut self, v: u32) {
                self.id = ::std::option::Option::Some(v);
            }

            // required string value = 2;

            pub fn value(&self) -> &str {
                match self.value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: ::std::string::String) {
                self.value = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_value(&mut self) -> &mut ::std::string::String {
                if self.value.is_none() {
                    self.value = ::std::option::Option::Some(::std::string::String::new());
                }
                self.value.as_mut().unwrap()
            }

            // Take field
            pub fn take_value(&mut self) -> ::std::string::String {
                self.value.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "id",
                    |m: &DictString| { &m.id },
                    |m: &mut DictString| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value",
                    |m: &DictString| { &m.value },
                    |m: &mut DictString| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DictString>(
                    "CSerializedCombatLog.Dictionary.DictString",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DictString {
            const NAME: &'static str = "DictString";

            fn is_initialized(&self) -> bool {
                if self.id.is_none() {
                    return false;
                }
                if self.value.is_none() {
                    return false;
                }
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.value = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DictString {
                DictString::new()
            }

            fn clear(&mut self) {
                self.id = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DictString {
                static instance: DictString = DictString {
                    id: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DictString {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CSerializedCombatLog.Dictionary.DictString").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DictString {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DictString {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCVictoryPredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCVictoryPredictions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCVictoryPredictions.records)
    pub records: ::std::vec::Vec<cmsg_server_to_gcvictory_predictions::Record>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCVictoryPredictions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCVictoryPredictions {
    fn default() -> &'a CMsgServerToGCVictoryPredictions {
        <CMsgServerToGCVictoryPredictions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCVictoryPredictions {
    pub fn new() -> CMsgServerToGCVictoryPredictions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "records",
            |m: &CMsgServerToGCVictoryPredictions| { &m.records },
            |m: &mut CMsgServerToGCVictoryPredictions| { &mut m.records },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCVictoryPredictions>(
            "CMsgServerToGCVictoryPredictions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCVictoryPredictions {
    const NAME: &'static str = "CMsgServerToGCVictoryPredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.records.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.records {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCVictoryPredictions {
        CMsgServerToGCVictoryPredictions::new()
    }

    fn clear(&mut self) {
        self.records.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCVictoryPredictions {
        static instance: CMsgServerToGCVictoryPredictions = CMsgServerToGCVictoryPredictions {
            records: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCVictoryPredictions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCVictoryPredictions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCVictoryPredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCVictoryPredictions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCVictoryPredictions`
pub mod cmsg_server_to_gcvictory_predictions {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCVictoryPredictions.Record)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Record {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCVictoryPredictions.Record.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCVictoryPredictions.Record.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCVictoryPredictions.Record.item_ids)
        pub item_ids: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCVictoryPredictions.Record.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Record {
        fn default() -> &'a Record {
            <Record as ::protobuf::Message>::default_instance()
        }
    }

    impl Record {
        pub fn new() -> Record {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 2;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Record| { &m.account_id },
                |m: &mut Record| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &Record| { &m.item_id },
                |m: &mut Record| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "item_ids",
                |m: &Record| { &m.item_ids },
                |m: &mut Record| { &mut m.item_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Record>(
                "CMsgServerToGCVictoryPredictions.Record",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Record {
        const NAME: &'static str = "Record";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    42 => {
                        is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                    },
                    40 => {
                        self.item_ids.push(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            for value in &self.item_ids {
                my_size += ::protobuf::rt::uint64_size(5, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(2, v)?;
            }
            for v in &self.item_ids {
                os.write_uint64(5, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Record {
            Record::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.item_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Record {
            static instance: Record = Record {
                account_id: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                item_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Record {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCVictoryPredictions.Record").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Record {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Record {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRequestStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestStatus {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRequestStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestStatus {
    fn default() -> &'a CMsgServerToGCRequestStatus {
        <CMsgServerToGCRequestStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestStatus {
    pub fn new() -> CMsgServerToGCRequestStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRequestStatus>(
            "CMsgServerToGCRequestStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestStatus {
    const NAME: &'static str = "CMsgServerToGCRequestStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestStatus {
        CMsgServerToGCRequestStatus::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestStatus {
        static instance: CMsgServerToGCRequestStatus = CMsgServerToGCRequestStatus {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRequestStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRequestStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRequestStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestStatus_Response {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestStatus_Response.response)
    pub response: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRequestStatus_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestStatus_Response {
    fn default() -> &'a CMsgServerToGCRequestStatus_Response {
        <CMsgServerToGCRequestStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestStatus_Response {
    pub fn new() -> CMsgServerToGCRequestStatus_Response {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgServerToGCRequestStatus_Response| { &m.response },
            |m: &mut CMsgServerToGCRequestStatus_Response| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRequestStatus_Response>(
            "CMsgServerToGCRequestStatus_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestStatus_Response {
    const NAME: &'static str = "CMsgServerToGCRequestStatus_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestStatus_Response {
        CMsgServerToGCRequestStatus_Response::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestStatus_Response {
        static instance: CMsgServerToGCRequestStatus_Response = CMsgServerToGCRequestStatus_Response {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRequestStatus_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRequestStatus_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRequestStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestStatus_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSignOutAssassinMiniGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutAssassinMiniGameInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.winning_players)
    pub winning_players: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.losing_players)
    pub losing_players: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.arcana_owners)
    pub arcana_owners: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.assassin_won)
    pub assassin_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.target_hero_id)
    pub target_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.contract_completed)
    pub contract_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.contract_complete_time)
    pub contract_complete_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutAssassinMiniGameInfo.pa_is_radiant)
    pub pa_is_radiant: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutAssassinMiniGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutAssassinMiniGameInfo {
    fn default() -> &'a CMsgSignOutAssassinMiniGameInfo {
        <CMsgSignOutAssassinMiniGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutAssassinMiniGameInfo {
    pub fn new() -> CMsgSignOutAssassinMiniGameInfo {
        ::std::default::Default::default()
    }

    // optional bool assassin_won = 4;

    pub fn assassin_won(&self) -> bool {
        self.assassin_won.unwrap_or(false)
    }

    pub fn clear_assassin_won(&mut self) {
        self.assassin_won = ::std::option::Option::None;
    }

    pub fn has_assassin_won(&self) -> bool {
        self.assassin_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assassin_won(&mut self, v: bool) {
        self.assassin_won = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hero_id = 5;

    pub fn target_hero_id(&self) -> u32 {
        self.target_hero_id.unwrap_or(0)
    }

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: u32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    // optional bool contract_completed = 6;

    pub fn contract_completed(&self) -> bool {
        self.contract_completed.unwrap_or(false)
    }

    pub fn clear_contract_completed(&mut self) {
        self.contract_completed = ::std::option::Option::None;
    }

    pub fn has_contract_completed(&self) -> bool {
        self.contract_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_completed(&mut self, v: bool) {
        self.contract_completed = ::std::option::Option::Some(v);
    }

    // optional float contract_complete_time = 7;

    pub fn contract_complete_time(&self) -> f32 {
        self.contract_complete_time.unwrap_or(0.)
    }

    pub fn clear_contract_complete_time(&mut self) {
        self.contract_complete_time = ::std::option::Option::None;
    }

    pub fn has_contract_complete_time(&self) -> bool {
        self.contract_complete_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_complete_time(&mut self, v: f32) {
        self.contract_complete_time = ::std::option::Option::Some(v);
    }

    // optional bool pa_is_radiant = 8;

    pub fn pa_is_radiant(&self) -> bool {
        self.pa_is_radiant.unwrap_or(false)
    }

    pub fn clear_pa_is_radiant(&mut self) {
        self.pa_is_radiant = ::std::option::Option::None;
    }

    pub fn has_pa_is_radiant(&self) -> bool {
        self.pa_is_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pa_is_radiant(&mut self, v: bool) {
        self.pa_is_radiant = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "winning_players",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.winning_players },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.winning_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "losing_players",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.losing_players },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.losing_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arcana_owners",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.arcana_owners },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.arcana_owners },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assassin_won",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.assassin_won },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.assassin_won },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_hero_id",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.target_hero_id },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.target_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contract_completed",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.contract_completed },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.contract_completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contract_complete_time",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.contract_complete_time },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.contract_complete_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pa_is_radiant",
            |m: &CMsgSignOutAssassinMiniGameInfo| { &m.pa_is_radiant },
            |m: &mut CMsgSignOutAssassinMiniGameInfo| { &mut m.pa_is_radiant },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutAssassinMiniGameInfo>(
            "CMsgSignOutAssassinMiniGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutAssassinMiniGameInfo {
    const NAME: &'static str = "CMsgSignOutAssassinMiniGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.winning_players)?;
                },
                9 => {
                    self.winning_players.push(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.losing_players)?;
                },
                17 => {
                    self.losing_players.push(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.arcana_owners)?;
                },
                25 => {
                    self.arcana_owners.push(is.read_fixed64()?);
                },
                32 => {
                    self.assassin_won = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.target_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.contract_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                61 => {
                    self.contract_complete_time = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pa_is_radiant = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.winning_players.len() as u64;
        my_size += 9 * self.losing_players.len() as u64;
        my_size += 9 * self.arcana_owners.len() as u64;
        if let Some(v) = self.assassin_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.target_hero_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.contract_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.contract_complete_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pa_is_radiant {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.winning_players {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.losing_players {
            os.write_fixed64(2, *v)?;
        };
        for v in &self.arcana_owners {
            os.write_fixed64(3, *v)?;
        };
        if let Some(v) = self.assassin_won {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.target_hero_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.contract_completed {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.contract_complete_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pa_is_radiant {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutAssassinMiniGameInfo {
        CMsgSignOutAssassinMiniGameInfo::new()
    }

    fn clear(&mut self) {
        self.winning_players.clear();
        self.losing_players.clear();
        self.arcana_owners.clear();
        self.assassin_won = ::std::option::Option::None;
        self.target_hero_id = ::std::option::Option::None;
        self.contract_completed = ::std::option::Option::None;
        self.contract_complete_time = ::std::option::Option::None;
        self.pa_is_radiant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutAssassinMiniGameInfo {
        static instance: CMsgSignOutAssassinMiniGameInfo = CMsgSignOutAssassinMiniGameInfo {
            winning_players: ::std::vec::Vec::new(),
            losing_players: ::std::vec::Vec::new(),
            arcana_owners: ::std::vec::Vec::new(),
            assassin_won: ::std::option::Option::None,
            target_hero_id: ::std::option::Option::None,
            contract_completed: ::std::option::Option::None,
            contract_complete_time: ::std::option::Option::None,
            pa_is_radiant: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutAssassinMiniGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutAssassinMiniGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutAssassinMiniGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutAssassinMiniGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCKillSummaries)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCKillSummaries {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCKillSummaries.ingameevent_id)
    pub ingameevent_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCKillSummaries.summaries)
    pub summaries: ::std::vec::Vec<cmsg_server_to_gckill_summaries::KillSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCKillSummaries.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCKillSummaries {
    fn default() -> &'a CMsgServerToGCKillSummaries {
        <CMsgServerToGCKillSummaries as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCKillSummaries {
    pub fn new() -> CMsgServerToGCKillSummaries {
        ::std::default::Default::default()
    }

    // optional uint32 ingameevent_id = 1;

    pub fn ingameevent_id(&self) -> u32 {
        self.ingameevent_id.unwrap_or(0)
    }

    pub fn clear_ingameevent_id(&mut self) {
        self.ingameevent_id = ::std::option::Option::None;
    }

    pub fn has_ingameevent_id(&self) -> bool {
        self.ingameevent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingameevent_id(&mut self, v: u32) {
        self.ingameevent_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ingameevent_id",
            |m: &CMsgServerToGCKillSummaries| { &m.ingameevent_id },
            |m: &mut CMsgServerToGCKillSummaries| { &mut m.ingameevent_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "summaries",
            |m: &CMsgServerToGCKillSummaries| { &m.summaries },
            |m: &mut CMsgServerToGCKillSummaries| { &mut m.summaries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCKillSummaries>(
            "CMsgServerToGCKillSummaries",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCKillSummaries {
    const NAME: &'static str = "CMsgServerToGCKillSummaries";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ingameevent_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.summaries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingameevent_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ingameevent_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.summaries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCKillSummaries {
        CMsgServerToGCKillSummaries::new()
    }

    fn clear(&mut self) {
        self.ingameevent_id = ::std::option::Option::None;
        self.summaries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCKillSummaries {
        static instance: CMsgServerToGCKillSummaries = CMsgServerToGCKillSummaries {
            ingameevent_id: ::std::option::Option::None,
            summaries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCKillSummaries {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCKillSummaries").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCKillSummaries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCKillSummaries {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCKillSummaries`
pub mod cmsg_server_to_gckill_summaries {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCKillSummaries.KillSummary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KillSummary {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCKillSummaries.KillSummary.killer_hero_id)
        pub killer_hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCKillSummaries.KillSummary.victim_hero_id)
        pub victim_hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCKillSummaries.KillSummary.kill_count)
        pub kill_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCKillSummaries.KillSummary.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KillSummary {
        fn default() -> &'a KillSummary {
            <KillSummary as ::protobuf::Message>::default_instance()
        }
    }

    impl KillSummary {
        pub fn new() -> KillSummary {
            ::std::default::Default::default()
        }

        // optional uint32 killer_hero_id = 1;

        pub fn killer_hero_id(&self) -> u32 {
            self.killer_hero_id.unwrap_or(0)
        }

        pub fn clear_killer_hero_id(&mut self) {
            self.killer_hero_id = ::std::option::Option::None;
        }

        pub fn has_killer_hero_id(&self) -> bool {
            self.killer_hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_killer_hero_id(&mut self, v: u32) {
            self.killer_hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 victim_hero_id = 2;

        pub fn victim_hero_id(&self) -> u32 {
            self.victim_hero_id.unwrap_or(0)
        }

        pub fn clear_victim_hero_id(&mut self) {
            self.victim_hero_id = ::std::option::Option::None;
        }

        pub fn has_victim_hero_id(&self) -> bool {
            self.victim_hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_victim_hero_id(&mut self, v: u32) {
            self.victim_hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 kill_count = 3;

        pub fn kill_count(&self) -> u32 {
            self.kill_count.unwrap_or(0)
        }

        pub fn clear_kill_count(&mut self) {
            self.kill_count = ::std::option::Option::None;
        }

        pub fn has_kill_count(&self) -> bool {
            self.kill_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_count(&mut self, v: u32) {
            self.kill_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "killer_hero_id",
                |m: &KillSummary| { &m.killer_hero_id },
                |m: &mut KillSummary| { &mut m.killer_hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "victim_hero_id",
                |m: &KillSummary| { &m.victim_hero_id },
                |m: &mut KillSummary| { &mut m.victim_hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kill_count",
                |m: &KillSummary| { &m.kill_count },
                |m: &mut KillSummary| { &mut m.kill_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KillSummary>(
                "CMsgServerToGCKillSummaries.KillSummary",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KillSummary {
        const NAME: &'static str = "KillSummary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.killer_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.victim_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.kill_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.killer_hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.victim_hero_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.kill_count {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.killer_hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.victim_hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.kill_count {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KillSummary {
            KillSummary::new()
        }

        fn clear(&mut self) {
            self.killer_hero_id = ::std::option::Option::None;
            self.victim_hero_id = ::std::option::Option::None;
            self.kill_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KillSummary {
            static instance: KillSummary = KillSummary {
                killer_hero_id: ::std::option::Option::None,
                victim_hero_id: ::std::option::Option::None,
                kill_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KillSummary {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCKillSummaries.KillSummary").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KillSummary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KillSummary {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerPredictionResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerPredictionResult {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.correct)
    pub correct: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.predictions)
    pub predictions: ::std::vec::Vec<cmsg_gcto_server_prediction_result::Prediction>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerPredictionResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerPredictionResult {
    fn default() -> &'a CMsgGCToServerPredictionResult {
        <CMsgGCToServerPredictionResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerPredictionResult {
    pub fn new() -> CMsgGCToServerPredictionResult {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool correct = 3;

    pub fn correct(&self) -> bool {
        self.correct.unwrap_or(false)
    }

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: bool) {
        self.correct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToServerPredictionResult| { &m.account_id },
            |m: &mut CMsgGCToServerPredictionResult| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCToServerPredictionResult| { &m.match_id },
            |m: &mut CMsgGCToServerPredictionResult| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "correct",
            |m: &CMsgGCToServerPredictionResult| { &m.correct },
            |m: &mut CMsgGCToServerPredictionResult| { &mut m.correct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "predictions",
            |m: &CMsgGCToServerPredictionResult| { &m.predictions },
            |m: &mut CMsgGCToServerPredictionResult| { &mut m.predictions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerPredictionResult>(
            "CMsgGCToServerPredictionResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerPredictionResult {
    const NAME: &'static str = "CMsgGCToServerPredictionResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.correct = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.predictions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.correct {
            my_size += 1 + 1;
        }
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.correct {
            os.write_bool(3, v)?;
        }
        for v in &self.predictions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerPredictionResult {
        CMsgGCToServerPredictionResult::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.correct = ::std::option::Option::None;
        self.predictions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerPredictionResult {
        static instance: CMsgGCToServerPredictionResult = CMsgGCToServerPredictionResult {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            correct: ::std::option::Option::None,
            predictions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerPredictionResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerPredictionResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerPredictionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPredictionResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToServerPredictionResult`
pub mod cmsg_gcto_server_prediction_result {
    // @@protoc_insertion_point(message:dota.CMsgGCToServerPredictionResult.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.Prediction.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.Prediction.num_correct)
        pub num_correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.Prediction.num_fails)
        pub num_fails: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.Prediction.result)
        pub result: ::std::option::Option<::protobuf::EnumOrUnknown<prediction::EResult>>,
        // @@protoc_insertion_point(field:dota.CMsgGCToServerPredictionResult.Prediction.granted_item_defs)
        pub granted_item_defs: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToServerPredictionResult.Prediction.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 num_correct = 2;

        pub fn num_correct(&self) -> u32 {
            self.num_correct.unwrap_or(0)
        }

        pub fn clear_num_correct(&mut self) {
            self.num_correct = ::std::option::Option::None;
        }

        pub fn has_num_correct(&self) -> bool {
            self.num_correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_correct(&mut self, v: u32) {
            self.num_correct = ::std::option::Option::Some(v);
        }

        // optional uint32 num_fails = 3;

        pub fn num_fails(&self) -> u32 {
            self.num_fails.unwrap_or(0)
        }

        pub fn clear_num_fails(&mut self) {
            self.num_fails = ::std::option::Option::None;
        }

        pub fn has_num_fails(&self) -> bool {
            self.num_fails.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_fails(&mut self, v: u32) {
            self.num_fails = ::std::option::Option::Some(v);
        }

        // optional .dota.CMsgGCToServerPredictionResult.Prediction.EResult result = 4;

        pub fn result(&self) -> prediction::EResult {
            match self.result {
                Some(e) => e.enum_value_or(prediction::EResult::k_eResult_ItemGranted),
                None => prediction::EResult::k_eResult_ItemGranted,
            }
        }

        pub fn clear_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_result(&self) -> bool {
            self.result.is_some()
        }

        // Param is passed by value, moved
        pub fn set_result(&mut self, v: prediction::EResult) {
            self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_def",
                |m: &Prediction| { &m.item_def },
                |m: &mut Prediction| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_correct",
                |m: &Prediction| { &m.num_correct },
                |m: &mut Prediction| { &mut m.num_correct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_fails",
                |m: &Prediction| { &m.num_fails },
                |m: &mut Prediction| { &mut m.num_fails },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "result",
                |m: &Prediction| { &m.result },
                |m: &mut Prediction| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "granted_item_defs",
                |m: &Prediction| { &m.granted_item_defs },
                |m: &mut Prediction| { &mut m.granted_item_defs },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Prediction>(
                "CMsgGCToServerPredictionResult.Prediction",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.num_correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.num_fails = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.granted_item_defs)?;
                    },
                    48 => {
                        self.granted_item_defs.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.num_correct {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.num_fails {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.result {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            for value in &self.granted_item_defs {
                my_size += ::protobuf::rt::uint32_size(6, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.num_correct {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.num_fails {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.result {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.granted_item_defs {
                os.write_uint32(6, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.num_correct = ::std::option::Option::None;
            self.num_fails = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.granted_item_defs.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                item_def: ::std::option::Option::None,
                num_correct: ::std::option::Option::None,
                num_fails: ::std::option::Option::None,
                result: ::std::option::Option::None,
                granted_item_defs: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Prediction {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToServerPredictionResult.Prediction").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Prediction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Prediction {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Prediction`
    pub mod prediction {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CMsgGCToServerPredictionResult.Prediction.EResult)
        pub enum EResult {
            // @@protoc_insertion_point(enum_value:dota.CMsgGCToServerPredictionResult.Prediction.EResult.k_eResult_ItemGranted)
            k_eResult_ItemGranted = 1,
            // @@protoc_insertion_point(enum_value:dota.CMsgGCToServerPredictionResult.Prediction.EResult.k_eResult_Destroyed)
            k_eResult_Destroyed = 2,
        }

        impl ::protobuf::Enum for EResult {
            const NAME: &'static str = "EResult";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EResult> {
                match value {
                    1 => ::std::option::Option::Some(EResult::k_eResult_ItemGranted),
                    2 => ::std::option::Option::Some(EResult::k_eResult_Destroyed),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EResult> {
                match str {
                    "k_eResult_ItemGranted" => ::std::option::Option::Some(EResult::k_eResult_ItemGranted),
                    "k_eResult_Destroyed" => ::std::option::Option::Some(EResult::k_eResult_Destroyed),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EResult] = &[
                EResult::k_eResult_ItemGranted,
                EResult::k_eResult_Destroyed,
            ];
        }

        impl ::protobuf::EnumFull for EResult {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CMsgGCToServerPredictionResult.Prediction.EResult").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = match self {
                    EResult::k_eResult_ItemGranted => 0,
                    EResult::k_eResult_Destroyed => 1,
                };
                Self::enum_descriptor().value_by_index(index)
            }
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for EResult {
            fn default() -> Self {
                EResult::k_eResult_ItemGranted
            }
        }

        impl EResult {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResult>("CMsgGCToServerPredictionResult.Prediction.EResult")
            }
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCLockCharmTrading)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCLockCharmTrading {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCLockCharmTrading.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCLockCharmTrading.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCLockCharmTrading.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCLockCharmTrading {
    fn default() -> &'a CMsgServerToGCLockCharmTrading {
        <CMsgServerToGCLockCharmTrading as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCLockCharmTrading {
    pub fn new() -> CMsgServerToGCLockCharmTrading {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgServerToGCLockCharmTrading| { &m.account_id },
            |m: &mut CMsgServerToGCLockCharmTrading| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgServerToGCLockCharmTrading| { &m.item_id },
            |m: &mut CMsgServerToGCLockCharmTrading| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCLockCharmTrading>(
            "CMsgServerToGCLockCharmTrading",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCLockCharmTrading {
    const NAME: &'static str = "CMsgServerToGCLockCharmTrading";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCLockCharmTrading {
        CMsgServerToGCLockCharmTrading::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCLockCharmTrading {
        static instance: CMsgServerToGCLockCharmTrading = CMsgServerToGCLockCharmTrading {
            account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCLockCharmTrading {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCLockCharmTrading").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCLockCharmTrading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCLockCharmTrading {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSignOutUpdatePlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutUpdatePlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.completed)
    pub completed: ::std::vec::Vec<cmsg_sign_out_update_player_challenge::Challenge>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.rerolled)
    pub rerolled: ::std::vec::Vec<cmsg_sign_out_update_player_challenge::Challenge>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutUpdatePlayerChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutUpdatePlayerChallenge {
    fn default() -> &'a CMsgSignOutUpdatePlayerChallenge {
        <CMsgSignOutUpdatePlayerChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutUpdatePlayerChallenge {
    pub fn new() -> CMsgSignOutUpdatePlayerChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 4;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 5;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgSignOutUpdatePlayerChallenge| { &m.account_id },
            |m: &mut CMsgSignOutUpdatePlayerChallenge| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "completed",
            |m: &CMsgSignOutUpdatePlayerChallenge| { &m.completed },
            |m: &mut CMsgSignOutUpdatePlayerChallenge| { &mut m.completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rerolled",
            |m: &CMsgSignOutUpdatePlayerChallenge| { &m.rerolled },
            |m: &mut CMsgSignOutUpdatePlayerChallenge| { &mut m.rerolled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgSignOutUpdatePlayerChallenge| { &m.match_id },
            |m: &mut CMsgSignOutUpdatePlayerChallenge| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgSignOutUpdatePlayerChallenge| { &m.hero_id },
            |m: &mut CMsgSignOutUpdatePlayerChallenge| { &mut m.hero_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutUpdatePlayerChallenge>(
            "CMsgSignOutUpdatePlayerChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutUpdatePlayerChallenge {
    const NAME: &'static str = "CMsgSignOutUpdatePlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.completed.push(is.read_message()?);
                },
                26 => {
                    self.rerolled.push(is.read_message()?);
                },
                32 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.completed {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rerolled {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.completed {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.rerolled {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutUpdatePlayerChallenge {
        CMsgSignOutUpdatePlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.completed.clear();
        self.rerolled.clear();
        self.match_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutUpdatePlayerChallenge {
        static instance: CMsgSignOutUpdatePlayerChallenge = CMsgSignOutUpdatePlayerChallenge {
            account_id: ::std::option::Option::None,
            completed: ::std::vec::Vec::new(),
            rerolled: ::std::vec::Vec::new(),
            match_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutUpdatePlayerChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutUpdatePlayerChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutUpdatePlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutUpdatePlayerChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutUpdatePlayerChallenge`
pub mod cmsg_sign_out_update_player_challenge {
    // @@protoc_insertion_point(message:dota.CMsgSignOutUpdatePlayerChallenge.Challenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Challenge {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.Challenge.event_id)
        pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.Challenge.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.Challenge.sequence_id)
        pub sequence_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.Challenge.progress)
        pub progress: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutUpdatePlayerChallenge.Challenge.challenge_rank)
        pub challenge_rank: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutUpdatePlayerChallenge.Challenge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Challenge {
        fn default() -> &'a Challenge {
            <Challenge as ::protobuf::Message>::default_instance()
        }
    }

    impl Challenge {
        pub fn new() -> Challenge {
            ::std::default::Default::default()
        }

        // optional .dota.EEvent event_id = 1;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 slot_id = 2;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 sequence_id = 3;

        pub fn sequence_id(&self) -> u32 {
            self.sequence_id.unwrap_or(0)
        }

        pub fn clear_sequence_id(&mut self) {
            self.sequence_id = ::std::option::Option::None;
        }

        pub fn has_sequence_id(&self) -> bool {
            self.sequence_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_id(&mut self, v: u32) {
            self.sequence_id = ::std::option::Option::Some(v);
        }

        // optional uint32 progress = 4;

        pub fn progress(&self) -> u32 {
            self.progress.unwrap_or(0)
        }

        pub fn clear_progress(&mut self) {
            self.progress = ::std::option::Option::None;
        }

        pub fn has_progress(&self) -> bool {
            self.progress.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress(&mut self, v: u32) {
            self.progress = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_rank = 5;

        pub fn challenge_rank(&self) -> u32 {
            self.challenge_rank.unwrap_or(0)
        }

        pub fn clear_challenge_rank(&mut self) {
            self.challenge_rank = ::std::option::Option::None;
        }

        pub fn has_challenge_rank(&self) -> bool {
            self.challenge_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_rank(&mut self, v: u32) {
            self.challenge_rank = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &Challenge| { &m.event_id },
                |m: &mut Challenge| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &Challenge| { &m.slot_id },
                |m: &mut Challenge| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sequence_id",
                |m: &Challenge| { &m.sequence_id },
                |m: &mut Challenge| { &mut m.sequence_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "progress",
                |m: &Challenge| { &m.progress },
                |m: &mut Challenge| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_rank",
                |m: &Challenge| { &m.challenge_rank },
                |m: &mut Challenge| { &mut m.challenge_rank },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Challenge>(
                "CMsgSignOutUpdatePlayerChallenge.Challenge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Challenge {
        const NAME: &'static str = "Challenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.progress = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.challenge_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.sequence_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.progress {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.challenge_rank {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.slot_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sequence_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.progress {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.challenge_rank {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Challenge {
            Challenge::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.slot_id = ::std::option::Option::None;
            self.sequence_id = ::std::option::Option::None;
            self.progress = ::std::option::Option::None;
            self.challenge_rank = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Challenge {
            static instance: Challenge = Challenge {
                event_id: ::std::option::Option::None,
                slot_id: ::std::option::Option::None,
                sequence_id: ::std::option::Option::None,
                progress: ::std::option::Option::None,
                challenge_rank: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Challenge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutUpdatePlayerChallenge.Challenge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Challenge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Challenge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRerollPlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRerollPlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRerollPlayerChallenge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRerollPlayerChallenge.reroll_msg)
    pub reroll_msg: ::protobuf::MessageField<super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRerollPlayerChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRerollPlayerChallenge {
    fn default() -> &'a CMsgServerToGCRerollPlayerChallenge {
        <CMsgServerToGCRerollPlayerChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRerollPlayerChallenge {
    pub fn new() -> CMsgServerToGCRerollPlayerChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgServerToGCRerollPlayerChallenge| { &m.account_id },
            |m: &mut CMsgServerToGCRerollPlayerChallenge| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge>(
            "reroll_msg",
            |m: &CMsgServerToGCRerollPlayerChallenge| { &m.reroll_msg },
            |m: &mut CMsgServerToGCRerollPlayerChallenge| { &mut m.reroll_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRerollPlayerChallenge>(
            "CMsgServerToGCRerollPlayerChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRerollPlayerChallenge {
    const NAME: &'static str = "CMsgServerToGCRerollPlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reroll_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reroll_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reroll_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRerollPlayerChallenge {
        CMsgServerToGCRerollPlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reroll_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRerollPlayerChallenge {
        static instance: CMsgServerToGCRerollPlayerChallenge = CMsgServerToGCRerollPlayerChallenge {
            account_id: ::std::option::Option::None,
            reroll_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRerollPlayerChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRerollPlayerChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRerollPlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRerollPlayerChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSpendWager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpendWager {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSpendWager.players)
    pub players: ::std::vec::Vec<cmsg_spend_wager::Player>,
    // @@protoc_insertion_point(field:dota.CMsgSpendWager.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgSpendWager.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSpendWager.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSpendWager.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSpendWager.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpendWager {
    fn default() -> &'a CMsgSpendWager {
        <CMsgSpendWager as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSpendWager {
    pub fn new() -> CMsgSpendWager {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 4;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 server_steam_id = 5;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgSpendWager| { &m.players },
            |m: &mut CMsgSpendWager| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgSpendWager| { &m.event_id },
            |m: &mut CMsgSpendWager| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgSpendWager| { &m.timestamp },
            |m: &mut CMsgSpendWager| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgSpendWager| { &m.match_id },
            |m: &mut CMsgSpendWager| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_steam_id",
            |m: &CMsgSpendWager| { &m.server_steam_id },
            |m: &mut CMsgSpendWager| { &mut m.server_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSpendWager>(
            "CMsgSpendWager",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSpendWager {
    const NAME: &'static str = "CMsgSpendWager";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.server_steam_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpendWager {
        CMsgSpendWager::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpendWager {
        static instance: CMsgSpendWager = CMsgSpendWager {
            players: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            server_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSpendWager {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSpendWager").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSpendWager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSpendWager {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSpendWager`
pub mod cmsg_spend_wager {
    // @@protoc_insertion_point(message:dota.CMsgSpendWager.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSpendWager.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSpendWager.Player.wager)
        pub wager: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSpendWager.Player.wager_token_item_id)
        pub wager_token_item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSpendWager.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 wager = 2;

        pub fn wager(&self) -> u32 {
            self.wager.unwrap_or(0)
        }

        pub fn clear_wager(&mut self) {
            self.wager = ::std::option::Option::None;
        }

        pub fn has_wager(&self) -> bool {
            self.wager.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager(&mut self, v: u32) {
            self.wager = ::std::option::Option::Some(v);
        }

        // optional uint64 wager_token_item_id = 3;

        pub fn wager_token_item_id(&self) -> u64 {
            self.wager_token_item_id.unwrap_or(0)
        }

        pub fn clear_wager_token_item_id(&mut self) {
            self.wager_token_item_id = ::std::option::Option::None;
        }

        pub fn has_wager_token_item_id(&self) -> bool {
            self.wager_token_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_token_item_id(&mut self, v: u64) {
            self.wager_token_item_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wager",
                |m: &Player| { &m.wager },
                |m: &mut Player| { &mut m.wager },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wager_token_item_id",
                |m: &Player| { &m.wager_token_item_id },
                |m: &mut Player| { &mut m.wager_token_item_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgSpendWager.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.wager = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.wager_token_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.wager {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.wager_token_item_id {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.wager {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.wager_token_item_id {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.wager = ::std::option::Option::None;
            self.wager_token_item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                wager: ::std::option::Option::None,
                wager_token_item_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSpendWager.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutXPCoins)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutXPCoins {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_xpcoins::Player>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutXPCoins.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutXPCoins {
    fn default() -> &'a CMsgSignOutXPCoins {
        <CMsgSignOutXPCoins as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutXPCoins {
    pub fn new() -> CMsgSignOutXPCoins {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 3;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgSignOutXPCoins| { &m.players },
            |m: &mut CMsgSignOutXPCoins| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgSignOutXPCoins| { &m.event_id },
            |m: &mut CMsgSignOutXPCoins| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgSignOutXPCoins| { &m.match_id },
            |m: &mut CMsgSignOutXPCoins| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgSignOutXPCoins| { &m.timestamp },
            |m: &mut CMsgSignOutXPCoins| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutXPCoins>(
            "CMsgSignOutXPCoins",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutXPCoins {
    const NAME: &'static str = "CMsgSignOutXPCoins";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutXPCoins {
        CMsgSignOutXPCoins::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.event_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutXPCoins {
        static instance: CMsgSignOutXPCoins = CMsgSignOutXPCoins {
            players: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutXPCoins {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutXPCoins").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutXPCoins {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutXPCoins {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutXPCoins`
pub mod cmsg_sign_out_xpcoins {
    // @@protoc_insertion_point(message:dota.CMsgSignOutXPCoins.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.Player.xp_gained)
        pub xp_gained: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.Player.coins_spent)
        pub coins_spent: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.Player.wager_token_item_id)
        pub wager_token_item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.Player.rank_wager)
        pub rank_wager: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutXPCoins.Player.wager_streak)
        pub wager_streak: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutXPCoins.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_gained = 2;

        pub fn xp_gained(&self) -> u32 {
            self.xp_gained.unwrap_or(0)
        }

        pub fn clear_xp_gained(&mut self) {
            self.xp_gained = ::std::option::Option::None;
        }

        pub fn has_xp_gained(&self) -> bool {
            self.xp_gained.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_gained(&mut self, v: u32) {
            self.xp_gained = ::std::option::Option::Some(v);
        }

        // optional uint32 coins_spent = 3;

        pub fn coins_spent(&self) -> u32 {
            self.coins_spent.unwrap_or(0)
        }

        pub fn clear_coins_spent(&mut self) {
            self.coins_spent = ::std::option::Option::None;
        }

        pub fn has_coins_spent(&self) -> bool {
            self.coins_spent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coins_spent(&mut self, v: u32) {
            self.coins_spent = ::std::option::Option::Some(v);
        }

        // optional uint64 wager_token_item_id = 4;

        pub fn wager_token_item_id(&self) -> u64 {
            self.wager_token_item_id.unwrap_or(0)
        }

        pub fn clear_wager_token_item_id(&mut self) {
            self.wager_token_item_id = ::std::option::Option::None;
        }

        pub fn has_wager_token_item_id(&self) -> bool {
            self.wager_token_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_token_item_id(&mut self, v: u64) {
            self.wager_token_item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 rank_wager = 5;

        pub fn rank_wager(&self) -> u32 {
            self.rank_wager.unwrap_or(0)
        }

        pub fn clear_rank_wager(&mut self) {
            self.rank_wager = ::std::option::Option::None;
        }

        pub fn has_rank_wager(&self) -> bool {
            self.rank_wager.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_wager(&mut self, v: u32) {
            self.rank_wager = ::std::option::Option::Some(v);
        }

        // optional uint32 wager_streak = 6;

        pub fn wager_streak(&self) -> u32 {
            self.wager_streak.unwrap_or(0)
        }

        pub fn clear_wager_streak(&mut self) {
            self.wager_streak = ::std::option::Option::None;
        }

        pub fn has_wager_streak(&self) -> bool {
            self.wager_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_streak(&mut self, v: u32) {
            self.wager_streak = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xp_gained",
                |m: &Player| { &m.xp_gained },
                |m: &mut Player| { &mut m.xp_gained },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "coins_spent",
                |m: &Player| { &m.coins_spent },
                |m: &mut Player| { &mut m.coins_spent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wager_token_item_id",
                |m: &Player| { &m.wager_token_item_id },
                |m: &mut Player| { &mut m.wager_token_item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_wager",
                |m: &Player| { &m.rank_wager },
                |m: &mut Player| { &mut m.rank_wager },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wager_streak",
                |m: &Player| { &m.wager_streak },
                |m: &mut Player| { &mut m.wager_streak },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgSignOutXPCoins.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.xp_gained = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.coins_spent = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.wager_token_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.rank_wager = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.wager_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.xp_gained {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.coins_spent {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.wager_token_item_id {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.rank_wager {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.wager_streak {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.xp_gained {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.coins_spent {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.wager_token_item_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.rank_wager {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.wager_streak {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.xp_gained = ::std::option::Option::None;
            self.coins_spent = ::std::option::Option::None;
            self.wager_token_item_id = ::std::option::Option::None;
            self.rank_wager = ::std::option::Option::None;
            self.wager_streak = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                xp_gained: ::std::option::Option::None,
                coins_spent: ::std::option::Option::None,
                wager_token_item_id: ::std::option::Option::None,
                rank_wager: ::std::option::Option::None,
                wager_streak: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutXPCoins.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutBounties)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutBounties {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutBounties.bounties)
    pub bounties: ::std::vec::Vec<cmsg_sign_out_bounties::Bounty>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutBounties.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutBounties.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutBounties.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutBounties.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutBounties {
    fn default() -> &'a CMsgSignOutBounties {
        <CMsgSignOutBounties as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutBounties {
    pub fn new() -> CMsgSignOutBounties {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 3;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bounties",
            |m: &CMsgSignOutBounties| { &m.bounties },
            |m: &mut CMsgSignOutBounties| { &mut m.bounties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgSignOutBounties| { &m.event_id },
            |m: &mut CMsgSignOutBounties| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgSignOutBounties| { &m.match_id },
            |m: &mut CMsgSignOutBounties| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgSignOutBounties| { &m.timestamp },
            |m: &mut CMsgSignOutBounties| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutBounties>(
            "CMsgSignOutBounties",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutBounties {
    const NAME: &'static str = "CMsgSignOutBounties";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bounties.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bounties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.bounties {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutBounties {
        CMsgSignOutBounties::new()
    }

    fn clear(&mut self) {
        self.bounties.clear();
        self.event_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutBounties {
        static instance: CMsgSignOutBounties = CMsgSignOutBounties {
            bounties: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutBounties {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutBounties").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutBounties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutBounties {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutBounties`
pub mod cmsg_sign_out_bounties {
    // @@protoc_insertion_point(message:dota.CMsgSignOutBounties.Bounty)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bounty {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutBounties.Bounty.issuer_account_id)
        pub issuer_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutBounties.Bounty.completer_account_id)
        pub completer_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutBounties.Bounty.target_account_id)
        pub target_account_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutBounties.Bounty.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bounty {
        fn default() -> &'a Bounty {
            <Bounty as ::protobuf::Message>::default_instance()
        }
    }

    impl Bounty {
        pub fn new() -> Bounty {
            ::std::default::Default::default()
        }

        // optional uint32 issuer_account_id = 1;

        pub fn issuer_account_id(&self) -> u32 {
            self.issuer_account_id.unwrap_or(0)
        }

        pub fn clear_issuer_account_id(&mut self) {
            self.issuer_account_id = ::std::option::Option::None;
        }

        pub fn has_issuer_account_id(&self) -> bool {
            self.issuer_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_issuer_account_id(&mut self, v: u32) {
            self.issuer_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 completer_account_id = 2;

        pub fn completer_account_id(&self) -> u32 {
            self.completer_account_id.unwrap_or(0)
        }

        pub fn clear_completer_account_id(&mut self) {
            self.completer_account_id = ::std::option::Option::None;
        }

        pub fn has_completer_account_id(&self) -> bool {
            self.completer_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completer_account_id(&mut self, v: u32) {
            self.completer_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 target_account_id = 3;

        pub fn target_account_id(&self) -> u32 {
            self.target_account_id.unwrap_or(0)
        }

        pub fn clear_target_account_id(&mut self) {
            self.target_account_id = ::std::option::Option::None;
        }

        pub fn has_target_account_id(&self) -> bool {
            self.target_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_account_id(&mut self, v: u32) {
            self.target_account_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "issuer_account_id",
                |m: &Bounty| { &m.issuer_account_id },
                |m: &mut Bounty| { &mut m.issuer_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "completer_account_id",
                |m: &Bounty| { &m.completer_account_id },
                |m: &mut Bounty| { &mut m.completer_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "target_account_id",
                |m: &Bounty| { &m.target_account_id },
                |m: &mut Bounty| { &mut m.target_account_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Bounty>(
                "CMsgSignOutBounties.Bounty",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Bounty {
        const NAME: &'static str = "Bounty";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.issuer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.completer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.issuer_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.completer_account_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.target_account_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.issuer_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.completer_account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.target_account_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bounty {
            Bounty::new()
        }

        fn clear(&mut self) {
            self.issuer_account_id = ::std::option::Option::None;
            self.completer_account_id = ::std::option::Option::None;
            self.target_account_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bounty {
            static instance: Bounty = Bounty {
                issuer_account_id: ::std::option::Option::None,
                completer_account_id: ::std::option::Option::None,
                target_account_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Bounty {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutBounties.Bounty").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Bounty {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Bounty {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutCommunityGoalProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutCommunityGoalProgress {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutCommunityGoalProgress.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutCommunityGoalProgress.event_increments)
    pub event_increments: ::std::vec::Vec<cmsg_sign_out_community_goal_progress::EventGoalIncrement>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutCommunityGoalProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutCommunityGoalProgress {
    fn default() -> &'a CMsgSignOutCommunityGoalProgress {
        <CMsgSignOutCommunityGoalProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutCommunityGoalProgress {
    pub fn new() -> CMsgSignOutCommunityGoalProgress {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgSignOutCommunityGoalProgress| { &m.event_id },
            |m: &mut CMsgSignOutCommunityGoalProgress| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_increments",
            |m: &CMsgSignOutCommunityGoalProgress| { &m.event_increments },
            |m: &mut CMsgSignOutCommunityGoalProgress| { &mut m.event_increments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutCommunityGoalProgress>(
            "CMsgSignOutCommunityGoalProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutCommunityGoalProgress {
    const NAME: &'static str = "CMsgSignOutCommunityGoalProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.event_increments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.event_increments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.event_increments {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutCommunityGoalProgress {
        CMsgSignOutCommunityGoalProgress::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_increments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutCommunityGoalProgress {
        static instance: CMsgSignOutCommunityGoalProgress = CMsgSignOutCommunityGoalProgress {
            event_id: ::std::option::Option::None,
            event_increments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutCommunityGoalProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutCommunityGoalProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutCommunityGoalProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutCommunityGoalProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutCommunityGoalProgress`
pub mod cmsg_sign_out_community_goal_progress {
    // @@protoc_insertion_point(message:dota.CMsgSignOutCommunityGoalProgress.EventGoalIncrement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventGoalIncrement {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunityGoalProgress.EventGoalIncrement.event_goal_id)
        pub event_goal_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutCommunityGoalProgress.EventGoalIncrement.increment_amount)
        pub increment_amount: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutCommunityGoalProgress.EventGoalIncrement.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventGoalIncrement {
        fn default() -> &'a EventGoalIncrement {
            <EventGoalIncrement as ::protobuf::Message>::default_instance()
        }
    }

    impl EventGoalIncrement {
        pub fn new() -> EventGoalIncrement {
            ::std::default::Default::default()
        }

        // optional uint32 event_goal_id = 1;

        pub fn event_goal_id(&self) -> u32 {
            self.event_goal_id.unwrap_or(0)
        }

        pub fn clear_event_goal_id(&mut self) {
            self.event_goal_id = ::std::option::Option::None;
        }

        pub fn has_event_goal_id(&self) -> bool {
            self.event_goal_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_goal_id(&mut self, v: u32) {
            self.event_goal_id = ::std::option::Option::Some(v);
        }

        // optional uint32 increment_amount = 2;

        pub fn increment_amount(&self) -> u32 {
            self.increment_amount.unwrap_or(0)
        }

        pub fn clear_increment_amount(&mut self) {
            self.increment_amount = ::std::option::Option::None;
        }

        pub fn has_increment_amount(&self) -> bool {
            self.increment_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_increment_amount(&mut self, v: u32) {
            self.increment_amount = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_goal_id",
                |m: &EventGoalIncrement| { &m.event_goal_id },
                |m: &mut EventGoalIncrement| { &mut m.event_goal_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "increment_amount",
                |m: &EventGoalIncrement| { &m.increment_amount },
                |m: &mut EventGoalIncrement| { &mut m.increment_amount },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventGoalIncrement>(
                "CMsgSignOutCommunityGoalProgress.EventGoalIncrement",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EventGoalIncrement {
        const NAME: &'static str = "EventGoalIncrement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_goal_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.increment_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_goal_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.increment_amount {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.event_goal_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.increment_amount {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventGoalIncrement {
            EventGoalIncrement::new()
        }

        fn clear(&mut self) {
            self.event_goal_id = ::std::option::Option::None;
            self.increment_amount = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventGoalIncrement {
            static instance: EventGoalIncrement = EventGoalIncrement {
                event_goal_id: ::std::option::Option::None,
                increment_amount: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EventGoalIncrement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutCommunityGoalProgress.EventGoalIncrement").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EventGoalIncrement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EventGoalIncrement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCCloseCompendiumInGamePredictionVoting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCloseCompendiumInGamePredictionVoting.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCloseCompendiumInGamePredictionVoting.hltv_delay)
    pub hltv_delay: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCloseCompendiumInGamePredictionVoting.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCloseCompendiumInGamePredictionVoting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn default() -> &'a CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        <CMsgServerToGCCloseCompendiumInGamePredictionVoting as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    pub fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hltv_delay = 2;

    pub fn hltv_delay(&self) -> u32 {
        self.hltv_delay.unwrap_or(0)
    }

    pub fn clear_hltv_delay(&mut self) {
        self.hltv_delay = ::std::option::Option::None;
    }

    pub fn has_hltv_delay(&self) -> bool {
        self.hltv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_delay(&mut self, v: u32) {
        self.hltv_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCCloseCompendiumInGamePredictionVoting| { &m.match_id },
            |m: &mut CMsgServerToGCCloseCompendiumInGamePredictionVoting| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hltv_delay",
            |m: &CMsgServerToGCCloseCompendiumInGamePredictionVoting| { &m.hltv_delay },
            |m: &mut CMsgServerToGCCloseCompendiumInGamePredictionVoting| { &mut m.hltv_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgServerToGCCloseCompendiumInGamePredictionVoting| { &m.league_id },
            |m: &mut CMsgServerToGCCloseCompendiumInGamePredictionVoting| { &mut m.league_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCCloseCompendiumInGamePredictionVoting>(
            "CMsgServerToGCCloseCompendiumInGamePredictionVoting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    const NAME: &'static str = "CMsgServerToGCCloseCompendiumInGamePredictionVoting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.hltv_delay = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.hltv_delay {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hltv_delay {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        CMsgServerToGCCloseCompendiumInGamePredictionVoting::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.hltv_delay = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        static instance: CMsgServerToGCCloseCompendiumInGamePredictionVoting = CMsgServerToGCCloseCompendiumInGamePredictionVoting {
            match_id: ::std::option::Option::None,
            hltv_delay: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCCloseCompendiumInGamePredictionVoting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn default() -> &'a CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        <CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    pub fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse| { &m.result },
            |m: &mut CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse>(
            "CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    const NAME: &'static str = "CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        static instance: CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse = CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCCompendiumInGamePredictionResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCompendiumInGamePredictionResults {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumInGamePredictionResults.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumInGamePredictionResults.results)
    pub results: ::std::vec::Vec<cmsg_server_to_gccompendium_in_game_prediction_results::PredictionResult>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumInGamePredictionResults.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumInGamePredictionResults.league_node_id)
    pub league_node_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCompendiumInGamePredictionResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCompendiumInGamePredictionResults {
    fn default() -> &'a CMsgServerToGCCompendiumInGamePredictionResults {
        <CMsgServerToGCCompendiumInGamePredictionResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCompendiumInGamePredictionResults {
    pub fn new() -> CMsgServerToGCCompendiumInGamePredictionResults {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_node_id = 4;

    pub fn league_node_id(&self) -> u32 {
        self.league_node_id.unwrap_or(0)
    }

    pub fn clear_league_node_id(&mut self) {
        self.league_node_id = ::std::option::Option::None;
    }

    pub fn has_league_node_id(&self) -> bool {
        self.league_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_node_id(&mut self, v: u32) {
        self.league_node_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCCompendiumInGamePredictionResults| { &m.match_id },
            |m: &mut CMsgServerToGCCompendiumInGamePredictionResults| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CMsgServerToGCCompendiumInGamePredictionResults| { &m.results },
            |m: &mut CMsgServerToGCCompendiumInGamePredictionResults| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgServerToGCCompendiumInGamePredictionResults| { &m.league_id },
            |m: &mut CMsgServerToGCCompendiumInGamePredictionResults| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_node_id",
            |m: &CMsgServerToGCCompendiumInGamePredictionResults| { &m.league_node_id },
            |m: &mut CMsgServerToGCCompendiumInGamePredictionResults| { &mut m.league_node_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCCompendiumInGamePredictionResults>(
            "CMsgServerToGCCompendiumInGamePredictionResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCCompendiumInGamePredictionResults {
    const NAME: &'static str = "CMsgServerToGCCompendiumInGamePredictionResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.league_node_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.league_node_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCompendiumInGamePredictionResults {
        CMsgServerToGCCompendiumInGamePredictionResults::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.results.clear();
        self.league_id = ::std::option::Option::None;
        self.league_node_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCompendiumInGamePredictionResults {
        static instance: CMsgServerToGCCompendiumInGamePredictionResults = CMsgServerToGCCompendiumInGamePredictionResults {
            match_id: ::std::option::Option::None,
            results: ::std::vec::Vec::new(),
            league_id: ::std::option::Option::None,
            league_node_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCCompendiumInGamePredictionResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCCompendiumInGamePredictionResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCCompendiumInGamePredictionResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCompendiumInGamePredictionResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCCompendiumInGamePredictionResults`
pub mod cmsg_server_to_gccompendium_in_game_prediction_results {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PredictionResult {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.prediction_id)
        pub prediction_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.prediction_value)
        pub prediction_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.prediction_value_is_mask)
        pub prediction_value_is_mask: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PredictionResult {
        fn default() -> &'a PredictionResult {
            <PredictionResult as ::protobuf::Message>::default_instance()
        }
    }

    impl PredictionResult {
        pub fn new() -> PredictionResult {
            ::std::default::Default::default()
        }

        // optional uint32 prediction_id = 1;

        pub fn prediction_id(&self) -> u32 {
            self.prediction_id.unwrap_or(0)
        }

        pub fn clear_prediction_id(&mut self) {
            self.prediction_id = ::std::option::Option::None;
        }

        pub fn has_prediction_id(&self) -> bool {
            self.prediction_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_id(&mut self, v: u32) {
            self.prediction_id = ::std::option::Option::Some(v);
        }

        // optional uint32 prediction_value = 2;

        pub fn prediction_value(&self) -> u32 {
            self.prediction_value.unwrap_or(0)
        }

        pub fn clear_prediction_value(&mut self) {
            self.prediction_value = ::std::option::Option::None;
        }

        pub fn has_prediction_value(&self) -> bool {
            self.prediction_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_value(&mut self, v: u32) {
            self.prediction_value = ::std::option::Option::Some(v);
        }

        // optional bool prediction_value_is_mask = 3;

        pub fn prediction_value_is_mask(&self) -> bool {
            self.prediction_value_is_mask.unwrap_or(false)
        }

        pub fn clear_prediction_value_is_mask(&mut self) {
            self.prediction_value_is_mask = ::std::option::Option::None;
        }

        pub fn has_prediction_value_is_mask(&self) -> bool {
            self.prediction_value_is_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_value_is_mask(&mut self, v: bool) {
            self.prediction_value_is_mask = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "prediction_id",
                |m: &PredictionResult| { &m.prediction_id },
                |m: &mut PredictionResult| { &mut m.prediction_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "prediction_value",
                |m: &PredictionResult| { &m.prediction_value },
                |m: &mut PredictionResult| { &mut m.prediction_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "prediction_value_is_mask",
                |m: &PredictionResult| { &m.prediction_value_is_mask },
                |m: &mut PredictionResult| { &mut m.prediction_value_is_mask },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PredictionResult>(
                "CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PredictionResult {
        const NAME: &'static str = "PredictionResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.prediction_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.prediction_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.prediction_value_is_mask = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.prediction_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.prediction_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.prediction_value_is_mask {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.prediction_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.prediction_value {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.prediction_value_is_mask {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PredictionResult {
            PredictionResult::new()
        }

        fn clear(&mut self) {
            self.prediction_id = ::std::option::Option::None;
            self.prediction_value = ::std::option::Option::None;
            self.prediction_value_is_mask = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PredictionResult {
            static instance: PredictionResult = PredictionResult {
                prediction_id: ::std::option::Option::None,
                prediction_value: ::std::option::Option::None,
                prediction_value_is_mask: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PredictionResult {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PredictionResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PredictionResult {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCCompendiumChosenInGamePredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCompendiumChosenInGamePredictions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumChosenInGamePredictions.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumChosenInGamePredictions.predictions_chosen)
    pub predictions_chosen: ::std::vec::Vec<cmsg_server_to_gccompendium_chosen_in_game_predictions::Prediction>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumChosenInGamePredictions.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCompendiumChosenInGamePredictions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCompendiumChosenInGamePredictions {
    fn default() -> &'a CMsgServerToGCCompendiumChosenInGamePredictions {
        <CMsgServerToGCCompendiumChosenInGamePredictions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCompendiumChosenInGamePredictions {
    pub fn new() -> CMsgServerToGCCompendiumChosenInGamePredictions {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCCompendiumChosenInGamePredictions| { &m.match_id },
            |m: &mut CMsgServerToGCCompendiumChosenInGamePredictions| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "predictions_chosen",
            |m: &CMsgServerToGCCompendiumChosenInGamePredictions| { &m.predictions_chosen },
            |m: &mut CMsgServerToGCCompendiumChosenInGamePredictions| { &mut m.predictions_chosen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgServerToGCCompendiumChosenInGamePredictions| { &m.league_id },
            |m: &mut CMsgServerToGCCompendiumChosenInGamePredictions| { &mut m.league_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCCompendiumChosenInGamePredictions>(
            "CMsgServerToGCCompendiumChosenInGamePredictions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCCompendiumChosenInGamePredictions {
    const NAME: &'static str = "CMsgServerToGCCompendiumChosenInGamePredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.predictions_chosen.push(is.read_message()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.predictions_chosen {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.predictions_chosen {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCompendiumChosenInGamePredictions {
        CMsgServerToGCCompendiumChosenInGamePredictions::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.predictions_chosen.clear();
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCompendiumChosenInGamePredictions {
        static instance: CMsgServerToGCCompendiumChosenInGamePredictions = CMsgServerToGCCompendiumChosenInGamePredictions {
            match_id: ::std::option::Option::None,
            predictions_chosen: ::std::vec::Vec::new(),
            league_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCCompendiumChosenInGamePredictions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCCompendiumChosenInGamePredictions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCCompendiumChosenInGamePredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCompendiumChosenInGamePredictions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCCompendiumChosenInGamePredictions`
pub mod cmsg_server_to_gccompendium_chosen_in_game_predictions {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCCompendiumChosenInGamePredictions.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCCompendiumChosenInGamePredictions.Prediction.prediction_id)
        pub prediction_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCompendiumChosenInGamePredictions.Prediction.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional uint32 prediction_id = 1;

        pub fn prediction_id(&self) -> u32 {
            self.prediction_id.unwrap_or(0)
        }

        pub fn clear_prediction_id(&mut self) {
            self.prediction_id = ::std::option::Option::None;
        }

        pub fn has_prediction_id(&self) -> bool {
            self.prediction_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_id(&mut self, v: u32) {
            self.prediction_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "prediction_id",
                |m: &Prediction| { &m.prediction_id },
                |m: &mut Prediction| { &mut m.prediction_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Prediction>(
                "CMsgServerToGCCompendiumChosenInGamePredictions.Prediction",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.prediction_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.prediction_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.prediction_id {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.prediction_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                prediction_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Prediction {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCCompendiumChosenInGamePredictions.Prediction").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Prediction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Prediction {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCCompendiumInGamePredictionResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCCompendiumInGamePredictionResults {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCCompendiumInGamePredictionResults.results)
    pub results: ::protobuf::MessageField<CMsgServerToGCCompendiumInGamePredictionResults>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCCompendiumInGamePredictionResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCCompendiumInGamePredictionResults {
    fn default() -> &'a CMsgGCToGCCompendiumInGamePredictionResults {
        <CMsgGCToGCCompendiumInGamePredictionResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCCompendiumInGamePredictionResults {
    pub fn new() -> CMsgGCToGCCompendiumInGamePredictionResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgServerToGCCompendiumInGamePredictionResults>(
            "results",
            |m: &CMsgGCToGCCompendiumInGamePredictionResults| { &m.results },
            |m: &mut CMsgGCToGCCompendiumInGamePredictionResults| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCCompendiumInGamePredictionResults>(
            "CMsgGCToGCCompendiumInGamePredictionResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCCompendiumInGamePredictionResults {
    const NAME: &'static str = "CMsgGCToGCCompendiumInGamePredictionResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.results)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.results.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCCompendiumInGamePredictionResults {
        CMsgGCToGCCompendiumInGamePredictionResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCCompendiumInGamePredictionResults {
        static instance: CMsgGCToGCCompendiumInGamePredictionResults = CMsgGCToGCCompendiumInGamePredictionResults {
            results: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCCompendiumInGamePredictionResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCCompendiumInGamePredictionResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCCompendiumInGamePredictionResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCCompendiumInGamePredictionResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchPlayerItemPurchaseHistory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcmatch_player_item_purchase_history::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn default() -> &'a CMsgServerToGCMatchPlayerItemPurchaseHistory {
        <CMsgServerToGCMatchPlayerItemPurchaseHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchPlayerItemPurchaseHistory {
    pub fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 mmr = 2;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCMatchPlayerItemPurchaseHistory| { &m.match_id },
            |m: &mut CMsgServerToGCMatchPlayerItemPurchaseHistory| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr",
            |m: &CMsgServerToGCMatchPlayerItemPurchaseHistory| { &m.mmr },
            |m: &mut CMsgServerToGCMatchPlayerItemPurchaseHistory| { &mut m.mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgServerToGCMatchPlayerItemPurchaseHistory| { &m.players },
            |m: &mut CMsgServerToGCMatchPlayerItemPurchaseHistory| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCMatchPlayerItemPurchaseHistory>(
            "CMsgServerToGCMatchPlayerItemPurchaseHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    const NAME: &'static str = "CMsgServerToGCMatchPlayerItemPurchaseHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.mmr {
            os.write_uint32(2, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory {
        CMsgServerToGCMatchPlayerItemPurchaseHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.mmr = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchPlayerItemPurchaseHistory {
        static instance: CMsgServerToGCMatchPlayerItemPurchaseHistory = CMsgServerToGCMatchPlayerItemPurchaseHistory {
            match_id: ::std::option::Option::None,
            mmr: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchPlayerItemPurchaseHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCMatchPlayerItemPurchaseHistory`
pub mod cmsg_server_to_gcmatch_player_item_purchase_history {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemPurchase {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.item)
        pub item: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.inventory_items)
        pub inventory_items: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.talents_skilled)
        pub talents_skilled: ::std::vec::Vec<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemPurchase {
        fn default() -> &'a ItemPurchase {
            <ItemPurchase as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemPurchase {
        pub fn new() -> ItemPurchase {
            ::std::default::Default::default()
        }

        // optional int32 item = 1;

        pub fn item(&self) -> i32 {
            self.item.unwrap_or(0)
        }

        pub fn clear_item(&mut self) {
            self.item = ::std::option::Option::None;
        }

        pub fn has_item(&self) -> bool {
            self.item.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item(&mut self, v: i32) {
            self.item = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 2;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 3;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 game_time = 4;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item",
                |m: &ItemPurchase| { &m.item },
                |m: &mut ItemPurchase| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold",
                |m: &ItemPurchase| { &m.gold },
                |m: &mut ItemPurchase| { &mut m.gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &ItemPurchase| { &m.net_worth },
                |m: &mut ItemPurchase| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_time",
                |m: &ItemPurchase| { &m.game_time },
                |m: &mut ItemPurchase| { &mut m.game_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "inventory_items",
                |m: &ItemPurchase| { &m.inventory_items },
                |m: &mut ItemPurchase| { &mut m.inventory_items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "talents_skilled",
                |m: &ItemPurchase| { &m.talents_skilled },
                |m: &mut ItemPurchase| { &mut m.talents_skilled },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemPurchase>(
                "CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemPurchase {
        const NAME: &'static str = "ItemPurchase";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.inventory_items)?;
                    },
                    40 => {
                        self.inventory_items.push(is.read_int32()?);
                    },
                    58 => {
                        is.read_repeated_packed_bool_into(&mut self.talents_skilled)?;
                    },
                    56 => {
                        self.talents_skilled.push(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.gold {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.inventory_items {
                my_size += ::protobuf::rt::int32_size(5, *value);
            };
            my_size += 2 * self.talents_skilled.len() as u64;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_uint32(4, v)?;
            }
            for v in &self.inventory_items {
                os.write_int32(5, *v)?;
            };
            for v in &self.talents_skilled {
                os.write_bool(7, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemPurchase {
            ItemPurchase::new()
        }

        fn clear(&mut self) {
            self.item = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.inventory_items.clear();
            self.talents_skilled.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemPurchase {
            static instance: ItemPurchase = ItemPurchase {
                item: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                inventory_items: ::std::vec::Vec::new(),
                talents_skilled: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemPurchase {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemPurchase {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemPurchase {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.allied_hero_ids)
        pub allied_hero_ids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.enemy_hero_ids)
        pub enemy_hero_ids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.item_purchases)
        pub item_purchases: ::std::vec::Vec<ItemPurchase>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.lane)
        pub lane: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.is_winner)
        pub is_winner: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 player_slot = 1;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 3;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 lane = 7;

        pub fn lane(&self) -> u32 {
            self.lane.unwrap_or(0)
        }

        pub fn clear_lane(&mut self) {
            self.lane = ::std::option::Option::None;
        }

        pub fn has_lane(&self) -> bool {
            self.lane.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane(&mut self, v: u32) {
            self.lane = ::std::option::Option::Some(v);
        }

        // optional bool is_winner = 8;

        pub fn is_winner(&self) -> bool {
            self.is_winner.unwrap_or(false)
        }

        pub fn clear_is_winner(&mut self) {
            self.is_winner = ::std::option::Option::None;
        }

        pub fn has_is_winner(&self) -> bool {
            self.is_winner.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_winner(&mut self, v: bool) {
            self.is_winner = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_slot",
                |m: &Player| { &m.player_slot },
                |m: &mut Player| { &mut m.player_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Player| { &m.hero_id },
                |m: &mut Player| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "allied_hero_ids",
                |m: &Player| { &m.allied_hero_ids },
                |m: &mut Player| { &mut m.allied_hero_ids },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "enemy_hero_ids",
                |m: &Player| { &m.enemy_hero_ids },
                |m: &mut Player| { &mut m.enemy_hero_ids },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "item_purchases",
                |m: &Player| { &m.item_purchases },
                |m: &mut Player| { &mut m.item_purchases },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lane",
                |m: &Player| { &m.lane },
                |m: &mut Player| { &mut m.lane },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_winner",
                |m: &Player| { &m.is_winner },
                |m: &mut Player| { &mut m.is_winner },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgServerToGCMatchPlayerItemPurchaseHistory.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.allied_hero_ids)?;
                    },
                    32 => {
                        self.allied_hero_ids.push(is.read_uint32()?);
                    },
                    42 => {
                        is.read_repeated_packed_uint32_into(&mut self.enemy_hero_ids)?;
                    },
                    40 => {
                        self.enemy_hero_ids.push(is.read_uint32()?);
                    },
                    50 => {
                        self.item_purchases.push(is.read_message()?);
                    },
                    56 => {
                        self.lane = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.is_winner = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_slot {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.allied_hero_ids {
                my_size += ::protobuf::rt::uint32_size(4, *value);
            };
            for value in &self.enemy_hero_ids {
                my_size += ::protobuf::rt::uint32_size(5, *value);
            };
            for value in &self.item_purchases {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.lane {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.is_winner {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_slot {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(3, v)?;
            }
            for v in &self.allied_hero_ids {
                os.write_uint32(4, *v)?;
            };
            for v in &self.enemy_hero_ids {
                os.write_uint32(5, *v)?;
            };
            for v in &self.item_purchases {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.lane {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.is_winner {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.player_slot = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.allied_hero_ids.clear();
            self.enemy_hero_ids.clear();
            self.item_purchases.clear();
            self.lane = ::std::option::Option::None;
            self.is_winner = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                player_slot: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                allied_hero_ids: ::std::vec::Vec::new(),
                enemy_hero_ids: ::std::vec::Vec::new(),
                item_purchases: ::std::vec::Vec::new(),
                lane: ::std::option::Option::None,
                is_winner: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchPlayerItemPurchaseHistory.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcmatch_player_neutral_item_equip_history::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    fn default() -> &'a CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        <CMsgServerToGCMatchPlayerNeutralItemEquipHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    pub fn new() -> CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCMatchPlayerNeutralItemEquipHistory| { &m.match_id },
            |m: &mut CMsgServerToGCMatchPlayerNeutralItemEquipHistory| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgServerToGCMatchPlayerNeutralItemEquipHistory| { &m.players },
            |m: &mut CMsgServerToGCMatchPlayerNeutralItemEquipHistory| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCMatchPlayerNeutralItemEquipHistory>(
            "CMsgServerToGCMatchPlayerNeutralItemEquipHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    const NAME: &'static str = "CMsgServerToGCMatchPlayerNeutralItemEquipHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        CMsgServerToGCMatchPlayerNeutralItemEquipHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        static instance: CMsgServerToGCMatchPlayerNeutralItemEquipHistory = CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
            match_id: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchPlayerNeutralItemEquipHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCMatchPlayerNeutralItemEquipHistory`
pub mod cmsg_server_to_gcmatch_player_neutral_item_equip_history {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemEquip {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.item)
        pub item: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.inventory_items)
        pub inventory_items: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.talents_skilled)
        pub talents_skilled: ::std::vec::Vec<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.available_neutral_items)
        pub available_neutral_items: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemEquip {
        fn default() -> &'a ItemEquip {
            <ItemEquip as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemEquip {
        pub fn new() -> ItemEquip {
            ::std::default::Default::default()
        }

        // optional int32 item = 1;

        pub fn item(&self) -> i32 {
            self.item.unwrap_or(0)
        }

        pub fn clear_item(&mut self) {
            self.item = ::std::option::Option::None;
        }

        pub fn has_item(&self) -> bool {
            self.item.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item(&mut self, v: i32) {
            self.item = ::std::option::Option::Some(v);
        }

        // optional uint32 game_time = 2;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item",
                |m: &ItemEquip| { &m.item },
                |m: &mut ItemEquip| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_time",
                |m: &ItemEquip| { &m.game_time },
                |m: &mut ItemEquip| { &mut m.game_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "inventory_items",
                |m: &ItemEquip| { &m.inventory_items },
                |m: &mut ItemEquip| { &mut m.inventory_items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "talents_skilled",
                |m: &ItemEquip| { &m.talents_skilled },
                |m: &mut ItemEquip| { &mut m.talents_skilled },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "available_neutral_items",
                |m: &ItemEquip| { &m.available_neutral_items },
                |m: &mut ItemEquip| { &mut m.available_neutral_items },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemEquip>(
                "CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemEquip {
        const NAME: &'static str = "ItemEquip";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_int32_into(&mut self.inventory_items)?;
                    },
                    24 => {
                        self.inventory_items.push(is.read_int32()?);
                    },
                    34 => {
                        is.read_repeated_packed_bool_into(&mut self.talents_skilled)?;
                    },
                    32 => {
                        self.talents_skilled.push(is.read_bool()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.available_neutral_items)?;
                    },
                    40 => {
                        self.available_neutral_items.push(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.inventory_items {
                my_size += ::protobuf::rt::int32_size(3, *value);
            };
            my_size += 2 * self.talents_skilled.len() as u64;
            for value in &self.available_neutral_items {
                my_size += ::protobuf::rt::int32_size(5, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_uint32(2, v)?;
            }
            for v in &self.inventory_items {
                os.write_int32(3, *v)?;
            };
            for v in &self.talents_skilled {
                os.write_bool(4, *v)?;
            };
            for v in &self.available_neutral_items {
                os.write_int32(5, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemEquip {
            ItemEquip::new()
        }

        fn clear(&mut self) {
            self.item = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.inventory_items.clear();
            self.talents_skilled.clear();
            self.available_neutral_items.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemEquip {
            static instance: ItemEquip = ItemEquip {
                item: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                inventory_items: ::std::vec::Vec::new(),
                talents_skilled: ::std::vec::Vec::new(),
                available_neutral_items: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemEquip {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemEquip {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemEquip {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.allied_hero_ids)
        pub allied_hero_ids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.enemy_hero_ids)
        pub enemy_hero_ids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.item_equips)
        pub item_equips: ::std::vec::Vec<ItemEquip>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.is_winner)
        pub is_winner: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional bool is_winner = 5;

        pub fn is_winner(&self) -> bool {
            self.is_winner.unwrap_or(false)
        }

        pub fn clear_is_winner(&mut self) {
            self.is_winner = ::std::option::Option::None;
        }

        pub fn has_is_winner(&self) -> bool {
            self.is_winner.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_winner(&mut self, v: bool) {
            self.is_winner = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "allied_hero_ids",
                |m: &Player| { &m.allied_hero_ids },
                |m: &mut Player| { &mut m.allied_hero_ids },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "enemy_hero_ids",
                |m: &Player| { &m.enemy_hero_ids },
                |m: &mut Player| { &mut m.enemy_hero_ids },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "item_equips",
                |m: &Player| { &m.item_equips },
                |m: &mut Player| { &mut m.item_equips },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_winner",
                |m: &Player| { &m.is_winner },
                |m: &mut Player| { &mut m.is_winner },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.allied_hero_ids)?;
                    },
                    16 => {
                        self.allied_hero_ids.push(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.enemy_hero_ids)?;
                    },
                    24 => {
                        self.enemy_hero_ids.push(is.read_uint32()?);
                    },
                    34 => {
                        self.item_equips.push(is.read_message()?);
                    },
                    40 => {
                        self.is_winner = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.allied_hero_ids {
                my_size += ::protobuf::rt::uint32_size(2, *value);
            };
            for value in &self.enemy_hero_ids {
                my_size += ::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.item_equips {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.is_winner {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.allied_hero_ids {
                os.write_uint32(2, *v)?;
            };
            for v in &self.enemy_hero_ids {
                os.write_uint32(3, *v)?;
            };
            for v in &self.item_equips {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.is_winner {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.allied_hero_ids.clear();
            self.enemy_hero_ids.clear();
            self.item_equips.clear();
            self.is_winner = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                allied_hero_ids: ::std::vec::Vec::new(),
                enemy_hero_ids: ::std::vec::Vec::new(),
                item_equips: ::std::vec::Vec::new(),
                is_winner: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCMatchStateHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchStateHistory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.radiant_won)
    pub radiant_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.match_states)
    pub match_states: ::std::vec::Vec<cmsg_server_to_gcmatch_state_history::MatchState>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchStateHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchStateHistory {
    fn default() -> &'a CMsgServerToGCMatchStateHistory {
        <CMsgServerToGCMatchStateHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchStateHistory {
    pub fn new() -> CMsgServerToGCMatchStateHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool radiant_won = 2;

    pub fn radiant_won(&self) -> bool {
        self.radiant_won.unwrap_or(false)
    }

    pub fn clear_radiant_won(&mut self) {
        self.radiant_won = ::std::option::Option::None;
    }

    pub fn has_radiant_won(&self) -> bool {
        self.radiant_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_won(&mut self, v: bool) {
        self.radiant_won = ::std::option::Option::Some(v);
    }

    // optional uint32 mmr = 3;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCMatchStateHistory| { &m.match_id },
            |m: &mut CMsgServerToGCMatchStateHistory| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_won",
            |m: &CMsgServerToGCMatchStateHistory| { &m.radiant_won },
            |m: &mut CMsgServerToGCMatchStateHistory| { &mut m.radiant_won },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr",
            |m: &CMsgServerToGCMatchStateHistory| { &m.mmr },
            |m: &mut CMsgServerToGCMatchStateHistory| { &mut m.mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "match_states",
            |m: &CMsgServerToGCMatchStateHistory| { &m.match_states },
            |m: &mut CMsgServerToGCMatchStateHistory| { &mut m.match_states },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCMatchStateHistory>(
            "CMsgServerToGCMatchStateHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchStateHistory {
    const NAME: &'static str = "CMsgServerToGCMatchStateHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.radiant_won = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.match_states.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.radiant_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.match_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.radiant_won {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.mmr {
            os.write_uint32(3, v)?;
        }
        for v in &self.match_states {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchStateHistory {
        CMsgServerToGCMatchStateHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.radiant_won = ::std::option::Option::None;
        self.mmr = ::std::option::Option::None;
        self.match_states.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchStateHistory {
        static instance: CMsgServerToGCMatchStateHistory = CMsgServerToGCMatchStateHistory {
            match_id: ::std::option::Option::None,
            radiant_won: ::std::option::Option::None,
            mmr: ::std::option::Option::None,
            match_states: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCMatchStateHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchStateHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCMatchStateHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchStateHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCMatchStateHistory`
pub mod cmsg_server_to_gcmatch_state_history {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchStateHistory.PlayerState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerState {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.respawn_time)
        pub respawn_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.has_buyback)
        pub has_buyback: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.has_aegis)
        pub has_aegis: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.has_rapier)
        pub has_rapier: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.PlayerState.distance)
        pub distance: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchStateHistory.PlayerState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerState {
        fn default() -> &'a PlayerState {
            <PlayerState as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerState {
        pub fn new() -> PlayerState {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 2;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 3;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 4;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 respawn_time = 5;

        pub fn respawn_time(&self) -> u32 {
            self.respawn_time.unwrap_or(0)
        }

        pub fn clear_respawn_time(&mut self) {
            self.respawn_time = ::std::option::Option::None;
        }

        pub fn has_respawn_time(&self) -> bool {
            self.respawn_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_time(&mut self, v: u32) {
            self.respawn_time = ::std::option::Option::Some(v);
        }

        // optional bool has_buyback = 6;

        pub fn has_buyback(&self) -> bool {
            self.has_buyback.unwrap_or(false)
        }

        pub fn clear_has_buyback(&mut self) {
            self.has_buyback = ::std::option::Option::None;
        }

        pub fn has_has_buyback(&self) -> bool {
            self.has_buyback.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_buyback(&mut self, v: bool) {
            self.has_buyback = ::std::option::Option::Some(v);
        }

        // optional bool has_aegis = 7;

        pub fn has_aegis(&self) -> bool {
            self.has_aegis.unwrap_or(false)
        }

        pub fn clear_has_aegis(&mut self) {
            self.has_aegis = ::std::option::Option::None;
        }

        pub fn has_has_aegis(&self) -> bool {
            self.has_aegis.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_aegis(&mut self, v: bool) {
            self.has_aegis = ::std::option::Option::Some(v);
        }

        // optional bool has_rapier = 8;

        pub fn has_rapier(&self) -> bool {
            self.has_rapier.unwrap_or(false)
        }

        pub fn clear_has_rapier(&mut self) {
            self.has_rapier = ::std::option::Option::None;
        }

        pub fn has_has_rapier(&self) -> bool {
            self.has_rapier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_rapier(&mut self, v: bool) {
            self.has_rapier = ::std::option::Option::Some(v);
        }

        // optional uint32 distance = 9;

        pub fn distance(&self) -> u32 {
            self.distance.unwrap_or(0)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: u32) {
            self.distance = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &PlayerState| { &m.hero_id },
                |m: &mut PlayerState| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &PlayerState| { &m.net_worth },
                |m: &mut PlayerState| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &PlayerState| { &m.level },
                |m: &mut PlayerState| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &PlayerState| { &m.deaths },
                |m: &mut PlayerState| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "respawn_time",
                |m: &PlayerState| { &m.respawn_time },
                |m: &mut PlayerState| { &mut m.respawn_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_buyback",
                |m: &PlayerState| { &m.has_buyback },
                |m: &mut PlayerState| { &mut m.has_buyback },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_aegis",
                |m: &PlayerState| { &m.has_aegis },
                |m: &mut PlayerState| { &mut m.has_aegis },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_rapier",
                |m: &PlayerState| { &m.has_rapier },
                |m: &mut PlayerState| { &mut m.has_rapier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "distance",
                |m: &PlayerState| { &m.distance },
                |m: &mut PlayerState| { &mut m.distance },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerState>(
                "CMsgServerToGCMatchStateHistory.PlayerState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerState {
        const NAME: &'static str = "PlayerState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.respawn_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.has_buyback = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.has_aegis = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.has_rapier = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.distance = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.respawn_time {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.has_buyback {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_aegis {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_rapier {
                my_size += 1 + 1;
            }
            if let Some(v) = self.distance {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.respawn_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.has_buyback {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.has_aegis {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.has_rapier {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.distance {
                os.write_uint32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerState {
            PlayerState::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.respawn_time = ::std::option::Option::None;
            self.has_buyback = ::std::option::Option::None;
            self.has_aegis = ::std::option::Option::None;
            self.has_rapier = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerState {
            static instance: PlayerState = PlayerState {
                hero_id: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                level: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                respawn_time: ::std::option::Option::None,
                has_buyback: ::std::option::Option::None,
                has_aegis: ::std::option::Option::None,
                has_rapier: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchStateHistory.PlayerState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchStateHistory.TeamState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamState {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.player_states)
        pub player_states: ::std::vec::Vec<PlayerState>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.tower_health_pct)
        pub tower_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.barracks_health_pct)
        pub barracks_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.ancient_health_pct)
        pub ancient_health_pct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.glyph_cooldown)
        pub glyph_cooldown: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.creep_distance_safe)
        pub creep_distance_safe: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.creep_distance_mid)
        pub creep_distance_mid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.TeamState.creep_distance_off)
        pub creep_distance_off: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchStateHistory.TeamState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamState {
        fn default() -> &'a TeamState {
            <TeamState as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamState {
        pub fn new() -> TeamState {
            ::std::default::Default::default()
        }

        // optional uint32 team = 1;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 ancient_health_pct = 5;

        pub fn ancient_health_pct(&self) -> u32 {
            self.ancient_health_pct.unwrap_or(0)
        }

        pub fn clear_ancient_health_pct(&mut self) {
            self.ancient_health_pct = ::std::option::Option::None;
        }

        pub fn has_ancient_health_pct(&self) -> bool {
            self.ancient_health_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ancient_health_pct(&mut self, v: u32) {
            self.ancient_health_pct = ::std::option::Option::Some(v);
        }

        // optional uint32 glyph_cooldown = 6;

        pub fn glyph_cooldown(&self) -> u32 {
            self.glyph_cooldown.unwrap_or(0)
        }

        pub fn clear_glyph_cooldown(&mut self) {
            self.glyph_cooldown = ::std::option::Option::None;
        }

        pub fn has_glyph_cooldown(&self) -> bool {
            self.glyph_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_glyph_cooldown(&mut self, v: u32) {
            self.glyph_cooldown = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 7;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_safe = 8;

        pub fn creep_distance_safe(&self) -> u32 {
            self.creep_distance_safe.unwrap_or(0)
        }

        pub fn clear_creep_distance_safe(&mut self) {
            self.creep_distance_safe = ::std::option::Option::None;
        }

        pub fn has_creep_distance_safe(&self) -> bool {
            self.creep_distance_safe.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_safe(&mut self, v: u32) {
            self.creep_distance_safe = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_mid = 9;

        pub fn creep_distance_mid(&self) -> u32 {
            self.creep_distance_mid.unwrap_or(0)
        }

        pub fn clear_creep_distance_mid(&mut self) {
            self.creep_distance_mid = ::std::option::Option::None;
        }

        pub fn has_creep_distance_mid(&self) -> bool {
            self.creep_distance_mid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_mid(&mut self, v: u32) {
            self.creep_distance_mid = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_off = 10;

        pub fn creep_distance_off(&self) -> u32 {
            self.creep_distance_off.unwrap_or(0)
        }

        pub fn clear_creep_distance_off(&mut self) {
            self.creep_distance_off = ::std::option::Option::None;
        }

        pub fn has_creep_distance_off(&self) -> bool {
            self.creep_distance_off.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_off(&mut self, v: u32) {
            self.creep_distance_off = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &TeamState| { &m.team },
                |m: &mut TeamState| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "player_states",
                |m: &TeamState| { &m.player_states },
                |m: &mut TeamState| { &mut m.player_states },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "tower_health_pct",
                |m: &TeamState| { &m.tower_health_pct },
                |m: &mut TeamState| { &mut m.tower_health_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "barracks_health_pct",
                |m: &TeamState| { &m.barracks_health_pct },
                |m: &mut TeamState| { &mut m.barracks_health_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ancient_health_pct",
                |m: &TeamState| { &m.ancient_health_pct },
                |m: &mut TeamState| { &mut m.ancient_health_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "glyph_cooldown",
                |m: &TeamState| { &m.glyph_cooldown },
                |m: &mut TeamState| { &mut m.glyph_cooldown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &TeamState| { &m.kills },
                |m: &mut TeamState| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_distance_safe",
                |m: &TeamState| { &m.creep_distance_safe },
                |m: &mut TeamState| { &mut m.creep_distance_safe },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_distance_mid",
                |m: &TeamState| { &m.creep_distance_mid },
                |m: &mut TeamState| { &mut m.creep_distance_mid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_distance_off",
                |m: &TeamState| { &m.creep_distance_off },
                |m: &mut TeamState| { &mut m.creep_distance_off },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamState>(
                "CMsgServerToGCMatchStateHistory.TeamState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamState {
        const NAME: &'static str = "TeamState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_states.push(is.read_message()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.tower_health_pct)?;
                    },
                    24 => {
                        self.tower_health_pct.push(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.barracks_health_pct)?;
                    },
                    32 => {
                        self.barracks_health_pct.push(is.read_uint32()?);
                    },
                    40 => {
                        self.ancient_health_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.glyph_cooldown = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.creep_distance_safe = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.creep_distance_mid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.creep_distance_off = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.player_states {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.tower_health_pct {
                my_size += ::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.barracks_health_pct {
                my_size += ::protobuf::rt::uint32_size(4, *value);
            };
            if let Some(v) = self.ancient_health_pct {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.glyph_cooldown {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.creep_distance_safe {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.creep_distance_mid {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.creep_distance_off {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(1, v)?;
            }
            for v in &self.player_states {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.tower_health_pct {
                os.write_uint32(3, *v)?;
            };
            for v in &self.barracks_health_pct {
                os.write_uint32(4, *v)?;
            };
            if let Some(v) = self.ancient_health_pct {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.glyph_cooldown {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.creep_distance_safe {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.creep_distance_mid {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.creep_distance_off {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamState {
            TeamState::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.player_states.clear();
            self.tower_health_pct.clear();
            self.barracks_health_pct.clear();
            self.ancient_health_pct = ::std::option::Option::None;
            self.glyph_cooldown = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.creep_distance_safe = ::std::option::Option::None;
            self.creep_distance_mid = ::std::option::Option::None;
            self.creep_distance_off = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamState {
            static instance: TeamState = TeamState {
                team: ::std::option::Option::None,
                player_states: ::std::vec::Vec::new(),
                tower_health_pct: ::std::vec::Vec::new(),
                barracks_health_pct: ::std::vec::Vec::new(),
                ancient_health_pct: ::std::option::Option::None,
                glyph_cooldown: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                creep_distance_safe: ::std::option::Option::None,
                creep_distance_mid: ::std::option::Option::None,
                creep_distance_off: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchStateHistory.TeamState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgServerToGCMatchStateHistory.MatchState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchState {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.MatchState.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.MatchState.radiant_state)
        pub radiant_state: ::protobuf::MessageField<TeamState>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCMatchStateHistory.MatchState.dire_state)
        pub dire_state: ::protobuf::MessageField<TeamState>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCMatchStateHistory.MatchState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchState {
        fn default() -> &'a MatchState {
            <MatchState as ::protobuf::Message>::default_instance()
        }
    }

    impl MatchState {
        pub fn new() -> MatchState {
            ::std::default::Default::default()
        }

        // optional uint32 game_time = 1;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_time",
                |m: &MatchState| { &m.game_time },
                |m: &mut MatchState| { &mut m.game_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TeamState>(
                "radiant_state",
                |m: &MatchState| { &m.radiant_state },
                |m: &mut MatchState| { &mut m.radiant_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TeamState>(
                "dire_state",
                |m: &MatchState| { &m.dire_state },
                |m: &mut MatchState| { &mut m.dire_state },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchState>(
                "CMsgServerToGCMatchStateHistory.MatchState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatchState {
        const NAME: &'static str = "MatchState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_state)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_state)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_time {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.radiant_state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dire_state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.game_time {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.radiant_state.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.dire_state.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchState {
            MatchState::new()
        }

        fn clear(&mut self) {
            self.game_time = ::std::option::Option::None;
            self.radiant_state.clear();
            self.dire_state.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchState {
            static instance: MatchState = MatchState {
                game_time: ::std::option::Option::None,
                radiant_state: ::protobuf::MessageField::none(),
                dire_state: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatchState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCMatchStateHistory.MatchState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatchState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatchState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgMatchStateSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchStateSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgMatchStateSteamMLEntry.match_state)
    pub match_state: ::protobuf::MessageField<cmsg_server_to_gcmatch_state_history::MatchState>,
    // @@protoc_insertion_point(field:dota.CMsgMatchStateSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgMatchStateSteamMLEntry.radiant_won)
    pub radiant_won: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgMatchStateSteamMLEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchStateSteamMLEntry {
    fn default() -> &'a CMsgMatchStateSteamMLEntry {
        <CMsgMatchStateSteamMLEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchStateSteamMLEntry {
    pub fn new() -> CMsgMatchStateSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 2;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional bool radiant_won = 3;

    pub fn radiant_won(&self) -> bool {
        self.radiant_won.unwrap_or(false)
    }

    pub fn clear_radiant_won(&mut self) {
        self.radiant_won = ::std::option::Option::None;
    }

    pub fn has_radiant_won(&self) -> bool {
        self.radiant_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_won(&mut self, v: bool) {
        self.radiant_won = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_server_to_gcmatch_state_history::MatchState>(
            "match_state",
            |m: &CMsgMatchStateSteamMLEntry| { &m.match_state },
            |m: &mut CMsgMatchStateSteamMLEntry| { &mut m.match_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr",
            |m: &CMsgMatchStateSteamMLEntry| { &m.mmr },
            |m: &mut CMsgMatchStateSteamMLEntry| { &mut m.mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_won",
            |m: &CMsgMatchStateSteamMLEntry| { &m.radiant_won },
            |m: &mut CMsgMatchStateSteamMLEntry| { &mut m.radiant_won },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchStateSteamMLEntry>(
            "CMsgMatchStateSteamMLEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchStateSteamMLEntry {
    const NAME: &'static str = "CMsgMatchStateSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_state)?;
                },
                16 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.radiant_won = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.radiant_won {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.mmr {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.radiant_won {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchStateSteamMLEntry {
        CMsgMatchStateSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.match_state.clear();
        self.mmr = ::std::option::Option::None;
        self.radiant_won = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchStateSteamMLEntry {
        static instance: CMsgMatchStateSteamMLEntry = CMsgMatchStateSteamMLEntry {
            match_state: ::protobuf::MessageField::none(),
            mmr: ::std::option::Option::None,
            radiant_won: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchStateSteamMLEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchStateSteamMLEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchStateSteamMLEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchStateSteamMLEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLaneSelectionSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLaneSelectionSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLaneSelectionSteamMLEntry.hero_ids)
    pub hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLaneSelectionSteamMLEntry.lanes)
    pub lanes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLaneSelectionSteamMLEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLaneSelectionSteamMLEntry {
    fn default() -> &'a CMsgLaneSelectionSteamMLEntry {
        <CMsgLaneSelectionSteamMLEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLaneSelectionSteamMLEntry {
    pub fn new() -> CMsgLaneSelectionSteamMLEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_ids",
            |m: &CMsgLaneSelectionSteamMLEntry| { &m.hero_ids },
            |m: &mut CMsgLaneSelectionSteamMLEntry| { &mut m.hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lanes",
            |m: &CMsgLaneSelectionSteamMLEntry| { &m.lanes },
            |m: &mut CMsgLaneSelectionSteamMLEntry| { &mut m.lanes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLaneSelectionSteamMLEntry>(
            "CMsgLaneSelectionSteamMLEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLaneSelectionSteamMLEntry {
    const NAME: &'static str = "CMsgLaneSelectionSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.hero_ids)?;
                },
                8 => {
                    self.hero_ids.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.lanes)?;
                },
                16 => {
                    self.lanes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.lanes {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hero_ids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.lanes {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLaneSelectionSteamMLEntry {
        CMsgLaneSelectionSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.hero_ids.clear();
        self.lanes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLaneSelectionSteamMLEntry {
        static instance: CMsgLaneSelectionSteamMLEntry = CMsgLaneSelectionSteamMLEntry {
            hero_ids: ::std::vec::Vec::new(),
            lanes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLaneSelectionSteamMLEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLaneSelectionSteamMLEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLaneSelectionSteamMLEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLaneSelectionSteamMLEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAbilitySelectionSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAbilitySelectionSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAbilitySelectionSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAbilitySelectionSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAbilitySelectionSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAbilitySelectionSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAbilitySelectionSteamMLEntry.abilities)
    pub abilities: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgAbilitySelectionSteamMLEntry.selected_ability)
    pub selected_ability: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAbilitySelectionSteamMLEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAbilitySelectionSteamMLEntry {
    fn default() -> &'a CMsgAbilitySelectionSteamMLEntry {
        <CMsgAbilitySelectionSteamMLEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAbilitySelectionSteamMLEntry {
    pub fn new() -> CMsgAbilitySelectionSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 2;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 4;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional int32 selected_ability = 6;

    pub fn selected_ability(&self) -> i32 {
        self.selected_ability.unwrap_or(0)
    }

    pub fn clear_selected_ability(&mut self) {
        self.selected_ability = ::std::option::Option::None;
    }

    pub fn has_selected_ability(&self) -> bool {
        self.selected_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_ability(&mut self, v: i32) {
        self.selected_ability = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr",
            |m: &CMsgAbilitySelectionSteamMLEntry| { &m.mmr },
            |m: &mut CMsgAbilitySelectionSteamMLEntry| { &mut m.mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgAbilitySelectionSteamMLEntry| { &m.hero_id },
            |m: &mut CMsgAbilitySelectionSteamMLEntry| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_hero_ids",
            |m: &CMsgAbilitySelectionSteamMLEntry| { &m.enemy_hero_ids },
            |m: &mut CMsgAbilitySelectionSteamMLEntry| { &mut m.enemy_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane",
            |m: &CMsgAbilitySelectionSteamMLEntry| { &m.lane },
            |m: &mut CMsgAbilitySelectionSteamMLEntry| { &mut m.lane },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &CMsgAbilitySelectionSteamMLEntry| { &m.abilities },
            |m: &mut CMsgAbilitySelectionSteamMLEntry| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_ability",
            |m: &CMsgAbilitySelectionSteamMLEntry| { &m.selected_ability },
            |m: &mut CMsgAbilitySelectionSteamMLEntry| { &mut m.selected_ability },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAbilitySelectionSteamMLEntry>(
            "CMsgAbilitySelectionSteamMLEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAbilitySelectionSteamMLEntry {
    const NAME: &'static str = "CMsgAbilitySelectionSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.enemy_hero_ids)?;
                },
                24 => {
                    self.enemy_hero_ids.push(is.read_uint32()?);
                },
                32 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.abilities)?;
                },
                40 => {
                    self.abilities.push(is.read_int32()?);
                },
                48 => {
                    self.selected_ability = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.enemy_hero_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.lane {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.abilities {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        if let Some(v) = self.selected_ability {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.enemy_hero_ids {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.lane {
            os.write_uint32(4, v)?;
        }
        for v in &self.abilities {
            os.write_int32(5, *v)?;
        };
        if let Some(v) = self.selected_ability {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAbilitySelectionSteamMLEntry {
        CMsgAbilitySelectionSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.enemy_hero_ids.clear();
        self.lane = ::std::option::Option::None;
        self.abilities.clear();
        self.selected_ability = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAbilitySelectionSteamMLEntry {
        static instance: CMsgAbilitySelectionSteamMLEntry = CMsgAbilitySelectionSteamMLEntry {
            mmr: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            enemy_hero_ids: ::std::vec::Vec::new(),
            lane: ::std::option::Option::None,
            abilities: ::std::vec::Vec::new(),
            selected_ability: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAbilitySelectionSteamMLEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAbilitySelectionSteamMLEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAbilitySelectionSteamMLEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAbilitySelectionSteamMLEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgItemPurchasePregameSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemPurchasePregameSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgItemPurchasePregameSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchasePregameSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchasePregameSteamMLEntry.balance)
    pub balance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchasePregameSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchasePregameSteamMLEntry.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchasePregameSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchasePregameSteamMLEntry.items)
    pub items: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgItemPurchasePregameSteamMLEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemPurchasePregameSteamMLEntry {
    fn default() -> &'a CMsgItemPurchasePregameSteamMLEntry {
        <CMsgItemPurchasePregameSteamMLEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemPurchasePregameSteamMLEntry {
    pub fn new() -> CMsgItemPurchasePregameSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional float balance = 3;

    pub fn balance(&self) -> f32 {
        self.balance.unwrap_or(0.)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: f32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 4;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr",
            |m: &CMsgItemPurchasePregameSteamMLEntry| { &m.mmr },
            |m: &mut CMsgItemPurchasePregameSteamMLEntry| { &mut m.mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane",
            |m: &CMsgItemPurchasePregameSteamMLEntry| { &m.lane },
            |m: &mut CMsgItemPurchasePregameSteamMLEntry| { &mut m.lane },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &CMsgItemPurchasePregameSteamMLEntry| { &m.balance },
            |m: &mut CMsgItemPurchasePregameSteamMLEntry| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgItemPurchasePregameSteamMLEntry| { &m.hero_id },
            |m: &mut CMsgItemPurchasePregameSteamMLEntry| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allied_hero_ids",
            |m: &CMsgItemPurchasePregameSteamMLEntry| { &m.allied_hero_ids },
            |m: &mut CMsgItemPurchasePregameSteamMLEntry| { &mut m.allied_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_hero_ids",
            |m: &CMsgItemPurchasePregameSteamMLEntry| { &m.enemy_hero_ids },
            |m: &mut CMsgItemPurchasePregameSteamMLEntry| { &mut m.enemy_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgItemPurchasePregameSteamMLEntry| { &m.items },
            |m: &mut CMsgItemPurchasePregameSteamMLEntry| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemPurchasePregameSteamMLEntry>(
            "CMsgItemPurchasePregameSteamMLEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemPurchasePregameSteamMLEntry {
    const NAME: &'static str = "CMsgItemPurchasePregameSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.balance = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.allied_hero_ids)?;
                },
                40 => {
                    self.allied_hero_ids.push(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.enemy_hero_ids)?;
                },
                48 => {
                    self.enemy_hero_ids.push(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                56 => {
                    self.items.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.balance {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        for value in &self.items {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.balance {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_uint32(5, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_uint32(6, *v)?;
        };
        for v in &self.items {
            os.write_int32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemPurchasePregameSteamMLEntry {
        CMsgItemPurchasePregameSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemPurchasePregameSteamMLEntry {
        static instance: CMsgItemPurchasePregameSteamMLEntry = CMsgItemPurchasePregameSteamMLEntry {
            mmr: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemPurchasePregameSteamMLEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemPurchasePregameSteamMLEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemPurchasePregameSteamMLEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemPurchasePregameSteamMLEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgItemPurchaseSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemPurchaseSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSteamMLEntry.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSteamMLEntry.items)
    pub items: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSteamMLEntry.items_to_be_purchased)
    pub items_to_be_purchased: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgItemPurchaseSteamMLEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemPurchaseSteamMLEntry {
    fn default() -> &'a CMsgItemPurchaseSteamMLEntry {
        <CMsgItemPurchaseSteamMLEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemPurchaseSteamMLEntry {
    pub fn new() -> CMsgItemPurchaseSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 3;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr",
            |m: &CMsgItemPurchaseSteamMLEntry| { &m.mmr },
            |m: &mut CMsgItemPurchaseSteamMLEntry| { &mut m.mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane",
            |m: &CMsgItemPurchaseSteamMLEntry| { &m.lane },
            |m: &mut CMsgItemPurchaseSteamMLEntry| { &mut m.lane },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgItemPurchaseSteamMLEntry| { &m.hero_id },
            |m: &mut CMsgItemPurchaseSteamMLEntry| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allied_hero_ids",
            |m: &CMsgItemPurchaseSteamMLEntry| { &m.allied_hero_ids },
            |m: &mut CMsgItemPurchaseSteamMLEntry| { &mut m.allied_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_hero_ids",
            |m: &CMsgItemPurchaseSteamMLEntry| { &m.enemy_hero_ids },
            |m: &mut CMsgItemPurchaseSteamMLEntry| { &mut m.enemy_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgItemPurchaseSteamMLEntry| { &m.items },
            |m: &mut CMsgItemPurchaseSteamMLEntry| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items_to_be_purchased",
            |m: &CMsgItemPurchaseSteamMLEntry| { &m.items_to_be_purchased },
            |m: &mut CMsgItemPurchaseSteamMLEntry| { &mut m.items_to_be_purchased },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemPurchaseSteamMLEntry>(
            "CMsgItemPurchaseSteamMLEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemPurchaseSteamMLEntry {
    const NAME: &'static str = "CMsgItemPurchaseSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.allied_hero_ids)?;
                },
                32 => {
                    self.allied_hero_ids.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.enemy_hero_ids)?;
                },
                40 => {
                    self.enemy_hero_ids.push(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                48 => {
                    self.items.push(is.read_int32()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.items_to_be_purchased)?;
                },
                56 => {
                    self.items_to_be_purchased.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.items {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        for value in &self.items_to_be_purchased {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_uint32(4, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_uint32(5, *v)?;
        };
        for v in &self.items {
            os.write_int32(6, *v)?;
        };
        for v in &self.items_to_be_purchased {
            os.write_int32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemPurchaseSteamMLEntry {
        CMsgItemPurchaseSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.items.clear();
        self.items_to_be_purchased.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemPurchaseSteamMLEntry {
        static instance: CMsgItemPurchaseSteamMLEntry = CMsgItemPurchaseSteamMLEntry {
            mmr: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            items_to_be_purchased: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemPurchaseSteamMLEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemPurchaseSteamMLEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemPurchaseSteamMLEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemPurchaseSteamMLEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgItemPurchaseSequenceSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemPurchaseSequenceSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSequenceSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSequenceSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSequenceSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSequenceSteamMLEntry.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSequenceSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSequenceSteamMLEntry.items)
    pub items: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgItemPurchaseSequenceSteamMLEntry.item_to_be_purchased)
    pub item_to_be_purchased: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgItemPurchaseSequenceSteamMLEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemPurchaseSequenceSteamMLEntry {
    fn default() -> &'a CMsgItemPurchaseSequenceSteamMLEntry {
        <CMsgItemPurchaseSequenceSteamMLEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemPurchaseSequenceSteamMLEntry {
    pub fn new() -> CMsgItemPurchaseSequenceSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 3;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_to_be_purchased = 7;

    pub fn item_to_be_purchased(&self) -> i32 {
        self.item_to_be_purchased.unwrap_or(0)
    }

    pub fn clear_item_to_be_purchased(&mut self) {
        self.item_to_be_purchased = ::std::option::Option::None;
    }

    pub fn has_item_to_be_purchased(&self) -> bool {
        self.item_to_be_purchased.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_to_be_purchased(&mut self, v: i32) {
        self.item_to_be_purchased = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr",
            |m: &CMsgItemPurchaseSequenceSteamMLEntry| { &m.mmr },
            |m: &mut CMsgItemPurchaseSequenceSteamMLEntry| { &mut m.mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane",
            |m: &CMsgItemPurchaseSequenceSteamMLEntry| { &m.lane },
            |m: &mut CMsgItemPurchaseSequenceSteamMLEntry| { &mut m.lane },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgItemPurchaseSequenceSteamMLEntry| { &m.hero_id },
            |m: &mut CMsgItemPurchaseSequenceSteamMLEntry| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allied_hero_ids",
            |m: &CMsgItemPurchaseSequenceSteamMLEntry| { &m.allied_hero_ids },
            |m: &mut CMsgItemPurchaseSequenceSteamMLEntry| { &mut m.allied_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_hero_ids",
            |m: &CMsgItemPurchaseSequenceSteamMLEntry| { &m.enemy_hero_ids },
            |m: &mut CMsgItemPurchaseSequenceSteamMLEntry| { &mut m.enemy_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgItemPurchaseSequenceSteamMLEntry| { &m.items },
            |m: &mut CMsgItemPurchaseSequenceSteamMLEntry| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_to_be_purchased",
            |m: &CMsgItemPurchaseSequenceSteamMLEntry| { &m.item_to_be_purchased },
            |m: &mut CMsgItemPurchaseSequenceSteamMLEntry| { &mut m.item_to_be_purchased },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemPurchaseSequenceSteamMLEntry>(
            "CMsgItemPurchaseSequenceSteamMLEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemPurchaseSequenceSteamMLEntry {
    const NAME: &'static str = "CMsgItemPurchaseSequenceSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.allied_hero_ids)?;
                },
                32 => {
                    self.allied_hero_ids.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.enemy_hero_ids)?;
                },
                40 => {
                    self.enemy_hero_ids.push(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                48 => {
                    self.items.push(is.read_int32()?);
                },
                56 => {
                    self.item_to_be_purchased = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.items {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        if let Some(v) = self.item_to_be_purchased {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_uint32(4, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_uint32(5, *v)?;
        };
        for v in &self.items {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.item_to_be_purchased {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemPurchaseSequenceSteamMLEntry {
        CMsgItemPurchaseSequenceSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.items.clear();
        self.item_to_be_purchased = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemPurchaseSequenceSteamMLEntry {
        static instance: CMsgItemPurchaseSequenceSteamMLEntry = CMsgItemPurchaseSequenceSteamMLEntry {
            mmr: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            item_to_be_purchased: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemPurchaseSequenceSteamMLEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemPurchaseSequenceSteamMLEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemPurchaseSequenceSteamMLEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemPurchaseSequenceSteamMLEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCCavernCrawlIsHeroActive)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCavernCrawlIsHeroActive {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActive.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActive.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActive.preferred_map_variant)
    pub preferred_map_variant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActive.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActive.turbo_mode)
    pub turbo_mode: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCavernCrawlIsHeroActive.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCavernCrawlIsHeroActive {
    fn default() -> &'a CMsgServerToGCCavernCrawlIsHeroActive {
        <CMsgServerToGCCavernCrawlIsHeroActive as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCavernCrawlIsHeroActive {
    pub fn new() -> CMsgServerToGCCavernCrawlIsHeroActive {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preferred_map_variant = 3;

    pub fn preferred_map_variant(&self) -> u32 {
        self.preferred_map_variant.unwrap_or(0)
    }

    pub fn clear_preferred_map_variant(&mut self) {
        self.preferred_map_variant = ::std::option::Option::None;
    }

    pub fn has_preferred_map_variant(&self) -> bool {
        self.preferred_map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_map_variant(&mut self, v: u32) {
        self.preferred_map_variant = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 4;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional bool turbo_mode = 5;

    pub fn turbo_mode(&self) -> bool {
        self.turbo_mode.unwrap_or(false)
    }

    pub fn clear_turbo_mode(&mut self) {
        self.turbo_mode = ::std::option::Option::None;
    }

    pub fn has_turbo_mode(&self) -> bool {
        self.turbo_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turbo_mode(&mut self, v: bool) {
        self.turbo_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgServerToGCCavernCrawlIsHeroActive| { &m.event_id },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActive| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgServerToGCCavernCrawlIsHeroActive| { &m.account_id },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActive| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preferred_map_variant",
            |m: &CMsgServerToGCCavernCrawlIsHeroActive| { &m.preferred_map_variant },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActive| { &mut m.preferred_map_variant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgServerToGCCavernCrawlIsHeroActive| { &m.hero_id },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActive| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "turbo_mode",
            |m: &CMsgServerToGCCavernCrawlIsHeroActive| { &m.turbo_mode },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActive| { &mut m.turbo_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCCavernCrawlIsHeroActive>(
            "CMsgServerToGCCavernCrawlIsHeroActive",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCCavernCrawlIsHeroActive {
    const NAME: &'static str = "CMsgServerToGCCavernCrawlIsHeroActive";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.preferred_map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.turbo_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.preferred_map_variant {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.turbo_mode {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.preferred_map_variant {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.turbo_mode {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCavernCrawlIsHeroActive {
        CMsgServerToGCCavernCrawlIsHeroActive::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.preferred_map_variant = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.turbo_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCavernCrawlIsHeroActive {
        static instance: CMsgServerToGCCavernCrawlIsHeroActive = CMsgServerToGCCavernCrawlIsHeroActive {
            event_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            preferred_map_variant: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            turbo_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCCavernCrawlIsHeroActive {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCCavernCrawlIsHeroActive").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCCavernCrawlIsHeroActive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCavernCrawlIsHeroActive {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCPlayerChallengeHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCPlayerChallengeHistory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.average_rank)
    pub average_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.challenge_records)
    pub challenge_records: ::std::vec::Vec<cmsg_server_to_gcplayer_challenge_history::PlayerChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCPlayerChallengeHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCPlayerChallengeHistory {
    fn default() -> &'a CMsgServerToGCPlayerChallengeHistory {
        <CMsgServerToGCPlayerChallengeHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCPlayerChallengeHistory {
    pub fn new() -> CMsgServerToGCPlayerChallengeHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 average_rank = 2;

    pub fn average_rank(&self) -> u32 {
        self.average_rank.unwrap_or(0)
    }

    pub fn clear_average_rank(&mut self) {
        self.average_rank = ::std::option::Option::None;
    }

    pub fn has_average_rank(&self) -> bool {
        self.average_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_rank(&mut self, v: u32) {
        self.average_rank = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgServerToGCPlayerChallengeHistory| { &m.match_id },
            |m: &mut CMsgServerToGCPlayerChallengeHistory| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_rank",
            |m: &CMsgServerToGCPlayerChallengeHistory| { &m.average_rank },
            |m: &mut CMsgServerToGCPlayerChallengeHistory| { &mut m.average_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "challenge_records",
            |m: &CMsgServerToGCPlayerChallengeHistory| { &m.challenge_records },
            |m: &mut CMsgServerToGCPlayerChallengeHistory| { &mut m.challenge_records },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCPlayerChallengeHistory>(
            "CMsgServerToGCPlayerChallengeHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCPlayerChallengeHistory {
    const NAME: &'static str = "CMsgServerToGCPlayerChallengeHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.average_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.challenge_records.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.average_rank {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.challenge_records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.average_rank {
            os.write_uint32(2, v)?;
        }
        for v in &self.challenge_records {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCPlayerChallengeHistory {
        CMsgServerToGCPlayerChallengeHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.average_rank = ::std::option::Option::None;
        self.challenge_records.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCPlayerChallengeHistory {
        static instance: CMsgServerToGCPlayerChallengeHistory = CMsgServerToGCPlayerChallengeHistory {
            match_id: ::std::option::Option::None,
            average_rank: ::std::option::Option::None,
            challenge_records: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCPlayerChallengeHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCPlayerChallengeHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCPlayerChallengeHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCPlayerChallengeHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCPlayerChallengeHistory`
pub mod cmsg_server_to_gcplayer_challenge_history {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerChallenge {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.challenge_type)
        pub challenge_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EPlayerChallengeHistoryType>>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.challenge_id1)
        pub challenge_id1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.challenge_id2)
        pub challenge_id2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.progress_value_start)
        pub progress_value_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.progress_value_end)
        pub progress_value_end: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.team_won)
        pub team_won: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.audit_data)
        pub audit_data: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.rank_completed)
        pub rank_completed: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerChallenge {
        fn default() -> &'a PlayerChallenge {
            <PlayerChallenge as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerChallenge {
        pub fn new() -> PlayerChallenge {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional .dota.EPlayerChallengeHistoryType challenge_type = 2;

        pub fn challenge_type(&self) -> super::super::dota_shared_enums::EPlayerChallengeHistoryType {
            match self.challenge_type {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid),
                None => super::super::dota_shared_enums::EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid,
            }
        }

        pub fn clear_challenge_type(&mut self) {
            self.challenge_type = ::std::option::Option::None;
        }

        pub fn has_challenge_type(&self) -> bool {
            self.challenge_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_type(&mut self, v: super::super::dota_shared_enums::EPlayerChallengeHistoryType) {
            self.challenge_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 challenge_id1 = 3;

        pub fn challenge_id1(&self) -> u32 {
            self.challenge_id1.unwrap_or(0)
        }

        pub fn clear_challenge_id1(&mut self) {
            self.challenge_id1 = ::std::option::Option::None;
        }

        pub fn has_challenge_id1(&self) -> bool {
            self.challenge_id1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_id1(&mut self, v: u32) {
            self.challenge_id1 = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_id2 = 4;

        pub fn challenge_id2(&self) -> u32 {
            self.challenge_id2.unwrap_or(0)
        }

        pub fn clear_challenge_id2(&mut self) {
            self.challenge_id2 = ::std::option::Option::None;
        }

        pub fn has_challenge_id2(&self) -> bool {
            self.challenge_id2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_id2(&mut self, v: u32) {
            self.challenge_id2 = ::std::option::Option::Some(v);
        }

        // optional uint32 progress_value_start = 5;

        pub fn progress_value_start(&self) -> u32 {
            self.progress_value_start.unwrap_or(0)
        }

        pub fn clear_progress_value_start(&mut self) {
            self.progress_value_start = ::std::option::Option::None;
        }

        pub fn has_progress_value_start(&self) -> bool {
            self.progress_value_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress_value_start(&mut self, v: u32) {
            self.progress_value_start = ::std::option::Option::Some(v);
        }

        // optional uint32 progress_value_end = 6;

        pub fn progress_value_end(&self) -> u32 {
            self.progress_value_end.unwrap_or(0)
        }

        pub fn clear_progress_value_end(&mut self) {
            self.progress_value_end = ::std::option::Option::None;
        }

        pub fn has_progress_value_end(&self) -> bool {
            self.progress_value_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress_value_end(&mut self, v: u32) {
            self.progress_value_end = ::std::option::Option::Some(v);
        }

        // optional bool team_won = 7;

        pub fn team_won(&self) -> bool {
            self.team_won.unwrap_or(false)
        }

        pub fn clear_team_won(&mut self) {
            self.team_won = ::std::option::Option::None;
        }

        pub fn has_team_won(&self) -> bool {
            self.team_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_won(&mut self, v: bool) {
            self.team_won = ::std::option::Option::Some(v);
        }

        // optional uint64 audit_data = 8;

        pub fn audit_data(&self) -> u64 {
            self.audit_data.unwrap_or(0)
        }

        pub fn clear_audit_data(&mut self) {
            self.audit_data = ::std::option::Option::None;
        }

        pub fn has_audit_data(&self) -> bool {
            self.audit_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_data(&mut self, v: u64) {
            self.audit_data = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 9;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 rank_completed = 10;

        pub fn rank_completed(&self) -> u32 {
            self.rank_completed.unwrap_or(0)
        }

        pub fn clear_rank_completed(&mut self) {
            self.rank_completed = ::std::option::Option::None;
        }

        pub fn has_rank_completed(&self) -> bool {
            self.rank_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_completed(&mut self, v: u32) {
            self.rank_completed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerChallenge| { &m.account_id },
                |m: &mut PlayerChallenge| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_type",
                |m: &PlayerChallenge| { &m.challenge_type },
                |m: &mut PlayerChallenge| { &mut m.challenge_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_id1",
                |m: &PlayerChallenge| { &m.challenge_id1 },
                |m: &mut PlayerChallenge| { &mut m.challenge_id1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_id2",
                |m: &PlayerChallenge| { &m.challenge_id2 },
                |m: &mut PlayerChallenge| { &mut m.challenge_id2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "progress_value_start",
                |m: &PlayerChallenge| { &m.progress_value_start },
                |m: &mut PlayerChallenge| { &mut m.progress_value_start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "progress_value_end",
                |m: &PlayerChallenge| { &m.progress_value_end },
                |m: &mut PlayerChallenge| { &mut m.progress_value_end },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_won",
                |m: &PlayerChallenge| { &m.team_won },
                |m: &mut PlayerChallenge| { &mut m.team_won },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "audit_data",
                |m: &PlayerChallenge| { &m.audit_data },
                |m: &mut PlayerChallenge| { &mut m.audit_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &PlayerChallenge| { &m.hero_id },
                |m: &mut PlayerChallenge| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_completed",
                |m: &PlayerChallenge| { &m.rank_completed },
                |m: &mut PlayerChallenge| { &mut m.rank_completed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerChallenge>(
                "CMsgServerToGCPlayerChallengeHistory.PlayerChallenge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerChallenge {
        const NAME: &'static str = "PlayerChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.challenge_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.challenge_id1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.challenge_id2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.progress_value_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.progress_value_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.team_won = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.rank_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.challenge_type {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.challenge_id1 {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.challenge_id2 {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.progress_value_start {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.progress_value_end {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.team_won {
                my_size += 1 + 1;
            }
            if let Some(v) = self.audit_data {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.rank_completed {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.challenge_type {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.challenge_id1 {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.challenge_id2 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.progress_value_start {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.progress_value_end {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.team_won {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.audit_data {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.rank_completed {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerChallenge {
            PlayerChallenge::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.challenge_type = ::std::option::Option::None;
            self.challenge_id1 = ::std::option::Option::None;
            self.challenge_id2 = ::std::option::Option::None;
            self.progress_value_start = ::std::option::Option::None;
            self.progress_value_end = ::std::option::Option::None;
            self.team_won = ::std::option::Option::None;
            self.audit_data = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.rank_completed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerChallenge {
            static instance: PlayerChallenge = PlayerChallenge {
                account_id: ::std::option::Option::None,
                challenge_type: ::std::option::Option::None,
                challenge_id1: ::std::option::Option::None,
                challenge_id2: ::std::option::Option::None,
                progress_value_start: ::std::option::Option::None,
                progress_value_end: ::std::option::Option::None,
                team_won: ::std::option::Option::None,
                audit_data: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                rank_completed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerChallenge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCPlayerChallengeHistory.PlayerChallenge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerChallenge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerChallenge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.result)
    pub result: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.potential_winnings)
    pub potential_winnings: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.map_results)
    pub map_results: ::std::vec::Vec<cmsg_server_to_gccavern_crawl_is_hero_active_response::MapResults>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.potential_plus_shard_winnings)
    pub potential_plus_shard_winnings: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    fn default() -> &'a CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        <CMsgServerToGCCavernCrawlIsHeroActiveResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    pub fn new() -> CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint32 map_variant = 5;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(0)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }

    // optional uint32 potential_winnings = 2;

    pub fn potential_winnings(&self) -> u32 {
        self.potential_winnings.unwrap_or(0)
    }

    pub fn clear_potential_winnings(&mut self) {
        self.potential_winnings = ::std::option::Option::None;
    }

    pub fn has_potential_winnings(&self) -> bool {
        self.potential_winnings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_potential_winnings(&mut self, v: u32) {
        self.potential_winnings = ::std::option::Option::Some(v);
    }

    // optional uint32 potential_plus_shard_winnings = 4;

    pub fn potential_plus_shard_winnings(&self) -> u32 {
        self.potential_plus_shard_winnings.unwrap_or(0)
    }

    pub fn clear_potential_plus_shard_winnings(&mut self) {
        self.potential_plus_shard_winnings = ::std::option::Option::None;
    }

    pub fn has_potential_plus_shard_winnings(&self) -> bool {
        self.potential_plus_shard_winnings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_potential_plus_shard_winnings(&mut self, v: u32) {
        self.potential_plus_shard_winnings = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &m.result },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_variant",
            |m: &CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &m.map_variant },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &mut m.map_variant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "potential_winnings",
            |m: &CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &m.potential_winnings },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &mut m.potential_winnings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "map_results",
            |m: &CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &m.map_results },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &mut m.map_results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "potential_plus_shard_winnings",
            |m: &CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &m.potential_plus_shard_winnings },
            |m: &mut CMsgServerToGCCavernCrawlIsHeroActiveResponse| { &mut m.potential_plus_shard_winnings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCCavernCrawlIsHeroActiveResponse>(
            "CMsgServerToGCCavernCrawlIsHeroActiveResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    const NAME: &'static str = "CMsgServerToGCCavernCrawlIsHeroActiveResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.potential_winnings = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.map_results.push(is.read_message()?);
                },
                32 => {
                    self.potential_plus_shard_winnings = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        if let Some(v) = self.map_variant {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.potential_winnings {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.map_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.potential_plus_shard_winnings {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.map_variant {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.potential_winnings {
            os.write_uint32(2, v)?;
        }
        for v in &self.map_results {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.potential_plus_shard_winnings {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        CMsgServerToGCCavernCrawlIsHeroActiveResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.map_variant = ::std::option::Option::None;
        self.potential_winnings = ::std::option::Option::None;
        self.map_results.clear();
        self.potential_plus_shard_winnings = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        static instance: CMsgServerToGCCavernCrawlIsHeroActiveResponse = CMsgServerToGCCavernCrawlIsHeroActiveResponse {
            result: ::std::option::Option::None,
            map_variant: ::std::option::Option::None,
            potential_winnings: ::std::option::Option::None,
            map_results: ::std::vec::Vec::new(),
            potential_plus_shard_winnings: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCCavernCrawlIsHeroActiveResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCCavernCrawlIsHeroActiveResponse`
pub mod cmsg_server_to_gccavern_crawl_is_hero_active_response {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MapResults {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults.path_id_completed)
        pub path_id_completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults.room_id_claimed)
        pub room_id_claimed: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MapResults {
        fn default() -> &'a MapResults {
            <MapResults as ::protobuf::Message>::default_instance()
        }
    }

    impl MapResults {
        pub fn new() -> MapResults {
            ::std::default::Default::default()
        }

        // optional uint32 path_id_completed = 1;

        pub fn path_id_completed(&self) -> u32 {
            self.path_id_completed.unwrap_or(0)
        }

        pub fn clear_path_id_completed(&mut self) {
            self.path_id_completed = ::std::option::Option::None;
        }

        pub fn has_path_id_completed(&self) -> bool {
            self.path_id_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path_id_completed(&mut self, v: u32) {
            self.path_id_completed = ::std::option::Option::Some(v);
        }

        // optional uint32 room_id_claimed = 2;

        pub fn room_id_claimed(&self) -> u32 {
            self.room_id_claimed.unwrap_or(0)
        }

        pub fn clear_room_id_claimed(&mut self) {
            self.room_id_claimed = ::std::option::Option::None;
        }

        pub fn has_room_id_claimed(&self) -> bool {
            self.room_id_claimed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_room_id_claimed(&mut self, v: u32) {
            self.room_id_claimed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "path_id_completed",
                |m: &MapResults| { &m.path_id_completed },
                |m: &mut MapResults| { &mut m.path_id_completed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "room_id_claimed",
                |m: &MapResults| { &m.room_id_claimed },
                |m: &mut MapResults| { &mut m.room_id_claimed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapResults>(
                "CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MapResults {
        const NAME: &'static str = "MapResults";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.path_id_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.room_id_claimed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.path_id_completed {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.room_id_claimed {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.path_id_completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.room_id_claimed {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MapResults {
            MapResults::new()
        }

        fn clear(&mut self) {
            self.path_id_completed = ::std::option::Option::None;
            self.room_id_claimed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MapResults {
            static instance: MapResults = MapResults {
                path_id_completed: ::std::option::Option::None,
                room_id_claimed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MapResults {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MapResults {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MapResults {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCtoServerTensorflowInstance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCtoServerTensorflowInstance {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCtoServerTensorflowInstance.server_instance)
    pub server_instance: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCtoServerTensorflowInstance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCtoServerTensorflowInstance {
    fn default() -> &'a CMsgGCtoServerTensorflowInstance {
        <CMsgGCtoServerTensorflowInstance as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCtoServerTensorflowInstance {
    pub fn new() -> CMsgGCtoServerTensorflowInstance {
        ::std::default::Default::default()
    }

    // optional uint32 server_instance = 1;

    pub fn server_instance(&self) -> u32 {
        self.server_instance.unwrap_or(0)
    }

    pub fn clear_server_instance(&mut self) {
        self.server_instance = ::std::option::Option::None;
    }

    pub fn has_server_instance(&self) -> bool {
        self.server_instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_instance(&mut self, v: u32) {
        self.server_instance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_instance",
            |m: &CMsgGCtoServerTensorflowInstance| { &m.server_instance },
            |m: &mut CMsgGCtoServerTensorflowInstance| { &mut m.server_instance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCtoServerTensorflowInstance>(
            "CMsgGCtoServerTensorflowInstance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCtoServerTensorflowInstance {
    const NAME: &'static str = "CMsgGCtoServerTensorflowInstance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_instance = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_instance {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_instance {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCtoServerTensorflowInstance {
        CMsgGCtoServerTensorflowInstance::new()
    }

    fn clear(&mut self) {
        self.server_instance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCtoServerTensorflowInstance {
        static instance: CMsgGCtoServerTensorflowInstance = CMsgGCtoServerTensorflowInstance {
            server_instance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCtoServerTensorflowInstance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCtoServerTensorflowInstance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCtoServerTensorflowInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCtoServerTensorflowInstance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDetailedGameStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDetailedGameStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.minutes)
    pub minutes: ::std::vec::Vec<cmsg_detailed_game_stats::MinuteEntry>,
    // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.player_info)
    pub player_info: ::std::vec::Vec<cmsg_detailed_game_stats::PlayerInfo>,
    // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.game_stats)
    pub game_stats: ::protobuf::MessageField<cmsg_detailed_game_stats::GameStats>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDetailedGameStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDetailedGameStats {
    fn default() -> &'a CMsgDetailedGameStats {
        <CMsgDetailedGameStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDetailedGameStats {
    pub fn new() -> CMsgDetailedGameStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "minutes",
            |m: &CMsgDetailedGameStats| { &m.minutes },
            |m: &mut CMsgDetailedGameStats| { &mut m.minutes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_info",
            |m: &CMsgDetailedGameStats| { &m.player_info },
            |m: &mut CMsgDetailedGameStats| { &mut m.player_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_detailed_game_stats::GameStats>(
            "game_stats",
            |m: &CMsgDetailedGameStats| { &m.game_stats },
            |m: &mut CMsgDetailedGameStats| { &mut m.game_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDetailedGameStats>(
            "CMsgDetailedGameStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDetailedGameStats {
    const NAME: &'static str = "CMsgDetailedGameStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.minutes.push(is.read_message()?);
                },
                18 => {
                    self.player_info.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.minutes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.player_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.game_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.minutes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.player_info {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.game_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDetailedGameStats {
        CMsgDetailedGameStats::new()
    }

    fn clear(&mut self) {
        self.minutes.clear();
        self.player_info.clear();
        self.game_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDetailedGameStats {
        static instance: CMsgDetailedGameStats = CMsgDetailedGameStats {
            minutes: ::std::vec::Vec::new(),
            player_info: ::std::vec::Vec::new(),
            game_stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDetailedGameStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDetailedGameStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDetailedGameStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDetailedGameStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDetailedGameStats`
pub mod cmsg_detailed_game_stats {
    // @@protoc_insertion_point(message:dota.CMsgDetailedGameStats.PlayerStatEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerStatEntry {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_earned_gold)
        pub total_earned_gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_networth)
        pub total_networth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_dps)
        pub total_dps: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.average_dps)
        pub average_dps: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.ability_damage_output)
        pub ability_damage_output: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.base_health)
        pub base_health: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_health)
        pub total_health: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_mana)
        pub total_mana: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.base_physical_damage_reduction_pct)
        pub base_physical_damage_reduction_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_physical_damage_reduction_pct)
        pub total_physical_damage_reduction_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.base_ability_damage_reduction_pct)
        pub base_ability_damage_reduction_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_ability_damage_reduction_pct)
        pub total_ability_damage_reduction_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.ability_damage_block)
        pub ability_damage_block: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.physical_damage_block)
        pub physical_damage_block: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.mana_regen)
        pub mana_regen: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.health_regen)
        pub health_regen: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.physical_magic_dmg_pct)
        pub physical_magic_dmg_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.assists)
        pub assists: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.gold_from_kills)
        pub gold_from_kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.gold_from_creeps)
        pub gold_from_creeps: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.gold_shared)
        pub gold_shared: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.xp_from_kills)
        pub xp_from_kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.xp_from_creeps)
        pub xp_from_creeps: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_xp)
        pub total_xp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.ability_casts)
        pub ability_casts: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.item_casts)
        pub item_casts: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.total_time_stunned)
        pub total_time_stunned: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerStatEntry.item_count)
        pub item_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDetailedGameStats.PlayerStatEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerStatEntry {
        fn default() -> &'a PlayerStatEntry {
            <PlayerStatEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerStatEntry {
        pub fn new() -> PlayerStatEntry {
            ::std::default::Default::default()
        }

        // optional uint32 total_earned_gold = 1;

        pub fn total_earned_gold(&self) -> u32 {
            self.total_earned_gold.unwrap_or(0)
        }

        pub fn clear_total_earned_gold(&mut self) {
            self.total_earned_gold = ::std::option::Option::None;
        }

        pub fn has_total_earned_gold(&self) -> bool {
            self.total_earned_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_earned_gold(&mut self, v: u32) {
            self.total_earned_gold = ::std::option::Option::Some(v);
        }

        // optional uint32 total_networth = 2;

        pub fn total_networth(&self) -> u32 {
            self.total_networth.unwrap_or(0)
        }

        pub fn clear_total_networth(&mut self) {
            self.total_networth = ::std::option::Option::None;
        }

        pub fn has_total_networth(&self) -> bool {
            self.total_networth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_networth(&mut self, v: u32) {
            self.total_networth = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 3;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 total_dps = 4;

        pub fn total_dps(&self) -> u32 {
            self.total_dps.unwrap_or(0)
        }

        pub fn clear_total_dps(&mut self) {
            self.total_dps = ::std::option::Option::None;
        }

        pub fn has_total_dps(&self) -> bool {
            self.total_dps.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_dps(&mut self, v: u32) {
            self.total_dps = ::std::option::Option::Some(v);
        }

        // optional uint32 average_dps = 5;

        pub fn average_dps(&self) -> u32 {
            self.average_dps.unwrap_or(0)
        }

        pub fn clear_average_dps(&mut self) {
            self.average_dps = ::std::option::Option::None;
        }

        pub fn has_average_dps(&self) -> bool {
            self.average_dps.is_some()
        }

        // Param is passed by value, moved
        pub fn set_average_dps(&mut self, v: u32) {
            self.average_dps = ::std::option::Option::Some(v);
        }

        // optional uint32 ability_damage_output = 6;

        pub fn ability_damage_output(&self) -> u32 {
            self.ability_damage_output.unwrap_or(0)
        }

        pub fn clear_ability_damage_output(&mut self) {
            self.ability_damage_output = ::std::option::Option::None;
        }

        pub fn has_ability_damage_output(&self) -> bool {
            self.ability_damage_output.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ability_damage_output(&mut self, v: u32) {
            self.ability_damage_output = ::std::option::Option::Some(v);
        }

        // optional uint32 base_health = 7;

        pub fn base_health(&self) -> u32 {
            self.base_health.unwrap_or(0)
        }

        pub fn clear_base_health(&mut self) {
            self.base_health = ::std::option::Option::None;
        }

        pub fn has_base_health(&self) -> bool {
            self.base_health.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_health(&mut self, v: u32) {
            self.base_health = ::std::option::Option::Some(v);
        }

        // optional uint32 total_health = 8;

        pub fn total_health(&self) -> u32 {
            self.total_health.unwrap_or(0)
        }

        pub fn clear_total_health(&mut self) {
            self.total_health = ::std::option::Option::None;
        }

        pub fn has_total_health(&self) -> bool {
            self.total_health.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_health(&mut self, v: u32) {
            self.total_health = ::std::option::Option::Some(v);
        }

        // optional uint32 total_mana = 9;

        pub fn total_mana(&self) -> u32 {
            self.total_mana.unwrap_or(0)
        }

        pub fn clear_total_mana(&mut self) {
            self.total_mana = ::std::option::Option::None;
        }

        pub fn has_total_mana(&self) -> bool {
            self.total_mana.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_mana(&mut self, v: u32) {
            self.total_mana = ::std::option::Option::Some(v);
        }

        // optional float base_physical_damage_reduction_pct = 10;

        pub fn base_physical_damage_reduction_pct(&self) -> f32 {
            self.base_physical_damage_reduction_pct.unwrap_or(0.)
        }

        pub fn clear_base_physical_damage_reduction_pct(&mut self) {
            self.base_physical_damage_reduction_pct = ::std::option::Option::None;
        }

        pub fn has_base_physical_damage_reduction_pct(&self) -> bool {
            self.base_physical_damage_reduction_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_physical_damage_reduction_pct(&mut self, v: f32) {
            self.base_physical_damage_reduction_pct = ::std::option::Option::Some(v);
        }

        // optional float total_physical_damage_reduction_pct = 11;

        pub fn total_physical_damage_reduction_pct(&self) -> f32 {
            self.total_physical_damage_reduction_pct.unwrap_or(0.)
        }

        pub fn clear_total_physical_damage_reduction_pct(&mut self) {
            self.total_physical_damage_reduction_pct = ::std::option::Option::None;
        }

        pub fn has_total_physical_damage_reduction_pct(&self) -> bool {
            self.total_physical_damage_reduction_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_physical_damage_reduction_pct(&mut self, v: f32) {
            self.total_physical_damage_reduction_pct = ::std::option::Option::Some(v);
        }

        // optional float base_ability_damage_reduction_pct = 12;

        pub fn base_ability_damage_reduction_pct(&self) -> f32 {
            self.base_ability_damage_reduction_pct.unwrap_or(0.)
        }

        pub fn clear_base_ability_damage_reduction_pct(&mut self) {
            self.base_ability_damage_reduction_pct = ::std::option::Option::None;
        }

        pub fn has_base_ability_damage_reduction_pct(&self) -> bool {
            self.base_ability_damage_reduction_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_ability_damage_reduction_pct(&mut self, v: f32) {
            self.base_ability_damage_reduction_pct = ::std::option::Option::Some(v);
        }

        // optional float total_ability_damage_reduction_pct = 13;

        pub fn total_ability_damage_reduction_pct(&self) -> f32 {
            self.total_ability_damage_reduction_pct.unwrap_or(0.)
        }

        pub fn clear_total_ability_damage_reduction_pct(&mut self) {
            self.total_ability_damage_reduction_pct = ::std::option::Option::None;
        }

        pub fn has_total_ability_damage_reduction_pct(&self) -> bool {
            self.total_ability_damage_reduction_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_ability_damage_reduction_pct(&mut self, v: f32) {
            self.total_ability_damage_reduction_pct = ::std::option::Option::Some(v);
        }

        // optional float ability_damage_block = 14;

        pub fn ability_damage_block(&self) -> f32 {
            self.ability_damage_block.unwrap_or(0.)
        }

        pub fn clear_ability_damage_block(&mut self) {
            self.ability_damage_block = ::std::option::Option::None;
        }

        pub fn has_ability_damage_block(&self) -> bool {
            self.ability_damage_block.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ability_damage_block(&mut self, v: f32) {
            self.ability_damage_block = ::std::option::Option::Some(v);
        }

        // optional float physical_damage_block = 15;

        pub fn physical_damage_block(&self) -> f32 {
            self.physical_damage_block.unwrap_or(0.)
        }

        pub fn clear_physical_damage_block(&mut self) {
            self.physical_damage_block = ::std::option::Option::None;
        }

        pub fn has_physical_damage_block(&self) -> bool {
            self.physical_damage_block.is_some()
        }

        // Param is passed by value, moved
        pub fn set_physical_damage_block(&mut self, v: f32) {
            self.physical_damage_block = ::std::option::Option::Some(v);
        }

        // optional uint32 mana_regen = 16;

        pub fn mana_regen(&self) -> u32 {
            self.mana_regen.unwrap_or(0)
        }

        pub fn clear_mana_regen(&mut self) {
            self.mana_regen = ::std::option::Option::None;
        }

        pub fn has_mana_regen(&self) -> bool {
            self.mana_regen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mana_regen(&mut self, v: u32) {
            self.mana_regen = ::std::option::Option::Some(v);
        }

        // optional uint32 health_regen = 17;

        pub fn health_regen(&self) -> u32 {
            self.health_regen.unwrap_or(0)
        }

        pub fn clear_health_regen(&mut self) {
            self.health_regen = ::std::option::Option::None;
        }

        pub fn has_health_regen(&self) -> bool {
            self.health_regen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_health_regen(&mut self, v: u32) {
            self.health_regen = ::std::option::Option::Some(v);
        }

        // optional float physical_magic_dmg_pct = 18;

        pub fn physical_magic_dmg_pct(&self) -> f32 {
            self.physical_magic_dmg_pct.unwrap_or(0.)
        }

        pub fn clear_physical_magic_dmg_pct(&mut self) {
            self.physical_magic_dmg_pct = ::std::option::Option::None;
        }

        pub fn has_physical_magic_dmg_pct(&self) -> bool {
            self.physical_magic_dmg_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_physical_magic_dmg_pct(&mut self, v: f32) {
            self.physical_magic_dmg_pct = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 19;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 20;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 21;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_from_kills = 22;

        pub fn gold_from_kills(&self) -> u32 {
            self.gold_from_kills.unwrap_or(0)
        }

        pub fn clear_gold_from_kills(&mut self) {
            self.gold_from_kills = ::std::option::Option::None;
        }

        pub fn has_gold_from_kills(&self) -> bool {
            self.gold_from_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_from_kills(&mut self, v: u32) {
            self.gold_from_kills = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_from_creeps = 23;

        pub fn gold_from_creeps(&self) -> u32 {
            self.gold_from_creeps.unwrap_or(0)
        }

        pub fn clear_gold_from_creeps(&mut self) {
            self.gold_from_creeps = ::std::option::Option::None;
        }

        pub fn has_gold_from_creeps(&self) -> bool {
            self.gold_from_creeps.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_from_creeps(&mut self, v: u32) {
            self.gold_from_creeps = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_shared = 24;

        pub fn gold_shared(&self) -> u32 {
            self.gold_shared.unwrap_or(0)
        }

        pub fn clear_gold_shared(&mut self) {
            self.gold_shared = ::std::option::Option::None;
        }

        pub fn has_gold_shared(&self) -> bool {
            self.gold_shared.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_shared(&mut self, v: u32) {
            self.gold_shared = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_from_kills = 25;

        pub fn xp_from_kills(&self) -> u32 {
            self.xp_from_kills.unwrap_or(0)
        }

        pub fn clear_xp_from_kills(&mut self) {
            self.xp_from_kills = ::std::option::Option::None;
        }

        pub fn has_xp_from_kills(&self) -> bool {
            self.xp_from_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_from_kills(&mut self, v: u32) {
            self.xp_from_kills = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_from_creeps = 26;

        pub fn xp_from_creeps(&self) -> u32 {
            self.xp_from_creeps.unwrap_or(0)
        }

        pub fn clear_xp_from_creeps(&mut self) {
            self.xp_from_creeps = ::std::option::Option::None;
        }

        pub fn has_xp_from_creeps(&self) -> bool {
            self.xp_from_creeps.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_from_creeps(&mut self, v: u32) {
            self.xp_from_creeps = ::std::option::Option::Some(v);
        }

        // optional uint32 total_xp = 27;

        pub fn total_xp(&self) -> u32 {
            self.total_xp.unwrap_or(0)
        }

        pub fn clear_total_xp(&mut self) {
            self.total_xp = ::std::option::Option::None;
        }

        pub fn has_total_xp(&self) -> bool {
            self.total_xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_xp(&mut self, v: u32) {
            self.total_xp = ::std::option::Option::Some(v);
        }

        // optional uint32 ability_casts = 28;

        pub fn ability_casts(&self) -> u32 {
            self.ability_casts.unwrap_or(0)
        }

        pub fn clear_ability_casts(&mut self) {
            self.ability_casts = ::std::option::Option::None;
        }

        pub fn has_ability_casts(&self) -> bool {
            self.ability_casts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ability_casts(&mut self, v: u32) {
            self.ability_casts = ::std::option::Option::Some(v);
        }

        // optional uint32 item_casts = 29;

        pub fn item_casts(&self) -> u32 {
            self.item_casts.unwrap_or(0)
        }

        pub fn clear_item_casts(&mut self) {
            self.item_casts = ::std::option::Option::None;
        }

        pub fn has_item_casts(&self) -> bool {
            self.item_casts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_casts(&mut self, v: u32) {
            self.item_casts = ::std::option::Option::Some(v);
        }

        // optional float total_time_stunned = 30;

        pub fn total_time_stunned(&self) -> f32 {
            self.total_time_stunned.unwrap_or(0.)
        }

        pub fn clear_total_time_stunned(&mut self) {
            self.total_time_stunned = ::std::option::Option::None;
        }

        pub fn has_total_time_stunned(&self) -> bool {
            self.total_time_stunned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_time_stunned(&mut self, v: f32) {
            self.total_time_stunned = ::std::option::Option::Some(v);
        }

        // optional uint32 item_count = 31;

        pub fn item_count(&self) -> u32 {
            self.item_count.unwrap_or(0)
        }

        pub fn clear_item_count(&mut self) {
            self.item_count = ::std::option::Option::None;
        }

        pub fn has_item_count(&self) -> bool {
            self.item_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_count(&mut self, v: u32) {
            self.item_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(31);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_earned_gold",
                |m: &PlayerStatEntry| { &m.total_earned_gold },
                |m: &mut PlayerStatEntry| { &mut m.total_earned_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_networth",
                |m: &PlayerStatEntry| { &m.total_networth },
                |m: &mut PlayerStatEntry| { &mut m.total_networth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &PlayerStatEntry| { &m.level },
                |m: &mut PlayerStatEntry| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_dps",
                |m: &PlayerStatEntry| { &m.total_dps },
                |m: &mut PlayerStatEntry| { &mut m.total_dps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "average_dps",
                |m: &PlayerStatEntry| { &m.average_dps },
                |m: &mut PlayerStatEntry| { &mut m.average_dps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ability_damage_output",
                |m: &PlayerStatEntry| { &m.ability_damage_output },
                |m: &mut PlayerStatEntry| { &mut m.ability_damage_output },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_health",
                |m: &PlayerStatEntry| { &m.base_health },
                |m: &mut PlayerStatEntry| { &mut m.base_health },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_health",
                |m: &PlayerStatEntry| { &m.total_health },
                |m: &mut PlayerStatEntry| { &mut m.total_health },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_mana",
                |m: &PlayerStatEntry| { &m.total_mana },
                |m: &mut PlayerStatEntry| { &mut m.total_mana },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_physical_damage_reduction_pct",
                |m: &PlayerStatEntry| { &m.base_physical_damage_reduction_pct },
                |m: &mut PlayerStatEntry| { &mut m.base_physical_damage_reduction_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_physical_damage_reduction_pct",
                |m: &PlayerStatEntry| { &m.total_physical_damage_reduction_pct },
                |m: &mut PlayerStatEntry| { &mut m.total_physical_damage_reduction_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_ability_damage_reduction_pct",
                |m: &PlayerStatEntry| { &m.base_ability_damage_reduction_pct },
                |m: &mut PlayerStatEntry| { &mut m.base_ability_damage_reduction_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_ability_damage_reduction_pct",
                |m: &PlayerStatEntry| { &m.total_ability_damage_reduction_pct },
                |m: &mut PlayerStatEntry| { &mut m.total_ability_damage_reduction_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ability_damage_block",
                |m: &PlayerStatEntry| { &m.ability_damage_block },
                |m: &mut PlayerStatEntry| { &mut m.ability_damage_block },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "physical_damage_block",
                |m: &PlayerStatEntry| { &m.physical_damage_block },
                |m: &mut PlayerStatEntry| { &mut m.physical_damage_block },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mana_regen",
                |m: &PlayerStatEntry| { &m.mana_regen },
                |m: &mut PlayerStatEntry| { &mut m.mana_regen },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "health_regen",
                |m: &PlayerStatEntry| { &m.health_regen },
                |m: &mut PlayerStatEntry| { &mut m.health_regen },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "physical_magic_dmg_pct",
                |m: &PlayerStatEntry| { &m.physical_magic_dmg_pct },
                |m: &mut PlayerStatEntry| { &mut m.physical_magic_dmg_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &PlayerStatEntry| { &m.kills },
                |m: &mut PlayerStatEntry| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &PlayerStatEntry| { &m.deaths },
                |m: &mut PlayerStatEntry| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists",
                |m: &PlayerStatEntry| { &m.assists },
                |m: &mut PlayerStatEntry| { &mut m.assists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_from_kills",
                |m: &PlayerStatEntry| { &m.gold_from_kills },
                |m: &mut PlayerStatEntry| { &mut m.gold_from_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_from_creeps",
                |m: &PlayerStatEntry| { &m.gold_from_creeps },
                |m: &mut PlayerStatEntry| { &mut m.gold_from_creeps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_shared",
                |m: &PlayerStatEntry| { &m.gold_shared },
                |m: &mut PlayerStatEntry| { &mut m.gold_shared },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xp_from_kills",
                |m: &PlayerStatEntry| { &m.xp_from_kills },
                |m: &mut PlayerStatEntry| { &mut m.xp_from_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xp_from_creeps",
                |m: &PlayerStatEntry| { &m.xp_from_creeps },
                |m: &mut PlayerStatEntry| { &mut m.xp_from_creeps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_xp",
                |m: &PlayerStatEntry| { &m.total_xp },
                |m: &mut PlayerStatEntry| { &mut m.total_xp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ability_casts",
                |m: &PlayerStatEntry| { &m.ability_casts },
                |m: &mut PlayerStatEntry| { &mut m.ability_casts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_casts",
                |m: &PlayerStatEntry| { &m.item_casts },
                |m: &mut PlayerStatEntry| { &mut m.item_casts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_time_stunned",
                |m: &PlayerStatEntry| { &m.total_time_stunned },
                |m: &mut PlayerStatEntry| { &mut m.total_time_stunned },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_count",
                |m: &PlayerStatEntry| { &m.item_count },
                |m: &mut PlayerStatEntry| { &mut m.item_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerStatEntry>(
                "CMsgDetailedGameStats.PlayerStatEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerStatEntry {
        const NAME: &'static str = "PlayerStatEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.total_earned_gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_networth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.total_dps = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.average_dps = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.ability_damage_output = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.base_health = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.total_health = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.total_mana = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    85 => {
                        self.base_physical_damage_reduction_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    93 => {
                        self.total_physical_damage_reduction_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    101 => {
                        self.base_ability_damage_reduction_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    109 => {
                        self.total_ability_damage_reduction_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    117 => {
                        self.ability_damage_block = ::std::option::Option::Some(is.read_float()?);
                    },
                    125 => {
                        self.physical_damage_block = ::std::option::Option::Some(is.read_float()?);
                    },
                    128 => {
                        self.mana_regen = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.health_regen = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    149 => {
                        self.physical_magic_dmg_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    152 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.gold_from_kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.gold_from_creeps = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    192 => {
                        self.gold_shared = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.xp_from_kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    208 => {
                        self.xp_from_creeps = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    216 => {
                        self.total_xp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    224 => {
                        self.ability_casts = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    232 => {
                        self.item_casts = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    245 => {
                        self.total_time_stunned = ::std::option::Option::Some(is.read_float()?);
                    },
                    248 => {
                        self.item_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_earned_gold {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_networth {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.total_dps {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.average_dps {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.ability_damage_output {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.base_health {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.total_health {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.total_mana {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.base_physical_damage_reduction_pct {
                my_size += 1 + 4;
            }
            if let Some(v) = self.total_physical_damage_reduction_pct {
                my_size += 1 + 4;
            }
            if let Some(v) = self.base_ability_damage_reduction_pct {
                my_size += 1 + 4;
            }
            if let Some(v) = self.total_ability_damage_reduction_pct {
                my_size += 1 + 4;
            }
            if let Some(v) = self.ability_damage_block {
                my_size += 1 + 4;
            }
            if let Some(v) = self.physical_damage_block {
                my_size += 1 + 4;
            }
            if let Some(v) = self.mana_regen {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.health_regen {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.physical_magic_dmg_pct {
                my_size += 2 + 4;
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.assists {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.gold_from_kills {
                my_size += ::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.gold_from_creeps {
                my_size += ::protobuf::rt::uint32_size(23, v);
            }
            if let Some(v) = self.gold_shared {
                my_size += ::protobuf::rt::uint32_size(24, v);
            }
            if let Some(v) = self.xp_from_kills {
                my_size += ::protobuf::rt::uint32_size(25, v);
            }
            if let Some(v) = self.xp_from_creeps {
                my_size += ::protobuf::rt::uint32_size(26, v);
            }
            if let Some(v) = self.total_xp {
                my_size += ::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.ability_casts {
                my_size += ::protobuf::rt::uint32_size(28, v);
            }
            if let Some(v) = self.item_casts {
                my_size += ::protobuf::rt::uint32_size(29, v);
            }
            if let Some(v) = self.total_time_stunned {
                my_size += 2 + 4;
            }
            if let Some(v) = self.item_count {
                my_size += ::protobuf::rt::uint32_size(31, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.total_earned_gold {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_networth {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.total_dps {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.average_dps {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.ability_damage_output {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.base_health {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.total_health {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.total_mana {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.base_physical_damage_reduction_pct {
                os.write_float(10, v)?;
            }
            if let Some(v) = self.total_physical_damage_reduction_pct {
                os.write_float(11, v)?;
            }
            if let Some(v) = self.base_ability_damage_reduction_pct {
                os.write_float(12, v)?;
            }
            if let Some(v) = self.total_ability_damage_reduction_pct {
                os.write_float(13, v)?;
            }
            if let Some(v) = self.ability_damage_block {
                os.write_float(14, v)?;
            }
            if let Some(v) = self.physical_damage_block {
                os.write_float(15, v)?;
            }
            if let Some(v) = self.mana_regen {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.health_regen {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.physical_magic_dmg_pct {
                os.write_float(18, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.gold_from_kills {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.gold_from_creeps {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.gold_shared {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.xp_from_kills {
                os.write_uint32(25, v)?;
            }
            if let Some(v) = self.xp_from_creeps {
                os.write_uint32(26, v)?;
            }
            if let Some(v) = self.total_xp {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.ability_casts {
                os.write_uint32(28, v)?;
            }
            if let Some(v) = self.item_casts {
                os.write_uint32(29, v)?;
            }
            if let Some(v) = self.total_time_stunned {
                os.write_float(30, v)?;
            }
            if let Some(v) = self.item_count {
                os.write_uint32(31, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerStatEntry {
            PlayerStatEntry::new()
        }

        fn clear(&mut self) {
            self.total_earned_gold = ::std::option::Option::None;
            self.total_networth = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.total_dps = ::std::option::Option::None;
            self.average_dps = ::std::option::Option::None;
            self.ability_damage_output = ::std::option::Option::None;
            self.base_health = ::std::option::Option::None;
            self.total_health = ::std::option::Option::None;
            self.total_mana = ::std::option::Option::None;
            self.base_physical_damage_reduction_pct = ::std::option::Option::None;
            self.total_physical_damage_reduction_pct = ::std::option::Option::None;
            self.base_ability_damage_reduction_pct = ::std::option::Option::None;
            self.total_ability_damage_reduction_pct = ::std::option::Option::None;
            self.ability_damage_block = ::std::option::Option::None;
            self.physical_damage_block = ::std::option::Option::None;
            self.mana_regen = ::std::option::Option::None;
            self.health_regen = ::std::option::Option::None;
            self.physical_magic_dmg_pct = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.gold_from_kills = ::std::option::Option::None;
            self.gold_from_creeps = ::std::option::Option::None;
            self.gold_shared = ::std::option::Option::None;
            self.xp_from_kills = ::std::option::Option::None;
            self.xp_from_creeps = ::std::option::Option::None;
            self.total_xp = ::std::option::Option::None;
            self.ability_casts = ::std::option::Option::None;
            self.item_casts = ::std::option::Option::None;
            self.total_time_stunned = ::std::option::Option::None;
            self.item_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerStatEntry {
            static instance: PlayerStatEntry = PlayerStatEntry {
                total_earned_gold: ::std::option::Option::None,
                total_networth: ::std::option::Option::None,
                level: ::std::option::Option::None,
                total_dps: ::std::option::Option::None,
                average_dps: ::std::option::Option::None,
                ability_damage_output: ::std::option::Option::None,
                base_health: ::std::option::Option::None,
                total_health: ::std::option::Option::None,
                total_mana: ::std::option::Option::None,
                base_physical_damage_reduction_pct: ::std::option::Option::None,
                total_physical_damage_reduction_pct: ::std::option::Option::None,
                base_ability_damage_reduction_pct: ::std::option::Option::None,
                total_ability_damage_reduction_pct: ::std::option::Option::None,
                ability_damage_block: ::std::option::Option::None,
                physical_damage_block: ::std::option::Option::None,
                mana_regen: ::std::option::Option::None,
                health_regen: ::std::option::Option::None,
                physical_magic_dmg_pct: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                gold_from_kills: ::std::option::Option::None,
                gold_from_creeps: ::std::option::Option::None,
                gold_shared: ::std::option::Option::None,
                xp_from_kills: ::std::option::Option::None,
                xp_from_creeps: ::std::option::Option::None,
                total_xp: ::std::option::Option::None,
                ability_casts: ::std::option::Option::None,
                item_casts: ::std::option::Option::None,
                total_time_stunned: ::std::option::Option::None,
                item_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerStatEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDetailedGameStats.PlayerStatEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerStatEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerStatEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDetailedGameStats.GameStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GameStats {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.GameStats.tower_death_time_t1)
        pub tower_death_time_t1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.GameStats.tower_death_time_t2)
        pub tower_death_time_t2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.GameStats.tower_death_time_t3)
        pub tower_death_time_t3: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDetailedGameStats.GameStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GameStats {
        fn default() -> &'a GameStats {
            <GameStats as ::protobuf::Message>::default_instance()
        }
    }

    impl GameStats {
        pub fn new() -> GameStats {
            ::std::default::Default::default()
        }

        // optional uint32 tower_death_time_t1 = 1;

        pub fn tower_death_time_t1(&self) -> u32 {
            self.tower_death_time_t1.unwrap_or(0)
        }

        pub fn clear_tower_death_time_t1(&mut self) {
            self.tower_death_time_t1 = ::std::option::Option::None;
        }

        pub fn has_tower_death_time_t1(&self) -> bool {
            self.tower_death_time_t1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_death_time_t1(&mut self, v: u32) {
            self.tower_death_time_t1 = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_death_time_t2 = 2;

        pub fn tower_death_time_t2(&self) -> u32 {
            self.tower_death_time_t2.unwrap_or(0)
        }

        pub fn clear_tower_death_time_t2(&mut self) {
            self.tower_death_time_t2 = ::std::option::Option::None;
        }

        pub fn has_tower_death_time_t2(&self) -> bool {
            self.tower_death_time_t2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_death_time_t2(&mut self, v: u32) {
            self.tower_death_time_t2 = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_death_time_t3 = 3;

        pub fn tower_death_time_t3(&self) -> u32 {
            self.tower_death_time_t3.unwrap_or(0)
        }

        pub fn clear_tower_death_time_t3(&mut self) {
            self.tower_death_time_t3 = ::std::option::Option::None;
        }

        pub fn has_tower_death_time_t3(&self) -> bool {
            self.tower_death_time_t3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_death_time_t3(&mut self, v: u32) {
            self.tower_death_time_t3 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_death_time_t1",
                |m: &GameStats| { &m.tower_death_time_t1 },
                |m: &mut GameStats| { &mut m.tower_death_time_t1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_death_time_t2",
                |m: &GameStats| { &m.tower_death_time_t2 },
                |m: &mut GameStats| { &mut m.tower_death_time_t2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_death_time_t3",
                |m: &GameStats| { &m.tower_death_time_t3 },
                |m: &mut GameStats| { &mut m.tower_death_time_t3 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameStats>(
                "CMsgDetailedGameStats.GameStats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GameStats {
        const NAME: &'static str = "GameStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tower_death_time_t1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.tower_death_time_t2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tower_death_time_t3 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tower_death_time_t1 {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.tower_death_time_t2 {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tower_death_time_t3 {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tower_death_time_t1 {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.tower_death_time_t2 {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tower_death_time_t3 {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GameStats {
            GameStats::new()
        }

        fn clear(&mut self) {
            self.tower_death_time_t1 = ::std::option::Option::None;
            self.tower_death_time_t2 = ::std::option::Option::None;
            self.tower_death_time_t3 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GameStats {
            static instance: GameStats = GameStats {
                tower_death_time_t1: ::std::option::Option::None,
                tower_death_time_t2: ::std::option::Option::None,
                tower_death_time_t3: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GameStats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDetailedGameStats.GameStats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GameStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GameStats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDetailedGameStats.MinuteEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MinuteEntry {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.MinuteEntry.minute)
        pub minute: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.MinuteEntry.stats)
        pub stats: ::std::vec::Vec<PlayerStatEntry>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDetailedGameStats.MinuteEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MinuteEntry {
        fn default() -> &'a MinuteEntry {
            <MinuteEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl MinuteEntry {
        pub fn new() -> MinuteEntry {
            ::std::default::Default::default()
        }

        // optional uint32 minute = 1;

        pub fn minute(&self) -> u32 {
            self.minute.unwrap_or(0)
        }

        pub fn clear_minute(&mut self) {
            self.minute = ::std::option::Option::None;
        }

        pub fn has_minute(&self) -> bool {
            self.minute.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minute(&mut self, v: u32) {
            self.minute = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "minute",
                |m: &MinuteEntry| { &m.minute },
                |m: &mut MinuteEntry| { &mut m.minute },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "stats",
                |m: &MinuteEntry| { &m.stats },
                |m: &mut MinuteEntry| { &mut m.stats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MinuteEntry>(
                "CMsgDetailedGameStats.MinuteEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MinuteEntry {
        const NAME: &'static str = "MinuteEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.minute = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.stats.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.minute {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.stats {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.minute {
                os.write_uint32(1, v)?;
            }
            for v in &self.stats {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MinuteEntry {
            MinuteEntry::new()
        }

        fn clear(&mut self) {
            self.minute = ::std::option::Option::None;
            self.stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MinuteEntry {
            static instance: MinuteEntry = MinuteEntry {
                minute: ::std::option::Option::None,
                stats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MinuteEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDetailedGameStats.MinuteEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MinuteEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MinuteEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDetailedGameStats.PlayerInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerInfo.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerInfo.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDetailedGameStats.PlayerInfo.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDetailedGameStats.PlayerInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerInfo {
        fn default() -> &'a PlayerInfo {
            <PlayerInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerInfo {
        pub fn new() -> PlayerInfo {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 2;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 3;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerInfo| { &m.account_id },
                |m: &mut PlayerInfo| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &PlayerInfo| { &m.hero_id },
                |m: &mut PlayerInfo| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_slot",
                |m: &PlayerInfo| { &m.player_slot },
                |m: &mut PlayerInfo| { &mut m.player_slot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerInfo>(
                "CMsgDetailedGameStats.PlayerInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerInfo {
        const NAME: &'static str = "PlayerInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.player_slot {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.player_slot {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerInfo {
            PlayerInfo::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.player_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerInfo {
            static instance: PlayerInfo = PlayerInfo {
                account_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                player_slot: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDetailedGameStats.PlayerInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgNeutralItemStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeutralItemStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgNeutralItemStats.neutral_items)
    pub neutral_items: ::std::vec::Vec<cmsg_neutral_item_stats::NeutralItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgNeutralItemStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeutralItemStats {
    fn default() -> &'a CMsgNeutralItemStats {
        <CMsgNeutralItemStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNeutralItemStats {
    pub fn new() -> CMsgNeutralItemStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "neutral_items",
            |m: &CMsgNeutralItemStats| { &m.neutral_items },
            |m: &mut CMsgNeutralItemStats| { &mut m.neutral_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNeutralItemStats>(
            "CMsgNeutralItemStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgNeutralItemStats {
    const NAME: &'static str = "CMsgNeutralItemStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.neutral_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.neutral_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.neutral_items {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeutralItemStats {
        CMsgNeutralItemStats::new()
    }

    fn clear(&mut self) {
        self.neutral_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeutralItemStats {
        static instance: CMsgNeutralItemStats = CMsgNeutralItemStats {
            neutral_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgNeutralItemStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNeutralItemStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNeutralItemStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNeutralItemStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgNeutralItemStats`
pub mod cmsg_neutral_item_stats {
    // @@protoc_insertion_point(message:dota.CMsgNeutralItemStats.NeutralItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NeutralItem {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgNeutralItemStats.NeutralItem.item_id)
        pub item_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgNeutralItemStats.NeutralItem.time_dropped)
        pub time_dropped: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgNeutralItemStats.NeutralItem.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgNeutralItemStats.NeutralItem.time_last_equipped)
        pub time_last_equipped: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgNeutralItemStats.NeutralItem.time_last_unequipped)
        pub time_last_unequipped: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgNeutralItemStats.NeutralItem.duration_equipped)
        pub duration_equipped: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgNeutralItemStats.NeutralItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NeutralItem {
        fn default() -> &'a NeutralItem {
            <NeutralItem as ::protobuf::Message>::default_instance()
        }
    }

    impl NeutralItem {
        pub fn new() -> NeutralItem {
            ::std::default::Default::default()
        }

        // optional int32 item_id = 1;

        pub fn item_id(&self) -> i32 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: i32) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_dropped = 2;

        pub fn time_dropped(&self) -> u32 {
            self.time_dropped.unwrap_or(0)
        }

        pub fn clear_time_dropped(&mut self) {
            self.time_dropped = ::std::option::Option::None;
        }

        pub fn has_time_dropped(&self) -> bool {
            self.time_dropped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_dropped(&mut self, v: u32) {
            self.time_dropped = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 3;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_equipped = 4;

        pub fn time_last_equipped(&self) -> u32 {
            self.time_last_equipped.unwrap_or(0)
        }

        pub fn clear_time_last_equipped(&mut self) {
            self.time_last_equipped = ::std::option::Option::None;
        }

        pub fn has_time_last_equipped(&self) -> bool {
            self.time_last_equipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_equipped(&mut self, v: u32) {
            self.time_last_equipped = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_unequipped = 5;

        pub fn time_last_unequipped(&self) -> u32 {
            self.time_last_unequipped.unwrap_or(0)
        }

        pub fn clear_time_last_unequipped(&mut self) {
            self.time_last_unequipped = ::std::option::Option::None;
        }

        pub fn has_time_last_unequipped(&self) -> bool {
            self.time_last_unequipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_unequipped(&mut self, v: u32) {
            self.time_last_unequipped = ::std::option::Option::Some(v);
        }

        // optional uint32 duration_equipped = 6;

        pub fn duration_equipped(&self) -> u32 {
            self.duration_equipped.unwrap_or(0)
        }

        pub fn clear_duration_equipped(&mut self) {
            self.duration_equipped = ::std::option::Option::None;
        }

        pub fn has_duration_equipped(&self) -> bool {
            self.duration_equipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration_equipped(&mut self, v: u32) {
            self.duration_equipped = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &NeutralItem| { &m.item_id },
                |m: &mut NeutralItem| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_dropped",
                |m: &NeutralItem| { &m.time_dropped },
                |m: &mut NeutralItem| { &mut m.time_dropped },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &NeutralItem| { &m.team },
                |m: &mut NeutralItem| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_last_equipped",
                |m: &NeutralItem| { &m.time_last_equipped },
                |m: &mut NeutralItem| { &mut m.time_last_equipped },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_last_unequipped",
                |m: &NeutralItem| { &m.time_last_unequipped },
                |m: &mut NeutralItem| { &mut m.time_last_unequipped },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "duration_equipped",
                |m: &NeutralItem| { &m.duration_equipped },
                |m: &mut NeutralItem| { &mut m.duration_equipped },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NeutralItem>(
                "CMsgNeutralItemStats.NeutralItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NeutralItem {
        const NAME: &'static str = "NeutralItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.time_dropped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.time_last_equipped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.time_last_unequipped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.duration_equipped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.time_dropped {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.time_last_equipped {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.time_last_unequipped {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.duration_equipped {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.time_dropped {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.time_last_equipped {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_last_unequipped {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.duration_equipped {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NeutralItem {
            NeutralItem::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.time_dropped = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.time_last_equipped = ::std::option::Option::None;
            self.time_last_unequipped = ::std::option::Option::None;
            self.duration_equipped = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NeutralItem {
            static instance: NeutralItem = NeutralItem {
                item_id: ::std::option::Option::None,
                time_dropped: ::std::option::Option::None,
                team: ::std::option::Option::None,
                time_last_equipped: ::std::option::Option::None,
                time_last_unequipped: ::std::option::Option::None,
                duration_equipped: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NeutralItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgNeutralItemStats.NeutralItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NeutralItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NeutralItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerLobbyHeroBanRates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerLobbyHeroBanRates {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerLobbyHeroBanRates.ban_data)
    pub ban_data: ::std::vec::Vec<cmsg_gcto_server_lobby_hero_ban_rates::HeroBanEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerLobbyHeroBanRates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerLobbyHeroBanRates {
    fn default() -> &'a CMsgGCToServerLobbyHeroBanRates {
        <CMsgGCToServerLobbyHeroBanRates as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerLobbyHeroBanRates {
    pub fn new() -> CMsgGCToServerLobbyHeroBanRates {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ban_data",
            |m: &CMsgGCToServerLobbyHeroBanRates| { &m.ban_data },
            |m: &mut CMsgGCToServerLobbyHeroBanRates| { &mut m.ban_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerLobbyHeroBanRates>(
            "CMsgGCToServerLobbyHeroBanRates",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerLobbyHeroBanRates {
    const NAME: &'static str = "CMsgGCToServerLobbyHeroBanRates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ban_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ban_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ban_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerLobbyHeroBanRates {
        CMsgGCToServerLobbyHeroBanRates::new()
    }

    fn clear(&mut self) {
        self.ban_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerLobbyHeroBanRates {
        static instance: CMsgGCToServerLobbyHeroBanRates = CMsgGCToServerLobbyHeroBanRates {
            ban_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerLobbyHeroBanRates {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerLobbyHeroBanRates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerLobbyHeroBanRates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerLobbyHeroBanRates {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToServerLobbyHeroBanRates`
pub mod cmsg_gcto_server_lobby_hero_ban_rates {
    // @@protoc_insertion_point(message:dota.CMsgGCToServerLobbyHeroBanRates.HeroBanEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroBanEntry {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.ban_count)
        pub ban_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.pick_count)
        pub pick_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroBanEntry {
        fn default() -> &'a HeroBanEntry {
            <HeroBanEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl HeroBanEntry {
        pub fn new() -> HeroBanEntry {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 ban_count = 2;

        pub fn ban_count(&self) -> u32 {
            self.ban_count.unwrap_or(0)
        }

        pub fn clear_ban_count(&mut self) {
            self.ban_count = ::std::option::Option::None;
        }

        pub fn has_ban_count(&self) -> bool {
            self.ban_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_count(&mut self, v: u32) {
            self.ban_count = ::std::option::Option::Some(v);
        }

        // optional uint32 pick_count = 3;

        pub fn pick_count(&self) -> u32 {
            self.pick_count.unwrap_or(0)
        }

        pub fn clear_pick_count(&mut self) {
            self.pick_count = ::std::option::Option::None;
        }

        pub fn has_pick_count(&self) -> bool {
            self.pick_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick_count(&mut self, v: u32) {
            self.pick_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &HeroBanEntry| { &m.hero_id },
                |m: &mut HeroBanEntry| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ban_count",
                |m: &HeroBanEntry| { &m.ban_count },
                |m: &mut HeroBanEntry| { &mut m.ban_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pick_count",
                |m: &HeroBanEntry| { &m.pick_count },
                |m: &mut HeroBanEntry| { &mut m.pick_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroBanEntry>(
                "CMsgGCToServerLobbyHeroBanRates.HeroBanEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HeroBanEntry {
        const NAME: &'static str = "HeroBanEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ban_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.pick_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ban_count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.pick_count {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ban_count {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.pick_count {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroBanEntry {
            HeroBanEntry::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.ban_count = ::std::option::Option::None;
            self.pick_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroBanEntry {
            static instance: HeroBanEntry = HeroBanEntry {
                hero_id: ::std::option::Option::None,
                ban_count: ::std::option::Option::None,
                pick_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HeroBanEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToServerLobbyHeroBanRates.HeroBanEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HeroBanEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HeroBanEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutGuildContractProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutGuildContractProgress {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutGuildContractProgress.player_contracts)
    pub player_contracts: ::std::vec::Vec<cmsg_sign_out_guild_contract_progress::PlayerContract>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutGuildContractProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutGuildContractProgress {
    fn default() -> &'a CMsgSignOutGuildContractProgress {
        <CMsgSignOutGuildContractProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutGuildContractProgress {
    pub fn new() -> CMsgSignOutGuildContractProgress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_contracts",
            |m: &CMsgSignOutGuildContractProgress| { &m.player_contracts },
            |m: &mut CMsgSignOutGuildContractProgress| { &mut m.player_contracts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutGuildContractProgress>(
            "CMsgSignOutGuildContractProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutGuildContractProgress {
    const NAME: &'static str = "CMsgSignOutGuildContractProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_contracts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_contracts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_contracts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutGuildContractProgress {
        CMsgSignOutGuildContractProgress::new()
    }

    fn clear(&mut self) {
        self.player_contracts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutGuildContractProgress {
        static instance: CMsgSignOutGuildContractProgress = CMsgSignOutGuildContractProgress {
            player_contracts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutGuildContractProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutGuildContractProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutGuildContractProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutGuildContractProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutGuildContractProgress`
pub mod cmsg_sign_out_guild_contract_progress {
    // @@protoc_insertion_point(message:dota.CMsgSignOutGuildContractProgress.CompletedGuildEventContracts)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CompletedGuildEventContracts {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.contracts)
        pub contracts: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CompletedGuildEventContracts {
        fn default() -> &'a CompletedGuildEventContracts {
            <CompletedGuildEventContracts as ::protobuf::Message>::default_instance()
        }
    }

    impl CompletedGuildEventContracts {
        pub fn new() -> CompletedGuildEventContracts {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional uint32 event_id = 2;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_id",
                |m: &CompletedGuildEventContracts| { &m.guild_id },
                |m: &mut CompletedGuildEventContracts| { &mut m.guild_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &CompletedGuildEventContracts| { &m.event_id },
                |m: &mut CompletedGuildEventContracts| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "contracts",
                |m: &CompletedGuildEventContracts| { &m.contracts },
                |m: &mut CompletedGuildEventContracts| { &mut m.contracts },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompletedGuildEventContracts>(
                "CMsgSignOutGuildContractProgress.CompletedGuildEventContracts",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CompletedGuildEventContracts {
        const NAME: &'static str = "CompletedGuildEventContracts";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint64_into(&mut self.contracts)?;
                    },
                    24 => {
                        self.contracts.push(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.contracts {
                my_size += ::protobuf::rt::uint64_size(3, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_uint32(2, v)?;
            }
            for v in &self.contracts {
                os.write_uint64(3, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CompletedGuildEventContracts {
            CompletedGuildEventContracts::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.contracts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CompletedGuildEventContracts {
            static instance: CompletedGuildEventContracts = CompletedGuildEventContracts {
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                contracts: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CompletedGuildEventContracts {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutGuildContractProgress.CompletedGuildEventContracts").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CompletedGuildEventContracts {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CompletedGuildEventContracts {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgSignOutGuildContractProgress.PlayerContract)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerContract {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildContractProgress.PlayerContract.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildContractProgress.PlayerContract.completed_contracts)
        pub completed_contracts: ::std::vec::Vec<CompletedGuildEventContracts>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutGuildContractProgress.PlayerContract.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerContract {
        fn default() -> &'a PlayerContract {
            <PlayerContract as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerContract {
        pub fn new() -> PlayerContract {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerContract| { &m.account_id },
                |m: &mut PlayerContract| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "completed_contracts",
                |m: &PlayerContract| { &m.completed_contracts },
                |m: &mut PlayerContract| { &mut m.completed_contracts },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerContract>(
                "CMsgSignOutGuildContractProgress.PlayerContract",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerContract {
        const NAME: &'static str = "PlayerContract";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.completed_contracts.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.completed_contracts {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.completed_contracts {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerContract {
            PlayerContract::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.completed_contracts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerContract {
            static instance: PlayerContract = PlayerContract {
                account_id: ::std::option::Option::None,
                completed_contracts: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerContract {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutGuildContractProgress.PlayerContract").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerContract {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerContract {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutGuildChallengeProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutGuildChallengeProgress {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.guild_challenges_progresses)
    pub guild_challenges_progresses: ::std::vec::Vec<cmsg_sign_out_guild_challenge_progress::ChallengeProgress>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutGuildChallengeProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutGuildChallengeProgress {
    fn default() -> &'a CMsgSignOutGuildChallengeProgress {
        <CMsgSignOutGuildChallengeProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutGuildChallengeProgress {
    pub fn new() -> CMsgSignOutGuildChallengeProgress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_challenges_progresses",
            |m: &CMsgSignOutGuildChallengeProgress| { &m.guild_challenges_progresses },
            |m: &mut CMsgSignOutGuildChallengeProgress| { &mut m.guild_challenges_progresses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutGuildChallengeProgress>(
            "CMsgSignOutGuildChallengeProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutGuildChallengeProgress {
    const NAME: &'static str = "CMsgSignOutGuildChallengeProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guild_challenges_progresses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.guild_challenges_progresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.guild_challenges_progresses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutGuildChallengeProgress {
        CMsgSignOutGuildChallengeProgress::new()
    }

    fn clear(&mut self) {
        self.guild_challenges_progresses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutGuildChallengeProgress {
        static instance: CMsgSignOutGuildChallengeProgress = CMsgSignOutGuildChallengeProgress {
            guild_challenges_progresses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutGuildChallengeProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutGuildChallengeProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutGuildChallengeProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutGuildChallengeProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutGuildChallengeProgress`
pub mod cmsg_sign_out_guild_challenge_progress {
    // @@protoc_insertion_point(message:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChallengeProgress {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_instance_id)
        pub challenge_instance_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_instance_timestamp)
        pub challenge_instance_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_period_serial)
        pub challenge_period_serial: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.progress)
        pub progress: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_parameter)
        pub challenge_parameter: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutGuildChallengeProgress.ChallengeProgress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChallengeProgress {
        fn default() -> &'a ChallengeProgress {
            <ChallengeProgress as ::protobuf::Message>::default_instance()
        }
    }

    impl ChallengeProgress {
        pub fn new() -> ChallengeProgress {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional uint32 event_id = 2;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_instance_id = 3;

        pub fn challenge_instance_id(&self) -> u32 {
            self.challenge_instance_id.unwrap_or(0)
        }

        pub fn clear_challenge_instance_id(&mut self) {
            self.challenge_instance_id = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_id(&self) -> bool {
            self.challenge_instance_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_id(&mut self, v: u32) {
            self.challenge_instance_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_instance_timestamp = 4;

        pub fn challenge_instance_timestamp(&self) -> u32 {
            self.challenge_instance_timestamp.unwrap_or(0)
        }

        pub fn clear_challenge_instance_timestamp(&mut self) {
            self.challenge_instance_timestamp = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_timestamp(&self) -> bool {
            self.challenge_instance_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_timestamp(&mut self, v: u32) {
            self.challenge_instance_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_period_serial = 5;

        pub fn challenge_period_serial(&self) -> u32 {
            self.challenge_period_serial.unwrap_or(0)
        }

        pub fn clear_challenge_period_serial(&mut self) {
            self.challenge_period_serial = ::std::option::Option::None;
        }

        pub fn has_challenge_period_serial(&self) -> bool {
            self.challenge_period_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_period_serial(&mut self, v: u32) {
            self.challenge_period_serial = ::std::option::Option::Some(v);
        }

        // optional uint32 progress = 6;

        pub fn progress(&self) -> u32 {
            self.progress.unwrap_or(0)
        }

        pub fn clear_progress(&mut self) {
            self.progress = ::std::option::Option::None;
        }

        pub fn has_progress(&self) -> bool {
            self.progress.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress(&mut self, v: u32) {
            self.progress = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_parameter = 7;

        pub fn challenge_parameter(&self) -> u32 {
            self.challenge_parameter.unwrap_or(0)
        }

        pub fn clear_challenge_parameter(&mut self) {
            self.challenge_parameter = ::std::option::Option::None;
        }

        pub fn has_challenge_parameter(&self) -> bool {
            self.challenge_parameter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_parameter(&mut self, v: u32) {
            self.challenge_parameter = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_id",
                |m: &ChallengeProgress| { &m.guild_id },
                |m: &mut ChallengeProgress| { &mut m.guild_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &ChallengeProgress| { &m.event_id },
                |m: &mut ChallengeProgress| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_instance_id",
                |m: &ChallengeProgress| { &m.challenge_instance_id },
                |m: &mut ChallengeProgress| { &mut m.challenge_instance_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_instance_timestamp",
                |m: &ChallengeProgress| { &m.challenge_instance_timestamp },
                |m: &mut ChallengeProgress| { &mut m.challenge_instance_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_period_serial",
                |m: &ChallengeProgress| { &m.challenge_period_serial },
                |m: &mut ChallengeProgress| { &mut m.challenge_period_serial },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "progress",
                |m: &ChallengeProgress| { &m.progress },
                |m: &mut ChallengeProgress| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_parameter",
                |m: &ChallengeProgress| { &m.challenge_parameter },
                |m: &mut ChallengeProgress| { &mut m.challenge_parameter },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChallengeProgress>(
                "CMsgSignOutGuildChallengeProgress.ChallengeProgress",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChallengeProgress {
        const NAME: &'static str = "ChallengeProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.challenge_instance_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.challenge_period_serial = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.progress = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.challenge_instance_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.challenge_instance_timestamp {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.challenge_period_serial {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.progress {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.challenge_parameter {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.challenge_instance_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.challenge_instance_timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.challenge_period_serial {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.progress {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.challenge_parameter {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChallengeProgress {
            ChallengeProgress::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.challenge_instance_id = ::std::option::Option::None;
            self.challenge_instance_timestamp = ::std::option::Option::None;
            self.challenge_period_serial = ::std::option::Option::None;
            self.progress = ::std::option::Option::None;
            self.challenge_parameter = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChallengeProgress {
            static instance: ChallengeProgress = ChallengeProgress {
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                challenge_instance_id: ::std::option::Option::None,
                challenge_instance_timestamp: ::std::option::Option::None,
                challenge_period_serial: ::std::option::Option::None,
                progress: ::std::option::Option::None,
                challenge_parameter: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChallengeProgress {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutGuildChallengeProgress.ChallengeProgress").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChallengeProgress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChallengeProgress {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutMVPStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutMVPStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_mvpstats::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutMVPStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutMVPStats {
    fn default() -> &'a CMsgSignOutMVPStats {
        <CMsgSignOutMVPStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutMVPStats {
    pub fn new() -> CMsgSignOutMVPStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 2;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 3;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    // optional float game_time = 4;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgSignOutMVPStats| { &m.match_id },
            |m: &mut CMsgSignOutMVPStats| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgSignOutMVPStats| { &m.game_mode },
            |m: &mut CMsgSignOutMVPStats| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "winning_team",
            |m: &CMsgSignOutMVPStats| { &m.winning_team },
            |m: &mut CMsgSignOutMVPStats| { &mut m.winning_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_time",
            |m: &CMsgSignOutMVPStats| { &m.game_time },
            |m: &mut CMsgSignOutMVPStats| { &mut m.game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgSignOutMVPStats| { &m.players },
            |m: &mut CMsgSignOutMVPStats| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutMVPStats>(
            "CMsgSignOutMVPStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutMVPStats {
    const NAME: &'static str = "CMsgSignOutMVPStats";

    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_float(4, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutMVPStats {
        CMsgSignOutMVPStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.game_time = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutMVPStats {
        static instance: CMsgSignOutMVPStats = CMsgSignOutMVPStats {
            match_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            game_time: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutMVPStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutMVPStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutMVPStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutMVPStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutMVPStats`
pub mod cmsg_sign_out_mvpstats {
    // @@protoc_insertion_point(message:dota.CMsgSignOutMVPStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.team_networth_rank)
        pub team_networth_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.kills)
        pub kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.deaths)
        pub deaths: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.assists)
        pub assists: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.xp)
        pub xp: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.net_worth)
        pub net_worth: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.support_gold_spent)
        pub support_gold_spent: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.wards_placed)
        pub wards_placed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.wards_spotted_for_dewarding)
        pub wards_spotted_for_dewarding: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.camps_stacked)
        pub camps_stacked: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.last_hits)
        pub last_hits: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.denies)
        pub denies: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.building_damage)
        pub building_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.other_damage)
        pub other_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.triple_kills)
        pub triple_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.rampages)
        pub rampages: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.first_blood)
        pub first_blood: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.kill_eater_events)
        pub kill_eater_events: ::std::vec::Vec<player::KillEaterEvent>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.highest_killstreak)
        pub highest_killstreak: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutMVPStats.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team_networth_rank = 2;

        pub fn team_networth_rank(&self) -> u32 {
            self.team_networth_rank.unwrap_or(0)
        }

        pub fn clear_team_networth_rank(&mut self) {
            self.team_networth_rank = ::std::option::Option::None;
        }

        pub fn has_team_networth_rank(&self) -> bool {
            self.team_networth_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_networth_rank(&mut self, v: u32) {
            self.team_networth_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 3;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 32;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 rank = 33;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 4;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 role = 5;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional int32 kills = 6;

        pub fn kills(&self) -> i32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: i32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional int32 deaths = 7;

        pub fn deaths(&self) -> i32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: i32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional int32 assists = 8;

        pub fn assists(&self) -> i32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: i32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional int32 xp = 9;

        pub fn xp(&self) -> i32 {
            self.xp.unwrap_or(0)
        }

        pub fn clear_xp(&mut self) {
            self.xp = ::std::option::Option::None;
        }

        pub fn has_xp(&self) -> bool {
            self.xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp(&mut self, v: i32) {
            self.xp = ::std::option::Option::Some(v);
        }

        // optional int32 net_worth = 10;

        pub fn net_worth(&self) -> i32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: i32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional int32 support_gold_spent = 12;

        pub fn support_gold_spent(&self) -> i32 {
            self.support_gold_spent.unwrap_or(0)
        }

        pub fn clear_support_gold_spent(&mut self) {
            self.support_gold_spent = ::std::option::Option::None;
        }

        pub fn has_support_gold_spent(&self) -> bool {
            self.support_gold_spent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_gold_spent(&mut self, v: i32) {
            self.support_gold_spent = ::std::option::Option::Some(v);
        }

        // optional int32 wards_placed = 13;

        pub fn wards_placed(&self) -> i32 {
            self.wards_placed.unwrap_or(0)
        }

        pub fn clear_wards_placed(&mut self) {
            self.wards_placed = ::std::option::Option::None;
        }

        pub fn has_wards_placed(&self) -> bool {
            self.wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_placed(&mut self, v: i32) {
            self.wards_placed = ::std::option::Option::Some(v);
        }

        // optional int32 wards_spotted_for_dewarding = 14;

        pub fn wards_spotted_for_dewarding(&self) -> i32 {
            self.wards_spotted_for_dewarding.unwrap_or(0)
        }

        pub fn clear_wards_spotted_for_dewarding(&mut self) {
            self.wards_spotted_for_dewarding = ::std::option::Option::None;
        }

        pub fn has_wards_spotted_for_dewarding(&self) -> bool {
            self.wards_spotted_for_dewarding.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_spotted_for_dewarding(&mut self, v: i32) {
            self.wards_spotted_for_dewarding = ::std::option::Option::Some(v);
        }

        // optional int32 camps_stacked = 15;

        pub fn camps_stacked(&self) -> i32 {
            self.camps_stacked.unwrap_or(0)
        }

        pub fn clear_camps_stacked(&mut self) {
            self.camps_stacked = ::std::option::Option::None;
        }

        pub fn has_camps_stacked(&self) -> bool {
            self.camps_stacked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_camps_stacked(&mut self, v: i32) {
            self.camps_stacked = ::std::option::Option::Some(v);
        }

        // optional int32 last_hits = 16;

        pub fn last_hits(&self) -> i32 {
            self.last_hits.unwrap_or(0)
        }

        pub fn clear_last_hits(&mut self) {
            self.last_hits = ::std::option::Option::None;
        }

        pub fn has_last_hits(&self) -> bool {
            self.last_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hits(&mut self, v: i32) {
            self.last_hits = ::std::option::Option::Some(v);
        }

        // optional int32 denies = 17;

        pub fn denies(&self) -> i32 {
            self.denies.unwrap_or(0)
        }

        pub fn clear_denies(&mut self) {
            self.denies = ::std::option::Option::None;
        }

        pub fn has_denies(&self) -> bool {
            self.denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies(&mut self, v: i32) {
            self.denies = ::std::option::Option::Some(v);
        }

        // optional int32 building_damage = 19;

        pub fn building_damage(&self) -> i32 {
            self.building_damage.unwrap_or(0)
        }

        pub fn clear_building_damage(&mut self) {
            self.building_damage = ::std::option::Option::None;
        }

        pub fn has_building_damage(&self) -> bool {
            self.building_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_building_damage(&mut self, v: i32) {
            self.building_damage = ::std::option::Option::Some(v);
        }

        // optional int32 other_damage = 20;

        pub fn other_damage(&self) -> i32 {
            self.other_damage.unwrap_or(0)
        }

        pub fn clear_other_damage(&mut self) {
            self.other_damage = ::std::option::Option::None;
        }

        pub fn has_other_damage(&self) -> bool {
            self.other_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_other_damage(&mut self, v: i32) {
            self.other_damage = ::std::option::Option::Some(v);
        }

        // optional int32 triple_kills = 26;

        pub fn triple_kills(&self) -> i32 {
            self.triple_kills.unwrap_or(0)
        }

        pub fn clear_triple_kills(&mut self) {
            self.triple_kills = ::std::option::Option::None;
        }

        pub fn has_triple_kills(&self) -> bool {
            self.triple_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_triple_kills(&mut self, v: i32) {
            self.triple_kills = ::std::option::Option::Some(v);
        }

        // optional int32 rampages = 28;

        pub fn rampages(&self) -> i32 {
            self.rampages.unwrap_or(0)
        }

        pub fn clear_rampages(&mut self) {
            self.rampages = ::std::option::Option::None;
        }

        pub fn has_rampages(&self) -> bool {
            self.rampages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rampages(&mut self, v: i32) {
            self.rampages = ::std::option::Option::Some(v);
        }

        // optional int32 first_blood = 31;

        pub fn first_blood(&self) -> i32 {
            self.first_blood.unwrap_or(0)
        }

        pub fn clear_first_blood(&mut self) {
            self.first_blood = ::std::option::Option::None;
        }

        pub fn has_first_blood(&self) -> bool {
            self.first_blood.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_blood(&mut self, v: i32) {
            self.first_blood = ::std::option::Option::Some(v);
        }

        // optional uint32 highest_killstreak = 35;

        pub fn highest_killstreak(&self) -> u32 {
            self.highest_killstreak.unwrap_or(0)
        }

        pub fn clear_highest_killstreak(&mut self) {
            self.highest_killstreak = ::std::option::Option::None;
        }

        pub fn has_highest_killstreak(&self) -> bool {
            self.highest_killstreak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_highest_killstreak(&mut self, v: u32) {
            self.highest_killstreak = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(25);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Player| { &m.team_id },
                |m: &mut Player| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_networth_rank",
                |m: &Player| { &m.team_networth_rank },
                |m: &mut Player| { &mut m.team_networth_rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_slot",
                |m: &Player| { &m.player_slot },
                |m: &mut Player| { &mut m.player_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank",
                |m: &Player| { &m.rank },
                |m: &mut Player| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Player| { &m.hero_id },
                |m: &mut Player| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "role",
                |m: &Player| { &m.role },
                |m: &mut Player| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &Player| { &m.kills },
                |m: &mut Player| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &Player| { &m.deaths },
                |m: &mut Player| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists",
                |m: &Player| { &m.assists },
                |m: &mut Player| { &mut m.assists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xp",
                |m: &Player| { &m.xp },
                |m: &mut Player| { &mut m.xp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &Player| { &m.net_worth },
                |m: &mut Player| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "support_gold_spent",
                |m: &Player| { &m.support_gold_spent },
                |m: &mut Player| { &mut m.support_gold_spent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wards_placed",
                |m: &Player| { &m.wards_placed },
                |m: &mut Player| { &mut m.wards_placed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wards_spotted_for_dewarding",
                |m: &Player| { &m.wards_spotted_for_dewarding },
                |m: &mut Player| { &mut m.wards_spotted_for_dewarding },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "camps_stacked",
                |m: &Player| { &m.camps_stacked },
                |m: &mut Player| { &mut m.camps_stacked },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_hits",
                |m: &Player| { &m.last_hits },
                |m: &mut Player| { &mut m.last_hits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "denies",
                |m: &Player| { &m.denies },
                |m: &mut Player| { &mut m.denies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "building_damage",
                |m: &Player| { &m.building_damage },
                |m: &mut Player| { &mut m.building_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "other_damage",
                |m: &Player| { &m.other_damage },
                |m: &mut Player| { &mut m.other_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "triple_kills",
                |m: &Player| { &m.triple_kills },
                |m: &mut Player| { &mut m.triple_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rampages",
                |m: &Player| { &m.rampages },
                |m: &mut Player| { &mut m.rampages },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "first_blood",
                |m: &Player| { &m.first_blood },
                |m: &mut Player| { &mut m.first_blood },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "kill_eater_events",
                |m: &Player| { &m.kill_eater_events },
                |m: &mut Player| { &mut m.kill_eater_events },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "highest_killstreak",
                |m: &Player| { &m.highest_killstreak },
                |m: &mut Player| { &mut m.highest_killstreak },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgSignOutMVPStats.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            for v in &self.kill_eater_events {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_networth_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    256 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    264 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.deaths = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.assists = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.xp = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.net_worth = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.support_gold_spent = ::std::option::Option::Some(is.read_int32()?);
                    },
                    104 => {
                        self.wards_placed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.wards_spotted_for_dewarding = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.camps_stacked = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.last_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    136 => {
                        self.denies = ::std::option::Option::Some(is.read_int32()?);
                    },
                    152 => {
                        self.building_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    160 => {
                        self.other_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    208 => {
                        self.triple_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    224 => {
                        self.rampages = ::std::option::Option::Some(is.read_int32()?);
                    },
                    248 => {
                        self.first_blood = ::std::option::Option::Some(is.read_int32()?);
                    },
                    274 => {
                        self.kill_eater_events.push(is.read_message()?);
                    },
                    280 => {
                        self.highest_killstreak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_networth_rank {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.player_slot {
                my_size += ::protobuf::rt::uint32_size(32, v);
            }
            if let Some(v) = self.rank {
                my_size += ::protobuf::rt::uint32_size(33, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.role {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.assists {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.xp {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.support_gold_spent {
                my_size += ::protobuf::rt::int32_size(12, v);
            }
            if let Some(v) = self.wards_placed {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.wards_spotted_for_dewarding {
                my_size += ::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.camps_stacked {
                my_size += ::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.last_hits {
                my_size += ::protobuf::rt::int32_size(16, v);
            }
            if let Some(v) = self.denies {
                my_size += ::protobuf::rt::int32_size(17, v);
            }
            if let Some(v) = self.building_damage {
                my_size += ::protobuf::rt::int32_size(19, v);
            }
            if let Some(v) = self.other_damage {
                my_size += ::protobuf::rt::int32_size(20, v);
            }
            if let Some(v) = self.triple_kills {
                my_size += ::protobuf::rt::int32_size(26, v);
            }
            if let Some(v) = self.rampages {
                my_size += ::protobuf::rt::int32_size(28, v);
            }
            if let Some(v) = self.first_blood {
                my_size += ::protobuf::rt::int32_size(31, v);
            }
            for value in &self.kill_eater_events {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.highest_killstreak {
                my_size += ::protobuf::rt::uint32_size(35, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_networth_rank {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.player_slot {
                os.write_uint32(32, v)?;
            }
            if let Some(v) = self.rank {
                os.write_uint32(33, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.kills {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.assists {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.xp {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.support_gold_spent {
                os.write_int32(12, v)?;
            }
            if let Some(v) = self.wards_placed {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.wards_spotted_for_dewarding {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.camps_stacked {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.last_hits {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.denies {
                os.write_int32(17, v)?;
            }
            if let Some(v) = self.building_damage {
                os.write_int32(19, v)?;
            }
            if let Some(v) = self.other_damage {
                os.write_int32(20, v)?;
            }
            if let Some(v) = self.triple_kills {
                os.write_int32(26, v)?;
            }
            if let Some(v) = self.rampages {
                os.write_int32(28, v)?;
            }
            if let Some(v) = self.first_blood {
                os.write_int32(31, v)?;
            }
            for v in &self.kill_eater_events {
                ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
            };
            if let Some(v) = self.highest_killstreak {
                os.write_uint32(35, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.team_networth_rank = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.player_slot = ::std::option::Option::None;
            self.rank = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.xp = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.support_gold_spent = ::std::option::Option::None;
            self.wards_placed = ::std::option::Option::None;
            self.wards_spotted_for_dewarding = ::std::option::Option::None;
            self.camps_stacked = ::std::option::Option::None;
            self.last_hits = ::std::option::Option::None;
            self.denies = ::std::option::Option::None;
            self.building_damage = ::std::option::Option::None;
            self.other_damage = ::std::option::Option::None;
            self.triple_kills = ::std::option::Option::None;
            self.rampages = ::std::option::Option::None;
            self.first_blood = ::std::option::Option::None;
            self.kill_eater_events.clear();
            self.highest_killstreak = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                team_id: ::std::option::Option::None,
                team_networth_rank: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                player_slot: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                role: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                xp: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                support_gold_spent: ::std::option::Option::None,
                wards_placed: ::std::option::Option::None,
                wards_spotted_for_dewarding: ::std::option::Option::None,
                camps_stacked: ::std::option::Option::None,
                last_hits: ::std::option::Option::None,
                denies: ::std::option::Option::None,
                building_damage: ::std::option::Option::None,
                other_damage: ::std::option::Option::None,
                triple_kills: ::std::option::Option::None,
                rampages: ::std::option::Option::None,
                first_blood: ::std::option::Option::None,
                kill_eater_events: ::std::vec::Vec::new(),
                highest_killstreak: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutMVPStats.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Player`
    pub mod player {
        // @@protoc_insertion_point(message:dota.CMsgSignOutMVPStats.Player.KillEaterEvent)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct KillEaterEvent {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.KillEaterEvent.event_type)
            pub event_type: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgSignOutMVPStats.Player.KillEaterEvent.amount)
            pub amount: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgSignOutMVPStats.Player.KillEaterEvent.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a KillEaterEvent {
            fn default() -> &'a KillEaterEvent {
                <KillEaterEvent as ::protobuf::Message>::default_instance()
            }
        }

        impl KillEaterEvent {
            pub fn new() -> KillEaterEvent {
                ::std::default::Default::default()
            }

            // required uint32 event_type = 1;

            pub fn event_type(&self) -> u32 {
                self.event_type.unwrap_or(0)
            }

            pub fn clear_event_type(&mut self) {
                self.event_type = ::std::option::Option::None;
            }

            pub fn has_event_type(&self) -> bool {
                self.event_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_type(&mut self, v: u32) {
                self.event_type = ::std::option::Option::Some(v);
            }

            // required uint32 amount = 2;

            pub fn amount(&self) -> u32 {
                self.amount.unwrap_or(0)
            }

            pub fn clear_amount(&mut self) {
                self.amount = ::std::option::Option::None;
            }

            pub fn has_amount(&self) -> bool {
                self.amount.is_some()
            }

            // Param is passed by value, moved
            pub fn set_amount(&mut self, v: u32) {
                self.amount = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "event_type",
                    |m: &KillEaterEvent| { &m.event_type },
                    |m: &mut KillEaterEvent| { &mut m.event_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "amount",
                    |m: &KillEaterEvent| { &m.amount },
                    |m: &mut KillEaterEvent| { &mut m.amount },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KillEaterEvent>(
                    "CMsgSignOutMVPStats.Player.KillEaterEvent",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for KillEaterEvent {
            const NAME: &'static str = "KillEaterEvent";

            fn is_initialized(&self) -> bool {
                if self.event_type.is_none() {
                    return false;
                }
                if self.amount.is_none() {
                    return false;
                }
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.amount = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.event_type {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.amount {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.event_type {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.amount {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> KillEaterEvent {
                KillEaterEvent::new()
            }

            fn clear(&mut self) {
                self.event_type = ::std::option::Option::None;
                self.amount = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static KillEaterEvent {
                static instance: KillEaterEvent = KillEaterEvent {
                    event_type: ::std::option::Option::None,
                    amount: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for KillEaterEvent {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSignOutMVPStats.Player.KillEaterEvent").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for KillEaterEvent {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for KillEaterEvent {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerRecordTrainingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerRecordTrainingData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerRecordTrainingData.enable)
    pub enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerRecordTrainingData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerRecordTrainingData {
    fn default() -> &'a CMsgGCToServerRecordTrainingData {
        <CMsgGCToServerRecordTrainingData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerRecordTrainingData {
    pub fn new() -> CMsgGCToServerRecordTrainingData {
        ::std::default::Default::default()
    }

    // optional bool enable = 1;

    pub fn enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable",
            |m: &CMsgGCToServerRecordTrainingData| { &m.enable },
            |m: &mut CMsgGCToServerRecordTrainingData| { &mut m.enable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerRecordTrainingData>(
            "CMsgGCToServerRecordTrainingData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerRecordTrainingData {
    const NAME: &'static str = "CMsgGCToServerRecordTrainingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerRecordTrainingData {
        CMsgGCToServerRecordTrainingData::new()
    }

    fn clear(&mut self) {
        self.enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerRecordTrainingData {
        static instance: CMsgGCToServerRecordTrainingData = CMsgGCToServerRecordTrainingData {
            enable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerRecordTrainingData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerRecordTrainingData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerRecordTrainingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerRecordTrainingData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCGetGuildContracts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetGuildContracts {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContracts.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetGuildContracts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetGuildContracts {
    fn default() -> &'a CMsgServerToGCGetGuildContracts {
        <CMsgServerToGCGetGuildContracts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetGuildContracts {
    pub fn new() -> CMsgServerToGCGetGuildContracts {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgServerToGCGetGuildContracts| { &m.account_ids },
            |m: &mut CMsgServerToGCGetGuildContracts| { &mut m.account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCGetGuildContracts>(
            "CMsgServerToGCGetGuildContracts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCGetGuildContracts {
    const NAME: &'static str = "CMsgServerToGCGetGuildContracts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetGuildContracts {
        CMsgServerToGCGetGuildContracts::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetGuildContracts {
        static instance: CMsgServerToGCGetGuildContracts = CMsgServerToGCGetGuildContracts {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCGetGuildContracts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCGetGuildContracts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCGetGuildContracts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetGuildContracts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCGetGuildContractsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetGuildContractsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.player_contracts)
    pub player_contracts: ::std::vec::Vec<cmsg_server_to_gcget_guild_contracts_response::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetGuildContractsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetGuildContractsResponse {
    fn default() -> &'a CMsgServerToGCGetGuildContractsResponse {
        <CMsgServerToGCGetGuildContractsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetGuildContractsResponse {
    pub fn new() -> CMsgServerToGCGetGuildContractsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_contracts",
            |m: &CMsgServerToGCGetGuildContractsResponse| { &m.player_contracts },
            |m: &mut CMsgServerToGCGetGuildContractsResponse| { &mut m.player_contracts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCGetGuildContractsResponse>(
            "CMsgServerToGCGetGuildContractsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCGetGuildContractsResponse {
    const NAME: &'static str = "CMsgServerToGCGetGuildContractsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_contracts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_contracts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_contracts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetGuildContractsResponse {
        CMsgServerToGCGetGuildContractsResponse::new()
    }

    fn clear(&mut self) {
        self.player_contracts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetGuildContractsResponse {
        static instance: CMsgServerToGCGetGuildContractsResponse = CMsgServerToGCGetGuildContractsResponse {
            player_contracts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCGetGuildContractsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCGetGuildContractsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCGetGuildContractsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetGuildContractsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCGetGuildContractsResponse`
pub mod cmsg_server_to_gcget_guild_contracts_response {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCGetGuildContractsResponse.ContractDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ContractDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.ContractDetails.contract_id)
        pub contract_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.ContractDetails.challenge_instance_id)
        pub challenge_instance_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.ContractDetails.challenge_parameter)
        pub challenge_parameter: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.ContractDetails.contract_stars)
        pub contract_stars: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.ContractDetails.contract_slot)
        pub contract_slot: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetGuildContractsResponse.ContractDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContractDetails {
        fn default() -> &'a ContractDetails {
            <ContractDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl ContractDetails {
        pub fn new() -> ContractDetails {
            ::std::default::Default::default()
        }

        // optional uint64 contract_id = 1;

        pub fn contract_id(&self) -> u64 {
            self.contract_id.unwrap_or(0)
        }

        pub fn clear_contract_id(&mut self) {
            self.contract_id = ::std::option::Option::None;
        }

        pub fn has_contract_id(&self) -> bool {
            self.contract_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contract_id(&mut self, v: u64) {
            self.contract_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_instance_id = 2;

        pub fn challenge_instance_id(&self) -> u32 {
            self.challenge_instance_id.unwrap_or(0)
        }

        pub fn clear_challenge_instance_id(&mut self) {
            self.challenge_instance_id = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_id(&self) -> bool {
            self.challenge_instance_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_id(&mut self, v: u32) {
            self.challenge_instance_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_parameter = 3;

        pub fn challenge_parameter(&self) -> u32 {
            self.challenge_parameter.unwrap_or(0)
        }

        pub fn clear_challenge_parameter(&mut self) {
            self.challenge_parameter = ::std::option::Option::None;
        }

        pub fn has_challenge_parameter(&self) -> bool {
            self.challenge_parameter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_parameter(&mut self, v: u32) {
            self.challenge_parameter = ::std::option::Option::Some(v);
        }

        // optional uint32 contract_stars = 4;

        pub fn contract_stars(&self) -> u32 {
            self.contract_stars.unwrap_or(0)
        }

        pub fn clear_contract_stars(&mut self) {
            self.contract_stars = ::std::option::Option::None;
        }

        pub fn has_contract_stars(&self) -> bool {
            self.contract_stars.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contract_stars(&mut self, v: u32) {
            self.contract_stars = ::std::option::Option::Some(v);
        }

        // optional uint32 contract_slot = 5;

        pub fn contract_slot(&self) -> u32 {
            self.contract_slot.unwrap_or(0)
        }

        pub fn clear_contract_slot(&mut self) {
            self.contract_slot = ::std::option::Option::None;
        }

        pub fn has_contract_slot(&self) -> bool {
            self.contract_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contract_slot(&mut self, v: u32) {
            self.contract_slot = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "contract_id",
                |m: &ContractDetails| { &m.contract_id },
                |m: &mut ContractDetails| { &mut m.contract_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_instance_id",
                |m: &ContractDetails| { &m.challenge_instance_id },
                |m: &mut ContractDetails| { &mut m.challenge_instance_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_parameter",
                |m: &ContractDetails| { &m.challenge_parameter },
                |m: &mut ContractDetails| { &mut m.challenge_parameter },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "contract_stars",
                |m: &ContractDetails| { &m.contract_stars },
                |m: &mut ContractDetails| { &mut m.contract_stars },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "contract_slot",
                |m: &ContractDetails| { &m.contract_slot },
                |m: &mut ContractDetails| { &mut m.contract_slot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContractDetails>(
                "CMsgServerToGCGetGuildContractsResponse.ContractDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ContractDetails {
        const NAME: &'static str = "ContractDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.contract_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.contract_stars = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.contract_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.contract_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.challenge_instance_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.challenge_parameter {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.contract_stars {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.contract_slot {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.contract_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.challenge_instance_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.challenge_parameter {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.contract_stars {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.contract_slot {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContractDetails {
            ContractDetails::new()
        }

        fn clear(&mut self) {
            self.contract_id = ::std::option::Option::None;
            self.challenge_instance_id = ::std::option::Option::None;
            self.challenge_parameter = ::std::option::Option::None;
            self.contract_stars = ::std::option::Option::None;
            self.contract_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContractDetails {
            static instance: ContractDetails = ContractDetails {
                contract_id: ::std::option::Option::None,
                challenge_instance_id: ::std::option::Option::None,
                challenge_parameter: ::std::option::Option::None,
                contract_stars: ::std::option::Option::None,
                contract_slot: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ContractDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCGetGuildContractsResponse.ContractDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ContractDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ContractDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgServerToGCGetGuildContractsResponse.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.Player.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.Player.event_id)
        pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetGuildContractsResponse.Player.contracts)
        pub contracts: ::std::vec::Vec<ContractDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetGuildContractsResponse.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_id = 2;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional .dota.EEvent event_id = 3;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_id",
                |m: &Player| { &m.guild_id },
                |m: &mut Player| { &mut m.guild_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &Player| { &m.event_id },
                |m: &mut Player| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "contracts",
                |m: &Player| { &m.contracts },
                |m: &mut Player| { &mut m.contracts },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgServerToGCGetGuildContractsResponse.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.contracts.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guild_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            for value in &self.contracts {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guild_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.contracts {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.contracts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                contracts: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCGetGuildContractsResponse.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgMatchDiretideCandy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchDiretideCandy {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.player_candy_data)
    pub player_candy_data: ::std::vec::Vec<cmsg_match_diretide_candy::PlayerCandy>,
    // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgMatchDiretideCandy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchDiretideCandy {
    fn default() -> &'a CMsgMatchDiretideCandy {
        <CMsgMatchDiretideCandy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchDiretideCandy {
    pub fn new() -> CMsgMatchDiretideCandy {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_candy_data",
            |m: &CMsgMatchDiretideCandy| { &m.player_candy_data },
            |m: &mut CMsgMatchDiretideCandy| { &mut m.player_candy_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgMatchDiretideCandy| { &m.event_id },
            |m: &mut CMsgMatchDiretideCandy| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchDiretideCandy>(
            "CMsgMatchDiretideCandy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchDiretideCandy {
    const NAME: &'static str = "CMsgMatchDiretideCandy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_candy_data.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_candy_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_candy_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchDiretideCandy {
        CMsgMatchDiretideCandy::new()
    }

    fn clear(&mut self) {
        self.player_candy_data.clear();
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchDiretideCandy {
        static instance: CMsgMatchDiretideCandy = CMsgMatchDiretideCandy {
            player_candy_data: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchDiretideCandy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchDiretideCandy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchDiretideCandy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchDiretideCandy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMatchDiretideCandy`
pub mod cmsg_match_diretide_candy {
    // @@protoc_insertion_point(message:dota.CMsgMatchDiretideCandy.CandyDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CandyDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.CandyDetails.amount)
        pub amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.CandyDetails.audit)
        pub audit: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgMatchDiretideCandy.CandyDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CandyDetails {
        fn default() -> &'a CandyDetails {
            <CandyDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl CandyDetails {
        pub fn new() -> CandyDetails {
            ::std::default::Default::default()
        }

        // optional uint32 amount = 1;

        pub fn amount(&self) -> u32 {
            self.amount.unwrap_or(0)
        }

        pub fn clear_amount(&mut self) {
            self.amount = ::std::option::Option::None;
        }

        pub fn has_amount(&self) -> bool {
            self.amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_amount(&mut self, v: u32) {
            self.amount = ::std::option::Option::Some(v);
        }

        // optional uint32 audit = 2;

        pub fn audit(&self) -> u32 {
            self.audit.unwrap_or(0)
        }

        pub fn clear_audit(&mut self) {
            self.audit = ::std::option::Option::None;
        }

        pub fn has_audit(&self) -> bool {
            self.audit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit(&mut self, v: u32) {
            self.audit = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "amount",
                |m: &CandyDetails| { &m.amount },
                |m: &mut CandyDetails| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "audit",
                |m: &CandyDetails| { &m.audit },
                |m: &mut CandyDetails| { &mut m.audit },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CandyDetails>(
                "CMsgMatchDiretideCandy.CandyDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CandyDetails {
        const NAME: &'static str = "CandyDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.audit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.amount {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.audit {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.amount {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.audit {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CandyDetails {
            CandyDetails::new()
        }

        fn clear(&mut self) {
            self.amount = ::std::option::Option::None;
            self.audit = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CandyDetails {
            static instance: CandyDetails = CandyDetails {
                amount: ::std::option::Option::None,
                audit: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CandyDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMatchDiretideCandy.CandyDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CandyDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CandyDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgMatchDiretideCandy.PlayerCandy)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCandy {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.PlayerCandy.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.PlayerCandy.candy_amount)
        pub candy_amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.PlayerCandy.consumes_periodic_resource)
        pub consumes_periodic_resource: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgMatchDiretideCandy.PlayerCandy.candy_breakdown)
        pub candy_breakdown: ::std::vec::Vec<CandyDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgMatchDiretideCandy.PlayerCandy.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCandy {
        fn default() -> &'a PlayerCandy {
            <PlayerCandy as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCandy {
        pub fn new() -> PlayerCandy {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 candy_amount = 3;

        pub fn candy_amount(&self) -> u32 {
            self.candy_amount.unwrap_or(0)
        }

        pub fn clear_candy_amount(&mut self) {
            self.candy_amount = ::std::option::Option::None;
        }

        pub fn has_candy_amount(&self) -> bool {
            self.candy_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_candy_amount(&mut self, v: u32) {
            self.candy_amount = ::std::option::Option::Some(v);
        }

        // optional bool consumes_periodic_resource = 4;

        pub fn consumes_periodic_resource(&self) -> bool {
            self.consumes_periodic_resource.unwrap_or(false)
        }

        pub fn clear_consumes_periodic_resource(&mut self) {
            self.consumes_periodic_resource = ::std::option::Option::None;
        }

        pub fn has_consumes_periodic_resource(&self) -> bool {
            self.consumes_periodic_resource.is_some()
        }

        // Param is passed by value, moved
        pub fn set_consumes_periodic_resource(&mut self, v: bool) {
            self.consumes_periodic_resource = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerCandy| { &m.account_id },
                |m: &mut PlayerCandy| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "candy_amount",
                |m: &PlayerCandy| { &m.candy_amount },
                |m: &mut PlayerCandy| { &mut m.candy_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "consumes_periodic_resource",
                |m: &PlayerCandy| { &m.consumes_periodic_resource },
                |m: &mut PlayerCandy| { &mut m.consumes_periodic_resource },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "candy_breakdown",
                |m: &PlayerCandy| { &m.candy_breakdown },
                |m: &mut PlayerCandy| { &mut m.candy_breakdown },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerCandy>(
                "CMsgMatchDiretideCandy.PlayerCandy",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerCandy {
        const NAME: &'static str = "PlayerCandy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.candy_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.consumes_periodic_resource = ::std::option::Option::Some(is.read_bool()?);
                    },
                    42 => {
                        self.candy_breakdown.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.candy_amount {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.consumes_periodic_resource {
                my_size += 1 + 1;
            }
            for value in &self.candy_breakdown {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.candy_amount {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.consumes_periodic_resource {
                os.write_bool(4, v)?;
            }
            for v in &self.candy_breakdown {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCandy {
            PlayerCandy::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.candy_amount = ::std::option::Option::None;
            self.consumes_periodic_resource = ::std::option::Option::None;
            self.candy_breakdown.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCandy {
            static instance: PlayerCandy = PlayerCandy {
                account_id: ::std::option::Option::None,
                candy_amount: ::std::option::Option::None,
                consumes_periodic_resource: ::std::option::Option::None,
                candy_breakdown: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerCandy {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMatchDiretideCandy.PlayerCandy").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerCandy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerCandy {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerCheerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerCheerData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerCheerData.cheer_types)
    pub cheer_types: ::std::vec::Vec<cmsg_gcto_server_cheer_data::CheerTypeCount>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerCheerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerCheerData {
    fn default() -> &'a CMsgGCToServerCheerData {
        <CMsgGCToServerCheerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerCheerData {
    pub fn new() -> CMsgGCToServerCheerData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cheer_types",
            |m: &CMsgGCToServerCheerData| { &m.cheer_types },
            |m: &mut CMsgGCToServerCheerData| { &mut m.cheer_types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerCheerData>(
            "CMsgGCToServerCheerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerCheerData {
    const NAME: &'static str = "CMsgGCToServerCheerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cheer_types.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cheer_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cheer_types {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerCheerData {
        CMsgGCToServerCheerData::new()
    }

    fn clear(&mut self) {
        self.cheer_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerCheerData {
        static instance: CMsgGCToServerCheerData = CMsgGCToServerCheerData {
            cheer_types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerCheerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerCheerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerCheerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerCheerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToServerCheerData`
pub mod cmsg_gcto_server_cheer_data {
    // @@protoc_insertion_point(message:dota.CMsgGCToServerCheerData.CheerTypeCount)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CheerTypeCount {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToServerCheerData.CheerTypeCount.cheer_type)
        pub cheer_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToServerCheerData.CheerTypeCount.cheer_count)
        pub cheer_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToServerCheerData.CheerTypeCount.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CheerTypeCount {
        fn default() -> &'a CheerTypeCount {
            <CheerTypeCount as ::protobuf::Message>::default_instance()
        }
    }

    impl CheerTypeCount {
        pub fn new() -> CheerTypeCount {
            ::std::default::Default::default()
        }

        // optional uint32 cheer_type = 1;

        pub fn cheer_type(&self) -> u32 {
            self.cheer_type.unwrap_or(0)
        }

        pub fn clear_cheer_type(&mut self) {
            self.cheer_type = ::std::option::Option::None;
        }

        pub fn has_cheer_type(&self) -> bool {
            self.cheer_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheer_type(&mut self, v: u32) {
            self.cheer_type = ::std::option::Option::Some(v);
        }

        // optional uint32 cheer_count = 2;

        pub fn cheer_count(&self) -> u32 {
            self.cheer_count.unwrap_or(0)
        }

        pub fn clear_cheer_count(&mut self) {
            self.cheer_count = ::std::option::Option::None;
        }

        pub fn has_cheer_count(&self) -> bool {
            self.cheer_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheer_count(&mut self, v: u32) {
            self.cheer_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cheer_type",
                |m: &CheerTypeCount| { &m.cheer_type },
                |m: &mut CheerTypeCount| { &mut m.cheer_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cheer_count",
                |m: &CheerTypeCount| { &m.cheer_count },
                |m: &mut CheerTypeCount| { &mut m.cheer_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CheerTypeCount>(
                "CMsgGCToServerCheerData.CheerTypeCount",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CheerTypeCount {
        const NAME: &'static str = "CheerTypeCount";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.cheer_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.cheer_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.cheer_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.cheer_count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.cheer_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.cheer_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CheerTypeCount {
            CheerTypeCount::new()
        }

        fn clear(&mut self) {
            self.cheer_type = ::std::option::Option::None;
            self.cheer_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CheerTypeCount {
            static instance: CheerTypeCount = CheerTypeCount {
                cheer_type: ::std::option::Option::None,
                cheer_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CheerTypeCount {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToServerCheerData.CheerTypeCount").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CheerTypeCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CheerTypeCount {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgCheerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCheerConfig {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheers_enabled)
    pub cheers_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.is_valid_league_id)
    pub is_valid_league_id: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.window_duration)
    pub window_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.window_bucket_count)
    pub window_bucket_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.crowd_level_push_time)
    pub crowd_level_push_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.crowd_level_low)
    pub crowd_level_low: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.crowd_level_medium)
    pub crowd_level_medium: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.crowd_level_high)
    pub crowd_level_high: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_scale_start)
    pub cheer_scale_start: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_scale_speed)
    pub cheer_scale_speed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_scale_push_mark)
    pub cheer_scale_push_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_scale_pull_mark)
    pub cheer_scale_pull_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_scale_pct_of_max_cps_clamp)
    pub cheer_scale_pct_of_max_cps_clamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_scale_dampener_value)
    pub cheer_scale_dampener_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_scale_dampener_lerp_time)
    pub cheer_scale_dampener_lerp_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_factor_bronze)
    pub cheer_factor_bronze: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_factor_silver)
    pub cheer_factor_silver: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerConfig.cheer_factor_gold)
    pub cheer_factor_gold: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCheerConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCheerConfig {
    fn default() -> &'a CMsgCheerConfig {
        <CMsgCheerConfig as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCheerConfig {
    pub fn new() -> CMsgCheerConfig {
        ::std::default::Default::default()
    }

    // optional bool cheers_enabled = 1;

    pub fn cheers_enabled(&self) -> bool {
        self.cheers_enabled.unwrap_or(false)
    }

    pub fn clear_cheers_enabled(&mut self) {
        self.cheers_enabled = ::std::option::Option::None;
    }

    pub fn has_cheers_enabled(&self) -> bool {
        self.cheers_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheers_enabled(&mut self, v: bool) {
        self.cheers_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_valid_league_id = 2;

    pub fn is_valid_league_id(&self) -> bool {
        self.is_valid_league_id.unwrap_or(false)
    }

    pub fn clear_is_valid_league_id(&mut self) {
        self.is_valid_league_id = ::std::option::Option::None;
    }

    pub fn has_is_valid_league_id(&self) -> bool {
        self.is_valid_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valid_league_id(&mut self, v: bool) {
        self.is_valid_league_id = ::std::option::Option::Some(v);
    }

    // optional float window_duration = 3;

    pub fn window_duration(&self) -> f32 {
        self.window_duration.unwrap_or(0.)
    }

    pub fn clear_window_duration(&mut self) {
        self.window_duration = ::std::option::Option::None;
    }

    pub fn has_window_duration(&self) -> bool {
        self.window_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_duration(&mut self, v: f32) {
        self.window_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 window_bucket_count = 4;

    pub fn window_bucket_count(&self) -> u32 {
        self.window_bucket_count.unwrap_or(0)
    }

    pub fn clear_window_bucket_count(&mut self) {
        self.window_bucket_count = ::std::option::Option::None;
    }

    pub fn has_window_bucket_count(&self) -> bool {
        self.window_bucket_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_bucket_count(&mut self, v: u32) {
        self.window_bucket_count = ::std::option::Option::Some(v);
    }

    // optional float crowd_level_push_time = 6;

    pub fn crowd_level_push_time(&self) -> f32 {
        self.crowd_level_push_time.unwrap_or(0.)
    }

    pub fn clear_crowd_level_push_time(&mut self) {
        self.crowd_level_push_time = ::std::option::Option::None;
    }

    pub fn has_crowd_level_push_time(&self) -> bool {
        self.crowd_level_push_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_push_time(&mut self, v: f32) {
        self.crowd_level_push_time = ::std::option::Option::Some(v);
    }

    // optional uint32 crowd_level_low = 10;

    pub fn crowd_level_low(&self) -> u32 {
        self.crowd_level_low.unwrap_or(0)
    }

    pub fn clear_crowd_level_low(&mut self) {
        self.crowd_level_low = ::std::option::Option::None;
    }

    pub fn has_crowd_level_low(&self) -> bool {
        self.crowd_level_low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_low(&mut self, v: u32) {
        self.crowd_level_low = ::std::option::Option::Some(v);
    }

    // optional uint32 crowd_level_medium = 11;

    pub fn crowd_level_medium(&self) -> u32 {
        self.crowd_level_medium.unwrap_or(0)
    }

    pub fn clear_crowd_level_medium(&mut self) {
        self.crowd_level_medium = ::std::option::Option::None;
    }

    pub fn has_crowd_level_medium(&self) -> bool {
        self.crowd_level_medium.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_medium(&mut self, v: u32) {
        self.crowd_level_medium = ::std::option::Option::Some(v);
    }

    // optional uint32 crowd_level_high = 12;

    pub fn crowd_level_high(&self) -> u32 {
        self.crowd_level_high.unwrap_or(0)
    }

    pub fn clear_crowd_level_high(&mut self) {
        self.crowd_level_high = ::std::option::Option::None;
    }

    pub fn has_crowd_level_high(&self) -> bool {
        self.crowd_level_high.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_high(&mut self, v: u32) {
        self.crowd_level_high = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_start = 13;

    pub fn cheer_scale_start(&self) -> f32 {
        self.cheer_scale_start.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_start(&mut self) {
        self.cheer_scale_start = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_start(&self) -> bool {
        self.cheer_scale_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_start(&mut self, v: f32) {
        self.cheer_scale_start = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_speed = 14;

    pub fn cheer_scale_speed(&self) -> f32 {
        self.cheer_scale_speed.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_speed(&mut self) {
        self.cheer_scale_speed = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_speed(&self) -> bool {
        self.cheer_scale_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_speed(&mut self, v: f32) {
        self.cheer_scale_speed = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_scale_push_mark = 15;

    pub fn cheer_scale_push_mark(&self) -> u32 {
        self.cheer_scale_push_mark.unwrap_or(0)
    }

    pub fn clear_cheer_scale_push_mark(&mut self) {
        self.cheer_scale_push_mark = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_push_mark(&self) -> bool {
        self.cheer_scale_push_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_push_mark(&mut self, v: u32) {
        self.cheer_scale_push_mark = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_scale_pull_mark = 16;

    pub fn cheer_scale_pull_mark(&self) -> u32 {
        self.cheer_scale_pull_mark.unwrap_or(0)
    }

    pub fn clear_cheer_scale_pull_mark(&mut self) {
        self.cheer_scale_pull_mark = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_pull_mark(&self) -> bool {
        self.cheer_scale_pull_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_pull_mark(&mut self, v: u32) {
        self.cheer_scale_pull_mark = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_pct_of_max_cps_clamp = 17;

    pub fn cheer_scale_pct_of_max_cps_clamp(&self) -> f32 {
        self.cheer_scale_pct_of_max_cps_clamp.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_pct_of_max_cps_clamp(&mut self) {
        self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_pct_of_max_cps_clamp(&self) -> bool {
        self.cheer_scale_pct_of_max_cps_clamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_pct_of_max_cps_clamp(&mut self, v: f32) {
        self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_dampener_value = 21;

    pub fn cheer_scale_dampener_value(&self) -> f32 {
        self.cheer_scale_dampener_value.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_dampener_value(&mut self) {
        self.cheer_scale_dampener_value = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_dampener_value(&self) -> bool {
        self.cheer_scale_dampener_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_dampener_value(&mut self, v: f32) {
        self.cheer_scale_dampener_value = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_scale_dampener_lerp_time = 22;

    pub fn cheer_scale_dampener_lerp_time(&self) -> u32 {
        self.cheer_scale_dampener_lerp_time.unwrap_or(0)
    }

    pub fn clear_cheer_scale_dampener_lerp_time(&mut self) {
        self.cheer_scale_dampener_lerp_time = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_dampener_lerp_time(&self) -> bool {
        self.cheer_scale_dampener_lerp_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_dampener_lerp_time(&mut self, v: u32) {
        self.cheer_scale_dampener_lerp_time = ::std::option::Option::Some(v);
    }

    // optional float cheer_factor_bronze = 18;

    pub fn cheer_factor_bronze(&self) -> f32 {
        self.cheer_factor_bronze.unwrap_or(0.)
    }

    pub fn clear_cheer_factor_bronze(&mut self) {
        self.cheer_factor_bronze = ::std::option::Option::None;
    }

    pub fn has_cheer_factor_bronze(&self) -> bool {
        self.cheer_factor_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_factor_bronze(&mut self, v: f32) {
        self.cheer_factor_bronze = ::std::option::Option::Some(v);
    }

    // optional float cheer_factor_silver = 19;

    pub fn cheer_factor_silver(&self) -> f32 {
        self.cheer_factor_silver.unwrap_or(0.)
    }

    pub fn clear_cheer_factor_silver(&mut self) {
        self.cheer_factor_silver = ::std::option::Option::None;
    }

    pub fn has_cheer_factor_silver(&self) -> bool {
        self.cheer_factor_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_factor_silver(&mut self, v: f32) {
        self.cheer_factor_silver = ::std::option::Option::Some(v);
    }

    // optional float cheer_factor_gold = 20;

    pub fn cheer_factor_gold(&self) -> f32 {
        self.cheer_factor_gold.unwrap_or(0.)
    }

    pub fn clear_cheer_factor_gold(&mut self) {
        self.cheer_factor_gold = ::std::option::Option::None;
    }

    pub fn has_cheer_factor_gold(&self) -> bool {
        self.cheer_factor_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_factor_gold(&mut self, v: f32) {
        self.cheer_factor_gold = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheers_enabled",
            |m: &CMsgCheerConfig| { &m.cheers_enabled },
            |m: &mut CMsgCheerConfig| { &mut m.cheers_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_valid_league_id",
            |m: &CMsgCheerConfig| { &m.is_valid_league_id },
            |m: &mut CMsgCheerConfig| { &mut m.is_valid_league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "window_duration",
            |m: &CMsgCheerConfig| { &m.window_duration },
            |m: &mut CMsgCheerConfig| { &mut m.window_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "window_bucket_count",
            |m: &CMsgCheerConfig| { &m.window_bucket_count },
            |m: &mut CMsgCheerConfig| { &mut m.window_bucket_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crowd_level_push_time",
            |m: &CMsgCheerConfig| { &m.crowd_level_push_time },
            |m: &mut CMsgCheerConfig| { &mut m.crowd_level_push_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crowd_level_low",
            |m: &CMsgCheerConfig| { &m.crowd_level_low },
            |m: &mut CMsgCheerConfig| { &mut m.crowd_level_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crowd_level_medium",
            |m: &CMsgCheerConfig| { &m.crowd_level_medium },
            |m: &mut CMsgCheerConfig| { &mut m.crowd_level_medium },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crowd_level_high",
            |m: &CMsgCheerConfig| { &m.crowd_level_high },
            |m: &mut CMsgCheerConfig| { &mut m.crowd_level_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale_start",
            |m: &CMsgCheerConfig| { &m.cheer_scale_start },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_scale_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale_speed",
            |m: &CMsgCheerConfig| { &m.cheer_scale_speed },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_scale_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale_push_mark",
            |m: &CMsgCheerConfig| { &m.cheer_scale_push_mark },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_scale_push_mark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale_pull_mark",
            |m: &CMsgCheerConfig| { &m.cheer_scale_pull_mark },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_scale_pull_mark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale_pct_of_max_cps_clamp",
            |m: &CMsgCheerConfig| { &m.cheer_scale_pct_of_max_cps_clamp },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_scale_pct_of_max_cps_clamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale_dampener_value",
            |m: &CMsgCheerConfig| { &m.cheer_scale_dampener_value },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_scale_dampener_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale_dampener_lerp_time",
            |m: &CMsgCheerConfig| { &m.cheer_scale_dampener_lerp_time },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_scale_dampener_lerp_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_factor_bronze",
            |m: &CMsgCheerConfig| { &m.cheer_factor_bronze },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_factor_bronze },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_factor_silver",
            |m: &CMsgCheerConfig| { &m.cheer_factor_silver },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_factor_silver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_factor_gold",
            |m: &CMsgCheerConfig| { &m.cheer_factor_gold },
            |m: &mut CMsgCheerConfig| { &mut m.cheer_factor_gold },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCheerConfig>(
            "CMsgCheerConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCheerConfig {
    const NAME: &'static str = "CMsgCheerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cheers_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_valid_league_id = ::std::option::Option::Some(is.read_bool()?);
                },
                29 => {
                    self.window_duration = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.window_bucket_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.crowd_level_push_time = ::std::option::Option::Some(is.read_float()?);
                },
                80 => {
                    self.crowd_level_low = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.crowd_level_medium = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.crowd_level_high = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.cheer_scale_start = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.cheer_scale_speed = ::std::option::Option::Some(is.read_float()?);
                },
                120 => {
                    self.cheer_scale_push_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.cheer_scale_pull_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                141 => {
                    self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.cheer_scale_dampener_value = ::std::option::Option::Some(is.read_float()?);
                },
                176 => {
                    self.cheer_scale_dampener_lerp_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                149 => {
                    self.cheer_factor_bronze = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.cheer_factor_silver = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.cheer_factor_gold = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheers_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_valid_league_id {
            my_size += 1 + 1;
        }
        if let Some(v) = self.window_duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.window_bucket_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.crowd_level_push_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.crowd_level_low {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.crowd_level_medium {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.crowd_level_high {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.cheer_scale_start {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cheer_scale_speed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cheer_scale_push_mark {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.cheer_scale_pull_mark {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.cheer_scale_pct_of_max_cps_clamp {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_scale_dampener_value {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_scale_dampener_lerp_time {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.cheer_factor_bronze {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_factor_silver {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_factor_gold {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cheers_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_valid_league_id {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.window_duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.window_bucket_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.crowd_level_push_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.crowd_level_low {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.crowd_level_medium {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.crowd_level_high {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.cheer_scale_start {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.cheer_scale_speed {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.cheer_scale_push_mark {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.cheer_scale_pull_mark {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.cheer_scale_pct_of_max_cps_clamp {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.cheer_scale_dampener_value {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.cheer_scale_dampener_lerp_time {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.cheer_factor_bronze {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.cheer_factor_silver {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.cheer_factor_gold {
            os.write_float(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCheerConfig {
        CMsgCheerConfig::new()
    }

    fn clear(&mut self) {
        self.cheers_enabled = ::std::option::Option::None;
        self.is_valid_league_id = ::std::option::Option::None;
        self.window_duration = ::std::option::Option::None;
        self.window_bucket_count = ::std::option::Option::None;
        self.crowd_level_push_time = ::std::option::Option::None;
        self.crowd_level_low = ::std::option::Option::None;
        self.crowd_level_medium = ::std::option::Option::None;
        self.crowd_level_high = ::std::option::Option::None;
        self.cheer_scale_start = ::std::option::Option::None;
        self.cheer_scale_speed = ::std::option::Option::None;
        self.cheer_scale_push_mark = ::std::option::Option::None;
        self.cheer_scale_pull_mark = ::std::option::Option::None;
        self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::None;
        self.cheer_scale_dampener_value = ::std::option::Option::None;
        self.cheer_scale_dampener_lerp_time = ::std::option::Option::None;
        self.cheer_factor_bronze = ::std::option::Option::None;
        self.cheer_factor_silver = ::std::option::Option::None;
        self.cheer_factor_gold = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCheerConfig {
        static instance: CMsgCheerConfig = CMsgCheerConfig {
            cheers_enabled: ::std::option::Option::None,
            is_valid_league_id: ::std::option::Option::None,
            window_duration: ::std::option::Option::None,
            window_bucket_count: ::std::option::Option::None,
            crowd_level_push_time: ::std::option::Option::None,
            crowd_level_low: ::std::option::Option::None,
            crowd_level_medium: ::std::option::Option::None,
            crowd_level_high: ::std::option::Option::None,
            cheer_scale_start: ::std::option::Option::None,
            cheer_scale_speed: ::std::option::Option::None,
            cheer_scale_push_mark: ::std::option::Option::None,
            cheer_scale_pull_mark: ::std::option::Option::None,
            cheer_scale_pct_of_max_cps_clamp: ::std::option::Option::None,
            cheer_scale_dampener_value: ::std::option::Option::None,
            cheer_scale_dampener_lerp_time: ::std::option::Option::None,
            cheer_factor_bronze: ::std::option::Option::None,
            cheer_factor_silver: ::std::option::Option::None,
            cheer_factor_gold: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCheerConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCheerConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCheerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCheerConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerCheerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerCheerConfig {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerCheerConfig.cheer_config)
    pub cheer_config: ::protobuf::MessageField<CMsgCheerConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerCheerConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerCheerConfig {
    fn default() -> &'a CMsgGCToServerCheerConfig {
        <CMsgGCToServerCheerConfig as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerCheerConfig {
    pub fn new() -> CMsgGCToServerCheerConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCheerConfig>(
            "cheer_config",
            |m: &CMsgGCToServerCheerConfig| { &m.cheer_config },
            |m: &mut CMsgGCToServerCheerConfig| { &mut m.cheer_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerCheerConfig>(
            "CMsgGCToServerCheerConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerCheerConfig {
    const NAME: &'static str = "CMsgGCToServerCheerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cheer_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerCheerConfig {
        CMsgGCToServerCheerConfig::new()
    }

    fn clear(&mut self) {
        self.cheer_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerCheerConfig {
        static instance: CMsgGCToServerCheerConfig = CMsgGCToServerCheerConfig {
            cheer_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerCheerConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerCheerConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerCheerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerCheerConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCGetCheerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetCheerConfig {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCGetCheerConfig.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetCheerConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetCheerConfig {
    fn default() -> &'a CMsgServerToGCGetCheerConfig {
        <CMsgServerToGCGetCheerConfig as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetCheerConfig {
    pub fn new() -> CMsgServerToGCGetCheerConfig {
        ::std::default::Default::default()
    }

    // optional uint32 league_id = 1;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgServerToGCGetCheerConfig| { &m.league_id },
            |m: &mut CMsgServerToGCGetCheerConfig| { &mut m.league_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCGetCheerConfig>(
            "CMsgServerToGCGetCheerConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCGetCheerConfig {
    const NAME: &'static str = "CMsgServerToGCGetCheerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetCheerConfig {
        CMsgServerToGCGetCheerConfig::new()
    }

    fn clear(&mut self) {
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetCheerConfig {
        static instance: CMsgServerToGCGetCheerConfig = CMsgServerToGCGetCheerConfig {
            league_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCGetCheerConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCGetCheerConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCGetCheerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetCheerConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCGetCheerConfigResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetCheerConfigResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCGetCheerConfigResponse.cheer_config)
    pub cheer_config: ::protobuf::MessageField<CMsgCheerConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetCheerConfigResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetCheerConfigResponse {
    fn default() -> &'a CMsgServerToGCGetCheerConfigResponse {
        <CMsgServerToGCGetCheerConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetCheerConfigResponse {
    pub fn new() -> CMsgServerToGCGetCheerConfigResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCheerConfig>(
            "cheer_config",
            |m: &CMsgServerToGCGetCheerConfigResponse| { &m.cheer_config },
            |m: &mut CMsgServerToGCGetCheerConfigResponse| { &mut m.cheer_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCGetCheerConfigResponse>(
            "CMsgServerToGCGetCheerConfigResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCGetCheerConfigResponse {
    const NAME: &'static str = "CMsgServerToGCGetCheerConfigResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cheer_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetCheerConfigResponse {
        CMsgServerToGCGetCheerConfigResponse::new()
    }

    fn clear(&mut self) {
        self.cheer_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetCheerConfigResponse {
        static instance: CMsgServerToGCGetCheerConfigResponse = CMsgServerToGCGetCheerConfigResponse {
            cheer_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCGetCheerConfigResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCGetCheerConfigResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCGetCheerConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetCheerConfigResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerCheerScalesOverride)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerCheerScalesOverride {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerCheerScalesOverride.scales)
    pub scales: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerCheerScalesOverride.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerCheerScalesOverride {
    fn default() -> &'a CMsgGCToServerCheerScalesOverride {
        <CMsgGCToServerCheerScalesOverride as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerCheerScalesOverride {
    pub fn new() -> CMsgGCToServerCheerScalesOverride {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scales",
            |m: &CMsgGCToServerCheerScalesOverride| { &m.scales },
            |m: &mut CMsgGCToServerCheerScalesOverride| { &mut m.scales },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerCheerScalesOverride>(
            "CMsgGCToServerCheerScalesOverride",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerCheerScalesOverride {
    const NAME: &'static str = "CMsgGCToServerCheerScalesOverride";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.scales)?;
                },
                13 => {
                    self.scales.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.scales.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.scales {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerCheerScalesOverride {
        CMsgGCToServerCheerScalesOverride::new()
    }

    fn clear(&mut self) {
        self.scales.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerCheerScalesOverride {
        static instance: CMsgGCToServerCheerScalesOverride = CMsgGCToServerCheerScalesOverride {
            scales: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerCheerScalesOverride {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerCheerScalesOverride").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerCheerScalesOverride {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerCheerScalesOverride {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerGetCheerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerGetCheerState {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerGetCheerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerGetCheerState {
    fn default() -> &'a CMsgGCToServerGetCheerState {
        <CMsgGCToServerGetCheerState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerGetCheerState {
    pub fn new() -> CMsgGCToServerGetCheerState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerGetCheerState>(
            "CMsgGCToServerGetCheerState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerGetCheerState {
    const NAME: &'static str = "CMsgGCToServerGetCheerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerGetCheerState {
        CMsgGCToServerGetCheerState::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerGetCheerState {
        static instance: CMsgGCToServerGetCheerState = CMsgGCToServerGetCheerState {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerGetCheerState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerGetCheerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerGetCheerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerGetCheerState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCheerTypeState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCheerTypeState {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCheerTypeState.cheer_counts)
    pub cheer_counts: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerTypeState.max_per_second)
    pub max_per_second: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerTypeState.cheer_scale)
    pub cheer_scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerTypeState.override_scale)
    pub override_scale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCheerTypeState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCheerTypeState {
    fn default() -> &'a CMsgCheerTypeState {
        <CMsgCheerTypeState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCheerTypeState {
    pub fn new() -> CMsgCheerTypeState {
        ::std::default::Default::default()
    }

    // optional float max_per_second = 2;

    pub fn max_per_second(&self) -> f32 {
        self.max_per_second.unwrap_or(0.)
    }

    pub fn clear_max_per_second(&mut self) {
        self.max_per_second = ::std::option::Option::None;
    }

    pub fn has_max_per_second(&self) -> bool {
        self.max_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_per_second(&mut self, v: f32) {
        self.max_per_second = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale = 3;

    pub fn cheer_scale(&self) -> f32 {
        self.cheer_scale.unwrap_or(0.)
    }

    pub fn clear_cheer_scale(&mut self) {
        self.cheer_scale = ::std::option::Option::None;
    }

    pub fn has_cheer_scale(&self) -> bool {
        self.cheer_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale(&mut self, v: f32) {
        self.cheer_scale = ::std::option::Option::Some(v);
    }

    // optional float override_scale = 4;

    pub fn override_scale(&self) -> f32 {
        self.override_scale.unwrap_or(0.)
    }

    pub fn clear_override_scale(&mut self) {
        self.override_scale = ::std::option::Option::None;
    }

    pub fn has_override_scale(&self) -> bool {
        self.override_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_scale(&mut self, v: f32) {
        self.override_scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cheer_counts",
            |m: &CMsgCheerTypeState| { &m.cheer_counts },
            |m: &mut CMsgCheerTypeState| { &mut m.cheer_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_per_second",
            |m: &CMsgCheerTypeState| { &m.max_per_second },
            |m: &mut CMsgCheerTypeState| { &mut m.max_per_second },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_scale",
            |m: &CMsgCheerTypeState| { &m.cheer_scale },
            |m: &mut CMsgCheerTypeState| { &mut m.cheer_scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_scale",
            |m: &CMsgCheerTypeState| { &m.override_scale },
            |m: &mut CMsgCheerTypeState| { &mut m.override_scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCheerTypeState>(
            "CMsgCheerTypeState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCheerTypeState {
    const NAME: &'static str = "CMsgCheerTypeState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.cheer_counts)?;
                },
                8 => {
                    self.cheer_counts.push(is.read_uint32()?);
                },
                21 => {
                    self.max_per_second = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.cheer_scale = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.override_scale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cheer_counts {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.max_per_second {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cheer_scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.override_scale {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cheer_counts {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.max_per_second {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.cheer_scale {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.override_scale {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCheerTypeState {
        CMsgCheerTypeState::new()
    }

    fn clear(&mut self) {
        self.cheer_counts.clear();
        self.max_per_second = ::std::option::Option::None;
        self.cheer_scale = ::std::option::Option::None;
        self.override_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCheerTypeState {
        static instance: CMsgCheerTypeState = CMsgCheerTypeState {
            cheer_counts: ::std::vec::Vec::new(),
            max_per_second: ::std::option::Option::None,
            cheer_scale: ::std::option::Option::None,
            override_scale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCheerTypeState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCheerTypeState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCheerTypeState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCheerTypeState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCheerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCheerState {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCheerState.cheer_types)
    pub cheer_types: ::std::vec::Vec<CMsgCheerTypeState>,
    // @@protoc_insertion_point(field:dota.CMsgCheerState.radiant_crowd_level)
    pub radiant_crowd_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCheerState.dire_crowd_level)
    pub dire_crowd_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCheerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCheerState {
    fn default() -> &'a CMsgCheerState {
        <CMsgCheerState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCheerState {
    pub fn new() -> CMsgCheerState {
        ::std::default::Default::default()
    }

    // optional uint32 radiant_crowd_level = 2;

    pub fn radiant_crowd_level(&self) -> u32 {
        self.radiant_crowd_level.unwrap_or(0)
    }

    pub fn clear_radiant_crowd_level(&mut self) {
        self.radiant_crowd_level = ::std::option::Option::None;
    }

    pub fn has_radiant_crowd_level(&self) -> bool {
        self.radiant_crowd_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_crowd_level(&mut self, v: u32) {
        self.radiant_crowd_level = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_crowd_level = 3;

    pub fn dire_crowd_level(&self) -> u32 {
        self.dire_crowd_level.unwrap_or(0)
    }

    pub fn clear_dire_crowd_level(&mut self) {
        self.dire_crowd_level = ::std::option::Option::None;
    }

    pub fn has_dire_crowd_level(&self) -> bool {
        self.dire_crowd_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_crowd_level(&mut self, v: u32) {
        self.dire_crowd_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cheer_types",
            |m: &CMsgCheerState| { &m.cheer_types },
            |m: &mut CMsgCheerState| { &mut m.cheer_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_crowd_level",
            |m: &CMsgCheerState| { &m.radiant_crowd_level },
            |m: &mut CMsgCheerState| { &mut m.radiant_crowd_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_crowd_level",
            |m: &CMsgCheerState| { &m.dire_crowd_level },
            |m: &mut CMsgCheerState| { &mut m.dire_crowd_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCheerState>(
            "CMsgCheerState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCheerState {
    const NAME: &'static str = "CMsgCheerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cheer_types.push(is.read_message()?);
                },
                16 => {
                    self.radiant_crowd_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.dire_crowd_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cheer_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.radiant_crowd_level {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.dire_crowd_level {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cheer_types {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.radiant_crowd_level {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.dire_crowd_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCheerState {
        CMsgCheerState::new()
    }

    fn clear(&mut self) {
        self.cheer_types.clear();
        self.radiant_crowd_level = ::std::option::Option::None;
        self.dire_crowd_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCheerState {
        static instance: CMsgCheerState = CMsgCheerState {
            cheer_types: ::std::vec::Vec::new(),
            radiant_crowd_level: ::std::option::Option::None,
            dire_crowd_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCheerState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCheerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCheerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCheerState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCReportCheerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCReportCheerState {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCReportCheerState.cheer_config)
    pub cheer_config: ::protobuf::MessageField<CMsgCheerConfig>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCReportCheerState.cheer_state)
    pub cheer_state: ::protobuf::MessageField<CMsgCheerState>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCReportCheerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCReportCheerState {
    fn default() -> &'a CMsgServerToGCReportCheerState {
        <CMsgServerToGCReportCheerState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCReportCheerState {
    pub fn new() -> CMsgServerToGCReportCheerState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCheerConfig>(
            "cheer_config",
            |m: &CMsgServerToGCReportCheerState| { &m.cheer_config },
            |m: &mut CMsgServerToGCReportCheerState| { &mut m.cheer_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCheerState>(
            "cheer_state",
            |m: &CMsgServerToGCReportCheerState| { &m.cheer_state },
            |m: &mut CMsgServerToGCReportCheerState| { &mut m.cheer_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCReportCheerState>(
            "CMsgServerToGCReportCheerState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCReportCheerState {
    const NAME: &'static str = "CMsgServerToGCReportCheerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_config)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cheer_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cheer_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.cheer_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCReportCheerState {
        CMsgServerToGCReportCheerState::new()
    }

    fn clear(&mut self) {
        self.cheer_config.clear();
        self.cheer_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCReportCheerState {
        static instance: CMsgServerToGCReportCheerState = CMsgServerToGCReportCheerState {
            cheer_config: ::protobuf::MessageField::none(),
            cheer_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCReportCheerState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCReportCheerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCReportCheerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCReportCheerState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCGetStickerHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetStickerHeroes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCGetStickerHeroes.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetStickerHeroes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetStickerHeroes {
    fn default() -> &'a CMsgServerToGCGetStickerHeroes {
        <CMsgServerToGCGetStickerHeroes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetStickerHeroes {
    pub fn new() -> CMsgServerToGCGetStickerHeroes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgServerToGCGetStickerHeroes| { &m.account_ids },
            |m: &mut CMsgServerToGCGetStickerHeroes| { &mut m.account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCGetStickerHeroes>(
            "CMsgServerToGCGetStickerHeroes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCGetStickerHeroes {
    const NAME: &'static str = "CMsgServerToGCGetStickerHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetStickerHeroes {
        CMsgServerToGCGetStickerHeroes::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetStickerHeroes {
        static instance: CMsgServerToGCGetStickerHeroes = CMsgServerToGCGetStickerHeroes {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCGetStickerHeroes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCGetStickerHeroes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCGetStickerHeroes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetStickerHeroes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCGetStickerHeroesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetStickerHeroesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCGetStickerHeroesResponse.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcget_sticker_heroes_response::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetStickerHeroesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetStickerHeroesResponse {
    fn default() -> &'a CMsgServerToGCGetStickerHeroesResponse {
        <CMsgServerToGCGetStickerHeroesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetStickerHeroesResponse {
    pub fn new() -> CMsgServerToGCGetStickerHeroesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgServerToGCGetStickerHeroesResponse| { &m.players },
            |m: &mut CMsgServerToGCGetStickerHeroesResponse| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCGetStickerHeroesResponse>(
            "CMsgServerToGCGetStickerHeroesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCGetStickerHeroesResponse {
    const NAME: &'static str = "CMsgServerToGCGetStickerHeroesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetStickerHeroesResponse {
        CMsgServerToGCGetStickerHeroesResponse::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetStickerHeroesResponse {
        static instance: CMsgServerToGCGetStickerHeroesResponse = CMsgServerToGCGetStickerHeroesResponse {
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCGetStickerHeroesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCGetStickerHeroesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCGetStickerHeroesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetStickerHeroesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCGetStickerHeroesResponse`
pub mod cmsg_server_to_gcget_sticker_heroes_response {
    // @@protoc_insertion_point(message:dota.CMsgServerToGCGetStickerHeroesResponse.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetStickerHeroesResponse.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgServerToGCGetStickerHeroesResponse.Player.stickers)
        pub stickers: ::protobuf::MessageField<super::super::dota_gcmessages_common::CMsgStickerHeroes>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgServerToGCGetStickerHeroesResponse.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::dota_gcmessages_common::CMsgStickerHeroes>(
                "stickers",
                |m: &Player| { &m.stickers },
                |m: &mut Player| { &mut m.stickers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgServerToGCGetStickerHeroesResponse.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickers)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stickers.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stickers.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.stickers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                stickers: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerToGCGetStickerHeroesResponse.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerSetSteamLearnDisable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerSetSteamLearnDisable {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerSetSteamLearnDisable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerSetSteamLearnDisable {
    fn default() -> &'a CMsgGCToServerSetSteamLearnDisable {
        <CMsgGCToServerSetSteamLearnDisable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerSetSteamLearnDisable {
    pub fn new() -> CMsgGCToServerSetSteamLearnDisable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerSetSteamLearnDisable>(
            "CMsgGCToServerSetSteamLearnDisable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerSetSteamLearnDisable {
    const NAME: &'static str = "CMsgGCToServerSetSteamLearnDisable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerSetSteamLearnDisable {
        CMsgGCToServerSetSteamLearnDisable::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerSetSteamLearnDisable {
        static instance: CMsgGCToServerSetSteamLearnDisable = CMsgGCToServerSetSteamLearnDisable {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerSetSteamLearnDisable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerSetSteamLearnDisable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerSetSteamLearnDisable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerSetSteamLearnDisable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerSetSteamLearnInferencing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerSetSteamLearnInferencing {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerSetSteamLearnInferencing.enable)
    pub enable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerSetSteamLearnInferencing.project_id)
    pub project_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerSetSteamLearnInferencing.published_version)
    pub published_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToServerSetSteamLearnInferencing.hmac_key)
    pub hmac_key: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerSetSteamLearnInferencing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerSetSteamLearnInferencing {
    fn default() -> &'a CMsgGCToServerSetSteamLearnInferencing {
        <CMsgGCToServerSetSteamLearnInferencing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerSetSteamLearnInferencing {
    pub fn new() -> CMsgGCToServerSetSteamLearnInferencing {
        ::std::default::Default::default()
    }

    // optional bool enable = 1;

    pub fn enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }

    // optional uint32 project_id = 2;

    pub fn project_id(&self) -> u32 {
        self.project_id.unwrap_or(0)
    }

    pub fn clear_project_id(&mut self) {
        self.project_id = ::std::option::Option::None;
    }

    pub fn has_project_id(&self) -> bool {
        self.project_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: u32) {
        self.project_id = ::std::option::Option::Some(v);
    }

    // optional uint32 published_version = 3;

    pub fn published_version(&self) -> u32 {
        self.published_version.unwrap_or(0)
    }

    pub fn clear_published_version(&mut self) {
        self.published_version = ::std::option::Option::None;
    }

    pub fn has_published_version(&self) -> bool {
        self.published_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_version(&mut self, v: u32) {
        self.published_version = ::std::option::Option::Some(v);
    }

    // optional string hmac_key = 4;

    pub fn hmac_key(&self) -> &str {
        match self.hmac_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hmac_key(&mut self) {
        self.hmac_key = ::std::option::Option::None;
    }

    pub fn has_hmac_key(&self) -> bool {
        self.hmac_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmac_key(&mut self, v: ::std::string::String) {
        self.hmac_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hmac_key(&mut self) -> &mut ::std::string::String {
        if self.hmac_key.is_none() {
            self.hmac_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hmac_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_hmac_key(&mut self) -> ::std::string::String {
        self.hmac_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable",
            |m: &CMsgGCToServerSetSteamLearnInferencing| { &m.enable },
            |m: &mut CMsgGCToServerSetSteamLearnInferencing| { &mut m.enable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "project_id",
            |m: &CMsgGCToServerSetSteamLearnInferencing| { &m.project_id },
            |m: &mut CMsgGCToServerSetSteamLearnInferencing| { &mut m.project_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_version",
            |m: &CMsgGCToServerSetSteamLearnInferencing| { &m.published_version },
            |m: &mut CMsgGCToServerSetSteamLearnInferencing| { &mut m.published_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hmac_key",
            |m: &CMsgGCToServerSetSteamLearnInferencing| { &m.hmac_key },
            |m: &mut CMsgGCToServerSetSteamLearnInferencing| { &mut m.hmac_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerSetSteamLearnInferencing>(
            "CMsgGCToServerSetSteamLearnInferencing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerSetSteamLearnInferencing {
    const NAME: &'static str = "CMsgGCToServerSetSteamLearnInferencing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enable = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.project_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.published_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.hmac_key = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.project_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.published_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hmac_key.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.project_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.published_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hmac_key.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerSetSteamLearnInferencing {
        CMsgGCToServerSetSteamLearnInferencing::new()
    }

    fn clear(&mut self) {
        self.enable = ::std::option::Option::None;
        self.project_id = ::std::option::Option::None;
        self.published_version = ::std::option::Option::None;
        self.hmac_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerSetSteamLearnInferencing {
        static instance: CMsgGCToServerSetSteamLearnInferencing = CMsgGCToServerSetSteamLearnInferencing {
            enable: ::std::option::Option::None,
            project_id: ::std::option::Option::None,
            published_version: ::std::option::Option::None,
            hmac_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerSetSteamLearnInferencing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerSetSteamLearnInferencing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerSetSteamLearnInferencing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerSetSteamLearnInferencing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerSetSteamLearnKeysChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerSetSteamLearnKeysChanged {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerSetSteamLearnKeysChanged.keys)
    pub keys: ::protobuf::MessageField<super::steammessages_steamlearn_steamworkssdk::CMsgSteamLearnHMACKeys>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerSetSteamLearnKeysChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerSetSteamLearnKeysChanged {
    fn default() -> &'a CMsgGCToServerSetSteamLearnKeysChanged {
        <CMsgGCToServerSetSteamLearnKeysChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerSetSteamLearnKeysChanged {
    pub fn new() -> CMsgGCToServerSetSteamLearnKeysChanged {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_steamlearn_steamworkssdk::CMsgSteamLearnHMACKeys>(
            "keys",
            |m: &CMsgGCToServerSetSteamLearnKeysChanged| { &m.keys },
            |m: &mut CMsgGCToServerSetSteamLearnKeysChanged| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerSetSteamLearnKeysChanged>(
            "CMsgGCToServerSetSteamLearnKeysChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerSetSteamLearnKeysChanged {
    const NAME: &'static str = "CMsgGCToServerSetSteamLearnKeysChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keys)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keys.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerSetSteamLearnKeysChanged {
        CMsgGCToServerSetSteamLearnKeysChanged::new()
    }

    fn clear(&mut self) {
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerSetSteamLearnKeysChanged {
        static instance: CMsgGCToServerSetSteamLearnKeysChanged = CMsgGCToServerSetSteamLearnKeysChanged {
            keys: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerSetSteamLearnKeysChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerSetSteamLearnKeysChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerSetSteamLearnKeysChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerSetSteamLearnKeysChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnMatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfo.average_mmr)
    pub average_mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfo.radiant_won)
    pub radiant_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfo.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfo.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnMatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchInfo {
    fn default() -> &'a CMsgSteamLearnMatchInfo {
        <CMsgSteamLearnMatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchInfo {
    pub fn new() -> CMsgSteamLearnMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint32 average_mmr = 1;

    pub fn average_mmr(&self) -> u32 {
        self.average_mmr.unwrap_or(0)
    }

    pub fn clear_average_mmr(&mut self) {
        self.average_mmr = ::std::option::Option::None;
    }

    pub fn has_average_mmr(&self) -> bool {
        self.average_mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_mmr(&mut self, v: u32) {
        self.average_mmr = ::std::option::Option::Some(v);
    }

    // optional bool radiant_won = 2;

    pub fn radiant_won(&self) -> bool {
        self.radiant_won.unwrap_or(false)
    }

    pub fn clear_radiant_won(&mut self) {
        self.radiant_won = ::std::option::Option::None;
    }

    pub fn has_radiant_won(&self) -> bool {
        self.radiant_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_won(&mut self, v: bool) {
        self.radiant_won = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 4;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 5;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_mmr",
            |m: &CMsgSteamLearnMatchInfo| { &m.average_mmr },
            |m: &mut CMsgSteamLearnMatchInfo| { &mut m.average_mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_won",
            |m: &CMsgSteamLearnMatchInfo| { &m.radiant_won },
            |m: &mut CMsgSteamLearnMatchInfo| { &mut m.radiant_won },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgSteamLearnMatchInfo| { &m.duration },
            |m: &mut CMsgSteamLearnMatchInfo| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgSteamLearnMatchInfo| { &m.game_mode },
            |m: &mut CMsgSteamLearnMatchInfo| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgSteamLearnMatchInfo| { &m.lobby_type },
            |m: &mut CMsgSteamLearnMatchInfo| { &mut m.lobby_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnMatchInfo>(
            "CMsgSteamLearnMatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnMatchInfo {
    const NAME: &'static str = "CMsgSteamLearnMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.average_mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.radiant_won = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_mmr {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.radiant_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.average_mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.radiant_won {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchInfo {
        CMsgSteamLearnMatchInfo::new()
    }

    fn clear(&mut self) {
        self.average_mmr = ::std::option::Option::None;
        self.radiant_won = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchInfo {
        static instance: CMsgSteamLearnMatchInfo = CMsgSteamLearnMatchInfo {
            average_mmr: ::std::option::Option::None,
            radiant_won: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnMatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnMatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnMatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnMatchInfoPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchInfoPlayer {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfoPlayer.average_mmr)
    pub average_mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfoPlayer.team_won)
    pub team_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfoPlayer.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfoPlayer.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchInfoPlayer.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnMatchInfoPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchInfoPlayer {
    fn default() -> &'a CMsgSteamLearnMatchInfoPlayer {
        <CMsgSteamLearnMatchInfoPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchInfoPlayer {
    pub fn new() -> CMsgSteamLearnMatchInfoPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 average_mmr = 1;

    pub fn average_mmr(&self) -> u32 {
        self.average_mmr.unwrap_or(0)
    }

    pub fn clear_average_mmr(&mut self) {
        self.average_mmr = ::std::option::Option::None;
    }

    pub fn has_average_mmr(&self) -> bool {
        self.average_mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_mmr(&mut self, v: u32) {
        self.average_mmr = ::std::option::Option::Some(v);
    }

    // optional bool team_won = 2;

    pub fn team_won(&self) -> bool {
        self.team_won.unwrap_or(false)
    }

    pub fn clear_team_won(&mut self) {
        self.team_won = ::std::option::Option::None;
    }

    pub fn has_team_won(&self) -> bool {
        self.team_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_won(&mut self, v: bool) {
        self.team_won = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 4;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 5;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_mmr",
            |m: &CMsgSteamLearnMatchInfoPlayer| { &m.average_mmr },
            |m: &mut CMsgSteamLearnMatchInfoPlayer| { &mut m.average_mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_won",
            |m: &CMsgSteamLearnMatchInfoPlayer| { &m.team_won },
            |m: &mut CMsgSteamLearnMatchInfoPlayer| { &mut m.team_won },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgSteamLearnMatchInfoPlayer| { &m.duration },
            |m: &mut CMsgSteamLearnMatchInfoPlayer| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgSteamLearnMatchInfoPlayer| { &m.game_mode },
            |m: &mut CMsgSteamLearnMatchInfoPlayer| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgSteamLearnMatchInfoPlayer| { &m.lobby_type },
            |m: &mut CMsgSteamLearnMatchInfoPlayer| { &mut m.lobby_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnMatchInfoPlayer>(
            "CMsgSteamLearnMatchInfoPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnMatchInfoPlayer {
    const NAME: &'static str = "CMsgSteamLearnMatchInfoPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.average_mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.team_won = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_mmr {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.team_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.average_mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_won {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchInfoPlayer {
        CMsgSteamLearnMatchInfoPlayer::new()
    }

    fn clear(&mut self) {
        self.average_mmr = ::std::option::Option::None;
        self.team_won = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchInfoPlayer {
        static instance: CMsgSteamLearnMatchInfoPlayer = CMsgSteamLearnMatchInfoPlayer {
            average_mmr: ::std::option::Option::None,
            team_won: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnMatchInfoPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnMatchInfoPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnMatchInfoPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnMatchInfoPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnMatchHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchHeroes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHeroes.radiant_hero_ids)
    pub radiant_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHeroes.dire_hero_ids)
    pub dire_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHeroes.radiant_lanes)
    pub radiant_lanes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHeroes.dire_lanes)
    pub dire_lanes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnMatchHeroes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchHeroes {
    fn default() -> &'a CMsgSteamLearnMatchHeroes {
        <CMsgSteamLearnMatchHeroes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchHeroes {
    pub fn new() -> CMsgSteamLearnMatchHeroes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "radiant_hero_ids",
            |m: &CMsgSteamLearnMatchHeroes| { &m.radiant_hero_ids },
            |m: &mut CMsgSteamLearnMatchHeroes| { &mut m.radiant_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dire_hero_ids",
            |m: &CMsgSteamLearnMatchHeroes| { &m.dire_hero_ids },
            |m: &mut CMsgSteamLearnMatchHeroes| { &mut m.dire_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "radiant_lanes",
            |m: &CMsgSteamLearnMatchHeroes| { &m.radiant_lanes },
            |m: &mut CMsgSteamLearnMatchHeroes| { &mut m.radiant_lanes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dire_lanes",
            |m: &CMsgSteamLearnMatchHeroes| { &m.dire_lanes },
            |m: &mut CMsgSteamLearnMatchHeroes| { &mut m.dire_lanes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnMatchHeroes>(
            "CMsgSteamLearnMatchHeroes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnMatchHeroes {
    const NAME: &'static str = "CMsgSteamLearnMatchHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.radiant_hero_ids)?;
                },
                8 => {
                    self.radiant_hero_ids.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.dire_hero_ids)?;
                },
                16 => {
                    self.dire_hero_ids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.radiant_lanes)?;
                },
                24 => {
                    self.radiant_lanes.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.dire_lanes)?;
                },
                32 => {
                    self.dire_lanes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.radiant_hero_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.dire_hero_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.radiant_lanes {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.dire_lanes {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.radiant_hero_ids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.dire_hero_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.radiant_lanes {
            os.write_uint32(3, *v)?;
        };
        for v in &self.dire_lanes {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchHeroes {
        CMsgSteamLearnMatchHeroes::new()
    }

    fn clear(&mut self) {
        self.radiant_hero_ids.clear();
        self.dire_hero_ids.clear();
        self.radiant_lanes.clear();
        self.dire_lanes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchHeroes {
        static instance: CMsgSteamLearnMatchHeroes = CMsgSteamLearnMatchHeroes {
            radiant_hero_ids: ::std::vec::Vec::new(),
            dire_hero_ids: ::std::vec::Vec::new(),
            radiant_lanes: ::std::vec::Vec::new(),
            dire_lanes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnMatchHeroes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnMatchHeroes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnMatchHeroes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnMatchHeroes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnMatchHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchHero {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHero.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHero.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHero.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchHero.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnMatchHero.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchHero {
    fn default() -> &'a CMsgSteamLearnMatchHero {
        <CMsgSteamLearnMatchHero as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchHero {
    pub fn new() -> CMsgSteamLearnMatchHero {
        ::std::default::Default::default()
    }

    // optional uint32 hero_id = 1;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgSteamLearnMatchHero| { &m.hero_id },
            |m: &mut CMsgSteamLearnMatchHero| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane",
            |m: &CMsgSteamLearnMatchHero| { &m.lane },
            |m: &mut CMsgSteamLearnMatchHero| { &mut m.lane },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allied_hero_ids",
            |m: &CMsgSteamLearnMatchHero| { &m.allied_hero_ids },
            |m: &mut CMsgSteamLearnMatchHero| { &mut m.allied_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_hero_ids",
            |m: &CMsgSteamLearnMatchHero| { &m.enemy_hero_ids },
            |m: &mut CMsgSteamLearnMatchHero| { &mut m.enemy_hero_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnMatchHero>(
            "CMsgSteamLearnMatchHero",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnMatchHero {
    const NAME: &'static str = "CMsgSteamLearnMatchHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.allied_hero_ids)?;
                },
                24 => {
                    self.allied_hero_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.enemy_hero_ids)?;
                },
                32 => {
                    self.enemy_hero_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_uint32(3, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchHero {
        CMsgSteamLearnMatchHero::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchHero {
        static instance: CMsgSteamLearnMatchHero = CMsgSteamLearnMatchHero {
            hero_id: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnMatchHero {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnMatchHero").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnMatchHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnMatchHero {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnMatchState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchState {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.radiant_state)
    pub radiant_state: ::protobuf::MessageField<cmsg_steam_learn_match_state::TeamState>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.dire_state)
    pub dire_state: ::protobuf::MessageField<cmsg_steam_learn_match_state::TeamState>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnMatchState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchState {
    fn default() -> &'a CMsgSteamLearnMatchState {
        <CMsgSteamLearnMatchState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchState {
    pub fn new() -> CMsgSteamLearnMatchState {
        ::std::default::Default::default()
    }

    // optional float game_time = 1;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_time",
            |m: &CMsgSteamLearnMatchState| { &m.game_time },
            |m: &mut CMsgSteamLearnMatchState| { &mut m.game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_learn_match_state::TeamState>(
            "radiant_state",
            |m: &CMsgSteamLearnMatchState| { &m.radiant_state },
            |m: &mut CMsgSteamLearnMatchState| { &mut m.radiant_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_learn_match_state::TeamState>(
            "dire_state",
            |m: &CMsgSteamLearnMatchState| { &m.dire_state },
            |m: &mut CMsgSteamLearnMatchState| { &mut m.dire_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnMatchState>(
            "CMsgSteamLearnMatchState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnMatchState {
    const NAME: &'static str = "CMsgSteamLearnMatchState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.radiant_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dire_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.radiant_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.dire_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchState {
        CMsgSteamLearnMatchState::new()
    }

    fn clear(&mut self) {
        self.game_time = ::std::option::Option::None;
        self.radiant_state.clear();
        self.dire_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchState {
        static instance: CMsgSteamLearnMatchState = CMsgSteamLearnMatchState {
            game_time: ::std::option::Option::None,
            radiant_state: ::protobuf::MessageField::none(),
            dire_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnMatchState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnMatchState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnMatchState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnMatchState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamLearnMatchState`
pub mod cmsg_steam_learn_match_state {
    // @@protoc_insertion_point(message:dota.CMsgSteamLearnMatchState.PlayerState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerState {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.respawn_time)
        pub respawn_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.has_buyback)
        pub has_buyback: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.has_aegis)
        pub has_aegis: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.has_rapier)
        pub has_rapier: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.PlayerState.distance)
        pub distance: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnMatchState.PlayerState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerState {
        fn default() -> &'a PlayerState {
            <PlayerState as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerState {
        pub fn new() -> PlayerState {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 2;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 3;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 4;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 respawn_time = 5;

        pub fn respawn_time(&self) -> u32 {
            self.respawn_time.unwrap_or(0)
        }

        pub fn clear_respawn_time(&mut self) {
            self.respawn_time = ::std::option::Option::None;
        }

        pub fn has_respawn_time(&self) -> bool {
            self.respawn_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_time(&mut self, v: u32) {
            self.respawn_time = ::std::option::Option::Some(v);
        }

        // optional bool has_buyback = 6;

        pub fn has_buyback(&self) -> bool {
            self.has_buyback.unwrap_or(false)
        }

        pub fn clear_has_buyback(&mut self) {
            self.has_buyback = ::std::option::Option::None;
        }

        pub fn has_has_buyback(&self) -> bool {
            self.has_buyback.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_buyback(&mut self, v: bool) {
            self.has_buyback = ::std::option::Option::Some(v);
        }

        // optional bool has_aegis = 7;

        pub fn has_aegis(&self) -> bool {
            self.has_aegis.unwrap_or(false)
        }

        pub fn clear_has_aegis(&mut self) {
            self.has_aegis = ::std::option::Option::None;
        }

        pub fn has_has_aegis(&self) -> bool {
            self.has_aegis.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_aegis(&mut self, v: bool) {
            self.has_aegis = ::std::option::Option::Some(v);
        }

        // optional bool has_rapier = 8;

        pub fn has_rapier(&self) -> bool {
            self.has_rapier.unwrap_or(false)
        }

        pub fn clear_has_rapier(&mut self) {
            self.has_rapier = ::std::option::Option::None;
        }

        pub fn has_has_rapier(&self) -> bool {
            self.has_rapier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_rapier(&mut self, v: bool) {
            self.has_rapier = ::std::option::Option::Some(v);
        }

        // optional uint32 distance = 9;

        pub fn distance(&self) -> u32 {
            self.distance.unwrap_or(0)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: u32) {
            self.distance = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &PlayerState| { &m.hero_id },
                |m: &mut PlayerState| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &PlayerState| { &m.net_worth },
                |m: &mut PlayerState| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &PlayerState| { &m.level },
                |m: &mut PlayerState| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &PlayerState| { &m.deaths },
                |m: &mut PlayerState| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "respawn_time",
                |m: &PlayerState| { &m.respawn_time },
                |m: &mut PlayerState| { &mut m.respawn_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_buyback",
                |m: &PlayerState| { &m.has_buyback },
                |m: &mut PlayerState| { &mut m.has_buyback },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_aegis",
                |m: &PlayerState| { &m.has_aegis },
                |m: &mut PlayerState| { &mut m.has_aegis },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_rapier",
                |m: &PlayerState| { &m.has_rapier },
                |m: &mut PlayerState| { &mut m.has_rapier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "distance",
                |m: &PlayerState| { &m.distance },
                |m: &mut PlayerState| { &mut m.distance },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerState>(
                "CMsgSteamLearnMatchState.PlayerState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerState {
        const NAME: &'static str = "PlayerState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.respawn_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.has_buyback = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.has_aegis = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.has_rapier = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.distance = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.respawn_time {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.has_buyback {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_aegis {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_rapier {
                my_size += 1 + 1;
            }
            if let Some(v) = self.distance {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.respawn_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.has_buyback {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.has_aegis {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.has_rapier {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.distance {
                os.write_uint32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerState {
            PlayerState::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.respawn_time = ::std::option::Option::None;
            self.has_buyback = ::std::option::Option::None;
            self.has_aegis = ::std::option::Option::None;
            self.has_rapier = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerState {
            static instance: PlayerState = PlayerState {
                hero_id: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                level: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                respawn_time: ::std::option::Option::None,
                has_buyback: ::std::option::Option::None,
                has_aegis: ::std::option::Option::None,
                has_rapier: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearnMatchState.PlayerState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgSteamLearnMatchState.TeamState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamState {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.player_states)
        pub player_states: ::std::vec::Vec<PlayerState>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.tower_health_pct)
        pub tower_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.barracks_health_pct)
        pub barracks_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.ancient_health_pct)
        pub ancient_health_pct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.glyph_cooldown)
        pub glyph_cooldown: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.creep_distance_safe)
        pub creep_distance_safe: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.creep_distance_mid)
        pub creep_distance_mid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnMatchState.TeamState.creep_distance_off)
        pub creep_distance_off: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnMatchState.TeamState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamState {
        fn default() -> &'a TeamState {
            <TeamState as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamState {
        pub fn new() -> TeamState {
            ::std::default::Default::default()
        }

        // optional uint32 team = 1;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 ancient_health_pct = 5;

        pub fn ancient_health_pct(&self) -> u32 {
            self.ancient_health_pct.unwrap_or(0)
        }

        pub fn clear_ancient_health_pct(&mut self) {
            self.ancient_health_pct = ::std::option::Option::None;
        }

        pub fn has_ancient_health_pct(&self) -> bool {
            self.ancient_health_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ancient_health_pct(&mut self, v: u32) {
            self.ancient_health_pct = ::std::option::Option::Some(v);
        }

        // optional uint32 glyph_cooldown = 6;

        pub fn glyph_cooldown(&self) -> u32 {
            self.glyph_cooldown.unwrap_or(0)
        }

        pub fn clear_glyph_cooldown(&mut self) {
            self.glyph_cooldown = ::std::option::Option::None;
        }

        pub fn has_glyph_cooldown(&self) -> bool {
            self.glyph_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_glyph_cooldown(&mut self, v: u32) {
            self.glyph_cooldown = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 7;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_safe = 8;

        pub fn creep_distance_safe(&self) -> u32 {
            self.creep_distance_safe.unwrap_or(0)
        }

        pub fn clear_creep_distance_safe(&mut self) {
            self.creep_distance_safe = ::std::option::Option::None;
        }

        pub fn has_creep_distance_safe(&self) -> bool {
            self.creep_distance_safe.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_safe(&mut self, v: u32) {
            self.creep_distance_safe = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_mid = 9;

        pub fn creep_distance_mid(&self) -> u32 {
            self.creep_distance_mid.unwrap_or(0)
        }

        pub fn clear_creep_distance_mid(&mut self) {
            self.creep_distance_mid = ::std::option::Option::None;
        }

        pub fn has_creep_distance_mid(&self) -> bool {
            self.creep_distance_mid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_mid(&mut self, v: u32) {
            self.creep_distance_mid = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_off = 10;

        pub fn creep_distance_off(&self) -> u32 {
            self.creep_distance_off.unwrap_or(0)
        }

        pub fn clear_creep_distance_off(&mut self) {
            self.creep_distance_off = ::std::option::Option::None;
        }

        pub fn has_creep_distance_off(&self) -> bool {
            self.creep_distance_off.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_off(&mut self, v: u32) {
            self.creep_distance_off = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &TeamState| { &m.team },
                |m: &mut TeamState| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "player_states",
                |m: &TeamState| { &m.player_states },
                |m: &mut TeamState| { &mut m.player_states },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "tower_health_pct",
                |m: &TeamState| { &m.tower_health_pct },
                |m: &mut TeamState| { &mut m.tower_health_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "barracks_health_pct",
                |m: &TeamState| { &m.barracks_health_pct },
                |m: &mut TeamState| { &mut m.barracks_health_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ancient_health_pct",
                |m: &TeamState| { &m.ancient_health_pct },
                |m: &mut TeamState| { &mut m.ancient_health_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "glyph_cooldown",
                |m: &TeamState| { &m.glyph_cooldown },
                |m: &mut TeamState| { &mut m.glyph_cooldown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &TeamState| { &m.kills },
                |m: &mut TeamState| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_distance_safe",
                |m: &TeamState| { &m.creep_distance_safe },
                |m: &mut TeamState| { &mut m.creep_distance_safe },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_distance_mid",
                |m: &TeamState| { &m.creep_distance_mid },
                |m: &mut TeamState| { &mut m.creep_distance_mid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_distance_off",
                |m: &TeamState| { &m.creep_distance_off },
                |m: &mut TeamState| { &mut m.creep_distance_off },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamState>(
                "CMsgSteamLearnMatchState.TeamState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamState {
        const NAME: &'static str = "TeamState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_states.push(is.read_message()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.tower_health_pct)?;
                    },
                    24 => {
                        self.tower_health_pct.push(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.barracks_health_pct)?;
                    },
                    32 => {
                        self.barracks_health_pct.push(is.read_uint32()?);
                    },
                    40 => {
                        self.ancient_health_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.glyph_cooldown = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.creep_distance_safe = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.creep_distance_mid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.creep_distance_off = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.player_states {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.tower_health_pct {
                my_size += ::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.barracks_health_pct {
                my_size += ::protobuf::rt::uint32_size(4, *value);
            };
            if let Some(v) = self.ancient_health_pct {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.glyph_cooldown {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.creep_distance_safe {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.creep_distance_mid {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.creep_distance_off {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(1, v)?;
            }
            for v in &self.player_states {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.tower_health_pct {
                os.write_uint32(3, *v)?;
            };
            for v in &self.barracks_health_pct {
                os.write_uint32(4, *v)?;
            };
            if let Some(v) = self.ancient_health_pct {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.glyph_cooldown {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.creep_distance_safe {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.creep_distance_mid {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.creep_distance_off {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamState {
            TeamState::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.player_states.clear();
            self.tower_health_pct.clear();
            self.barracks_health_pct.clear();
            self.ancient_health_pct = ::std::option::Option::None;
            self.glyph_cooldown = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.creep_distance_safe = ::std::option::Option::None;
            self.creep_distance_mid = ::std::option::Option::None;
            self.creep_distance_off = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamState {
            static instance: TeamState = TeamState {
                team: ::std::option::Option::None,
                player_states: ::std::vec::Vec::new(),
                tower_health_pct: ::std::vec::Vec::new(),
                barracks_health_pct: ::std::vec::Vec::new(),
                ancient_health_pct: ::std::option::Option::None,
                glyph_cooldown: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                creep_distance_safe: ::std::option::Option::None,
                creep_distance_mid: ::std::option::Option::None,
                creep_distance_off: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearnMatchState.TeamState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnItemPurchase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnItemPurchase {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.item_id)
    pub item_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.inventory_items)
    pub inventory_items: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.purchase_history)
    pub purchase_history: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.gold)
    pub gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.net_worth)
    pub net_worth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.is_radiant_team)
    pub is_radiant_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnItemPurchase.is_using_dota_plus)
    pub is_using_dota_plus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnItemPurchase.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnItemPurchase {
    fn default() -> &'a CMsgSteamLearnItemPurchase {
        <CMsgSteamLearnItemPurchase as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnItemPurchase {
    pub fn new() -> CMsgSteamLearnItemPurchase {
        ::std::default::Default::default()
    }

    // optional int32 item_id = 1;

    pub fn item_id(&self) -> i32 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: i32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gold = 4;

    pub fn gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    // optional uint32 net_worth = 5;

    pub fn net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional uint32 is_radiant_team = 6;

    pub fn is_radiant_team(&self) -> u32 {
        self.is_radiant_team.unwrap_or(0)
    }

    pub fn clear_is_radiant_team(&mut self) {
        self.is_radiant_team = ::std::option::Option::None;
    }

    pub fn has_is_radiant_team(&self) -> bool {
        self.is_radiant_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_radiant_team(&mut self, v: u32) {
        self.is_radiant_team = ::std::option::Option::Some(v);
    }

    // optional float game_time = 7;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional bool is_using_dota_plus = 8;

    pub fn is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.unwrap_or(false)
    }

    pub fn clear_is_using_dota_plus(&mut self) {
        self.is_using_dota_plus = ::std::option::Option::None;
    }

    pub fn has_is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_using_dota_plus(&mut self, v: bool) {
        self.is_using_dota_plus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgSteamLearnItemPurchase| { &m.item_id },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inventory_items",
            |m: &CMsgSteamLearnItemPurchase| { &m.inventory_items },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.inventory_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "purchase_history",
            |m: &CMsgSteamLearnItemPurchase| { &m.purchase_history },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.purchase_history },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold",
            |m: &CMsgSteamLearnItemPurchase| { &m.gold },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_worth",
            |m: &CMsgSteamLearnItemPurchase| { &m.net_worth },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.net_worth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_radiant_team",
            |m: &CMsgSteamLearnItemPurchase| { &m.is_radiant_team },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.is_radiant_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_time",
            |m: &CMsgSteamLearnItemPurchase| { &m.game_time },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_using_dota_plus",
            |m: &CMsgSteamLearnItemPurchase| { &m.is_using_dota_plus },
            |m: &mut CMsgSteamLearnItemPurchase| { &mut m.is_using_dota_plus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnItemPurchase>(
            "CMsgSteamLearnItemPurchase",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnItemPurchase {
    const NAME: &'static str = "CMsgSteamLearnItemPurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.inventory_items)?;
                },
                16 => {
                    self.inventory_items.push(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.purchase_history)?;
                },
                24 => {
                    self.purchase_history.push(is.read_int32()?);
                },
                32 => {
                    self.gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.is_radiant_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.is_using_dota_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.inventory_items {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        for value in &self.purchase_history {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.is_radiant_team {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_using_dota_plus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_int32(1, v)?;
        }
        for v in &self.inventory_items {
            os.write_int32(2, *v)?;
        };
        for v in &self.purchase_history {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.gold {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.is_radiant_team {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.is_using_dota_plus {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnItemPurchase {
        CMsgSteamLearnItemPurchase::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.inventory_items.clear();
        self.purchase_history.clear();
        self.gold = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.is_radiant_team = ::std::option::Option::None;
        self.game_time = ::std::option::Option::None;
        self.is_using_dota_plus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnItemPurchase {
        static instance: CMsgSteamLearnItemPurchase = CMsgSteamLearnItemPurchase {
            item_id: ::std::option::Option::None,
            inventory_items: ::std::vec::Vec::new(),
            purchase_history: ::std::vec::Vec::new(),
            gold: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            is_radiant_team: ::std::option::Option::None,
            game_time: ::std::option::Option::None,
            is_using_dota_plus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnItemPurchase {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnItemPurchase").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnItemPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnItemPurchase {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnPreGameItemPurchases)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnPreGameItemPurchases {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnPreGameItemPurchases.item_ids)
    pub item_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnPreGameItemPurchases.is_radiant_team)
    pub is_radiant_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnPreGameItemPurchases.is_using_dota_plus)
    pub is_using_dota_plus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnPreGameItemPurchases.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnPreGameItemPurchases {
    fn default() -> &'a CMsgSteamLearnPreGameItemPurchases {
        <CMsgSteamLearnPreGameItemPurchases as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnPreGameItemPurchases {
    pub fn new() -> CMsgSteamLearnPreGameItemPurchases {
        ::std::default::Default::default()
    }

    // optional uint32 is_radiant_team = 2;

    pub fn is_radiant_team(&self) -> u32 {
        self.is_radiant_team.unwrap_or(0)
    }

    pub fn clear_is_radiant_team(&mut self) {
        self.is_radiant_team = ::std::option::Option::None;
    }

    pub fn has_is_radiant_team(&self) -> bool {
        self.is_radiant_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_radiant_team(&mut self, v: u32) {
        self.is_radiant_team = ::std::option::Option::Some(v);
    }

    // optional bool is_using_dota_plus = 3;

    pub fn is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.unwrap_or(false)
    }

    pub fn clear_is_using_dota_plus(&mut self) {
        self.is_using_dota_plus = ::std::option::Option::None;
    }

    pub fn has_is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_using_dota_plus(&mut self, v: bool) {
        self.is_using_dota_plus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgSteamLearnPreGameItemPurchases| { &m.item_ids },
            |m: &mut CMsgSteamLearnPreGameItemPurchases| { &mut m.item_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_radiant_team",
            |m: &CMsgSteamLearnPreGameItemPurchases| { &m.is_radiant_team },
            |m: &mut CMsgSteamLearnPreGameItemPurchases| { &mut m.is_radiant_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_using_dota_plus",
            |m: &CMsgSteamLearnPreGameItemPurchases| { &m.is_using_dota_plus },
            |m: &mut CMsgSteamLearnPreGameItemPurchases| { &mut m.is_using_dota_plus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnPreGameItemPurchases>(
            "CMsgSteamLearnPreGameItemPurchases",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnPreGameItemPurchases {
    const NAME: &'static str = "CMsgSteamLearnPreGameItemPurchases";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_int32()?);
                },
                16 => {
                    self.is_radiant_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_using_dota_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        if let Some(v) = self.is_radiant_team {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_using_dota_plus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_int32(1, *v)?;
        };
        if let Some(v) = self.is_radiant_team {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_using_dota_plus {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnPreGameItemPurchases {
        CMsgSteamLearnPreGameItemPurchases::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.is_radiant_team = ::std::option::Option::None;
        self.is_using_dota_plus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnPreGameItemPurchases {
        static instance: CMsgSteamLearnPreGameItemPurchases = CMsgSteamLearnPreGameItemPurchases {
            item_ids: ::std::vec::Vec::new(),
            is_radiant_team: ::std::option::Option::None,
            is_using_dota_plus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnPreGameItemPurchases {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnPreGameItemPurchases").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnPreGameItemPurchases {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnPreGameItemPurchases {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnAbilitySkill)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnAbilitySkill {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnAbilitySkill.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnAbilitySkill.skilled_abilities)
    pub skilled_abilities: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnAbilitySkill.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnAbilitySkill.is_using_dota_plus)
    pub is_using_dota_plus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnAbilitySkill.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnAbilitySkill {
    fn default() -> &'a CMsgSteamLearnAbilitySkill {
        <CMsgSteamLearnAbilitySkill as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnAbilitySkill {
    pub fn new() -> CMsgSteamLearnAbilitySkill {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional float game_time = 3;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional bool is_using_dota_plus = 4;

    pub fn is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.unwrap_or(false)
    }

    pub fn clear_is_using_dota_plus(&mut self) {
        self.is_using_dota_plus = ::std::option::Option::None;
    }

    pub fn has_is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_using_dota_plus(&mut self, v: bool) {
        self.is_using_dota_plus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CMsgSteamLearnAbilitySkill| { &m.ability_id },
            |m: &mut CMsgSteamLearnAbilitySkill| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skilled_abilities",
            |m: &CMsgSteamLearnAbilitySkill| { &m.skilled_abilities },
            |m: &mut CMsgSteamLearnAbilitySkill| { &mut m.skilled_abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_time",
            |m: &CMsgSteamLearnAbilitySkill| { &m.game_time },
            |m: &mut CMsgSteamLearnAbilitySkill| { &mut m.game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_using_dota_plus",
            |m: &CMsgSteamLearnAbilitySkill| { &m.is_using_dota_plus },
            |m: &mut CMsgSteamLearnAbilitySkill| { &mut m.is_using_dota_plus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnAbilitySkill>(
            "CMsgSteamLearnAbilitySkill",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnAbilitySkill {
    const NAME: &'static str = "CMsgSteamLearnAbilitySkill";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.skilled_abilities)?;
                },
                16 => {
                    self.skilled_abilities.push(is.read_int32()?);
                },
                29 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.is_using_dota_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.skilled_abilities {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_using_dota_plus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        for v in &self.skilled_abilities {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.game_time {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.is_using_dota_plus {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnAbilitySkill {
        CMsgSteamLearnAbilitySkill::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.skilled_abilities.clear();
        self.game_time = ::std::option::Option::None;
        self.is_using_dota_plus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnAbilitySkill {
        static instance: CMsgSteamLearnAbilitySkill = CMsgSteamLearnAbilitySkill {
            ability_id: ::std::option::Option::None,
            skilled_abilities: ::std::vec::Vec::new(),
            game_time: ::std::option::Option::None,
            is_using_dota_plus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnAbilitySkill {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnAbilitySkill").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnAbilitySkill {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnAbilitySkill {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSteamLearnWardPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnWardPlacement {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnWardPlacement.ward_loc)
    pub ward_loc: ::protobuf::MessageField<cmsg_steam_learn_ward_placement::Location>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnWardPlacement.existing_ward_locs)
    pub existing_ward_locs: ::std::vec::Vec<cmsg_steam_learn_ward_placement::Location>,
    // @@protoc_insertion_point(field:dota.CMsgSteamLearnWardPlacement.team)
    pub team: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnWardPlacement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnWardPlacement {
    fn default() -> &'a CMsgSteamLearnWardPlacement {
        <CMsgSteamLearnWardPlacement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnWardPlacement {
    pub fn new() -> CMsgSteamLearnWardPlacement {
        ::std::default::Default::default()
    }

    // optional uint32 team = 3;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_learn_ward_placement::Location>(
            "ward_loc",
            |m: &CMsgSteamLearnWardPlacement| { &m.ward_loc },
            |m: &mut CMsgSteamLearnWardPlacement| { &mut m.ward_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "existing_ward_locs",
            |m: &CMsgSteamLearnWardPlacement| { &m.existing_ward_locs },
            |m: &mut CMsgSteamLearnWardPlacement| { &mut m.existing_ward_locs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CMsgSteamLearnWardPlacement| { &m.team },
            |m: &mut CMsgSteamLearnWardPlacement| { &mut m.team },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnWardPlacement>(
            "CMsgSteamLearnWardPlacement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnWardPlacement {
    const NAME: &'static str = "CMsgSteamLearnWardPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ward_loc)?;
                },
                18 => {
                    self.existing_ward_locs.push(is.read_message()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ward_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.existing_ward_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ward_loc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.existing_ward_locs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.team {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnWardPlacement {
        CMsgSteamLearnWardPlacement::new()
    }

    fn clear(&mut self) {
        self.ward_loc.clear();
        self.existing_ward_locs.clear();
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnWardPlacement {
        static instance: CMsgSteamLearnWardPlacement = CMsgSteamLearnWardPlacement {
            ward_loc: ::protobuf::MessageField::none(),
            existing_ward_locs: ::std::vec::Vec::new(),
            team: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnWardPlacement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnWardPlacement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnWardPlacement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnWardPlacement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamLearnWardPlacement`
pub mod cmsg_steam_learn_ward_placement {
    // @@protoc_insertion_point(message:dota.CMsgSteamLearnWardPlacement.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnWardPlacement.Location.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgSteamLearnWardPlacement.Location.y)
        pub y: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSteamLearnWardPlacement.Location.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional float x = 1;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 2;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &Location| { &m.x },
                |m: &mut Location| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &Location| { &m.y },
                |m: &mut Location| { &mut m.y },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "CMsgSteamLearnWardPlacement.Location",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.x {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Location {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearnWardPlacement.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Location {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSignOutMuertaMinigame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutMuertaMinigame {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutMuertaMinigame.event_game_data)
    pub event_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutMuertaMinigame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutMuertaMinigame {
    fn default() -> &'a CMsgSignOutMuertaMinigame {
        <CMsgSignOutMuertaMinigame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutMuertaMinigame {
    pub fn new() -> CMsgSignOutMuertaMinigame {
        ::std::default::Default::default()
    }

    // optional bytes event_game_data = 1;

    pub fn event_game_data(&self) -> &[u8] {
        match self.event_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_event_game_data(&mut self) {
        self.event_game_data = ::std::option::Option::None;
    }

    pub fn has_event_game_data(&self) -> bool {
        self.event_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.event_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.event_game_data.is_none() {
            self.event_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.event_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.event_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_game_data",
            |m: &CMsgSignOutMuertaMinigame| { &m.event_game_data },
            |m: &mut CMsgSignOutMuertaMinigame| { &mut m.event_game_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutMuertaMinigame>(
            "CMsgSignOutMuertaMinigame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutMuertaMinigame {
    const NAME: &'static str = "CMsgSignOutMuertaMinigame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_game_data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutMuertaMinigame {
        CMsgSignOutMuertaMinigame::new()
    }

    fn clear(&mut self) {
        self.event_game_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutMuertaMinigame {
        static instance: CMsgSignOutMuertaMinigame = CMsgSignOutMuertaMinigame {
            event_game_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutMuertaMinigame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutMuertaMinigame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutMuertaMinigame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutMuertaMinigame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSignOutMapStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutMapStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSignOutMapStats.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_map_stats::Player>,
    // @@protoc_insertion_point(field:dota.CMsgSignOutMapStats.global_stats)
    pub global_stats: ::protobuf::MessageField<super::dota_gcmessages_common::CMsgMapStatsSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSignOutMapStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutMapStats {
    fn default() -> &'a CMsgSignOutMapStats {
        <CMsgSignOutMapStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutMapStats {
    pub fn new() -> CMsgSignOutMapStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgSignOutMapStats| { &m.players },
            |m: &mut CMsgSignOutMapStats| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common::CMsgMapStatsSnapshot>(
            "global_stats",
            |m: &CMsgSignOutMapStats| { &m.global_stats },
            |m: &mut CMsgSignOutMapStats| { &mut m.global_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSignOutMapStats>(
            "CMsgSignOutMapStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSignOutMapStats {
    const NAME: &'static str = "CMsgSignOutMapStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.global_stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.global_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutMapStats {
        CMsgSignOutMapStats::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.global_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutMapStats {
        static instance: CMsgSignOutMapStats = CMsgSignOutMapStats {
            players: ::std::vec::Vec::new(),
            global_stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSignOutMapStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSignOutMapStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSignOutMapStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutMapStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSignOutMapStats`
pub mod cmsg_sign_out_map_stats {
    // @@protoc_insertion_point(message:dota.CMsgSignOutMapStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSignOutMapStats.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSignOutMapStats.Player.personal_stats)
        pub personal_stats: ::protobuf::MessageField<super::super::dota_gcmessages_common::CMsgMapStatsSnapshot>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSignOutMapStats.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::dota_gcmessages_common::CMsgMapStatsSnapshot>(
                "personal_stats",
                |m: &Player| { &m.personal_stats },
                |m: &mut Player| { &mut m.personal_stats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgSignOutMapStats.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.personal_stats)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.personal_stats.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.personal_stats.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.personal_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                personal_stats: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSignOutMapStats.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EPoorNetworkConditionsType)
pub enum EPoorNetworkConditionsType {
    // @@protoc_insertion_point(enum_value:dota.EPoorNetworkConditionsType.k_EPoorNetworkConditions_None)
    k_EPoorNetworkConditions_None = 0,
    // @@protoc_insertion_point(enum_value:dota.EPoorNetworkConditionsType.k_EPoorNetworkConditions_Unknown)
    k_EPoorNetworkConditions_Unknown = 1,
    // @@protoc_insertion_point(enum_value:dota.EPoorNetworkConditionsType.k_EPoorNetworkConditions_MassDisconnect)
    k_EPoorNetworkConditions_MassDisconnect = 2,
    // @@protoc_insertion_point(enum_value:dota.EPoorNetworkConditionsType.k_EPoorNetworkConditions_ExcessBadQosIntervals)
    k_EPoorNetworkConditions_ExcessBadQosIntervals = 3,
}

impl ::protobuf::Enum for EPoorNetworkConditionsType {
    const NAME: &'static str = "EPoorNetworkConditionsType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPoorNetworkConditionsType> {
        match value {
            0 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None),
            1 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown),
            2 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect),
            3 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPoorNetworkConditionsType> {
        match str {
            "k_EPoorNetworkConditions_None" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None),
            "k_EPoorNetworkConditions_Unknown" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown),
            "k_EPoorNetworkConditions_MassDisconnect" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect),
            "k_EPoorNetworkConditions_ExcessBadQosIntervals" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPoorNetworkConditionsType] = &[
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_None,
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown,
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect,
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals,
    ];
}

impl ::protobuf::EnumFull for EPoorNetworkConditionsType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPoorNetworkConditionsType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPoorNetworkConditionsType {
    fn default() -> Self {
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_None
    }
}

impl EPoorNetworkConditionsType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPoorNetworkConditionsType>("EPoorNetworkConditionsType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cdota_gcmessages_server.proto\x12\x04dota\x1a\x13steammessages.prot\
    o\x1a\x15valveextensions.proto\x1a\x17dota_shared_enums.proto\x1a\x1cdot\
    a_gcmessages_common.proto\x1a\x15econ_gcmessages.proto\x1a\x18network_co\
    nnection.proto\x1a\"dota_gcmessages_common_lobby.proto\x1a-dota_gcmessag\
    es_common_match_management.proto\x1a\x16gcsdk_gcmessages.proto\x1a,steam\
    messages_steamlearn.steamworkssdk.proto\"\xf0\x02\n\x19CMsgPoorNetworkCo\
    nditions\x12G\n\x0edetection_type\x18\x01\x20\x01(\x0e2\x20.dota.EPoorNe\
    tworkConditionsTypeR\rdetectionType\x12@\n\x07players\x18\x02\x20\x03(\
    \x0b2&.dota.CMsgPoorNetworkConditions.PlayerR\x07players\x1a\xc7\x01\n\
    \x06Player\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12N\n\
    \x11disconnect_reason\x18\x02\x20\x01(\x0e2!.dota.ENetworkDisconnectionR\
    easonR\x10disconnectReason\x12*\n\x11num_bad_intervals\x18\x03\x20\x01(\
    \rR\x0fnumBadIntervals\x12\"\n\rpeak_loss_pct\x18\x04\x20\x01(\rR\x0bpea\
    kLossPct\"\xc6\x03\n\x13CMsgGameserverCrash\x12\x19\n\x08match_id\x18\
    \x01\x20\x01(\x04R\x07matchId\x12\x19\n\x08lobby_id\x18\x02\x20\x01(\x06\
    R\x07lobbyId\x123\n\ngame_state\x18\x03\x20\x01(\x0e2\x14.dota.DOTA_Game\
    StateR\tgameState\x12,\n\x12sentinel_save_time\x18\x04\x20\x01(\x07R\x10\
    sentinelSaveTime\x12$\n\x0ecustom_game_id\x18\x0b\x20\x01(\x06R\x0ccusto\
    mGameId\x12#\n\rtournament_id\x18\x0c\x20\x01(\rR\x0ctournamentId\x12&\n\
    \x0fserver_steam_id\x18\x05\x20\x01(\x06R\rserverSteamId\x121\n\x15serve\
    r_public_ip_addr\x18\x06\x20\x01(\x07R\x12serverPublicIpAddr\x12\x1f\n\
    \x0bserver_port\x18\x07\x20\x01(\rR\nserverPort\x12%\n\x0eserver_cluster\
    \x18\x08\x20\x01(\rR\rserverCluster\x12\x10\n\x03pid\x18\t\x20\x01(\rR\
    \x03pid\x12\x16\n\x06engine\x18\n\x20\x01(\rR\x06engine\"\xe1\t\n\x14CMs\
    gConnectedPlayers\x12N\n\x11connected_players\x18\x01\x20\x03(\x0b2!.dot\
    a.CMsgConnectedPlayers.PlayerR\x10connectedPlayers\x12T\n\x14disconnecte\
    d_players\x18\x07\x20\x03(\x0b2!.dota.CMsgConnectedPlayers.PlayerR\x13di\
    sconnectedPlayers\x123\n\ngame_state\x18\x02\x20\x01(\x0e2\x14.dota.DOTA\
    _GameStateR\tgameState\x120\n\x14first_blood_happened\x18\x06\x20\x01(\
    \x08R\x12firstBloodHappened\x12W\n\x17poor_network_conditions\x18\n\x20\
    \x01(\x0b2\x1f.dota.CMsgPoorNetworkConditionsR\x15poorNetworkConditions\
    \x12F\n\x0bsend_reason\x18\x08\x20\x01(\x0e2%.dota.CMsgConnectedPlayers.\
    SendReasonR\nsendReason\x12#\n\rradiant_kills\x18\x0b\x20\x01(\rR\x0crad\
    iantKills\x12\x1d\n\ndire_kills\x18\x0c\x20\x01(\rR\tdireKills\x12!\n\
    \x0cradiant_lead\x18\x0e\x20\x01(\x05R\x0bradiantLead\x12%\n\x0ebuilding\
    _state\x18\x0f\x20\x01(\rR\rbuildingState\x12I\n\x0cplayer_draft\x18\x10\
    \x20\x03(\x0b2&.dota.CMsgConnectedPlayers.PlayerDraftR\x0bplayerDraft\
    \x1a\xc6\x01\n\x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07\
    steamId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x128\n\x0clea\
    ver_state\x18\x03\x20\x01(\x0b2\x15.dota.CMsgLeaverStateR\x0bleaverState\
    \x12N\n\x11disconnect_reason\x18\x04\x20\x01(\x0e2!.dota.ENetworkDisconn\
    ectionReasonR\x10disconnectReason\x1am\n\x0bPlayerDraft\x12\x19\n\x08ste\
    am_id\x18\x01\x20\x01(\x06R\x07steamId\x12&\n\x04team\x18\x02\x20\x01(\
    \x0e2\x12.dota.DOTA_GC_TEAMR\x04team\x12\x1b\n\tteam_slot\x18\x03\x20\
    \x01(\x05R\x08teamSlot\"\x89\x02\n\nSendReason\x12\x0b\n\x07INVALID\x10\
    \0\x12\r\n\tHEARTBEAT\x10\x01\x12\x0e\n\nGAME_STATE\x10\x02\x12\x0f\n\
    \x0bFIRST_BLOOD\x10\x03\x12\x14\n\x10PLAYER_CONNECTED\x10\x04\x12\x0f\n\
    \x0bPLAYER_HERO\x10\x05\x12$\n\x20PLAYER_DISCONNECTED_CONSEQUENCES\x10\
    \x06\x12&\n\"PLAYER_DISCONNECTED_NOCONSEQUENCES\x10\x07\x12\x15\n\x11GAM\
    ESTATE_TIMEOUT\x10\n\x12\x13\n\x0fMASS_DISCONNECT\x10\x0b\x12\t\n\x05KIL\
    LS\x10\r\x12\x12\n\x0eBUILDING_STATE\x10\x0e\"\xb8\x0c\n\x12CMsgGameServ\
    erInfo\x121\n\x15server_public_ip_addr\x18\x01\x20\x01(\x07R\x12serverPu\
    blicIpAddr\x123\n\x16server_private_ip_addr\x18\x02\x20\x01(\x07R\x13ser\
    verPrivateIpAddr\x12\x1f\n\x0bserver_port\x18\x03\x20\x01(\rR\nserverPor\
    t\x12$\n\x0eserver_tv_port\x18\x04\x20\x01(\rR\x0cserverTvPort\x125\n\
    \x17assigned_server_tv_port\x18\x16\x20\x01(\rR\x14assignedServerTvPort\
    \x12M\n#legacy_server_steamdatagram_address\x18\x1b\x20\x01(\x0cR\x20leg\
    acyServerSteamdatagramAddress\x12\x1d\n\nserver_key\x18\x05\x20\x01(\tR\
    \tserverKey\x12-\n\x12server_hibernation\x18\x06\x20\x01(\x08R\x11server\
    Hibernation\x12D\n\x0bserver_type\x18\x07\x20\x01(\x0e2#.dota.CMsgGameSe\
    rverInfo.ServerTypeR\nserverType\x12#\n\rserver_region\x18\x08\x20\x01(\
    \rR\x0cserverRegion\x12%\n\x0eserver_loadavg\x18\t\x20\x01(\x02R\rserver\
    Loadavg\x127\n\x18server_tv_broadcast_time\x18\n\x20\x01(\x02R\x15server\
    TvBroadcastTime\x12(\n\x10server_game_time\x18\x0b\x20\x01(\x02R\x0eserv\
    erGameTime\x12D\n\x1fserver_relay_connected_steam_id\x18\x0c\x20\x01(\
    \x06R\x1bserverRelayConnectedSteamId\x12&\n\x0frelay_slots_max\x18\r\x20\
    \x01(\rR\rrelaySlotsMax\x12)\n\x10relays_connected\x18\x0e\x20\x01(\x05R\
    \x0frelaysConnected\x126\n\x17relay_clients_connected\x18\x0f\x20\x01(\
    \x05R\x15relayClientsConnected\x12>\n\x1crelayed_game_server_steam_id\
    \x18\x10\x20\x01(\x06R\x18relayedGameServerSteamId\x12,\n\x12parent_rela\
    y_count\x18\x11\x20\x01(\rR\x10parentRelayCount\x12$\n\x0etv_secret_code\
    \x18\x12\x20\x01(\x06R\x0ctvSecretCode\x12%\n\x0eserver_version\x18\x13\
    \x20\x01(\rR\rserverVersion\x12%\n\x0eserver_cluster\x18\x14\x20\x01(\rR\
    \rserverCluster\x12R\n\x12allow_custom_games\x18\x17\x20\x01(\x0e2$.dota\
    .CMsgGameServerInfo.CustomGamesR\x10allowCustomGames\x12#\n\rbuild_versi\
    on\x18\x18\x20\x01(\rR\x0cbuildVersion\x12&\n\x0ftf_server_count\x18\x19\
    \x20\x01(\rR\rtfServerCount\x12%\n\x0esrcds_instance\x18\x1a\x20\x01(\rR\
    \rsrcdsInstance\x121\n\x15dev_force_server_type\x18\x1c\x20\x01(\x08R\
    \x12devForceServerType\x12F\n\x20is_recording_match_training_data\x18\
    \x1d\x20\x01(\x08R\x1cisRecordingMatchTrainingData\"|\n\nServerType\x12\
    \x0f\n\x0bUNSPECIFIED\x10\0\x12\x08\n\x04GAME\x10\x01\x12\t\n\x05PROXY\
    \x10\x02\x12\x0e\n\nTENSORFLOW\x10\x03\x12\r\n\tDOTA_ONLY\x10\x04\x12\
    \x14\n\x10CUSTOM_GAME_ONLY\x10\x05\x12\x13\n\x0fEVENT_GAME_ONLY\x10\x06\
    \"6\n\x0bCustomGames\x12\x08\n\x04BOTH\x10\0\x12\x08\n\x04NONE\x10\x01\
    \x12\x08\n\x04ONLY\x10\x02\x12\t\n\x05EVENT\x10\x03\"\xf8\x02\n\x12CMsgL\
    eaverDetected\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\
    =\n\rleaver_status\x18\x02\x20\x01(\x0e2\x18.dota.DOTALeaverStatus_tR\
    \x0cleaverStatus\x128\n\x0cleaver_state\x18\x04\x20\x01(\x0b2\x15.dota.C\
    MsgLeaverStateR\x0bleaverState\x12%\n\x0eserver_cluster\x18\x05\x20\x01(\
    \rR\rserverCluster\x12N\n\x11disconnect_reason\x18\x06\x20\x01(\x0e2!.do\
    ta.ENetworkDisconnectionReasonR\x10disconnectReason\x12W\n\x17poor_netwo\
    rk_conditions\x18\x07\x20\x01(\x0b2\x1f.dota.CMsgPoorNetworkConditionsR\
    \x15poorNetworkConditions\"4\n\x1aCMsgLeaverDetectedResponse\x12\x16\n\
    \x06result\x18\x01\x20\x01(\rR\x06result\"Y\n\x1fCMsgDOTAFantasyFinalPla\
    yerStats\x126\n\x05stats\x18\x02\x20\x03(\x0b2\x20.dota.CMsgDOTAFantasyP\
    layerStatsR\x05stats\"X\n\x1eCMsgDOTAFantasyLivePlayerStats\x126\n\x05st\
    ats\x18\x02\x20\x03(\x0b2\x20.dota.CMsgDOTAFantasyPlayerStatsR\x05stats\
    \"]\n\x1bCMsgServerToGCRealtimeStats\x12>\n\x07delayed\x18\x01\x20\x01(\
    \x0b2$.dota.CMsgDOTARealtimeGameStatsTerseR\x07delayed\"@\n$CMsgGCToServ\
    erRealtimeStatsStartStop\x12\x18\n\x07delayed\x18\x01\x20\x01(\x08R\x07d\
    elayed\"?\n%CMsgGCToServerUpdateSteamBroadcasting\x12\x16\n\x06active\
    \x18\x01\x20\x01(\x08R\x06active\"\xe5\x03\n\x18CMsgSignOutGameplayStats\
    \x12:\n\x05teams\x18\x01\x20\x03(\x0b2$.dota.CMsgSignOutGameplayStats.CT\
    eamR\x05teams\x1a\xaa\x01\n\x07CPlayer\x12\x19\n\x08steam_id\x18\x01\x20\
    \x01(\x06R\x07steamId\x12\x1f\n\x0bplayer_slot\x18\x02\x20\x01(\rR\nplay\
    erSlot\x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\x06heroId\x12J\n\x12time\
    d_player_stats\x18\x04\x20\x03(\x0b2\x1c.dota.CMatchPlayerTimedStatsR\
    \x10timedPlayerStats\x1a\xdf\x01\n\x05CTeam\x12&\n\x0fis_winning_team\
    \x18\x01\x20\x01(\x08R\risWinningTeam\x12&\n\x0fis_radiant_team\x18\x02\
    \x20\x01(\x08R\risRadiantTeam\x12D\n\x10timed_team_stats\x18\x03\x20\x03\
    (\x0b2\x1a.dota.CMatchTeamTimedStatsR\x0etimedTeamStats\x12@\n\x07player\
    s\x18\x04\x20\x03(\x0b2&.dota.CMsgSignOutGameplayStats.CPlayerR\x07playe\
    rs\"\xc5/\n\x14CMsgGameMatchSignOut\x12\x19\n\x08match_id\x18\x01\x20\
    \x01(\x04R\x07matchId\x12\x1a\n\x08duration\x18\x02\x20\x01(\rR\x08durat\
    ion\x12\"\n\rgood_guys_win\x18\x03\x20\x01(\x08R\x0bgoodGuysWin\x12\x12\
    \n\x04date\x18\x04\x20\x01(\x07R\x04date\x126\n\x05teams\x18\x06\x20\x03\
    (\x0b2\x20.dota.CMsgGameMatchSignOut.CTeamR\x05teams\x12!\n\x0ctower_sta\
    tus\x18\x08\x20\x03(\rR\x0btowerStatus\x12'\n\x0fbarracks_status\x18\t\
    \x20\x03(\rR\x0ebarracksStatus\x12\x18\n\x07cluster\x18\n\x20\x01(\rR\
    \x07cluster\x12\x1f\n\x0bserver_addr\x18\x0b\x20\x01(\tR\nserverAddr\x12\
    (\n\x10first_blood_time\x18\x0c\x20\x01(\rR\x0efirstBloodTime\x12\x1f\n\
    \x0bevent_score\x18\x0e\x20\x01(\rR\neventScore\x12:\n\npicks_bans\x18\
    \x0f\x20\x03(\x0b2\x1b.dota.CMatchHeroSelectEventR\tpicksBans\x12E\n\rfa\
    ntasy_stats\x18)\x20\x03(\x0b2\x20.dota.CMsgDOTAFantasyPlayerStatsR\x0cf\
    antasyStats\x12s\n\x20player_strange_count_adjustments\x18\x11\x20\x03(\
    \x0b2*.dota.CMsgEconPlayerStrangeCountAdjustmentR\x1dplayerStrangeCountA\
    djustments\x12/\n\x13automatic_surrender\x18\x12\x20\x01(\x08R\x12automa\
    ticSurrender\x12%\n\x0eserver_version\x18\x13\x20\x01(\rR\rserverVersion\
    \x12W\n\x17poor_network_conditions\x18#\x20\x01(\x0b2\x1f.dota.CMsgPoorN\
    etworkConditionsR\x15poorNetworkConditions\x12Y\n\x0fadditional_msgs\x18\
    \x14\x20\x03(\x0b20.dota.CMsgGameMatchSignOut.CAdditionalSignoutMsgR\x0e\
    additionalMsgs\x12^\n\x12social_feed_events\x18$\x20\x03(\x0b20.dota.CMs\
    gGameMatchSignOut.CSocialFeedMatchEventR\x10socialFeedEvents\x124\n\x16a\
    verage_networth_delta\x18\x16\x20\x01(\x11R\x14averageNetworthDelta\x12T\
    \n\x10custom_game_data\x18%\x20\x01(\x0b2*.dota.CMsgGameMatchSignOut.CCu\
    stomGameDataR\x0ecustomGameData\x12\x1f\n\x0bmatch_flags\x18&\x20\x01(\r\
    R\nmatchFlags\x12\x1f\n\x0bteam_scores\x18'\x20\x03(\rR\nteamScores\x12*\
    \n\x11pre_game_duration\x18(\x20\x01(\rR\x0fpreGameDuration\x12y\n\x1eev\
    ent_game_leaderboard_entries\x18*\x20\x03(\x0b24.dota.CMsgGameMatchSignO\
    ut.EventGameLeaderboardEntryR\x1beventGameLeaderboardEntries\x12Q\n\x0fw\
    ard_placements\x18+\x20\x03(\x0b2(.dota.CMsgGameMatchSignOut.WardPlaceme\
    ntR\x0ewardPlacements\x12E\n\x0egameplay_stats\x18,\x20\x01(\x0b2\x1e.do\
    ta.CMsgSignOutGameplayStatsR\rgameplayStats\x12;\n\x0eextra_messages\x18\
    6\x20\x03(\x0b2\x14.dota.CExtraMsgBlockR\rextraMessages\x124\n\x16traini\
    ng_data_recorded\x187\x20\x01(\x08R\x14trainingDataRecorded\x125\n\x0cwi\
    nning_team\x188\x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\x0bwinningTeam\x12E\
    \n\x1fnormalized_win_probability_diff\x189\x20\x01(\x02R\x1cnormalizedWi\
    nProbabilityDiff\x1a\x85\x1b\n\x05CTeam\x12B\n\x07players\x18\x01\x20\
    \x03(\x0b2(.dota.CMsgGameMatchSignOut.CTeam.CPlayerR\x07players\x1a\xb7\
    \x1a\n\x07CPlayer\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\
    \x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\x06heroId\x12\x14\n\x05items\
    \x18\x04\x20\x03(\x05R\x05items\x12.\n\x13item_purchase_times\x18?\x20\
    \x03(\rR\x11itemPurchaseTimes\x12\x12\n\x04gold\x18\x05\x20\x01(\rR\x04g\
    old\x12\x14\n\x05kills\x18\x06\x20\x01(\rR\x05kills\x12\x16\n\x06deaths\
    \x18\x07\x20\x01(\rR\x06deaths\x12\x18\n\x07assists\x18\x08\x20\x01(\rR\
    \x07assists\x12#\n\rleaver_status\x18\t\x20\x01(\rR\x0cleaverStatus\x12\
    \x1b\n\tlast_hits\x18\n\x20\x01(\rR\x08lastHits\x12\x16\n\x06denies\x18\
    \x0b\x20\x01(\rR\x06denies\x12\x20\n\x0cgold_per_min\x18\x0c\x20\x01(\rR\
    \ngoldPerMin\x12\"\n\rxp_per_minute\x18\r\x20\x01(\rR\x0bxpPerMinute\x12\
    \x1d\n\ngold_spent\x18\x0e\x20\x01(\rR\tgoldSpent\x12\x14\n\x05level\x18\
    \x0f\x20\x01(\rR\x05level\x12,\n\x12scaled_hero_damage\x18\x10\x20\x01(\
    \rR\x10scaledHeroDamage\x12.\n\x13scaled_tower_damage\x18\x11\x20\x01(\r\
    R\x11scaledTowerDamage\x12.\n\x13scaled_hero_healing\x18\x12\x20\x01(\rR\
    \x11scaledHeroHealing\x12$\n\x0etime_last_seen\x18\x13\x20\x01(\rR\x0cti\
    meLastSeen\x122\n\x15support_ability_value\x18\x14\x20\x01(\rR\x13suppor\
    tAbilityValue\x12\x19\n\x08party_id\x18\x15\x20\x01(\x04R\x07partyId\x12\
    *\n\x11claimed_farm_gold\x18\x1b\x20\x01(\rR\x0fclaimedFarmGold\x12!\n\
    \x0csupport_gold\x18\x1c\x20\x01(\rR\x0bsupportGold\x12%\n\x0eclaimed_de\
    nies\x18\x1d\x20\x01(\rR\rclaimedDenies\x12%\n\x0eclaimed_misses\x18\x1e\
    \x20\x01(\rR\rclaimedMisses\x12\x16\n\x06misses\x18\x1f\x20\x01(\rR\x06m\
    isses\x12\x1b\n\tnet_worth\x18\"\x20\x01(\rR\x08netWorth\x12\x1f\n\x0bhe\
    ro_damage\x18%\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_damage\x18&\x20\
    \x01(\rR\x0btowerDamage\x12!\n\x0chero_healing\x18'\x20\x01(\rR\x0bheroH\
    ealing\x12K\n\x10ability_upgrades\x18\x20\x20\x03(\x0b2\x20.dota.CMatchP\
    layerAbilityUpgradeR\x0fabilityUpgrades\x12a\n\x1aadditional_units_inven\
    tory\x18!\x20\x03(\x0b2#.dota.CMatchAdditionalUnitInventoryR\x18addition\
    alUnitsInventory\x12H\n\x0fpermanent_buffs\x18(\x20\x03(\x0b2\x1f.dota.C\
    MatchPlayerPermanentBuffR\x0epermanentBuffs\x12b\n\x10custom_game_data\
    \x18#\x20\x01(\x0b28.dota.CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGame\
    DataR\x0ecustomGameData\x12,\n\x12match_player_flags\x18$\x20\x01(\rR\
    \x10matchPlayerFlags\x12,\n\x12talent_ability_ids\x18)\x20\x03(\x05R\x10\
    talentAbilityIds\x12&\n\x0fhero_pick_order\x18*\x20\x01(\rR\rheroPickOrd\
    er\x12*\n\x11hero_was_randomed\x18+\x20\x01(\x08R\x0fheroWasRandomed\x12\
    @\n\x1dhero_was_dota_plus_suggestion\x182\x20\x01(\x08R\x19heroWasDotaPl\
    usSuggestion\x12\x12\n\x04lane\x18-\x20\x01(\rR\x04lane\x12-\n\x13is_usi\
    ng_plus_guide\x18/\x20\x01(\x08R\x10isUsingPlusGuide\x12m\n\x14hero_dama\
    ge_received\x180\x20\x03(\x0b2;.dota.CMsgGameMatchSignOut.CTeam.CPlayer.\
    HeroDamageReceivedR\x12heroDamageReceived\x12g\n\x11hero_damage_dealt\
    \x18@\x20\x03(\x0b2;.dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageR\
    eceivedR\x0fheroDamageDealt\x12!\n\x0cseconds_dead\x183\x20\x01(\rR\x0bs\
    econdsDead\x12+\n\x12gold_lost_to_death\x184\x20\x01(\rR\x0fgoldLostToDe\
    ath\x12#\n\rcommand_count\x185\x20\x01(\rR\x0ccommandCount\x12B\n\x1emou\
    se_click_cast_command_count\x186\x20\x01(\rR\x1amouseClickCastCommandCou\
    nt\x12%\n\x0eteleports_used\x187\x20\x01(\rR\rteleportsUsed\x12J\n\"cave\
    rn_crawl_preferred_map_variant\x188\x20\x01(\rR\x1ecavernCrawlPreferredM\
    apVariant\x12!\n\x0cbounty_runes\x189\x20\x01(\rR\x0bbountyRunes\x12+\n\
    \x11outposts_captured\x18:\x20\x01(\rR\x10outpostsCaptured\x12\x18\n\x07\
    dewards\x18;\x20\x01(\rR\x07dewards\x12!\n\x0cwards_placed\x18<\x20\x01(\
    \rR\x0bwardsPlaced\x12#\n\rcamps_stacked\x18=\x20\x01(\rR\x0ccampsStacke\
    d\x12\x1f\n\x0bplayer_slot\x18>\x20\x01(\rR\nplayerSlot\x12-\n\x12predic\
    ted_position\x18B\x20\x01(\rR\x11predictedPosition\x12#\n\rlane_outcomes\
    \x18C\x20\x01(\rR\x0claneOutcomes\x12;\n\x1afriendly_t1_destroyed_time\
    \x18D\x20\x01(\rR\x17friendlyT1DestroyedTime\x125\n\x17enemy_t1_destroye\
    d_time\x18E\x20\x01(\rR\x14enemyT1DestroyedTime\x122\n\x15friendly_rosha\
    n_kills\x18F\x20\x01(\rR\x13friendlyRoshanKills\x12,\n\x12enemy_roshan_k\
    ills\x18G\x20\x01(\rR\x10enemyRoshanKills\x12\x1f\n\x0bpower_runes\x18H\
    \x20\x01(\rR\npowerRunes\x12\x1f\n\x0bwater_runes\x18I\x20\x01(\rR\nwate\
    rRunes\x12#\n\rstun_duration\x18J\x20\x01(\x02R\x0cstunDuration\x123\n\
    \x0bteam_number\x18K\x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\nteamNumber\
    \x12\x1b\n\tteam_slot\x18L\x20\x01(\rR\x08teamSlot\x120\n\x14time_purcha\
    sed_shard\x18M\x20\x01(\rR\x12timePurchasedShard\x12.\n\x13time_purchase\
    d_aghs\x18N\x20\x01(\rR\x11timePurchasedAghs\x126\n\x17ability_draft_abi\
    lities\x18O\x20\x03(\x05R\x15abilityDraftAbilities\x1aF\n\x0fCCustomGame\
    Data\x12\x1b\n\tdota_team\x18\x01\x20\x01(\rR\x08dotaTeam\x12\x16\n\x06w\
    inner\x18\x02\x20\x01(\x08R\x06winner\x1a\xba\x01\n\x12HeroDamageReceive\
    d\x12#\n\rpre_reduction\x18\x01\x20\x01(\rR\x0cpreReduction\x12%\n\x0epo\
    st_reduction\x18\x02\x20\x01(\rR\rpostReduction\x12X\n\x0bdamage_type\
    \x18\x03\x20\x01(\x0e27.dota.CMsgGameMatchSignOut.CTeam.CPlayer.HeroDama\
    geTypeR\ndamageType\"Y\n\x0eHeroDamageType\x12\x18\n\x14HERO_DAMAGE_PHYS\
    ICAL\x10\0\x12\x17\n\x13HERO_DAMAGE_MAGICAL\x10\x01\x12\x14\n\x10HERO_DA\
    MAGE_PURE\x10\x02\x1aC\n\x15CAdditionalSignoutMsg\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\rR\x02id\x12\x1a\n\x08contents\x18\x02\x20\x01(\x0cR\x08co\
    ntents\x1a\xb1\x01\n\x15CSocialFeedMatchEvent\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\tti\
    mestamp\x12\x1d\n\nevent_type\x18\x03\x20\x01(\rR\teventType\x12\x1b\n\t\
    game_time\x18\x04\x20\x01(\x05R\x08gameTime\x12\x1f\n\x0breplay_time\x18\
    \x05\x20\x01(\rR\nreplayTime\x1a>\n\x0fCCustomGameData\x12+\n\x11publish\
    _timestamp\x18\x01\x20\x01(\rR\x10publishTimestamp\x1a\xfc\x01\n\x19Even\
    tGameLeaderboardEntry\x12\x1f\n\x0bname_suffix\x18\x01\x20\x01(\tR\nname\
    Suffix\x12\x14\n\x05score\x18\x02\x20\x01(\x05R\x05score\x12\x20\n\x0cex\
    tra_data_1\x18\x03\x20\x01(\rR\nextraData1\x12\x20\n\x0cextra_data_2\x18\
    \x04\x20\x01(\rR\nextraData2\x12\x20\n\x0cextra_data_3\x18\x05\x20\x01(\
    \rR\nextraData3\x12\x20\n\x0cextra_data_4\x18\x06\x20\x01(\rR\nextraData\
    4\x12\x20\n\x0cextra_data_5\x18\x07\x20\x01(\rR\nextraData5\x1a\x8f\x02\
    \n\rWardPlacement\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\
    \x12\x17\n\x07team_id\x18\x02\x20\x01(\rR\x06teamId\x12\x1f\n\x0bplaced_\
    time\x18\x03\x20\x01(\rR\nplacedTime\x12%\n\x0ebuilding_state\x18\x04\
    \x20\x01(\rR\rbuildingState\x12\x1f\n\x0bcreep_state\x18\x05\x20\x01(\rR\
    \ncreepState\x12!\n\x0croshan_alive\x18\x06\x20\x01(\x08R\x0broshanAlive\
    \x12\x1d\n\nposition_x\x18\x07\x20\x01(\rR\tpositionX\x12\x1d\n\npositio\
    n_y\x18\x08\x20\x01(\rR\tpositionY\"\xc6\x01\n\x14CMsgSignOutDraftInfo\
    \x12;\n\x1aradiant_captain_account_id\x18\x01\x20\x01(\rR\x17radiantCapt\
    ainAccountId\x125\n\x17dire_captain_account_id\x18\x02\x20\x01(\rR\x14di\
    reCaptainAccountId\x12:\n\npicks_bans\x18\x03\x20\x03(\x0b2\x1b.dota.CMa\
    tchHeroSelectEventR\tpicksBans\"\xf4\x01\n\x12CMsgSignOutBotInfo\x12!\n\
    \x0callow_cheats\x18\x01\x20\x01(\x08R\x0ballowCheats\x12M\n\x16bot_diff\
    iculty_radiant\x18\x02\x20\x01(\x0e2\x17.dota.DOTABotDifficultyR\x14botD\
    ifficultyRadiant\x12#\n\rcreated_lobby\x18\x03\x20\x01(\x08R\x0ccreatedL\
    obby\x12G\n\x13bot_difficulty_dire\x18\x05\x20\x01(\x0e2\x17.dota.DOTABo\
    tDifficultyR\x11botDifficultyDire\"\xee\x01\n\x17CMsgSignOutTextMuteInfo\
    \x12[\n\x12text_mute_messages\x18\x01\x20\x03(\x0b2-.dota.CMsgSignOutTex\
    tMuteInfo.TextMuteMessageR\x10textMuteMessages\x1av\n\x0fTextMuteMessage\
    \x12\x16\n\x06region\x18\x01\x20\x01(\rR\x06region\x12(\n\x10caused_text\
    _mute\x18\x02\x20\x01(\x08R\x0ecausedTextMute\x12!\n\x0cchat_message\x18\
    \x03\x20\x01(\tR\x0bchatMessage\"\xd5\x07\n\x16CMsgSignOutPlayerStats\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\x05R\taccountId\x12\x19\n\x08mat\
    ch_id\x18\x02\x20\x01(\x04R\x07matchId\x12\x12\n\x04rank\x18\x03\x20\x01\
    (\rR\x04rank\x12\x17\n\x07hero_id\x18\x04\x20\x01(\rR\x06heroId\x12\x1a\
    \n\x08rampages\x18\x05\x20\x01(\rR\x08rampages\x12!\n\x0ctriple_kills\
    \x18\x06\x20\x01(\rR\x0btripleKills\x12.\n\x13first_blood_claimed\x18\
    \x07\x20\x01(\rR\x11firstBloodClaimed\x12*\n\x11first_blood_given\x18\
    \x08\x20\x01(\rR\x0ffirstBloodGiven\x12'\n\x0fcouriers_killed\x18\t\x20\
    \x01(\rR\x0ecouriersKilled\x12)\n\x10aegises_snatched\x18\n\x20\x01(\rR\
    \x0faegisesSnatched\x12#\n\rcheeses_eaten\x18\x0b\x20\x01(\rR\x0ccheeses\
    Eaten\x12%\n\x0ecreeps_stacked\x18\x0c\x20\x01(\rR\rcreepsStacked\x12\
    \x1f\n\x0bfight_score\x18\r\x20\x01(\x02R\nfightScore\x12\x1d\n\nfarm_sc\
    ore\x18\x0e\x20\x01(\x02R\tfarmScore\x12#\n\rsupport_score\x18\x0f\x20\
    \x01(\x02R\x0csupportScore\x12\x1d\n\npush_score\x18\x10\x20\x01(\x02R\t\
    pushScore\x12\x14\n\x05kills\x18\x11\x20\x01(\rR\x05kills\x12\x16\n\x06d\
    eaths\x18\x12\x20\x01(\rR\x06deaths\x12\x18\n\x07assists\x18\x13\x20\x01\
    (\rR\x07assists\x12\x1b\n\tlast_hits\x18\x14\x20\x01(\rR\x08lastHits\x12\
    \x16\n\x06denies\x18\x15\x20\x01(\rR\x06denies\x12\x10\n\x03gpm\x18\x16\
    \x20\x01(\x02R\x03gpm\x12\x12\n\x04xppm\x18\x17\x20\x01(\x02R\x04xppm\
    \x12\x1b\n\tnet_worth\x18\x18\x20\x01(\x02R\x08netWorth\x12\x16\n\x06dam\
    age\x18\x19\x20\x01(\x02R\x06damage\x12\x14\n\x05heals\x18\x1a\x20\x01(\
    \x02R\x05heals\x12+\n\x11rapiers_purchased\x18\x1b\x20\x01(\rR\x10rapier\
    sPurchased\x122\n\x15observer_wards_placed\x18\x1c\x20\x01(\rR\x13observ\
    erWardsPlaced\x12'\n\x0fwards_destroyed\x18\x1d\x20\x01(\rR\x0ewardsDest\
    royed\x12\x1d\n\nlobby_type\x18\x1e\x20\x01(\rR\tlobbyType\"\xab\x07\n\
    \x1fCMsgSignOutCommunicationSummary\x12S\n\x07players\x18\x01\x20\x03(\
    \x0b29.dota.CMsgSignOutCommunicationSummary.PlayerCommunicationR\x07play\
    ers\x1a\xb2\x06\n\x13PlayerCommunication\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x14\n\x05pings\x18\x02\x20\x01(\rR\x05pings\
    \x123\n\x16max_pings_per_interval\x18\x03\x20\x01(\rR\x13maxPingsPerInte\
    rval\x12%\n\x0eteammate_pings\x18\x04\x20\x01(\rR\rteammatePings\x12D\n\
    \x1fmax_teammate_pings_per_interval\x18\x05\x20\x01(\rR\x1bmaxTeammatePi\
    ngsPerInterval\x12,\n\x12team_chat_messages\x18\x06\x20\x01(\rR\x10teamC\
    hatMessages\x12*\n\x11all_chat_messages\x18\x07\x20\x01(\rR\x0fallChatMe\
    ssages\x12.\n\x13chat_wheel_messages\x18\x08\x20\x01(\rR\x11chatWheelMes\
    sages\x12\x16\n\x06pauses\x18\t\x20\x01(\rR\x06pauses\x12\x1a\n\x08unpau\
    ses\x18\n\x20\x01(\rR\x08unpauses\x12\x1f\n\x0blines_drawn\x18\x0b\x20\
    \x01(\rR\nlinesDrawn\x12,\n\x12voice_chat_seconds\x18\x0c\x20\x01(\rR\
    \x10voiceChatSeconds\x12\x1d\n\nchat_mutes\x18\r\x20\x01(\rR\tchatMutes\
    \x12\x1f\n\x0bvoice_mutes\x18\x0e\x20\x01(\rR\nvoiceMutes\x12g\n\x0cping\
    _details\x18\x0f\x20\x03(\x0b2D.dota.CMsgSignOutCommunicationSummary.Pla\
    yerCommunication.PingDetailR\x0bpingDetails\x12*\n\x11comms_blocks_solo\
    \x18\x10\x20\x01(\rR\x0fcommsBlocksSolo\x12*\n\x11comms_blocks_mass\x18\
    \x11\x20\x01(\rR\x0fcommsBlocksMass\x1a6\n\nPingDetail\x12\x12\n\x04type\
    \x18\x01\x20\x01(\rR\x04type\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05c\
    ount\"\xc0\x08\n\x1cCMsgGameMatchSignoutResponse\x12\x19\n\x08match_id\
    \x18\x01\x20\x01(\x04R\x07matchId\x12\x1f\n\x0breplay_salt\x18\x02\x20\
    \x01(\x07R\nreplaySalt\x12P\n\x14timed_reward_details\x18\x03\x20\x03(\
    \x0b2\x1e.dota.CLobbyTimedRewardDetailsR\x12timedRewardDetails\x12D\n\
    \x11xp_reward_details\x18\x04\x20\x03(\x0b2\x18.dota.CSODOTALobbyMemberR\
    \x0fxpRewardDetails\x12\x1a\n\x08leagueid\x18\x05\x20\x01(\rR\x08leaguei\
    d\x120\n\x14metadata_private_key\x18\x07\x20\x01(\x07R\x12metadataPrivat\
    eKey\x128\n\rmatch_details\x18\x08\x20\x01(\x0b2\x13.dota.CMsgDOTAMatchR\
    \x0cmatchDetails\x12\\\n\x10players_metadata\x18\t\x20\x03(\x0b21.dota.C\
    MsgGameMatchSignoutResponse.PlayerMetadataR\x0fplayersMetadata\x12)\n\
    \x08mvp_data\x18\n\x20\x01(\x0b2\x0e.dota.CMvpDataR\x07mvpData\x12$\n\
    \x0eow_private_key\x18\x0b\x20\x01(\x06R\x0cowPrivateKey\x12\x17\n\x07ow\
    _salt\x18\x0c\x20\x01(\x07R\x06owSalt\x12\x20\n\x0cow_replay_id\x18\r\
    \x20\x01(\x04R\nowReplayId\x1a\xd9\x03\n\x0ePlayerMetadata\x12\x17\n\x07\
    hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\"\n\ravg_kills_x16\x18\x02\x20\
    \x01(\rR\x0bavgKillsX16\x12$\n\x0eavg_deaths_x16\x18\x03\x20\x01(\rR\x0c\
    avgDeathsX16\x12&\n\x0favg_assists_x16\x18\x04\x20\x01(\rR\ravgAssistsX1\
    6\x12\x1e\n\x0bavg_gpm_x16\x18\x05\x20\x01(\rR\tavgGpmX16\x12\x1e\n\x0ba\
    vg_xpm_x16\x18\x06\x20\x01(\rR\tavgXpmX16\x12$\n\x0ebest_kills_x16\x18\
    \x07\x20\x01(\rR\x0cbestKillsX16\x12(\n\x10best_assists_x16\x18\x08\x20\
    \x01(\rR\x0ebestAssistsX16\x12\x20\n\x0cbest_gpm_x16\x18\t\x20\x01(\rR\n\
    bestGpmX16\x12\x20\n\x0cbest_xpm_x16\x18\n\x20\x01(\rR\nbestXpmX16\x12\
    \x1d\n\nwin_streak\x18\x0b\x20\x01(\rR\twinStreak\x12&\n\x0fbest_win_str\
    eak\x18\x0c\x20\x01(\rR\rbestWinStreak\x12!\n\x0cgames_played\x18\r\x20\
    \x01(\rR\x0bgamesPlayed\"l\n\x18CMsgTimedRewardContainer\x12P\n\x14timed\
    _reward_details\x18\x01\x20\x03(\x0b2\x1e.dota.CLobbyTimedRewardDetailsR\
    \x12timedRewardDetails\"\xbf\x01\n%CMsgGameMatchSignOutPermissionRequest\
    \x12%\n\x0eserver_version\x18\x01\x20\x01(\rR\rserverVersion\x12#\n\rloc\
    al_attempt\x18\x02\x20\x01(\rR\x0clocalAttempt\x12#\n\rtotal_attempt\x18\
    \x03\x20\x01(\rR\x0ctotalAttempt\x12%\n\x0eseconds_waited\x18\x04\x20\
    \x01(\rR\rsecondsWaited\"\xb0\x01\n&CMsgGameMatchSignOutPermissionRespon\
    se\x12-\n\x12permission_granted\x18\x01\x20\x01(\x08R\x11permissionGrant\
    ed\x12'\n\x0fabandon_signout\x18\x02\x20\x01(\x08R\x0eabandonSignout\x12\
    .\n\x13retry_delay_seconds\x18\x03\x20\x01(\rR\x11retryDelaySeconds\"\
    \xcb\x01\n!CMsgGameMatchSignOutEventGameData\x12'\n\x08event_id\x18\x01\
    \x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12\x1b\n\tgame_name\x18\x02\
    \x20\x01(\tR\x08gameName\x12\x19\n\x08map_name\x18\x03\x20\x01(\tR\x07ma\
    pName\x12&\n\x0fevent_game_data\x18\x04\x20\x01(\x0cR\reventGameData\x12\
    \x1d\n\nstart_time\x18\x05\x20\x01(\rR\tstartTime\"\xb4\t\n\x1cCMsgGameM\
    atchSignOutPerfData\x12,\n\x12average_frame_time\x18\x01\x20\x03(\x02R\
    \x10averageFrameTime\x12$\n\x0emax_frame_time\x18\x02\x20\x03(\x02R\x0cm\
    axFrameTime\x129\n\x19server_average_frame_time\x18\x03\x20\x01(\x02R\
    \x16serverAverageFrameTime\x121\n\x15server_max_frame_time\x18\x04\x20\
    \x01(\x02R\x12serverMaxFrameTime\x120\n\x14average_compute_time\x18\x05\
    \x20\x03(\x02R\x12averageComputeTime\x12(\n\x10max_compute_time\x18\x06\
    \x20\x03(\x02R\x0emaxComputeTime\x127\n\x18average_client_tick_time\x18\
    \x07\x20\x03(\x02R\x15averageClientTickTime\x12/\n\x14max_client_tick_ti\
    me\x18\x08\x20\x03(\x02R\x11maxClientTickTime\x12?\n\x1caverage_client_s\
    imulate_time\x18\t\x20\x03(\x02R\x19averageClientSimulateTime\x127\n\x18\
    max_client_simulate_time\x18\n\x20\x03(\x02R\x15maxClientSimulateTime\
    \x12.\n\x13average_output_time\x18\x0b\x20\x03(\x02R\x11averageOutputTim\
    e\x12&\n\x0fmax_output_time\x18\x0c\x20\x03(\x02R\rmaxOutputTime\x12Z\n+\
    average_wait_for_rendering_to_complete_time\x18\r\x20\x03(\x02R%averageW\
    aitForRenderingToCompleteTime\x12R\n'max_wait_for_rendering_to_complete_\
    time\x18\x0e\x20\x03(\x02R!maxWaitForRenderingToCompleteTime\x12*\n\x11a\
    verage_swap_time\x18\x0f\x20\x03(\x02R\x0faverageSwapTime\x12\"\n\rmax_s\
    wap_time\x18\x10\x20\x03(\x02R\x0bmaxSwapTime\x129\n\x19average_frame_up\
    date_time\x18\x11\x20\x03(\x02R\x16averageFrameUpdateTime\x121\n\x15max_\
    frame_update_time\x18\x12\x20\x03(\x02R\x12maxFrameUpdateTime\x12*\n\x11\
    average_idle_time\x18\x13\x20\x03(\x02R\x0faverageIdleTime\x12\"\n\rmax_\
    idle_time\x18\x14\x20\x03(\x02R\x0bmaxIdleTime\x12A\n\x1daverage_input_p\
    rocessing_time\x18\x15\x20\x03(\x02R\x1aaverageInputProcessingTime\x129\
    \n\x19max_input_processing_time\x18\x16\x20\x03(\x02R\x16maxInputProcess\
    ingTime\"`\n\x1bCMsgGameMatchSignOutBanData\x12\x1b\n\thero_bans\x18\x01\
    \x20\x03(\rR\x08heroBans\x12$\n\x0ehero_ban_votes\x18\x02\x20\x03(\rR\
    \x0cheroBanVotes\"\xfb\r\n\x1cCMsgDOTALiveScoreboardUpdate\x12#\n\rtourn\
    ament_id\x18\x01\x20\x01(\rR\x0ctournamentId\x12,\n\x12tournament_game_i\
    d\x18\x02\x20\x01(\rR\x10tournamentGameId\x12\x1a\n\x08duration\x18\x03\
    \x20\x01(\x02R\x08duration\x12\x1d\n\nhltv_delay\x18\x04\x20\x01(\x05R\t\
    hltvDelay\x12D\n\tteam_good\x18\x05\x20\x01(\x0b2'.dota.CMsgDOTALiveScor\
    eboardUpdate.TeamR\x08teamGood\x12B\n\x08team_bad\x18\x06\x20\x01(\x0b2'\
    .dota.CMsgDOTALiveScoreboardUpdate.TeamR\x07teamBad\x120\n\x14roshan_res\
    pawn_timer\x18\x07\x20\x01(\rR\x12roshanRespawnTimer\x12\x1b\n\tleague_i\
    d\x18\x08\x20\x01(\rR\x08leagueId\x12\x19\n\x08match_id\x18\t\x20\x01(\
    \x04R\x07matchId\x1a\xd8\n\n\x04Team\x12H\n\x07players\x18\x01\x20\x03(\
    \x0b2..dota.CMsgDOTALiveScoreboardUpdate.Team.PlayerR\x07players\x12\x14\
    \n\x05score\x18\x02\x20\x01(\rR\x05score\x12\x1f\n\x0btower_state\x18\
    \x03\x20\x01(\rR\ntowerState\x12%\n\x0ebarracks_state\x18\x04\x20\x01(\r\
    R\rbarracksState\x12\x1d\n\nhero_picks\x18\x05\x20\x03(\rR\theroPicks\
    \x12\x1b\n\thero_bans\x18\x06\x20\x03(\rR\x08heroBans\x1a\xeb\x08\n\x06P\
    layer\x12\x1f\n\x0bplayer_slot\x18\x01\x20\x01(\rR\nplayerSlot\x12\x1f\n\
    \x0bplayer_name\x18\x02\x20\x01(\tR\nplayerName\x12\x1b\n\thero_name\x18\
    \x03\x20\x01(\tR\x08heroName\x12\x17\n\x07hero_id\x18\x04\x20\x01(\rR\
    \x06heroId\x12\x14\n\x05kills\x18\x05\x20\x01(\rR\x05kills\x12\x16\n\x06\
    deaths\x18\x06\x20\x01(\rR\x06deaths\x12\x18\n\x07assists\x18\x07\x20\
    \x01(\rR\x07assists\x12\x1b\n\tlast_hits\x18\x08\x20\x01(\rR\x08lastHits\
    \x12\x16\n\x06denies\x18\t\x20\x01(\rR\x06denies\x12\x12\n\x04gold\x18\n\
    \x20\x01(\rR\x04gold\x12\x14\n\x05level\x18\x0b\x20\x01(\rR\x05level\x12\
    \x20\n\x0cgold_per_min\x18\x0c\x20\x01(\x02R\ngoldPerMin\x12\x1c\n\nxp_p\
    er_min\x18\r\x20\x01(\x02R\x08xpPerMin\x12g\n\x0eultimate_state\x18\x0e\
    \x20\x01(\x0e2@.dota.CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltima\
    teStateR\rultimateState\x12+\n\x11ultimate_cooldown\x18\x0f\x20\x01(\x02\
    R\x10ultimateCooldown\x12\x14\n\x05item0\x18\x10\x20\x01(\x05R\x05item0\
    \x12\x14\n\x05item1\x18\x11\x20\x01(\x05R\x05item1\x12\x14\n\x05item2\
    \x18\x12\x20\x01(\x05R\x05item2\x12\x14\n\x05item3\x18\x13\x20\x01(\x05R\
    \x05item3\x12\x14\n\x05item4\x18\x14\x20\x01(\x05R\x05item4\x12\x14\n\
    \x05item5\x18\x15\x20\x01(\x05R\x05item5\x12#\n\rrespawn_timer\x18\x16\
    \x20\x01(\rR\x0crespawnTimer\x12\x1d\n\naccount_id\x18\x17\x20\x01(\rR\t\
    accountId\x12\x1d\n\nposition_x\x18\x18\x20\x01(\x02R\tpositionX\x12\x1d\
    \n\nposition_y\x18\x19\x20\x01(\x02R\tpositionY\x12\x1b\n\tnet_worth\x18\
    \x1a\x20\x01(\rR\x08netWorth\x12X\n\tabilities\x18\x1b\x20\x03(\x0b2:.do\
    ta.CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbilityR\tabilities\x1aQ\
    \n\x0bHeroAbility\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilityId\
    \x12#\n\rability_level\x18\x02\x20\x01(\rR\x0cabilityLevel\"\x9b\x01\n\
    \x11DOTAUltimateState\x12\"\n\x1ek_EDOTAUltimateStateNotLearned\x10\0\
    \x12\x20\n\x1ck_EDOTAUltimateStateCooldown\x10\x01\x12!\n\x1dk_EDOTAUlti\
    mateStateNeedsMana\x10\x02\x12\x1d\n\x19k_EDOTAUltimateStateReady\x10\
    \x03\"k\n)CMsgServerToGCRequestBatchPlayerResources\x12\x1f\n\x0baccount\
    _ids\x18\x01\x20\x03(\rR\naccountIds\x12\x1d\n\nrank_types\x18\x04\x20\
    \x03(\rR\trankTypes\"\xbd\x03\n1CMsgServerToGCRequestBatchPlayerResource\
    sResponse\x12X\n\x07results\x18\x06\x20\x03(\x0b2>.dota.CMsgServerToGCRe\
    questBatchPlayerResourcesResponse.ResultR\x07results\x1a\xad\x02\n\x06Re\
    sult\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12*\n\x11prev\
    ent_text_chat\x18\x02\x20\x01(\x08R\x0fpreventTextChat\x12,\n\x12prevent\
    _voice_chat\x18\x03\x20\x01(\x08R\x10preventVoiceChat\x12\x12\n\x04rank\
    \x18\x04\x20\x01(\rR\x04rank\x12'\n\x0frank_calibrated\x18\x05\x20\x01(\
    \x08R\x0erankCalibrated\x12!\n\x0clow_priority\x18\x06\x20\x01(\x08R\x0b\
    lowPriority\x12\"\n\ris_new_player\x18\x07\x20\x01(\x08R\x0bisNewPlayer\
    \x12&\n\x0fis_guide_player\x18\x08\x20\x01(\x08R\risGuidePlayer\"s\n\x1d\
    CMsgDOTAPlayerFailedToConnect\x12%\n\x0efailed_loaders\x18\x01\x20\x03(\
    \x06R\rfailedLoaders\x12+\n\x11abandoned_loaders\x18\x02\x20\x03(\x06R\
    \x10abandonedLoaders\"\xd7\x02\n\x14CMsgGCToRelayConnect\x121\n\x15sourc\
    e_tv_public_addr\x18\x01\x20\x01(\rR\x12sourceTvPublicAddr\x123\n\x16sou\
    rce_tv_private_addr\x18\x02\x20\x01(\rR\x13sourceTvPrivateAddr\x12$\n\
    \x0esource_tv_port\x18\x03\x20\x01(\rR\x0csourceTvPort\x12/\n\x14game_se\
    rver_steam_id\x18\x04\x20\x01(\x04R\x11gameServerSteamId\x12!\n\x0cparen\
    t_count\x18\x05\x20\x01(\rR\x0bparentCount\x121\n\x15tv_unique_secret_co\
    de\x18\x06\x20\x01(\x06R\x12tvUniqueSecretCode\x12*\n\x11source_tv_steam\
    id\x18\x07\x20\x01(\x06R\x0fsourceTvSteamid\"F\n\x1fCMsgGCGCToLANServerR\
    elayConnect\x12#\n\rrelay_steamid\x18\x01\x20\x01(\x06R\x0crelaySteamid\
    \"7\n\x16CMsgGCBanStatusRequest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\r\
    R\taccountId\"\xaa\x01\n\x17CMsgGCBanStatusResponse\x12\x16\n\x06result\
    \x18\x01\x20\x01(\rR\x06result\x12!\n\x0clow_priority\x18\x02\x20\x01(\
    \x08R\x0blowPriority\x12(\n\x10text_chat_banned\x18\x03\x20\x01(\x08R\
    \x0etextChatBanned\x12*\n\x11voice_chat_banned\x18\x04\x20\x01(\x08R\x0f\
    voiceChatBanned\"\xef\x03\n\x17CMsgTournamentItemEvent\x12*\n\x11killer_\
    account_id\x18\x01\x20\x01(\x07R\x0fkillerAccountId\x12*\n\x11victim_acc\
    ount_id\x18\x02\x20\x01(\x07R\x0fvictimAccountId\x12:\n\nevent_type\x18\
    \x03\x20\x01(\x0e2\x1b.dota.DOTA_TournamentEventsR\teventType\x12\x19\n\
    \x08tv_delay\x18\x04\x20\x01(\x05R\x07tvDelay\x12\x1b\n\tdota_time\x18\
    \x05\x20\x01(\x05R\x08dotaTime\x12\x1f\n\x0breplay_time\x18\x06\x20\x01(\
    \x02R\nreplayTime\x12\x1b\n\tloot_list\x18\x07\x20\x01(\tR\x08lootList\
    \x12\x1d\n\nevent_team\x18\x08\x20\x01(\rR\teventTeam\x12(\n\x10multi_ki\
    ll_count\x18\t\x20\x01(\rR\x0emultiKillCount\x12!\n\x0cwinner_score\x18\
    \n\x20\x01(\rR\x0bwinnerScore\x12\x1f\n\x0bloser_score\x18\x0b\x20\x01(\
    \rR\nloserScore\x12=\n\x0chero_statues\x18\x0c\x20\x03(\x0b2\x1a.dota.CP\
    rotoItemHeroStatueR\x0bheroStatues\"\x86\x01\n\x1fCMsgTournamentItemEven\
    tResponse\x12:\n\nevent_type\x18\x01\x20\x01(\x0e2\x1b.dota.DOTA_Tournam\
    entEventsR\teventType\x12'\n\x0fviewers_granted\x18\x06\x20\x01(\rR\x0ev\
    iewersGranted\",\n\x0fCMsgTeamFanfare\x12\x19\n\x08match_id\x18\x01\x20\
    \x01(\x04R\x07matchId\"m\n\x17CMsgResponseTeamFanfare\x12)\n\x10fanfare_\
    goodguys\x18\x01\x20\x01(\rR\x0ffanfareGoodguys\x12'\n\x0ffanfare_badguy\
    s\x18\x02\x20\x01(\rR\x0efanfareBadguys\"\xa6\x01\n\x1cCMsgGameServerUpl\
    oadSaveGame\x12\x1b\n\tgame_time\x18\x01\x20\x01(\rR\x08gameTime\x12$\n\
    \x0esave_game_data\x18\x02\x20\x01(\x0cR\x0csaveGameData\x12\x19\n\x08lo\
    bby_id\x18\x03\x20\x01(\x04R\x07lobbyId\x12(\n\x10player_steam_ids\x18\
    \x04\x20\x03(\x04R\x0eplayerSteamIds\"\xb3\x01\n\x1cCMsgGameServerSaveGa\
    meResult\x12A\n\x06result\x18\x01\x20\x01(\x0e2).dota.CMsgGameServerSave\
    GameResult.ResultR\x06result\"P\n\x06Result\x12\x12\n\x0eSaveSuccessful\
    \x10\0\x12\x13\n\x0fSessionNotFound\x10\x01\x12\x11\n\rDatabaseError\x10\
    \x02\x12\n\n\x06TooBig\x10\x03\"4\n\x19CMsgGameServerGetLoadGame\x12\x17\
    \n\x07save_id\x18\x01\x20\x01(\rR\x06saveId\"G\n\x1fCMsgGameServerGetLoa\
    dGameResult\x12$\n\x0esave_game_data\x18\x01\x20\x01(\x0cR\x0csaveGameDa\
    ta\"\x8f\x04\n\x18CMsgDOTAAwardEventPoints\x12M\n\x0caward_points\x18\
    \x01\x20\x03(\x0b2*.dota.CMsgDOTAAwardEventPoints.AwardPointsR\x0bawardP\
    oints\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\x12'\n\x08e\
    vent_id\x18\x04\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12\x1c\n\ttim\
    estamp\x18\x05\x20\x01(\rR\ttimestamp\x12!\n\x0caudit_action\x18\x06\x20\
    \x01(\rR\x0bauditAction\x1a\x9e\x02\n\x0bAwardPoints\x12\x1d\n\naccount_\
    id\x18\x01\x20\x01(\rR\taccountId\x12\x16\n\x06points\x18\x02\x20\x01(\
    \x05R\x06points\x12%\n\x0epremium_points\x18\x03\x20\x01(\x05R\rpremiumP\
    oints\x12$\n\x0etrade_ban_time\x18\x05\x20\x01(\rR\x0ctradeBanTime\x12G\
    \n\x20eligible_for_periodic_adjustment\x18\x06\x20\x01(\x08R\x1deligible\
    ForPeriodicAdjustment\x12B\n\x1epoint_cap_periodic_resource_id\x18\x07\
    \x20\x01(\rR\x1apointCapPeriodicResourceId\"]\n\x19CMsgGCToServerPingReq\
    uest\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\x06R\trequestId\x12!\n\x0cre\
    quest_time\x18\x02\x20\x01(\x04R\x0brequestTime\"x\n\x1aCMsgGCToServerPi\
    ngResponse\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\x06R\trequestId\x12!\n\
    \x0crequest_time\x18\x02\x20\x01(\x04R\x0brequestTime\x12\x18\n\x07clust\
    er\x18\x03\x20\x01(\rR\x07cluster\"\xa8\x03\n\"CMsgServerToGCMatchConnec\
    tionStats\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\
    \n\tregion_id\x18\x02\x20\x01(\rR\x08regionId\x12\x1b\n\tleague_id\x18\
    \x03\x20\x01(\rR\x08leagueId\x12I\n\x07players\x18\x04\x20\x03(\x0b2/.do\
    ta.CMsgServerToGCMatchConnectionStats.PlayerR\x07players\x12\x1d\n\nclus\
    ter_id\x18\x05\x20\x01(\rR\tclusterId\x1a\xc2\x01\n\x06Player\x12\x1d\n\
    \naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x0e\n\x02ip\x18\x02\x20\
    \x01(\x07R\x02ip\x12\x1e\n\x0bavg_ping_ms\x18\x03\x20\x01(\rR\tavgPingMs\
    \x12\x1f\n\x0bpacket_loss\x18\x05\x20\x01(\x02R\npacketLoss\x12%\n\x0epi\
    ng_deviation\x18\x06\x20\x01(\x02R\rpingDeviation\x12!\n\x0cfull_resends\
    \x18\x07\x20\x01(\rR\x0bfullResends\"K\n\x20CMsgServerGCUpdateSpectatorC\
    ount\x12'\n\x0fspectator_count\x18\x01\x20\x01(\rR\x0espectatorCount\"\
    \xbe\x02\n\x14CSerializedCombatLog\x12\x18\n\x07version\x18\x01\x20\x01(\
    \rR\x07version\x12E\n\ndictionary\x18\x02\x20\x01(\x0b2%.dota.CSerialize\
    dCombatLog.DictionaryR\ndictionary\x126\n\x07entries\x18\x03\x20\x03(\
    \x0b2\x1c.dota.CMsgDOTACombatLogEntryR\x07entries\x1a\x8c\x01\n\nDiction\
    ary\x12J\n\x07strings\x18\x01\x20\x03(\x0b20.dota.CSerializedCombatLog.D\
    ictionary.DictStringR\x07strings\x1a2\n\nDictString\x12\x0e\n\x02id\x18\
    \x01\x20\x02(\rR\x02id\x12\x14\n\x05value\x18\x02\x20\x02(\tR\x05value\"\
    \xc8\x01\n\x20CMsgServerToGCVictoryPredictions\x12G\n\x07records\x18\x01\
    \x20\x03(\x0b2-.dota.CMsgServerToGCVictoryPredictions.RecordR\x07records\
    \x1a[\n\x06Record\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\x12\x19\n\x08item_\
    ids\x18\x05\x20\x03(\x04R\x07itemIds\"\x1d\n\x1bCMsgServerToGCRequestSta\
    tus\"B\n$CMsgServerToGCRequestStatus_Response\x12\x1a\n\x08response\x18\
    \x01\x20\x01(\rR\x08response\"\xe8\x02\n\x1fCMsgSignOutAssassinMiniGameI\
    nfo\x12'\n\x0fwinning_players\x18\x01\x20\x03(\x06R\x0ewinningPlayers\
    \x12%\n\x0elosing_players\x18\x02\x20\x03(\x06R\rlosingPlayers\x12#\n\ra\
    rcana_owners\x18\x03\x20\x03(\x06R\x0carcanaOwners\x12!\n\x0cassassin_wo\
    n\x18\x04\x20\x01(\x08R\x0bassassinWon\x12$\n\x0etarget_hero_id\x18\x05\
    \x20\x01(\rR\x0ctargetHeroId\x12-\n\x12contract_completed\x18\x06\x20\
    \x01(\x08R\x11contractCompleted\x124\n\x16contract_complete_time\x18\x07\
    \x20\x01(\x02R\x14contractCompleteTime\x12\"\n\rpa_is_radiant\x18\x08\
    \x20\x01(\x08R\x0bpaIsRadiant\"\x8b\x02\n\x1bCMsgServerToGCKillSummaries\
    \x12%\n\x0eingameevent_id\x18\x01\x20\x01(\rR\ringameeventId\x12K\n\tsum\
    maries\x18\x02\x20\x03(\x0b2-.dota.CMsgServerToGCKillSummaries.KillSumma\
    ryR\tsummaries\x1ax\n\x0bKillSummary\x12$\n\x0ekiller_hero_id\x18\x01\
    \x20\x01(\rR\x0ckillerHeroId\x12$\n\x0evictim_hero_id\x18\x02\x20\x01(\r\
    R\x0cvictimHeroId\x12\x1d\n\nkill_count\x18\x03\x20\x01(\rR\tkillCount\"\
    \xeb\x03\n\x1eCMsgGCToServerPredictionResult\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\
    \x07matchId\x12\x18\n\x07correct\x18\x03\x20\x01(\x08R\x07correct\x12Q\n\
    \x0bpredictions\x18\x04\x20\x03(\x0b2/.dota.CMsgGCToServerPredictionResu\
    lt.PredictionR\x0bpredictions\x1a\xa1\x02\n\nPrediction\x12\x19\n\x08ite\
    m_def\x18\x01\x20\x01(\rR\x07itemDef\x12\x1f\n\x0bnum_correct\x18\x02\
    \x20\x01(\rR\nnumCorrect\x12\x1b\n\tnum_fails\x18\x03\x20\x01(\rR\x08num\
    Fails\x12O\n\x06result\x18\x04\x20\x01(\x0e27.dota.CMsgGCToServerPredict\
    ionResult.Prediction.EResultR\x06result\x12*\n\x11granted_item_defs\x18\
    \x06\x20\x03(\rR\x0fgrantedItemDefs\"=\n\x07EResult\x12\x19\n\x15k_eResu\
    lt_ItemGranted\x10\x01\x12\x17\n\x13k_eResult_Destroyed\x10\x02\"X\n\x1e\
    CMsgServerToGCLockCharmTrading\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\"\xc7\
    \x03\n\x20CMsgSignOutUpdatePlayerChallenge\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12N\n\tcompleted\x18\x02\x20\x03(\x0b20.dota.CM\
    sgSignOutUpdatePlayerChallenge.ChallengeR\tcompleted\x12L\n\x08rerolled\
    \x18\x03\x20\x03(\x0b20.dota.CMsgSignOutUpdatePlayerChallenge.ChallengeR\
    \x08rerolled\x12\x19\n\x08match_id\x18\x04\x20\x01(\x04R\x07matchId\x12\
    \x17\n\x07hero_id\x18\x05\x20\x01(\rR\x06heroId\x1a\xb1\x01\n\tChallenge\
    \x12'\n\x08event_id\x18\x01\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\
    \x12\x17\n\x07slot_id\x18\x02\x20\x01(\rR\x06slotId\x12\x1f\n\x0bsequenc\
    e_id\x18\x03\x20\x01(\rR\nsequenceId\x12\x1a\n\x08progress\x18\x04\x20\
    \x01(\rR\x08progress\x12%\n\x0echallenge_rank\x18\x05\x20\x01(\rR\rchall\
    engeRank\"\x8e\x01\n#CMsgServerToGCRerollPlayerChallenge\x12\x1d\n\nacco\
    unt_id\x18\x01\x20\x01(\rR\taccountId\x12H\n\nreroll_msg\x18\x02\x20\x01\
    (\x0b2).dota.CMsgClientToGCRerollPlayerChallengeR\trerollMsg\"\xbf\x02\n\
    \x0eCMsgSpendWager\x125\n\x07players\x18\x01\x20\x03(\x0b2\x1b.dota.CMsg\
    SpendWager.PlayerR\x07players\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\
    \x0c.dota.EEventR\x07eventId\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\tt\
    imestamp\x12\x19\n\x08match_id\x18\x04\x20\x01(\x04R\x07matchId\x12&\n\
    \x0fserver_steam_id\x18\x05\x20\x01(\x04R\rserverSteamId\x1al\n\x06Playe\
    r\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x14\n\x05wage\
    r\x18\x02\x20\x01(\rR\x05wager\x12-\n\x13wager_token_item_id\x18\x03\x20\
    \x01(\x04R\x10wagerTokenItemId\"\x8a\x03\n\x12CMsgSignOutXPCoins\x129\n\
    \x07players\x18\x01\x20\x03(\x0b2\x1f.dota.CMsgSignOutXPCoins.PlayerR\
    \x07players\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\
    \x07eventId\x12\x19\n\x08match_id\x18\x03\x20\x01(\x04R\x07matchId\x12\
    \x1c\n\ttimestamp\x18\x04\x20\x01(\rR\ttimestamp\x1a\xd6\x01\n\x06Player\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1b\n\txp_gain\
    ed\x18\x02\x20\x01(\rR\x08xpGained\x12\x1f\n\x0bcoins_spent\x18\x03\x20\
    \x01(\rR\ncoinsSpent\x12-\n\x13wager_token_item_id\x18\x04\x20\x01(\x04R\
    \x10wagerTokenItemId\x12\x1d\n\nrank_wager\x18\x05\x20\x01(\rR\trankWage\
    r\x12!\n\x0cwager_streak\x18\x06\x20\x01(\rR\x0bwagerStreak\"\xca\x02\n\
    \x13CMsgSignOutBounties\x12<\n\x08bounties\x18\x01\x20\x03(\x0b2\x20.dot\
    a.CMsgSignOutBounties.BountyR\x08bounties\x12'\n\x08event_id\x18\x02\x20\
    \x01(\x0e2\x0c.dota.EEventR\x07eventId\x12\x19\n\x08match_id\x18\x03\x20\
    \x01(\x04R\x07matchId\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\rR\ttimestam\
    p\x1a\x92\x01\n\x06Bounty\x12*\n\x11issuer_account_id\x18\x01\x20\x01(\r\
    R\x0fissuerAccountId\x120\n\x14completer_account_id\x18\x02\x20\x01(\rR\
    \x12completerAccountId\x12*\n\x11target_account_id\x18\x03\x20\x01(\rR\
    \x0ftargetAccountId\"\x96\x02\n\x20CMsgSignOutCommunityGoalProgress\x12'\
    \n\x08event_id\x18\x01\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12d\n\
    \x10event_increments\x18\x02\x20\x03(\x0b29.dota.CMsgSignOutCommunityGoa\
    lProgress.EventGoalIncrementR\x0feventIncrements\x1ac\n\x12EventGoalIncr\
    ement\x12\"\n\revent_goal_id\x18\x01\x20\x01(\rR\x0beventGoalId\x12)\n\
    \x10increment_amount\x18\x02\x20\x01(\rR\x0fincrementAmount\"\x8c\x01\n3\
    CMsgServerToGCCloseCompendiumInGamePredictionVoting\x12\x19\n\x08match_i\
    d\x18\x01\x20\x01(\x04R\x07matchId\x12\x1d\n\nhltv_delay\x18\x02\x20\x01\
    (\rR\thltvDelay\x12\x1b\n\tleague_id\x18\x03\x20\x01(\rR\x08leagueId\"U\
    \n;CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse\x12\x16\n\
    \x06result\x18\x01\x20\x01(\x08R\x06result\"\x8f\x03\n/CMsgServerToGCCom\
    pendiumInGamePredictionResults\x12\x19\n\x08match_id\x18\x01\x20\x01(\
    \x04R\x07matchId\x12`\n\x07results\x18\x02\x20\x03(\x0b2F.dota.CMsgServe\
    rToGCCompendiumInGamePredictionResults.PredictionResultR\x07results\x12\
    \x1b\n\tleague_id\x18\x03\x20\x01(\rR\x08leagueId\x12$\n\x0eleague_node_\
    id\x18\x04\x20\x01(\rR\x0cleagueNodeId\x1a\x9b\x01\n\x10PredictionResult\
    \x12#\n\rprediction_id\x18\x01\x20\x01(\rR\x0cpredictionId\x12)\n\x10pre\
    diction_value\x18\x02\x20\x01(\rR\x0fpredictionValue\x127\n\x18predictio\
    n_value_is_mask\x18\x03\x20\x01(\x08R\x15predictionValueIsMask\"\x8d\x02\
    \n/CMsgServerToGCCompendiumChosenInGamePredictions\x12\x19\n\x08match_id\
    \x18\x01\x20\x01(\x04R\x07matchId\x12o\n\x12predictions_chosen\x18\x02\
    \x20\x03(\x0b2@.dota.CMsgServerToGCCompendiumChosenInGamePredictions.Pre\
    dictionR\x11predictionsChosen\x12\x1b\n\tleague_id\x18\x03\x20\x01(\rR\
    \x08leagueId\x1a1\n\nPrediction\x12#\n\rprediction_id\x18\x01\x20\x01(\r\
    R\x0cpredictionId\"~\n+CMsgGCToGCCompendiumInGamePredictionResults\x12O\
    \n\x07results\x18\x01\x20\x01(\x0b25.dota.CMsgServerToGCCompendiumInGame\
    PredictionResultsR\x07results\"\xc0\x05\n,CMsgServerToGCMatchPlayerItemP\
    urchaseHistory\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\
    \x12\x10\n\x03mmr\x18\x02\x20\x01(\rR\x03mmr\x12S\n\x07players\x18\x03\
    \x20\x03(\x0b29.dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.Player\
    R\x07players\x1a\xc2\x01\n\x0cItemPurchase\x12\x12\n\x04item\x18\x01\x20\
    \x01(\x05R\x04item\x12\x12\n\x04gold\x18\x02\x20\x01(\rR\x04gold\x12\x1b\
    \n\tnet_worth\x18\x03\x20\x01(\rR\x08netWorth\x12\x1b\n\tgame_time\x18\
    \x04\x20\x01(\rR\x08gameTime\x12'\n\x0finventory_items\x18\x05\x20\x03(\
    \x05R\x0einventoryItems\x12'\n\x0ftalents_skilled\x18\x07\x20\x03(\x08R\
    \x0etalentsSkilled\x1a\xc8\x02\n\x06Player\x12\x1f\n\x0bplayer_slot\x18\
    \x01\x20\x01(\rR\nplayerSlot\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\t\
    accountId\x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\x06heroId\x12&\n\x0fa\
    llied_hero_ids\x18\x04\x20\x03(\rR\ralliedHeroIds\x12$\n\x0eenemy_hero_i\
    ds\x18\x05\x20\x03(\rR\x0cenemyHeroIds\x12f\n\x0eitem_purchases\x18\x06\
    \x20\x03(\x0b2?.dota.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPu\
    rchaseR\ritemPurchases\x12\x12\n\x04lane\x18\x07\x20\x01(\rR\x04lane\x12\
    \x1b\n\tis_winner\x18\x08\x20\x01(\x08R\x08isWinner\"\xe7\x04\n0CMsgServ\
    erToGCMatchPlayerNeutralItemEquipHistory\x12\x19\n\x08match_id\x18\x01\
    \x20\x01(\x04R\x07matchId\x12W\n\x07players\x18\x02\x20\x03(\x0b2=.dota.\
    CMsgServerToGCMatchPlayerNeutralItemEquipHistory.PlayerR\x07players\x1a\
    \xc6\x01\n\tItemEquip\x12\x12\n\x04item\x18\x01\x20\x01(\x05R\x04item\
    \x12\x1b\n\tgame_time\x18\x02\x20\x01(\rR\x08gameTime\x12'\n\x0finventor\
    y_items\x18\x03\x20\x03(\x05R\x0einventoryItems\x12'\n\x0ftalents_skille\
    d\x18\x04\x20\x03(\x08R\x0etalentsSkilled\x126\n\x17available_neutral_it\
    ems\x18\x05\x20\x03(\x05R\x15availableNeutralItems\x1a\xf5\x01\n\x06Play\
    er\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12&\n\x0fallied\
    _hero_ids\x18\x02\x20\x03(\rR\ralliedHeroIds\x12$\n\x0eenemy_hero_ids\
    \x18\x03\x20\x03(\rR\x0cenemyHeroIds\x12a\n\x0bitem_equips\x18\x04\x20\
    \x03(\x0b2@.dota.CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEq\
    uipR\nitemEquips\x12\x1b\n\tis_winner\x18\x05\x20\x01(\x08R\x08isWinner\
    \"\xf1\x08\n\x1fCMsgServerToGCMatchStateHistory\x12\x19\n\x08match_id\
    \x18\x01\x20\x01(\x04R\x07matchId\x12\x1f\n\x0bradiant_won\x18\x02\x20\
    \x01(\x08R\nradiantWon\x12\x10\n\x03mmr\x18\x03\x20\x01(\rR\x03mmr\x12S\
    \n\x0cmatch_states\x18\x04\x20\x03(\x0b20.dota.CMsgServerToGCMatchStateH\
    istory.MatchStateR\x0bmatchStates\x1a\x8d\x02\n\x0bPlayerState\x12\x17\n\
    \x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\x1b\n\tnet_worth\x18\x02\
    \x20\x01(\rR\x08netWorth\x12\x14\n\x05level\x18\x03\x20\x01(\rR\x05level\
    \x12\x16\n\x06deaths\x18\x04\x20\x01(\rR\x06deaths\x12!\n\x0crespawn_tim\
    e\x18\x05\x20\x01(\rR\x0brespawnTime\x12\x1f\n\x0bhas_buyback\x18\x06\
    \x20\x01(\x08R\nhasBuyback\x12\x1b\n\thas_aegis\x18\x07\x20\x01(\x08R\
    \x08hasAegis\x12\x1d\n\nhas_rapier\x18\x08\x20\x01(\x08R\thasRapier\x12\
    \x1a\n\x08distance\x18\t\x20\x01(\rR\x08distance\x1a\xc8\x03\n\tTeamStat\
    e\x12\x12\n\x04team\x18\x01\x20\x01(\rR\x04team\x12V\n\rplayer_states\
    \x18\x02\x20\x03(\x0b21.dota.CMsgServerToGCMatchStateHistory.PlayerState\
    R\x0cplayerStates\x12(\n\x10tower_health_pct\x18\x03\x20\x03(\rR\x0etowe\
    rHealthPct\x12.\n\x13barracks_health_pct\x18\x04\x20\x03(\rR\x11barracks\
    HealthPct\x12,\n\x12ancient_health_pct\x18\x05\x20\x01(\rR\x10ancientHea\
    lthPct\x12%\n\x0eglyph_cooldown\x18\x06\x20\x01(\rR\rglyphCooldown\x12\
    \x14\n\x05kills\x18\x07\x20\x01(\rR\x05kills\x12.\n\x13creep_distance_sa\
    fe\x18\x08\x20\x01(\rR\x11creepDistanceSafe\x12,\n\x12creep_distance_mid\
    \x18\t\x20\x01(\rR\x10creepDistanceMid\x12,\n\x12creep_distance_off\x18\
    \n\x20\x01(\rR\x10creepDistanceOff\x1a\xcf\x01\n\nMatchState\x12\x1b\n\t\
    game_time\x18\x01\x20\x01(\rR\x08gameTime\x12T\n\rradiant_state\x18\x02\
    \x20\x01(\x0b2/.dota.CMsgServerToGCMatchStateHistory.TeamStateR\x0cradia\
    ntState\x12N\n\ndire_state\x18\x03\x20\x01(\x0b2/.dota.CMsgServerToGCMat\
    chStateHistory.TeamStateR\tdireState\"\xa2\x01\n\x1aCMsgMatchStateSteamM\
    LEntry\x12Q\n\x0bmatch_state\x18\x01\x20\x01(\x0b20.dota.CMsgServerToGCM\
    atchStateHistory.MatchStateR\nmatchState\x12\x10\n\x03mmr\x18\x02\x20\
    \x01(\rR\x03mmr\x12\x1f\n\x0bradiant_won\x18\x03\x20\x01(\x08R\nradiantW\
    on\"P\n\x1dCMsgLaneSelectionSteamMLEntry\x12\x19\n\x08hero_ids\x18\x01\
    \x20\x03(\rR\x07heroIds\x12\x14\n\x05lanes\x18\x02\x20\x03(\rR\x05lanes\
    \"\xd0\x01\n\x20CMsgAbilitySelectionSteamMLEntry\x12\x10\n\x03mmr\x18\
    \x01\x20\x01(\rR\x03mmr\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06hero\
    Id\x12$\n\x0eenemy_hero_ids\x18\x03\x20\x03(\rR\x0cenemyHeroIds\x12\x12\
    \n\x04lane\x18\x04\x20\x01(\rR\x04lane\x12\x1c\n\tabilities\x18\x05\x20\
    \x03(\x05R\tabilities\x12)\n\x10selected_ability\x18\x06\x20\x01(\x05R\
    \x0fselectedAbility\"\xe2\x01\n#CMsgItemPurchasePregameSteamMLEntry\x12\
    \x10\n\x03mmr\x18\x01\x20\x01(\rR\x03mmr\x12\x12\n\x04lane\x18\x02\x20\
    \x01(\rR\x04lane\x12\x18\n\x07balance\x18\x03\x20\x01(\x02R\x07balance\
    \x12\x17\n\x07hero_id\x18\x04\x20\x01(\rR\x06heroId\x12&\n\x0fallied_her\
    o_ids\x18\x05\x20\x03(\rR\ralliedHeroIds\x12$\n\x0eenemy_hero_ids\x18\
    \x06\x20\x03(\rR\x0cenemyHeroIds\x12\x14\n\x05items\x18\x07\x20\x03(\x05\
    R\x05items\"\xf4\x01\n\x1cCMsgItemPurchaseSteamMLEntry\x12\x10\n\x03mmr\
    \x18\x01\x20\x01(\rR\x03mmr\x12\x12\n\x04lane\x18\x02\x20\x01(\rR\x04lan\
    e\x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\x06heroId\x12&\n\x0fallied_he\
    ro_ids\x18\x04\x20\x03(\rR\ralliedHeroIds\x12$\n\x0eenemy_hero_ids\x18\
    \x05\x20\x03(\rR\x0cenemyHeroIds\x12\x14\n\x05items\x18\x06\x20\x03(\x05\
    R\x05items\x121\n\x15items_to_be_purchased\x18\x07\x20\x03(\x05R\x12item\
    sToBePurchased\"\xfa\x01\n$CMsgItemPurchaseSequenceSteamMLEntry\x12\x10\
    \n\x03mmr\x18\x01\x20\x01(\rR\x03mmr\x12\x12\n\x04lane\x18\x02\x20\x01(\
    \rR\x04lane\x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\x06heroId\x12&\n\
    \x0fallied_hero_ids\x18\x04\x20\x03(\rR\ralliedHeroIds\x12$\n\x0eenemy_h\
    ero_ids\x18\x05\x20\x03(\rR\x0cenemyHeroIds\x12\x14\n\x05items\x18\x06\
    \x20\x03(\x05R\x05items\x12/\n\x14item_to_be_purchased\x18\x07\x20\x01(\
    \x05R\x11itemToBePurchased\"\xcd\x01\n%CMsgServerToGCCavernCrawlIsHeroAc\
    tive\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12\x1d\n\nacc\
    ount_id\x18\x02\x20\x01(\rR\taccountId\x122\n\x15preferred_map_variant\
    \x18\x03\x20\x01(\rR\x13preferredMapVariant\x12\x17\n\x07hero_id\x18\x04\
    \x20\x01(\rR\x06heroId\x12\x1d\n\nturbo_mode\x18\x05\x20\x01(\x08R\tturb\
    oMode\"\xee\x04\n$CMsgServerToGCPlayerChallengeHistory\x12\x19\n\x08matc\
    h_id\x18\x01\x20\x01(\x04R\x07matchId\x12!\n\x0caverage_rank\x18\x02\x20\
    \x01(\rR\x0baverageRank\x12g\n\x11challenge_records\x18\x03\x20\x03(\x0b\
    2:.dota.CMsgServerToGCPlayerChallengeHistory.PlayerChallengeR\x10challen\
    geRecords\x1a\x9e\x03\n\x0fPlayerChallenge\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12H\n\x0echallenge_type\x18\x02\x20\x01(\x0e2!.\
    dota.EPlayerChallengeHistoryTypeR\rchallengeType\x12#\n\rchallenge_id1\
    \x18\x03\x20\x01(\rR\x0cchallengeId1\x12#\n\rchallenge_id2\x18\x04\x20\
    \x01(\rR\x0cchallengeId2\x120\n\x14progress_value_start\x18\x05\x20\x01(\
    \rR\x12progressValueStart\x12,\n\x12progress_value_end\x18\x06\x20\x01(\
    \rR\x10progressValueEnd\x12\x19\n\x08team_won\x18\x07\x20\x01(\x08R\x07t\
    eamWon\x12\x1d\n\naudit_data\x18\x08\x20\x01(\x04R\tauditData\x12\x17\n\
    \x07hero_id\x18\t\x20\x01(\rR\x06heroId\x12%\n\x0erank_completed\x18\n\
    \x20\x01(\rR\rrankCompleted\"\x9d\x03\n-CMsgServerToGCCavernCrawlIsHeroA\
    ctiveResponse\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\x12\
    \x1f\n\x0bmap_variant\x18\x05\x20\x01(\rR\nmapVariant\x12-\n\x12potentia\
    l_winnings\x18\x02\x20\x01(\rR\x11potentialWinnings\x12_\n\x0bmap_result\
    s\x18\x03\x20\x03(\x0b2>.dota.CMsgServerToGCCavernCrawlIsHeroActiveRespo\
    nse.MapResultsR\nmapResults\x12A\n\x1dpotential_plus_shard_winnings\x18\
    \x04\x20\x01(\rR\x1apotentialPlusShardWinnings\x1a`\n\nMapResults\x12*\n\
    \x11path_id_completed\x18\x01\x20\x01(\rR\x0fpathIdCompleted\x12&\n\x0fr\
    oom_id_claimed\x18\x02\x20\x01(\rR\rroomIdClaimed\"K\n\x20CMsgGCtoServer\
    TensorflowInstance\x12'\n\x0fserver_instance\x18\x01\x20\x01(\rR\x0eserv\
    erInstance\"\xe5\x0e\n\x15CMsgDetailedGameStats\x12A\n\x07minutes\x18\
    \x01\x20\x03(\x0b2'.dota.CMsgDetailedGameStats.MinuteEntryR\x07minutes\
    \x12G\n\x0bplayer_info\x18\x02\x20\x03(\x0b2&.dota.CMsgDetailedGameStats\
    .PlayerInfoR\nplayerInfo\x12D\n\ngame_stats\x18\x03\x20\x01(\x0b2%.dota.\
    CMsgDetailedGameStats.GameStatsR\tgameStats\x1a\x8d\n\n\x0fPlayerStatEnt\
    ry\x12*\n\x11total_earned_gold\x18\x01\x20\x01(\rR\x0ftotalEarnedGold\
    \x12%\n\x0etotal_networth\x18\x02\x20\x01(\rR\rtotalNetworth\x12\x14\n\
    \x05level\x18\x03\x20\x01(\rR\x05level\x12\x1b\n\ttotal_dps\x18\x04\x20\
    \x01(\rR\x08totalDps\x12\x1f\n\x0baverage_dps\x18\x05\x20\x01(\rR\navera\
    geDps\x122\n\x15ability_damage_output\x18\x06\x20\x01(\rR\x13abilityDama\
    geOutput\x12\x1f\n\x0bbase_health\x18\x07\x20\x01(\rR\nbaseHealth\x12!\n\
    \x0ctotal_health\x18\x08\x20\x01(\rR\x0btotalHealth\x12\x1d\n\ntotal_man\
    a\x18\t\x20\x01(\rR\ttotalMana\x12J\n\"base_physical_damage_reduction_pc\
    t\x18\n\x20\x01(\x02R\x1ebasePhysicalDamageReductionPct\x12L\n#total_phy\
    sical_damage_reduction_pct\x18\x0b\x20\x01(\x02R\x1ftotalPhysicalDamageR\
    eductionPct\x12H\n!base_ability_damage_reduction_pct\x18\x0c\x20\x01(\
    \x02R\x1dbaseAbilityDamageReductionPct\x12J\n\"total_ability_damage_redu\
    ction_pct\x18\r\x20\x01(\x02R\x1etotalAbilityDamageReductionPct\x120\n\
    \x14ability_damage_block\x18\x0e\x20\x01(\x02R\x12abilityDamageBlock\x12\
    2\n\x15physical_damage_block\x18\x0f\x20\x01(\x02R\x13physicalDamageBloc\
    k\x12\x1d\n\nmana_regen\x18\x10\x20\x01(\rR\tmanaRegen\x12!\n\x0chealth_\
    regen\x18\x11\x20\x01(\rR\x0bhealthRegen\x123\n\x16physical_magic_dmg_pc\
    t\x18\x12\x20\x01(\x02R\x13physicalMagicDmgPct\x12\x14\n\x05kills\x18\
    \x13\x20\x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x14\x20\x01(\rR\x06dea\
    ths\x12\x18\n\x07assists\x18\x15\x20\x01(\rR\x07assists\x12&\n\x0fgold_f\
    rom_kills\x18\x16\x20\x01(\rR\rgoldFromKills\x12(\n\x10gold_from_creeps\
    \x18\x17\x20\x01(\rR\x0egoldFromCreeps\x12\x1f\n\x0bgold_shared\x18\x18\
    \x20\x01(\rR\ngoldShared\x12\"\n\rxp_from_kills\x18\x19\x20\x01(\rR\x0bx\
    pFromKills\x12$\n\x0exp_from_creeps\x18\x1a\x20\x01(\rR\x0cxpFromCreeps\
    \x12\x19\n\x08total_xp\x18\x1b\x20\x01(\rR\x07totalXp\x12#\n\rability_ca\
    sts\x18\x1c\x20\x01(\rR\x0cabilityCasts\x12\x1d\n\nitem_casts\x18\x1d\
    \x20\x01(\rR\titemCasts\x12,\n\x12total_time_stunned\x18\x1e\x20\x01(\
    \x02R\x10totalTimeStunned\x12\x1d\n\nitem_count\x18\x1f\x20\x01(\rR\tite\
    mCount\x1a\x98\x01\n\tGameStats\x12-\n\x13tower_death_time_t1\x18\x01\
    \x20\x01(\rR\x10towerDeathTimeT1\x12-\n\x13tower_death_time_t2\x18\x02\
    \x20\x01(\rR\x10towerDeathTimeT2\x12-\n\x13tower_death_time_t3\x18\x03\
    \x20\x01(\rR\x10towerDeathTimeT3\x1ah\n\x0bMinuteEntry\x12\x16\n\x06minu\
    te\x18\x01\x20\x01(\rR\x06minute\x12A\n\x05stats\x18\x02\x20\x03(\x0b2+.\
    dota.CMsgDetailedGameStats.PlayerStatEntryR\x05stats\x1ae\n\nPlayerInfo\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x17\n\x07hero_\
    id\x18\x02\x20\x01(\rR\x06heroId\x12\x1f\n\x0bplayer_slot\x18\x03\x20\
    \x01(\rR\nplayerSlot\"\xd0\x02\n\x14CMsgNeutralItemStats\x12K\n\rneutral\
    _items\x18\x01\x20\x03(\x0b2&.dota.CMsgNeutralItemStats.NeutralItemR\x0c\
    neutralItems\x1a\xea\x01\n\x0bNeutralItem\x12\x17\n\x07item_id\x18\x01\
    \x20\x01(\x05R\x06itemId\x12!\n\x0ctime_dropped\x18\x02\x20\x01(\rR\x0bt\
    imeDropped\x12\x12\n\x04team\x18\x03\x20\x01(\rR\x04team\x12,\n\x12time_\
    last_equipped\x18\x04\x20\x01(\rR\x10timeLastEquipped\x120\n\x14time_las\
    t_unequipped\x18\x05\x20\x01(\rR\x12timeLastUnequipped\x12+\n\x11duratio\
    n_equipped\x18\x06\x20\x01(\rR\x10durationEquipped\"\xd5\x01\n\x1fCMsgGC\
    ToServerLobbyHeroBanRates\x12M\n\x08ban_data\x18\x01\x20\x03(\x0b22.dota\
    .CMsgGCToServerLobbyHeroBanRates.HeroBanEntryR\x07banData\x1ac\n\x0cHero\
    BanEntry\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\x1b\n\tb\
    an_count\x18\x02\x20\x01(\rR\x08banCount\x12\x1d\n\npick_count\x18\x03\
    \x20\x01(\rR\tpickCount\"\xa0\x03\n\x20CMsgSignOutGuildContractProgress\
    \x12`\n\x10player_contracts\x18\x01\x20\x03(\x0b25.dota.CMsgSignOutGuild\
    ContractProgress.PlayerContractR\x0fplayerContracts\x1ar\n\x1cCompletedG\
    uildEventContracts\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\
    \x12\x19\n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\x12\x1c\n\tcontrac\
    ts\x18\x03\x20\x03(\x04R\tcontracts\x1a\xa5\x01\n\x0ePlayerContract\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12t\n\x13completed_co\
    ntracts\x18\x02\x20\x03(\x0b2C.dota.CMsgSignOutGuildContractProgress.Com\
    pletedGuildEventContractsR\x12completedContracts\"\xe5\x03\n!CMsgSignOut\
    GuildChallengeProgress\x12y\n\x1bguild_challenges_progresses\x18\x01\x20\
    \x03(\x0b29.dota.CMsgSignOutGuildChallengeProgress.ChallengeProgressR\
    \x19guildChallengesProgresses\x1a\xc4\x02\n\x11ChallengeProgress\x12\x19\
    \n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12\x19\n\x08event_id\x18\
    \x02\x20\x01(\rR\x07eventId\x122\n\x15challenge_instance_id\x18\x03\x20\
    \x01(\rR\x13challengeInstanceId\x12@\n\x1cchallenge_instance_timestamp\
    \x18\x04\x20\x01(\rR\x1achallengeInstanceTimestamp\x126\n\x17challenge_p\
    eriod_serial\x18\x05\x20\x01(\rR\x15challengePeriodSerial\x12\x1a\n\x08p\
    rogress\x18\x06\x20\x01(\rR\x08progress\x12/\n\x13challenge_parameter\
    \x18\x07\x20\x01(\rR\x12challengeParameter\"\xfc\x08\n\x13CMsgSignOutMVP\
    Stats\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\n\t\
    game_mode\x18\x02\x20\x01(\rR\x08gameMode\x12!\n\x0cwinning_team\x18\x03\
    \x20\x01(\rR\x0bwinningTeam\x12\x1b\n\tgame_time\x18\x04\x20\x01(\x02R\
    \x08gameTime\x12:\n\x07players\x18\x05\x20\x03(\x0b2\x20.dota.CMsgSignOu\
    tMVPStats.PlayerR\x07players\x1a\xb0\x07\n\x06Player\x12\x17\n\x07team_i\
    d\x18\x01\x20\x01(\rR\x06teamId\x12,\n\x12team_networth_rank\x18\x02\x20\
    \x01(\rR\x10teamNetworthRank\x12\x1d\n\naccount_id\x18\x03\x20\x01(\rR\t\
    accountId\x12\x1f\n\x0bplayer_slot\x18\x20\x20\x01(\rR\nplayerSlot\x12\
    \x12\n\x04rank\x18!\x20\x01(\rR\x04rank\x12\x17\n\x07hero_id\x18\x04\x20\
    \x01(\rR\x06heroId\x12\x12\n\x04role\x18\x05\x20\x01(\rR\x04role\x12\x14\
    \n\x05kills\x18\x06\x20\x01(\x05R\x05kills\x12\x16\n\x06deaths\x18\x07\
    \x20\x01(\x05R\x06deaths\x12\x18\n\x07assists\x18\x08\x20\x01(\x05R\x07a\
    ssists\x12\x0e\n\x02xp\x18\t\x20\x01(\x05R\x02xp\x12\x1b\n\tnet_worth\
    \x18\n\x20\x01(\x05R\x08netWorth\x12,\n\x12support_gold_spent\x18\x0c\
    \x20\x01(\x05R\x10supportGoldSpent\x12!\n\x0cwards_placed\x18\r\x20\x01(\
    \x05R\x0bwardsPlaced\x12=\n\x1bwards_spotted_for_dewarding\x18\x0e\x20\
    \x01(\x05R\x18wardsSpottedForDewarding\x12#\n\rcamps_stacked\x18\x0f\x20\
    \x01(\x05R\x0ccampsStacked\x12\x1b\n\tlast_hits\x18\x10\x20\x01(\x05R\
    \x08lastHits\x12\x16\n\x06denies\x18\x11\x20\x01(\x05R\x06denies\x12'\n\
    \x0fbuilding_damage\x18\x13\x20\x01(\x05R\x0ebuildingDamage\x12!\n\x0cot\
    her_damage\x18\x14\x20\x01(\x05R\x0botherDamage\x12!\n\x0ctriple_kills\
    \x18\x1a\x20\x01(\x05R\x0btripleKills\x12\x1a\n\x08rampages\x18\x1c\x20\
    \x01(\x05R\x08rampages\x12\x1f\n\x0bfirst_blood\x18\x1f\x20\x01(\x05R\nf\
    irstBlood\x12[\n\x11kill_eater_events\x18\"\x20\x03(\x0b2/.dota.CMsgSign\
    OutMVPStats.Player.KillEaterEventR\x0fkillEaterEvents\x12-\n\x12highest_\
    killstreak\x18#\x20\x01(\rR\x11highestKillstreak\x1aG\n\x0eKillEaterEven\
    t\x12\x1d\n\nevent_type\x18\x01\x20\x02(\rR\teventType\x12\x16\n\x06amou\
    nt\x18\x02\x20\x02(\rR\x06amount\":\n\x20CMsgGCToServerRecordTrainingDat\
    a\x12\x16\n\x06enable\x18\x01\x20\x01(\x08R\x06enable\"B\n\x1fCMsgServer\
    ToGCGetGuildContracts\x12\x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\nacco\
    untIds\"\xbb\x04\n'CMsgServerToGCGetGuildContractsResponse\x12_\n\x10pla\
    yer_contracts\x18\x01\x20\x03(\x0b24.dota.CMsgServerToGCGetGuildContract\
    sResponse.PlayerR\x0fplayerContracts\x1a\xe3\x01\n\x0fContractDetails\
    \x12\x1f\n\x0bcontract_id\x18\x01\x20\x01(\x04R\ncontractId\x122\n\x15ch\
    allenge_instance_id\x18\x02\x20\x01(\rR\x13challengeInstanceId\x12/\n\
    \x13challenge_parameter\x18\x03\x20\x01(\rR\x12challengeParameter\x12%\n\
    \x0econtract_stars\x18\x04\x20\x01(\rR\rcontractStars\x12#\n\rcontract_s\
    lot\x18\x05\x20\x01(\rR\x0ccontractSlot\x1a\xc8\x01\n\x06Player\x12\x1d\
    \n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08guild_id\x18\
    \x02\x20\x01(\rR\x07guildId\x12'\n\x08event_id\x18\x03\x20\x01(\x0e2\x0c\
    .dota.EEventR\x07eventId\x12[\n\tcontracts\x18\x04\x20\x03(\x0b2=.dota.C\
    MsgServerToGCGetGuildContractsResponse.ContractDetailsR\tcontracts\"\xb9\
    \x03\n\x16CMsgMatchDiretideCandy\x12T\n\x11player_candy_data\x18\x01\x20\
    \x03(\x0b2(.dota.CMsgMatchDiretideCandy.PlayerCandyR\x0fplayerCandyData\
    \x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\
    \x1a<\n\x0cCandyDetails\x12\x16\n\x06amount\x18\x01\x20\x01(\rR\x06amoun\
    t\x12\x14\n\x05audit\x18\x02\x20\x01(\rR\x05audit\x1a\xe1\x01\n\x0bPlaye\
    rCandy\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12!\n\x0cca\
    ndy_amount\x18\x03\x20\x01(\rR\x0bcandyAmount\x12<\n\x1aconsumes_periodi\
    c_resource\x18\x04\x20\x01(\x08R\x18consumesPeriodicResource\x12R\n\x0fc\
    andy_breakdown\x18\x05\x20\x03(\x0b2).dota.CMsgMatchDiretideCandy.CandyD\
    etailsR\x0ecandyBreakdown\"\xba\x01\n\x17CMsgGCToServerCheerData\x12M\n\
    \x0bcheer_types\x18\x01\x20\x03(\x0b2,.dota.CMsgGCToServerCheerData.Chee\
    rTypeCountR\ncheerTypes\x1aP\n\x0eCheerTypeCount\x12\x1d\n\ncheer_type\
    \x18\x01\x20\x01(\rR\tcheerType\x12\x1f\n\x0bcheer_count\x18\x02\x20\x01\
    (\rR\ncheerCount\"\x82\x07\n\x0fCMsgCheerConfig\x12%\n\x0echeers_enabled\
    \x18\x01\x20\x01(\x08R\rcheersEnabled\x12+\n\x12is_valid_league_id\x18\
    \x02\x20\x01(\x08R\x0fisValidLeagueId\x12'\n\x0fwindow_duration\x18\x03\
    \x20\x01(\x02R\x0ewindowDuration\x12.\n\x13window_bucket_count\x18\x04\
    \x20\x01(\rR\x11windowBucketCount\x121\n\x15crowd_level_push_time\x18\
    \x06\x20\x01(\x02R\x12crowdLevelPushTime\x12&\n\x0fcrowd_level_low\x18\n\
    \x20\x01(\rR\rcrowdLevelLow\x12,\n\x12crowd_level_medium\x18\x0b\x20\x01\
    (\rR\x10crowdLevelMedium\x12(\n\x10crowd_level_high\x18\x0c\x20\x01(\rR\
    \x0ecrowdLevelHigh\x12*\n\x11cheer_scale_start\x18\r\x20\x01(\x02R\x0fch\
    eerScaleStart\x12*\n\x11cheer_scale_speed\x18\x0e\x20\x01(\x02R\x0fcheer\
    ScaleSpeed\x121\n\x15cheer_scale_push_mark\x18\x0f\x20\x01(\rR\x12cheerS\
    calePushMark\x121\n\x15cheer_scale_pull_mark\x18\x10\x20\x01(\rR\x12chee\
    rScalePullMark\x12D\n\x20cheer_scale_pct_of_max_cps_clamp\x18\x11\x20\
    \x01(\x02R\x1acheerScalePctOfMaxCpsClamp\x12;\n\x1acheer_scale_dampener_\
    value\x18\x15\x20\x01(\x02R\x17cheerScaleDampenerValue\x12B\n\x1echeer_s\
    cale_dampener_lerp_time\x18\x16\x20\x01(\rR\x1acheerScaleDampenerLerpTim\
    e\x12.\n\x13cheer_factor_bronze\x18\x12\x20\x01(\x02R\x11cheerFactorBron\
    ze\x12.\n\x13cheer_factor_silver\x18\x13\x20\x01(\x02R\x11cheerFactorSil\
    ver\x12*\n\x11cheer_factor_gold\x18\x14\x20\x01(\x02R\x0fcheerFactorGold\
    \"U\n\x19CMsgGCToServerCheerConfig\x128\n\x0ccheer_config\x18\x01\x20\
    \x01(\x0b2\x15.dota.CMsgCheerConfigR\x0bcheerConfig\";\n\x1cCMsgServerTo\
    GCGetCheerConfig\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\"`\
    \n$CMsgServerToGCGetCheerConfigResponse\x128\n\x0ccheer_config\x18\x02\
    \x20\x01(\x0b2\x15.dota.CMsgCheerConfigR\x0bcheerConfig\";\n!CMsgGCToSer\
    verCheerScalesOverride\x12\x16\n\x06scales\x18\x01\x20\x03(\x02R\x06scal\
    es\"\x1d\n\x1bCMsgGCToServerGetCheerState\"\xa5\x01\n\x12CMsgCheerTypeSt\
    ate\x12!\n\x0ccheer_counts\x18\x01\x20\x03(\rR\x0bcheerCounts\x12$\n\x0e\
    max_per_second\x18\x02\x20\x01(\x02R\x0cmaxPerSecond\x12\x1f\n\x0bcheer_\
    scale\x18\x03\x20\x01(\x02R\ncheerScale\x12%\n\x0eoverride_scale\x18\x04\
    \x20\x01(\x02R\roverrideScale\"\xa5\x01\n\x0eCMsgCheerState\x129\n\x0bch\
    eer_types\x18\x01\x20\x03(\x0b2\x18.dota.CMsgCheerTypeStateR\ncheerTypes\
    \x12.\n\x13radiant_crowd_level\x18\x02\x20\x01(\rR\x11radiantCrowdLevel\
    \x12(\n\x10dire_crowd_level\x18\x03\x20\x01(\rR\x0edireCrowdLevel\"\x91\
    \x01\n\x1eCMsgServerToGCReportCheerState\x128\n\x0ccheer_config\x18\x01\
    \x20\x01(\x0b2\x15.dota.CMsgCheerConfigR\x0bcheerConfig\x125\n\x0bcheer_\
    state\x18\x02\x20\x01(\x0b2\x14.dota.CMsgCheerStateR\ncheerState\"A\n\
    \x1eCMsgServerToGCGetStickerHeroes\x12\x1f\n\x0baccount_ids\x18\x01\x20\
    \x03(\rR\naccountIds\"\xd5\x01\n&CMsgServerToGCGetStickerHeroesResponse\
    \x12M\n\x07players\x18\x01\x20\x03(\x0b23.dota.CMsgServerToGCGetStickerH\
    eroesResponse.PlayerR\x07players\x1a\\\n\x06Player\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x123\n\x08stickers\x18\x02\x20\x01(\x0b2\
    \x17.dota.CMsgStickerHeroesR\x08stickers\"$\n\"CMsgGCToServerSetSteamLea\
    rnDisable\"\xa7\x01\n&CMsgGCToServerSetSteamLearnInferencing\x12\x16\n\
    \x06enable\x18\x01\x20\x01(\x08R\x06enable\x12\x1d\n\nproject_id\x18\x02\
    \x20\x01(\rR\tprojectId\x12+\n\x11published_version\x18\x03\x20\x01(\rR\
    \x10publishedVersion\x12\x19\n\x08hmac_key\x18\x04\x20\x01(\tR\x07hmacKe\
    y\"Z\n&CMsgGCToServerSetSteamLearnKeysChanged\x120\n\x04keys\x18\x01\x20\
    \x01(\x0b2\x1c.dota.CMsgSteamLearnHMACKeysR\x04keys\"\xb3\x01\n\x17CMsgS\
    teamLearnMatchInfo\x12\x1f\n\x0baverage_mmr\x18\x01\x20\x01(\rR\naverage\
    Mmr\x12\x1f\n\x0bradiant_won\x18\x02\x20\x01(\x08R\nradiantWon\x12\x1a\n\
    \x08duration\x18\x03\x20\x01(\rR\x08duration\x12\x1b\n\tgame_mode\x18\
    \x04\x20\x01(\rR\x08gameMode\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\rR\t\
    lobbyType\"\xb3\x01\n\x1dCMsgSteamLearnMatchInfoPlayer\x12\x1f\n\x0baver\
    age_mmr\x18\x01\x20\x01(\rR\naverageMmr\x12\x19\n\x08team_won\x18\x02\
    \x20\x01(\x08R\x07teamWon\x12\x1a\n\x08duration\x18\x03\x20\x01(\rR\x08d\
    uration\x12\x1b\n\tgame_mode\x18\x04\x20\x01(\rR\x08gameMode\x12\x1d\n\n\
    lobby_type\x18\x05\x20\x01(\rR\tlobbyType\"\xad\x01\n\x19CMsgSteamLearnM\
    atchHeroes\x12(\n\x10radiant_hero_ids\x18\x01\x20\x03(\rR\x0eradiantHero\
    Ids\x12\"\n\rdire_hero_ids\x18\x02\x20\x03(\rR\x0bdireHeroIds\x12#\n\rra\
    diant_lanes\x18\x03\x20\x03(\rR\x0cradiantLanes\x12\x1d\n\ndire_lanes\
    \x18\x04\x20\x03(\rR\tdireLanes\"\x94\x01\n\x17CMsgSteamLearnMatchHero\
    \x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\x12\n\x04lane\
    \x18\x02\x20\x01(\rR\x04lane\x12&\n\x0fallied_hero_ids\x18\x03\x20\x03(\
    \rR\ralliedHeroIds\x12$\n\x0eenemy_hero_ids\x18\x04\x20\x03(\rR\x0cenemy\
    HeroIds\"\xa3\x07\n\x18CMsgSteamLearnMatchState\x12\x1b\n\tgame_time\x18\
    \x01\x20\x01(\x02R\x08gameTime\x12M\n\rradiant_state\x18\x02\x20\x01(\
    \x0b2(.dota.CMsgSteamLearnMatchState.TeamStateR\x0cradiantState\x12G\n\n\
    dire_state\x18\x03\x20\x01(\x0b2(.dota.CMsgSteamLearnMatchState.TeamStat\
    eR\tdireState\x1a\x8d\x02\n\x0bPlayerState\x12\x17\n\x07hero_id\x18\x01\
    \x20\x01(\rR\x06heroId\x12\x1b\n\tnet_worth\x18\x02\x20\x01(\rR\x08netWo\
    rth\x12\x14\n\x05level\x18\x03\x20\x01(\rR\x05level\x12\x16\n\x06deaths\
    \x18\x04\x20\x01(\rR\x06deaths\x12!\n\x0crespawn_time\x18\x05\x20\x01(\r\
    R\x0brespawnTime\x12\x1f\n\x0bhas_buyback\x18\x06\x20\x01(\x08R\nhasBuyb\
    ack\x12\x1b\n\thas_aegis\x18\x07\x20\x01(\x08R\x08hasAegis\x12\x1d\n\nha\
    s_rapier\x18\x08\x20\x01(\x08R\thasRapier\x12\x1a\n\x08distance\x18\t\
    \x20\x01(\rR\x08distance\x1a\xc1\x03\n\tTeamState\x12\x12\n\x04team\x18\
    \x01\x20\x01(\rR\x04team\x12O\n\rplayer_states\x18\x02\x20\x03(\x0b2*.do\
    ta.CMsgSteamLearnMatchState.PlayerStateR\x0cplayerStates\x12(\n\x10tower\
    _health_pct\x18\x03\x20\x03(\rR\x0etowerHealthPct\x12.\n\x13barracks_hea\
    lth_pct\x18\x04\x20\x03(\rR\x11barracksHealthPct\x12,\n\x12ancient_healt\
    h_pct\x18\x05\x20\x01(\rR\x10ancientHealthPct\x12%\n\x0eglyph_cooldown\
    \x18\x06\x20\x01(\rR\rglyphCooldown\x12\x14\n\x05kills\x18\x07\x20\x01(\
    \rR\x05kills\x12.\n\x13creep_distance_safe\x18\x08\x20\x01(\rR\x11creepD\
    istanceSafe\x12,\n\x12creep_distance_mid\x18\t\x20\x01(\rR\x10creepDista\
    nceMid\x12,\n\x12creep_distance_off\x18\n\x20\x01(\rR\x10creepDistanceOf\
    f\"\xac\x02\n\x1aCMsgSteamLearnItemPurchase\x12\x17\n\x07item_id\x18\x01\
    \x20\x01(\x05R\x06itemId\x12'\n\x0finventory_items\x18\x02\x20\x03(\x05R\
    \x0einventoryItems\x12)\n\x10purchase_history\x18\x03\x20\x03(\x05R\x0fp\
    urchaseHistory\x12\x12\n\x04gold\x18\x04\x20\x01(\rR\x04gold\x12\x1b\n\t\
    net_worth\x18\x05\x20\x01(\rR\x08netWorth\x12&\n\x0fis_radiant_team\x18\
    \x06\x20\x01(\rR\risRadiantTeam\x12\x1b\n\tgame_time\x18\x07\x20\x01(\
    \x02R\x08gameTime\x12+\n\x12is_using_dota_plus\x18\x08\x20\x01(\x08R\x0f\
    isUsingDotaPlus\"\x94\x01\n\"CMsgSteamLearnPreGameItemPurchases\x12\x19\
    \n\x08item_ids\x18\x01\x20\x03(\x05R\x07itemIds\x12&\n\x0fis_radiant_tea\
    m\x18\x02\x20\x01(\rR\risRadiantTeam\x12+\n\x12is_using_dota_plus\x18\
    \x03\x20\x01(\x08R\x0fisUsingDotaPlus\"\xb2\x01\n\x1aCMsgSteamLearnAbili\
    tySkill\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilityId\x12+\n\
    \x11skilled_abilities\x18\x02\x20\x03(\x05R\x10skilledAbilities\x12\x1b\
    \n\tgame_time\x18\x03\x20\x01(\x02R\x08gameTime\x12+\n\x12is_using_dota_\
    plus\x18\x04\x20\x01(\x08R\x0fisUsingDotaPlus\"\xfa\x01\n\x1bCMsgSteamLe\
    arnWardPlacement\x12E\n\x08ward_loc\x18\x01\x20\x01(\x0b2*.dota.CMsgStea\
    mLearnWardPlacement.LocationR\x07wardLoc\x12X\n\x12existing_ward_locs\
    \x18\x02\x20\x03(\x0b2*.dota.CMsgSteamLearnWardPlacement.LocationR\x10ex\
    istingWardLocs\x12\x12\n\x04team\x18\x03\x20\x01(\rR\x04team\x1a&\n\x08L\
    ocation\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\
    \x20\x01(\x02R\x01y\"C\n\x19CMsgSignOutMuertaMinigame\x12&\n\x0fevent_ga\
    me_data\x18\x01\x20\x01(\x0cR\reventGameData\"\xfc\x01\n\x13CMsgSignOutM\
    apStats\x12:\n\x07players\x18\x01\x20\x03(\x0b2\x20.dota.CMsgSignOutMapS\
    tats.PlayerR\x07players\x12=\n\x0cglobal_stats\x18\x02\x20\x01(\x0b2\x1a\
    .dota.CMsgMapStatsSnapshotR\x0bglobalStats\x1aj\n\x06Player\x12\x1d\n\na\
    ccount_id\x18\x01\x20\x01(\rR\taccountId\x12A\n\x0epersonal_stats\x18\
    \x02\x20\x01(\x0b2\x1a.dota.CMsgMapStatsSnapshotR\rpersonalStats*\xc6\
    \x01\n\x1aEPoorNetworkConditionsType\x12!\n\x1dk_EPoorNetworkConditions_\
    None\x10\0\x12$\n\x20k_EPoorNetworkConditions_Unknown\x10\x01\x12+\n'k_E\
    PoorNetworkConditions_MassDisconnect\x10\x02\x122\n.k_EPoorNetworkCondit\
    ions_ExcessBadQosIntervals\x10\x03B%Z#github.com/dotabuff/manta/dota;dot\
    aJ\xdd\xe6\x04\n\x07\x12\x05\0\0\xe5\x0b\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\
    \n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\n\
    \t\n\x02\x03\x01\x12\x03\x06\x07\x1e\n\t\n\x02\x03\x02\x12\x03\x07\x07\
    \x20\n\t\n\x02\x03\x03\x12\x03\x08\x07%\n\t\n\x02\x03\x04\x12\x03\t\x07\
    \x1e\n\t\n\x02\x03\x05\x12\x03\n\x07!\n\t\n\x02\x03\x06\x12\x03\x0b\x07+\
    \n\t\n\x02\x03\x07\x12\x03\x0c\x076\n\t\n\x02\x03\x08\x12\x03\r\x07\x1f\
    \n\t\n\x02\x03\t\x12\x03\x0e\x075\n\n\n\x02\x05\0\x12\x04\x10\0\x15\x01\
    \n\n\n\x03\x05\0\x01\x12\x03\x10\x05\x1f\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x11\x08*\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x11\x08%\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x03\x11()\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x12\x08-\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x12\x08(\n\x0c\n\x05\x05\0\x02\x01\
    \x02\x12\x03\x12+,\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x13\x084\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x13\x08/\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x1323\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x14\x08;\n\x0c\n\x05\
    \x05\0\x02\x03\x01\x12\x03\x14\x086\n\x0c\n\x05\x05\0\x02\x03\x02\x12\
    \x03\x149:\n\n\n\x02\x04\0\x12\x04\x17\0!\x01\n\n\n\x03\x04\0\x01\x12\
    \x03\x17\x08!\n\x0c\n\x04\x04\0\x03\0\x12\x04\x18\x08\x1d\t\n\x0c\n\x05\
    \x04\0\x03\0\x01\x12\x03\x18\x10\x16\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03\
    \x19\x10/\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03\x19\x10\x18\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x05\x12\x03\x19\x19\x1f\n\x0e\n\x07\x04\0\x03\0\
    \x02\0\x01\x12\x03\x19\x20*\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\
    \x19-.\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03\x1a\x10K\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x04\x12\x03\x1a\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x06\x12\x03\x1a\x194\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03\x1a5F\
    \n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x03\x1aIJ\n\r\n\x06\x04\0\x03\0\
    \x02\x02\x12\x03\x1b\x106\n\x0e\n\x07\x04\0\x03\0\x02\x02\x04\x12\x03\
    \x1b\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x02\x05\x12\x03\x1b\x19\x1f\n\
    \x0e\n\x07\x04\0\x03\0\x02\x02\x01\x12\x03\x1b\x201\n\x0e\n\x07\x04\0\
    \x03\0\x02\x02\x03\x12\x03\x1b45\n\r\n\x06\x04\0\x03\0\x02\x03\x12\x03\
    \x1c\x102\n\x0e\n\x07\x04\0\x03\0\x02\x03\x04\x12\x03\x1c\x10\x18\n\x0e\
    \n\x07\x04\0\x03\0\x02\x03\x05\x12\x03\x1c\x19\x1f\n\x0e\n\x07\x04\0\x03\
    \0\x02\x03\x01\x12\x03\x1c\x20-\n\x0e\n\x07\x04\0\x03\0\x02\x03\x03\x12\
    \x03\x1c01\n\x0b\n\x04\x04\0\x02\0\x12\x03\x1f\x08?\n\x0c\n\x05\x04\0\
    \x02\0\x04\x12\x03\x1f\x08\x10\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x1f\
    \x11+\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1f,:\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x1f=>\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x20\x08>\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x06\
    \x12\x03\x20\x111\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x2029\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\x20<=\n\n\n\x02\x04\x01\x12\x04#\00\x01\n\
    \n\n\x03\x04\x01\x01\x12\x03#\x08\x1b\n\x0b\n\x04\x04\x01\x02\0\x12\x03$\
    \x08%\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03$\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03$\x18\
    \x20\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03$#$\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x03%\x08&\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03%\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x01\x05\x12\x03%\x11\x18\n\x0c\n\x05\x04\x01\x02\
    \x01\x01\x12\x03%\x19!\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03%$%\n\x0b\
    \n\x04\x04\x01\x02\x02\x12\x03&\x08/\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\
    \x03&\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03&\x11\x1f\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03&\x20*\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03&-.\n\x0b\n\x04\x04\x01\x02\x03\x12\x03'\x080\n\x0c\n\x05\x04\
    \x01\x02\x03\x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\
    \x03'\x11\x18\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03'\x19+\n\x0c\n\x05\
    \x04\x01\x02\x03\x03\x12\x03'./\n\x0b\n\x04\x04\x01\x02\x04\x12\x03(\x08\
    -\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x04\x05\x12\x03(\x11\x18\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03(\
    \x19'\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03(*,\n\x0b\n\x04\x04\x01\x02\
    \x05\x12\x03)\x08+\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03)\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x05\x05\x12\x03)\x11\x17\n\x0c\n\x05\x04\x01\x02\
    \x05\x01\x12\x03)\x18%\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03)(*\n\x0b\
    \n\x04\x04\x01\x02\x06\x12\x03*\x08-\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\
    \x03*\x08\x10\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\x03*\x11\x18\n\x0c\n\
    \x05\x04\x01\x02\x06\x01\x12\x03*\x19(\n\x0c\n\x05\x04\x01\x02\x06\x03\
    \x12\x03*+,\n\x0b\n\x04\x04\x01\x02\x07\x12\x03+\x083\n\x0c\n\x05\x04\
    \x01\x02\x07\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\
    \x03+\x11\x18\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03+\x19.\n\x0c\n\x05\
    \x04\x01\x02\x07\x03\x12\x03+12\n\x0b\n\x04\x04\x01\x02\x08\x12\x03,\x08\
    (\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03,\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x08\x05\x12\x03,\x11\x17\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03,\
    \x18#\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03,&'\n\x0b\n\x04\x04\x01\x02\
    \t\x12\x03-\x08+\n\x0c\n\x05\x04\x01\x02\t\x04\x12\x03-\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\t\x05\x12\x03-\x11\x17\n\x0c\n\x05\x04\x01\x02\t\x01\
    \x12\x03-\x18&\n\x0c\n\x05\x04\x01\x02\t\x03\x12\x03-)*\n\x0b\n\x04\x04\
    \x01\x02\n\x12\x03.\x08\x20\n\x0c\n\x05\x04\x01\x02\n\x04\x12\x03.\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\n\x05\x12\x03.\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\n\x01\x12\x03.\x18\x1b\n\x0c\n\x05\x04\x01\x02\n\x03\x12\x03.\x1e\
    \x1f\n\x0b\n\x04\x04\x01\x02\x0b\x12\x03/\x08$\n\x0c\n\x05\x04\x01\x02\
    \x0b\x04\x12\x03/\x08\x10\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03/\x11\
    \x17\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03/\x18\x1e\n\x0c\n\x05\x04\
    \x01\x02\x0b\x03\x12\x03/!#\n\n\n\x02\x04\x02\x12\x042\0Z\x01\n\n\n\x03\
    \x04\x02\x01\x12\x032\x08\x1c\n\x0c\n\x04\x04\x02\x03\0\x12\x043\x088\t\
    \n\x0c\n\x05\x04\x02\x03\0\x01\x12\x033\x10\x16\n\r\n\x06\x04\x02\x03\0\
    \x02\0\x12\x034\x10.\n\x0e\n\x07\x04\x02\x03\0\x02\0\x04\x12\x034\x10\
    \x18\n\x0e\n\x07\x04\x02\x03\0\x02\0\x05\x12\x034\x19\x20\n\x0e\n\x07\
    \x04\x02\x03\0\x02\0\x01\x12\x034!)\n\x0e\n\x07\x04\x02\x03\0\x02\0\x03\
    \x12\x034,-\n\r\n\x06\x04\x02\x03\0\x02\x01\x12\x035\x10,\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x01\x04\x12\x035\x10\x18\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x01\x05\x12\x035\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\
    \x035\x20'\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x035*+\n\r\n\x06\
    \x04\x02\x03\0\x02\x02\x12\x036\x10:\n\x0e\n\x07\x04\x02\x03\0\x02\x02\
    \x04\x12\x036\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x06\x12\x036\x19\
    (\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x01\x12\x036)5\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x02\x03\x12\x03689\n\r\n\x06\x04\x02\x03\0\x02\x03\x12\x037\
    \x10K\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x04\x12\x037\x10\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x03\x06\x12\x037\x194\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x03\x01\x12\x0375F\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x03\x12\x037IJ\n\
    \x0c\n\x04\x04\x02\x03\x01\x12\x04:\x08>\t\n\x0c\n\x05\x04\x02\x03\x01\
    \x01\x12\x03:\x10\x1b\n\r\n\x06\x04\x02\x03\x01\x02\0\x12\x03;\x10.\n\
    \x0e\n\x07\x04\x02\x03\x01\x02\0\x04\x12\x03;\x10\x18\n\x0e\n\x07\x04\
    \x02\x03\x01\x02\0\x05\x12\x03;\x19\x20\n\x0e\n\x07\x04\x02\x03\x01\x02\
    \0\x01\x12\x03;!)\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x03\x12\x03;,-\n\r\n\
    \x06\x04\x02\x03\x01\x02\x01\x12\x03<\x10/\n\x0e\n\x07\x04\x02\x03\x01\
    \x02\x01\x04\x12\x03<\x10\x18\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x06\
    \x12\x03<\x19%\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x01\x12\x03<&*\n\x0e\
    \n\x07\x04\x02\x03\x01\x02\x01\x03\x12\x03<-.\n\r\n\x06\x04\x02\x03\x01\
    \x02\x02\x12\x03=\x10-\n\x0e\n\x07\x04\x02\x03\x01\x02\x02\x04\x12\x03=\
    \x10\x18\n\x0e\n\x07\x04\x02\x03\x01\x02\x02\x05\x12\x03=\x19\x1e\n\x0e\
    \n\x07\x04\x02\x03\x01\x02\x02\x01\x12\x03=\x1f(\n\x0e\n\x07\x04\x02\x03\
    \x01\x02\x02\x03\x12\x03=+,\n\x0c\n\x04\x04\x02\x04\0\x12\x04@\x08M\t\n\
    \x0c\n\x05\x04\x02\x04\0\x01\x12\x03@\r\x17\n\r\n\x06\x04\x02\x04\0\x02\
    \0\x12\x03A\x10\x1c\n\x0e\n\x07\x04\x02\x04\0\x02\0\x01\x12\x03A\x10\x17\
    \n\x0e\n\x07\x04\x02\x04\0\x02\0\x02\x12\x03A\x1a\x1b\n\r\n\x06\x04\x02\
    \x04\0\x02\x01\x12\x03B\x10\x1e\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x01\
    \x12\x03B\x10\x19\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x02\x12\x03B\x1c\x1d\
    \n\r\n\x06\x04\x02\x04\0\x02\x02\x12\x03C\x10\x1f\n\x0e\n\x07\x04\x02\
    \x04\0\x02\x02\x01\x12\x03C\x10\x1a\n\x0e\n\x07\x04\x02\x04\0\x02\x02\
    \x02\x12\x03C\x1d\x1e\n\r\n\x06\x04\x02\x04\0\x02\x03\x12\x03D\x10\x20\n\
    \x0e\n\x07\x04\x02\x04\0\x02\x03\x01\x12\x03D\x10\x1b\n\x0e\n\x07\x04\
    \x02\x04\0\x02\x03\x02\x12\x03D\x1e\x1f\n\r\n\x06\x04\x02\x04\0\x02\x04\
    \x12\x03E\x10%\n\x0e\n\x07\x04\x02\x04\0\x02\x04\x01\x12\x03E\x10\x20\n\
    \x0e\n\x07\x04\x02\x04\0\x02\x04\x02\x12\x03E#$\n\r\n\x06\x04\x02\x04\0\
    \x02\x05\x12\x03F\x10\x20\n\x0e\n\x07\x04\x02\x04\0\x02\x05\x01\x12\x03F\
    \x10\x1b\n\x0e\n\x07\x04\x02\x04\0\x02\x05\x02\x12\x03F\x1e\x1f\n\r\n\
    \x06\x04\x02\x04\0\x02\x06\x12\x03G\x105\n\x0e\n\x07\x04\x02\x04\0\x02\
    \x06\x01\x12\x03G\x100\n\x0e\n\x07\x04\x02\x04\0\x02\x06\x02\x12\x03G34\
    \n\r\n\x06\x04\x02\x04\0\x02\x07\x12\x03H\x107\n\x0e\n\x07\x04\x02\x04\0\
    \x02\x07\x01\x12\x03H\x102\n\x0e\n\x07\x04\x02\x04\0\x02\x07\x02\x12\x03\
    H56\n\r\n\x06\x04\x02\x04\0\x02\x08\x12\x03I\x10'\n\x0e\n\x07\x04\x02\
    \x04\0\x02\x08\x01\x12\x03I\x10!\n\x0e\n\x07\x04\x02\x04\0\x02\x08\x02\
    \x12\x03I$&\n\r\n\x06\x04\x02\x04\0\x02\t\x12\x03J\x10%\n\x0e\n\x07\x04\
    \x02\x04\0\x02\t\x01\x12\x03J\x10\x1f\n\x0e\n\x07\x04\x02\x04\0\x02\t\
    \x02\x12\x03J\"$\n\r\n\x06\x04\x02\x04\0\x02\n\x12\x03K\x10\x1b\n\x0e\n\
    \x07\x04\x02\x04\0\x02\n\x01\x12\x03K\x10\x15\n\x0e\n\x07\x04\x02\x04\0\
    \x02\n\x02\x12\x03K\x18\x1a\n\r\n\x06\x04\x02\x04\0\x02\x0b\x12\x03L\x10\
    $\n\x0e\n\x07\x04\x02\x04\0\x02\x0b\x01\x12\x03L\x10\x1e\n\x0e\n\x07\x04\
    \x02\x04\0\x02\x0b\x02\x12\x03L!#\n\x0b\n\x04\x04\x02\x02\0\x12\x03O\x08\
    C\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \0\x06\x12\x03O\x11,\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03O->\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03OAB\n\x0b\n\x04\x04\x02\x02\x01\x12\x03P\
    \x08F\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03P\x08\x10\n\x0c\n\x05\x04\
    \x02\x02\x01\x06\x12\x03P\x11,\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03P-\
    A\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03PDE\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03Q\x08/\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03Q\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x02\x06\x12\x03Q\x11\x1f\n\x0c\n\x05\x04\x02\x02\x02\
    \x01\x12\x03Q\x20*\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03Q-.\n\x0b\n\
    \x04\x04\x02\x02\x03\x12\x03R\x08/\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\
    \x03R\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03R\x11\x15\n\x0c\n\
    \x05\x04\x02\x02\x03\x01\x12\x03R\x16*\n\x0c\n\x05\x04\x02\x02\x03\x03\
    \x12\x03R-.\n\x0b\n\x04\x04\x02\x02\x04\x12\x03S\x08H\n\x0c\n\x05\x04\
    \x02\x02\x04\x04\x12\x03S\x08\x10\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\
    \x03S\x11*\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03S+B\n\x0c\n\x05\x04\
    \x02\x02\x04\x03\x12\x03SEG\n\x0b\n\x04\x04\x02\x02\x05\x12\x03T\x08A\n\
    \x0c\n\x05\x04\x02\x02\x05\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \x05\x06\x12\x03T\x110\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03T1<\n\x0c\
    \n\x05\x04\x02\x02\x05\x03\x12\x03T?@\n\x0b\n\x04\x04\x02\x02\x06\x12\
    \x03U\x08+\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\x03U\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\x06\x05\x12\x03U\x11\x17\n\x0c\n\x05\x04\x02\x02\x06\x01\
    \x12\x03U\x18%\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03U(*\n\x0b\n\x04\
    \x04\x02\x02\x07\x12\x03V\x08(\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03V\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\x07\x05\x12\x03V\x11\x17\n\x0c\n\x05\
    \x04\x02\x02\x07\x01\x12\x03V\x18\"\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\
    \x03V%'\n\x0b\n\x04\x04\x02\x02\x08\x12\x03W\x08)\n\x0c\n\x05\x04\x02\
    \x02\x08\x04\x12\x03W\x08\x10\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\x03W\
    \x11\x16\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03W\x17#\n\x0c\n\x05\x04\
    \x02\x02\x08\x03\x12\x03W&(\n\x0b\n\x04\x04\x02\x02\t\x12\x03X\x08,\n\
    \x0c\n\x05\x04\x02\x02\t\x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\x02\x02\t\
    \x05\x12\x03X\x11\x17\n\x0c\n\x05\x04\x02\x02\t\x01\x12\x03X\x18&\n\x0c\
    \n\x05\x04\x02\x02\t\x03\x12\x03X)+\n\x0b\n\x04\x04\x02\x02\n\x12\x03Y\
    \x08D\n\x0c\n\x05\x04\x02\x02\n\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\n\x06\x12\x03Y\x111\n\x0c\n\x05\x04\x02\x02\n\x01\x12\x03Y2>\n\x0c\
    \n\x05\x04\x02\x02\n\x03\x12\x03YAC\n\x0b\n\x02\x04\x03\x12\x05\\\0\x8a\
    \x01\x01\n\n\n\x03\x04\x03\x01\x12\x03\\\x08\x1a\n\x0c\n\x04\x04\x03\x04\
    \0\x12\x04]\x08e\t\n\x0c\n\x05\x04\x03\x04\0\x01\x12\x03]\r\x17\n\r\n\
    \x06\x04\x03\x04\0\x02\0\x12\x03^\x10\x20\n\x0e\n\x07\x04\x03\x04\0\x02\
    \0\x01\x12\x03^\x10\x1b\n\x0e\n\x07\x04\x03\x04\0\x02\0\x02\x12\x03^\x1e\
    \x1f\n\r\n\x06\x04\x03\x04\0\x02\x01\x12\x03_\x10\x19\n\x0e\n\x07\x04\
    \x03\x04\0\x02\x01\x01\x12\x03_\x10\x14\n\x0e\n\x07\x04\x03\x04\0\x02\
    \x01\x02\x12\x03_\x17\x18\n\r\n\x06\x04\x03\x04\0\x02\x02\x12\x03`\x10\
    \x1a\n\x0e\n\x07\x04\x03\x04\0\x02\x02\x01\x12\x03`\x10\x15\n\x0e\n\x07\
    \x04\x03\x04\0\x02\x02\x02\x12\x03`\x18\x19\n\r\n\x06\x04\x03\x04\0\x02\
    \x03\x12\x03a\x10\x1f\n\x0e\n\x07\x04\x03\x04\0\x02\x03\x01\x12\x03a\x10\
    \x1a\n\x0e\n\x07\x04\x03\x04\0\x02\x03\x02\x12\x03a\x1d\x1e\n\r\n\x06\
    \x04\x03\x04\0\x02\x04\x12\x03b\x10\x1e\n\x0e\n\x07\x04\x03\x04\0\x02\
    \x04\x01\x12\x03b\x10\x19\n\x0e\n\x07\x04\x03\x04\0\x02\x04\x02\x12\x03b\
    \x1c\x1d\n\r\n\x06\x04\x03\x04\0\x02\x05\x12\x03c\x10%\n\x0e\n\x07\x04\
    \x03\x04\0\x02\x05\x01\x12\x03c\x10\x20\n\x0e\n\x07\x04\x03\x04\0\x02\
    \x05\x02\x12\x03c#$\n\r\n\x06\x04\x03\x04\0\x02\x06\x12\x03d\x10$\n\x0e\
    \n\x07\x04\x03\x04\0\x02\x06\x01\x12\x03d\x10\x1f\n\x0e\n\x07\x04\x03\
    \x04\0\x02\x06\x02\x12\x03d\"#\n\x0c\n\x04\x04\x03\x04\x01\x12\x04g\x08l\
    \t\n\x0c\n\x05\x04\x03\x04\x01\x01\x12\x03g\r\x18\n\r\n\x06\x04\x03\x04\
    \x01\x02\0\x12\x03h\x10\x19\n\x0e\n\x07\x04\x03\x04\x01\x02\0\x01\x12\
    \x03h\x10\x14\n\x0e\n\x07\x04\x03\x04\x01\x02\0\x02\x12\x03h\x17\x18\n\r\
    \n\x06\x04\x03\x04\x01\x02\x01\x12\x03i\x10\x19\n\x0e\n\x07\x04\x03\x04\
    \x01\x02\x01\x01\x12\x03i\x10\x14\n\x0e\n\x07\x04\x03\x04\x01\x02\x01\
    \x02\x12\x03i\x17\x18\n\r\n\x06\x04\x03\x04\x01\x02\x02\x12\x03j\x10\x19\
    \n\x0e\n\x07\x04\x03\x04\x01\x02\x02\x01\x12\x03j\x10\x14\n\x0e\n\x07\
    \x04\x03\x04\x01\x02\x02\x02\x12\x03j\x17\x18\n\r\n\x06\x04\x03\x04\x01\
    \x02\x03\x12\x03k\x10\x1a\n\x0e\n\x07\x04\x03\x04\x01\x02\x03\x01\x12\
    \x03k\x10\x15\n\x0e\n\x07\x04\x03\x04\x01\x02\x03\x02\x12\x03k\x18\x19\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03n\x083\n\x0c\n\x05\x04\x03\x02\0\x04\x12\
    \x03n\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03n\x11\x18\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03n\x19.\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03n1\
    2\n\x0b\n\x04\x04\x03\x02\x01\x12\x03o\x084\n\x0c\n\x05\x04\x03\x02\x01\
    \x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03o\x11\x18\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03o\x19/\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03o23\n\x0b\n\x04\x04\x03\x02\x02\x12\x03p\x08(\n\x0c\n\x05\
    \x04\x03\x02\x02\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\
    \x12\x03p\x11\x17\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03p\x18#\n\x0c\n\
    \x05\x04\x03\x02\x02\x03\x12\x03p&'\n\x0b\n\x04\x04\x03\x02\x03\x12\x03q\
    \x08+\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x03\x05\x12\x03q\x11\x17\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\
    \x03q\x18&\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03q)*\n\x0b\n\x04\x04\
    \x03\x02\x04\x12\x03r\x085\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03r\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03r\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x04\x01\x12\x03r\x18/\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03r2\
    4\n\x0b\n\x04\x04\x03\x02\x05\x12\x03s\x08@\n\x0c\n\x05\x04\x03\x02\x05\
    \x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03s\x11\x16\n\
    \x0c\n\x05\x04\x03\x02\x05\x01\x12\x03s\x17:\n\x0c\n\x05\x04\x03\x02\x05\
    \x03\x12\x03s=?\n\x0b\n\x04\x04\x03\x02\x06\x12\x03t\x08'\n\x0c\n\x05\
    \x04\x03\x02\x06\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\x03\x02\x06\x05\
    \x12\x03t\x11\x17\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03t\x18\"\n\x0c\n\
    \x05\x04\x03\x02\x06\x03\x12\x03t%&\n\x0b\n\x04\x04\x03\x02\x07\x12\x03u\
    \x08-\n\x0c\n\x05\x04\x03\x02\x07\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x07\x05\x12\x03u\x11\x15\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\
    \x03u\x16(\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\x03u+,\n\x0b\n\x04\x04\
    \x03\x02\x08\x12\x03v\x08?\n\x0c\n\x05\x04\x03\x02\x08\x04\x12\x03v\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x08\x06\x12\x03v\x11.\n\x0c\n\x05\x04\x03\
    \x02\x08\x01\x12\x03v/:\n\x0c\n\x05\x04\x03\x02\x08\x03\x12\x03v=>\n\x0b\
    \n\x04\x04\x03\x02\t\x12\x03w\x08*\n\x0c\n\x05\x04\x03\x02\t\x04\x12\x03\
    w\x08\x10\n\x0c\n\x05\x04\x03\x02\t\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\t\x01\x12\x03w\x18%\n\x0c\n\x05\x04\x03\x02\t\x03\x12\x03w()\n\
    \x0b\n\x04\x04\x03\x02\n\x12\x03x\x08*\n\x0c\n\x05\x04\x03\x02\n\x04\x12\
    \x03x\x08\x10\n\x0c\n\x05\x04\x03\x02\n\x05\x12\x03x\x11\x16\n\x0c\n\x05\
    \x04\x03\x02\n\x01\x12\x03x\x17%\n\x0c\n\x05\x04\x03\x02\n\x03\x12\x03x(\
    )\n\x0b\n\x04\x04\x03\x02\x0b\x12\x03y\x085\n\x0c\n\x05\x04\x03\x02\x0b\
    \x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\x03\x02\x0b\x05\x12\x03y\x11\x16\n\
    \x0c\n\x05\x04\x03\x02\x0b\x01\x12\x03y\x17/\n\x0c\n\x05\x04\x03\x02\x0b\
    \x03\x12\x03y24\n\x0b\n\x04\x04\x03\x02\x0c\x12\x03z\x08-\n\x0c\n\x05\
    \x04\x03\x02\x0c\x04\x12\x03z\x08\x10\n\x0c\n\x05\x04\x03\x02\x0c\x05\
    \x12\x03z\x11\x16\n\x0c\n\x05\x04\x03\x02\x0c\x01\x12\x03z\x17'\n\x0c\n\
    \x05\x04\x03\x02\x0c\x03\x12\x03z*,\n\x0b\n\x04\x04\x03\x02\r\x12\x03{\
    \x08>\n\x0c\n\x05\x04\x03\x02\r\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\r\x05\x12\x03{\x11\x18\n\x0c\n\x05\x04\x03\x02\r\x01\x12\x03{\x198\
    \n\x0c\n\x05\x04\x03\x02\r\x03\x12\x03{;=\n\x0b\n\x04\x04\x03\x02\x0e\
    \x12\x03|\x08-\n\x0c\n\x05\x04\x03\x02\x0e\x04\x12\x03|\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\x0e\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\x03\x02\x0e\
    \x01\x12\x03|\x18'\n\x0c\n\x05\x04\x03\x02\x0e\x03\x12\x03|*,\n\x0b\n\
    \x04\x04\x03\x02\x0f\x12\x03}\x08-\n\x0c\n\x05\x04\x03\x02\x0f\x04\x12\
    \x03}\x08\x10\n\x0c\n\x05\x04\x03\x02\x0f\x05\x12\x03}\x11\x16\n\x0c\n\
    \x05\x04\x03\x02\x0f\x01\x12\x03}\x17'\n\x0c\n\x05\x04\x03\x02\x0f\x03\
    \x12\x03}*,\n\x0b\n\x04\x04\x03\x02\x10\x12\x03~\x084\n\x0c\n\x05\x04\
    \x03\x02\x10\x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\x03\x02\x10\x05\x12\
    \x03~\x11\x16\n\x0c\n\x05\x04\x03\x02\x10\x01\x12\x03~\x17.\n\x0c\n\x05\
    \x04\x03\x02\x10\x03\x12\x03~13\n\x0b\n\x04\x04\x03\x02\x11\x12\x03\x7f\
    \x08;\n\x0c\n\x05\x04\x03\x02\x11\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\x11\x05\x12\x03\x7f\x11\x18\n\x0c\n\x05\x04\x03\x02\x11\x01\
    \x12\x03\x7f\x195\n\x0c\n\x05\x04\x03\x02\x11\x03\x12\x03\x7f8:\n\x0c\n\
    \x04\x04\x03\x02\x12\x12\x04\x80\x01\x080\n\r\n\x05\x04\x03\x02\x12\x04\
    \x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\x03\x02\x12\x05\x12\x04\x80\x01\
    \x11\x17\n\r\n\x05\x04\x03\x02\x12\x01\x12\x04\x80\x01\x18*\n\r\n\x05\
    \x04\x03\x02\x12\x03\x12\x04\x80\x01-/\n\x0c\n\x04\x04\x03\x02\x13\x12\
    \x04\x81\x01\x08-\n\r\n\x05\x04\x03\x02\x13\x04\x12\x04\x81\x01\x08\x10\
    \n\r\n\x05\x04\x03\x02\x13\x05\x12\x04\x81\x01\x11\x18\n\r\n\x05\x04\x03\
    \x02\x13\x01\x12\x04\x81\x01\x19'\n\r\n\x05\x04\x03\x02\x13\x03\x12\x04\
    \x81\x01*,\n\x0c\n\x04\x04\x03\x02\x14\x12\x04\x82\x01\x08,\n\r\n\x05\
    \x04\x03\x02\x14\x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\x03\x02\x14\
    \x05\x12\x04\x82\x01\x11\x17\n\r\n\x05\x04\x03\x02\x14\x01\x12\x04\x82\
    \x01\x18&\n\r\n\x05\x04\x03\x02\x14\x03\x12\x04\x82\x01)+\n\x0c\n\x04\
    \x04\x03\x02\x15\x12\x04\x83\x01\x08,\n\r\n\x05\x04\x03\x02\x15\x04\x12\
    \x04\x83\x01\x08\x10\n\r\n\x05\x04\x03\x02\x15\x05\x12\x04\x83\x01\x11\
    \x17\n\r\n\x05\x04\x03\x02\x15\x01\x12\x04\x83\x01\x18&\n\r\n\x05\x04\
    \x03\x02\x15\x03\x12\x04\x83\x01)+\n\x0c\n\x04\x04\x03\x02\x16\x12\x04\
    \x84\x01\x08H\n\r\n\x05\x04\x03\x02\x16\x04\x12\x04\x84\x01\x08\x10\n\r\
    \n\x05\x04\x03\x02\x16\x06\x12\x04\x84\x01\x11/\n\r\n\x05\x04\x03\x02\
    \x16\x01\x12\x04\x84\x010B\n\r\n\x05\x04\x03\x02\x16\x03\x12\x04\x84\x01\
    EG\n\x0c\n\x04\x04\x03\x02\x17\x12\x04\x85\x01\x08+\n\r\n\x05\x04\x03\
    \x02\x17\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x03\x02\x17\x05\x12\
    \x04\x85\x01\x11\x17\n\r\n\x05\x04\x03\x02\x17\x01\x12\x04\x85\x01\x18%\
    \n\r\n\x05\x04\x03\x02\x17\x03\x12\x04\x85\x01(*\n\x0c\n\x04\x04\x03\x02\
    \x18\x12\x04\x86\x01\x08-\n\r\n\x05\x04\x03\x02\x18\x04\x12\x04\x86\x01\
    \x08\x10\n\r\n\x05\x04\x03\x02\x18\x05\x12\x04\x86\x01\x11\x17\n\r\n\x05\
    \x04\x03\x02\x18\x01\x12\x04\x86\x01\x18'\n\r\n\x05\x04\x03\x02\x18\x03\
    \x12\x04\x86\x01*,\n\x0c\n\x04\x04\x03\x02\x19\x12\x04\x87\x01\x08,\n\r\
    \n\x05\x04\x03\x02\x19\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x03\x02\
    \x19\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x03\x02\x19\x01\x12\x04\
    \x87\x01\x18&\n\r\n\x05\x04\x03\x02\x19\x03\x12\x04\x87\x01)+\n\x0c\n\
    \x04\x04\x03\x02\x1a\x12\x04\x88\x01\x081\n\r\n\x05\x04\x03\x02\x1a\x04\
    \x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x03\x02\x1a\x05\x12\x04\x88\x01\
    \x11\x15\n\r\n\x05\x04\x03\x02\x1a\x01\x12\x04\x88\x01\x16+\n\r\n\x05\
    \x04\x03\x02\x1a\x03\x12\x04\x88\x01.0\n\x0c\n\x04\x04\x03\x02\x1b\x12\
    \x04\x89\x01\x08<\n\r\n\x05\x04\x03\x02\x1b\x04\x12\x04\x89\x01\x08\x10\
    \n\r\n\x05\x04\x03\x02\x1b\x05\x12\x04\x89\x01\x11\x15\n\r\n\x05\x04\x03\
    \x02\x1b\x01\x12\x04\x89\x01\x166\n\r\n\x05\x04\x03\x02\x1b\x03\x12\x04\
    \x89\x019;\n\x0c\n\x02\x04\x04\x12\x06\x8c\x01\0\x93\x01\x01\n\x0b\n\x03\
    \x04\x04\x01\x12\x04\x8c\x01\x08\x1a\n\x0c\n\x04\x04\x04\x02\0\x12\x04\
    \x8d\x01\x08&\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x8d\x01\x08\x10\n\r\n\
    \x05\x04\x04\x02\0\x05\x12\x04\x8d\x01\x11\x18\n\r\n\x05\x04\x04\x02\0\
    \x01\x12\x04\x8d\x01\x19!\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x8d\x01$%\
    \n\x0c\n\x04\x04\x04\x02\x01\x12\x04\x8e\x01\x086\n\r\n\x05\x04\x04\x02\
    \x01\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\
    \x8e\x01\x11#\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x8e\x01$1\n\r\n\x05\
    \x04\x04\x02\x01\x03\x12\x04\x8e\x0145\n\x0c\n\x04\x04\x04\x02\x02\x12\
    \x04\x8f\x01\x082\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\x8f\x01\x08\x10\
    \n\r\n\x05\x04\x04\x02\x02\x06\x12\x04\x8f\x01\x11\x20\n\r\n\x05\x04\x04\
    \x02\x02\x01\x12\x04\x8f\x01!-\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x8f\
    \x0101\n\x0c\n\x04\x04\x04\x02\x03\x12\x04\x90\x01\x08+\n\r\n\x05\x04\
    \x04\x02\x03\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\x04\x02\x03\x05\
    \x12\x04\x90\x01\x11\x17\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\x90\x01\
    \x18&\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\x90\x01)*\n\x0c\n\x04\x04\
    \x04\x02\x04\x12\x04\x91\x01\x08C\n\r\n\x05\x04\x04\x02\x04\x04\x12\x04\
    \x91\x01\x08\x10\n\r\n\x05\x04\x04\x02\x04\x06\x12\x04\x91\x01\x11,\n\r\
    \n\x05\x04\x04\x02\x04\x01\x12\x04\x91\x01->\n\r\n\x05\x04\x04\x02\x04\
    \x03\x12\x04\x91\x01AB\n\x0c\n\x04\x04\x04\x02\x05\x12\x04\x92\x01\x08G\
    \n\r\n\x05\x04\x04\x02\x05\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x04\
    \x02\x05\x06\x12\x04\x92\x01\x11*\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\
    \x92\x01+B\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\x92\x01EF\n\x0c\n\x02\
    \x04\x05\x12\x06\x95\x01\0\x97\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\
    \x95\x01\x08\"\n\x0c\n\x04\x04\x05\x02\0\x12\x04\x96\x01\x08#\n\r\n\x05\
    \x04\x05\x02\0\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\x05\
    \x12\x04\x96\x01\x11\x17\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x96\x01\x18\
    \x1e\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x96\x01!\"\n\x0c\n\x02\x04\x06\
    \x12\x06\x99\x01\0\x9b\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x99\x01\
    \x08'\n\x0c\n\x04\x04\x06\x02\0\x12\x04\x9a\x01\x086\n\r\n\x05\x04\x06\
    \x02\0\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\
    \x9a\x01\x11+\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x9a\x01,1\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\x9a\x0145\n\x0c\n\x02\x04\x07\x12\x06\x9d\x01\
    \0\x9f\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x9d\x01\x08&\n\x0c\n\x04\
    \x04\x07\x02\0\x12\x04\x9e\x01\x086\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\
    \x9e\x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\x9e\x01\x11+\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\x9e\x01,1\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\x9e\x0145\n\x0c\n\x02\x04\x08\x12\x06\xa1\x01\0\xa3\x01\x01\n\x0b\n\
    \x03\x04\x08\x01\x12\x04\xa1\x01\x08#\n\x0c\n\x04\x04\x08\x02\0\x12\x04\
    \xa2\x01\x08<\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xa2\x01\x08\x10\n\r\n\
    \x05\x04\x08\x02\0\x06\x12\x04\xa2\x01\x11/\n\r\n\x05\x04\x08\x02\0\x01\
    \x12\x04\xa2\x0107\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xa2\x01:;\n\x0c\n\
    \x02\x04\t\x12\x06\xa5\x01\0\xa7\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xa5\x01\x08,\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa6\x01\x08\"\n\r\n\x05\
    \x04\t\x02\0\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\
    \x04\xa6\x01\x11\x15\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa6\x01\x16\x1d\n\
    \r\n\x05\x04\t\x02\0\x03\x12\x04\xa6\x01\x20!\n\x0c\n\x02\x04\n\x12\x06\
    \xa9\x01\0\xab\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xa9\x01\x08-\n\x0c\
    \n\x04\x04\n\x02\0\x12\x04\xaa\x01\x08!\n\r\n\x05\x04\n\x02\0\x04\x12\
    \x04\xaa\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xaa\x01\x11\x15\n\
    \r\n\x05\x04\n\x02\0\x01\x12\x04\xaa\x01\x16\x1c\n\r\n\x05\x04\n\x02\0\
    \x03\x12\x04\xaa\x01\x1f\x20\n\x0c\n\x02\x04\x0b\x12\x06\xad\x01\0\xbd\
    \x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xad\x01\x08\x20\n\x0e\n\x04\x04\
    \x0b\x03\0\x12\x06\xae\x01\x08\xb3\x01\t\n\r\n\x05\x04\x0b\x03\0\x01\x12\
    \x04\xae\x01\x10\x17\n\x0e\n\x06\x04\x0b\x03\0\x02\0\x12\x04\xaf\x01\x10\
    .\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x04\x12\x04\xaf\x01\x10\x18\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\0\x05\x12\x04\xaf\x01\x19\x20\n\x0f\n\x07\x04\x0b\
    \x03\0\x02\0\x01\x12\x04\xaf\x01!)\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x03\
    \x12\x04\xaf\x01,-\n\x0e\n\x06\x04\x0b\x03\0\x02\x01\x12\x04\xb0\x01\x10\
    0\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x04\x12\x04\xb0\x01\x10\x18\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\x01\x05\x12\x04\xb0\x01\x19\x1f\n\x0f\n\x07\x04\
    \x0b\x03\0\x02\x01\x01\x12\x04\xb0\x01\x20+\n\x0f\n\x07\x04\x0b\x03\0\
    \x02\x01\x03\x12\x04\xb0\x01./\n\x0e\n\x06\x04\x0b\x03\0\x02\x02\x12\x04\
    \xb1\x01\x10,\n\x0f\n\x07\x04\x0b\x03\0\x02\x02\x04\x12\x04\xb1\x01\x10\
    \x18\n\x0f\n\x07\x04\x0b\x03\0\x02\x02\x05\x12\x04\xb1\x01\x19\x1f\n\x0f\
    \n\x07\x04\x0b\x03\0\x02\x02\x01\x12\x04\xb1\x01\x20'\n\x0f\n\x07\x04\
    \x0b\x03\0\x02\x02\x03\x12\x04\xb1\x01*+\n\x0e\n\x06\x04\x0b\x03\0\x02\
    \x03\x12\x04\xb2\x01\x10G\n\x0f\n\x07\x04\x0b\x03\0\x02\x03\x04\x12\x04\
    \xb2\x01\x10\x18\n\x0f\n\x07\x04\x0b\x03\0\x02\x03\x06\x12\x04\xb2\x01\
    \x19/\n\x0f\n\x07\x04\x0b\x03\0\x02\x03\x01\x12\x04\xb2\x010B\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\x03\x03\x12\x04\xb2\x01EF\n\x0e\n\x04\x04\x0b\x03\
    \x01\x12\x06\xb5\x01\x08\xba\x01\t\n\r\n\x05\x04\x0b\x03\x01\x01\x12\x04\
    \xb5\x01\x10\x15\n\x0e\n\x06\x04\x0b\x03\x01\x02\0\x12\x04\xb6\x01\x102\
    \n\x0f\n\x07\x04\x0b\x03\x01\x02\0\x04\x12\x04\xb6\x01\x10\x18\n\x0f\n\
    \x07\x04\x0b\x03\x01\x02\0\x05\x12\x04\xb6\x01\x19\x1d\n\x0f\n\x07\x04\
    \x0b\x03\x01\x02\0\x01\x12\x04\xb6\x01\x1e-\n\x0f\n\x07\x04\x0b\x03\x01\
    \x02\0\x03\x12\x04\xb6\x0101\n\x0e\n\x06\x04\x0b\x03\x01\x02\x01\x12\x04\
    \xb7\x01\x102\n\x0f\n\x07\x04\x0b\x03\x01\x02\x01\x04\x12\x04\xb7\x01\
    \x10\x18\n\x0f\n\x07\x04\x0b\x03\x01\x02\x01\x05\x12\x04\xb7\x01\x19\x1d\
    \n\x0f\n\x07\x04\x0b\x03\x01\x02\x01\x01\x12\x04\xb7\x01\x1e-\n\x0f\n\
    \x07\x04\x0b\x03\x01\x02\x01\x03\x12\x04\xb7\x0101\n\x0e\n\x06\x04\x0b\
    \x03\x01\x02\x02\x12\x04\xb8\x01\x10C\n\x0f\n\x07\x04\x0b\x03\x01\x02\
    \x02\x04\x12\x04\xb8\x01\x10\x18\n\x0f\n\x07\x04\x0b\x03\x01\x02\x02\x06\
    \x12\x04\xb8\x01\x19-\n\x0f\n\x07\x04\x0b\x03\x01\x02\x02\x01\x12\x04\
    \xb8\x01.>\n\x0f\n\x07\x04\x0b\x03\x01\x02\x02\x03\x12\x04\xb8\x01AB\n\
    \x0e\n\x06\x04\x0b\x03\x01\x02\x03\x12\x04\xb9\x01\x10F\n\x0f\n\x07\x04\
    \x0b\x03\x01\x02\x03\x04\x12\x04\xb9\x01\x10\x18\n\x0f\n\x07\x04\x0b\x03\
    \x01\x02\x03\x06\x12\x04\xb9\x01\x199\n\x0f\n\x07\x04\x0b\x03\x01\x02\
    \x03\x01\x12\x04\xb9\x01:A\n\x0f\n\x07\x04\x0b\x03\x01\x02\x03\x03\x12\
    \x04\xb9\x01DE\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xbc\x01\x08:\n\r\n\x05\
    \x04\x0b\x02\0\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\
    \x12\x04\xbc\x01\x11/\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xbc\x0105\n\r\
    \n\x05\x04\x0b\x02\0\x03\x12\x04\xbc\x0189\n\x0c\n\x02\x04\x0c\x12\x06\
    \xbf\x01\0\xe2\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xbf\x01\x08\x1c\n\
    \x0e\n\x04\x04\x0c\x03\0\x12\x06\xc0\x01\x08\x9b\x02\t\n\r\n\x05\x04\x0c\
    \x03\0\x01\x12\x04\xc0\x01\x10\x15\n\x10\n\x06\x04\x0c\x03\0\x03\0\x12\
    \x06\xc1\x01\x10\x98\x02\x11\n\x0f\n\x07\x04\x0c\x03\0\x03\0\x01\x12\x04\
    \xc1\x01\x18\x1f\n\x12\n\x08\x04\x0c\x03\0\x03\0\x03\0\x12\x06\xc2\x01\
    \x18\xc5\x01\x19\n\x11\n\t\x04\x0c\x03\0\x03\0\x03\0\x01\x12\x04\xc2\x01\
    \x20/\n\x12\n\n\x04\x0c\x03\0\x03\0\x03\0\x02\0\x12\x04\xc3\x01\x20>\n\
    \x13\n\x0b\x04\x0c\x03\0\x03\0\x03\0\x02\0\x04\x12\x04\xc3\x01\x20(\n\
    \x13\n\x0b\x04\x0c\x03\0\x03\0\x03\0\x02\0\x05\x12\x04\xc3\x01)/\n\x13\n\
    \x0b\x04\x0c\x03\0\x03\0\x03\0\x02\0\x01\x12\x04\xc3\x0109\n\x13\n\x0b\
    \x04\x0c\x03\0\x03\0\x03\0\x02\0\x03\x12\x04\xc3\x01<=\n\x12\n\n\x04\x0c\
    \x03\0\x03\0\x03\0\x02\x01\x12\x04\xc4\x01\x209\n\x13\n\x0b\x04\x0c\x03\
    \0\x03\0\x03\0\x02\x01\x04\x12\x04\xc4\x01\x20(\n\x13\n\x0b\x04\x0c\x03\
    \0\x03\0\x03\0\x02\x01\x05\x12\x04\xc4\x01)-\n\x13\n\x0b\x04\x0c\x03\0\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xc4\x01.4\n\x13\n\x0b\x04\x0c\x03\0\x03\
    \0\x03\0\x02\x01\x03\x12\x04\xc4\x0178\n\x12\n\x08\x04\x0c\x03\0\x03\0\
    \x03\x01\x12\x06\xc7\x01\x18\xcb\x01\x19\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x03\x01\x01\x12\x04\xc7\x01\x202\n\x12\n\n\x04\x0c\x03\0\x03\0\x03\x01\
    \x02\0\x12\x04\xc8\x01\x20B\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\
    \0\x04\x12\x04\xc8\x01\x20(\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\
    \0\x05\x12\x04\xc8\x01)/\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\0\
    \x01\x12\x04\xc8\x010=\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\0\x03\
    \x12\x04\xc8\x01@A\n\x12\n\n\x04\x0c\x03\0\x03\0\x03\x01\x02\x01\x12\x04\
    \xc9\x01\x20C\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x01\x04\x12\
    \x04\xc9\x01\x20(\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x01\x05\
    \x12\x04\xc9\x01)/\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x01\x01\
    \x12\x04\xc9\x010>\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x01\x03\
    \x12\x04\xc9\x01AB\n\x12\n\n\x04\x0c\x03\0\x03\0\x03\x01\x02\x02\x12\x04\
    \xca\x01\x20k\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x02\x04\x12\
    \x04\xca\x01\x20(\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x02\x06\
    \x12\x04\xca\x01)Z\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x02\x01\
    \x12\x04\xca\x01[f\n\x13\n\x0b\x04\x0c\x03\0\x03\0\x03\x01\x02\x02\x03\
    \x12\x04\xca\x01ij\n\x12\n\x08\x04\x0c\x03\0\x03\0\x04\0\x12\x06\xcd\x01\
    \x18\xd1\x01\x19\n\x11\n\t\x04\x0c\x03\0\x03\0\x04\0\x01\x12\x04\xcd\x01\
    \x1d+\n\x12\n\n\x04\x0c\x03\0\x03\0\x04\0\x02\0\x12\x04\xce\x01\x209\n\
    \x13\n\x0b\x04\x0c\x03\0\x03\0\x04\0\x02\0\x01\x12\x04\xce\x01\x204\n\
    \x13\n\x0b\x04\x0c\x03\0\x03\0\x04\0\x02\0\x02\x12\x04\xce\x0178\n\x12\n\
    \n\x04\x0c\x03\0\x03\0\x04\0\x02\x01\x12\x04\xcf\x01\x208\n\x13\n\x0b\
    \x04\x0c\x03\0\x03\0\x04\0\x02\x01\x01\x12\x04\xcf\x01\x203\n\x13\n\x0b\
    \x04\x0c\x03\0\x03\0\x04\0\x02\x01\x02\x12\x04\xcf\x0167\n\x12\n\n\x04\
    \x0c\x03\0\x03\0\x04\0\x02\x02\x12\x04\xd0\x01\x205\n\x13\n\x0b\x04\x0c\
    \x03\0\x03\0\x04\0\x02\x02\x01\x12\x04\xd0\x01\x200\n\x13\n\x0b\x04\x0c\
    \x03\0\x03\0\x04\0\x02\x02\x02\x12\x04\xd0\x0134\n\x10\n\x08\x04\x0c\x03\
    \0\x03\0\x02\0\x12\x04\xd3\x01\x186\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\0\
    \x04\x12\x04\xd3\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\0\x05\x12\
    \x04\xd3\x01!(\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\0\x01\x12\x04\xd3\x01)1\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\0\x03\x12\x04\xd3\x0145\n\x10\n\x08\
    \x04\x0c\x03\0\x03\0\x02\x01\x12\x04\xd4\x01\x184\n\x11\n\t\x04\x0c\x03\
    \0\x03\0\x02\x01\x04\x12\x04\xd4\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\
    \0\x02\x01\x05\x12\x04\xd4\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x01\
    \x01\x12\x04\xd4\x01(/\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x01\x03\x12\x04\
    \xd4\x0123\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x02\x12\x04\xd5\x01\x181\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x02\x04\x12\x04\xd5\x01\x18\x20\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02\x02\x05\x12\x04\xd5\x01!&\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02\x02\x01\x12\x04\xd5\x01',\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x02\x03\x12\x04\xd5\x01/0\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x03\
    \x12\x04\xd6\x01\x18A\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x03\x04\x12\x04\
    \xd6\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x03\x05\x12\x04\xd6\
    \x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x03\x01\x12\x04\xd6\x01(;\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02\x03\x03\x12\x04\xd6\x01>@\n\x10\n\x08\x04\
    \x0c\x03\0\x03\0\x02\x04\x12\x04\xd7\x01\x181\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x04\x04\x12\x04\xd7\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x04\x05\x12\x04\xd7\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x04\x01\
    \x12\x04\xd7\x01(,\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x04\x03\x12\x04\xd7\
    \x01/0\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x05\x12\x04\xd8\x01\x182\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02\x05\x04\x12\x04\xd8\x01\x18\x20\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02\x05\x05\x12\x04\xd8\x01!'\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02\x05\x01\x12\x04\xd8\x01(-\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x05\x03\x12\x04\xd8\x0101\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x06\
    \x12\x04\xd9\x01\x183\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x06\x04\x12\x04\
    \xd9\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x06\x05\x12\x04\xd9\
    \x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x06\x01\x12\x04\xd9\x01(.\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02\x06\x03\x12\x04\xd9\x0112\n\x10\n\x08\x04\
    \x0c\x03\0\x03\0\x02\x07\x12\x04\xda\x01\x184\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x07\x04\x12\x04\xda\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x07\x05\x12\x04\xda\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x07\x01\
    \x12\x04\xda\x01(/\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x07\x03\x12\x04\xda\
    \x0123\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x08\x12\x04\xdb\x01\x18:\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02\x08\x04\x12\x04\xdb\x01\x18\x20\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02\x08\x05\x12\x04\xdb\x01!'\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02\x08\x01\x12\x04\xdb\x01(5\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x08\x03\x12\x04\xdb\x0189\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\t\x12\
    \x04\xdc\x01\x187\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\t\x04\x12\x04\xdc\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\t\x05\x12\x04\xdc\x01!'\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02\t\x01\x12\x04\xdc\x01(1\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\t\x03\x12\x04\xdc\x0146\n\x10\n\x08\x04\x0c\x03\0\
    \x03\0\x02\n\x12\x04\xdd\x01\x184\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\n\
    \x04\x12\x04\xdd\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\n\x05\x12\
    \x04\xdd\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\n\x01\x12\x04\xdd\x01(.\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\n\x03\x12\x04\xdd\x0113\n\x10\n\x08\
    \x04\x0c\x03\0\x03\0\x02\x0b\x12\x04\xde\x01\x18:\n\x11\n\t\x04\x0c\x03\
    \0\x03\0\x02\x0b\x04\x12\x04\xde\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\
    \0\x02\x0b\x05\x12\x04\xde\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x0b\
    \x01\x12\x04\xde\x01(4\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x0b\x03\x12\x04\
    \xde\x0179\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x0c\x12\x04\xdf\x01\x18;\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x0c\x04\x12\x04\xdf\x01\x18\x20\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02\x0c\x05\x12\x04\xdf\x01!'\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02\x0c\x01\x12\x04\xdf\x01(5\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x0c\x03\x12\x04\xdf\x018:\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\r\x12\
    \x04\xe0\x01\x188\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\r\x04\x12\x04\xe0\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\r\x05\x12\x04\xe0\x01!'\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02\r\x01\x12\x04\xe0\x01(2\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\r\x03\x12\x04\xe0\x0157\n\x10\n\x08\x04\x0c\x03\0\
    \x03\0\x02\x0e\x12\x04\xe1\x01\x183\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x0e\x04\x12\x04\xe1\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x0e\
    \x05\x12\x04\xe1\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x0e\x01\x12\x04\
    \xe1\x01(-\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x0e\x03\x12\x04\xe1\x0102\n\
    \x10\n\x08\x04\x0c\x03\0\x03\0\x02\x0f\x12\x04\xe2\x01\x18@\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02\x0f\x04\x12\x04\xe2\x01\x18\x20\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\x0f\x05\x12\x04\xe2\x01!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x0f\x01\x12\x04\xe2\x01(:\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x0f\x03\x12\x04\xe2\x01=?\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x10\x12\
    \x04\xe3\x01\x18A\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x10\x04\x12\x04\xe3\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x10\x05\x12\x04\xe3\x01!'\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x10\x01\x12\x04\xe3\x01(;\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02\x10\x03\x12\x04\xe3\x01>@\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02\x11\x12\x04\xe4\x01\x18A\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x11\x04\x12\x04\xe4\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x11\x05\x12\x04\xe4\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x11\x01\x12\
    \x04\xe4\x01(;\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x11\x03\x12\x04\xe4\x01\
    >@\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x12\x12\x04\xe5\x01\x18<\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02\x12\x04\x12\x04\xe5\x01\x18\x20\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\x12\x05\x12\x04\xe5\x01!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x12\x01\x12\x04\xe5\x01(6\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x12\x03\x12\x04\xe5\x019;\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x13\x12\
    \x04\xe6\x01\x18C\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x13\x04\x12\x04\xe6\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x13\x05\x12\x04\xe6\x01!'\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x13\x01\x12\x04\xe6\x01(=\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02\x13\x03\x12\x04\xe6\x01@B\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02\x14\x12\x04\xe7\x01\x186\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x14\x04\x12\x04\xe7\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x14\x05\x12\x04\xe7\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x14\x01\x12\
    \x04\xe7\x01(0\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x14\x03\x12\x04\xe7\x01\
    35\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x15\x12\x04\xe8\x01\x18?\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02\x15\x04\x12\x04\xe8\x01\x18\x20\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\x15\x05\x12\x04\xe8\x01!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x15\x01\x12\x04\xe8\x01(9\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x15\x03\x12\x04\xe8\x01<>\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x16\x12\
    \x04\xe9\x01\x18:\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x16\x04\x12\x04\xe9\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x16\x05\x12\x04\xe9\x01!'\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x16\x01\x12\x04\xe9\x01(4\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02\x16\x03\x12\x04\xe9\x0179\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02\x17\x12\x04\xea\x01\x18<\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x17\x04\x12\x04\xea\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x17\x05\x12\x04\xea\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x17\x01\x12\
    \x04\xea\x01(6\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x17\x03\x12\x04\xea\x01\
    9;\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x18\x12\x04\xeb\x01\x18<\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02\x18\x04\x12\x04\xeb\x01\x18\x20\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\x18\x05\x12\x04\xeb\x01!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x18\x01\x12\x04\xeb\x01(6\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x18\x03\x12\x04\xeb\x019;\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x19\x12\
    \x04\xec\x01\x184\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x19\x04\x12\x04\xec\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x19\x05\x12\x04\xec\x01!'\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x19\x01\x12\x04\xec\x01(.\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02\x19\x03\x12\x04\xec\x0113\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02\x1a\x12\x04\xed\x01\x187\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x1a\x04\x12\x04\xed\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x1a\x05\x12\x04\xed\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1a\x01\x12\
    \x04\xed\x01(1\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1a\x03\x12\x04\xed\x01\
    46\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x1b\x12\x04\xee\x01\x189\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02\x1b\x04\x12\x04\xee\x01\x18\x20\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\x1b\x05\x12\x04\xee\x01!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x1b\x01\x12\x04\xee\x01(3\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x1b\x03\x12\x04\xee\x0168\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x1c\x12\
    \x04\xef\x01\x18:\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1c\x04\x12\x04\xef\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1c\x05\x12\x04\xef\x01!'\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1c\x01\x12\x04\xef\x01(4\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02\x1c\x03\x12\x04\xef\x0179\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02\x1d\x12\x04\xf0\x01\x18:\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x1d\x04\x12\x04\xf0\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x1d\x05\x12\x04\xf0\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1d\x01\x12\
    \x04\xf0\x01(4\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1d\x03\x12\x04\xf0\x01\
    79\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x1e\x12\x04\xf1\x01\x18R\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02\x1e\x04\x12\x04\xf1\x01\x18\x20\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02\x1e\x06\x12\x04\xf1\x01!;\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02\x1e\x01\x12\x04\xf1\x01<L\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x1e\x03\x12\x04\xf1\x01OQ\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\x1f\x12\
    \x04\xf2\x01\x18_\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1f\x04\x12\x04\xf2\
    \x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1f\x06\x12\x04\xf2\x01!>\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x1f\x01\x12\x04\xf2\x01?Y\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02\x1f\x03\x12\x04\xf2\x01\\^\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02\x20\x12\x04\xf3\x01\x18P\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\x20\x04\x12\x04\xf3\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    \x20\x06\x12\x04\xf3\x01!:\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x20\x01\x12\
    \x04\xf3\x01;J\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\x20\x03\x12\x04\xf3\x01\
    MO\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02!\x12\x04\xf4\x01\x18j\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02!\x04\x12\x04\xf4\x01\x18\x20\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02!\x06\x12\x04\xf4\x01!S\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02!\x01\x12\x04\xf4\x01Td\n\x11\n\t\x04\x0c\x03\0\x03\0\x02!\x03\x12\
    \x04\xf4\x01gi\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02\"\x12\x04\xf5\x01\x18\
    @\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\"\x04\x12\x04\xf5\x01\x18\x20\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02\"\x05\x12\x04\xf5\x01!'\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02\"\x01\x12\x04\xf5\x01(:\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02\"\x03\x12\x04\xf5\x01=?\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02#\x12\
    \x04\xf6\x01\x18?\n\x11\n\t\x04\x0c\x03\0\x03\0\x02#\x04\x12\x04\xf6\x01\
    \x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02#\x05\x12\x04\xf6\x01!&\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02#\x01\x12\x04\xf6\x01'9\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02#\x03\x12\x04\xf6\x01<>\n\x10\n\x08\x04\x0c\x03\0\x03\0\
    \x02$\x12\x04\xf7\x01\x18=\n\x11\n\t\x04\x0c\x03\0\x03\0\x02$\x04\x12\
    \x04\xf7\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02$\x05\x12\x04\xf7\
    \x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02$\x01\x12\x04\xf7\x01(7\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02$\x03\x12\x04\xf7\x01:<\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02%\x12\x04\xf8\x01\x18=\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    %\x04\x12\x04\xf8\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02%\x05\x12\
    \x04\xf8\x01!%\n\x11\n\t\x04\x0c\x03\0\x03\0\x02%\x01\x12\x04\xf8\x01&7\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02%\x03\x12\x04\xf8\x01:<\n\x10\n\x08\
    \x04\x0c\x03\0\x03\0\x02&\x12\x04\xf9\x01\x18I\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02&\x04\x12\x04\xf9\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02&\x05\x12\x04\xf9\x01!%\n\x11\n\t\x04\x0c\x03\0\x03\0\x02&\x01\x12\
    \x04\xf9\x01&C\n\x11\n\t\x04\x0c\x03\0\x03\0\x02&\x03\x12\x04\xf9\x01FH\
    \n\x10\n\x08\x04\x0c\x03\0\x03\0\x02'\x12\x04\xfa\x01\x182\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02'\x04\x12\x04\xfa\x01\x18\x20\n\x11\n\t\x04\x0c\x03\
    \0\x03\0\x02'\x05\x12\x04\xfa\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02'\
    \x01\x12\x04\xfa\x01(,\n\x11\n\t\x04\x0c\x03\0\x03\0\x02'\x03\x12\x04\
    \xfa\x01/1\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02(\x12\x04\xfb\x01\x18?\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02(\x04\x12\x04\xfb\x01\x18\x20\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02(\x05\x12\x04\xfb\x01!%\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02(\x01\x12\x04\xfb\x01&9\n\x11\n\t\x04\x0c\x03\0\x03\0\x02(\x03\
    \x12\x04\xfb\x01<>\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02)\x12\x04\xfc\x01\
    \x18q\n\x11\n\t\x04\x0c\x03\0\x03\0\x02)\x04\x12\x04\xfc\x01\x18\x20\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02)\x06\x12\x04\xfc\x01!V\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02)\x01\x12\x04\xfc\x01Wk\n\x11\n\t\x04\x0c\x03\0\x03\
    \0\x02)\x03\x12\x04\xfc\x01np\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02*\x12\
    \x04\xfd\x01\x18n\n\x11\n\t\x04\x0c\x03\0\x03\0\x02*\x04\x12\x04\xfd\x01\
    \x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02*\x06\x12\x04\xfd\x01!V\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02*\x01\x12\x04\xfd\x01Wh\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02*\x03\x12\x04\xfd\x01km\n\x10\n\x08\x04\x0c\x03\0\x03\0\
    \x02+\x12\x04\xfe\x01\x18:\n\x11\n\t\x04\x0c\x03\0\x03\0\x02+\x04\x12\
    \x04\xfe\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02+\x05\x12\x04\xfe\
    \x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02+\x01\x12\x04\xfe\x01(4\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02+\x03\x12\x04\xfe\x0179\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02,\x12\x04\xff\x01\x18@\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    ,\x04\x12\x04\xff\x01\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02,\x05\x12\
    \x04\xff\x01!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02,\x01\x12\x04\xff\x01(:\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02,\x03\x12\x04\xff\x01=?\n\x10\n\x08\
    \x04\x0c\x03\0\x03\0\x02-\x12\x04\x80\x02\x18;\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02-\x04\x12\x04\x80\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02-\x05\x12\x04\x80\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02-\x01\x12\
    \x04\x80\x02(5\n\x11\n\t\x04\x0c\x03\0\x03\0\x02-\x03\x12\x04\x80\x028:\
    \n\x10\n\x08\x04\x0c\x03\0\x03\0\x02.\x12\x04\x81\x02\x18L\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02.\x04\x12\x04\x81\x02\x18\x20\n\x11\n\t\x04\x0c\x03\
    \0\x03\0\x02.\x05\x12\x04\x81\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02.\
    \x01\x12\x04\x81\x02(F\n\x11\n\t\x04\x0c\x03\0\x03\0\x02.\x03\x12\x04\
    \x81\x02IK\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02/\x12\x04\x82\x02\x18<\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02/\x04\x12\x04\x82\x02\x18\x20\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02/\x05\x12\x04\x82\x02!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02/\x01\x12\x04\x82\x02(6\n\x11\n\t\x04\x0c\x03\0\x03\0\x02/\x03\
    \x12\x04\x82\x029;\n\x10\n\x08\x04\x0c\x03\0\x03\0\x020\x12\x04\x83\x02\
    \x18P\n\x11\n\t\x04\x0c\x03\0\x03\0\x020\x04\x12\x04\x83\x02\x18\x20\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x020\x05\x12\x04\x83\x02!'\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x020\x01\x12\x04\x83\x02(J\n\x11\n\t\x04\x0c\x03\0\x03\
    \0\x020\x03\x12\x04\x83\x02MO\n\x10\n\x08\x04\x0c\x03\0\x03\0\x021\x12\
    \x04\x84\x02\x18:\n\x11\n\t\x04\x0c\x03\0\x03\0\x021\x04\x12\x04\x84\x02\
    \x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x021\x05\x12\x04\x84\x02!'\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x021\x01\x12\x04\x84\x02(4\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x021\x03\x12\x04\x84\x0279\n\x10\n\x08\x04\x0c\x03\0\x03\0\
    \x022\x12\x04\x85\x02\x18?\n\x11\n\t\x04\x0c\x03\0\x03\0\x022\x04\x12\
    \x04\x85\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x022\x05\x12\x04\x85\
    \x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x022\x01\x12\x04\x85\x02(9\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x022\x03\x12\x04\x85\x02<>\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x023\x12\x04\x86\x02\x185\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    3\x04\x12\x04\x86\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x023\x05\x12\
    \x04\x86\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x023\x01\x12\x04\x86\x02(/\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x023\x03\x12\x04\x86\x0224\n\x10\n\x08\
    \x04\x0c\x03\0\x03\0\x024\x12\x04\x87\x02\x18:\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x024\x04\x12\x04\x87\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x024\x05\x12\x04\x87\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x024\x01\x12\
    \x04\x87\x02(4\n\x11\n\t\x04\x0c\x03\0\x03\0\x024\x03\x12\x04\x87\x0279\
    \n\x10\n\x08\x04\x0c\x03\0\x03\0\x025\x12\x04\x88\x02\x18;\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x025\x04\x12\x04\x88\x02\x18\x20\n\x11\n\t\x04\x0c\x03\
    \0\x03\0\x025\x05\x12\x04\x88\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x025\
    \x01\x12\x04\x88\x02(5\n\x11\n\t\x04\x0c\x03\0\x03\0\x025\x03\x12\x04\
    \x88\x028:\n\x10\n\x08\x04\x0c\x03\0\x03\0\x026\x12\x04\x89\x02\x189\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x026\x04\x12\x04\x89\x02\x18\x20\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x026\x05\x12\x04\x89\x02!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x026\x01\x12\x04\x89\x02(3\n\x11\n\t\x04\x0c\x03\0\x03\0\x026\x03\
    \x12\x04\x89\x0268\n\x10\n\x08\x04\x0c\x03\0\x03\0\x027\x12\x04\x8a\x02\
    \x18@\n\x11\n\t\x04\x0c\x03\0\x03\0\x027\x04\x12\x04\x8a\x02\x18\x20\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x027\x05\x12\x04\x8a\x02!'\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x027\x01\x12\x04\x8a\x02(:\n\x11\n\t\x04\x0c\x03\0\x03\
    \0\x027\x03\x12\x04\x8a\x02=?\n\x10\n\x08\x04\x0c\x03\0\x03\0\x028\x12\
    \x04\x8b\x02\x18;\n\x11\n\t\x04\x0c\x03\0\x03\0\x028\x04\x12\x04\x8b\x02\
    \x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x028\x05\x12\x04\x8b\x02!'\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x028\x01\x12\x04\x8b\x02(5\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x028\x03\x12\x04\x8b\x028:\n\x10\n\x08\x04\x0c\x03\0\x03\0\
    \x029\x12\x04\x8c\x02\x18H\n\x11\n\t\x04\x0c\x03\0\x03\0\x029\x04\x12\
    \x04\x8c\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x029\x05\x12\x04\x8c\
    \x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x029\x01\x12\x04\x8c\x02(B\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x029\x03\x12\x04\x8c\x02EG\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02:\x12\x04\x8d\x02\x18E\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    :\x04\x12\x04\x8d\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02:\x05\x12\
    \x04\x8d\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02:\x01\x12\x04\x8d\x02(?\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02:\x03\x12\x04\x8d\x02BD\n\x10\n\x08\
    \x04\x0c\x03\0\x03\0\x02;\x12\x04\x8e\x02\x18C\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02;\x04\x12\x04\x8e\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02;\x05\x12\x04\x8e\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02;\x01\x12\
    \x04\x8e\x02(=\n\x11\n\t\x04\x0c\x03\0\x03\0\x02;\x03\x12\x04\x8e\x02@B\
    \n\x10\n\x08\x04\x0c\x03\0\x03\0\x02<\x12\x04\x8f\x02\x18@\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02<\x04\x12\x04\x8f\x02\x18\x20\n\x11\n\t\x04\x0c\x03\
    \0\x03\0\x02<\x05\x12\x04\x8f\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02<\
    \x01\x12\x04\x8f\x02(:\n\x11\n\t\x04\x0c\x03\0\x03\0\x02<\x03\x12\x04\
    \x8f\x02=?\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02=\x12\x04\x90\x02\x189\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02=\x04\x12\x04\x90\x02\x18\x20\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02=\x05\x12\x04\x90\x02!'\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02=\x01\x12\x04\x90\x02(3\n\x11\n\t\x04\x0c\x03\0\x03\0\x02=\x03\
    \x12\x04\x90\x0268\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02>\x12\x04\x91\x02\
    \x189\n\x11\n\t\x04\x0c\x03\0\x03\0\x02>\x04\x12\x04\x91\x02\x18\x20\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02>\x05\x12\x04\x91\x02!'\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02>\x01\x12\x04\x91\x02(3\n\x11\n\t\x04\x0c\x03\0\x03\
    \0\x02>\x03\x12\x04\x91\x0268\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02?\x12\
    \x04\x92\x02\x18:\n\x11\n\t\x04\x0c\x03\0\x03\0\x02?\x04\x12\x04\x92\x02\
    \x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02?\x05\x12\x04\x92\x02!&\n\x11\
    \n\t\x04\x0c\x03\0\x03\0\x02?\x01\x12\x04\x92\x02'4\n\x11\n\t\x04\x0c\
    \x03\0\x03\0\x02?\x03\x12\x04\x92\x0279\n\x10\n\x08\x04\x0c\x03\0\x03\0\
    \x02@\x12\x04\x93\x02\x18?\n\x11\n\t\x04\x0c\x03\0\x03\0\x02@\x04\x12\
    \x04\x93\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02@\x06\x12\x04\x93\
    \x02!-\n\x11\n\t\x04\x0c\x03\0\x03\0\x02@\x01\x12\x04\x93\x02.9\n\x11\n\
    \t\x04\x0c\x03\0\x03\0\x02@\x03\x12\x04\x93\x02<>\n\x10\n\x08\x04\x0c\
    \x03\0\x03\0\x02A\x12\x04\x94\x02\x187\n\x11\n\t\x04\x0c\x03\0\x03\0\x02\
    A\x04\x12\x04\x94\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\x02A\x05\x12\
    \x04\x94\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02A\x01\x12\x04\x94\x02(1\
    \n\x11\n\t\x04\x0c\x03\0\x03\0\x02A\x03\x12\x04\x94\x0246\n\x10\n\x08\
    \x04\x0c\x03\0\x03\0\x02B\x12\x04\x95\x02\x18B\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02B\x04\x12\x04\x95\x02\x18\x20\n\x11\n\t\x04\x0c\x03\0\x03\0\
    \x02B\x05\x12\x04\x95\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02B\x01\x12\
    \x04\x95\x02(<\n\x11\n\t\x04\x0c\x03\0\x03\0\x02B\x03\x12\x04\x95\x02?A\
    \n\x10\n\x08\x04\x0c\x03\0\x03\0\x02C\x12\x04\x96\x02\x18A\n\x11\n\t\x04\
    \x0c\x03\0\x03\0\x02C\x04\x12\x04\x96\x02\x18\x20\n\x11\n\t\x04\x0c\x03\
    \0\x03\0\x02C\x05\x12\x04\x96\x02!'\n\x11\n\t\x04\x0c\x03\0\x03\0\x02C\
    \x01\x12\x04\x96\x02(;\n\x11\n\t\x04\x0c\x03\0\x03\0\x02C\x03\x12\x04\
    \x96\x02>@\n\x10\n\x08\x04\x0c\x03\0\x03\0\x02D\x12\x04\x97\x02\x18D\n\
    \x11\n\t\x04\x0c\x03\0\x03\0\x02D\x04\x12\x04\x97\x02\x18\x20\n\x11\n\t\
    \x04\x0c\x03\0\x03\0\x02D\x05\x12\x04\x97\x02!&\n\x11\n\t\x04\x0c\x03\0\
    \x03\0\x02D\x01\x12\x04\x97\x02'>\n\x11\n\t\x04\x0c\x03\0\x03\0\x02D\x03\
    \x12\x04\x97\x02AC\n\x0e\n\x06\x04\x0c\x03\0\x02\0\x12\x04\x9a\x02\x10H\
    \n\x0f\n\x07\x04\x0c\x03\0\x02\0\x04\x12\x04\x9a\x02\x10\x18\n\x0f\n\x07\
    \x04\x0c\x03\0\x02\0\x06\x12\x04\x9a\x02\x19;\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\0\x01\x12\x04\x9a\x02<C\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x03\x12\x04\
    \x9a\x02FG\n\x0e\n\x04\x04\x0c\x03\x01\x12\x06\x9d\x02\x08\xa0\x02\t\n\r\
    \n\x05\x04\x0c\x03\x01\x01\x12\x04\x9d\x02\x10%\n\x0e\n\x06\x04\x0c\x03\
    \x01\x02\0\x12\x04\x9e\x02\x10'\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x04\
    \x12\x04\x9e\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x05\x12\x04\
    \x9e\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x01\x12\x04\x9e\x02\
    \x20\"\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x03\x12\x04\x9e\x02%&\n\x0e\n\
    \x06\x04\x0c\x03\x01\x02\x01\x12\x04\x9f\x02\x10,\n\x0f\n\x07\x04\x0c\
    \x03\x01\x02\x01\x04\x12\x04\x9f\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x01\
    \x02\x01\x05\x12\x04\x9f\x02\x19\x1e\n\x0f\n\x07\x04\x0c\x03\x01\x02\x01\
    \x01\x12\x04\x9f\x02\x1f'\n\x0f\n\x07\x04\x0c\x03\x01\x02\x01\x03\x12\
    \x04\x9f\x02*+\n\x0e\n\x04\x04\x0c\x03\x02\x12\x06\xa2\x02\x08\xa8\x02\t\
    \n\r\n\x05\x04\x0c\x03\x02\x01\x12\x04\xa2\x02\x10%\n\x0e\n\x06\x04\x0c\
    \x03\x02\x02\0\x12\x04\xa3\x02\x10/\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\
    \x04\x12\x04\xa3\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x05\x12\
    \x04\xa3\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x01\x12\x04\xa3\
    \x02\x20*\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x03\x12\x04\xa3\x02-.\n\x0e\
    \n\x06\x04\x0c\x03\x02\x02\x01\x12\x04\xa4\x02\x10.\n\x0f\n\x07\x04\x0c\
    \x03\x02\x02\x01\x04\x12\x04\xa4\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x02\
    \x02\x01\x05\x12\x04\xa4\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x02\x02\x01\
    \x01\x12\x04\xa4\x02\x20)\n\x0f\n\x07\x04\x0c\x03\x02\x02\x01\x03\x12\
    \x04\xa4\x02,-\n\x0e\n\x06\x04\x0c\x03\x02\x02\x02\x12\x04\xa5\x02\x10/\
    \n\x0f\n\x07\x04\x0c\x03\x02\x02\x02\x04\x12\x04\xa5\x02\x10\x18\n\x0f\n\
    \x07\x04\x0c\x03\x02\x02\x02\x05\x12\x04\xa5\x02\x19\x1f\n\x0f\n\x07\x04\
    \x0c\x03\x02\x02\x02\x01\x12\x04\xa5\x02\x20*\n\x0f\n\x07\x04\x0c\x03\
    \x02\x02\x02\x03\x12\x04\xa5\x02-.\n\x0e\n\x06\x04\x0c\x03\x02\x02\x03\
    \x12\x04\xa6\x02\x10-\n\x0f\n\x07\x04\x0c\x03\x02\x02\x03\x04\x12\x04\
    \xa6\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x02\x02\x03\x05\x12\x04\xa6\x02\
    \x19\x1e\n\x0f\n\x07\x04\x0c\x03\x02\x02\x03\x01\x12\x04\xa6\x02\x1f(\n\
    \x0f\n\x07\x04\x0c\x03\x02\x02\x03\x03\x12\x04\xa6\x02+,\n\x0e\n\x06\x04\
    \x0c\x03\x02\x02\x04\x12\x04\xa7\x02\x100\n\x0f\n\x07\x04\x0c\x03\x02\
    \x02\x04\x04\x12\x04\xa7\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x02\x02\x04\
    \x05\x12\x04\xa7\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x02\x02\x04\x01\x12\
    \x04\xa7\x02\x20+\n\x0f\n\x07\x04\x0c\x03\x02\x02\x04\x03\x12\x04\xa7\
    \x02./\n\x0e\n\x04\x04\x0c\x03\x03\x12\x06\xaa\x02\x08\xac\x02\t\n\r\n\
    \x05\x04\x0c\x03\x03\x01\x12\x04\xaa\x02\x10\x1f\n\x0e\n\x06\x04\x0c\x03\
    \x03\x02\0\x12\x04\xab\x02\x106\n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x04\
    \x12\x04\xab\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x05\x12\x04\
    \xab\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x01\x12\x04\xab\x02\
    \x201\n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x03\x12\x04\xab\x0245\n\x0e\n\
    \x04\x04\x0c\x03\x04\x12\x06\xae\x02\x08\xb6\x02\t\n\r\n\x05\x04\x0c\x03\
    \x04\x01\x12\x04\xae\x02\x10)\n\x0e\n\x06\x04\x0c\x03\x04\x02\0\x12\x04\
    \xaf\x02\x100\n\x0f\n\x07\x04\x0c\x03\x04\x02\0\x04\x12\x04\xaf\x02\x10\
    \x18\n\x0f\n\x07\x04\x0c\x03\x04\x02\0\x05\x12\x04\xaf\x02\x19\x1f\n\x0f\
    \n\x07\x04\x0c\x03\x04\x02\0\x01\x12\x04\xaf\x02\x20+\n\x0f\n\x07\x04\
    \x0c\x03\x04\x02\0\x03\x12\x04\xaf\x02./\n\x0e\n\x06\x04\x0c\x03\x04\x02\
    \x01\x12\x04\xb0\x02\x10)\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x04\x12\
    \x04\xb0\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x05\x12\x04\xb0\
    \x02\x19\x1e\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x01\x12\x04\xb0\x02\x1f\
    $\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x03\x12\x04\xb0\x02'(\n\x0e\n\x06\
    \x04\x0c\x03\x04\x02\x02\x12\x04\xb1\x02\x101\n\x0f\n\x07\x04\x0c\x03\
    \x04\x02\x02\x04\x12\x04\xb1\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x04\x02\
    \x02\x05\x12\x04\xb1\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x04\x02\x02\x01\
    \x12\x04\xb1\x02\x20,\n\x0f\n\x07\x04\x0c\x03\x04\x02\x02\x03\x12\x04\
    \xb1\x02/0\n\x0e\n\x06\x04\x0c\x03\x04\x02\x03\x12\x04\xb2\x02\x101\n\
    \x0f\n\x07\x04\x0c\x03\x04\x02\x03\x04\x12\x04\xb2\x02\x10\x18\n\x0f\n\
    \x07\x04\x0c\x03\x04\x02\x03\x05\x12\x04\xb2\x02\x19\x1f\n\x0f\n\x07\x04\
    \x0c\x03\x04\x02\x03\x01\x12\x04\xb2\x02\x20,\n\x0f\n\x07\x04\x0c\x03\
    \x04\x02\x03\x03\x12\x04\xb2\x02/0\n\x0e\n\x06\x04\x0c\x03\x04\x02\x04\
    \x12\x04\xb3\x02\x101\n\x0f\n\x07\x04\x0c\x03\x04\x02\x04\x04\x12\x04\
    \xb3\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x04\x02\x04\x05\x12\x04\xb3\x02\
    \x19\x1f\n\x0f\n\x07\x04\x0c\x03\x04\x02\x04\x01\x12\x04\xb3\x02\x20,\n\
    \x0f\n\x07\x04\x0c\x03\x04\x02\x04\x03\x12\x04\xb3\x02/0\n\x0e\n\x06\x04\
    \x0c\x03\x04\x02\x05\x12\x04\xb4\x02\x101\n\x0f\n\x07\x04\x0c\x03\x04\
    \x02\x05\x04\x12\x04\xb4\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x04\x02\x05\
    \x05\x12\x04\xb4\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x04\x02\x05\x01\x12\
    \x04\xb4\x02\x20,\n\x0f\n\x07\x04\x0c\x03\x04\x02\x05\x03\x12\x04\xb4\
    \x02/0\n\x0e\n\x06\x04\x0c\x03\x04\x02\x06\x12\x04\xb5\x02\x101\n\x0f\n\
    \x07\x04\x0c\x03\x04\x02\x06\x04\x12\x04\xb5\x02\x10\x18\n\x0f\n\x07\x04\
    \x0c\x03\x04\x02\x06\x05\x12\x04\xb5\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\
    \x04\x02\x06\x01\x12\x04\xb5\x02\x20,\n\x0f\n\x07\x04\x0c\x03\x04\x02\
    \x06\x03\x12\x04\xb5\x02/0\n\x0e\n\x04\x04\x0c\x03\x05\x12\x06\xb8\x02\
    \x08\xc1\x02\t\n\r\n\x05\x04\x0c\x03\x05\x01\x12\x04\xb8\x02\x10\x1d\n\
    \x0e\n\x06\x04\x0c\x03\x05\x02\0\x12\x04\xb9\x02\x10-\n\x0f\n\x07\x04\
    \x0c\x03\x05\x02\0\x04\x12\x04\xb9\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\
    \x05\x02\0\x05\x12\x04\xb9\x02\x19\x1e\n\x0f\n\x07\x04\x0c\x03\x05\x02\0\
    \x01\x12\x04\xb9\x02\x1f(\n\x0f\n\x07\x04\x0c\x03\x05\x02\0\x03\x12\x04\
    \xb9\x02+,\n\x0e\n\x06\x04\x0c\x03\x05\x02\x01\x12\x04\xba\x02\x10,\n\
    \x0f\n\x07\x04\x0c\x03\x05\x02\x01\x04\x12\x04\xba\x02\x10\x18\n\x0f\n\
    \x07\x04\x0c\x03\x05\x02\x01\x05\x12\x04\xba\x02\x19\x1f\n\x0f\n\x07\x04\
    \x0c\x03\x05\x02\x01\x01\x12\x04\xba\x02\x20'\n\x0f\n\x07\x04\x0c\x03\
    \x05\x02\x01\x03\x12\x04\xba\x02*+\n\x0e\n\x06\x04\x0c\x03\x05\x02\x02\
    \x12\x04\xbb\x02\x100\n\x0f\n\x07\x04\x0c\x03\x05\x02\x02\x04\x12\x04\
    \xbb\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x05\x02\x02\x05\x12\x04\xbb\x02\
    \x19\x1f\n\x0f\n\x07\x04\x0c\x03\x05\x02\x02\x01\x12\x04\xbb\x02\x20+\n\
    \x0f\n\x07\x04\x0c\x03\x05\x02\x02\x03\x12\x04\xbb\x02./\n\x0e\n\x06\x04\
    \x0c\x03\x05\x02\x03\x12\x04\xbc\x02\x103\n\x0f\n\x07\x04\x0c\x03\x05\
    \x02\x03\x04\x12\x04\xbc\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x05\x02\x03\
    \x05\x12\x04\xbc\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x05\x02\x03\x01\x12\
    \x04\xbc\x02\x20.\n\x0f\n\x07\x04\x0c\x03\x05\x02\x03\x03\x12\x04\xbc\
    \x0212\n\x0e\n\x06\x04\x0c\x03\x05\x02\x04\x12\x04\xbd\x02\x100\n\x0f\n\
    \x07\x04\x0c\x03\x05\x02\x04\x04\x12\x04\xbd\x02\x10\x18\n\x0f\n\x07\x04\
    \x0c\x03\x05\x02\x04\x05\x12\x04\xbd\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\
    \x05\x02\x04\x01\x12\x04\xbd\x02\x20+\n\x0f\n\x07\x04\x0c\x03\x05\x02\
    \x04\x03\x12\x04\xbd\x02./\n\x0e\n\x06\x04\x0c\x03\x05\x02\x05\x12\x04\
    \xbe\x02\x10/\n\x0f\n\x07\x04\x0c\x03\x05\x02\x05\x04\x12\x04\xbe\x02\
    \x10\x18\n\x0f\n\x07\x04\x0c\x03\x05\x02\x05\x05\x12\x04\xbe\x02\x19\x1d\
    \n\x0f\n\x07\x04\x0c\x03\x05\x02\x05\x01\x12\x04\xbe\x02\x1e*\n\x0f\n\
    \x07\x04\x0c\x03\x05\x02\x05\x03\x12\x04\xbe\x02-.\n\x0e\n\x06\x04\x0c\
    \x03\x05\x02\x06\x12\x04\xbf\x02\x10/\n\x0f\n\x07\x04\x0c\x03\x05\x02\
    \x06\x04\x12\x04\xbf\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\x05\x02\x06\x05\
    \x12\x04\xbf\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x05\x02\x06\x01\x12\x04\
    \xbf\x02\x20*\n\x0f\n\x07\x04\x0c\x03\x05\x02\x06\x03\x12\x04\xbf\x02-.\
    \n\x0e\n\x06\x04\x0c\x03\x05\x02\x07\x12\x04\xc0\x02\x10/\n\x0f\n\x07\
    \x04\x0c\x03\x05\x02\x07\x04\x12\x04\xc0\x02\x10\x18\n\x0f\n\x07\x04\x0c\
    \x03\x05\x02\x07\x05\x12\x04\xc0\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\x05\
    \x02\x07\x01\x12\x04\xc0\x02\x20*\n\x0f\n\x07\x04\x0c\x03\x05\x02\x07\
    \x03\x12\x04\xc0\x02-.\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xc3\x02\x08%\n\
    \r\n\x05\x04\x0c\x02\0\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04\x0c\x02\
    \0\x05\x12\x04\xc3\x02\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xc3\
    \x02\x18\x20\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xc3\x02#$\n\x0c\n\x04\
    \x04\x0c\x02\x01\x12\x04\xc4\x02\x08%\n\r\n\x05\x04\x0c\x02\x01\x04\x12\
    \x04\xc4\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xc4\x02\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xc4\x02\x18\x20\n\r\n\x05\x04\
    \x0c\x02\x01\x03\x12\x04\xc4\x02#$\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\
    \xc5\x02\x08(\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xc5\x02\x08\x10\n\r\
    \n\x05\x04\x0c\x02\x02\x05\x12\x04\xc5\x02\x11\x15\n\r\n\x05\x04\x0c\x02\
    \x02\x01\x12\x04\xc5\x02\x16#\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xc5\
    \x02&'\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\xc6\x02\x08\"\n\r\n\x05\x04\
    \x0c\x02\x03\x04\x12\x04\xc6\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\
    \x12\x04\xc6\x02\x11\x18\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xc6\x02\
    \x19\x1d\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xc6\x02\x20!\n\x0c\n\x04\
    \x04\x0c\x02\x04\x12\x04\xc7\x02\x086\n\r\n\x05\x04\x0c\x02\x04\x04\x12\
    \x04\xc7\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x04\x06\x12\x04\xc7\x02\x11+\
    \n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xc7\x02,1\n\r\n\x05\x04\x0c\x02\
    \x04\x03\x12\x04\xc7\x0245\n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\xc8\x02\
    \x08)\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xc8\x02\x08\x10\n\r\n\x05\
    \x04\x0c\x02\x05\x05\x12\x04\xc8\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x05\
    \x01\x12\x04\xc8\x02\x18$\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xc8\x02'\
    (\n\x0c\n\x04\x04\x0c\x02\x06\x12\x04\xc9\x02\x08,\n\r\n\x05\x04\x0c\x02\
    \x06\x04\x12\x04\xc9\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\
    \xc9\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xc9\x02\x18'\n\r\
    \n\x05\x04\x0c\x02\x06\x03\x12\x04\xc9\x02*+\n\x0c\n\x04\x04\x0c\x02\x07\
    \x12\x04\xca\x02\x08%\n\r\n\x05\x04\x0c\x02\x07\x04\x12\x04\xca\x02\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\xca\x02\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x07\x01\x12\x04\xca\x02\x18\x1f\n\r\n\x05\x04\x0c\x02\x07\x03\
    \x12\x04\xca\x02\"$\n\x0c\n\x04\x04\x0c\x02\x08\x12\x04\xcb\x02\x08)\n\r\
    \n\x05\x04\x0c\x02\x08\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x08\x05\x12\x04\xcb\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\
    \xcb\x02\x18#\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\xcb\x02&(\n\x0c\n\
    \x04\x04\x0c\x02\t\x12\x04\xcc\x02\x08.\n\r\n\x05\x04\x0c\x02\t\x04\x12\
    \x04\xcc\x02\x08\x10\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\xcc\x02\x11\x17\
    \n\r\n\x05\x04\x0c\x02\t\x01\x12\x04\xcc\x02\x18(\n\r\n\x05\x04\x0c\x02\
    \t\x03\x12\x04\xcc\x02+-\n\x0c\n\x04\x04\x0c\x02\n\x12\x04\xcd\x02\x08)\
    \n\r\n\x05\x04\x0c\x02\n\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04\x0c\
    \x02\n\x05\x12\x04\xcd\x02\x11\x17\n\r\n\x05\x04\x0c\x02\n\x01\x12\x04\
    \xcd\x02\x18#\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\xcd\x02&(\n\x0c\n\x04\
    \x04\x0c\x02\x0b\x12\x04\xce\x02\x087\n\r\n\x05\x04\x0c\x02\x0b\x04\x12\
    \x04\xce\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x0b\x06\x12\x04\xce\x02\x11&\
    \n\r\n\x05\x04\x0c\x02\x0b\x01\x12\x04\xce\x02'1\n\r\n\x05\x04\x0c\x02\
    \x0b\x03\x12\x04\xce\x0246\n\x0c\n\x04\x04\x0c\x02\x0c\x12\x04\xcf\x02\
    \x08?\n\r\n\x05\x04\x0c\x02\x0c\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\
    \x04\x0c\x02\x0c\x06\x12\x04\xcf\x02\x11+\n\r\n\x05\x04\x0c\x02\x0c\x01\
    \x12\x04\xcf\x02,9\n\r\n\x05\x04\x0c\x02\x0c\x03\x12\x04\xcf\x02<>\n\x0c\
    \n\x04\x04\x0c\x02\r\x12\x04\xd0\x02\x08\\\n\r\n\x05\x04\x0c\x02\r\x04\
    \x12\x04\xd0\x02\x08\x10\n\r\n\x05\x04\x0c\x02\r\x06\x12\x04\xd0\x02\x11\
    5\n\r\n\x05\x04\x0c\x02\r\x01\x12\x04\xd0\x026V\n\r\n\x05\x04\x0c\x02\r\
    \x03\x12\x04\xd0\x02Y[\n\x0c\n\x04\x04\x0c\x02\x0e\x12\x04\xd1\x02\x08/\
    \n\r\n\x05\x04\x0c\x02\x0e\x04\x12\x04\xd1\x02\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x0e\x05\x12\x04\xd1\x02\x11\x15\n\r\n\x05\x04\x0c\x02\x0e\x01\x12\
    \x04\xd1\x02\x16)\n\r\n\x05\x04\x0c\x02\x0e\x03\x12\x04\xd1\x02,.\n\x0c\
    \n\x04\x04\x0c\x02\x0f\x12\x04\xd2\x02\x08,\n\r\n\x05\x04\x0c\x02\x0f\
    \x04\x12\x04\xd2\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x0f\x05\x12\x04\xd2\
    \x02\x11\x17\n\r\n\x05\x04\x0c\x02\x0f\x01\x12\x04\xd2\x02\x18&\n\r\n\
    \x05\x04\x0c\x02\x0f\x03\x12\x04\xd2\x02)+\n\x0c\n\x04\x04\x0c\x02\x10\
    \x12\x04\xd3\x02\x08H\n\r\n\x05\x04\x0c\x02\x10\x04\x12\x04\xd3\x02\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x10\x06\x12\x04\xd3\x02\x11*\n\r\n\x05\x04\
    \x0c\x02\x10\x01\x12\x04\xd3\x02+B\n\r\n\x05\x04\x0c\x02\x10\x03\x12\x04\
    \xd3\x02EG\n\x0c\n\x04\x04\x0c\x02\x11\x12\x04\xd4\x02\x08Q\n\r\n\x05\
    \x04\x0c\x02\x11\x04\x12\x04\xd4\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x11\
    \x06\x12\x04\xd4\x02\x11;\n\r\n\x05\x04\x0c\x02\x11\x01\x12\x04\xd4\x02<\
    K\n\r\n\x05\x04\x0c\x02\x11\x03\x12\x04\xd4\x02NP\n\x0c\n\x04\x04\x0c\
    \x02\x12\x12\x04\xd5\x02\x08T\n\r\n\x05\x04\x0c\x02\x12\x04\x12\x04\xd5\
    \x02\x08\x10\n\r\n\x05\x04\x0c\x02\x12\x06\x12\x04\xd5\x02\x11;\n\r\n\
    \x05\x04\x0c\x02\x12\x01\x12\x04\xd5\x02<N\n\r\n\x05\x04\x0c\x02\x12\x03\
    \x12\x04\xd5\x02QS\n\x0c\n\x04\x04\x0c\x02\x13\x12\x04\xd6\x02\x084\n\r\
    \n\x05\x04\x0c\x02\x13\x04\x12\x04\xd6\x02\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x13\x05\x12\x04\xd6\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x13\x01\x12\x04\
    \xd6\x02\x18.\n\r\n\x05\x04\x0c\x02\x13\x03\x12\x04\xd6\x0213\n\x0c\n\
    \x04\x04\x0c\x02\x14\x12\x04\xd7\x02\x08L\n\r\n\x05\x04\x0c\x02\x14\x04\
    \x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x14\x06\x12\x04\xd7\x02\
    \x115\n\r\n\x05\x04\x0c\x02\x14\x01\x12\x04\xd7\x026F\n\r\n\x05\x04\x0c\
    \x02\x14\x03\x12\x04\xd7\x02IK\n\x0c\n\x04\x04\x0c\x02\x15\x12\x04\xd8\
    \x02\x08)\n\r\n\x05\x04\x0c\x02\x15\x04\x12\x04\xd8\x02\x08\x10\n\r\n\
    \x05\x04\x0c\x02\x15\x05\x12\x04\xd8\x02\x11\x17\n\r\n\x05\x04\x0c\x02\
    \x15\x01\x12\x04\xd8\x02\x18#\n\r\n\x05\x04\x0c\x02\x15\x03\x12\x04\xd8\
    \x02&(\n\x0c\n\x04\x04\x0c\x02\x16\x12\x04\xd9\x02\x08)\n\r\n\x05\x04\
    \x0c\x02\x16\x04\x12\x04\xd9\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x16\x05\
    \x12\x04\xd9\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x16\x01\x12\x04\xd9\x02\
    \x18#\n\r\n\x05\x04\x0c\x02\x16\x03\x12\x04\xd9\x02&(\n\x0c\n\x04\x04\
    \x0c\x02\x17\x12\x04\xda\x02\x08/\n\r\n\x05\x04\x0c\x02\x17\x04\x12\x04\
    \xda\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x17\x05\x12\x04\xda\x02\x11\x17\n\
    \r\n\x05\x04\x0c\x02\x17\x01\x12\x04\xda\x02\x18)\n\r\n\x05\x04\x0c\x02\
    \x17\x03\x12\x04\xda\x02,.\n\x0c\n\x04\x04\x0c\x02\x18\x12\x04\xdb\x02\
    \x08d\n\r\n\x05\x04\x0c\x02\x18\x04\x12\x04\xdb\x02\x08\x10\n\r\n\x05\
    \x04\x0c\x02\x18\x06\x12\x04\xdb\x02\x11?\n\r\n\x05\x04\x0c\x02\x18\x01\
    \x12\x04\xdb\x02@^\n\r\n\x05\x04\x0c\x02\x18\x03\x12\x04\xdb\x02ac\n\x0c\
    \n\x04\x04\x0c\x02\x19\x12\x04\xdc\x02\x08I\n\r\n\x05\x04\x0c\x02\x19\
    \x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x19\x06\x12\x04\xdc\
    \x02\x113\n\r\n\x05\x04\x0c\x02\x19\x01\x12\x04\xdc\x024C\n\r\n\x05\x04\
    \x0c\x02\x19\x03\x12\x04\xdc\x02FH\n\x0c\n\x04\x04\x0c\x02\x1a\x12\x04\
    \xdd\x02\x08>\n\r\n\x05\x04\x0c\x02\x1a\x04\x12\x04\xdd\x02\x08\x10\n\r\
    \n\x05\x04\x0c\x02\x1a\x06\x12\x04\xdd\x02\x11)\n\r\n\x05\x04\x0c\x02\
    \x1a\x01\x12\x04\xdd\x02*8\n\r\n\x05\x04\x0c\x02\x1a\x03\x12\x04\xdd\x02\
    ;=\n\x0c\n\x04\x04\x0c\x02\x1b\x12\x04\xde\x02\x084\n\r\n\x05\x04\x0c\
    \x02\x1b\x04\x12\x04\xde\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x1b\x06\x12\
    \x04\xde\x02\x11\x1f\n\r\n\x05\x04\x0c\x02\x1b\x01\x12\x04\xde\x02\x20.\
    \n\r\n\x05\x04\x0c\x02\x1b\x03\x12\x04\xde\x0213\n\x0c\n\x04\x04\x0c\x02\
    \x1c\x12\x04\xdf\x02\x082\n\r\n\x05\x04\x0c\x02\x1c\x04\x12\x04\xdf\x02\
    \x08\x10\n\r\n\x05\x04\x0c\x02\x1c\x05\x12\x04\xdf\x02\x11\x15\n\r\n\x05\
    \x04\x0c\x02\x1c\x01\x12\x04\xdf\x02\x16,\n\r\n\x05\x04\x0c\x02\x1c\x03\
    \x12\x04\xdf\x02/1\n\x0c\n\x04\x04\x0c\x02\x1d\x12\x04\xe0\x02\x080\n\r\
    \n\x05\x04\x0c\x02\x1d\x04\x12\x04\xe0\x02\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x1d\x06\x12\x04\xe0\x02\x11\x1d\n\r\n\x05\x04\x0c\x02\x1d\x01\x12\x04\
    \xe0\x02\x1e*\n\r\n\x05\x04\x0c\x02\x1d\x03\x12\x04\xe0\x02-/\n\x0c\n\
    \x04\x04\x0c\x02\x1e\x12\x04\xe1\x02\x08<\n\r\n\x05\x04\x0c\x02\x1e\x04\
    \x12\x04\xe1\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x1e\x05\x12\x04\xe1\x02\
    \x11\x16\n\r\n\x05\x04\x0c\x02\x1e\x01\x12\x04\xe1\x02\x176\n\r\n\x05\
    \x04\x0c\x02\x1e\x03\x12\x04\xe1\x029;\n\x0c\n\x02\x04\r\x12\x06\xe4\x02\
    \0\xe8\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xe4\x02\x08\x1c\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\xe5\x02\x087\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xe5\
    \x02\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xe5\x02\x11\x17\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\xe5\x02\x182\n\r\n\x05\x04\r\x02\0\x03\x12\x04\
    \xe5\x0256\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xe6\x02\x084\n\r\n\x05\x04\
    \r\x02\x01\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\
    \x04\xe6\x02\x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xe6\x02\x18/\n\
    \r\n\x05\x04\r\x02\x01\x03\x12\x04\xe6\x0223\n\x0c\n\x04\x04\r\x02\x02\
    \x12\x04\xe7\x02\x086\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xe7\x02\x08\
    \x10\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\xe7\x02\x11&\n\r\n\x05\x04\r\
    \x02\x02\x01\x12\x04\xe7\x02'1\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xe7\
    \x0245\n\x0c\n\x02\x04\x0e\x12\x06\xea\x02\0\xef\x02\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xea\x02\x08\x1a\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xeb\
    \x02\x08'\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\xeb\x02\x11\x15\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xeb\x02\x16\"\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xeb\x02%&\n\
    \x0c\n\x04\x04\x0e\x02\x01\x12\x04\xec\x02\x08>\n\r\n\x05\x04\x0e\x02\
    \x01\x04\x12\x04\xec\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\
    \xec\x02\x11\"\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xec\x02#9\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\xec\x02<=\n\x0c\n\x04\x04\x0e\x02\x02\x12\
    \x04\xed\x02\x08(\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xed\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xed\x02\x11\x15\n\r\n\x05\x04\x0e\
    \x02\x02\x01\x12\x04\xed\x02\x16#\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\
    \xed\x02&'\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xee\x02\x08;\n\r\n\x05\
    \x04\x0e\x02\x03\x04\x12\x04\xee\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x03\
    \x06\x12\x04\xee\x02\x11\"\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xee\x02\
    #6\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xee\x029:\n\x0c\n\x02\x04\x0f\
    \x12\x06\xf1\x02\0\xf9\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xf1\x02\
    \x08\x1f\n\x0e\n\x04\x04\x0f\x03\0\x12\x06\xf2\x02\x08\xf6\x02\t\n\r\n\
    \x05\x04\x0f\x03\0\x01\x12\x04\xf2\x02\x10\x1f\n\x0e\n\x06\x04\x0f\x03\0\
    \x02\0\x12\x04\xf3\x02\x10+\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x04\x12\x04\
    \xf3\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x05\x12\x04\xf3\x02\x19\
    \x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x01\x12\x04\xf3\x02\x20&\n\x0f\n\
    \x07\x04\x0f\x03\0\x02\0\x03\x12\x04\xf3\x02)*\n\x0e\n\x06\x04\x0f\x03\0\
    \x02\x01\x12\x04\xf4\x02\x103\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x04\x12\
    \x04\xf4\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x05\x12\x04\xf4\
    \x02\x19\x1d\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\x04\xf4\x02\x1e.\
    \n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x03\x12\x04\xf4\x0212\n\x0e\n\x06\x04\
    \x0f\x03\0\x02\x02\x12\x04\xf5\x02\x101\n\x0f\n\x07\x04\x0f\x03\0\x02\
    \x02\x04\x12\x04\xf5\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x05\
    \x12\x04\xf5\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x01\x12\x04\
    \xf5\x02\x20,\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x03\x12\x04\xf5\x02/0\n\
    \x0c\n\x04\x04\x0f\x02\0\x12\x04\xf8\x02\x08P\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xf8\x02\
    \x118\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xf8\x029K\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xf8\x02NO\n\x0c\n\x02\x04\x10\x12\x06\xfb\x02\0\x9a\
    \x03\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xfb\x02\x08\x1e\n\x0c\n\x04\x04\
    \x10\x02\0\x12\x04\xfc\x02\x08&\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xfc\
    \x02\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xfc\x02\x11\x16\n\r\n\
    \x05\x04\x10\x02\0\x01\x12\x04\xfc\x02\x17!\n\r\n\x05\x04\x10\x02\0\x03\
    \x12\x04\xfc\x02$%\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xfd\x02\x08%\n\r\
    \n\x05\x04\x10\x02\x01\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\xfd\x02\x11\x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xfd\x02\x18\x20\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xfd\x02#$\n\x0c\n\
    \x04\x04\x10\x02\x02\x12\x04\xfe\x02\x08!\n\r\n\x05\x04\x10\x02\x02\x04\
    \x12\x04\xfe\x02\x08\x10\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xfe\x02\
    \x11\x17\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xfe\x02\x18\x1c\n\r\n\x05\
    \x04\x10\x02\x02\x03\x12\x04\xfe\x02\x1f\x20\n\x0c\n\x04\x04\x10\x02\x03\
    \x12\x04\xff\x02\x08$\n\r\n\x05\x04\x10\x02\x03\x04\x12\x04\xff\x02\x08\
    \x10\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xff\x02\x11\x17\n\r\n\x05\x04\
    \x10\x02\x03\x01\x12\x04\xff\x02\x18\x1f\n\r\n\x05\x04\x10\x02\x03\x03\
    \x12\x04\xff\x02\"#\n\x0c\n\x04\x04\x10\x02\x04\x12\x04\x80\x03\x08%\n\r\
    \n\x05\x04\x10\x02\x04\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\x04\x10\x02\
    \x04\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\
    \x80\x03\x18\x20\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\x80\x03#$\n\x0c\n\
    \x04\x04\x10\x02\x05\x12\x04\x81\x03\x08)\n\r\n\x05\x04\x10\x02\x05\x04\
    \x12\x04\x81\x03\x08\x10\n\r\n\x05\x04\x10\x02\x05\x05\x12\x04\x81\x03\
    \x11\x17\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\x81\x03\x18$\n\r\n\x05\
    \x04\x10\x02\x05\x03\x12\x04\x81\x03'(\n\x0c\n\x04\x04\x10\x02\x06\x12\
    \x04\x82\x03\x080\n\r\n\x05\x04\x10\x02\x06\x04\x12\x04\x82\x03\x08\x10\
    \n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\x82\x03\x11\x17\n\r\n\x05\x04\x10\
    \x02\x06\x01\x12\x04\x82\x03\x18+\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\
    \x82\x03./\n\x0c\n\x04\x04\x10\x02\x07\x12\x04\x83\x03\x08.\n\r\n\x05\
    \x04\x10\x02\x07\x04\x12\x04\x83\x03\x08\x10\n\r\n\x05\x04\x10\x02\x07\
    \x05\x12\x04\x83\x03\x11\x17\n\r\n\x05\x04\x10\x02\x07\x01\x12\x04\x83\
    \x03\x18)\n\r\n\x05\x04\x10\x02\x07\x03\x12\x04\x83\x03,-\n\x0c\n\x04\
    \x04\x10\x02\x08\x12\x04\x84\x03\x08,\n\r\n\x05\x04\x10\x02\x08\x04\x12\
    \x04\x84\x03\x08\x10\n\r\n\x05\x04\x10\x02\x08\x05\x12\x04\x84\x03\x11\
    \x17\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\x84\x03\x18'\n\r\n\x05\x04\
    \x10\x02\x08\x03\x12\x04\x84\x03*+\n\x0c\n\x04\x04\x10\x02\t\x12\x04\x85\
    \x03\x08.\n\r\n\x05\x04\x10\x02\t\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\
    \x04\x10\x02\t\x05\x12\x04\x85\x03\x11\x17\n\r\n\x05\x04\x10\x02\t\x01\
    \x12\x04\x85\x03\x18(\n\r\n\x05\x04\x10\x02\t\x03\x12\x04\x85\x03+-\n\
    \x0c\n\x04\x04\x10\x02\n\x12\x04\x86\x03\x08+\n\r\n\x05\x04\x10\x02\n\
    \x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x10\x02\n\x05\x12\x04\x86\x03\
    \x11\x17\n\r\n\x05\x04\x10\x02\n\x01\x12\x04\x86\x03\x18%\n\r\n\x05\x04\
    \x10\x02\n\x03\x12\x04\x86\x03(*\n\x0c\n\x04\x04\x10\x02\x0b\x12\x04\x87\
    \x03\x08,\n\r\n\x05\x04\x10\x02\x0b\x04\x12\x04\x87\x03\x08\x10\n\r\n\
    \x05\x04\x10\x02\x0b\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x04\x10\x02\
    \x0b\x01\x12\x04\x87\x03\x18&\n\r\n\x05\x04\x10\x02\x0b\x03\x12\x04\x87\
    \x03)+\n\x0c\n\x04\x04\x10\x02\x0c\x12\x04\x88\x03\x08(\n\r\n\x05\x04\
    \x10\x02\x0c\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x10\x02\x0c\x05\
    \x12\x04\x88\x03\x11\x16\n\r\n\x05\x04\x10\x02\x0c\x01\x12\x04\x88\x03\
    \x17\"\n\r\n\x05\x04\x10\x02\x0c\x03\x12\x04\x88\x03%'\n\x0c\n\x04\x04\
    \x10\x02\r\x12\x04\x89\x03\x08'\n\r\n\x05\x04\x10\x02\r\x04\x12\x04\x89\
    \x03\x08\x10\n\r\n\x05\x04\x10\x02\r\x05\x12\x04\x89\x03\x11\x16\n\r\n\
    \x05\x04\x10\x02\r\x01\x12\x04\x89\x03\x17!\n\r\n\x05\x04\x10\x02\r\x03\
    \x12\x04\x89\x03$&\n\x0c\n\x04\x04\x10\x02\x0e\x12\x04\x8a\x03\x08*\n\r\
    \n\x05\x04\x10\x02\x0e\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\x10\x02\
    \x0e\x05\x12\x04\x8a\x03\x11\x16\n\r\n\x05\x04\x10\x02\x0e\x01\x12\x04\
    \x8a\x03\x17$\n\r\n\x05\x04\x10\x02\x0e\x03\x12\x04\x8a\x03')\n\x0c\n\
    \x04\x04\x10\x02\x0f\x12\x04\x8b\x03\x08'\n\r\n\x05\x04\x10\x02\x0f\x04\
    \x12\x04\x8b\x03\x08\x10\n\r\n\x05\x04\x10\x02\x0f\x05\x12\x04\x8b\x03\
    \x11\x16\n\r\n\x05\x04\x10\x02\x0f\x01\x12\x04\x8b\x03\x17!\n\r\n\x05\
    \x04\x10\x02\x0f\x03\x12\x04\x8b\x03$&\n\x0c\n\x04\x04\x10\x02\x10\x12\
    \x04\x8c\x03\x08#\n\r\n\x05\x04\x10\x02\x10\x04\x12\x04\x8c\x03\x08\x10\
    \n\r\n\x05\x04\x10\x02\x10\x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04\x10\
    \x02\x10\x01\x12\x04\x8c\x03\x18\x1d\n\r\n\x05\x04\x10\x02\x10\x03\x12\
    \x04\x8c\x03\x20\"\n\x0c\n\x04\x04\x10\x02\x11\x12\x04\x8d\x03\x08$\n\r\
    \n\x05\x04\x10\x02\x11\x04\x12\x04\x8d\x03\x08\x10\n\r\n\x05\x04\x10\x02\
    \x11\x05\x12\x04\x8d\x03\x11\x17\n\r\n\x05\x04\x10\x02\x11\x01\x12\x04\
    \x8d\x03\x18\x1e\n\r\n\x05\x04\x10\x02\x11\x03\x12\x04\x8d\x03!#\n\x0c\n\
    \x04\x04\x10\x02\x12\x12\x04\x8e\x03\x08%\n\r\n\x05\x04\x10\x02\x12\x04\
    \x12\x04\x8e\x03\x08\x10\n\r\n\x05\x04\x10\x02\x12\x05\x12\x04\x8e\x03\
    \x11\x17\n\r\n\x05\x04\x10\x02\x12\x01\x12\x04\x8e\x03\x18\x1f\n\r\n\x05\
    \x04\x10\x02\x12\x03\x12\x04\x8e\x03\"$\n\x0c\n\x04\x04\x10\x02\x13\x12\
    \x04\x8f\x03\x08'\n\r\n\x05\x04\x10\x02\x13\x04\x12\x04\x8f\x03\x08\x10\
    \n\r\n\x05\x04\x10\x02\x13\x05\x12\x04\x8f\x03\x11\x17\n\r\n\x05\x04\x10\
    \x02\x13\x01\x12\x04\x8f\x03\x18!\n\r\n\x05\x04\x10\x02\x13\x03\x12\x04\
    \x8f\x03$&\n\x0c\n\x04\x04\x10\x02\x14\x12\x04\x90\x03\x08$\n\r\n\x05\
    \x04\x10\x02\x14\x04\x12\x04\x90\x03\x08\x10\n\r\n\x05\x04\x10\x02\x14\
    \x05\x12\x04\x90\x03\x11\x17\n\r\n\x05\x04\x10\x02\x14\x01\x12\x04\x90\
    \x03\x18\x1e\n\r\n\x05\x04\x10\x02\x14\x03\x12\x04\x90\x03!#\n\x0c\n\x04\
    \x04\x10\x02\x15\x12\x04\x91\x03\x08\x20\n\r\n\x05\x04\x10\x02\x15\x04\
    \x12\x04\x91\x03\x08\x10\n\r\n\x05\x04\x10\x02\x15\x05\x12\x04\x91\x03\
    \x11\x16\n\r\n\x05\x04\x10\x02\x15\x01\x12\x04\x91\x03\x17\x1a\n\r\n\x05\
    \x04\x10\x02\x15\x03\x12\x04\x91\x03\x1d\x1f\n\x0c\n\x04\x04\x10\x02\x16\
    \x12\x04\x92\x03\x08!\n\r\n\x05\x04\x10\x02\x16\x04\x12\x04\x92\x03\x08\
    \x10\n\r\n\x05\x04\x10\x02\x16\x05\x12\x04\x92\x03\x11\x16\n\r\n\x05\x04\
    \x10\x02\x16\x01\x12\x04\x92\x03\x17\x1b\n\r\n\x05\x04\x10\x02\x16\x03\
    \x12\x04\x92\x03\x1e\x20\n\x0c\n\x04\x04\x10\x02\x17\x12\x04\x93\x03\x08\
    &\n\r\n\x05\x04\x10\x02\x17\x04\x12\x04\x93\x03\x08\x10\n\r\n\x05\x04\
    \x10\x02\x17\x05\x12\x04\x93\x03\x11\x16\n\r\n\x05\x04\x10\x02\x17\x01\
    \x12\x04\x93\x03\x17\x20\n\r\n\x05\x04\x10\x02\x17\x03\x12\x04\x93\x03#%\
    \n\x0c\n\x04\x04\x10\x02\x18\x12\x04\x94\x03\x08#\n\r\n\x05\x04\x10\x02\
    \x18\x04\x12\x04\x94\x03\x08\x10\n\r\n\x05\x04\x10\x02\x18\x05\x12\x04\
    \x94\x03\x11\x16\n\r\n\x05\x04\x10\x02\x18\x01\x12\x04\x94\x03\x17\x1d\n\
    \r\n\x05\x04\x10\x02\x18\x03\x12\x04\x94\x03\x20\"\n\x0c\n\x04\x04\x10\
    \x02\x19\x12\x04\x95\x03\x08\"\n\r\n\x05\x04\x10\x02\x19\x04\x12\x04\x95\
    \x03\x08\x10\n\r\n\x05\x04\x10\x02\x19\x05\x12\x04\x95\x03\x11\x16\n\r\n\
    \x05\x04\x10\x02\x19\x01\x12\x04\x95\x03\x17\x1c\n\r\n\x05\x04\x10\x02\
    \x19\x03\x12\x04\x95\x03\x1f!\n\x0c\n\x04\x04\x10\x02\x1a\x12\x04\x96\
    \x03\x08/\n\r\n\x05\x04\x10\x02\x1a\x04\x12\x04\x96\x03\x08\x10\n\r\n\
    \x05\x04\x10\x02\x1a\x05\x12\x04\x96\x03\x11\x17\n\r\n\x05\x04\x10\x02\
    \x1a\x01\x12\x04\x96\x03\x18)\n\r\n\x05\x04\x10\x02\x1a\x03\x12\x04\x96\
    \x03,.\n\x0c\n\x04\x04\x10\x02\x1b\x12\x04\x97\x03\x083\n\r\n\x05\x04\
    \x10\x02\x1b\x04\x12\x04\x97\x03\x08\x10\n\r\n\x05\x04\x10\x02\x1b\x05\
    \x12\x04\x97\x03\x11\x17\n\r\n\x05\x04\x10\x02\x1b\x01\x12\x04\x97\x03\
    \x18-\n\r\n\x05\x04\x10\x02\x1b\x03\x12\x04\x97\x0302\n\x0c\n\x04\x04\
    \x10\x02\x1c\x12\x04\x98\x03\x08-\n\r\n\x05\x04\x10\x02\x1c\x04\x12\x04\
    \x98\x03\x08\x10\n\r\n\x05\x04\x10\x02\x1c\x05\x12\x04\x98\x03\x11\x17\n\
    \r\n\x05\x04\x10\x02\x1c\x01\x12\x04\x98\x03\x18'\n\r\n\x05\x04\x10\x02\
    \x1c\x03\x12\x04\x98\x03*,\n\x0c\n\x04\x04\x10\x02\x1d\x12\x04\x99\x03\
    \x08(\n\r\n\x05\x04\x10\x02\x1d\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\
    \x04\x10\x02\x1d\x05\x12\x04\x99\x03\x11\x17\n\r\n\x05\x04\x10\x02\x1d\
    \x01\x12\x04\x99\x03\x18\"\n\r\n\x05\x04\x10\x02\x1d\x03\x12\x04\x99\x03\
    %'\n\x0c\n\x02\x04\x11\x12\x06\x9c\x03\0\xb7\x03\x01\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\x9c\x03\x08'\n\x0e\n\x04\x04\x11\x03\0\x12\x06\x9d\x03\x08\
    \xb4\x03\t\n\r\n\x05\x04\x11\x03\0\x01\x12\x04\x9d\x03\x10#\n\x10\n\x06\
    \x04\x11\x03\0\x03\0\x12\x06\x9e\x03\x10\xa1\x03\x11\n\x0f\n\x07\x04\x11\
    \x03\0\x03\0\x01\x12\x04\x9e\x03\x18\"\n\x10\n\x08\x04\x11\x03\0\x03\0\
    \x02\0\x12\x04\x9f\x03\x181\n\x11\n\t\x04\x11\x03\0\x03\0\x02\0\x04\x12\
    \x04\x9f\x03\x18\x20\n\x11\n\t\x04\x11\x03\0\x03\0\x02\0\x05\x12\x04\x9f\
    \x03!'\n\x11\n\t\x04\x11\x03\0\x03\0\x02\0\x01\x12\x04\x9f\x03(,\n\x11\n\
    \t\x04\x11\x03\0\x03\0\x02\0\x03\x12\x04\x9f\x03/0\n\x10\n\x08\x04\x11\
    \x03\0\x03\0\x02\x01\x12\x04\xa0\x03\x182\n\x11\n\t\x04\x11\x03\0\x03\0\
    \x02\x01\x04\x12\x04\xa0\x03\x18\x20\n\x11\n\t\x04\x11\x03\0\x03\0\x02\
    \x01\x05\x12\x04\xa0\x03!'\n\x11\n\t\x04\x11\x03\0\x03\0\x02\x01\x01\x12\
    \x04\xa0\x03(-\n\x11\n\t\x04\x11\x03\0\x03\0\x02\x01\x03\x12\x04\xa0\x03\
    01\n\x0e\n\x06\x04\x11\x03\0\x02\0\x12\x04\xa3\x03\x10/\n\x0f\n\x07\x04\
    \x11\x03\0\x02\0\x04\x12\x04\xa3\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\
    \x02\0\x05\x12\x04\xa3\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\0\x01\
    \x12\x04\xa3\x03\x20*\n\x0f\n\x07\x04\x11\x03\0\x02\0\x03\x12\x04\xa3\
    \x03-.\n\x0e\n\x06\x04\x11\x03\0\x02\x01\x12\x04\xa4\x03\x10*\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x01\x04\x12\x04\xa4\x03\x10\x18\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x01\x05\x12\x04\xa4\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x01\x01\x12\x04\xa4\x03\x20%\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x03\
    \x12\x04\xa4\x03()\n\x0e\n\x06\x04\x11\x03\0\x02\x02\x12\x04\xa5\x03\x10\
    ;\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x04\x12\x04\xa5\x03\x10\x18\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x02\x05\x12\x04\xa5\x03\x19\x1f\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x02\x01\x12\x04\xa5\x03\x206\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x02\x03\x12\x04\xa5\x039:\n\x0e\n\x06\x04\x11\x03\0\x02\x03\x12\x04\
    \xa6\x03\x103\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x04\x12\x04\xa6\x03\x10\
    \x18\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x05\x12\x04\xa6\x03\x19\x1f\n\x0f\
    \n\x07\x04\x11\x03\0\x02\x03\x01\x12\x04\xa6\x03\x20.\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x03\x03\x12\x04\xa6\x0312\n\x0e\n\x06\x04\x11\x03\0\x02\
    \x04\x12\x04\xa7\x03\x10D\n\x0f\n\x07\x04\x11\x03\0\x02\x04\x04\x12\x04\
    \xa7\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x04\x05\x12\x04\xa7\x03\
    \x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x04\x01\x12\x04\xa7\x03\x20?\n\
    \x0f\n\x07\x04\x11\x03\0\x02\x04\x03\x12\x04\xa7\x03BC\n\x0e\n\x06\x04\
    \x11\x03\0\x02\x05\x12\x04\xa8\x03\x107\n\x0f\n\x07\x04\x11\x03\0\x02\
    \x05\x04\x12\x04\xa8\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x05\x05\
    \x12\x04\xa8\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x05\x01\x12\x04\
    \xa8\x03\x202\n\x0f\n\x07\x04\x11\x03\0\x02\x05\x03\x12\x04\xa8\x0356\n\
    \x0e\n\x06\x04\x11\x03\0\x02\x06\x12\x04\xa9\x03\x106\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x06\x04\x12\x04\xa9\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x06\x05\x12\x04\xa9\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x06\
    \x01\x12\x04\xa9\x03\x201\n\x0f\n\x07\x04\x11\x03\0\x02\x06\x03\x12\x04\
    \xa9\x0345\n\x0e\n\x06\x04\x11\x03\0\x02\x07\x12\x04\xaa\x03\x108\n\x0f\
    \n\x07\x04\x11\x03\0\x02\x07\x04\x12\x04\xaa\x03\x10\x18\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x07\x05\x12\x04\xaa\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x07\x01\x12\x04\xaa\x03\x203\n\x0f\n\x07\x04\x11\x03\0\x02\x07\x03\
    \x12\x04\xaa\x0367\n\x0e\n\x06\x04\x11\x03\0\x02\x08\x12\x04\xab\x03\x10\
    +\n\x0f\n\x07\x04\x11\x03\0\x02\x08\x04\x12\x04\xab\x03\x10\x18\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x08\x05\x12\x04\xab\x03\x19\x1f\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x08\x01\x12\x04\xab\x03\x20&\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x08\x03\x12\x04\xab\x03)*\n\x0e\n\x06\x04\x11\x03\0\x02\t\x12\x04\
    \xac\x03\x10.\n\x0f\n\x07\x04\x11\x03\0\x02\t\x04\x12\x04\xac\x03\x10\
    \x18\n\x0f\n\x07\x04\x11\x03\0\x02\t\x05\x12\x04\xac\x03\x19\x1f\n\x0f\n\
    \x07\x04\x11\x03\0\x02\t\x01\x12\x04\xac\x03\x20(\n\x0f\n\x07\x04\x11\
    \x03\0\x02\t\x03\x12\x04\xac\x03+-\n\x0e\n\x06\x04\x11\x03\0\x02\n\x12\
    \x04\xad\x03\x101\n\x0f\n\x07\x04\x11\x03\0\x02\n\x04\x12\x04\xad\x03\
    \x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\n\x05\x12\x04\xad\x03\x19\x1f\n\
    \x0f\n\x07\x04\x11\x03\0\x02\n\x01\x12\x04\xad\x03\x20+\n\x0f\n\x07\x04\
    \x11\x03\0\x02\n\x03\x12\x04\xad\x03.0\n\x0e\n\x06\x04\x11\x03\0\x02\x0b\
    \x12\x04\xae\x03\x108\n\x0f\n\x07\x04\x11\x03\0\x02\x0b\x04\x12\x04\xae\
    \x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x0b\x05\x12\x04\xae\x03\x19\
    \x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x0b\x01\x12\x04\xae\x03\x202\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x0b\x03\x12\x04\xae\x0357\n\x0e\n\x06\x04\x11\x03\
    \0\x02\x0c\x12\x04\xaf\x03\x100\n\x0f\n\x07\x04\x11\x03\0\x02\x0c\x04\
    \x12\x04\xaf\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x0c\x05\x12\x04\
    \xaf\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x0c\x01\x12\x04\xaf\x03\
    \x20*\n\x0f\n\x07\x04\x11\x03\0\x02\x0c\x03\x12\x04\xaf\x03-/\n\x0e\n\
    \x06\x04\x11\x03\0\x02\r\x12\x04\xb0\x03\x101\n\x0f\n\x07\x04\x11\x03\0\
    \x02\r\x04\x12\x04\xb0\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\r\x05\
    \x12\x04\xb0\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\r\x01\x12\x04\xb0\
    \x03\x20+\n\x0f\n\x07\x04\x11\x03\0\x02\r\x03\x12\x04\xb0\x03.0\n\x0e\n\
    \x06\x04\x11\x03\0\x02\x0e\x12\x04\xb1\x03\x10j\n\x0f\n\x07\x04\x11\x03\
    \0\x02\x0e\x04\x12\x04\xb1\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x0e\
    \x06\x12\x04\xb1\x03\x19W\n\x0f\n\x07\x04\x11\x03\0\x02\x0e\x01\x12\x04\
    \xb1\x03Xd\n\x0f\n\x07\x04\x11\x03\0\x02\x0e\x03\x12\x04\xb1\x03gi\n\x0e\
    \n\x06\x04\x11\x03\0\x02\x0f\x12\x04\xb2\x03\x107\n\x0f\n\x07\x04\x11\
    \x03\0\x02\x0f\x04\x12\x04\xb2\x03\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\
    \x0f\x05\x12\x04\xb2\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x0f\x01\
    \x12\x04\xb2\x03\x201\n\x0f\n\x07\x04\x11\x03\0\x02\x0f\x03\x12\x04\xb2\
    \x0346\n\x0e\n\x06\x04\x11\x03\0\x02\x10\x12\x04\xb3\x03\x107\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x10\x04\x12\x04\xb3\x03\x10\x18\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x10\x05\x12\x04\xb3\x03\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x10\x01\x12\x04\xb3\x03\x201\n\x0f\n\x07\x04\x11\x03\0\x02\x10\x03\
    \x12\x04\xb3\x0346\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xb6\x03\x08Q\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x06\x12\x04\xb6\x03\x11D\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb6\x03EL\
    \n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb6\x03OP\n\x0c\n\x02\x04\x12\x12\
    \x06\xb9\x03\0\xd6\x03\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xb9\x03\x08$\
    \n\x0e\n\x04\x04\x12\x03\0\x12\x06\xba\x03\x08\xc8\x03\t\n\r\n\x05\x04\
    \x12\x03\0\x01\x12\x04\xba\x03\x10\x1e\n\x0e\n\x06\x04\x12\x03\0\x02\0\
    \x12\x04\xbb\x03\x10,\n\x0f\n\x07\x04\x12\x03\0\x02\0\x04\x12\x04\xbb\
    \x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\0\x05\x12\x04\xbb\x03\x19\x1f\
    \n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\x12\x04\xbb\x03\x20'\n\x0f\n\x07\
    \x04\x12\x03\0\x02\0\x03\x12\x04\xbb\x03*+\n\x0e\n\x06\x04\x12\x03\0\x02\
    \x01\x12\x04\xbc\x03\x102\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x04\x12\x04\
    \xbc\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x05\x12\x04\xbc\x03\
    \x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x01\x12\x04\xbc\x03\x20-\n\
    \x0f\n\x07\x04\x12\x03\0\x02\x01\x03\x12\x04\xbc\x0301\n\x0e\n\x06\x04\
    \x12\x03\0\x02\x02\x12\x04\xbd\x03\x103\n\x0f\n\x07\x04\x12\x03\0\x02\
    \x02\x04\x12\x04\xbd\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x05\
    \x12\x04\xbd\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x01\x12\x04\
    \xbd\x03\x20.\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x03\x12\x04\xbd\x0312\n\
    \x0e\n\x06\x04\x12\x03\0\x02\x03\x12\x04\xbe\x03\x104\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x03\x04\x12\x04\xbe\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x03\x05\x12\x04\xbe\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x03\
    \x01\x12\x04\xbe\x03\x20/\n\x0f\n\x07\x04\x12\x03\0\x02\x03\x03\x12\x04\
    \xbe\x0323\n\x0e\n\x06\x04\x12\x03\0\x02\x04\x12\x04\xbf\x03\x100\n\x0f\
    \n\x07\x04\x12\x03\0\x02\x04\x04\x12\x04\xbf\x03\x10\x18\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x04\x05\x12\x04\xbf\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x04\x01\x12\x04\xbf\x03\x20+\n\x0f\n\x07\x04\x12\x03\0\x02\x04\x03\
    \x12\x04\xbf\x03./\n\x0e\n\x06\x04\x12\x03\0\x02\x05\x12\x04\xc0\x03\x10\
    0\n\x0f\n\x07\x04\x12\x03\0\x02\x05\x04\x12\x04\xc0\x03\x10\x18\n\x0f\n\
    \x07\x04\x12\x03\0\x02\x05\x05\x12\x04\xc0\x03\x19\x1f\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x05\x01\x12\x04\xc0\x03\x20+\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x05\x03\x12\x04\xc0\x03./\n\x0e\n\x06\x04\x12\x03\0\x02\x06\x12\x04\
    \xc1\x03\x103\n\x0f\n\x07\x04\x12\x03\0\x02\x06\x04\x12\x04\xc1\x03\x10\
    \x18\n\x0f\n\x07\x04\x12\x03\0\x02\x06\x05\x12\x04\xc1\x03\x19\x1f\n\x0f\
    \n\x07\x04\x12\x03\0\x02\x06\x01\x12\x04\xc1\x03\x20.\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x06\x03\x12\x04\xc1\x0312\n\x0e\n\x06\x04\x12\x03\0\x02\
    \x07\x12\x04\xc2\x03\x105\n\x0f\n\x07\x04\x12\x03\0\x02\x07\x04\x12\x04\
    \xc2\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x07\x05\x12\x04\xc2\x03\
    \x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x07\x01\x12\x04\xc2\x03\x200\n\
    \x0f\n\x07\x04\x12\x03\0\x02\x07\x03\x12\x04\xc2\x0334\n\x0e\n\x06\x04\
    \x12\x03\0\x02\x08\x12\x04\xc3\x03\x101\n\x0f\n\x07\x04\x12\x03\0\x02\
    \x08\x04\x12\x04\xc3\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x08\x05\
    \x12\x04\xc3\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x08\x01\x12\x04\
    \xc3\x03\x20,\n\x0f\n\x07\x04\x12\x03\0\x02\x08\x03\x12\x04\xc3\x03/0\n\
    \x0e\n\x06\x04\x12\x03\0\x02\t\x12\x04\xc4\x03\x102\n\x0f\n\x07\x04\x12\
    \x03\0\x02\t\x04\x12\x04\xc4\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\t\
    \x05\x12\x04\xc4\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\t\x01\x12\x04\
    \xc4\x03\x20,\n\x0f\n\x07\x04\x12\x03\0\x02\t\x03\x12\x04\xc4\x03/1\n\
    \x0e\n\x06\x04\x12\x03\0\x02\n\x12\x04\xc5\x03\x100\n\x0f\n\x07\x04\x12\
    \x03\0\x02\n\x04\x12\x04\xc5\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\n\
    \x05\x12\x04\xc5\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\n\x01\x12\x04\
    \xc5\x03\x20*\n\x0f\n\x07\x04\x12\x03\0\x02\n\x03\x12\x04\xc5\x03-/\n\
    \x0e\n\x06\x04\x12\x03\0\x02\x0b\x12\x04\xc6\x03\x105\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x0b\x04\x12\x04\xc6\x03\x10\x18\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x0b\x05\x12\x04\xc6\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x0b\
    \x01\x12\x04\xc6\x03\x20/\n\x0f\n\x07\x04\x12\x03\0\x02\x0b\x03\x12\x04\
    \xc6\x0324\n\x0e\n\x06\x04\x12\x03\0\x02\x0c\x12\x04\xc7\x03\x102\n\x0f\
    \n\x07\x04\x12\x03\0\x02\x0c\x04\x12\x04\xc7\x03\x10\x18\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x0c\x05\x12\x04\xc7\x03\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x0c\x01\x12\x04\xc7\x03\x20,\n\x0f\n\x07\x04\x12\x03\0\x02\x0c\x03\
    \x12\x04\xc7\x03/1\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xca\x03\x08%\n\r\n\
    \x05\x04\x12\x02\0\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x04\x12\x02\0\
    \x05\x12\x04\xca\x03\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xca\x03\
    \x18\x20\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xca\x03#$\n\x0c\n\x04\x04\
    \x12\x02\x01\x12\x04\xcb\x03\x08)\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\
    \xcb\x03\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xcb\x03\x11\x18\n\
    \r\n\x05\x04\x12\x02\x01\x01\x12\x04\xcb\x03\x19$\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xcb\x03'(\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xcc\x03\
    \x08C\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xcc\x03\x08\x10\n\r\n\x05\
    \x04\x12\x02\x02\x06\x12\x04\xcc\x03\x11)\n\r\n\x05\x04\x12\x02\x02\x01\
    \x12\x04\xcc\x03*>\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xcc\x03AB\n\x0c\
    \n\x04\x04\x12\x02\x03\x12\x04\xcd\x03\x08:\n\r\n\x05\x04\x12\x02\x03\
    \x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\xcd\
    \x03\x11#\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xcd\x03$5\n\r\n\x05\x04\
    \x12\x02\x03\x03\x12\x04\xcd\x0389\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\
    \xce\x03\x08%\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xce\x03\x08\x10\n\r\
    \n\x05\x04\x12\x02\x04\x05\x12\x04\xce\x03\x11\x17\n\r\n\x05\x04\x12\x02\
    \x04\x01\x12\x04\xce\x03\x18\x20\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\
    \xce\x03#$\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\xcf\x03\x082\n\r\n\x05\
    \x04\x12\x02\x05\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04\x12\x02\x05\
    \x05\x12\x04\xcf\x03\x11\x18\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\xcf\
    \x03\x19-\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\xcf\x0301\n\x0c\n\x04\
    \x04\x12\x02\x06\x12\x04\xd0\x03\x081\n\r\n\x05\x04\x12\x02\x06\x04\x12\
    \x04\xd0\x03\x08\x10\n\r\n\x05\x04\x12\x02\x06\x06\x12\x04\xd0\x03\x11\
    \x1e\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\xd0\x03\x1f,\n\r\n\x05\x04\
    \x12\x02\x06\x03\x12\x04\xd0\x03/0\n\x0c\n\x04\x04\x12\x02\x07\x12\x04\
    \xd1\x03\x08R\n\r\n\x05\x04\x12\x02\x07\x04\x12\x04\xd1\x03\x08\x10\n\r\
    \n\x05\x04\x12\x02\x07\x06\x12\x04\xd1\x03\x11<\n\r\n\x05\x04\x12\x02\
    \x07\x01\x12\x04\xd1\x03=M\n\r\n\x05\x04\x12\x02\x07\x03\x12\x04\xd1\x03\
    PQ\n\x0c\n\x04\x04\x12\x02\x08\x12\x04\xd2\x03\x08(\n\r\n\x05\x04\x12\
    \x02\x08\x04\x12\x04\xd2\x03\x08\x10\n\r\n\x05\x04\x12\x02\x08\x06\x12\
    \x04\xd2\x03\x11\x19\n\r\n\x05\x04\x12\x02\x08\x01\x12\x04\xd2\x03\x1a\"\
    \n\r\n\x05\x04\x12\x02\x08\x03\x12\x04\xd2\x03%'\n\x0c\n\x04\x04\x12\x02\
    \t\x12\x04\xd3\x03\x08-\n\r\n\x05\x04\x12\x02\t\x04\x12\x04\xd3\x03\x08\
    \x10\n\r\n\x05\x04\x12\x02\t\x05\x12\x04\xd3\x03\x11\x18\n\r\n\x05\x04\
    \x12\x02\t\x01\x12\x04\xd3\x03\x19'\n\r\n\x05\x04\x12\x02\t\x03\x12\x04\
    \xd3\x03*,\n\x0c\n\x04\x04\x12\x02\n\x12\x04\xd4\x03\x08&\n\r\n\x05\x04\
    \x12\x02\n\x04\x12\x04\xd4\x03\x08\x10\n\r\n\x05\x04\x12\x02\n\x05\x12\
    \x04\xd4\x03\x11\x18\n\r\n\x05\x04\x12\x02\n\x01\x12\x04\xd4\x03\x19\x20\
    \n\r\n\x05\x04\x12\x02\n\x03\x12\x04\xd4\x03#%\n\x0c\n\x04\x04\x12\x02\
    \x0b\x12\x04\xd5\x03\x08*\n\r\n\x05\x04\x12\x02\x0b\x04\x12\x04\xd5\x03\
    \x08\x10\n\r\n\x05\x04\x12\x02\x0b\x05\x12\x04\xd5\x03\x11\x17\n\r\n\x05\
    \x04\x12\x02\x0b\x01\x12\x04\xd5\x03\x18$\n\r\n\x05\x04\x12\x02\x0b\x03\
    \x12\x04\xd5\x03')\n\x0c\n\x02\x04\x13\x12\x06\xd8\x03\0\xda\x03\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\xd8\x03\x08\x20\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xd9\x03\x08C\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xd9\x03\x08\
    \x10\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xd9\x03\x11)\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xd9\x03*>\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xd9\x03\
    AB\n\x0c\n\x02\x04\x14\x12\x06\xdc\x03\0\xe1\x03\x01\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\xdc\x03\x08-\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xdd\x03\x08+\
    \n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04\x14\
    \x02\0\x05\x12\x04\xdd\x03\x11\x17\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\
    \xdd\x03\x18&\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xdd\x03)*\n\x0c\n\x04\
    \x04\x14\x02\x01\x12\x04\xde\x03\x08*\n\r\n\x05\x04\x14\x02\x01\x04\x12\
    \x04\xde\x03\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xde\x03\x11\
    \x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xde\x03\x18%\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xde\x03()\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\
    \xdf\x03\x08*\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xdf\x03\x08\x10\n\r\
    \n\x05\x04\x14\x02\x02\x05\x12\x04\xdf\x03\x11\x17\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xdf\x03\x18%\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xdf\
    \x03()\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xe0\x03\x08+\n\r\n\x05\x04\
    \x14\x02\x03\x04\x12\x04\xe0\x03\x08\x10\n\r\n\x05\x04\x14\x02\x03\x05\
    \x12\x04\xe0\x03\x11\x17\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xe0\x03\
    \x18&\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xe0\x03)*\n\x0c\n\x02\x04\
    \x15\x12\x06\xe3\x03\0\xe7\x03\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xe3\
    \x03\x08.\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xe4\x03\x08-\n\r\n\x05\x04\
    \x15\x02\0\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\
    \x04\xe4\x03\x11\x15\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xe4\x03\x16(\n\
    \r\n\x05\x04\x15\x02\0\x03\x12\x04\xe4\x03+,\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\xe5\x03\x08*\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xe5\x03\x08\
    \x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xe5\x03\x11\x15\n\r\n\x05\x04\
    \x15\x02\x01\x01\x12\x04\xe5\x03\x16%\n\r\n\x05\x04\x15\x02\x01\x03\x12\
    \x04\xe5\x03()\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xe6\x03\x080\n\r\n\
    \x05\x04\x15\x02\x02\x04\x12\x04\xe6\x03\x08\x10\n\r\n\x05\x04\x15\x02\
    \x02\x05\x12\x04\xe6\x03\x11\x17\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\
    \xe6\x03\x18+\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xe6\x03./\n\x0c\n\
    \x02\x04\x16\x12\x06\xe9\x03\0\xef\x03\x01\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\xe9\x03\x08)\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xea\x03\x08%\n\r\n\
    \x05\x04\x16\x02\0\x04\x12\x04\xea\x03\x08\x10\n\r\n\x05\x04\x16\x02\0\
    \x06\x12\x04\xea\x03\x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xea\x03\
    \x18\x20\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xea\x03#$\n\x0c\n\x04\x04\
    \x16\x02\x01\x12\x04\xeb\x03\x08&\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\
    \xeb\x03\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xeb\x03\x11\x17\n\
    \r\n\x05\x04\x16\x02\x01\x01\x12\x04\xeb\x03\x18!\n\r\n\x05\x04\x16\x02\
    \x01\x03\x12\x04\xeb\x03$%\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xec\x03\
    \x08%\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xec\x03\x08\x10\n\r\n\x05\
    \x04\x16\x02\x02\x05\x12\x04\xec\x03\x11\x17\n\r\n\x05\x04\x16\x02\x02\
    \x01\x12\x04\xec\x03\x18\x20\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xec\
    \x03#$\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\xed\x03\x08+\n\r\n\x05\x04\
    \x16\x02\x03\x04\x12\x04\xed\x03\x08\x10\n\r\n\x05\x04\x16\x02\x03\x05\
    \x12\x04\xed\x03\x11\x16\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xed\x03\
    \x17&\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xed\x03)*\n\x0c\n\x04\x04\
    \x16\x02\x04\x12\x04\xee\x03\x08'\n\r\n\x05\x04\x16\x02\x04\x04\x12\x04\
    \xee\x03\x08\x10\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\xee\x03\x11\x17\n\
    \r\n\x05\x04\x16\x02\x04\x01\x12\x04\xee\x03\x18\"\n\r\n\x05\x04\x16\x02\
    \x04\x03\x12\x04\xee\x03%&\n\x0c\n\x02\x04\x17\x12\x06\xf1\x03\0\x88\x04\
    \x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xf1\x03\x08$\n\x0c\n\x04\x04\x17\
    \x02\0\x12\x04\xf2\x03\x08.\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xf2\x03\
    \x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xf2\x03\x11\x16\n\r\n\x05\
    \x04\x17\x02\0\x01\x12\x04\xf2\x03\x17)\n\r\n\x05\x04\x17\x02\0\x03\x12\
    \x04\xf2\x03,-\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xf3\x03\x08*\n\r\n\
    \x05\x04\x17\x02\x01\x04\x12\x04\xf3\x03\x08\x10\n\r\n\x05\x04\x17\x02\
    \x01\x05\x12\x04\xf3\x03\x11\x16\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\
    \xf3\x03\x17%\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xf3\x03()\n\x0c\n\
    \x04\x04\x17\x02\x02\x12\x04\xf4\x03\x085\n\r\n\x05\x04\x17\x02\x02\x04\
    \x12\x04\xf4\x03\x08\x10\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xf4\x03\
    \x11\x16\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xf4\x03\x170\n\r\n\x05\
    \x04\x17\x02\x02\x03\x12\x04\xf4\x0334\n\x0c\n\x04\x04\x17\x02\x03\x12\
    \x04\xf5\x03\x081\n\r\n\x05\x04\x17\x02\x03\x04\x12\x04\xf5\x03\x08\x10\
    \n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xf5\x03\x11\x16\n\r\n\x05\x04\x17\
    \x02\x03\x01\x12\x04\xf5\x03\x17,\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\
    \xf5\x03/0\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\xf6\x03\x080\n\r\n\x05\
    \x04\x17\x02\x04\x04\x12\x04\xf6\x03\x08\x10\n\r\n\x05\x04\x17\x02\x04\
    \x05\x12\x04\xf6\x03\x11\x16\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\xf6\
    \x03\x17+\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\xf6\x03./\n\x0c\n\x04\
    \x04\x17\x02\x05\x12\x04\xf7\x03\x08,\n\r\n\x05\x04\x17\x02\x05\x04\x12\
    \x04\xf7\x03\x08\x10\n\r\n\x05\x04\x17\x02\x05\x05\x12\x04\xf7\x03\x11\
    \x16\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\xf7\x03\x17'\n\r\n\x05\x04\
    \x17\x02\x05\x03\x12\x04\xf7\x03*+\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\
    \xf8\x03\x084\n\r\n\x05\x04\x17\x02\x06\x04\x12\x04\xf8\x03\x08\x10\n\r\
    \n\x05\x04\x17\x02\x06\x05\x12\x04\xf8\x03\x11\x16\n\r\n\x05\x04\x17\x02\
    \x06\x01\x12\x04\xf8\x03\x17/\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\xf8\
    \x0323\n\x0c\n\x04\x04\x17\x02\x07\x12\x04\xf9\x03\x080\n\r\n\x05\x04\
    \x17\x02\x07\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04\x17\x02\x07\x05\
    \x12\x04\xf9\x03\x11\x16\n\r\n\x05\x04\x17\x02\x07\x01\x12\x04\xf9\x03\
    \x17+\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\xf9\x03./\n\x0c\n\x04\x04\
    \x17\x02\x08\x12\x04\xfa\x03\x088\n\r\n\x05\x04\x17\x02\x08\x04\x12\x04\
    \xfa\x03\x08\x10\n\r\n\x05\x04\x17\x02\x08\x05\x12\x04\xfa\x03\x11\x16\n\
    \r\n\x05\x04\x17\x02\x08\x01\x12\x04\xfa\x03\x173\n\r\n\x05\x04\x17\x02\
    \x08\x03\x12\x04\xfa\x0367\n\x0c\n\x04\x04\x17\x02\t\x12\x04\xfb\x03\x08\
    5\n\r\n\x05\x04\x17\x02\t\x04\x12\x04\xfb\x03\x08\x10\n\r\n\x05\x04\x17\
    \x02\t\x05\x12\x04\xfb\x03\x11\x16\n\r\n\x05\x04\x17\x02\t\x01\x12\x04\
    \xfb\x03\x17/\n\r\n\x05\x04\x17\x02\t\x03\x12\x04\xfb\x0324\n\x0c\n\x04\
    \x04\x17\x02\n\x12\x04\xfc\x03\x080\n\r\n\x05\x04\x17\x02\n\x04\x12\x04\
    \xfc\x03\x08\x10\n\r\n\x05\x04\x17\x02\n\x05\x12\x04\xfc\x03\x11\x16\n\r\
    \n\x05\x04\x17\x02\n\x01\x12\x04\xfc\x03\x17*\n\r\n\x05\x04\x17\x02\n\
    \x03\x12\x04\xfc\x03-/\n\x0c\n\x04\x04\x17\x02\x0b\x12\x04\xfd\x03\x08,\
    \n\r\n\x05\x04\x17\x02\x0b\x04\x12\x04\xfd\x03\x08\x10\n\r\n\x05\x04\x17\
    \x02\x0b\x05\x12\x04\xfd\x03\x11\x16\n\r\n\x05\x04\x17\x02\x0b\x01\x12\
    \x04\xfd\x03\x17&\n\r\n\x05\x04\x17\x02\x0b\x03\x12\x04\xfd\x03)+\n\x0c\
    \n\x04\x04\x17\x02\x0c\x12\x04\xfe\x03\x08H\n\r\n\x05\x04\x17\x02\x0c\
    \x04\x12\x04\xfe\x03\x08\x10\n\r\n\x05\x04\x17\x02\x0c\x05\x12\x04\xfe\
    \x03\x11\x16\n\r\n\x05\x04\x17\x02\x0c\x01\x12\x04\xfe\x03\x17B\n\r\n\
    \x05\x04\x17\x02\x0c\x03\x12\x04\xfe\x03EG\n\x0c\n\x04\x04\x17\x02\r\x12\
    \x04\xff\x03\x08D\n\r\n\x05\x04\x17\x02\r\x04\x12\x04\xff\x03\x08\x10\n\
    \r\n\x05\x04\x17\x02\r\x05\x12\x04\xff\x03\x11\x16\n\r\n\x05\x04\x17\x02\
    \r\x01\x12\x04\xff\x03\x17>\n\r\n\x05\x04\x17\x02\r\x03\x12\x04\xff\x03A\
    C\n\x0c\n\x04\x04\x17\x02\x0e\x12\x04\x80\x04\x08.\n\r\n\x05\x04\x17\x02\
    \x0e\x04\x12\x04\x80\x04\x08\x10\n\r\n\x05\x04\x17\x02\x0e\x05\x12\x04\
    \x80\x04\x11\x16\n\r\n\x05\x04\x17\x02\x0e\x01\x12\x04\x80\x04\x17(\n\r\
    \n\x05\x04\x17\x02\x0e\x03\x12\x04\x80\x04+-\n\x0c\n\x04\x04\x17\x02\x0f\
    \x12\x04\x81\x04\x08*\n\r\n\x05\x04\x17\x02\x0f\x04\x12\x04\x81\x04\x08\
    \x10\n\r\n\x05\x04\x17\x02\x0f\x05\x12\x04\x81\x04\x11\x16\n\r\n\x05\x04\
    \x17\x02\x0f\x01\x12\x04\x81\x04\x17$\n\r\n\x05\x04\x17\x02\x0f\x03\x12\
    \x04\x81\x04')\n\x0c\n\x04\x04\x17\x02\x10\x12\x04\x82\x04\x086\n\r\n\
    \x05\x04\x17\x02\x10\x04\x12\x04\x82\x04\x08\x10\n\r\n\x05\x04\x17\x02\
    \x10\x05\x12\x04\x82\x04\x11\x16\n\r\n\x05\x04\x17\x02\x10\x01\x12\x04\
    \x82\x04\x170\n\r\n\x05\x04\x17\x02\x10\x03\x12\x04\x82\x0435\n\x0c\n\
    \x04\x04\x17\x02\x11\x12\x04\x83\x04\x082\n\r\n\x05\x04\x17\x02\x11\x04\
    \x12\x04\x83\x04\x08\x10\n\r\n\x05\x04\x17\x02\x11\x05\x12\x04\x83\x04\
    \x11\x16\n\r\n\x05\x04\x17\x02\x11\x01\x12\x04\x83\x04\x17,\n\r\n\x05\
    \x04\x17\x02\x11\x03\x12\x04\x83\x04/1\n\x0c\n\x04\x04\x17\x02\x12\x12\
    \x04\x84\x04\x08.\n\r\n\x05\x04\x17\x02\x12\x04\x12\x04\x84\x04\x08\x10\
    \n\r\n\x05\x04\x17\x02\x12\x05\x12\x04\x84\x04\x11\x16\n\r\n\x05\x04\x17\
    \x02\x12\x01\x12\x04\x84\x04\x17(\n\r\n\x05\x04\x17\x02\x12\x03\x12\x04\
    \x84\x04+-\n\x0c\n\x04\x04\x17\x02\x13\x12\x04\x85\x04\x08*\n\r\n\x05\
    \x04\x17\x02\x13\x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04\x17\x02\x13\
    \x05\x12\x04\x85\x04\x11\x16\n\r\n\x05\x04\x17\x02\x13\x01\x12\x04\x85\
    \x04\x17$\n\r\n\x05\x04\x17\x02\x13\x03\x12\x04\x85\x04')\n\x0c\n\x04\
    \x04\x17\x02\x14\x12\x04\x86\x04\x08:\n\r\n\x05\x04\x17\x02\x14\x04\x12\
    \x04\x86\x04\x08\x10\n\r\n\x05\x04\x17\x02\x14\x05\x12\x04\x86\x04\x11\
    \x16\n\r\n\x05\x04\x17\x02\x14\x01\x12\x04\x86\x04\x174\n\r\n\x05\x04\
    \x17\x02\x14\x03\x12\x04\x86\x0479\n\x0c\n\x04\x04\x17\x02\x15\x12\x04\
    \x87\x04\x086\n\r\n\x05\x04\x17\x02\x15\x04\x12\x04\x87\x04\x08\x10\n\r\
    \n\x05\x04\x17\x02\x15\x05\x12\x04\x87\x04\x11\x16\n\r\n\x05\x04\x17\x02\
    \x15\x01\x12\x04\x87\x04\x170\n\r\n\x05\x04\x17\x02\x15\x03\x12\x04\x87\
    \x0435\n\x0c\n\x02\x04\x18\x12\x06\x8a\x04\0\x8d\x04\x01\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\x8a\x04\x08#\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x8b\x04\
    \x08&\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\x8b\x04\x08\x10\n\r\n\x05\x04\
    \x18\x02\0\x05\x12\x04\x8b\x04\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\
    \x04\x8b\x04\x18!\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x8b\x04$%\n\x0c\n\
    \x04\x04\x18\x02\x01\x12\x04\x8c\x04\x08+\n\r\n\x05\x04\x18\x02\x01\x04\
    \x12\x04\x8c\x04\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\x8c\x04\
    \x11\x17\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\x8c\x04\x18&\n\r\n\x05\
    \x04\x18\x02\x01\x03\x12\x04\x8c\x04)*\n\x0c\n\x02\x04\x19\x12\x06\x8f\
    \x04\0\xcc\x04\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\x8f\x04\x08$\n\x0e\n\
    \x04\x04\x19\x03\0\x12\x06\x90\x04\x08\xc1\x04\t\n\r\n\x05\x04\x19\x03\0\
    \x01\x12\x04\x90\x04\x10\x14\n\x10\n\x06\x04\x19\x03\0\x03\0\x12\x06\x91\
    \x04\x10\xb9\x04\x11\n\x0f\n\x07\x04\x19\x03\0\x03\0\x01\x12\x04\x91\x04\
    \x18\x1e\n\x12\n\x08\x04\x19\x03\0\x03\0\x03\0\x12\x06\x92\x04\x18\x95\
    \x04\x19\n\x11\n\t\x04\x19\x03\0\x03\0\x03\0\x01\x12\x04\x92\x04\x20+\n\
    \x12\n\n\x04\x19\x03\0\x03\0\x03\0\x02\0\x12\x04\x93\x04\x20>\n\x13\n\
    \x0b\x04\x19\x03\0\x03\0\x03\0\x02\0\x04\x12\x04\x93\x04\x20(\n\x13\n\
    \x0b\x04\x19\x03\0\x03\0\x03\0\x02\0\x05\x12\x04\x93\x04).\n\x13\n\x0b\
    \x04\x19\x03\0\x03\0\x03\0\x02\0\x01\x12\x04\x93\x04/9\n\x13\n\x0b\x04\
    \x19\x03\0\x03\0\x03\0\x02\0\x03\x12\x04\x93\x04<=\n\x12\n\n\x04\x19\x03\
    \0\x03\0\x03\0\x02\x01\x12\x04\x94\x04\x20B\n\x13\n\x0b\x04\x19\x03\0\
    \x03\0\x03\0\x02\x01\x04\x12\x04\x94\x04\x20(\n\x13\n\x0b\x04\x19\x03\0\
    \x03\0\x03\0\x02\x01\x05\x12\x04\x94\x04)/\n\x13\n\x0b\x04\x19\x03\0\x03\
    \0\x03\0\x02\x01\x01\x12\x04\x94\x040=\n\x13\n\x0b\x04\x19\x03\0\x03\0\
    \x03\0\x02\x01\x03\x12\x04\x94\x04@A\n\x12\n\x08\x04\x19\x03\0\x03\0\x04\
    \0\x12\x06\x97\x04\x18\x9c\x04\x19\n\x11\n\t\x04\x19\x03\0\x03\0\x04\0\
    \x01\x12\x04\x97\x04\x1d.\n\x12\n\n\x04\x19\x03\0\x03\0\x04\0\x02\0\x12\
    \x04\x98\x04\x20C\n\x13\n\x0b\x04\x19\x03\0\x03\0\x04\0\x02\0\x01\x12\
    \x04\x98\x04\x20>\n\x13\n\x0b\x04\x19\x03\0\x03\0\x04\0\x02\0\x02\x12\
    \x04\x98\x04AB\n\x12\n\n\x04\x19\x03\0\x03\0\x04\0\x02\x01\x12\x04\x99\
    \x04\x20A\n\x13\n\x0b\x04\x19\x03\0\x03\0\x04\0\x02\x01\x01\x12\x04\x99\
    \x04\x20<\n\x13\n\x0b\x04\x19\x03\0\x03\0\x04\0\x02\x01\x02\x12\x04\x99\
    \x04?@\n\x12\n\n\x04\x19\x03\0\x03\0\x04\0\x02\x02\x12\x04\x9a\x04\x20B\
    \n\x13\n\x0b\x04\x19\x03\0\x03\0\x04\0\x02\x02\x01\x12\x04\x9a\x04\x20=\
    \n\x13\n\x0b\x04\x19\x03\0\x03\0\x04\0\x02\x02\x02\x12\x04\x9a\x04@A\n\
    \x12\n\n\x04\x19\x03\0\x03\0\x04\0\x02\x03\x12\x04\x9b\x04\x20>\n\x13\n\
    \x0b\x04\x19\x03\0\x03\0\x04\0\x02\x03\x01\x12\x04\x9b\x04\x209\n\x13\n\
    \x0b\x04\x19\x03\0\x03\0\x04\0\x02\x03\x02\x12\x04\x9b\x04<=\n\x10\n\x08\
    \x04\x19\x03\0\x03\0\x02\0\x12\x04\x9e\x04\x188\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\0\x04\x12\x04\x9e\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\0\x05\x12\x04\x9e\x04!'\n\x11\n\t\x04\x19\x03\0\x03\0\x02\0\x01\x12\
    \x04\x9e\x04(3\n\x11\n\t\x04\x19\x03\0\x03\0\x02\0\x03\x12\x04\x9e\x0467\
    \n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x01\x12\x04\x9f\x04\x188\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x01\x04\x12\x04\x9f\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x01\x05\x12\x04\x9f\x04!'\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x01\x01\x12\x04\x9f\x04(3\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x01\x03\x12\x04\x9f\x0467\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x02\x12\
    \x04\xa0\x04\x186\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x02\x04\x12\x04\xa0\
    \x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x02\x05\x12\x04\xa0\x04!'\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x02\x01\x12\x04\xa0\x04(1\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x02\x03\x12\x04\xa0\x0445\n\x10\n\x08\x04\x19\
    \x03\0\x03\0\x02\x03\x12\x04\xa1\x04\x184\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\x03\x04\x12\x04\xa1\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x03\x05\x12\x04\xa1\x04!'\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x03\x01\x12\
    \x04\xa1\x04(/\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x03\x03\x12\x04\xa1\x04\
    23\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x04\x12\x04\xa2\x04\x182\n\x11\n\
    \t\x04\x19\x03\0\x03\0\x02\x04\x04\x12\x04\xa2\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x04\x05\x12\x04\xa2\x04!'\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x04\x01\x12\x04\xa2\x04(-\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x04\x03\x12\x04\xa2\x0401\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x05\x12\
    \x04\xa3\x04\x183\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x05\x04\x12\x04\xa3\
    \x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x05\x05\x12\x04\xa3\x04!'\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x05\x01\x12\x04\xa3\x04(.\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x05\x03\x12\x04\xa3\x0412\n\x10\n\x08\x04\x19\
    \x03\0\x03\0\x02\x06\x12\x04\xa4\x04\x184\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\x06\x04\x12\x04\xa4\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x06\x05\x12\x04\xa4\x04!'\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x06\x01\x12\
    \x04\xa4\x04(/\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x06\x03\x12\x04\xa4\x04\
    23\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x07\x12\x04\xa5\x04\x186\n\x11\n\
    \t\x04\x19\x03\0\x03\0\x02\x07\x04\x12\x04\xa5\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x07\x05\x12\x04\xa5\x04!'\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x07\x01\x12\x04\xa5\x04(1\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x07\x03\x12\x04\xa5\x0445\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x08\x12\
    \x04\xa6\x04\x183\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x08\x04\x12\x04\xa6\
    \x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x08\x05\x12\x04\xa6\x04!'\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x08\x01\x12\x04\xa6\x04(.\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x08\x03\x12\x04\xa6\x0412\n\x10\n\x08\x04\x19\
    \x03\0\x03\0\x02\t\x12\x04\xa7\x04\x182\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\t\x04\x12\x04\xa7\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\t\
    \x05\x12\x04\xa7\x04!'\n\x11\n\t\x04\x19\x03\0\x03\0\x02\t\x01\x12\x04\
    \xa7\x04(,\n\x11\n\t\x04\x19\x03\0\x03\0\x02\t\x03\x12\x04\xa7\x04/1\n\
    \x10\n\x08\x04\x19\x03\0\x03\0\x02\n\x12\x04\xa8\x04\x183\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\n\x04\x12\x04\xa8\x04\x18\x20\n\x11\n\t\x04\x19\x03\
    \0\x03\0\x02\n\x05\x12\x04\xa8\x04!'\n\x11\n\t\x04\x19\x03\0\x03\0\x02\n\
    \x01\x12\x04\xa8\x04(-\n\x11\n\t\x04\x19\x03\0\x03\0\x02\n\x03\x12\x04\
    \xa8\x0402\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x0b\x12\x04\xa9\x04\x189\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x0b\x04\x12\x04\xa9\x04\x18\x20\n\x11\
    \n\t\x04\x19\x03\0\x03\0\x02\x0b\x05\x12\x04\xa9\x04!&\n\x11\n\t\x04\x19\
    \x03\0\x03\0\x02\x0b\x01\x12\x04\xa9\x04'3\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\x0b\x03\x12\x04\xa9\x0468\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x0c\
    \x12\x04\xaa\x04\x187\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x0c\x04\x12\x04\
    \xaa\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x0c\x05\x12\x04\xaa\
    \x04!&\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x0c\x01\x12\x04\xaa\x04'1\n\x11\
    \n\t\x04\x19\x03\0\x03\0\x02\x0c\x03\x12\x04\xaa\x0446\n\x10\n\x08\x04\
    \x19\x03\0\x03\0\x02\r\x12\x04\xab\x04\x18p\n\x11\n\t\x04\x19\x03\0\x03\
    \0\x02\r\x04\x12\x04\xab\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\r\
    \x06\x12\x04\xab\x04![\n\x11\n\t\x04\x19\x03\0\x03\0\x02\r\x01\x12\x04\
    \xab\x04\\j\n\x11\n\t\x04\x19\x03\0\x03\0\x02\r\x03\x12\x04\xab\x04mo\n\
    \x10\n\x08\x04\x19\x03\0\x03\0\x02\x0e\x12\x04\xac\x04\x18>\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x0e\x04\x12\x04\xac\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x0e\x05\x12\x04\xac\x04!&\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x0e\x01\x12\x04\xac\x04'8\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x0e\x03\x12\x04\xac\x04;=\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x0f\x12\
    \x04\xad\x04\x182\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x0f\x04\x12\x04\xad\
    \x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x0f\x05\x12\x04\xad\x04!&\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x0f\x01\x12\x04\xad\x04',\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x0f\x03\x12\x04\xad\x04/1\n\x10\n\x08\x04\x19\
    \x03\0\x03\0\x02\x10\x12\x04\xae\x04\x182\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\x10\x04\x12\x04\xae\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x10\x05\x12\x04\xae\x04!&\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x10\x01\x12\
    \x04\xae\x04',\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x10\x03\x12\x04\xae\x04\
    /1\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x11\x12\x04\xaf\x04\x182\n\x11\n\
    \t\x04\x19\x03\0\x03\0\x02\x11\x04\x12\x04\xaf\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x11\x05\x12\x04\xaf\x04!&\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x11\x01\x12\x04\xaf\x04',\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x11\x03\x12\x04\xaf\x04/1\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x12\x12\
    \x04\xb0\x04\x182\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x12\x04\x12\x04\xb0\
    \x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x12\x05\x12\x04\xb0\x04!&\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x12\x01\x12\x04\xb0\x04',\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x12\x03\x12\x04\xb0\x04/1\n\x10\n\x08\x04\x19\
    \x03\0\x03\0\x02\x13\x12\x04\xb1\x04\x182\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\x13\x04\x12\x04\xb1\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x13\x05\x12\x04\xb1\x04!&\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x13\x01\x12\
    \x04\xb1\x04',\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x13\x03\x12\x04\xb1\x04\
    /1\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x14\x12\x04\xb2\x04\x182\n\x11\n\
    \t\x04\x19\x03\0\x03\0\x02\x14\x04\x12\x04\xb2\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x14\x05\x12\x04\xb2\x04!&\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x14\x01\x12\x04\xb2\x04',\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x14\x03\x12\x04\xb2\x04/1\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x15\x12\
    \x04\xb3\x04\x18;\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x15\x04\x12\x04\xb3\
    \x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x15\x05\x12\x04\xb3\x04!'\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x15\x01\x12\x04\xb3\x04(5\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x15\x03\x12\x04\xb3\x048:\n\x10\n\x08\x04\x19\
    \x03\0\x03\0\x02\x16\x12\x04\xb4\x04\x188\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\x16\x04\x12\x04\xb4\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x16\x05\x12\x04\xb4\x04!'\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x16\x01\x12\
    \x04\xb4\x04(2\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x16\x03\x12\x04\xb4\x04\
    57\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x17\x12\x04\xb5\x04\x187\n\x11\n\
    \t\x04\x19\x03\0\x03\0\x02\x17\x04\x12\x04\xb5\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x17\x05\x12\x04\xb5\x04!&\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x17\x01\x12\x04\xb5\x04'1\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x17\x03\x12\x04\xb5\x0446\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x18\x12\
    \x04\xb6\x04\x187\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x18\x04\x12\x04\xb6\
    \x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x18\x05\x12\x04\xb6\x04!&\
    \n\x11\n\t\x04\x19\x03\0\x03\0\x02\x18\x01\x12\x04\xb6\x04'1\n\x11\n\t\
    \x04\x19\x03\0\x03\0\x02\x18\x03\x12\x04\xb6\x0446\n\x10\n\x08\x04\x19\
    \x03\0\x03\0\x02\x19\x12\x04\xb7\x04\x187\n\x11\n\t\x04\x19\x03\0\x03\0\
    \x02\x19\x04\x12\x04\xb7\x04\x18\x20\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x19\x05\x12\x04\xb7\x04!'\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x19\x01\x12\
    \x04\xb7\x04(1\n\x11\n\t\x04\x19\x03\0\x03\0\x02\x19\x03\x12\x04\xb7\x04\
    46\n\x10\n\x08\x04\x19\x03\0\x03\0\x02\x1a\x12\x04\xb8\x04\x18e\n\x11\n\
    \t\x04\x19\x03\0\x03\0\x02\x1a\x04\x12\x04\xb8\x04\x18\x20\n\x11\n\t\x04\
    \x19\x03\0\x03\0\x02\x1a\x06\x12\x04\xb8\x04!U\n\x11\n\t\x04\x19\x03\0\
    \x03\0\x02\x1a\x01\x12\x04\xb8\x04V_\n\x11\n\t\x04\x19\x03\0\x03\0\x02\
    \x1a\x03\x12\x04\xb8\x04bd\n\x0e\n\x06\x04\x19\x03\0\x02\0\x12\x04\xbb\
    \x04\x10N\n\x0f\n\x07\x04\x19\x03\0\x02\0\x04\x12\x04\xbb\x04\x10\x18\n\
    \x0f\n\x07\x04\x19\x03\0\x02\0\x06\x12\x04\xbb\x04\x19A\n\x0f\n\x07\x04\
    \x19\x03\0\x02\0\x01\x12\x04\xbb\x04BI\n\x0f\n\x07\x04\x19\x03\0\x02\0\
    \x03\x12\x04\xbb\x04LM\n\x0e\n\x06\x04\x19\x03\0\x02\x01\x12\x04\xbc\x04\
    \x10*\n\x0f\n\x07\x04\x19\x03\0\x02\x01\x04\x12\x04\xbc\x04\x10\x18\n\
    \x0f\n\x07\x04\x19\x03\0\x02\x01\x05\x12\x04\xbc\x04\x19\x1f\n\x0f\n\x07\
    \x04\x19\x03\0\x02\x01\x01\x12\x04\xbc\x04\x20%\n\x0f\n\x07\x04\x19\x03\
    \0\x02\x01\x03\x12\x04\xbc\x04()\n\x0e\n\x06\x04\x19\x03\0\x02\x02\x12\
    \x04\xbd\x04\x100\n\x0f\n\x07\x04\x19\x03\0\x02\x02\x04\x12\x04\xbd\x04\
    \x10\x18\n\x0f\n\x07\x04\x19\x03\0\x02\x02\x05\x12\x04\xbd\x04\x19\x1f\n\
    \x0f\n\x07\x04\x19\x03\0\x02\x02\x01\x12\x04\xbd\x04\x20+\n\x0f\n\x07\
    \x04\x19\x03\0\x02\x02\x03\x12\x04\xbd\x04./\n\x0e\n\x06\x04\x19\x03\0\
    \x02\x03\x12\x04\xbe\x04\x103\n\x0f\n\x07\x04\x19\x03\0\x02\x03\x04\x12\
    \x04\xbe\x04\x10\x18\n\x0f\n\x07\x04\x19\x03\0\x02\x03\x05\x12\x04\xbe\
    \x04\x19\x1f\n\x0f\n\x07\x04\x19\x03\0\x02\x03\x01\x12\x04\xbe\x04\x20.\
    \n\x0f\n\x07\x04\x19\x03\0\x02\x03\x03\x12\x04\xbe\x0412\n\x0e\n\x06\x04\
    \x19\x03\0\x02\x04\x12\x04\xbf\x04\x10/\n\x0f\n\x07\x04\x19\x03\0\x02\
    \x04\x04\x12\x04\xbf\x04\x10\x18\n\x0f\n\x07\x04\x19\x03\0\x02\x04\x05\
    \x12\x04\xbf\x04\x19\x1f\n\x0f\n\x07\x04\x19\x03\0\x02\x04\x01\x12\x04\
    \xbf\x04\x20*\n\x0f\n\x07\x04\x19\x03\0\x02\x04\x03\x12\x04\xbf\x04-.\n\
    \x0e\n\x06\x04\x19\x03\0\x02\x05\x12\x04\xc0\x04\x10.\n\x0f\n\x07\x04\
    \x19\x03\0\x02\x05\x04\x12\x04\xc0\x04\x10\x18\n\x0f\n\x07\x04\x19\x03\0\
    \x02\x05\x05\x12\x04\xc0\x04\x19\x1f\n\x0f\n\x07\x04\x19\x03\0\x02\x05\
    \x01\x12\x04\xc0\x04\x20)\n\x0f\n\x07\x04\x19\x03\0\x02\x05\x03\x12\x04\
    \xc0\x04,-\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xc3\x04\x08*\n\r\n\x05\x04\
    \x19\x02\0\x04\x12\x04\xc3\x04\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\
    \x04\xc3\x04\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xc3\x04\x18%\n\
    \r\n\x05\x04\x19\x02\0\x03\x12\x04\xc3\x04()\n\x0c\n\x04\x04\x19\x02\x01\
    \x12\x04\xc4\x04\x08/\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xc4\x04\x08\
    \x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xc4\x04\x11\x17\n\r\n\x05\x04\
    \x19\x02\x01\x01\x12\x04\xc4\x04\x18*\n\r\n\x05\x04\x19\x02\x01\x03\x12\
    \x04\xc4\x04-.\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xc5\x04\x08$\n\r\n\
    \x05\x04\x19\x02\x02\x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\x04\x19\x02\
    \x02\x05\x12\x04\xc5\x04\x11\x16\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\
    \xc5\x04\x17\x1f\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xc5\x04\"#\n\x0c\
    \n\x04\x04\x19\x02\x03\x12\x04\xc6\x04\x08&\n\r\n\x05\x04\x19\x02\x03\
    \x04\x12\x04\xc6\x04\x08\x10\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xc6\
    \x04\x11\x16\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xc6\x04\x17!\n\r\n\
    \x05\x04\x19\x02\x03\x03\x12\x04\xc6\x04$%\n\x0c\n\x04\x04\x19\x02\x04\
    \x12\x04\xc7\x04\x08A\n\r\n\x05\x04\x19\x02\x04\x04\x12\x04\xc7\x04\x08\
    \x10\n\r\n\x05\x04\x19\x02\x04\x06\x12\x04\xc7\x04\x112\n\r\n\x05\x04\
    \x19\x02\x04\x01\x12\x04\xc7\x043<\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\
    \xc7\x04?@\n\x0c\n\x04\x04\x19\x02\x05\x12\x04\xc8\x04\x08@\n\r\n\x05\
    \x04\x19\x02\x05\x04\x12\x04\xc8\x04\x08\x10\n\r\n\x05\x04\x19\x02\x05\
    \x06\x12\x04\xc8\x04\x112\n\r\n\x05\x04\x19\x02\x05\x01\x12\x04\xc8\x043\
    ;\n\r\n\x05\x04\x19\x02\x05\x03\x12\x04\xc8\x04>?\n\x0c\n\x04\x04\x19\
    \x02\x06\x12\x04\xc9\x04\x081\n\r\n\x05\x04\x19\x02\x06\x04\x12\x04\xc9\
    \x04\x08\x10\n\r\n\x05\x04\x19\x02\x06\x05\x12\x04\xc9\x04\x11\x17\n\r\n\
    \x05\x04\x19\x02\x06\x01\x12\x04\xc9\x04\x18,\n\r\n\x05\x04\x19\x02\x06\
    \x03\x12\x04\xc9\x04/0\n\x0c\n\x04\x04\x19\x02\x07\x12\x04\xca\x04\x08&\
    \n\r\n\x05\x04\x19\x02\x07\x04\x12\x04\xca\x04\x08\x10\n\r\n\x05\x04\x19\
    \x02\x07\x05\x12\x04\xca\x04\x11\x17\n\r\n\x05\x04\x19\x02\x07\x01\x12\
    \x04\xca\x04\x18!\n\r\n\x05\x04\x19\x02\x07\x03\x12\x04\xca\x04$%\n\x0c\
    \n\x04\x04\x19\x02\x08\x12\x04\xcb\x04\x08%\n\r\n\x05\x04\x19\x02\x08\
    \x04\x12\x04\xcb\x04\x08\x10\n\r\n\x05\x04\x19\x02\x08\x05\x12\x04\xcb\
    \x04\x11\x17\n\r\n\x05\x04\x19\x02\x08\x01\x12\x04\xcb\x04\x18\x20\n\r\n\
    \x05\x04\x19\x02\x08\x03\x12\x04\xcb\x04#$\n\x0c\n\x02\x04\x1a\x12\x06\
    \xce\x04\0\xd1\x04\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xce\x04\x081\n\
    \x0c\n\x04\x04\x1a\x02\0\x12\x04\xcf\x04\x08(\n\r\n\x05\x04\x1a\x02\0\
    \x04\x12\x04\xcf\x04\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xcf\x04\
    \x11\x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xcf\x04\x18#\n\r\n\x05\x04\
    \x1a\x02\0\x03\x12\x04\xcf\x04&'\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd0\
    \x04\x08'\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xd0\x04\x08\x10\n\r\n\
    \x05\x04\x1a\x02\x01\x05\x12\x04\xd0\x04\x11\x17\n\r\n\x05\x04\x1a\x02\
    \x01\x01\x12\x04\xd0\x04\x18\"\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xd0\
    \x04%&\n\x0c\n\x02\x04\x1b\x12\x06\xd3\x04\0\xe0\x04\x01\n\x0b\n\x03\x04\
    \x1b\x01\x12\x04\xd3\x04\x089\n\x0e\n\x04\x04\x1b\x03\0\x12\x06\xd4\x04\
    \x08\xdd\x04\t\n\r\n\x05\x04\x1b\x03\0\x01\x12\x04\xd4\x04\x10\x16\n\x0e\
    \n\x06\x04\x1b\x03\0\x02\0\x12\x04\xd5\x04\x10/\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\0\x04\x12\x04\xd5\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x05\
    \x12\x04\xd5\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x01\x12\x04\xd5\
    \x04\x20*\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x03\x12\x04\xd5\x04-.\n\x0e\n\
    \x06\x04\x1b\x03\0\x02\x01\x12\x04\xd6\x04\x104\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\x01\x04\x12\x04\xd6\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\
    \x05\x12\x04\xd6\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x01\x12\
    \x04\xd6\x04\x1e/\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x03\x12\x04\xd6\x042\
    3\n\x0e\n\x06\x04\x1b\x03\0\x02\x02\x12\x04\xd7\x04\x105\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x02\x04\x12\x04\xd7\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x02\x05\x12\x04\xd7\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\
    \x01\x12\x04\xd7\x04\x1e0\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x03\x12\x04\
    \xd7\x0434\n\x0e\n\x06\x04\x1b\x03\0\x02\x03\x12\x04\xd8\x04\x10)\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\x03\x04\x12\x04\xd8\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x03\x05\x12\x04\xd8\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x03\x01\x12\x04\xd8\x04\x20$\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x03\
    \x12\x04\xd8\x04'(\n\x0e\n\x06\x04\x1b\x03\0\x02\x04\x12\x04\xd9\x04\x10\
    2\n\x0f\n\x07\x04\x1b\x03\0\x02\x04\x04\x12\x04\xd9\x04\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\x04\x05\x12\x04\xd9\x04\x19\x1d\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x04\x01\x12\x04\xd9\x04\x1e-\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x04\x03\x12\x04\xd9\x0401\n\x0e\n\x06\x04\x1b\x03\0\x02\x05\x12\x04\
    \xda\x04\x10/\n\x0f\n\x07\x04\x1b\x03\0\x02\x05\x04\x12\x04\xda\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x05\x05\x12\x04\xda\x04\x19\x1d\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\x05\x01\x12\x04\xda\x04\x1e*\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x05\x03\x12\x04\xda\x04-.\n\x0e\n\x06\x04\x1b\x03\0\x02\
    \x06\x12\x04\xdb\x04\x100\n\x0f\n\x07\x04\x1b\x03\0\x02\x06\x04\x12\x04\
    \xdb\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x06\x05\x12\x04\xdb\x04\
    \x19\x1d\n\x0f\n\x07\x04\x1b\x03\0\x02\x06\x01\x12\x04\xdb\x04\x1e+\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\x06\x03\x12\x04\xdb\x04./\n\x0e\n\x06\x04\
    \x1b\x03\0\x02\x07\x12\x04\xdc\x04\x102\n\x0f\n\x07\x04\x1b\x03\0\x02\
    \x07\x04\x12\x04\xdc\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x07\x05\
    \x12\x04\xdc\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\0\x02\x07\x01\x12\x04\
    \xdc\x04\x1e-\n\x0f\n\x07\x04\x1b\x03\0\x02\x07\x03\x12\x04\xdc\x0401\n\
    \x0c\n\x04\x04\x1b\x02\0\x12\x04\xdf\x04\x08V\n\r\n\x05\x04\x1b\x02\0\
    \x04\x12\x04\xdf\x04\x08\x10\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xdf\x04\
    \x11I\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xdf\x04JQ\n\r\n\x05\x04\x1b\
    \x02\0\x03\x12\x04\xdf\x04TU\n\x0c\n\x02\x04\x1c\x12\x06\xe2\x04\0\xe5\
    \x04\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xe2\x04\x08%\n\x0c\n\x04\x04\
    \x1c\x02\0\x12\x04\xe3\x04\x08,\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xe3\
    \x04\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xe3\x04\x11\x18\n\r\n\
    \x05\x04\x1c\x02\0\x01\x12\x04\xe3\x04\x19'\n\r\n\x05\x04\x1c\x02\0\x03\
    \x12\x04\xe3\x04*+\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xe4\x04\x08/\n\r\
    \n\x05\x04\x1c\x02\x01\x04\x12\x04\xe4\x04\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x01\x05\x12\x04\xe4\x04\x11\x18\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\
    \xe4\x04\x19*\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xe4\x04-.\n\x0c\n\
    \x02\x04\x1d\x12\x06\xe7\x04\0\xef\x04\x01\n\x0b\n\x03\x04\x1d\x01\x12\
    \x04\xe7\x04\x08\x1c\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xe8\x04\x082\n\r\
    \n\x05\x04\x1d\x02\0\x04\x12\x04\xe8\x04\x08\x10\n\r\n\x05\x04\x1d\x02\0\
    \x05\x12\x04\xe8\x04\x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xe8\x04\
    \x18-\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xe8\x0401\n\x0c\n\x04\x04\x1d\
    \x02\x01\x12\x04\xe9\x04\x083\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xe9\
    \x04\x08\x10\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xe9\x04\x11\x17\n\r\n\
    \x05\x04\x1d\x02\x01\x01\x12\x04\xe9\x04\x18.\n\r\n\x05\x04\x1d\x02\x01\
    \x03\x12\x04\xe9\x0412\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xea\x04\x08+\
    \n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\xea\x04\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x02\x05\x12\x04\xea\x04\x11\x17\n\r\n\x05\x04\x1d\x02\x02\x01\x12\
    \x04\xea\x04\x18&\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xea\x04)*\n\x0c\
    \n\x04\x04\x1d\x02\x03\x12\x04\xeb\x04\x081\n\r\n\x05\x04\x1d\x02\x03\
    \x04\x12\x04\xeb\x04\x08\x10\n\r\n\x05\x04\x1d\x02\x03\x05\x12\x04\xeb\
    \x04\x11\x17\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xeb\x04\x18,\n\r\n\
    \x05\x04\x1d\x02\x03\x03\x12\x04\xeb\x04/0\n\x0c\n\x04\x04\x1d\x02\x04\
    \x12\x04\xec\x04\x08)\n\r\n\x05\x04\x1d\x02\x04\x04\x12\x04\xec\x04\x08\
    \x10\n\r\n\x05\x04\x1d\x02\x04\x05\x12\x04\xec\x04\x11\x17\n\r\n\x05\x04\
    \x1d\x02\x04\x01\x12\x04\xec\x04\x18$\n\r\n\x05\x04\x1d\x02\x04\x03\x12\
    \x04\xec\x04'(\n\x0c\n\x04\x04\x1d\x02\x05\x12\x04\xed\x04\x083\n\r\n\
    \x05\x04\x1d\x02\x05\x04\x12\x04\xed\x04\x08\x10\n\r\n\x05\x04\x1d\x02\
    \x05\x05\x12\x04\xed\x04\x11\x18\n\r\n\x05\x04\x1d\x02\x05\x01\x12\x04\
    \xed\x04\x19.\n\r\n\x05\x04\x1d\x02\x05\x03\x12\x04\xed\x0412\n\x0c\n\
    \x04\x04\x1d\x02\x06\x12\x04\xee\x04\x08/\n\r\n\x05\x04\x1d\x02\x06\x04\
    \x12\x04\xee\x04\x08\x10\n\r\n\x05\x04\x1d\x02\x06\x05\x12\x04\xee\x04\
    \x11\x18\n\r\n\x05\x04\x1d\x02\x06\x01\x12\x04\xee\x04\x19*\n\r\n\x05\
    \x04\x1d\x02\x06\x03\x12\x04\xee\x04-.\n\x0c\n\x02\x04\x1e\x12\x06\xf1\
    \x04\0\xf3\x04\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xf1\x04\x08'\n\x0c\n\
    \x04\x04\x1e\x02\0\x12\x04\xf2\x04\x08+\n\r\n\x05\x04\x1e\x02\0\x04\x12\
    \x04\xf2\x04\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xf2\x04\x11\x18\
    \n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xf2\x04\x19&\n\r\n\x05\x04\x1e\x02\
    \0\x03\x12\x04\xf2\x04)*\n\x0c\n\x02\x04\x1f\x12\x06\xf5\x04\0\xf7\x04\
    \x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xf5\x04\x08\x1e\n\x0c\n\x04\x04\x1f\
    \x02\0\x12\x04\xf6\x04\x08'\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\xf6\x04\
    \x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xf6\x04\x11\x17\n\r\n\x05\
    \x04\x1f\x02\0\x01\x12\x04\xf6\x04\x18\"\n\r\n\x05\x04\x1f\x02\0\x03\x12\
    \x04\xf6\x04%&\n\x0c\n\x02\x04\x20\x12\x06\xf9\x04\0\xfe\x04\x01\n\x0b\n\
    \x03\x04\x20\x01\x12\x04\xf9\x04\x08\x1f\n\x0c\n\x04\x04\x20\x02\0\x12\
    \x04\xfa\x04\x08#\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xfa\x04\x08\x10\n\
    \r\n\x05\x04\x20\x02\0\x05\x12\x04\xfa\x04\x11\x17\n\r\n\x05\x04\x20\x02\
    \0\x01\x12\x04\xfa\x04\x18\x1e\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xfa\
    \x04!\"\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xfb\x04\x08'\n\r\n\x05\x04\
    \x20\x02\x01\x04\x12\x04\xfb\x04\x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\
    \x12\x04\xfb\x04\x11\x15\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xfb\x04\
    \x16\"\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xfb\x04%&\n\x0c\n\x04\x04\
    \x20\x02\x02\x12\x04\xfc\x04\x08+\n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\
    \xfc\x04\x08\x10\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\xfc\x04\x11\x15\n\
    \r\n\x05\x04\x20\x02\x02\x01\x12\x04\xfc\x04\x16&\n\r\n\x05\x04\x20\x02\
    \x02\x03\x12\x04\xfc\x04)*\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\xfd\x04\
    \x08,\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\xfd\x04\x08\x10\n\r\n\x05\
    \x04\x20\x02\x03\x05\x12\x04\xfd\x04\x11\x15\n\r\n\x05\x04\x20\x02\x03\
    \x01\x12\x04\xfd\x04\x16'\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\xfd\x04*\
    +\n\x0c\n\x02\x04!\x12\x06\x80\x05\0\x8d\x05\x01\n\x0b\n\x03\x04!\x01\
    \x12\x04\x80\x05\x08\x1f\n\x0c\n\x04\x04!\x02\0\x12\x04\x81\x05\x08/\n\r\
    \n\x05\x04!\x02\0\x04\x12\x04\x81\x05\x08\x10\n\r\n\x05\x04!\x02\0\x05\
    \x12\x04\x81\x05\x11\x18\n\r\n\x05\x04!\x02\0\x01\x12\x04\x81\x05\x19*\n\
    \r\n\x05\x04!\x02\0\x03\x12\x04\x81\x05-.\n\x0c\n\x04\x04!\x02\x01\x12\
    \x04\x82\x05\x08/\n\r\n\x05\x04!\x02\x01\x04\x12\x04\x82\x05\x08\x10\n\r\
    \n\x05\x04!\x02\x01\x05\x12\x04\x82\x05\x11\x18\n\r\n\x05\x04!\x02\x01\
    \x01\x12\x04\x82\x05\x19*\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x82\x05-.\n\
    \x0c\n\x04\x04!\x02\x02\x12\x04\x83\x05\x086\n\r\n\x05\x04!\x02\x02\x04\
    \x12\x04\x83\x05\x08\x10\n\r\n\x05\x04!\x02\x02\x06\x12\x04\x83\x05\x11&\
    \n\r\n\x05\x04!\x02\x02\x01\x12\x04\x83\x05'1\n\r\n\x05\x04!\x02\x02\x03\
    \x12\x04\x83\x0545\n\x0c\n\x04\x04!\x02\x03\x12\x04\x84\x05\x08$\n\r\n\
    \x05\x04!\x02\x03\x04\x12\x04\x84\x05\x08\x10\n\r\n\x05\x04!\x02\x03\x05\
    \x12\x04\x84\x05\x11\x16\n\r\n\x05\x04!\x02\x03\x01\x12\x04\x84\x05\x17\
    \x1f\n\r\n\x05\x04!\x02\x03\x03\x12\x04\x84\x05\"#\n\x0c\n\x04\x04!\x02\
    \x04\x12\x04\x85\x05\x08%\n\r\n\x05\x04!\x02\x04\x04\x12\x04\x85\x05\x08\
    \x10\n\r\n\x05\x04!\x02\x04\x05\x12\x04\x85\x05\x11\x16\n\r\n\x05\x04!\
    \x02\x04\x01\x12\x04\x85\x05\x17\x20\n\r\n\x05\x04!\x02\x04\x03\x12\x04\
    \x85\x05#$\n\x0c\n\x04\x04!\x02\x05\x12\x04\x86\x05\x08'\n\r\n\x05\x04!\
    \x02\x05\x04\x12\x04\x86\x05\x08\x10\n\r\n\x05\x04!\x02\x05\x05\x12\x04\
    \x86\x05\x11\x16\n\r\n\x05\x04!\x02\x05\x01\x12\x04\x86\x05\x17\"\n\r\n\
    \x05\x04!\x02\x05\x03\x12\x04\x86\x05%&\n\x0c\n\x04\x04!\x02\x06\x12\x04\
    \x87\x05\x08&\n\r\n\x05\x04!\x02\x06\x04\x12\x04\x87\x05\x08\x10\n\r\n\
    \x05\x04!\x02\x06\x05\x12\x04\x87\x05\x11\x17\n\r\n\x05\x04!\x02\x06\x01\
    \x12\x04\x87\x05\x18!\n\r\n\x05\x04!\x02\x06\x03\x12\x04\x87\x05$%\n\x0c\
    \n\x04\x04!\x02\x07\x12\x04\x88\x05\x08'\n\r\n\x05\x04!\x02\x07\x04\x12\
    \x04\x88\x05\x08\x10\n\r\n\x05\x04!\x02\x07\x05\x12\x04\x88\x05\x11\x17\
    \n\r\n\x05\x04!\x02\x07\x01\x12\x04\x88\x05\x18\"\n\r\n\x05\x04!\x02\x07\
    \x03\x12\x04\x88\x05%&\n\x0c\n\x04\x04!\x02\x08\x12\x04\x89\x05\x08-\n\r\
    \n\x05\x04!\x02\x08\x04\x12\x04\x89\x05\x08\x10\n\r\n\x05\x04!\x02\x08\
    \x05\x12\x04\x89\x05\x11\x17\n\r\n\x05\x04!\x02\x08\x01\x12\x04\x89\x05\
    \x18(\n\r\n\x05\x04!\x02\x08\x03\x12\x04\x89\x05+,\n\x0c\n\x04\x04!\x02\
    \t\x12\x04\x8a\x05\x08*\n\r\n\x05\x04!\x02\t\x04\x12\x04\x8a\x05\x08\x10\
    \n\r\n\x05\x04!\x02\t\x05\x12\x04\x8a\x05\x11\x17\n\r\n\x05\x04!\x02\t\
    \x01\x12\x04\x8a\x05\x18$\n\r\n\x05\x04!\x02\t\x03\x12\x04\x8a\x05')\n\
    \x0c\n\x04\x04!\x02\n\x12\x04\x8b\x05\x08)\n\r\n\x05\x04!\x02\n\x04\x12\
    \x04\x8b\x05\x08\x10\n\r\n\x05\x04!\x02\n\x05\x12\x04\x8b\x05\x11\x17\n\
    \r\n\x05\x04!\x02\n\x01\x12\x04\x8b\x05\x18#\n\r\n\x05\x04!\x02\n\x03\
    \x12\x04\x8b\x05&(\n\x0c\n\x04\x04!\x02\x0b\x12\x04\x8c\x05\x088\n\r\n\
    \x05\x04!\x02\x0b\x04\x12\x04\x8c\x05\x08\x10\n\r\n\x05\x04!\x02\x0b\x06\
    \x12\x04\x8c\x05\x11%\n\r\n\x05\x04!\x02\x0b\x01\x12\x04\x8c\x05&2\n\r\n\
    \x05\x04!\x02\x0b\x03\x12\x04\x8c\x0557\n\x0c\n\x02\x04\"\x12\x06\x8f\
    \x05\0\x92\x05\x01\n\x0b\n\x03\x04\"\x01\x12\x04\x8f\x05\x08'\n\x0c\n\
    \x04\x04\"\x02\0\x12\x04\x90\x05\x086\n\r\n\x05\x04\"\x02\0\x04\x12\x04\
    \x90\x05\x08\x10\n\r\n\x05\x04\"\x02\0\x06\x12\x04\x90\x05\x11&\n\r\n\
    \x05\x04\"\x02\0\x01\x12\x04\x90\x05'1\n\r\n\x05\x04\"\x02\0\x03\x12\x04\
    \x90\x0545\n\x0c\n\x04\x04\"\x02\x01\x12\x04\x91\x05\x08,\n\r\n\x05\x04\
    \"\x02\x01\x04\x12\x04\x91\x05\x08\x10\n\r\n\x05\x04\"\x02\x01\x05\x12\
    \x04\x91\x05\x11\x17\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x91\x05\x18'\n\
    \r\n\x05\x04\"\x02\x01\x03\x12\x04\x91\x05*+\n\x0c\n\x02\x04#\x12\x06\
    \x94\x05\0\x96\x05\x01\n\x0b\n\x03\x04#\x01\x12\x04\x94\x05\x08\x17\n\
    \x0c\n\x04\x04#\x02\0\x12\x04\x95\x05\x08%\n\r\n\x05\x04#\x02\0\x04\x12\
    \x04\x95\x05\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\x95\x05\x11\x17\n\
    \r\n\x05\x04#\x02\0\x01\x12\x04\x95\x05\x18\x20\n\r\n\x05\x04#\x02\0\x03\
    \x12\x04\x95\x05#$\n\x0c\n\x02\x04$\x12\x06\x98\x05\0\x9b\x05\x01\n\x0b\
    \n\x03\x04$\x01\x12\x04\x98\x05\x08\x1f\n\x0c\n\x04\x04$\x02\0\x12\x04\
    \x99\x05\x08-\n\r\n\x05\x04$\x02\0\x04\x12\x04\x99\x05\x08\x10\n\r\n\x05\
    \x04$\x02\0\x05\x12\x04\x99\x05\x11\x17\n\r\n\x05\x04$\x02\0\x01\x12\x04\
    \x99\x05\x18(\n\r\n\x05\x04$\x02\0\x03\x12\x04\x99\x05+,\n\x0c\n\x04\x04\
    $\x02\x01\x12\x04\x9a\x05\x08,\n\r\n\x05\x04$\x02\x01\x04\x12\x04\x9a\
    \x05\x08\x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\x9a\x05\x11\x17\n\r\n\
    \x05\x04$\x02\x01\x01\x12\x04\x9a\x05\x18'\n\r\n\x05\x04$\x02\x01\x03\
    \x12\x04\x9a\x05*+\n\x0c\n\x02\x04%\x12\x06\x9d\x05\0\xa2\x05\x01\n\x0b\
    \n\x03\x04%\x01\x12\x04\x9d\x05\x08$\n\x0c\n\x04\x04%\x02\0\x12\x04\x9e\
    \x05\x08&\n\r\n\x05\x04%\x02\0\x04\x12\x04\x9e\x05\x08\x10\n\r\n\x05\x04\
    %\x02\0\x05\x12\x04\x9e\x05\x11\x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\x9e\
    \x05\x18!\n\r\n\x05\x04%\x02\0\x03\x12\x04\x9e\x05$%\n\x0c\n\x04\x04%\
    \x02\x01\x12\x04\x9f\x05\x08*\n\r\n\x05\x04%\x02\x01\x04\x12\x04\x9f\x05\
    \x08\x10\n\r\n\x05\x04%\x02\x01\x05\x12\x04\x9f\x05\x11\x16\n\r\n\x05\
    \x04%\x02\x01\x01\x12\x04\x9f\x05\x17%\n\r\n\x05\x04%\x02\x01\x03\x12\
    \x04\x9f\x05()\n\x0c\n\x04\x04%\x02\x02\x12\x04\xa0\x05\x08%\n\r\n\x05\
    \x04%\x02\x02\x04\x12\x04\xa0\x05\x08\x10\n\r\n\x05\x04%\x02\x02\x05\x12\
    \x04\xa0\x05\x11\x17\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xa0\x05\x18\x20\
    \n\r\n\x05\x04%\x02\x02\x03\x12\x04\xa0\x05#$\n\x0c\n\x04\x04%\x02\x03\
    \x12\x04\xa1\x05\x08-\n\r\n\x05\x04%\x02\x03\x04\x12\x04\xa1\x05\x08\x10\
    \n\r\n\x05\x04%\x02\x03\x05\x12\x04\xa1\x05\x11\x17\n\r\n\x05\x04%\x02\
    \x03\x01\x12\x04\xa1\x05\x18(\n\r\n\x05\x04%\x02\x03\x03\x12\x04\xa1\x05\
    +,\n\x0c\n\x02\x04&\x12\x06\xa4\x05\0\xad\x05\x01\n\x0b\n\x03\x04&\x01\
    \x12\x04\xa4\x05\x08$\n\x0e\n\x04\x04&\x04\0\x12\x06\xa5\x05\x08\xaa\x05\
    \t\n\r\n\x05\x04&\x04\0\x01\x12\x04\xa5\x05\r\x13\n\x0e\n\x06\x04&\x04\0\
    \x02\0\x12\x04\xa6\x05\x10#\n\x0f\n\x07\x04&\x04\0\x02\0\x01\x12\x04\xa6\
    \x05\x10\x1e\n\x0f\n\x07\x04&\x04\0\x02\0\x02\x12\x04\xa6\x05!\"\n\x0e\n\
    \x06\x04&\x04\0\x02\x01\x12\x04\xa7\x05\x10$\n\x0f\n\x07\x04&\x04\0\x02\
    \x01\x01\x12\x04\xa7\x05\x10\x1f\n\x0f\n\x07\x04&\x04\0\x02\x01\x02\x12\
    \x04\xa7\x05\"#\n\x0e\n\x06\x04&\x04\0\x02\x02\x12\x04\xa8\x05\x10\"\n\
    \x0f\n\x07\x04&\x04\0\x02\x02\x01\x12\x04\xa8\x05\x10\x1d\n\x0f\n\x07\
    \x04&\x04\0\x02\x02\x02\x12\x04\xa8\x05\x20!\n\x0e\n\x06\x04&\x04\0\x02\
    \x03\x12\x04\xa9\x05\x10\x1b\n\x0f\n\x07\x04&\x04\0\x02\x03\x01\x12\x04\
    \xa9\x05\x10\x16\n\x0f\n\x07\x04&\x04\0\x02\x03\x02\x12\x04\xa9\x05\x19\
    \x1a\n\x0c\n\x04\x04&\x02\0\x12\x04\xac\x05\x08@\n\r\n\x05\x04&\x02\0\
    \x04\x12\x04\xac\x05\x08\x10\n\r\n\x05\x04&\x02\0\x06\x12\x04\xac\x05\
    \x114\n\r\n\x05\x04&\x02\0\x01\x12\x04\xac\x055;\n\r\n\x05\x04&\x02\0\
    \x03\x12\x04\xac\x05>?\n\x0c\n\x02\x04'\x12\x06\xaf\x05\0\xb1\x05\x01\n\
    \x0b\n\x03\x04'\x01\x12\x04\xaf\x05\x08!\n\x0c\n\x04\x04'\x02\0\x12\x04\
    \xb0\x05\x08$\n\r\n\x05\x04'\x02\0\x04\x12\x04\xb0\x05\x08\x10\n\r\n\x05\
    \x04'\x02\0\x05\x12\x04\xb0\x05\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\
    \xb0\x05\x18\x1f\n\r\n\x05\x04'\x02\0\x03\x12\x04\xb0\x05\"#\n\x0c\n\x02\
    \x04(\x12\x06\xb3\x05\0\xb5\x05\x01\n\x0b\n\x03\x04(\x01\x12\x04\xb3\x05\
    \x08'\n\x0c\n\x04\x04(\x02\0\x12\x04\xb4\x05\x08*\n\r\n\x05\x04(\x02\0\
    \x04\x12\x04\xb4\x05\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xb4\x05\
    \x11\x16\n\r\n\x05\x04(\x02\0\x01\x12\x04\xb4\x05\x17%\n\r\n\x05\x04(\
    \x02\0\x03\x12\x04\xb4\x05()\n\x0c\n\x02\x04)\x12\x06\xb7\x05\0\xc6\x05\
    \x01\n\x0b\n\x03\x04)\x01\x12\x04\xb7\x05\x08\x20\n\x0e\n\x04\x04)\x03\0\
    \x12\x06\xb8\x05\x08\xbf\x05\t\n\r\n\x05\x04)\x03\0\x01\x12\x04\xb8\x05\
    \x10\x1b\n\x0e\n\x06\x04)\x03\0\x02\0\x12\x04\xb9\x05\x10/\n\x0f\n\x07\
    \x04)\x03\0\x02\0\x04\x12\x04\xb9\x05\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\
    \0\x05\x12\x04\xb9\x05\x19\x1f\n\x0f\n\x07\x04)\x03\0\x02\0\x01\x12\x04\
    \xb9\x05\x20*\n\x0f\n\x07\x04)\x03\0\x02\0\x03\x12\x04\xb9\x05-.\n\x0e\n\
    \x06\x04)\x03\0\x02\x01\x12\x04\xba\x05\x10*\n\x0f\n\x07\x04)\x03\0\x02\
    \x01\x04\x12\x04\xba\x05\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\x01\x05\x12\
    \x04\xba\x05\x19\x1e\n\x0f\n\x07\x04)\x03\0\x02\x01\x01\x12\x04\xba\x05\
    \x1f%\n\x0f\n\x07\x04)\x03\0\x02\x01\x03\x12\x04\xba\x05()\n\x0e\n\x06\
    \x04)\x03\0\x02\x02\x12\x04\xbb\x05\x102\n\x0f\n\x07\x04)\x03\0\x02\x02\
    \x04\x12\x04\xbb\x05\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\x02\x05\x12\x04\
    \xbb\x05\x19\x1e\n\x0f\n\x07\x04)\x03\0\x02\x02\x01\x12\x04\xbb\x05\x1f-\
    \n\x0f\n\x07\x04)\x03\0\x02\x02\x03\x12\x04\xbb\x0501\n\x0e\n\x06\x04)\
    \x03\0\x02\x03\x12\x04\xbc\x05\x103\n\x0f\n\x07\x04)\x03\0\x02\x03\x04\
    \x12\x04\xbc\x05\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\x03\x05\x12\x04\xbc\
    \x05\x19\x1f\n\x0f\n\x07\x04)\x03\0\x02\x03\x01\x12\x04\xbc\x05\x20.\n\
    \x0f\n\x07\x04)\x03\0\x02\x03\x03\x12\x04\xbc\x0512\n\x0e\n\x06\x04)\x03\
    \0\x02\x04\x12\x04\xbd\x05\x10C\n\x0f\n\x07\x04)\x03\0\x02\x04\x04\x12\
    \x04\xbd\x05\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\x04\x05\x12\x04\xbd\x05\
    \x19\x1d\n\x0f\n\x07\x04)\x03\0\x02\x04\x01\x12\x04\xbd\x05\x1e>\n\x0f\n\
    \x07\x04)\x03\0\x02\x04\x03\x12\x04\xbd\x05AB\n\x0e\n\x06\x04)\x03\0\x02\
    \x05\x12\x04\xbe\x05\x10C\n\x0f\n\x07\x04)\x03\0\x02\x05\x04\x12\x04\xbe\
    \x05\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\x05\x05\x12\x04\xbe\x05\x19\x1f\
    \n\x0f\n\x07\x04)\x03\0\x02\x05\x01\x12\x04\xbe\x05\x20>\n\x0f\n\x07\x04\
    )\x03\0\x02\x05\x03\x12\x04\xbe\x05AB\n\x0c\n\x04\x04)\x02\0\x12\x04\xc1\
    \x05\x08G\n\r\n\x05\x04)\x02\0\x04\x12\x04\xc1\x05\x08\x10\n\r\n\x05\x04\
    )\x02\0\x06\x12\x04\xc1\x05\x115\n\r\n\x05\x04)\x02\0\x01\x12\x04\xc1\
    \x056B\n\r\n\x05\x04)\x02\0\x03\x12\x04\xc1\x05EF\n\x0c\n\x04\x04)\x02\
    \x01\x12\x04\xc2\x05\x08%\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xc2\x05\x08\
    \x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xc2\x05\x11\x17\n\r\n\x05\x04)\
    \x02\x01\x01\x12\x04\xc2\x05\x18\x20\n\r\n\x05\x04)\x02\x01\x03\x12\x04\
    \xc2\x05#$\n\x0c\n\x04\x04)\x02\x02\x12\x04\xc3\x05\x08%\n\r\n\x05\x04)\
    \x02\x02\x04\x12\x04\xc3\x05\x08\x10\n\r\n\x05\x04)\x02\x02\x06\x12\x04\
    \xc3\x05\x11\x17\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xc3\x05\x18\x20\n\r\
    \n\x05\x04)\x02\x02\x03\x12\x04\xc3\x05#$\n\x0c\n\x04\x04)\x02\x03\x12\
    \x04\xc4\x05\x08&\n\r\n\x05\x04)\x02\x03\x04\x12\x04\xc4\x05\x08\x10\n\r\
    \n\x05\x04)\x02\x03\x05\x12\x04\xc4\x05\x11\x17\n\r\n\x05\x04)\x02\x03\
    \x01\x12\x04\xc4\x05\x18!\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xc4\x05$%\n\
    \x0c\n\x04\x04)\x02\x04\x12\x04\xc5\x05\x08)\n\r\n\x05\x04)\x02\x04\x04\
    \x12\x04\xc5\x05\x08\x10\n\r\n\x05\x04)\x02\x04\x05\x12\x04\xc5\x05\x11\
    \x17\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xc5\x05\x18$\n\r\n\x05\x04)\x02\
    \x04\x03\x12\x04\xc5\x05'(\n\x0c\n\x02\x04*\x12\x06\xc8\x05\0\xcb\x05\
    \x01\n\x0b\n\x03\x04*\x01\x12\x04\xc8\x05\x08!\n\x0c\n\x04\x04*\x02\0\
    \x12\x04\xc9\x05\x08(\n\r\n\x05\x04*\x02\0\x04\x12\x04\xc9\x05\x08\x10\n\
    \r\n\x05\x04*\x02\0\x05\x12\x04\xc9\x05\x11\x18\n\r\n\x05\x04*\x02\0\x01\
    \x12\x04\xc9\x05\x19#\n\r\n\x05\x04*\x02\0\x03\x12\x04\xc9\x05&'\n\x0c\n\
    \x04\x04*\x02\x01\x12\x04\xca\x05\x08)\n\r\n\x05\x04*\x02\x01\x04\x12\
    \x04\xca\x05\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xca\x05\x11\x17\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xca\x05\x18$\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xca\x05'(\n\x0c\n\x02\x04+\x12\x06\xcd\x05\0\xd1\x05\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xcd\x05\x08\"\n\x0c\n\x04\x04+\x02\0\x12\x04\
    \xce\x05\x08(\n\r\n\x05\x04+\x02\0\x04\x12\x04\xce\x05\x08\x10\n\r\n\x05\
    \x04+\x02\0\x05\x12\x04\xce\x05\x11\x18\n\r\n\x05\x04+\x02\0\x01\x12\x04\
    \xce\x05\x19#\n\r\n\x05\x04+\x02\0\x03\x12\x04\xce\x05&'\n\x0c\n\x04\x04\
    +\x02\x01\x12\x04\xcf\x05\x08)\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xcf\
    \x05\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xcf\x05\x11\x17\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\xcf\x05\x18$\n\r\n\x05\x04+\x02\x01\x03\
    \x12\x04\xcf\x05'(\n\x0c\n\x04\x04+\x02\x02\x12\x04\xd0\x05\x08$\n\r\n\
    \x05\x04+\x02\x02\x04\x12\x04\xd0\x05\x08\x10\n\r\n\x05\x04+\x02\x02\x05\
    \x12\x04\xd0\x05\x11\x17\n\r\n\x05\x04+\x02\x02\x01\x12\x04\xd0\x05\x18\
    \x1f\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xd0\x05\"#\n\x0c\n\x02\x04,\x12\
    \x06\xd3\x05\0\xe2\x05\x01\n\x0b\n\x03\x04,\x01\x12\x04\xd3\x05\x08*\n\
    \x0e\n\x04\x04,\x03\0\x12\x06\xd4\x05\x08\xdb\x05\t\n\r\n\x05\x04,\x03\0\
    \x01\x12\x04\xd4\x05\x10\x16\n\x0e\n\x06\x04,\x03\0\x02\0\x12\x04\xd5\
    \x05\x10/\n\x0f\n\x07\x04,\x03\0\x02\0\x04\x12\x04\xd5\x05\x10\x18\n\x0f\
    \n\x07\x04,\x03\0\x02\0\x05\x12\x04\xd5\x05\x19\x1f\n\x0f\n\x07\x04,\x03\
    \0\x02\0\x01\x12\x04\xd5\x05\x20*\n\x0f\n\x07\x04,\x03\0\x02\0\x03\x12\
    \x04\xd5\x05-.\n\x0e\n\x06\x04,\x03\0\x02\x01\x12\x04\xd6\x05\x10(\n\x0f\
    \n\x07\x04,\x03\0\x02\x01\x04\x12\x04\xd6\x05\x10\x18\n\x0f\n\x07\x04,\
    \x03\0\x02\x01\x05\x12\x04\xd6\x05\x19\x20\n\x0f\n\x07\x04,\x03\0\x02\
    \x01\x01\x12\x04\xd6\x05!#\n\x0f\n\x07\x04,\x03\0\x02\x01\x03\x12\x04\
    \xd6\x05&'\n\x0e\n\x06\x04,\x03\0\x02\x02\x12\x04\xd7\x05\x100\n\x0f\n\
    \x07\x04,\x03\0\x02\x02\x04\x12\x04\xd7\x05\x10\x18\n\x0f\n\x07\x04,\x03\
    \0\x02\x02\x05\x12\x04\xd7\x05\x19\x1f\n\x0f\n\x07\x04,\x03\0\x02\x02\
    \x01\x12\x04\xd7\x05\x20+\n\x0f\n\x07\x04,\x03\0\x02\x02\x03\x12\x04\xd7\
    \x05./\n\x0e\n\x06\x04,\x03\0\x02\x03\x12\x04\xd8\x05\x10/\n\x0f\n\x07\
    \x04,\x03\0\x02\x03\x04\x12\x04\xd8\x05\x10\x18\n\x0f\n\x07\x04,\x03\0\
    \x02\x03\x05\x12\x04\xd8\x05\x19\x1e\n\x0f\n\x07\x04,\x03\0\x02\x03\x01\
    \x12\x04\xd8\x05\x1f*\n\x0f\n\x07\x04,\x03\0\x02\x03\x03\x12\x04\xd8\x05\
    -.\n\x0e\n\x06\x04,\x03\0\x02\x04\x12\x04\xd9\x05\x102\n\x0f\n\x07\x04,\
    \x03\0\x02\x04\x04\x12\x04\xd9\x05\x10\x18\n\x0f\n\x07\x04,\x03\0\x02\
    \x04\x05\x12\x04\xd9\x05\x19\x1e\n\x0f\n\x07\x04,\x03\0\x02\x04\x01\x12\
    \x04\xd9\x05\x1f-\n\x0f\n\x07\x04,\x03\0\x02\x04\x03\x12\x04\xd9\x0501\n\
    \x0e\n\x06\x04,\x03\0\x02\x05\x12\x04\xda\x05\x101\n\x0f\n\x07\x04,\x03\
    \0\x02\x05\x04\x12\x04\xda\x05\x10\x18\n\x0f\n\x07\x04,\x03\0\x02\x05\
    \x05\x12\x04\xda\x05\x19\x1f\n\x0f\n\x07\x04,\x03\0\x02\x05\x01\x12\x04\
    \xda\x05\x20,\n\x0f\n\x07\x04,\x03\0\x02\x05\x03\x12\x04\xda\x05/0\n\x0c\
    \n\x04\x04,\x02\0\x12\x04\xdd\x05\x08%\n\r\n\x05\x04,\x02\0\x04\x12\x04\
    \xdd\x05\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\xdd\x05\x11\x17\n\r\n\
    \x05\x04,\x02\0\x01\x12\x04\xdd\x05\x18\x20\n\r\n\x05\x04,\x02\0\x03\x12\
    \x04\xdd\x05#$\n\x0c\n\x04\x04,\x02\x01\x12\x04\xde\x05\x08&\n\r\n\x05\
    \x04,\x02\x01\x04\x12\x04\xde\x05\x08\x10\n\r\n\x05\x04,\x02\x01\x05\x12\
    \x04\xde\x05\x11\x17\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xde\x05\x18!\n\r\
    \n\x05\x04,\x02\x01\x03\x12\x04\xde\x05$%\n\x0c\n\x04\x04,\x02\x02\x12\
    \x04\xdf\x05\x08&\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xdf\x05\x08\x10\n\r\
    \n\x05\x04,\x02\x02\x05\x12\x04\xdf\x05\x11\x17\n\r\n\x05\x04,\x02\x02\
    \x01\x12\x04\xdf\x05\x18!\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xdf\x05$%\n\
    \x0c\n\x04\x04,\x02\x03\x12\x04\xe0\x05\x08G\n\r\n\x05\x04,\x02\x03\x04\
    \x12\x04\xe0\x05\x08\x10\n\r\n\x05\x04,\x02\x03\x06\x12\x04\xe0\x05\x11:\
    \n\r\n\x05\x04,\x02\x03\x01\x12\x04\xe0\x05;B\n\r\n\x05\x04,\x02\x03\x03\
    \x12\x04\xe0\x05EF\n\x0c\n\x04\x04,\x02\x04\x12\x04\xe1\x05\x08'\n\r\n\
    \x05\x04,\x02\x04\x04\x12\x04\xe1\x05\x08\x10\n\r\n\x05\x04,\x02\x04\x05\
    \x12\x04\xe1\x05\x11\x17\n\r\n\x05\x04,\x02\x04\x01\x12\x04\xe1\x05\x18\
    \"\n\r\n\x05\x04,\x02\x04\x03\x12\x04\xe1\x05%&\n\x0c\n\x02\x04-\x12\x06\
    \xe4\x05\0\xe6\x05\x01\n\x0b\n\x03\x04-\x01\x12\x04\xe4\x05\x08(\n\x0c\n\
    \x04\x04-\x02\0\x12\x04\xe5\x05\x08,\n\r\n\x05\x04-\x02\0\x04\x12\x04\
    \xe5\x05\x08\x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\xe5\x05\x11\x17\n\r\n\
    \x05\x04-\x02\0\x01\x12\x04\xe5\x05\x18'\n\r\n\x05\x04-\x02\0\x03\x12\
    \x04\xe5\x05*+\n\x0c\n\x02\x04.\x12\x06\xe8\x05\0\xf5\x05\x01\n\x0b\n\
    \x03\x04.\x01\x12\x04\xe8\x05\x08\x1c\n\x0e\n\x04\x04.\x03\0\x12\x06\xe9\
    \x05\x08\xf0\x05\t\n\r\n\x05\x04.\x03\0\x01\x12\x04\xe9\x05\x10\x1a\n\
    \x10\n\x06\x04.\x03\0\x03\0\x12\x06\xea\x05\x10\xed\x05\x11\n\x0f\n\x07\
    \x04.\x03\0\x03\0\x01\x12\x04\xea\x05\x18\"\n\x10\n\x08\x04.\x03\0\x03\0\
    \x02\0\x12\x04\xeb\x05\x18/\n\x11\n\t\x04.\x03\0\x03\0\x02\0\x04\x12\x04\
    \xeb\x05\x18\x20\n\x11\n\t\x04.\x03\0\x03\0\x02\0\x05\x12\x04\xeb\x05!'\
    \n\x11\n\t\x04.\x03\0\x03\0\x02\0\x01\x12\x04\xeb\x05(*\n\x11\n\t\x04.\
    \x03\0\x03\0\x02\0\x03\x12\x04\xeb\x05-.\n\x10\n\x08\x04.\x03\0\x03\0\
    \x02\x01\x12\x04\xec\x05\x182\n\x11\n\t\x04.\x03\0\x03\0\x02\x01\x04\x12\
    \x04\xec\x05\x18\x20\n\x11\n\t\x04.\x03\0\x03\0\x02\x01\x05\x12\x04\xec\
    \x05!'\n\x11\n\t\x04.\x03\0\x03\0\x02\x01\x01\x12\x04\xec\x05(-\n\x11\n\
    \t\x04.\x03\0\x03\0\x02\x01\x03\x12\x04\xec\x0501\n\x0e\n\x06\x04.\x03\0\
    \x02\0\x12\x04\xef\x05\x10P\n\x0f\n\x07\x04.\x03\0\x02\0\x04\x12\x04\xef\
    \x05\x10\x18\n\x0f\n\x07\x04.\x03\0\x02\0\x06\x12\x04\xef\x05\x19C\n\x0f\
    \n\x07\x04.\x03\0\x02\0\x01\x12\x04\xef\x05DK\n\x0f\n\x07\x04.\x03\0\x02\
    \0\x03\x12\x04\xef\x05NO\n\x0c\n\x04\x04.\x02\0\x12\x04\xf2\x05\x08$\n\r\
    \n\x05\x04.\x02\0\x04\x12\x04\xf2\x05\x08\x10\n\r\n\x05\x04.\x02\0\x05\
    \x12\x04\xf2\x05\x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xf2\x05\x18\
    \x1f\n\r\n\x05\x04.\x02\0\x03\x12\x04\xf2\x05\"#\n\x0c\n\x04\x04.\x02\
    \x01\x12\x04\xf3\x05\x08@\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xf3\x05\x08\
    \x10\n\r\n\x05\x04.\x02\x01\x06\x12\x04\xf3\x05\x110\n\r\n\x05\x04.\x02\
    \x01\x01\x12\x04\xf3\x051;\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xf3\x05>?\
    \n\x0c\n\x04\x04.\x02\x02\x12\x04\xf4\x05\x084\n\r\n\x05\x04.\x02\x02\
    \x04\x12\x04\xf4\x05\x08\x10\n\r\n\x05\x04.\x02\x02\x06\x12\x04\xf4\x05\
    \x11'\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xf4\x05(/\n\r\n\x05\x04.\x02\
    \x02\x03\x12\x04\xf4\x0523\n\x0c\n\x02\x04/\x12\x06\xf7\x05\0\xff\x05\
    \x01\n\x0b\n\x03\x04/\x01\x12\x04\xf7\x05\x08(\n\x0e\n\x04\x04/\x03\0\
    \x12\x06\xf8\x05\x08\xfc\x05\t\n\r\n\x05\x04/\x03\0\x01\x12\x04\xf8\x05\
    \x10\x16\n\x0e\n\x06\x04/\x03\0\x02\0\x12\x04\xf9\x05\x10/\n\x0f\n\x07\
    \x04/\x03\0\x02\0\x04\x12\x04\xf9\x05\x10\x18\n\x0f\n\x07\x04/\x03\0\x02\
    \0\x05\x12\x04\xf9\x05\x19\x1f\n\x0f\n\x07\x04/\x03\0\x02\0\x01\x12\x04\
    \xf9\x05\x20*\n\x0f\n\x07\x04/\x03\0\x02\0\x03\x12\x04\xf9\x05-.\n\x0e\n\
    \x06\x04/\x03\0\x02\x01\x12\x04\xfa\x05\x10,\n\x0f\n\x07\x04/\x03\0\x02\
    \x01\x04\x12\x04\xfa\x05\x10\x18\n\x0f\n\x07\x04/\x03\0\x02\x01\x05\x12\
    \x04\xfa\x05\x19\x1f\n\x0f\n\x07\x04/\x03\0\x02\x01\x01\x12\x04\xfa\x05\
    \x20'\n\x0f\n\x07\x04/\x03\0\x02\x01\x03\x12\x04\xfa\x05*+\n\x0e\n\x06\
    \x04/\x03\0\x02\x02\x12\x04\xfb\x05\x10-\n\x0f\n\x07\x04/\x03\0\x02\x02\
    \x04\x12\x04\xfb\x05\x10\x18\n\x0f\n\x07\x04/\x03\0\x02\x02\x05\x12\x04\
    \xfb\x05\x19\x1f\n\x0f\n\x07\x04/\x03\0\x02\x02\x01\x12\x04\xfb\x05\x20(\
    \n\x0f\n\x07\x04/\x03\0\x02\x02\x03\x12\x04\xfb\x05+,\n\x0c\n\x04\x04/\
    \x02\0\x12\x04\xfe\x05\x08E\n\r\n\x05\x04/\x02\0\x04\x12\x04\xfe\x05\x08\
    \x10\n\r\n\x05\x04/\x02\0\x06\x12\x04\xfe\x05\x118\n\r\n\x05\x04/\x02\0\
    \x01\x12\x04\xfe\x059@\n\r\n\x05\x04/\x02\0\x03\x12\x04\xfe\x05CD\n\x0c\
    \n\x02\x040\x12\x06\x81\x06\0\x82\x06\x01\n\x0b\n\x03\x040\x01\x12\x04\
    \x81\x06\x08#\n\x0c\n\x02\x041\x12\x06\x84\x06\0\x86\x06\x01\n\x0b\n\x03\
    \x041\x01\x12\x04\x84\x06\x08,\n\x0c\n\x04\x041\x02\0\x12\x04\x85\x06\
    \x08%\n\r\n\x05\x041\x02\0\x04\x12\x04\x85\x06\x08\x10\n\r\n\x05\x041\
    \x02\0\x05\x12\x04\x85\x06\x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\x85\
    \x06\x18\x20\n\r\n\x05\x041\x02\0\x03\x12\x04\x85\x06#$\n\x0c\n\x02\x042\
    \x12\x06\x88\x06\0\x91\x06\x01\n\x0b\n\x03\x042\x01\x12\x04\x88\x06\x08'\
    \n\x0c\n\x04\x042\x02\0\x12\x04\x89\x06\x08-\n\r\n\x05\x042\x02\0\x04\
    \x12\x04\x89\x06\x08\x10\n\r\n\x05\x042\x02\0\x05\x12\x04\x89\x06\x11\
    \x18\n\r\n\x05\x042\x02\0\x01\x12\x04\x89\x06\x19(\n\r\n\x05\x042\x02\0\
    \x03\x12\x04\x89\x06+,\n\x0c\n\x04\x042\x02\x01\x12\x04\x8a\x06\x08,\n\r\
    \n\x05\x042\x02\x01\x04\x12\x04\x8a\x06\x08\x10\n\r\n\x05\x042\x02\x01\
    \x05\x12\x04\x8a\x06\x11\x18\n\r\n\x05\x042\x02\x01\x01\x12\x04\x8a\x06\
    \x19'\n\r\n\x05\x042\x02\x01\x03\x12\x04\x8a\x06*+\n\x0c\n\x04\x042\x02\
    \x02\x12\x04\x8b\x06\x08+\n\r\n\x05\x042\x02\x02\x04\x12\x04\x8b\x06\x08\
    \x10\n\r\n\x05\x042\x02\x02\x05\x12\x04\x8b\x06\x11\x18\n\r\n\x05\x042\
    \x02\x02\x01\x12\x04\x8b\x06\x19&\n\r\n\x05\x042\x02\x02\x03\x12\x04\x8b\
    \x06)*\n\x0c\n\x04\x042\x02\x03\x12\x04\x8c\x06\x08'\n\r\n\x05\x042\x02\
    \x03\x04\x12\x04\x8c\x06\x08\x10\n\r\n\x05\x042\x02\x03\x05\x12\x04\x8c\
    \x06\x11\x15\n\r\n\x05\x042\x02\x03\x01\x12\x04\x8c\x06\x16\"\n\r\n\x05\
    \x042\x02\x03\x03\x12\x04\x8c\x06%&\n\x0c\n\x04\x042\x02\x04\x12\x04\x8d\
    \x06\x08+\n\r\n\x05\x042\x02\x04\x04\x12\x04\x8d\x06\x08\x10\n\r\n\x05\
    \x042\x02\x04\x05\x12\x04\x8d\x06\x11\x17\n\r\n\x05\x042\x02\x04\x01\x12\
    \x04\x8d\x06\x18&\n\r\n\x05\x042\x02\x04\x03\x12\x04\x8d\x06)*\n\x0c\n\
    \x04\x042\x02\x05\x12\x04\x8e\x06\x08-\n\r\n\x05\x042\x02\x05\x04\x12\
    \x04\x8e\x06\x08\x10\n\r\n\x05\x042\x02\x05\x05\x12\x04\x8e\x06\x11\x15\
    \n\r\n\x05\x042\x02\x05\x01\x12\x04\x8e\x06\x16(\n\r\n\x05\x042\x02\x05\
    \x03\x12\x04\x8e\x06+,\n\x0c\n\x04\x042\x02\x06\x12\x04\x8f\x06\x082\n\r\
    \n\x05\x042\x02\x06\x04\x12\x04\x8f\x06\x08\x10\n\r\n\x05\x042\x02\x06\
    \x05\x12\x04\x8f\x06\x11\x16\n\r\n\x05\x042\x02\x06\x01\x12\x04\x8f\x06\
    \x17-\n\r\n\x05\x042\x02\x06\x03\x12\x04\x8f\x0601\n\x0c\n\x04\x042\x02\
    \x07\x12\x04\x90\x06\x08(\n\r\n\x05\x042\x02\x07\x04\x12\x04\x90\x06\x08\
    \x10\n\r\n\x05\x042\x02\x07\x05\x12\x04\x90\x06\x11\x15\n\r\n\x05\x042\
    \x02\x07\x01\x12\x04\x90\x06\x16#\n\r\n\x05\x042\x02\x07\x03\x12\x04\x90\
    \x06&'\n\x0c\n\x02\x043\x12\x06\x93\x06\0\x9c\x06\x01\n\x0b\n\x03\x043\
    \x01\x12\x04\x93\x06\x08#\n\x0e\n\x04\x043\x03\0\x12\x06\x94\x06\x08\x98\
    \x06\t\n\r\n\x05\x043\x03\0\x01\x12\x04\x94\x06\x10\x1b\n\x0e\n\x06\x043\
    \x03\0\x02\0\x12\x04\x95\x06\x103\n\x0f\n\x07\x043\x03\0\x02\0\x04\x12\
    \x04\x95\x06\x10\x18\n\x0f\n\x07\x043\x03\0\x02\0\x05\x12\x04\x95\x06\
    \x19\x1f\n\x0f\n\x07\x043\x03\0\x02\0\x01\x12\x04\x95\x06\x20.\n\x0f\n\
    \x07\x043\x03\0\x02\0\x03\x12\x04\x95\x0612\n\x0e\n\x06\x043\x03\0\x02\
    \x01\x12\x04\x96\x06\x103\n\x0f\n\x07\x043\x03\0\x02\x01\x04\x12\x04\x96\
    \x06\x10\x18\n\x0f\n\x07\x043\x03\0\x02\x01\x05\x12\x04\x96\x06\x19\x1f\
    \n\x0f\n\x07\x043\x03\0\x02\x01\x01\x12\x04\x96\x06\x20.\n\x0f\n\x07\x04\
    3\x03\0\x02\x01\x03\x12\x04\x96\x0612\n\x0e\n\x06\x043\x03\0\x02\x02\x12\
    \x04\x97\x06\x10/\n\x0f\n\x07\x043\x03\0\x02\x02\x04\x12\x04\x97\x06\x10\
    \x18\n\x0f\n\x07\x043\x03\0\x02\x02\x05\x12\x04\x97\x06\x19\x1f\n\x0f\n\
    \x07\x043\x03\0\x02\x02\x01\x12\x04\x97\x06\x20*\n\x0f\n\x07\x043\x03\0\
    \x02\x02\x03\x12\x04\x97\x06-.\n\x0c\n\x04\x043\x02\0\x12\x04\x9a\x06\
    \x08+\n\r\n\x05\x043\x02\0\x04\x12\x04\x9a\x06\x08\x10\n\r\n\x05\x043\
    \x02\0\x05\x12\x04\x9a\x06\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\x9a\
    \x06\x18&\n\r\n\x05\x043\x02\0\x03\x12\x04\x9a\x06)*\n\x0c\n\x04\x043\
    \x02\x01\x12\x04\x9b\x06\x08G\n\r\n\x05\x043\x02\x01\x04\x12\x04\x9b\x06\
    \x08\x10\n\r\n\x05\x043\x02\x01\x06\x12\x04\x9b\x06\x118\n\r\n\x05\x043\
    \x02\x01\x01\x12\x04\x9b\x069B\n\r\n\x05\x043\x02\x01\x03\x12\x04\x9b\
    \x06EF\n\x0c\n\x02\x044\x12\x06\x9e\x06\0\xb0\x06\x01\n\x0b\n\x03\x044\
    \x01\x12\x04\x9e\x06\x08&\n\x0e\n\x04\x044\x03\0\x12\x06\x9f\x06\x08\xaa\
    \x06\t\n\r\n\x05\x044\x03\0\x01\x12\x04\x9f\x06\x10\x1a\n\x10\n\x06\x044\
    \x03\0\x04\0\x12\x06\xa0\x06\x10\xa3\x06\x11\n\x0f\n\x07\x044\x03\0\x04\
    \0\x01\x12\x04\xa0\x06\x15\x1c\n\x10\n\x08\x044\x03\0\x04\0\x02\0\x12\
    \x04\xa1\x06\x182\n\x11\n\t\x044\x03\0\x04\0\x02\0\x01\x12\x04\xa1\x06\
    \x18-\n\x11\n\t\x044\x03\0\x04\0\x02\0\x02\x12\x04\xa1\x0601\n\x10\n\x08\
    \x044\x03\0\x04\0\x02\x01\x12\x04\xa2\x06\x180\n\x11\n\t\x044\x03\0\x04\
    \0\x02\x01\x01\x12\x04\xa2\x06\x18+\n\x11\n\t\x044\x03\0\x04\0\x02\x01\
    \x02\x12\x04\xa2\x06./\n\x0e\n\x06\x044\x03\0\x02\0\x12\x04\xa5\x06\x10-\
    \n\x0f\n\x07\x044\x03\0\x02\0\x04\x12\x04\xa5\x06\x10\x18\n\x0f\n\x07\
    \x044\x03\0\x02\0\x05\x12\x04\xa5\x06\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\
    \0\x01\x12\x04\xa5\x06\x20(\n\x0f\n\x07\x044\x03\0\x02\0\x03\x12\x04\xa5\
    \x06+,\n\x0e\n\x06\x044\x03\0\x02\x01\x12\x04\xa6\x06\x100\n\x0f\n\x07\
    \x044\x03\0\x02\x01\x04\x12\x04\xa6\x06\x10\x18\n\x0f\n\x07\x044\x03\0\
    \x02\x01\x05\x12\x04\xa6\x06\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\x01\x01\
    \x12\x04\xa6\x06\x20+\n\x0f\n\x07\x044\x03\0\x02\x01\x03\x12\x04\xa6\x06\
    ./\n\x0e\n\x06\x044\x03\0\x02\x02\x12\x04\xa7\x06\x10.\n\x0f\n\x07\x044\
    \x03\0\x02\x02\x04\x12\x04\xa7\x06\x10\x18\n\x0f\n\x07\x044\x03\0\x02\
    \x02\x05\x12\x04\xa7\x06\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\x02\x01\x12\
    \x04\xa7\x06\x20)\n\x0f\n\x07\x044\x03\0\x02\x02\x03\x12\x04\xa7\x06,-\n\
    \x0e\n\x06\x044\x03\0\x02\x03\x12\x04\xa8\x06\x10V\n\x0f\n\x07\x044\x03\
    \0\x02\x03\x04\x12\x04\xa8\x06\x10\x18\n\x0f\n\x07\x044\x03\0\x02\x03\
    \x06\x12\x04\xa8\x06\x19J\n\x0f\n\x07\x044\x03\0\x02\x03\x01\x12\x04\xa8\
    \x06KQ\n\x0f\n\x07\x044\x03\0\x02\x03\x03\x12\x04\xa8\x06TU\n\x0e\n\x06\
    \x044\x03\0\x02\x04\x12\x04\xa9\x06\x106\n\x0f\n\x07\x044\x03\0\x02\x04\
    \x04\x12\x04\xa9\x06\x10\x18\n\x0f\n\x07\x044\x03\0\x02\x04\x05\x12\x04\
    \xa9\x06\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\x04\x01\x12\x04\xa9\x06\x201\
    \n\x0f\n\x07\x044\x03\0\x02\x04\x03\x12\x04\xa9\x0645\n\x0c\n\x04\x044\
    \x02\0\x12\x04\xac\x06\x08'\n\r\n\x05\x044\x02\0\x04\x12\x04\xac\x06\x08\
    \x10\n\r\n\x05\x044\x02\0\x05\x12\x04\xac\x06\x11\x17\n\r\n\x05\x044\x02\
    \0\x01\x12\x04\xac\x06\x18\"\n\r\n\x05\x044\x02\0\x03\x12\x04\xac\x06%&\
    \n\x0c\n\x04\x044\x02\x01\x12\x04\xad\x06\x08%\n\r\n\x05\x044\x02\x01\
    \x04\x12\x04\xad\x06\x08\x10\n\r\n\x05\x044\x02\x01\x05\x12\x04\xad\x06\
    \x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\xad\x06\x18\x20\n\r\n\x05\
    \x044\x02\x01\x03\x12\x04\xad\x06#$\n\x0c\n\x04\x044\x02\x02\x12\x04\xae\
    \x06\x08\"\n\r\n\x05\x044\x02\x02\x04\x12\x04\xae\x06\x08\x10\n\r\n\x05\
    \x044\x02\x02\x05\x12\x04\xae\x06\x11\x15\n\r\n\x05\x044\x02\x02\x01\x12\
    \x04\xae\x06\x16\x1d\n\r\n\x05\x044\x02\x02\x03\x12\x04\xae\x06\x20!\n\
    \x0c\n\x04\x044\x02\x03\x12\x04\xaf\x06\x08K\n\r\n\x05\x044\x02\x03\x04\
    \x12\x04\xaf\x06\x08\x10\n\r\n\x05\x044\x02\x03\x06\x12\x04\xaf\x06\x11:\
    \n\r\n\x05\x044\x02\x03\x01\x12\x04\xaf\x06;F\n\r\n\x05\x044\x02\x03\x03\
    \x12\x04\xaf\x06IJ\n\x0c\n\x02\x045\x12\x06\xb2\x06\0\xb5\x06\x01\n\x0b\
    \n\x03\x045\x01\x12\x04\xb2\x06\x08&\n\x0c\n\x04\x045\x02\0\x12\x04\xb3\
    \x06\x08'\n\r\n\x05\x045\x02\0\x04\x12\x04\xb3\x06\x08\x10\n\r\n\x05\x04\
    5\x02\0\x05\x12\x04\xb3\x06\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xb3\
    \x06\x18\"\n\r\n\x05\x045\x02\0\x03\x12\x04\xb3\x06%&\n\x0c\n\x04\x045\
    \x02\x01\x12\x04\xb4\x06\x08$\n\r\n\x05\x045\x02\x01\x04\x12\x04\xb4\x06\
    \x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\xb4\x06\x11\x17\n\r\n\x05\
    \x045\x02\x01\x01\x12\x04\xb4\x06\x18\x1f\n\r\n\x05\x045\x02\x01\x03\x12\
    \x04\xb4\x06\"#\n\x0c\n\x02\x046\x12\x06\xb7\x06\0\xc5\x06\x01\n\x0b\n\
    \x03\x046\x01\x12\x04\xb7\x06\x08(\n\x0e\n\x04\x046\x03\0\x12\x06\xb8\
    \x06\x08\xbe\x06\t\n\r\n\x05\x046\x03\0\x01\x12\x04\xb8\x06\x10\x19\n\
    \x0e\n\x06\x046\x03\0\x02\0\x12\x04\xb9\x06\x10-\n\x0f\n\x07\x046\x03\0\
    \x02\0\x04\x12\x04\xb9\x06\x10\x18\n\x0f\n\x07\x046\x03\0\x02\0\x06\x12\
    \x04\xb9\x06\x19\x1f\n\x0f\n\x07\x046\x03\0\x02\0\x01\x12\x04\xb9\x06\
    \x20(\n\x0f\n\x07\x046\x03\0\x02\0\x03\x12\x04\xb9\x06+,\n\x0e\n\x06\x04\
    6\x03\0\x02\x01\x12\x04\xba\x06\x10,\n\x0f\n\x07\x046\x03\0\x02\x01\x04\
    \x12\x04\xba\x06\x10\x18\n\x0f\n\x07\x046\x03\0\x02\x01\x05\x12\x04\xba\
    \x06\x19\x1f\n\x0f\n\x07\x046\x03\0\x02\x01\x01\x12\x04\xba\x06\x20'\n\
    \x0f\n\x07\x046\x03\0\x02\x01\x03\x12\x04\xba\x06*+\n\x0e\n\x06\x046\x03\
    \0\x02\x02\x12\x04\xbb\x06\x100\n\x0f\n\x07\x046\x03\0\x02\x02\x04\x12\
    \x04\xbb\x06\x10\x18\n\x0f\n\x07\x046\x03\0\x02\x02\x05\x12\x04\xbb\x06\
    \x19\x1f\n\x0f\n\x07\x046\x03\0\x02\x02\x01\x12\x04\xbb\x06\x20+\n\x0f\n\
    \x07\x046\x03\0\x02\x02\x03\x12\x04\xbb\x06./\n\x0e\n\x06\x046\x03\0\x02\
    \x03\x12\x04\xbc\x06\x10-\n\x0f\n\x07\x046\x03\0\x02\x03\x04\x12\x04\xbc\
    \x06\x10\x18\n\x0f\n\x07\x046\x03\0\x02\x03\x05\x12\x04\xbc\x06\x19\x1f\
    \n\x0f\n\x07\x046\x03\0\x02\x03\x01\x12\x04\xbc\x06\x20(\n\x0f\n\x07\x04\
    6\x03\0\x02\x03\x03\x12\x04\xbc\x06+,\n\x0e\n\x06\x046\x03\0\x02\x04\x12\
    \x04\xbd\x06\x103\n\x0f\n\x07\x046\x03\0\x02\x04\x04\x12\x04\xbd\x06\x10\
    \x18\n\x0f\n\x07\x046\x03\0\x02\x04\x05\x12\x04\xbd\x06\x19\x1f\n\x0f\n\
    \x07\x046\x03\0\x02\x04\x01\x12\x04\xbd\x06\x20.\n\x0f\n\x07\x046\x03\0\
    \x02\x04\x03\x12\x04\xbd\x0612\n\x0c\n\x04\x046\x02\0\x12\x04\xc0\x06\
    \x08'\n\r\n\x05\x046\x02\0\x04\x12\x04\xc0\x06\x08\x10\n\r\n\x05\x046\
    \x02\0\x05\x12\x04\xc0\x06\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\xc0\
    \x06\x18\"\n\r\n\x05\x046\x02\0\x03\x12\x04\xc0\x06%&\n\x0c\n\x04\x046\
    \x02\x01\x12\x04\xc1\x06\x08J\n\r\n\x05\x046\x02\x01\x04\x12\x04\xc1\x06\
    \x08\x10\n\r\n\x05\x046\x02\x01\x06\x12\x04\xc1\x06\x11;\n\r\n\x05\x046\
    \x02\x01\x01\x12\x04\xc1\x06<E\n\r\n\x05\x046\x02\x01\x03\x12\x04\xc1\
    \x06HI\n\x0c\n\x04\x046\x02\x02\x12\x04\xc2\x06\x08I\n\r\n\x05\x046\x02\
    \x02\x04\x12\x04\xc2\x06\x08\x10\n\r\n\x05\x046\x02\x02\x06\x12\x04\xc2\
    \x06\x11;\n\r\n\x05\x046\x02\x02\x01\x12\x04\xc2\x06<D\n\r\n\x05\x046\
    \x02\x02\x03\x12\x04\xc2\x06GH\n\x0c\n\x04\x046\x02\x03\x12\x04\xc3\x06\
    \x08%\n\r\n\x05\x046\x02\x03\x04\x12\x04\xc3\x06\x08\x10\n\r\n\x05\x046\
    \x02\x03\x05\x12\x04\xc3\x06\x11\x17\n\r\n\x05\x046\x02\x03\x01\x12\x04\
    \xc3\x06\x18\x20\n\r\n\x05\x046\x02\x03\x03\x12\x04\xc3\x06#$\n\x0c\n\
    \x04\x046\x02\x04\x12\x04\xc4\x06\x08$\n\r\n\x05\x046\x02\x04\x04\x12\
    \x04\xc4\x06\x08\x10\n\r\n\x05\x046\x02\x04\x05\x12\x04\xc4\x06\x11\x17\
    \n\r\n\x05\x046\x02\x04\x01\x12\x04\xc4\x06\x18\x1f\n\r\n\x05\x046\x02\
    \x04\x03\x12\x04\xc4\x06\"#\n\x0c\n\x02\x047\x12\x06\xc7\x06\0\xca\x06\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xc7\x06\x08+\n\x0c\n\x04\x047\x02\0\
    \x12\x04\xc8\x06\x08'\n\r\n\x05\x047\x02\0\x04\x12\x04\xc8\x06\x08\x10\n\
    \r\n\x05\x047\x02\0\x05\x12\x04\xc8\x06\x11\x17\n\r\n\x05\x047\x02\0\x01\
    \x12\x04\xc8\x06\x18\"\n\r\n\x05\x047\x02\0\x03\x12\x04\xc8\x06%&\n\x0c\
    \n\x04\x047\x02\x01\x12\x04\xc9\x06\x08D\n\r\n\x05\x047\x02\x01\x04\x12\
    \x04\xc9\x06\x08\x10\n\r\n\x05\x047\x02\x01\x06\x12\x04\xc9\x06\x114\n\r\
    \n\x05\x047\x02\x01\x01\x12\x04\xc9\x065?\n\r\n\x05\x047\x02\x01\x03\x12\
    \x04\xc9\x06BC\n\x0c\n\x02\x048\x12\x06\xcc\x06\0\xd8\x06\x01\n\x0b\n\
    \x03\x048\x01\x12\x04\xcc\x06\x08\x16\n\x0e\n\x04\x048\x03\0\x12\x06\xcd\
    \x06\x08\xd1\x06\t\n\r\n\x05\x048\x03\0\x01\x12\x04\xcd\x06\x10\x16\n\
    \x0e\n\x06\x048\x03\0\x02\0\x12\x04\xce\x06\x10/\n\x0f\n\x07\x048\x03\0\
    \x02\0\x04\x12\x04\xce\x06\x10\x18\n\x0f\n\x07\x048\x03\0\x02\0\x05\x12\
    \x04\xce\x06\x19\x1f\n\x0f\n\x07\x048\x03\0\x02\0\x01\x12\x04\xce\x06\
    \x20*\n\x0f\n\x07\x048\x03\0\x02\0\x03\x12\x04\xce\x06-.\n\x0e\n\x06\x04\
    8\x03\0\x02\x01\x12\x04\xcf\x06\x10*\n\x0f\n\x07\x048\x03\0\x02\x01\x04\
    \x12\x04\xcf\x06\x10\x18\n\x0f\n\x07\x048\x03\0\x02\x01\x05\x12\x04\xcf\
    \x06\x19\x1f\n\x0f\n\x07\x048\x03\0\x02\x01\x01\x12\x04\xcf\x06\x20%\n\
    \x0f\n\x07\x048\x03\0\x02\x01\x03\x12\x04\xcf\x06()\n\x0e\n\x06\x048\x03\
    \0\x02\x02\x12\x04\xd0\x06\x108\n\x0f\n\x07\x048\x03\0\x02\x02\x04\x12\
    \x04\xd0\x06\x10\x18\n\x0f\n\x07\x048\x03\0\x02\x02\x05\x12\x04\xd0\x06\
    \x19\x1f\n\x0f\n\x07\x048\x03\0\x02\x02\x01\x12\x04\xd0\x06\x203\n\x0f\n\
    \x07\x048\x03\0\x02\x02\x03\x12\x04\xd0\x0667\n\x0c\n\x04\x048\x02\0\x12\
    \x04\xd3\x06\x083\n\r\n\x05\x048\x02\0\x04\x12\x04\xd3\x06\x08\x10\n\r\n\
    \x05\x048\x02\0\x06\x12\x04\xd3\x06\x11&\n\r\n\x05\x048\x02\0\x01\x12\
    \x04\xd3\x06'.\n\r\n\x05\x048\x02\0\x03\x12\x04\xd3\x0612\n\x0c\n\x04\
    \x048\x02\x01\x12\x04\xd4\x06\x08%\n\r\n\x05\x048\x02\x01\x04\x12\x04\
    \xd4\x06\x08\x10\n\r\n\x05\x048\x02\x01\x06\x12\x04\xd4\x06\x11\x17\n\r\
    \n\x05\x048\x02\x01\x01\x12\x04\xd4\x06\x18\x20\n\r\n\x05\x048\x02\x01\
    \x03\x12\x04\xd4\x06#$\n\x0c\n\x04\x048\x02\x02\x12\x04\xd5\x06\x08&\n\r\
    \n\x05\x048\x02\x02\x04\x12\x04\xd5\x06\x08\x10\n\r\n\x05\x048\x02\x02\
    \x05\x12\x04\xd5\x06\x11\x17\n\r\n\x05\x048\x02\x02\x01\x12\x04\xd5\x06\
    \x18!\n\r\n\x05\x048\x02\x02\x03\x12\x04\xd5\x06$%\n\x0c\n\x04\x048\x02\
    \x03\x12\x04\xd6\x06\x08%\n\r\n\x05\x048\x02\x03\x04\x12\x04\xd6\x06\x08\
    \x10\n\r\n\x05\x048\x02\x03\x05\x12\x04\xd6\x06\x11\x17\n\r\n\x05\x048\
    \x02\x03\x01\x12\x04\xd6\x06\x18\x20\n\r\n\x05\x048\x02\x03\x03\x12\x04\
    \xd6\x06#$\n\x0c\n\x04\x048\x02\x04\x12\x04\xd7\x06\x08,\n\r\n\x05\x048\
    \x02\x04\x04\x12\x04\xd7\x06\x08\x10\n\r\n\x05\x048\x02\x04\x05\x12\x04\
    \xd7\x06\x11\x17\n\r\n\x05\x048\x02\x04\x01\x12\x04\xd7\x06\x18'\n\r\n\
    \x05\x048\x02\x04\x03\x12\x04\xd7\x06*+\n\x0c\n\x02\x049\x12\x06\xda\x06\
    \0\xe8\x06\x01\n\x0b\n\x03\x049\x01\x12\x04\xda\x06\x08\x1a\n\x0e\n\x04\
    \x049\x03\0\x12\x06\xdb\x06\x08\xe2\x06\t\n\r\n\x05\x049\x03\0\x01\x12\
    \x04\xdb\x06\x10\x16\n\x0e\n\x06\x049\x03\0\x02\0\x12\x04\xdc\x06\x10/\n\
    \x0f\n\x07\x049\x03\0\x02\0\x04\x12\x04\xdc\x06\x10\x18\n\x0f\n\x07\x049\
    \x03\0\x02\0\x05\x12\x04\xdc\x06\x19\x1f\n\x0f\n\x07\x049\x03\0\x02\0\
    \x01\x12\x04\xdc\x06\x20*\n\x0f\n\x07\x049\x03\0\x02\0\x03\x12\x04\xdc\
    \x06-.\n\x0e\n\x06\x049\x03\0\x02\x01\x12\x04\xdd\x06\x10.\n\x0f\n\x07\
    \x049\x03\0\x02\x01\x04\x12\x04\xdd\x06\x10\x18\n\x0f\n\x07\x049\x03\0\
    \x02\x01\x05\x12\x04\xdd\x06\x19\x1f\n\x0f\n\x07\x049\x03\0\x02\x01\x01\
    \x12\x04\xdd\x06\x20)\n\x0f\n\x07\x049\x03\0\x02\x01\x03\x12\x04\xdd\x06\
    ,-\n\x0e\n\x06\x049\x03\0\x02\x02\x12\x04\xde\x06\x100\n\x0f\n\x07\x049\
    \x03\0\x02\x02\x04\x12\x04\xde\x06\x10\x18\n\x0f\n\x07\x049\x03\0\x02\
    \x02\x05\x12\x04\xde\x06\x19\x1f\n\x0f\n\x07\x049\x03\0\x02\x02\x01\x12\
    \x04\xde\x06\x20+\n\x0f\n\x07\x049\x03\0\x02\x02\x03\x12\x04\xde\x06./\n\
    \x0e\n\x06\x049\x03\0\x02\x03\x12\x04\xdf\x06\x108\n\x0f\n\x07\x049\x03\
    \0\x02\x03\x04\x12\x04\xdf\x06\x10\x18\n\x0f\n\x07\x049\x03\0\x02\x03\
    \x05\x12\x04\xdf\x06\x19\x1f\n\x0f\n\x07\x049\x03\0\x02\x03\x01\x12\x04\
    \xdf\x06\x203\n\x0f\n\x07\x049\x03\0\x02\x03\x03\x12\x04\xdf\x0667\n\x0e\
    \n\x06\x049\x03\0\x02\x04\x12\x04\xe0\x06\x10/\n\x0f\n\x07\x049\x03\0\
    \x02\x04\x04\x12\x04\xe0\x06\x10\x18\n\x0f\n\x07\x049\x03\0\x02\x04\x05\
    \x12\x04\xe0\x06\x19\x1f\n\x0f\n\x07\x049\x03\0\x02\x04\x01\x12\x04\xe0\
    \x06\x20*\n\x0f\n\x07\x049\x03\0\x02\x04\x03\x12\x04\xe0\x06-.\n\x0e\n\
    \x06\x049\x03\0\x02\x05\x12\x04\xe1\x06\x101\n\x0f\n\x07\x049\x03\0\x02\
    \x05\x04\x12\x04\xe1\x06\x10\x18\n\x0f\n\x07\x049\x03\0\x02\x05\x05\x12\
    \x04\xe1\x06\x19\x1f\n\x0f\n\x07\x049\x03\0\x02\x05\x01\x12\x04\xe1\x06\
    \x20,\n\x0f\n\x07\x049\x03\0\x02\x05\x03\x12\x04\xe1\x06/0\n\x0c\n\x04\
    \x049\x02\0\x12\x04\xe4\x06\x087\n\r\n\x05\x049\x02\0\x04\x12\x04\xe4\
    \x06\x08\x10\n\r\n\x05\x049\x02\0\x06\x12\x04\xe4\x06\x11*\n\r\n\x05\x04\
    9\x02\0\x01\x12\x04\xe4\x06+2\n\r\n\x05\x049\x02\0\x03\x12\x04\xe4\x0656\
    \n\x0c\n\x04\x049\x02\x01\x12\x04\xe5\x06\x08%\n\r\n\x05\x049\x02\x01\
    \x04\x12\x04\xe5\x06\x08\x10\n\r\n\x05\x049\x02\x01\x06\x12\x04\xe5\x06\
    \x11\x17\n\r\n\x05\x049\x02\x01\x01\x12\x04\xe5\x06\x18\x20\n\r\n\x05\
    \x049\x02\x01\x03\x12\x04\xe5\x06#$\n\x0c\n\x04\x049\x02\x02\x12\x04\xe6\
    \x06\x08%\n\r\n\x05\x049\x02\x02\x04\x12\x04\xe6\x06\x08\x10\n\r\n\x05\
    \x049\x02\x02\x05\x12\x04\xe6\x06\x11\x17\n\r\n\x05\x049\x02\x02\x01\x12\
    \x04\xe6\x06\x18\x20\n\r\n\x05\x049\x02\x02\x03\x12\x04\xe6\x06#$\n\x0c\
    \n\x04\x049\x02\x03\x12\x04\xe7\x06\x08&\n\r\n\x05\x049\x02\x03\x04\x12\
    \x04\xe7\x06\x08\x10\n\r\n\x05\x049\x02\x03\x05\x12\x04\xe7\x06\x11\x17\
    \n\r\n\x05\x049\x02\x03\x01\x12\x04\xe7\x06\x18!\n\r\n\x05\x049\x02\x03\
    \x03\x12\x04\xe7\x06$%\n\x0c\n\x02\x04:\x12\x06\xea\x06\0\xf5\x06\x01\n\
    \x0b\n\x03\x04:\x01\x12\x04\xea\x06\x08\x1b\n\x0e\n\x04\x04:\x03\0\x12\
    \x06\xeb\x06\x08\xef\x06\t\n\r\n\x05\x04:\x03\0\x01\x12\x04\xeb\x06\x10\
    \x16\n\x0e\n\x06\x04:\x03\0\x02\0\x12\x04\xec\x06\x106\n\x0f\n\x07\x04:\
    \x03\0\x02\0\x04\x12\x04\xec\x06\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\0\
    \x05\x12\x04\xec\x06\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\0\x01\x12\x04\
    \xec\x06\x201\n\x0f\n\x07\x04:\x03\0\x02\0\x03\x12\x04\xec\x0645\n\x0e\n\
    \x06\x04:\x03\0\x02\x01\x12\x04\xed\x06\x109\n\x0f\n\x07\x04:\x03\0\x02\
    \x01\x04\x12\x04\xed\x06\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x01\x05\x12\
    \x04\xed\x06\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x01\x01\x12\x04\xed\x06\
    \x204\n\x0f\n\x07\x04:\x03\0\x02\x01\x03\x12\x04\xed\x0678\n\x0e\n\x06\
    \x04:\x03\0\x02\x02\x12\x04\xee\x06\x106\n\x0f\n\x07\x04:\x03\0\x02\x02\
    \x04\x12\x04\xee\x06\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x02\x05\x12\x04\
    \xee\x06\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x02\x01\x12\x04\xee\x06\x201\
    \n\x0f\n\x07\x04:\x03\0\x02\x02\x03\x12\x04\xee\x0645\n\x0c\n\x04\x04:\
    \x02\0\x12\x04\xf1\x06\x089\n\r\n\x05\x04:\x02\0\x04\x12\x04\xf1\x06\x08\
    \x10\n\r\n\x05\x04:\x02\0\x06\x12\x04\xf1\x06\x11+\n\r\n\x05\x04:\x02\0\
    \x01\x12\x04\xf1\x06,4\n\r\n\x05\x04:\x02\0\x03\x12\x04\xf1\x0678\n\x0c\
    \n\x04\x04:\x02\x01\x12\x04\xf2\x06\x08%\n\r\n\x05\x04:\x02\x01\x04\x12\
    \x04\xf2\x06\x08\x10\n\r\n\x05\x04:\x02\x01\x06\x12\x04\xf2\x06\x11\x17\
    \n\r\n\x05\x04:\x02\x01\x01\x12\x04\xf2\x06\x18\x20\n\r\n\x05\x04:\x02\
    \x01\x03\x12\x04\xf2\x06#$\n\x0c\n\x04\x04:\x02\x02\x12\x04\xf3\x06\x08%\
    \n\r\n\x05\x04:\x02\x02\x04\x12\x04\xf3\x06\x08\x10\n\r\n\x05\x04:\x02\
    \x02\x05\x12\x04\xf3\x06\x11\x17\n\r\n\x05\x04:\x02\x02\x01\x12\x04\xf3\
    \x06\x18\x20\n\r\n\x05\x04:\x02\x02\x03\x12\x04\xf3\x06#$\n\x0c\n\x04\
    \x04:\x02\x03\x12\x04\xf4\x06\x08&\n\r\n\x05\x04:\x02\x03\x04\x12\x04\
    \xf4\x06\x08\x10\n\r\n\x05\x04:\x02\x03\x05\x12\x04\xf4\x06\x11\x17\n\r\
    \n\x05\x04:\x02\x03\x01\x12\x04\xf4\x06\x18!\n\r\n\x05\x04:\x02\x03\x03\
    \x12\x04\xf4\x06$%\n\x0c\n\x02\x04;\x12\x06\xf7\x06\0\xff\x06\x01\n\x0b\
    \n\x03\x04;\x01\x12\x04\xf7\x06\x08(\n\x0e\n\x04\x04;\x03\0\x12\x06\xf8\
    \x06\x08\xfb\x06\t\n\r\n\x05\x04;\x03\0\x01\x12\x04\xf8\x06\x10\"\n\x0e\
    \n\x06\x04;\x03\0\x02\0\x12\x04\xf9\x06\x102\n\x0f\n\x07\x04;\x03\0\x02\
    \0\x04\x12\x04\xf9\x06\x10\x18\n\x0f\n\x07\x04;\x03\0\x02\0\x05\x12\x04\
    \xf9\x06\x19\x1f\n\x0f\n\x07\x04;\x03\0\x02\0\x01\x12\x04\xf9\x06\x20-\n\
    \x0f\n\x07\x04;\x03\0\x02\0\x03\x12\x04\xf9\x0601\n\x0e\n\x06\x04;\x03\0\
    \x02\x01\x12\x04\xfa\x06\x105\n\x0f\n\x07\x04;\x03\0\x02\x01\x04\x12\x04\
    \xfa\x06\x10\x18\n\x0f\n\x07\x04;\x03\0\x02\x01\x05\x12\x04\xfa\x06\x19\
    \x1f\n\x0f\n\x07\x04;\x03\0\x02\x01\x01\x12\x04\xfa\x06\x200\n\x0f\n\x07\
    \x04;\x03\0\x02\x01\x03\x12\x04\xfa\x0634\n\x0c\n\x04\x04;\x02\0\x12\x04\
    \xfd\x06\x08%\n\r\n\x05\x04;\x02\0\x04\x12\x04\xfd\x06\x08\x10\n\r\n\x05\
    \x04;\x02\0\x06\x12\x04\xfd\x06\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\
    \xfd\x06\x18\x20\n\r\n\x05\x04;\x02\0\x03\x12\x04\xfd\x06#$\n\x0c\n\x04\
    \x04;\x02\x01\x12\x04\xfe\x06\x08Z\n\r\n\x05\x04;\x02\x01\x04\x12\x04\
    \xfe\x06\x08\x10\n\r\n\x05\x04;\x02\x01\x06\x12\x04\xfe\x06\x11D\n\r\n\
    \x05\x04;\x02\x01\x01\x12\x04\xfe\x06EU\n\r\n\x05\x04;\x02\x01\x03\x12\
    \x04\xfe\x06XY\n\x0c\n\x02\x04<\x12\x06\x81\x07\0\x85\x07\x01\n\x0b\n\
    \x03\x04<\x01\x12\x04\x81\x07\x08;\n\x0c\n\x04\x04<\x02\0\x12\x04\x82\
    \x07\x08%\n\r\n\x05\x04<\x02\0\x04\x12\x04\x82\x07\x08\x10\n\r\n\x05\x04\
    <\x02\0\x05\x12\x04\x82\x07\x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\x82\
    \x07\x18\x20\n\r\n\x05\x04<\x02\0\x03\x12\x04\x82\x07#$\n\x0c\n\x04\x04<\
    \x02\x01\x12\x04\x83\x07\x08'\n\r\n\x05\x04<\x02\x01\x04\x12\x04\x83\x07\
    \x08\x10\n\r\n\x05\x04<\x02\x01\x05\x12\x04\x83\x07\x11\x17\n\r\n\x05\
    \x04<\x02\x01\x01\x12\x04\x83\x07\x18\"\n\r\n\x05\x04<\x02\x01\x03\x12\
    \x04\x83\x07%&\n\x0c\n\x04\x04<\x02\x02\x12\x04\x84\x07\x08&\n\r\n\x05\
    \x04<\x02\x02\x04\x12\x04\x84\x07\x08\x10\n\r\n\x05\x04<\x02\x02\x05\x12\
    \x04\x84\x07\x11\x17\n\r\n\x05\x04<\x02\x02\x01\x12\x04\x84\x07\x18!\n\r\
    \n\x05\x04<\x02\x02\x03\x12\x04\x84\x07$%\n\x0c\n\x02\x04=\x12\x06\x87\
    \x07\0\x89\x07\x01\n\x0b\n\x03\x04=\x01\x12\x04\x87\x07\x08C\n\x0c\n\x04\
    \x04=\x02\0\x12\x04\x88\x07\x08!\n\r\n\x05\x04=\x02\0\x04\x12\x04\x88\
    \x07\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\x88\x07\x11\x15\n\r\n\x05\
    \x04=\x02\0\x01\x12\x04\x88\x07\x16\x1c\n\r\n\x05\x04=\x02\0\x03\x12\x04\
    \x88\x07\x1f\x20\n\x0c\n\x02\x04>\x12\x06\x8b\x07\0\x96\x07\x01\n\x0b\n\
    \x03\x04>\x01\x12\x04\x8b\x07\x087\n\x0e\n\x04\x04>\x03\0\x12\x06\x8c\
    \x07\x08\x90\x07\t\n\r\n\x05\x04>\x03\0\x01\x12\x04\x8c\x07\x10\x20\n\
    \x0e\n\x06\x04>\x03\0\x02\0\x12\x04\x8d\x07\x102\n\x0f\n\x07\x04>\x03\0\
    \x02\0\x04\x12\x04\x8d\x07\x10\x18\n\x0f\n\x07\x04>\x03\0\x02\0\x05\x12\
    \x04\x8d\x07\x19\x1f\n\x0f\n\x07\x04>\x03\0\x02\0\x01\x12\x04\x8d\x07\
    \x20-\n\x0f\n\x07\x04>\x03\0\x02\0\x03\x12\x04\x8d\x0701\n\x0e\n\x06\x04\
    >\x03\0\x02\x01\x12\x04\x8e\x07\x105\n\x0f\n\x07\x04>\x03\0\x02\x01\x04\
    \x12\x04\x8e\x07\x10\x18\n\x0f\n\x07\x04>\x03\0\x02\x01\x05\x12\x04\x8e\
    \x07\x19\x1f\n\x0f\n\x07\x04>\x03\0\x02\x01\x01\x12\x04\x8e\x07\x200\n\
    \x0f\n\x07\x04>\x03\0\x02\x01\x03\x12\x04\x8e\x0734\n\x0e\n\x06\x04>\x03\
    \0\x02\x02\x12\x04\x8f\x07\x10;\n\x0f\n\x07\x04>\x03\0\x02\x02\x04\x12\
    \x04\x8f\x07\x10\x18\n\x0f\n\x07\x04>\x03\0\x02\x02\x05\x12\x04\x8f\x07\
    \x19\x1d\n\x0f\n\x07\x04>\x03\0\x02\x02\x01\x12\x04\x8f\x07\x1e6\n\x0f\n\
    \x07\x04>\x03\0\x02\x02\x03\x12\x04\x8f\x079:\n\x0c\n\x04\x04>\x02\0\x12\
    \x04\x92\x07\x08%\n\r\n\x05\x04>\x02\0\x04\x12\x04\x92\x07\x08\x10\n\r\n\
    \x05\x04>\x02\0\x05\x12\x04\x92\x07\x11\x17\n\r\n\x05\x04>\x02\0\x01\x12\
    \x04\x92\x07\x18\x20\n\r\n\x05\x04>\x02\0\x03\x12\x04\x92\x07#$\n\x0c\n\
    \x04\x04>\x02\x01\x12\x04\x93\x07\x08^\n\r\n\x05\x04>\x02\x01\x04\x12\
    \x04\x93\x07\x08\x10\n\r\n\x05\x04>\x02\x01\x06\x12\x04\x93\x07\x11Q\n\r\
    \n\x05\x04>\x02\x01\x01\x12\x04\x93\x07RY\n\r\n\x05\x04>\x02\x01\x03\x12\
    \x04\x93\x07\\]\n\x0c\n\x04\x04>\x02\x02\x12\x04\x94\x07\x08&\n\r\n\x05\
    \x04>\x02\x02\x04\x12\x04\x94\x07\x08\x10\n\r\n\x05\x04>\x02\x02\x05\x12\
    \x04\x94\x07\x11\x17\n\r\n\x05\x04>\x02\x02\x01\x12\x04\x94\x07\x18!\n\r\
    \n\x05\x04>\x02\x02\x03\x12\x04\x94\x07$%\n\x0c\n\x04\x04>\x02\x03\x12\
    \x04\x95\x07\x08+\n\r\n\x05\x04>\x02\x03\x04\x12\x04\x95\x07\x08\x10\n\r\
    \n\x05\x04>\x02\x03\x05\x12\x04\x95\x07\x11\x17\n\r\n\x05\x04>\x02\x03\
    \x01\x12\x04\x95\x07\x18&\n\r\n\x05\x04>\x02\x03\x03\x12\x04\x95\x07)*\n\
    \x0c\n\x02\x04?\x12\x06\x98\x07\0\xa0\x07\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\x98\x07\x087\n\x0e\n\x04\x04?\x03\0\x12\x06\x99\x07\x08\x9b\x07\t\n\
    \r\n\x05\x04?\x03\0\x01\x12\x04\x99\x07\x10\x1a\n\x0e\n\x06\x04?\x03\0\
    \x02\0\x12\x04\x9a\x07\x102\n\x0f\n\x07\x04?\x03\0\x02\0\x04\x12\x04\x9a\
    \x07\x10\x18\n\x0f\n\x07\x04?\x03\0\x02\0\x05\x12\x04\x9a\x07\x19\x1f\n\
    \x0f\n\x07\x04?\x03\0\x02\0\x01\x12\x04\x9a\x07\x20-\n\x0f\n\x07\x04?\
    \x03\0\x02\0\x03\x12\x04\x9a\x0701\n\x0c\n\x04\x04?\x02\0\x12\x04\x9d\
    \x07\x08%\n\r\n\x05\x04?\x02\0\x04\x12\x04\x9d\x07\x08\x10\n\r\n\x05\x04\
    ?\x02\0\x05\x12\x04\x9d\x07\x11\x17\n\r\n\x05\x04?\x02\0\x01\x12\x04\x9d\
    \x07\x18\x20\n\r\n\x05\x04?\x02\0\x03\x12\x04\x9d\x07#$\n\x0c\n\x04\x04?\
    \x02\x01\x12\x04\x9e\x07\x08c\n\r\n\x05\x04?\x02\x01\x04\x12\x04\x9e\x07\
    \x08\x10\n\r\n\x05\x04?\x02\x01\x06\x12\x04\x9e\x07\x11K\n\r\n\x05\x04?\
    \x02\x01\x01\x12\x04\x9e\x07L^\n\r\n\x05\x04?\x02\x01\x03\x12\x04\x9e\
    \x07ab\n\x0c\n\x04\x04?\x02\x02\x12\x04\x9f\x07\x08&\n\r\n\x05\x04?\x02\
    \x02\x04\x12\x04\x9f\x07\x08\x10\n\r\n\x05\x04?\x02\x02\x05\x12\x04\x9f\
    \x07\x11\x17\n\r\n\x05\x04?\x02\x02\x01\x12\x04\x9f\x07\x18!\n\r\n\x05\
    \x04?\x02\x02\x03\x12\x04\x9f\x07$%\n\x0c\n\x02\x04@\x12\x06\xa2\x07\0\
    \xa4\x07\x01\n\x0b\n\x03\x04@\x01\x12\x04\xa2\x07\x083\n\x0c\n\x04\x04@\
    \x02\0\x12\x04\xa3\x07\x08M\n\r\n\x05\x04@\x02\0\x04\x12\x04\xa3\x07\x08\
    \x10\n\r\n\x05\x04@\x02\0\x06\x12\x04\xa3\x07\x11@\n\r\n\x05\x04@\x02\0\
    \x01\x12\x04\xa3\x07AH\n\r\n\x05\x04@\x02\0\x03\x12\x04\xa3\x07KL\n\x0c\
    \n\x02\x04A\x12\x06\xa6\x07\0\xbe\x07\x01\n\x0b\n\x03\x04A\x01\x12\x04\
    \xa6\x07\x084\n\x0e\n\x04\x04A\x03\0\x12\x06\xa7\x07\x08\xae\x07\t\n\r\n\
    \x05\x04A\x03\0\x01\x12\x04\xa7\x07\x10\x1c\n\x0e\n\x06\x04A\x03\0\x02\0\
    \x12\x04\xa8\x07\x10(\n\x0f\n\x07\x04A\x03\0\x02\0\x04\x12\x04\xa8\x07\
    \x10\x18\n\x0f\n\x07\x04A\x03\0\x02\0\x05\x12\x04\xa8\x07\x19\x1e\n\x0f\
    \n\x07\x04A\x03\0\x02\0\x01\x12\x04\xa8\x07\x1f#\n\x0f\n\x07\x04A\x03\0\
    \x02\0\x03\x12\x04\xa8\x07&'\n\x0e\n\x06\x04A\x03\0\x02\x01\x12\x04\xa9\
    \x07\x10)\n\x0f\n\x07\x04A\x03\0\x02\x01\x04\x12\x04\xa9\x07\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x01\x05\x12\x04\xa9\x07\x19\x1f\n\x0f\n\x07\
    \x04A\x03\0\x02\x01\x01\x12\x04\xa9\x07\x20$\n\x0f\n\x07\x04A\x03\0\x02\
    \x01\x03\x12\x04\xa9\x07'(\n\x0e\n\x06\x04A\x03\0\x02\x02\x12\x04\xaa\
    \x07\x10.\n\x0f\n\x07\x04A\x03\0\x02\x02\x04\x12\x04\xaa\x07\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x02\x05\x12\x04\xaa\x07\x19\x1f\n\x0f\n\x07\
    \x04A\x03\0\x02\x02\x01\x12\x04\xaa\x07\x20)\n\x0f\n\x07\x04A\x03\0\x02\
    \x02\x03\x12\x04\xaa\x07,-\n\x0e\n\x06\x04A\x03\0\x02\x03\x12\x04\xab\
    \x07\x10.\n\x0f\n\x07\x04A\x03\0\x02\x03\x04\x12\x04\xab\x07\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x03\x05\x12\x04\xab\x07\x19\x1f\n\x0f\n\x07\
    \x04A\x03\0\x02\x03\x01\x12\x04\xab\x07\x20)\n\x0f\n\x07\x04A\x03\0\x02\
    \x03\x03\x12\x04\xab\x07,-\n\x0e\n\x06\x04A\x03\0\x02\x04\x12\x04\xac\
    \x07\x103\n\x0f\n\x07\x04A\x03\0\x02\x04\x04\x12\x04\xac\x07\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x04\x05\x12\x04\xac\x07\x19\x1e\n\x0f\n\x07\
    \x04A\x03\0\x02\x04\x01\x12\x04\xac\x07\x1f.\n\x0f\n\x07\x04A\x03\0\x02\
    \x04\x03\x12\x04\xac\x0712\n\x0e\n\x06\x04A\x03\0\x02\x05\x12\x04\xad\
    \x07\x102\n\x0f\n\x07\x04A\x03\0\x02\x05\x04\x12\x04\xad\x07\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x05\x05\x12\x04\xad\x07\x19\x1d\n\x0f\n\x07\
    \x04A\x03\0\x02\x05\x01\x12\x04\xad\x07\x1e-\n\x0f\n\x07\x04A\x03\0\x02\
    \x05\x03\x12\x04\xad\x0701\n\x0e\n\x04\x04A\x03\x01\x12\x06\xb0\x07\x08\
    \xb9\x07\t\n\r\n\x05\x04A\x03\x01\x01\x12\x04\xb0\x07\x10\x16\n\x0e\n\
    \x06\x04A\x03\x01\x02\0\x12\x04\xb1\x07\x100\n\x0f\n\x07\x04A\x03\x01\
    \x02\0\x04\x12\x04\xb1\x07\x10\x18\n\x0f\n\x07\x04A\x03\x01\x02\0\x05\
    \x12\x04\xb1\x07\x19\x1f\n\x0f\n\x07\x04A\x03\x01\x02\0\x01\x12\x04\xb1\
    \x07\x20+\n\x0f\n\x07\x04A\x03\x01\x02\0\x03\x12\x04\xb1\x07./\n\x0e\n\
    \x06\x04A\x03\x01\x02\x01\x12\x04\xb2\x07\x10/\n\x0f\n\x07\x04A\x03\x01\
    \x02\x01\x04\x12\x04\xb2\x07\x10\x18\n\x0f\n\x07\x04A\x03\x01\x02\x01\
    \x05\x12\x04\xb2\x07\x19\x1f\n\x0f\n\x07\x04A\x03\x01\x02\x01\x01\x12\
    \x04\xb2\x07\x20*\n\x0f\n\x07\x04A\x03\x01\x02\x01\x03\x12\x04\xb2\x07-.\
    \n\x0e\n\x06\x04A\x03\x01\x02\x02\x12\x04\xb3\x07\x10,\n\x0f\n\x07\x04A\
    \x03\x01\x02\x02\x04\x12\x04\xb3\x07\x10\x18\n\x0f\n\x07\x04A\x03\x01\
    \x02\x02\x05\x12\x04\xb3\x07\x19\x1f\n\x0f\n\x07\x04A\x03\x01\x02\x02\
    \x01\x12\x04\xb3\x07\x20'\n\x0f\n\x07\x04A\x03\x01\x02\x02\x03\x12\x04\
    \xb3\x07*+\n\x0e\n\x06\x04A\x03\x01\x02\x03\x12\x04\xb4\x07\x104\n\x0f\n\
    \x07\x04A\x03\x01\x02\x03\x04\x12\x04\xb4\x07\x10\x18\n\x0f\n\x07\x04A\
    \x03\x01\x02\x03\x05\x12\x04\xb4\x07\x19\x1f\n\x0f\n\x07\x04A\x03\x01\
    \x02\x03\x01\x12\x04\xb4\x07\x20/\n\x0f\n\x07\x04A\x03\x01\x02\x03\x03\
    \x12\x04\xb4\x0723\n\x0e\n\x06\x04A\x03\x01\x02\x04\x12\x04\xb5\x07\x103\
    \n\x0f\n\x07\x04A\x03\x01\x02\x04\x04\x12\x04\xb5\x07\x10\x18\n\x0f\n\
    \x07\x04A\x03\x01\x02\x04\x05\x12\x04\xb5\x07\x19\x1f\n\x0f\n\x07\x04A\
    \x03\x01\x02\x04\x01\x12\x04\xb5\x07\x20.\n\x0f\n\x07\x04A\x03\x01\x02\
    \x04\x03\x12\x04\xb5\x0712\n\x0e\n\x06\x04A\x03\x01\x02\x05\x12\x04\xb6\
    \x07\x10f\n\x0f\n\x07\x04A\x03\x01\x02\x05\x04\x12\x04\xb6\x07\x10\x18\n\
    \x0f\n\x07\x04A\x03\x01\x02\x05\x06\x12\x04\xb6\x07\x19R\n\x0f\n\x07\x04\
    A\x03\x01\x02\x05\x01\x12\x04\xb6\x07Sa\n\x0f\n\x07\x04A\x03\x01\x02\x05\
    \x03\x12\x04\xb6\x07de\n\x0e\n\x06\x04A\x03\x01\x02\x06\x12\x04\xb7\x07\
    \x10)\n\x0f\n\x07\x04A\x03\x01\x02\x06\x04\x12\x04\xb7\x07\x10\x18\n\x0f\
    \n\x07\x04A\x03\x01\x02\x06\x05\x12\x04\xb7\x07\x19\x1f\n\x0f\n\x07\x04A\
    \x03\x01\x02\x06\x01\x12\x04\xb7\x07\x20$\n\x0f\n\x07\x04A\x03\x01\x02\
    \x06\x03\x12\x04\xb7\x07'(\n\x0e\n\x06\x04A\x03\x01\x02\x07\x12\x04\xb8\
    \x07\x10,\n\x0f\n\x07\x04A\x03\x01\x02\x07\x04\x12\x04\xb8\x07\x10\x18\n\
    \x0f\n\x07\x04A\x03\x01\x02\x07\x05\x12\x04\xb8\x07\x19\x1d\n\x0f\n\x07\
    \x04A\x03\x01\x02\x07\x01\x12\x04\xb8\x07\x1e'\n\x0f\n\x07\x04A\x03\x01\
    \x02\x07\x03\x12\x04\xb8\x07*+\n\x0c\n\x04\x04A\x02\0\x12\x04\xbb\x07\
    \x08%\n\r\n\x05\x04A\x02\0\x04\x12\x04\xbb\x07\x08\x10\n\r\n\x05\x04A\
    \x02\0\x05\x12\x04\xbb\x07\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\x04\xbb\
    \x07\x18\x20\n\r\n\x05\x04A\x02\0\x03\x12\x04\xbb\x07#$\n\x0c\n\x04\x04A\
    \x02\x01\x12\x04\xbc\x07\x08\x20\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xbc\
    \x07\x08\x10\n\r\n\x05\x04A\x02\x01\x05\x12\x04\xbc\x07\x11\x17\n\r\n\
    \x05\x04A\x02\x01\x01\x12\x04\xbc\x07\x18\x1b\n\r\n\x05\x04A\x02\x01\x03\
    \x12\x04\xbc\x07\x1e\x1f\n\x0c\n\x04\x04A\x02\x02\x12\x04\xbd\x07\x08Q\n\
    \r\n\x05\x04A\x02\x02\x04\x12\x04\xbd\x07\x08\x10\n\r\n\x05\x04A\x02\x02\
    \x06\x12\x04\xbd\x07\x11D\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xbd\x07EL\n\
    \r\n\x05\x04A\x02\x02\x03\x12\x04\xbd\x07OP\n\x0c\n\x02\x04B\x12\x06\xc0\
    \x07\0\xd3\x07\x01\n\x0b\n\x03\x04B\x01\x12\x04\xc0\x07\x088\n\x0e\n\x04\
    \x04B\x03\0\x12\x06\xc1\x07\x08\xc7\x07\t\n\r\n\x05\x04B\x03\0\x01\x12\
    \x04\xc1\x07\x10\x19\n\x0e\n\x06\x04B\x03\0\x02\0\x12\x04\xc2\x07\x10(\n\
    \x0f\n\x07\x04B\x03\0\x02\0\x04\x12\x04\xc2\x07\x10\x18\n\x0f\n\x07\x04B\
    \x03\0\x02\0\x05\x12\x04\xc2\x07\x19\x1e\n\x0f\n\x07\x04B\x03\0\x02\0\
    \x01\x12\x04\xc2\x07\x1f#\n\x0f\n\x07\x04B\x03\0\x02\0\x03\x12\x04\xc2\
    \x07&'\n\x0e\n\x06\x04B\x03\0\x02\x01\x12\x04\xc3\x07\x10.\n\x0f\n\x07\
    \x04B\x03\0\x02\x01\x04\x12\x04\xc3\x07\x10\x18\n\x0f\n\x07\x04B\x03\0\
    \x02\x01\x05\x12\x04\xc3\x07\x19\x1f\n\x0f\n\x07\x04B\x03\0\x02\x01\x01\
    \x12\x04\xc3\x07\x20)\n\x0f\n\x07\x04B\x03\0\x02\x01\x03\x12\x04\xc3\x07\
    ,-\n\x0e\n\x06\x04B\x03\0\x02\x02\x12\x04\xc4\x07\x103\n\x0f\n\x07\x04B\
    \x03\0\x02\x02\x04\x12\x04\xc4\x07\x10\x18\n\x0f\n\x07\x04B\x03\0\x02\
    \x02\x05\x12\x04\xc4\x07\x19\x1e\n\x0f\n\x07\x04B\x03\0\x02\x02\x01\x12\
    \x04\xc4\x07\x1f.\n\x0f\n\x07\x04B\x03\0\x02\x02\x03\x12\x04\xc4\x0712\n\
    \x0e\n\x06\x04B\x03\0\x02\x03\x12\x04\xc5\x07\x102\n\x0f\n\x07\x04B\x03\
    \0\x02\x03\x04\x12\x04\xc5\x07\x10\x18\n\x0f\n\x07\x04B\x03\0\x02\x03\
    \x05\x12\x04\xc5\x07\x19\x1d\n\x0f\n\x07\x04B\x03\0\x02\x03\x01\x12\x04\
    \xc5\x07\x1e-\n\x0f\n\x07\x04B\x03\0\x02\x03\x03\x12\x04\xc5\x0701\n\x0e\
    \n\x06\x04B\x03\0\x02\x04\x12\x04\xc6\x07\x10;\n\x0f\n\x07\x04B\x03\0\
    \x02\x04\x04\x12\x04\xc6\x07\x10\x18\n\x0f\n\x07\x04B\x03\0\x02\x04\x05\
    \x12\x04\xc6\x07\x19\x1e\n\x0f\n\x07\x04B\x03\0\x02\x04\x01\x12\x04\xc6\
    \x07\x1f6\n\x0f\n\x07\x04B\x03\0\x02\x04\x03\x12\x04\xc6\x079:\n\x0e\n\
    \x04\x04B\x03\x01\x12\x06\xc9\x07\x08\xcf\x07\t\n\r\n\x05\x04B\x03\x01\
    \x01\x12\x04\xc9\x07\x10\x16\n\x0e\n\x06\x04B\x03\x01\x02\0\x12\x04\xca\
    \x07\x10/\n\x0f\n\x07\x04B\x03\x01\x02\0\x04\x12\x04\xca\x07\x10\x18\n\
    \x0f\n\x07\x04B\x03\x01\x02\0\x05\x12\x04\xca\x07\x19\x1f\n\x0f\n\x07\
    \x04B\x03\x01\x02\0\x01\x12\x04\xca\x07\x20*\n\x0f\n\x07\x04B\x03\x01\
    \x02\0\x03\x12\x04\xca\x07-.\n\x0e\n\x06\x04B\x03\x01\x02\x01\x12\x04\
    \xcb\x07\x104\n\x0f\n\x07\x04B\x03\x01\x02\x01\x04\x12\x04\xcb\x07\x10\
    \x18\n\x0f\n\x07\x04B\x03\x01\x02\x01\x05\x12\x04\xcb\x07\x19\x1f\n\x0f\
    \n\x07\x04B\x03\x01\x02\x01\x01\x12\x04\xcb\x07\x20/\n\x0f\n\x07\x04B\
    \x03\x01\x02\x01\x03\x12\x04\xcb\x0723\n\x0e\n\x06\x04B\x03\x01\x02\x02\
    \x12\x04\xcc\x07\x103\n\x0f\n\x07\x04B\x03\x01\x02\x02\x04\x12\x04\xcc\
    \x07\x10\x18\n\x0f\n\x07\x04B\x03\x01\x02\x02\x05\x12\x04\xcc\x07\x19\
    \x1f\n\x0f\n\x07\x04B\x03\x01\x02\x02\x01\x12\x04\xcc\x07\x20.\n\x0f\n\
    \x07\x04B\x03\x01\x02\x02\x03\x12\x04\xcc\x0712\n\x0e\n\x06\x04B\x03\x01\
    \x02\x03\x12\x04\xcd\x07\x10d\n\x0f\n\x07\x04B\x03\x01\x02\x03\x04\x12\
    \x04\xcd\x07\x10\x18\n\x0f\n\x07\x04B\x03\x01\x02\x03\x06\x12\x04\xcd\
    \x07\x19S\n\x0f\n\x07\x04B\x03\x01\x02\x03\x01\x12\x04\xcd\x07T_\n\x0f\n\
    \x07\x04B\x03\x01\x02\x03\x03\x12\x04\xcd\x07bc\n\x0e\n\x06\x04B\x03\x01\
    \x02\x04\x12\x04\xce\x07\x10,\n\x0f\n\x07\x04B\x03\x01\x02\x04\x04\x12\
    \x04\xce\x07\x10\x18\n\x0f\n\x07\x04B\x03\x01\x02\x04\x05\x12\x04\xce\
    \x07\x19\x1d\n\x0f\n\x07\x04B\x03\x01\x02\x04\x01\x12\x04\xce\x07\x1e'\n\
    \x0f\n\x07\x04B\x03\x01\x02\x04\x03\x12\x04\xce\x07*+\n\x0c\n\x04\x04B\
    \x02\0\x12\x04\xd1\x07\x08%\n\r\n\x05\x04B\x02\0\x04\x12\x04\xd1\x07\x08\
    \x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\xd1\x07\x11\x17\n\r\n\x05\x04B\x02\
    \0\x01\x12\x04\xd1\x07\x18\x20\n\r\n\x05\x04B\x02\0\x03\x12\x04\xd1\x07#\
    $\n\x0c\n\x04\x04B\x02\x01\x12\x04\xd2\x07\x08U\n\r\n\x05\x04B\x02\x01\
    \x04\x12\x04\xd2\x07\x08\x10\n\r\n\x05\x04B\x02\x01\x06\x12\x04\xd2\x07\
    \x11H\n\r\n\x05\x04B\x02\x01\x01\x12\x04\xd2\x07IP\n\r\n\x05\x04B\x02\
    \x01\x03\x12\x04\xd2\x07ST\n\x0c\n\x02\x04C\x12\x06\xd5\x07\0\xf9\x07\
    \x01\n\x0b\n\x03\x04C\x01\x12\x04\xd5\x07\x08'\n\x0e\n\x04\x04C\x03\0\
    \x12\x06\xd6\x07\x08\xe0\x07\t\n\r\n\x05\x04C\x03\0\x01\x12\x04\xd6\x07\
    \x10\x1b\n\x0e\n\x06\x04C\x03\0\x02\0\x12\x04\xd7\x07\x10,\n\x0f\n\x07\
    \x04C\x03\0\x02\0\x04\x12\x04\xd7\x07\x10\x18\n\x0f\n\x07\x04C\x03\0\x02\
    \0\x05\x12\x04\xd7\x07\x19\x1f\n\x0f\n\x07\x04C\x03\0\x02\0\x01\x12\x04\
    \xd7\x07\x20'\n\x0f\n\x07\x04C\x03\0\x02\0\x03\x12\x04\xd7\x07*+\n\x0e\n\
    \x06\x04C\x03\0\x02\x01\x12\x04\xd8\x07\x10.\n\x0f\n\x07\x04C\x03\0\x02\
    \x01\x04\x12\x04\xd8\x07\x10\x18\n\x0f\n\x07\x04C\x03\0\x02\x01\x05\x12\
    \x04\xd8\x07\x19\x1f\n\x0f\n\x07\x04C\x03\0\x02\x01\x01\x12\x04\xd8\x07\
    \x20)\n\x0f\n\x07\x04C\x03\0\x02\x01\x03\x12\x04\xd8\x07,-\n\x0e\n\x06\
    \x04C\x03\0\x02\x02\x12\x04\xd9\x07\x10*\n\x0f\n\x07\x04C\x03\0\x02\x02\
    \x04\x12\x04\xd9\x07\x10\x18\n\x0f\n\x07\x04C\x03\0\x02\x02\x05\x12\x04\
    \xd9\x07\x19\x1f\n\x0f\n\x07\x04C\x03\0\x02\x02\x01\x12\x04\xd9\x07\x20%\
    \n\x0f\n\x07\x04C\x03\0\x02\x02\x03\x12\x04\xd9\x07()\n\x0e\n\x06\x04C\
    \x03\0\x02\x03\x12\x04\xda\x07\x10+\n\x0f\n\x07\x04C\x03\0\x02\x03\x04\
    \x12\x04\xda\x07\x10\x18\n\x0f\n\x07\x04C\x03\0\x02\x03\x05\x12\x04\xda\
    \x07\x19\x1f\n\x0f\n\x07\x04C\x03\0\x02\x03\x01\x12\x04\xda\x07\x20&\n\
    \x0f\n\x07\x04C\x03\0\x02\x03\x03\x12\x04\xda\x07)*\n\x0e\n\x06\x04C\x03\
    \0\x02\x04\x12\x04\xdb\x07\x101\n\x0f\n\x07\x04C\x03\0\x02\x04\x04\x12\
    \x04\xdb\x07\x10\x18\n\x0f\n\x07\x04C\x03\0\x02\x04\x05\x12\x04\xdb\x07\
    \x19\x1f\n\x0f\n\x07\x04C\x03\0\x02\x04\x01\x12\x04\xdb\x07\x20,\n\x0f\n\
    \x07\x04C\x03\0\x02\x04\x03\x12\x04\xdb\x07/0\n\x0e\n\x06\x04C\x03\0\x02\
    \x05\x12\x04\xdc\x07\x10.\n\x0f\n\x07\x04C\x03\0\x02\x05\x04\x12\x04\xdc\
    \x07\x10\x18\n\x0f\n\x07\x04C\x03\0\x02\x05\x05\x12\x04\xdc\x07\x19\x1d\
    \n\x0f\n\x07\x04C\x03\0\x02\x05\x01\x12\x04\xdc\x07\x1e)\n\x0f\n\x07\x04\
    C\x03\0\x02\x05\x03\x12\x04\xdc\x07,-\n\x0e\n\x06\x04C\x03\0\x02\x06\x12\
    \x04\xdd\x07\x10,\n\x0f\n\x07\x04C\x03\0\x02\x06\x04\x12\x04\xdd\x07\x10\
    \x18\n\x0f\n\x07\x04C\x03\0\x02\x06\x05\x12\x04\xdd\x07\x19\x1d\n\x0f\n\
    \x07\x04C\x03\0\x02\x06\x01\x12\x04\xdd\x07\x1e'\n\x0f\n\x07\x04C\x03\0\
    \x02\x06\x03\x12\x04\xdd\x07*+\n\x0e\n\x06\x04C\x03\0\x02\x07\x12\x04\
    \xde\x07\x10-\n\x0f\n\x07\x04C\x03\0\x02\x07\x04\x12\x04\xde\x07\x10\x18\
    \n\x0f\n\x07\x04C\x03\0\x02\x07\x05\x12\x04\xde\x07\x19\x1d\n\x0f\n\x07\
    \x04C\x03\0\x02\x07\x01\x12\x04\xde\x07\x1e(\n\x0f\n\x07\x04C\x03\0\x02\
    \x07\x03\x12\x04\xde\x07+,\n\x0e\n\x06\x04C\x03\0\x02\x08\x12\x04\xdf\
    \x07\x10-\n\x0f\n\x07\x04C\x03\0\x02\x08\x04\x12\x04\xdf\x07\x10\x18\n\
    \x0f\n\x07\x04C\x03\0\x02\x08\x05\x12\x04\xdf\x07\x19\x1f\n\x0f\n\x07\
    \x04C\x03\0\x02\x08\x01\x12\x04\xdf\x07\x20(\n\x0f\n\x07\x04C\x03\0\x02\
    \x08\x03\x12\x04\xdf\x07+,\n\x0e\n\x04\x04C\x03\x01\x12\x06\xe2\x07\x08\
    \xed\x07\t\n\r\n\x05\x04C\x03\x01\x01\x12\x04\xe2\x07\x10\x19\n\x0e\n\
    \x06\x04C\x03\x01\x02\0\x12\x04\xe3\x07\x10)\n\x0f\n\x07\x04C\x03\x01\
    \x02\0\x04\x12\x04\xe3\x07\x10\x18\n\x0f\n\x07\x04C\x03\x01\x02\0\x05\
    \x12\x04\xe3\x07\x19\x1f\n\x0f\n\x07\x04C\x03\x01\x02\0\x01\x12\x04\xe3\
    \x07\x20$\n\x0f\n\x07\x04C\x03\x01\x02\0\x03\x12\x04\xe3\x07'(\n\x0e\n\
    \x06\x04C\x03\x01\x02\x01\x12\x04\xe4\x07\x10W\n\x0f\n\x07\x04C\x03\x01\
    \x02\x01\x04\x12\x04\xe4\x07\x10\x18\n\x0f\n\x07\x04C\x03\x01\x02\x01\
    \x06\x12\x04\xe4\x07\x19D\n\x0f\n\x07\x04C\x03\x01\x02\x01\x01\x12\x04\
    \xe4\x07ER\n\x0f\n\x07\x04C\x03\x01\x02\x01\x03\x12\x04\xe4\x07UV\n\x0e\
    \n\x06\x04C\x03\x01\x02\x02\x12\x04\xe5\x07\x105\n\x0f\n\x07\x04C\x03\
    \x01\x02\x02\x04\x12\x04\xe5\x07\x10\x18\n\x0f\n\x07\x04C\x03\x01\x02\
    \x02\x05\x12\x04\xe5\x07\x19\x1f\n\x0f\n\x07\x04C\x03\x01\x02\x02\x01\
    \x12\x04\xe5\x07\x200\n\x0f\n\x07\x04C\x03\x01\x02\x02\x03\x12\x04\xe5\
    \x0734\n\x0e\n\x06\x04C\x03\x01\x02\x03\x12\x04\xe6\x07\x108\n\x0f\n\x07\
    \x04C\x03\x01\x02\x03\x04\x12\x04\xe6\x07\x10\x18\n\x0f\n\x07\x04C\x03\
    \x01\x02\x03\x05\x12\x04\xe6\x07\x19\x1f\n\x0f\n\x07\x04C\x03\x01\x02\
    \x03\x01\x12\x04\xe6\x07\x203\n\x0f\n\x07\x04C\x03\x01\x02\x03\x03\x12\
    \x04\xe6\x0767\n\x0e\n\x06\x04C\x03\x01\x02\x04\x12\x04\xe7\x07\x107\n\
    \x0f\n\x07\x04C\x03\x01\x02\x04\x04\x12\x04\xe7\x07\x10\x18\n\x0f\n\x07\
    \x04C\x03\x01\x02\x04\x05\x12\x04\xe7\x07\x19\x1f\n\x0f\n\x07\x04C\x03\
    \x01\x02\x04\x01\x12\x04\xe7\x07\x202\n\x0f\n\x07\x04C\x03\x01\x02\x04\
    \x03\x12\x04\xe7\x0756\n\x0e\n\x06\x04C\x03\x01\x02\x05\x12\x04\xe8\x07\
    \x103\n\x0f\n\x07\x04C\x03\x01\x02\x05\x04\x12\x04\xe8\x07\x10\x18\n\x0f\
    \n\x07\x04C\x03\x01\x02\x05\x05\x12\x04\xe8\x07\x19\x1f\n\x0f\n\x07\x04C\
    \x03\x01\x02\x05\x01\x12\x04\xe8\x07\x20.\n\x0f\n\x07\x04C\x03\x01\x02\
    \x05\x03\x12\x04\xe8\x0712\n\x0e\n\x06\x04C\x03\x01\x02\x06\x12\x04\xe9\
    \x07\x10*\n\x0f\n\x07\x04C\x03\x01\x02\x06\x04\x12\x04\xe9\x07\x10\x18\n\
    \x0f\n\x07\x04C\x03\x01\x02\x06\x05\x12\x04\xe9\x07\x19\x1f\n\x0f\n\x07\
    \x04C\x03\x01\x02\x06\x01\x12\x04\xe9\x07\x20%\n\x0f\n\x07\x04C\x03\x01\
    \x02\x06\x03\x12\x04\xe9\x07()\n\x0e\n\x06\x04C\x03\x01\x02\x07\x12\x04\
    \xea\x07\x108\n\x0f\n\x07\x04C\x03\x01\x02\x07\x04\x12\x04\xea\x07\x10\
    \x18\n\x0f\n\x07\x04C\x03\x01\x02\x07\x05\x12\x04\xea\x07\x19\x1f\n\x0f\
    \n\x07\x04C\x03\x01\x02\x07\x01\x12\x04\xea\x07\x203\n\x0f\n\x07\x04C\
    \x03\x01\x02\x07\x03\x12\x04\xea\x0767\n\x0e\n\x06\x04C\x03\x01\x02\x08\
    \x12\x04\xeb\x07\x107\n\x0f\n\x07\x04C\x03\x01\x02\x08\x04\x12\x04\xeb\
    \x07\x10\x18\n\x0f\n\x07\x04C\x03\x01\x02\x08\x05\x12\x04\xeb\x07\x19\
    \x1f\n\x0f\n\x07\x04C\x03\x01\x02\x08\x01\x12\x04\xeb\x07\x202\n\x0f\n\
    \x07\x04C\x03\x01\x02\x08\x03\x12\x04\xeb\x0756\n\x0e\n\x06\x04C\x03\x01\
    \x02\t\x12\x04\xec\x07\x108\n\x0f\n\x07\x04C\x03\x01\x02\t\x04\x12\x04\
    \xec\x07\x10\x18\n\x0f\n\x07\x04C\x03\x01\x02\t\x05\x12\x04\xec\x07\x19\
    \x1f\n\x0f\n\x07\x04C\x03\x01\x02\t\x01\x12\x04\xec\x07\x202\n\x0f\n\x07\
    \x04C\x03\x01\x02\t\x03\x12\x04\xec\x0757\n\x0e\n\x04\x04C\x03\x02\x12\
    \x06\xef\x07\x08\xf3\x07\t\n\r\n\x05\x04C\x03\x02\x01\x12\x04\xef\x07\
    \x10\x1a\n\x0e\n\x06\x04C\x03\x02\x02\0\x12\x04\xf0\x07\x10.\n\x0f\n\x07\
    \x04C\x03\x02\x02\0\x04\x12\x04\xf0\x07\x10\x18\n\x0f\n\x07\x04C\x03\x02\
    \x02\0\x05\x12\x04\xf0\x07\x19\x1f\n\x0f\n\x07\x04C\x03\x02\x02\0\x01\
    \x12\x04\xf0\x07\x20)\n\x0f\n\x07\x04C\x03\x02\x02\0\x03\x12\x04\xf0\x07\
    ,-\n\x0e\n\x06\x04C\x03\x02\x02\x01\x12\x04\xf1\x07\x10U\n\x0f\n\x07\x04\
    C\x03\x02\x02\x01\x04\x12\x04\xf1\x07\x10\x18\n\x0f\n\x07\x04C\x03\x02\
    \x02\x01\x06\x12\x04\xf1\x07\x19B\n\x0f\n\x07\x04C\x03\x02\x02\x01\x01\
    \x12\x04\xf1\x07CP\n\x0f\n\x07\x04C\x03\x02\x02\x01\x03\x12\x04\xf1\x07S\
    T\n\x0e\n\x06\x04C\x03\x02\x02\x02\x12\x04\xf2\x07\x10R\n\x0f\n\x07\x04C\
    \x03\x02\x02\x02\x04\x12\x04\xf2\x07\x10\x18\n\x0f\n\x07\x04C\x03\x02\
    \x02\x02\x06\x12\x04\xf2\x07\x19B\n\x0f\n\x07\x04C\x03\x02\x02\x02\x01\
    \x12\x04\xf2\x07CM\n\x0f\n\x07\x04C\x03\x02\x02\x02\x03\x12\x04\xf2\x07P\
    Q\n\x0c\n\x04\x04C\x02\0\x12\x04\xf5\x07\x08%\n\r\n\x05\x04C\x02\0\x04\
    \x12\x04\xf5\x07\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\xf5\x07\x11\
    \x17\n\r\n\x05\x04C\x02\0\x01\x12\x04\xf5\x07\x18\x20\n\r\n\x05\x04C\x02\
    \0\x03\x12\x04\xf5\x07#$\n\x0c\n\x04\x04C\x02\x01\x12\x04\xf6\x07\x08&\n\
    \r\n\x05\x04C\x02\x01\x04\x12\x04\xf6\x07\x08\x10\n\r\n\x05\x04C\x02\x01\
    \x05\x12\x04\xf6\x07\x11\x15\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xf6\x07\
    \x16!\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xf6\x07$%\n\x0c\n\x04\x04C\x02\
    \x02\x12\x04\xf7\x07\x08\x20\n\r\n\x05\x04C\x02\x02\x04\x12\x04\xf7\x07\
    \x08\x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xf7\x07\x11\x17\n\r\n\x05\
    \x04C\x02\x02\x01\x12\x04\xf7\x07\x18\x1b\n\r\n\x05\x04C\x02\x02\x03\x12\
    \x04\xf7\x07\x1e\x1f\n\x0c\n\x04\x04C\x02\x03\x12\x04\xf8\x07\x08M\n\r\n\
    \x05\x04C\x02\x03\x04\x12\x04\xf8\x07\x08\x10\n\r\n\x05\x04C\x02\x03\x06\
    \x12\x04\xf8\x07\x11;\n\r\n\x05\x04C\x02\x03\x01\x12\x04\xf8\x07<H\n\r\n\
    \x05\x04C\x02\x03\x03\x12\x04\xf8\x07KL\n\x0c\n\x02\x04D\x12\x06\xfb\x07\
    \0\xff\x07\x01\n\x0b\n\x03\x04D\x01\x12\x04\xfb\x07\x08\"\n\x0c\n\x04\
    \x04D\x02\0\x12\x04\xfc\x07\x08L\n\r\n\x05\x04D\x02\0\x04\x12\x04\xfc\
    \x07\x08\x10\n\r\n\x05\x04D\x02\0\x06\x12\x04\xfc\x07\x11;\n\r\n\x05\x04\
    D\x02\0\x01\x12\x04\xfc\x07<G\n\r\n\x05\x04D\x02\0\x03\x12\x04\xfc\x07JK\
    \n\x0c\n\x04\x04D\x02\x01\x12\x04\xfd\x07\x08\x20\n\r\n\x05\x04D\x02\x01\
    \x04\x12\x04\xfd\x07\x08\x10\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xfd\x07\
    \x11\x17\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xfd\x07\x18\x1b\n\r\n\x05\
    \x04D\x02\x01\x03\x12\x04\xfd\x07\x1e\x1f\n\x0c\n\x04\x04D\x02\x02\x12\
    \x04\xfe\x07\x08&\n\r\n\x05\x04D\x02\x02\x04\x12\x04\xfe\x07\x08\x10\n\r\
    \n\x05\x04D\x02\x02\x05\x12\x04\xfe\x07\x11\x15\n\r\n\x05\x04D\x02\x02\
    \x01\x12\x04\xfe\x07\x16!\n\r\n\x05\x04D\x02\x02\x03\x12\x04\xfe\x07$%\n\
    \x0c\n\x02\x04E\x12\x06\x81\x08\0\x84\x08\x01\n\x0b\n\x03\x04E\x01\x12\
    \x04\x81\x08\x08%\n\x0c\n\x04\x04E\x02\0\x12\x04\x82\x08\x08%\n\r\n\x05\
    \x04E\x02\0\x04\x12\x04\x82\x08\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\
    \x82\x08\x11\x17\n\r\n\x05\x04E\x02\0\x01\x12\x04\x82\x08\x18\x20\n\r\n\
    \x05\x04E\x02\0\x03\x12\x04\x82\x08#$\n\x0c\n\x04\x04E\x02\x01\x12\x04\
    \x83\x08\x08\"\n\r\n\x05\x04E\x02\x01\x04\x12\x04\x83\x08\x08\x10\n\r\n\
    \x05\x04E\x02\x01\x05\x12\x04\x83\x08\x11\x17\n\r\n\x05\x04E\x02\x01\x01\
    \x12\x04\x83\x08\x18\x1d\n\r\n\x05\x04E\x02\x01\x03\x12\x04\x83\x08\x20!\
    \n\x0c\n\x02\x04F\x12\x06\x86\x08\0\x8d\x08\x01\n\x0b\n\x03\x04F\x01\x12\
    \x04\x86\x08\x08(\n\x0c\n\x04\x04F\x02\0\x12\x04\x87\x08\x08\x20\n\r\n\
    \x05\x04F\x02\0\x04\x12\x04\x87\x08\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\
    \x04\x87\x08\x11\x17\n\r\n\x05\x04F\x02\0\x01\x12\x04\x87\x08\x18\x1b\n\
    \r\n\x05\x04F\x02\0\x03\x12\x04\x87\x08\x1e\x1f\n\x0c\n\x04\x04F\x02\x01\
    \x12\x04\x88\x08\x08$\n\r\n\x05\x04F\x02\x01\x04\x12\x04\x88\x08\x08\x10\
    \n\r\n\x05\x04F\x02\x01\x05\x12\x04\x88\x08\x11\x17\n\r\n\x05\x04F\x02\
    \x01\x01\x12\x04\x88\x08\x18\x1f\n\r\n\x05\x04F\x02\x01\x03\x12\x04\x88\
    \x08\"#\n\x0c\n\x04\x04F\x02\x02\x12\x04\x89\x08\x08+\n\r\n\x05\x04F\x02\
    \x02\x04\x12\x04\x89\x08\x08\x10\n\r\n\x05\x04F\x02\x02\x05\x12\x04\x89\
    \x08\x11\x17\n\r\n\x05\x04F\x02\x02\x01\x12\x04\x89\x08\x18&\n\r\n\x05\
    \x04F\x02\x02\x03\x12\x04\x89\x08)*\n\x0c\n\x04\x04F\x02\x03\x12\x04\x8a\
    \x08\x08!\n\r\n\x05\x04F\x02\x03\x04\x12\x04\x8a\x08\x08\x10\n\r\n\x05\
    \x04F\x02\x03\x05\x12\x04\x8a\x08\x11\x17\n\r\n\x05\x04F\x02\x03\x01\x12\
    \x04\x8a\x08\x18\x1c\n\r\n\x05\x04F\x02\x03\x03\x12\x04\x8a\x08\x1f\x20\
    \n\x0c\n\x04\x04F\x02\x04\x12\x04\x8b\x08\x08%\n\r\n\x05\x04F\x02\x04\
    \x04\x12\x04\x8b\x08\x08\x10\n\r\n\x05\x04F\x02\x04\x05\x12\x04\x8b\x08\
    \x11\x16\n\r\n\x05\x04F\x02\x04\x01\x12\x04\x8b\x08\x17\x20\n\r\n\x05\
    \x04F\x02\x04\x03\x12\x04\x8b\x08#$\n\x0c\n\x04\x04F\x02\x05\x12\x04\x8c\
    \x08\x08,\n\r\n\x05\x04F\x02\x05\x04\x12\x04\x8c\x08\x08\x10\n\r\n\x05\
    \x04F\x02\x05\x05\x12\x04\x8c\x08\x11\x16\n\r\n\x05\x04F\x02\x05\x01\x12\
    \x04\x8c\x08\x17'\n\r\n\x05\x04F\x02\x05\x03\x12\x04\x8c\x08*+\n\x0c\n\
    \x02\x04G\x12\x06\x8f\x08\0\x97\x08\x01\n\x0b\n\x03\x04G\x01\x12\x04\x8f\
    \x08\x08+\n\x0c\n\x04\x04G\x02\0\x12\x04\x90\x08\x08\x20\n\r\n\x05\x04G\
    \x02\0\x04\x12\x04\x90\x08\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\x90\
    \x08\x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\x90\x08\x18\x1b\n\r\n\x05\
    \x04G\x02\0\x03\x12\x04\x90\x08\x1e\x1f\n\x0c\n\x04\x04G\x02\x01\x12\x04\
    \x91\x08\x08!\n\r\n\x05\x04G\x02\x01\x04\x12\x04\x91\x08\x08\x10\n\r\n\
    \x05\x04G\x02\x01\x05\x12\x04\x91\x08\x11\x17\n\r\n\x05\x04G\x02\x01\x01\
    \x12\x04\x91\x08\x18\x1c\n\r\n\x05\x04G\x02\x01\x03\x12\x04\x91\x08\x1f\
    \x20\n\x0c\n\x04\x04G\x02\x02\x12\x04\x92\x08\x08#\n\r\n\x05\x04G\x02\
    \x02\x04\x12\x04\x92\x08\x08\x10\n\r\n\x05\x04G\x02\x02\x05\x12\x04\x92\
    \x08\x11\x16\n\r\n\x05\x04G\x02\x02\x01\x12\x04\x92\x08\x17\x1e\n\r\n\
    \x05\x04G\x02\x02\x03\x12\x04\x92\x08!\"\n\x0c\n\x04\x04G\x02\x03\x12\
    \x04\x93\x08\x08$\n\r\n\x05\x04G\x02\x03\x04\x12\x04\x93\x08\x08\x10\n\r\
    \n\x05\x04G\x02\x03\x05\x12\x04\x93\x08\x11\x17\n\r\n\x05\x04G\x02\x03\
    \x01\x12\x04\x93\x08\x18\x1f\n\r\n\x05\x04G\x02\x03\x03\x12\x04\x93\x08\
    \"#\n\x0c\n\x04\x04G\x02\x04\x12\x04\x94\x08\x08,\n\r\n\x05\x04G\x02\x04\
    \x04\x12\x04\x94\x08\x08\x10\n\r\n\x05\x04G\x02\x04\x05\x12\x04\x94\x08\
    \x11\x17\n\r\n\x05\x04G\x02\x04\x01\x12\x04\x94\x08\x18'\n\r\n\x05\x04G\
    \x02\x04\x03\x12\x04\x94\x08*+\n\x0c\n\x04\x04G\x02\x05\x12\x04\x95\x08\
    \x08+\n\r\n\x05\x04G\x02\x05\x04\x12\x04\x95\x08\x08\x10\n\r\n\x05\x04G\
    \x02\x05\x05\x12\x04\x95\x08\x11\x17\n\r\n\x05\x04G\x02\x05\x01\x12\x04\
    \x95\x08\x18&\n\r\n\x05\x04G\x02\x05\x03\x12\x04\x95\x08)*\n\x0c\n\x04\
    \x04G\x02\x06\x12\x04\x96\x08\x08!\n\r\n\x05\x04G\x02\x06\x04\x12\x04\
    \x96\x08\x08\x10\n\r\n\x05\x04G\x02\x06\x05\x12\x04\x96\x08\x11\x16\n\r\
    \n\x05\x04G\x02\x06\x01\x12\x04\x96\x08\x17\x1c\n\r\n\x05\x04G\x02\x06\
    \x03\x12\x04\x96\x08\x1f\x20\n\x0c\n\x02\x04H\x12\x06\x99\x08\0\xa1\x08\
    \x01\n\x0b\n\x03\x04H\x01\x12\x04\x99\x08\x08$\n\x0c\n\x04\x04H\x02\0\
    \x12\x04\x9a\x08\x08\x20\n\r\n\x05\x04H\x02\0\x04\x12\x04\x9a\x08\x08\
    \x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\x9a\x08\x11\x17\n\r\n\x05\x04H\x02\
    \0\x01\x12\x04\x9a\x08\x18\x1b\n\r\n\x05\x04H\x02\0\x03\x12\x04\x9a\x08\
    \x1e\x1f\n\x0c\n\x04\x04H\x02\x01\x12\x04\x9b\x08\x08!\n\r\n\x05\x04H\
    \x02\x01\x04\x12\x04\x9b\x08\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\x04\
    \x9b\x08\x11\x17\n\r\n\x05\x04H\x02\x01\x01\x12\x04\x9b\x08\x18\x1c\n\r\
    \n\x05\x04H\x02\x01\x03\x12\x04\x9b\x08\x1f\x20\n\x0c\n\x04\x04H\x02\x02\
    \x12\x04\x9c\x08\x08$\n\r\n\x05\x04H\x02\x02\x04\x12\x04\x9c\x08\x08\x10\
    \n\r\n\x05\x04H\x02\x02\x05\x12\x04\x9c\x08\x11\x17\n\r\n\x05\x04H\x02\
    \x02\x01\x12\x04\x9c\x08\x18\x1f\n\r\n\x05\x04H\x02\x02\x03\x12\x04\x9c\
    \x08\"#\n\x0c\n\x04\x04H\x02\x03\x12\x04\x9d\x08\x08,\n\r\n\x05\x04H\x02\
    \x03\x04\x12\x04\x9d\x08\x08\x10\n\r\n\x05\x04H\x02\x03\x05\x12\x04\x9d\
    \x08\x11\x17\n\r\n\x05\x04H\x02\x03\x01\x12\x04\x9d\x08\x18'\n\r\n\x05\
    \x04H\x02\x03\x03\x12\x04\x9d\x08*+\n\x0c\n\x04\x04H\x02\x04\x12\x04\x9e\
    \x08\x08+\n\r\n\x05\x04H\x02\x04\x04\x12\x04\x9e\x08\x08\x10\n\r\n\x05\
    \x04H\x02\x04\x05\x12\x04\x9e\x08\x11\x17\n\r\n\x05\x04H\x02\x04\x01\x12\
    \x04\x9e\x08\x18&\n\r\n\x05\x04H\x02\x04\x03\x12\x04\x9e\x08)*\n\x0c\n\
    \x04\x04H\x02\x05\x12\x04\x9f\x08\x08!\n\r\n\x05\x04H\x02\x05\x04\x12\
    \x04\x9f\x08\x08\x10\n\r\n\x05\x04H\x02\x05\x05\x12\x04\x9f\x08\x11\x16\
    \n\r\n\x05\x04H\x02\x05\x01\x12\x04\x9f\x08\x17\x1c\n\r\n\x05\x04H\x02\
    \x05\x03\x12\x04\x9f\x08\x1f\x20\n\x0c\n\x04\x04H\x02\x06\x12\x04\xa0\
    \x08\x081\n\r\n\x05\x04H\x02\x06\x04\x12\x04\xa0\x08\x08\x10\n\r\n\x05\
    \x04H\x02\x06\x05\x12\x04\xa0\x08\x11\x16\n\r\n\x05\x04H\x02\x06\x01\x12\
    \x04\xa0\x08\x17,\n\r\n\x05\x04H\x02\x06\x03\x12\x04\xa0\x08/0\n\x0c\n\
    \x02\x04I\x12\x06\xa3\x08\0\xab\x08\x01\n\x0b\n\x03\x04I\x01\x12\x04\xa3\
    \x08\x08,\n\x0c\n\x04\x04I\x02\0\x12\x04\xa4\x08\x08\x20\n\r\n\x05\x04I\
    \x02\0\x04\x12\x04\xa4\x08\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xa4\
    \x08\x11\x17\n\r\n\x05\x04I\x02\0\x01\x12\x04\xa4\x08\x18\x1b\n\r\n\x05\
    \x04I\x02\0\x03\x12\x04\xa4\x08\x1e\x1f\n\x0c\n\x04\x04I\x02\x01\x12\x04\
    \xa5\x08\x08!\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xa5\x08\x08\x10\n\r\n\
    \x05\x04I\x02\x01\x05\x12\x04\xa5\x08\x11\x17\n\r\n\x05\x04I\x02\x01\x01\
    \x12\x04\xa5\x08\x18\x1c\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xa5\x08\x1f\
    \x20\n\x0c\n\x04\x04I\x02\x02\x12\x04\xa6\x08\x08$\n\r\n\x05\x04I\x02\
    \x02\x04\x12\x04\xa6\x08\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xa6\
    \x08\x11\x17\n\r\n\x05\x04I\x02\x02\x01\x12\x04\xa6\x08\x18\x1f\n\r\n\
    \x05\x04I\x02\x02\x03\x12\x04\xa6\x08\"#\n\x0c\n\x04\x04I\x02\x03\x12\
    \x04\xa7\x08\x08,\n\r\n\x05\x04I\x02\x03\x04\x12\x04\xa7\x08\x08\x10\n\r\
    \n\x05\x04I\x02\x03\x05\x12\x04\xa7\x08\x11\x17\n\r\n\x05\x04I\x02\x03\
    \x01\x12\x04\xa7\x08\x18'\n\r\n\x05\x04I\x02\x03\x03\x12\x04\xa7\x08*+\n\
    \x0c\n\x04\x04I\x02\x04\x12\x04\xa8\x08\x08+\n\r\n\x05\x04I\x02\x04\x04\
    \x12\x04\xa8\x08\x08\x10\n\r\n\x05\x04I\x02\x04\x05\x12\x04\xa8\x08\x11\
    \x17\n\r\n\x05\x04I\x02\x04\x01\x12\x04\xa8\x08\x18&\n\r\n\x05\x04I\x02\
    \x04\x03\x12\x04\xa8\x08)*\n\x0c\n\x04\x04I\x02\x05\x12\x04\xa9\x08\x08!\
    \n\r\n\x05\x04I\x02\x05\x04\x12\x04\xa9\x08\x08\x10\n\r\n\x05\x04I\x02\
    \x05\x05\x12\x04\xa9\x08\x11\x16\n\r\n\x05\x04I\x02\x05\x01\x12\x04\xa9\
    \x08\x17\x1c\n\r\n\x05\x04I\x02\x05\x03\x12\x04\xa9\x08\x1f\x20\n\x0c\n\
    \x04\x04I\x02\x06\x12\x04\xaa\x08\x080\n\r\n\x05\x04I\x02\x06\x04\x12\
    \x04\xaa\x08\x08\x10\n\r\n\x05\x04I\x02\x06\x05\x12\x04\xaa\x08\x11\x16\
    \n\r\n\x05\x04I\x02\x06\x01\x12\x04\xaa\x08\x17+\n\r\n\x05\x04I\x02\x06\
    \x03\x12\x04\xaa\x08./\n\x0c\n\x02\x04J\x12\x06\xad\x08\0\xb3\x08\x01\n\
    \x0b\n\x03\x04J\x01\x12\x04\xad\x08\x08-\n\x0c\n\x04\x04J\x02\0\x12\x04\
    \xae\x08\x08%\n\r\n\x05\x04J\x02\0\x04\x12\x04\xae\x08\x08\x10\n\r\n\x05\
    \x04J\x02\0\x05\x12\x04\xae\x08\x11\x17\n\r\n\x05\x04J\x02\0\x01\x12\x04\
    \xae\x08\x18\x20\n\r\n\x05\x04J\x02\0\x03\x12\x04\xae\x08#$\n\x0c\n\x04\
    \x04J\x02\x01\x12\x04\xaf\x08\x08'\n\r\n\x05\x04J\x02\x01\x04\x12\x04\
    \xaf\x08\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xaf\x08\x11\x17\n\r\
    \n\x05\x04J\x02\x01\x01\x12\x04\xaf\x08\x18\"\n\r\n\x05\x04J\x02\x01\x03\
    \x12\x04\xaf\x08%&\n\x0c\n\x04\x04J\x02\x02\x12\x04\xb0\x08\x082\n\r\n\
    \x05\x04J\x02\x02\x04\x12\x04\xb0\x08\x08\x10\n\r\n\x05\x04J\x02\x02\x05\
    \x12\x04\xb0\x08\x11\x17\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xb0\x08\x18-\
    \n\r\n\x05\x04J\x02\x02\x03\x12\x04\xb0\x0801\n\x0c\n\x04\x04J\x02\x03\
    \x12\x04\xb1\x08\x08$\n\r\n\x05\x04J\x02\x03\x04\x12\x04\xb1\x08\x08\x10\
    \n\r\n\x05\x04J\x02\x03\x05\x12\x04\xb1\x08\x11\x17\n\r\n\x05\x04J\x02\
    \x03\x01\x12\x04\xb1\x08\x18\x1f\n\r\n\x05\x04J\x02\x03\x03\x12\x04\xb1\
    \x08\"#\n\x0c\n\x04\x04J\x02\x04\x12\x04\xb2\x08\x08%\n\r\n\x05\x04J\x02\
    \x04\x04\x12\x04\xb2\x08\x08\x10\n\r\n\x05\x04J\x02\x04\x05\x12\x04\xb2\
    \x08\x11\x15\n\r\n\x05\x04J\x02\x04\x01\x12\x04\xb2\x08\x16\x20\n\r\n\
    \x05\x04J\x02\x04\x03\x12\x04\xb2\x08#$\n\x0c\n\x02\x04K\x12\x06\xb5\x08\
    \0\xc6\x08\x01\n\x0b\n\x03\x04K\x01\x12\x04\xb5\x08\x08,\n\x0e\n\x04\x04\
    K\x03\0\x12\x06\xb6\x08\x08\xc1\x08\t\n\r\n\x05\x04K\x03\0\x01\x12\x04\
    \xb6\x08\x10\x1f\n\x0e\n\x06\x04K\x03\0\x02\0\x12\x04\xb7\x08\x10/\n\x0f\
    \n\x07\x04K\x03\0\x02\0\x04\x12\x04\xb7\x08\x10\x18\n\x0f\n\x07\x04K\x03\
    \0\x02\0\x05\x12\x04\xb7\x08\x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\0\x01\
    \x12\x04\xb7\x08\x20*\n\x0f\n\x07\x04K\x03\0\x02\0\x03\x12\x04\xb7\x08-.\
    \n\x0e\n\x06\x04K\x03\0\x02\x01\x12\x04\xb8\x08\x10H\n\x0f\n\x07\x04K\
    \x03\0\x02\x01\x04\x12\x04\xb8\x08\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\
    \x01\x06\x12\x04\xb8\x08\x194\n\x0f\n\x07\x04K\x03\0\x02\x01\x01\x12\x04\
    \xb8\x085C\n\x0f\n\x07\x04K\x03\0\x02\x01\x03\x12\x04\xb8\x08FG\n\x0e\n\
    \x06\x04K\x03\0\x02\x02\x12\x04\xb9\x08\x102\n\x0f\n\x07\x04K\x03\0\x02\
    \x02\x04\x12\x04\xb9\x08\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\x02\x05\x12\
    \x04\xb9\x08\x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\x02\x01\x12\x04\xb9\x08\
    \x20-\n\x0f\n\x07\x04K\x03\0\x02\x02\x03\x12\x04\xb9\x0801\n\x0e\n\x06\
    \x04K\x03\0\x02\x03\x12\x04\xba\x08\x102\n\x0f\n\x07\x04K\x03\0\x02\x03\
    \x04\x12\x04\xba\x08\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\x03\x05\x12\x04\
    \xba\x08\x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\x03\x01\x12\x04\xba\x08\x20-\
    \n\x0f\n\x07\x04K\x03\0\x02\x03\x03\x12\x04\xba\x0801\n\x0e\n\x06\x04K\
    \x03\0\x02\x04\x12\x04\xbb\x08\x109\n\x0f\n\x07\x04K\x03\0\x02\x04\x04\
    \x12\x04\xbb\x08\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\x04\x05\x12\x04\xbb\
    \x08\x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\x04\x01\x12\x04\xbb\x08\x204\n\
    \x0f\n\x07\x04K\x03\0\x02\x04\x03\x12\x04\xbb\x0878\n\x0e\n\x06\x04K\x03\
    \0\x02\x05\x12\x04\xbc\x08\x107\n\x0f\n\x07\x04K\x03\0\x02\x05\x04\x12\
    \x04\xbc\x08\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\x05\x05\x12\x04\xbc\x08\
    \x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\x05\x01\x12\x04\xbc\x08\x202\n\x0f\n\
    \x07\x04K\x03\0\x02\x05\x03\x12\x04\xbc\x0856\n\x0e\n\x06\x04K\x03\0\x02\
    \x06\x12\x04\xbd\x08\x10+\n\x0f\n\x07\x04K\x03\0\x02\x06\x04\x12\x04\xbd\
    \x08\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\x06\x05\x12\x04\xbd\x08\x19\x1d\
    \n\x0f\n\x07\x04K\x03\0\x02\x06\x01\x12\x04\xbd\x08\x1e&\n\x0f\n\x07\x04\
    K\x03\0\x02\x06\x03\x12\x04\xbd\x08)*\n\x0e\n\x06\x04K\x03\0\x02\x07\x12\
    \x04\xbe\x08\x10/\n\x0f\n\x07\x04K\x03\0\x02\x07\x04\x12\x04\xbe\x08\x10\
    \x18\n\x0f\n\x07\x04K\x03\0\x02\x07\x05\x12\x04\xbe\x08\x19\x1f\n\x0f\n\
    \x07\x04K\x03\0\x02\x07\x01\x12\x04\xbe\x08\x20*\n\x0f\n\x07\x04K\x03\0\
    \x02\x07\x03\x12\x04\xbe\x08-.\n\x0e\n\x06\x04K\x03\0\x02\x08\x12\x04\
    \xbf\x08\x10,\n\x0f\n\x07\x04K\x03\0\x02\x08\x04\x12\x04\xbf\x08\x10\x18\
    \n\x0f\n\x07\x04K\x03\0\x02\x08\x05\x12\x04\xbf\x08\x19\x1f\n\x0f\n\x07\
    \x04K\x03\0\x02\x08\x01\x12\x04\xbf\x08\x20'\n\x0f\n\x07\x04K\x03\0\x02\
    \x08\x03\x12\x04\xbf\x08*+\n\x0e\n\x06\x04K\x03\0\x02\t\x12\x04\xc0\x08\
    \x104\n\x0f\n\x07\x04K\x03\0\x02\t\x04\x12\x04\xc0\x08\x10\x18\n\x0f\n\
    \x07\x04K\x03\0\x02\t\x05\x12\x04\xc0\x08\x19\x1f\n\x0f\n\x07\x04K\x03\0\
    \x02\t\x01\x12\x04\xc0\x08\x20.\n\x0f\n\x07\x04K\x03\0\x02\t\x03\x12\x04\
    \xc0\x0813\n\x0c\n\x04\x04K\x02\0\x12\x04\xc3\x08\x08%\n\r\n\x05\x04K\
    \x02\0\x04\x12\x04\xc3\x08\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\xc3\
    \x08\x11\x17\n\r\n\x05\x04K\x02\0\x01\x12\x04\xc3\x08\x18\x20\n\r\n\x05\
    \x04K\x02\0\x03\x12\x04\xc3\x08#$\n\x0c\n\x04\x04K\x02\x01\x12\x04\xc4\
    \x08\x08)\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xc4\x08\x08\x10\n\r\n\x05\
    \x04K\x02\x01\x05\x12\x04\xc4\x08\x11\x17\n\r\n\x05\x04K\x02\x01\x01\x12\
    \x04\xc4\x08\x18$\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xc4\x08'(\n\x0c\n\
    \x04\x04K\x02\x02\x12\x04\xc5\x08\x08\\\n\r\n\x05\x04K\x02\x02\x04\x12\
    \x04\xc5\x08\x08\x10\n\r\n\x05\x04K\x02\x02\x06\x12\x04\xc5\x08\x11E\n\r\
    \n\x05\x04K\x02\x02\x01\x12\x04\xc5\x08FW\n\r\n\x05\x04K\x02\x02\x03\x12\
    \x04\xc5\x08Z[\n\x0c\n\x02\x04L\x12\x06\xc8\x08\0\xd3\x08\x01\n\x0b\n\
    \x03\x04L\x01\x12\x04\xc8\x08\x085\n\x0e\n\x04\x04L\x03\0\x12\x06\xc9\
    \x08\x08\xcc\x08\t\n\r\n\x05\x04L\x03\0\x01\x12\x04\xc9\x08\x10\x1a\n\
    \x0e\n\x06\x04L\x03\0\x02\0\x12\x04\xca\x08\x106\n\x0f\n\x07\x04L\x03\0\
    \x02\0\x04\x12\x04\xca\x08\x10\x18\n\x0f\n\x07\x04L\x03\0\x02\0\x05\x12\
    \x04\xca\x08\x19\x1f\n\x0f\n\x07\x04L\x03\0\x02\0\x01\x12\x04\xca\x08\
    \x201\n\x0f\n\x07\x04L\x03\0\x02\0\x03\x12\x04\xca\x0845\n\x0e\n\x06\x04\
    L\x03\0\x02\x01\x12\x04\xcb\x08\x104\n\x0f\n\x07\x04L\x03\0\x02\x01\x04\
    \x12\x04\xcb\x08\x10\x18\n\x0f\n\x07\x04L\x03\0\x02\x01\x05\x12\x04\xcb\
    \x08\x19\x1f\n\x0f\n\x07\x04L\x03\0\x02\x01\x01\x12\x04\xcb\x08\x20/\n\
    \x0f\n\x07\x04L\x03\0\x02\x01\x03\x12\x04\xcb\x0823\n\x0c\n\x04\x04L\x02\
    \0\x12\x04\xce\x08\x08!\n\r\n\x05\x04L\x02\0\x04\x12\x04\xce\x08\x08\x10\
    \n\r\n\x05\x04L\x02\0\x05\x12\x04\xce\x08\x11\x15\n\r\n\x05\x04L\x02\0\
    \x01\x12\x04\xce\x08\x16\x1c\n\r\n\x05\x04L\x02\0\x03\x12\x04\xce\x08\
    \x1f\x20\n\x0c\n\x04\x04L\x02\x01\x12\x04\xcf\x08\x08(\n\r\n\x05\x04L\
    \x02\x01\x04\x12\x04\xcf\x08\x08\x10\n\r\n\x05\x04L\x02\x01\x05\x12\x04\
    \xcf\x08\x11\x17\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xcf\x08\x18#\n\r\n\
    \x05\x04L\x02\x01\x03\x12\x04\xcf\x08&'\n\x0c\n\x04\x04L\x02\x02\x12\x04\
    \xd0\x08\x08/\n\r\n\x05\x04L\x02\x02\x04\x12\x04\xd0\x08\x08\x10\n\r\n\
    \x05\x04L\x02\x02\x05\x12\x04\xd0\x08\x11\x17\n\r\n\x05\x04L\x02\x02\x01\
    \x12\x04\xd0\x08\x18*\n\r\n\x05\x04L\x02\x02\x03\x12\x04\xd0\x08-.\n\x0c\
    \n\x04\x04L\x02\x03\x12\x04\xd1\x08\x08Z\n\r\n\x05\x04L\x02\x03\x04\x12\
    \x04\xd1\x08\x08\x10\n\r\n\x05\x04L\x02\x03\x06\x12\x04\xd1\x08\x11I\n\r\
    \n\x05\x04L\x02\x03\x01\x12\x04\xd1\x08JU\n\r\n\x05\x04L\x02\x03\x03\x12\
    \x04\xd1\x08XY\n\x0c\n\x04\x04L\x02\x04\x12\x04\xd2\x08\x08:\n\r\n\x05\
    \x04L\x02\x04\x04\x12\x04\xd2\x08\x08\x10\n\r\n\x05\x04L\x02\x04\x05\x12\
    \x04\xd2\x08\x11\x17\n\r\n\x05\x04L\x02\x04\x01\x12\x04\xd2\x08\x185\n\r\
    \n\x05\x04L\x02\x04\x03\x12\x04\xd2\x0889\n\x0c\n\x02\x04M\x12\x06\xd5\
    \x08\0\xd7\x08\x01\n\x0b\n\x03\x04M\x01\x12\x04\xd5\x08\x08(\n\x0c\n\x04\
    \x04M\x02\0\x12\x04\xd6\x08\x08,\n\r\n\x05\x04M\x02\0\x04\x12\x04\xd6\
    \x08\x08\x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\xd6\x08\x11\x17\n\r\n\x05\
    \x04M\x02\0\x01\x12\x04\xd6\x08\x18'\n\r\n\x05\x04M\x02\0\x03\x12\x04\
    \xd6\x08*+\n\x0c\n\x02\x04N\x12\x06\xd9\x08\0\x90\t\x01\n\x0b\n\x03\x04N\
    \x01\x12\x04\xd9\x08\x08\x1d\n\x0e\n\x04\x04N\x03\0\x12\x06\xda\x08\x08\
    \xfa\x08\t\n\r\n\x05\x04N\x03\0\x01\x12\x04\xda\x08\x10\x1f\n\x0e\n\x06\
    \x04N\x03\0\x02\0\x12\x04\xdb\x08\x106\n\x0f\n\x07\x04N\x03\0\x02\0\x04\
    \x12\x04\xdb\x08\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\0\x05\x12\x04\xdb\
    \x08\x19\x1f\n\x0f\n\x07\x04N\x03\0\x02\0\x01\x12\x04\xdb\x08\x201\n\x0f\
    \n\x07\x04N\x03\0\x02\0\x03\x12\x04\xdb\x0845\n\x0e\n\x06\x04N\x03\0\x02\
    \x01\x12\x04\xdc\x08\x103\n\x0f\n\x07\x04N\x03\0\x02\x01\x04\x12\x04\xdc\
    \x08\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\x01\x05\x12\x04\xdc\x08\x19\x1f\
    \n\x0f\n\x07\x04N\x03\0\x02\x01\x01\x12\x04\xdc\x08\x20.\n\x0f\n\x07\x04\
    N\x03\0\x02\x01\x03\x12\x04\xdc\x0812\n\x0e\n\x06\x04N\x03\0\x02\x02\x12\
    \x04\xdd\x08\x10*\n\x0f\n\x07\x04N\x03\0\x02\x02\x04\x12\x04\xdd\x08\x10\
    \x18\n\x0f\n\x07\x04N\x03\0\x02\x02\x05\x12\x04\xdd\x08\x19\x1f\n\x0f\n\
    \x07\x04N\x03\0\x02\x02\x01\x12\x04\xdd\x08\x20%\n\x0f\n\x07\x04N\x03\0\
    \x02\x02\x03\x12\x04\xdd\x08()\n\x0e\n\x06\x04N\x03\0\x02\x03\x12\x04\
    \xde\x08\x10.\n\x0f\n\x07\x04N\x03\0\x02\x03\x04\x12\x04\xde\x08\x10\x18\
    \n\x0f\n\x07\x04N\x03\0\x02\x03\x05\x12\x04\xde\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x03\x01\x12\x04\xde\x08\x20)\n\x0f\n\x07\x04N\x03\0\x02\
    \x03\x03\x12\x04\xde\x08,-\n\x0e\n\x06\x04N\x03\0\x02\x04\x12\x04\xdf\
    \x08\x100\n\x0f\n\x07\x04N\x03\0\x02\x04\x04\x12\x04\xdf\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x04\x05\x12\x04\xdf\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x04\x01\x12\x04\xdf\x08\x20+\n\x0f\n\x07\x04N\x03\0\x02\
    \x04\x03\x12\x04\xdf\x08./\n\x0e\n\x06\x04N\x03\0\x02\x05\x12\x04\xe0\
    \x08\x10:\n\x0f\n\x07\x04N\x03\0\x02\x05\x04\x12\x04\xe0\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x05\x05\x12\x04\xe0\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x05\x01\x12\x04\xe0\x08\x205\n\x0f\n\x07\x04N\x03\0\x02\
    \x05\x03\x12\x04\xe0\x0889\n\x0e\n\x06\x04N\x03\0\x02\x06\x12\x04\xe1\
    \x08\x100\n\x0f\n\x07\x04N\x03\0\x02\x06\x04\x12\x04\xe1\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x06\x05\x12\x04\xe1\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x06\x01\x12\x04\xe1\x08\x20+\n\x0f\n\x07\x04N\x03\0\x02\
    \x06\x03\x12\x04\xe1\x08./\n\x0e\n\x06\x04N\x03\0\x02\x07\x12\x04\xe2\
    \x08\x101\n\x0f\n\x07\x04N\x03\0\x02\x07\x04\x12\x04\xe2\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x07\x05\x12\x04\xe2\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x07\x01\x12\x04\xe2\x08\x20,\n\x0f\n\x07\x04N\x03\0\x02\
    \x07\x03\x12\x04\xe2\x08/0\n\x0e\n\x06\x04N\x03\0\x02\x08\x12\x04\xe3\
    \x08\x10/\n\x0f\n\x07\x04N\x03\0\x02\x08\x04\x12\x04\xe3\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x08\x05\x12\x04\xe3\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x08\x01\x12\x04\xe3\x08\x20*\n\x0f\n\x07\x04N\x03\0\x02\
    \x08\x03\x12\x04\xe3\x08-.\n\x0e\n\x06\x04N\x03\0\x02\t\x12\x04\xe4\x08\
    \x10G\n\x0f\n\x07\x04N\x03\0\x02\t\x04\x12\x04\xe4\x08\x10\x18\n\x0f\n\
    \x07\x04N\x03\0\x02\t\x05\x12\x04\xe4\x08\x19\x1e\n\x0f\n\x07\x04N\x03\0\
    \x02\t\x01\x12\x04\xe4\x08\x1fA\n\x0f\n\x07\x04N\x03\0\x02\t\x03\x12\x04\
    \xe4\x08DF\n\x0e\n\x06\x04N\x03\0\x02\n\x12\x04\xe5\x08\x10H\n\x0f\n\x07\
    \x04N\x03\0\x02\n\x04\x12\x04\xe5\x08\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\
    \n\x05\x12\x04\xe5\x08\x19\x1e\n\x0f\n\x07\x04N\x03\0\x02\n\x01\x12\x04\
    \xe5\x08\x1fB\n\x0f\n\x07\x04N\x03\0\x02\n\x03\x12\x04\xe5\x08EG\n\x0e\n\
    \x06\x04N\x03\0\x02\x0b\x12\x04\xe6\x08\x10F\n\x0f\n\x07\x04N\x03\0\x02\
    \x0b\x04\x12\x04\xe6\x08\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\x0b\x05\x12\
    \x04\xe6\x08\x19\x1e\n\x0f\n\x07\x04N\x03\0\x02\x0b\x01\x12\x04\xe6\x08\
    \x1f@\n\x0f\n\x07\x04N\x03\0\x02\x0b\x03\x12\x04\xe6\x08CE\n\x0e\n\x06\
    \x04N\x03\0\x02\x0c\x12\x04\xe7\x08\x10G\n\x0f\n\x07\x04N\x03\0\x02\x0c\
    \x04\x12\x04\xe7\x08\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\x0c\x05\x12\x04\
    \xe7\x08\x19\x1e\n\x0f\n\x07\x04N\x03\0\x02\x0c\x01\x12\x04\xe7\x08\x1fA\
    \n\x0f\n\x07\x04N\x03\0\x02\x0c\x03\x12\x04\xe7\x08DF\n\x0e\n\x06\x04N\
    \x03\0\x02\r\x12\x04\xe8\x08\x109\n\x0f\n\x07\x04N\x03\0\x02\r\x04\x12\
    \x04\xe8\x08\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\r\x05\x12\x04\xe8\x08\
    \x19\x1e\n\x0f\n\x07\x04N\x03\0\x02\r\x01\x12\x04\xe8\x08\x1f3\n\x0f\n\
    \x07\x04N\x03\0\x02\r\x03\x12\x04\xe8\x0868\n\x0e\n\x06\x04N\x03\0\x02\
    \x0e\x12\x04\xe9\x08\x10:\n\x0f\n\x07\x04N\x03\0\x02\x0e\x04\x12\x04\xe9\
    \x08\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\x0e\x05\x12\x04\xe9\x08\x19\x1e\
    \n\x0f\n\x07\x04N\x03\0\x02\x0e\x01\x12\x04\xe9\x08\x1f4\n\x0f\n\x07\x04\
    N\x03\0\x02\x0e\x03\x12\x04\xe9\x0879\n\x0e\n\x06\x04N\x03\0\x02\x0f\x12\
    \x04\xea\x08\x100\n\x0f\n\x07\x04N\x03\0\x02\x0f\x04\x12\x04\xea\x08\x10\
    \x18\n\x0f\n\x07\x04N\x03\0\x02\x0f\x05\x12\x04\xea\x08\x19\x1f\n\x0f\n\
    \x07\x04N\x03\0\x02\x0f\x01\x12\x04\xea\x08\x20*\n\x0f\n\x07\x04N\x03\0\
    \x02\x0f\x03\x12\x04\xea\x08-/\n\x0e\n\x06\x04N\x03\0\x02\x10\x12\x04\
    \xeb\x08\x102\n\x0f\n\x07\x04N\x03\0\x02\x10\x04\x12\x04\xeb\x08\x10\x18\
    \n\x0f\n\x07\x04N\x03\0\x02\x10\x05\x12\x04\xeb\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x10\x01\x12\x04\xeb\x08\x20,\n\x0f\n\x07\x04N\x03\0\x02\
    \x10\x03\x12\x04\xeb\x08/1\n\x0e\n\x06\x04N\x03\0\x02\x11\x12\x04\xec\
    \x08\x10;\n\x0f\n\x07\x04N\x03\0\x02\x11\x04\x12\x04\xec\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x11\x05\x12\x04\xec\x08\x19\x1e\n\x0f\n\x07\
    \x04N\x03\0\x02\x11\x01\x12\x04\xec\x08\x1f5\n\x0f\n\x07\x04N\x03\0\x02\
    \x11\x03\x12\x04\xec\x088:\n\x0e\n\x06\x04N\x03\0\x02\x12\x12\x04\xed\
    \x08\x10+\n\x0f\n\x07\x04N\x03\0\x02\x12\x04\x12\x04\xed\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x12\x05\x12\x04\xed\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x12\x01\x12\x04\xed\x08\x20%\n\x0f\n\x07\x04N\x03\0\x02\
    \x12\x03\x12\x04\xed\x08(*\n\x0e\n\x06\x04N\x03\0\x02\x13\x12\x04\xee\
    \x08\x10,\n\x0f\n\x07\x04N\x03\0\x02\x13\x04\x12\x04\xee\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x13\x05\x12\x04\xee\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x13\x01\x12\x04\xee\x08\x20&\n\x0f\n\x07\x04N\x03\0\x02\
    \x13\x03\x12\x04\xee\x08)+\n\x0e\n\x06\x04N\x03\0\x02\x14\x12\x04\xef\
    \x08\x10-\n\x0f\n\x07\x04N\x03\0\x02\x14\x04\x12\x04\xef\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x14\x05\x12\x04\xef\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x14\x01\x12\x04\xef\x08\x20'\n\x0f\n\x07\x04N\x03\0\x02\
    \x14\x03\x12\x04\xef\x08*,\n\x0e\n\x06\x04N\x03\0\x02\x15\x12\x04\xf0\
    \x08\x105\n\x0f\n\x07\x04N\x03\0\x02\x15\x04\x12\x04\xf0\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x15\x05\x12\x04\xf0\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x15\x01\x12\x04\xf0\x08\x20/\n\x0f\n\x07\x04N\x03\0\x02\
    \x15\x03\x12\x04\xf0\x0824\n\x0e\n\x06\x04N\x03\0\x02\x16\x12\x04\xf1\
    \x08\x106\n\x0f\n\x07\x04N\x03\0\x02\x16\x04\x12\x04\xf1\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x16\x05\x12\x04\xf1\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x16\x01\x12\x04\xf1\x08\x200\n\x0f\n\x07\x04N\x03\0\x02\
    \x16\x03\x12\x04\xf1\x0835\n\x0e\n\x06\x04N\x03\0\x02\x17\x12\x04\xf2\
    \x08\x101\n\x0f\n\x07\x04N\x03\0\x02\x17\x04\x12\x04\xf2\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x17\x05\x12\x04\xf2\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x17\x01\x12\x04\xf2\x08\x20+\n\x0f\n\x07\x04N\x03\0\x02\
    \x17\x03\x12\x04\xf2\x08.0\n\x0e\n\x06\x04N\x03\0\x02\x18\x12\x04\xf3\
    \x08\x103\n\x0f\n\x07\x04N\x03\0\x02\x18\x04\x12\x04\xf3\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x18\x05\x12\x04\xf3\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x18\x01\x12\x04\xf3\x08\x20-\n\x0f\n\x07\x04N\x03\0\x02\
    \x18\x03\x12\x04\xf3\x0802\n\x0e\n\x06\x04N\x03\0\x02\x19\x12\x04\xf4\
    \x08\x104\n\x0f\n\x07\x04N\x03\0\x02\x19\x04\x12\x04\xf4\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x19\x05\x12\x04\xf4\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x19\x01\x12\x04\xf4\x08\x20.\n\x0f\n\x07\x04N\x03\0\x02\
    \x19\x03\x12\x04\xf4\x0813\n\x0e\n\x06\x04N\x03\0\x02\x1a\x12\x04\xf5\
    \x08\x10.\n\x0f\n\x07\x04N\x03\0\x02\x1a\x04\x12\x04\xf5\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x1a\x05\x12\x04\xf5\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x1a\x01\x12\x04\xf5\x08\x20(\n\x0f\n\x07\x04N\x03\0\x02\
    \x1a\x03\x12\x04\xf5\x08+-\n\x0e\n\x06\x04N\x03\0\x02\x1b\x12\x04\xf6\
    \x08\x103\n\x0f\n\x07\x04N\x03\0\x02\x1b\x04\x12\x04\xf6\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x1b\x05\x12\x04\xf6\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x1b\x01\x12\x04\xf6\x08\x20-\n\x0f\n\x07\x04N\x03\0\x02\
    \x1b\x03\x12\x04\xf6\x0802\n\x0e\n\x06\x04N\x03\0\x02\x1c\x12\x04\xf7\
    \x08\x100\n\x0f\n\x07\x04N\x03\0\x02\x1c\x04\x12\x04\xf7\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x1c\x05\x12\x04\xf7\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x1c\x01\x12\x04\xf7\x08\x20*\n\x0f\n\x07\x04N\x03\0\x02\
    \x1c\x03\x12\x04\xf7\x08-/\n\x0e\n\x06\x04N\x03\0\x02\x1d\x12\x04\xf8\
    \x08\x107\n\x0f\n\x07\x04N\x03\0\x02\x1d\x04\x12\x04\xf8\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x1d\x05\x12\x04\xf8\x08\x19\x1e\n\x0f\n\x07\
    \x04N\x03\0\x02\x1d\x01\x12\x04\xf8\x08\x1f1\n\x0f\n\x07\x04N\x03\0\x02\
    \x1d\x03\x12\x04\xf8\x0846\n\x0e\n\x06\x04N\x03\0\x02\x1e\x12\x04\xf9\
    \x08\x100\n\x0f\n\x07\x04N\x03\0\x02\x1e\x04\x12\x04\xf9\x08\x10\x18\n\
    \x0f\n\x07\x04N\x03\0\x02\x1e\x05\x12\x04\xf9\x08\x19\x1f\n\x0f\n\x07\
    \x04N\x03\0\x02\x1e\x01\x12\x04\xf9\x08\x20*\n\x0f\n\x07\x04N\x03\0\x02\
    \x1e\x03\x12\x04\xf9\x08-/\n\x0e\n\x04\x04N\x03\x01\x12\x06\xfc\x08\x08\
    \x80\t\t\n\r\n\x05\x04N\x03\x01\x01\x12\x04\xfc\x08\x10\x19\n\x0e\n\x06\
    \x04N\x03\x01\x02\0\x12\x04\xfd\x08\x108\n\x0f\n\x07\x04N\x03\x01\x02\0\
    \x04\x12\x04\xfd\x08\x10\x18\n\x0f\n\x07\x04N\x03\x01\x02\0\x05\x12\x04\
    \xfd\x08\x19\x1f\n\x0f\n\x07\x04N\x03\x01\x02\0\x01\x12\x04\xfd\x08\x203\
    \n\x0f\n\x07\x04N\x03\x01\x02\0\x03\x12\x04\xfd\x0867\n\x0e\n\x06\x04N\
    \x03\x01\x02\x01\x12\x04\xfe\x08\x108\n\x0f\n\x07\x04N\x03\x01\x02\x01\
    \x04\x12\x04\xfe\x08\x10\x18\n\x0f\n\x07\x04N\x03\x01\x02\x01\x05\x12\
    \x04\xfe\x08\x19\x1f\n\x0f\n\x07\x04N\x03\x01\x02\x01\x01\x12\x04\xfe\
    \x08\x203\n\x0f\n\x07\x04N\x03\x01\x02\x01\x03\x12\x04\xfe\x0867\n\x0e\n\
    \x06\x04N\x03\x01\x02\x02\x12\x04\xff\x08\x108\n\x0f\n\x07\x04N\x03\x01\
    \x02\x02\x04\x12\x04\xff\x08\x10\x18\n\x0f\n\x07\x04N\x03\x01\x02\x02\
    \x05\x12\x04\xff\x08\x19\x1f\n\x0f\n\x07\x04N\x03\x01\x02\x02\x01\x12\
    \x04\xff\x08\x203\n\x0f\n\x07\x04N\x03\x01\x02\x02\x03\x12\x04\xff\x0867\
    \n\x0e\n\x04\x04N\x03\x02\x12\x06\x82\t\x08\x85\t\t\n\r\n\x05\x04N\x03\
    \x02\x01\x12\x04\x82\t\x10\x1b\n\x0e\n\x06\x04N\x03\x02\x02\0\x12\x04\
    \x83\t\x10+\n\x0f\n\x07\x04N\x03\x02\x02\0\x04\x12\x04\x83\t\x10\x18\n\
    \x0f\n\x07\x04N\x03\x02\x02\0\x05\x12\x04\x83\t\x19\x1f\n\x0f\n\x07\x04N\
    \x03\x02\x02\0\x01\x12\x04\x83\t\x20&\n\x0f\n\x07\x04N\x03\x02\x02\0\x03\
    \x12\x04\x83\t)*\n\x0e\n\x06\x04N\x03\x02\x02\x01\x12\x04\x84\t\x10I\n\
    \x0f\n\x07\x04N\x03\x02\x02\x01\x04\x12\x04\x84\t\x10\x18\n\x0f\n\x07\
    \x04N\x03\x02\x02\x01\x06\x12\x04\x84\t\x19>\n\x0f\n\x07\x04N\x03\x02\
    \x02\x01\x01\x12\x04\x84\t?D\n\x0f\n\x07\x04N\x03\x02\x02\x01\x03\x12\
    \x04\x84\tGH\n\x0e\n\x04\x04N\x03\x03\x12\x06\x87\t\x08\x8b\t\t\n\r\n\
    \x05\x04N\x03\x03\x01\x12\x04\x87\t\x10\x1a\n\x0e\n\x06\x04N\x03\x03\x02\
    \0\x12\x04\x88\t\x10/\n\x0f\n\x07\x04N\x03\x03\x02\0\x04\x12\x04\x88\t\
    \x10\x18\n\x0f\n\x07\x04N\x03\x03\x02\0\x05\x12\x04\x88\t\x19\x1f\n\x0f\
    \n\x07\x04N\x03\x03\x02\0\x01\x12\x04\x88\t\x20*\n\x0f\n\x07\x04N\x03\
    \x03\x02\0\x03\x12\x04\x88\t-.\n\x0e\n\x06\x04N\x03\x03\x02\x01\x12\x04\
    \x89\t\x10,\n\x0f\n\x07\x04N\x03\x03\x02\x01\x04\x12\x04\x89\t\x10\x18\n\
    \x0f\n\x07\x04N\x03\x03\x02\x01\x05\x12\x04\x89\t\x19\x1f\n\x0f\n\x07\
    \x04N\x03\x03\x02\x01\x01\x12\x04\x89\t\x20'\n\x0f\n\x07\x04N\x03\x03\
    \x02\x01\x03\x12\x04\x89\t*+\n\x0e\n\x06\x04N\x03\x03\x02\x02\x12\x04\
    \x8a\t\x100\n\x0f\n\x07\x04N\x03\x03\x02\x02\x04\x12\x04\x8a\t\x10\x18\n\
    \x0f\n\x07\x04N\x03\x03\x02\x02\x05\x12\x04\x8a\t\x19\x1f\n\x0f\n\x07\
    \x04N\x03\x03\x02\x02\x01\x12\x04\x8a\t\x20+\n\x0f\n\x07\x04N\x03\x03\
    \x02\x02\x03\x12\x04\x8a\t./\n\x0c\n\x04\x04N\x02\0\x12\x04\x8d\t\x08?\n\
    \r\n\x05\x04N\x02\0\x04\x12\x04\x8d\t\x08\x10\n\r\n\x05\x04N\x02\0\x06\
    \x12\x04\x8d\t\x112\n\r\n\x05\x04N\x02\0\x01\x12\x04\x8d\t3:\n\r\n\x05\
    \x04N\x02\0\x03\x12\x04\x8d\t=>\n\x0c\n\x04\x04N\x02\x01\x12\x04\x8e\t\
    \x08B\n\r\n\x05\x04N\x02\x01\x04\x12\x04\x8e\t\x08\x10\n\r\n\x05\x04N\
    \x02\x01\x06\x12\x04\x8e\t\x111\n\r\n\x05\x04N\x02\x01\x01\x12\x04\x8e\t\
    2=\n\r\n\x05\x04N\x02\x01\x03\x12\x04\x8e\t@A\n\x0c\n\x04\x04N\x02\x02\
    \x12\x04\x8f\t\x08@\n\r\n\x05\x04N\x02\x02\x04\x12\x04\x8f\t\x08\x10\n\r\
    \n\x05\x04N\x02\x02\x06\x12\x04\x8f\t\x110\n\r\n\x05\x04N\x02\x02\x01\
    \x12\x04\x8f\t1;\n\r\n\x05\x04N\x02\x02\x03\x12\x04\x8f\t>?\n\x0c\n\x02\
    \x04O\x12\x06\x92\t\0\x9d\t\x01\n\x0b\n\x03\x04O\x01\x12\x04\x92\t\x08\
    \x1c\n\x0e\n\x04\x04O\x03\0\x12\x06\x93\t\x08\x9a\t\t\n\r\n\x05\x04O\x03\
    \0\x01\x12\x04\x93\t\x10\x1b\n\x0e\n\x06\x04O\x03\0\x02\0\x12\x04\x94\t\
    \x10+\n\x0f\n\x07\x04O\x03\0\x02\0\x04\x12\x04\x94\t\x10\x18\n\x0f\n\x07\
    \x04O\x03\0\x02\0\x05\x12\x04\x94\t\x19\x1e\n\x0f\n\x07\x04O\x03\0\x02\0\
    \x01\x12\x04\x94\t\x1f&\n\x0f\n\x07\x04O\x03\0\x02\0\x03\x12\x04\x94\t)*\
    \n\x0e\n\x06\x04O\x03\0\x02\x01\x12\x04\x95\t\x101\n\x0f\n\x07\x04O\x03\
    \0\x02\x01\x04\x12\x04\x95\t\x10\x18\n\x0f\n\x07\x04O\x03\0\x02\x01\x05\
    \x12\x04\x95\t\x19\x1f\n\x0f\n\x07\x04O\x03\0\x02\x01\x01\x12\x04\x95\t\
    \x20,\n\x0f\n\x07\x04O\x03\0\x02\x01\x03\x12\x04\x95\t/0\n\x0e\n\x06\x04\
    O\x03\0\x02\x02\x12\x04\x96\t\x10)\n\x0f\n\x07\x04O\x03\0\x02\x02\x04\
    \x12\x04\x96\t\x10\x18\n\x0f\n\x07\x04O\x03\0\x02\x02\x05\x12\x04\x96\t\
    \x19\x1f\n\x0f\n\x07\x04O\x03\0\x02\x02\x01\x12\x04\x96\t\x20$\n\x0f\n\
    \x07\x04O\x03\0\x02\x02\x03\x12\x04\x96\t'(\n\x0e\n\x06\x04O\x03\0\x02\
    \x03\x12\x04\x97\t\x107\n\x0f\n\x07\x04O\x03\0\x02\x03\x04\x12\x04\x97\t\
    \x10\x18\n\x0f\n\x07\x04O\x03\0\x02\x03\x05\x12\x04\x97\t\x19\x1f\n\x0f\
    \n\x07\x04O\x03\0\x02\x03\x01\x12\x04\x97\t\x202\n\x0f\n\x07\x04O\x03\0\
    \x02\x03\x03\x12\x04\x97\t56\n\x0e\n\x06\x04O\x03\0\x02\x04\x12\x04\x98\
    \t\x109\n\x0f\n\x07\x04O\x03\0\x02\x04\x04\x12\x04\x98\t\x10\x18\n\x0f\n\
    \x07\x04O\x03\0\x02\x04\x05\x12\x04\x98\t\x19\x1f\n\x0f\n\x07\x04O\x03\0\
    \x02\x04\x01\x12\x04\x98\t\x204\n\x0f\n\x07\x04O\x03\0\x02\x04\x03\x12\
    \x04\x98\t78\n\x0e\n\x06\x04O\x03\0\x02\x05\x12\x04\x99\t\x106\n\x0f\n\
    \x07\x04O\x03\0\x02\x05\x04\x12\x04\x99\t\x10\x18\n\x0f\n\x07\x04O\x03\0\
    \x02\x05\x05\x12\x04\x99\t\x19\x1f\n\x0f\n\x07\x04O\x03\0\x02\x05\x01\
    \x12\x04\x99\t\x201\n\x0f\n\x07\x04O\x03\0\x02\x05\x03\x12\x04\x99\t45\n\
    \x0c\n\x04\x04O\x02\0\x12\x04\x9c\t\x08D\n\r\n\x05\x04O\x02\0\x04\x12\
    \x04\x9c\t\x08\x10\n\r\n\x05\x04O\x02\0\x06\x12\x04\x9c\t\x111\n\r\n\x05\
    \x04O\x02\0\x01\x12\x04\x9c\t2?\n\r\n\x05\x04O\x02\0\x03\x12\x04\x9c\tBC\
    \n\x0c\n\x02\x04P\x12\x06\x9f\t\0\xa7\t\x01\n\x0b\n\x03\x04P\x01\x12\x04\
    \x9f\t\x08'\n\x0e\n\x04\x04P\x03\0\x12\x06\xa0\t\x08\xa4\t\t\n\r\n\x05\
    \x04P\x03\0\x01\x12\x04\xa0\t\x10\x1c\n\x0e\n\x06\x04P\x03\0\x02\0\x12\
    \x04\xa1\t\x10,\n\x0f\n\x07\x04P\x03\0\x02\0\x04\x12\x04\xa1\t\x10\x18\n\
    \x0f\n\x07\x04P\x03\0\x02\0\x05\x12\x04\xa1\t\x19\x1f\n\x0f\n\x07\x04P\
    \x03\0\x02\0\x01\x12\x04\xa1\t\x20'\n\x0f\n\x07\x04P\x03\0\x02\0\x03\x12\
    \x04\xa1\t*+\n\x0e\n\x06\x04P\x03\0\x02\x01\x12\x04\xa2\t\x10.\n\x0f\n\
    \x07\x04P\x03\0\x02\x01\x04\x12\x04\xa2\t\x10\x18\n\x0f\n\x07\x04P\x03\0\
    \x02\x01\x05\x12\x04\xa2\t\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\x01\x01\
    \x12\x04\xa2\t\x20)\n\x0f\n\x07\x04P\x03\0\x02\x01\x03\x12\x04\xa2\t,-\n\
    \x0e\n\x06\x04P\x03\0\x02\x02\x12\x04\xa3\t\x10/\n\x0f\n\x07\x04P\x03\0\
    \x02\x02\x04\x12\x04\xa3\t\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x02\x05\
    \x12\x04\xa3\t\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\x02\x01\x12\x04\xa3\t\
    \x20*\n\x0f\n\x07\x04P\x03\0\x02\x02\x03\x12\x04\xa3\t-.\n\x0c\n\x04\x04\
    P\x02\0\x12\x04\xa6\t\x08K\n\r\n\x05\x04P\x02\0\x04\x12\x04\xa6\t\x08\
    \x10\n\r\n\x05\x04P\x02\0\x06\x12\x04\xa6\t\x11=\n\r\n\x05\x04P\x02\0\
    \x01\x12\x04\xa6\t>F\n\r\n\x05\x04P\x02\0\x03\x12\x04\xa6\tIJ\n\x0c\n\
    \x02\x04Q\x12\x06\xa9\t\0\xb6\t\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xa9\t\
    \x08(\n\x0e\n\x04\x04Q\x03\0\x12\x06\xaa\t\x08\xae\t\t\n\r\n\x05\x04Q\
    \x03\0\x01\x12\x04\xaa\t\x10,\n\x0e\n\x06\x04Q\x03\0\x02\0\x12\x04\xab\t\
    \x10-\n\x0f\n\x07\x04Q\x03\0\x02\0\x04\x12\x04\xab\t\x10\x18\n\x0f\n\x07\
    \x04Q\x03\0\x02\0\x05\x12\x04\xab\t\x19\x1f\n\x0f\n\x07\x04Q\x03\0\x02\0\
    \x01\x12\x04\xab\t\x20(\n\x0f\n\x07\x04Q\x03\0\x02\0\x03\x12\x04\xab\t+,\
    \n\x0e\n\x06\x04Q\x03\0\x02\x01\x12\x04\xac\t\x10-\n\x0f\n\x07\x04Q\x03\
    \0\x02\x01\x04\x12\x04\xac\t\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\x01\x05\
    \x12\x04\xac\t\x19\x1f\n\x0f\n\x07\x04Q\x03\0\x02\x01\x01\x12\x04\xac\t\
    \x20(\n\x0f\n\x07\x04Q\x03\0\x02\x01\x03\x12\x04\xac\t+,\n\x0e\n\x06\x04\
    Q\x03\0\x02\x02\x12\x04\xad\t\x10.\n\x0f\n\x07\x04Q\x03\0\x02\x02\x04\
    \x12\x04\xad\t\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\x02\x05\x12\x04\xad\t\
    \x19\x1f\n\x0f\n\x07\x04Q\x03\0\x02\x02\x01\x12\x04\xad\t\x20)\n\x0f\n\
    \x07\x04Q\x03\0\x02\x02\x03\x12\x04\xad\t,-\n\x0e\n\x04\x04Q\x03\x01\x12\
    \x06\xb0\t\x08\xb3\t\t\n\r\n\x05\x04Q\x03\x01\x01\x12\x04\xb0\t\x10\x1e\
    \n\x0e\n\x06\x04Q\x03\x01\x02\0\x12\x04\xb1\t\x10/\n\x0f\n\x07\x04Q\x03\
    \x01\x02\0\x04\x12\x04\xb1\t\x10\x18\n\x0f\n\x07\x04Q\x03\x01\x02\0\x05\
    \x12\x04\xb1\t\x19\x1f\n\x0f\n\x07\x04Q\x03\x01\x02\0\x01\x12\x04\xb1\t\
    \x20*\n\x0f\n\x07\x04Q\x03\x01\x02\0\x03\x12\x04\xb1\t-.\n\x0e\n\x06\x04\
    Q\x03\x01\x02\x01\x12\x04\xb2\t\x10o\n\x0f\n\x07\x04Q\x03\x01\x02\x01\
    \x04\x12\x04\xb2\t\x10\x18\n\x0f\n\x07\x04Q\x03\x01\x02\x01\x06\x12\x04\
    \xb2\t\x19V\n\x0f\n\x07\x04Q\x03\x01\x02\x01\x01\x12\x04\xb2\tWj\n\x0f\n\
    \x07\x04Q\x03\x01\x02\x01\x03\x12\x04\xb2\tmn\n\x0c\n\x04\x04Q\x02\0\x12\
    \x04\xb5\t\x08V\n\r\n\x05\x04Q\x02\0\x04\x12\x04\xb5\t\x08\x10\n\r\n\x05\
    \x04Q\x02\0\x06\x12\x04\xb5\t\x11@\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xb5\
    \tAQ\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xb5\tTU\n\x0c\n\x02\x04R\x12\x06\
    \xb8\t\0\xc4\t\x01\n\x0b\n\x03\x04R\x01\x12\x04\xb8\t\x08)\n\x0e\n\x04\
    \x04R\x03\0\x12\x06\xb9\t\x08\xc1\t\t\n\r\n\x05\x04R\x03\0\x01\x12\x04\
    \xb9\t\x10!\n\x0e\n\x06\x04R\x03\0\x02\0\x12\x04\xba\t\x10-\n\x0f\n\x07\
    \x04R\x03\0\x02\0\x04\x12\x04\xba\t\x10\x18\n\x0f\n\x07\x04R\x03\0\x02\0\
    \x05\x12\x04\xba\t\x19\x1f\n\x0f\n\x07\x04R\x03\0\x02\0\x01\x12\x04\xba\
    \t\x20(\n\x0f\n\x07\x04R\x03\0\x02\0\x03\x12\x04\xba\t+,\n\x0e\n\x06\x04\
    R\x03\0\x02\x01\x12\x04\xbb\t\x10-\n\x0f\n\x07\x04R\x03\0\x02\x01\x04\
    \x12\x04\xbb\t\x10\x18\n\x0f\n\x07\x04R\x03\0\x02\x01\x05\x12\x04\xbb\t\
    \x19\x1f\n\x0f\n\x07\x04R\x03\0\x02\x01\x01\x12\x04\xbb\t\x20(\n\x0f\n\
    \x07\x04R\x03\0\x02\x01\x03\x12\x04\xbb\t+,\n\x0e\n\x06\x04R\x03\0\x02\
    \x02\x12\x04\xbc\t\x10:\n\x0f\n\x07\x04R\x03\0\x02\x02\x04\x12\x04\xbc\t\
    \x10\x18\n\x0f\n\x07\x04R\x03\0\x02\x02\x05\x12\x04\xbc\t\x19\x1f\n\x0f\
    \n\x07\x04R\x03\0\x02\x02\x01\x12\x04\xbc\t\x205\n\x0f\n\x07\x04R\x03\0\
    \x02\x02\x03\x12\x04\xbc\t89\n\x0e\n\x06\x04R\x03\0\x02\x03\x12\x04\xbd\
    \t\x10A\n\x0f\n\x07\x04R\x03\0\x02\x03\x04\x12\x04\xbd\t\x10\x18\n\x0f\n\
    \x07\x04R\x03\0\x02\x03\x05\x12\x04\xbd\t\x19\x1f\n\x0f\n\x07\x04R\x03\0\
    \x02\x03\x01\x12\x04\xbd\t\x20<\n\x0f\n\x07\x04R\x03\0\x02\x03\x03\x12\
    \x04\xbd\t?@\n\x0e\n\x06\x04R\x03\0\x02\x04\x12\x04\xbe\t\x10<\n\x0f\n\
    \x07\x04R\x03\0\x02\x04\x04\x12\x04\xbe\t\x10\x18\n\x0f\n\x07\x04R\x03\0\
    \x02\x04\x05\x12\x04\xbe\t\x19\x1f\n\x0f\n\x07\x04R\x03\0\x02\x04\x01\
    \x12\x04\xbe\t\x207\n\x0f\n\x07\x04R\x03\0\x02\x04\x03\x12\x04\xbe\t:;\n\
    \x0e\n\x06\x04R\x03\0\x02\x05\x12\x04\xbf\t\x10-\n\x0f\n\x07\x04R\x03\0\
    \x02\x05\x04\x12\x04\xbf\t\x10\x18\n\x0f\n\x07\x04R\x03\0\x02\x05\x05\
    \x12\x04\xbf\t\x19\x1f\n\x0f\n\x07\x04R\x03\0\x02\x05\x01\x12\x04\xbf\t\
    \x20(\n\x0f\n\x07\x04R\x03\0\x02\x05\x03\x12\x04\xbf\t+,\n\x0e\n\x06\x04\
    R\x03\0\x02\x06\x12\x04\xc0\t\x108\n\x0f\n\x07\x04R\x03\0\x02\x06\x04\
    \x12\x04\xc0\t\x10\x18\n\x0f\n\x07\x04R\x03\0\x02\x06\x05\x12\x04\xc0\t\
    \x19\x1f\n\x0f\n\x07\x04R\x03\0\x02\x06\x01\x12\x04\xc0\t\x203\n\x0f\n\
    \x07\x04R\x03\0\x02\x06\x03\x12\x04\xc0\t67\n\x0c\n\x04\x04R\x02\0\x12\
    \x04\xc3\t\x08e\n\r\n\x05\x04R\x02\0\x04\x12\x04\xc3\t\x08\x10\n\r\n\x05\
    \x04R\x02\0\x06\x12\x04\xc3\t\x11D\n\r\n\x05\x04R\x02\0\x01\x12\x04\xc3\
    \tE`\n\r\n\x05\x04R\x02\0\x03\x12\x04\xc3\tcd\n\x0c\n\x02\x04S\x12\x06\
    \xc6\t\0\xed\t\x01\n\x0b\n\x03\x04S\x01\x12\x04\xc6\t\x08\x1b\n\x0e\n\
    \x04\x04S\x03\0\x12\x06\xc7\t\x08\xe6\t\t\n\r\n\x05\x04S\x03\0\x01\x12\
    \x04\xc7\t\x10\x16\n\x10\n\x06\x04S\x03\0\x03\0\x12\x06\xc8\t\x10\xcb\t\
    \x11\n\x0f\n\x07\x04S\x03\0\x03\0\x01\x12\x04\xc8\t\x18&\n\x10\n\x08\x04\
    S\x03\0\x03\0\x02\0\x12\x04\xc9\t\x187\n\x11\n\t\x04S\x03\0\x03\0\x02\0\
    \x04\x12\x04\xc9\t\x18\x20\n\x11\n\t\x04S\x03\0\x03\0\x02\0\x05\x12\x04\
    \xc9\t!'\n\x11\n\t\x04S\x03\0\x03\0\x02\0\x01\x12\x04\xc9\t(2\n\x11\n\t\
    \x04S\x03\0\x03\0\x02\0\x03\x12\x04\xc9\t56\n\x10\n\x08\x04S\x03\0\x03\0\
    \x02\x01\x12\x04\xca\t\x183\n\x11\n\t\x04S\x03\0\x03\0\x02\x01\x04\x12\
    \x04\xca\t\x18\x20\n\x11\n\t\x04S\x03\0\x03\0\x02\x01\x05\x12\x04\xca\t!\
    '\n\x11\n\t\x04S\x03\0\x03\0\x02\x01\x01\x12\x04\xca\t(.\n\x11\n\t\x04S\
    \x03\0\x03\0\x02\x01\x03\x12\x04\xca\t12\n\x0e\n\x06\x04S\x03\0\x02\0\
    \x12\x04\xcd\t\x10,\n\x0f\n\x07\x04S\x03\0\x02\0\x04\x12\x04\xcd\t\x10\
    \x18\n\x0f\n\x07\x04S\x03\0\x02\0\x05\x12\x04\xcd\t\x19\x1f\n\x0f\n\x07\
    \x04S\x03\0\x02\0\x01\x12\x04\xcd\t\x20'\n\x0f\n\x07\x04S\x03\0\x02\0\
    \x03\x12\x04\xcd\t*+\n\x0e\n\x06\x04S\x03\0\x02\x01\x12\x04\xce\t\x107\n\
    \x0f\n\x07\x04S\x03\0\x02\x01\x04\x12\x04\xce\t\x10\x18\n\x0f\n\x07\x04S\
    \x03\0\x02\x01\x05\x12\x04\xce\t\x19\x1f\n\x0f\n\x07\x04S\x03\0\x02\x01\
    \x01\x12\x04\xce\t\x202\n\x0f\n\x07\x04S\x03\0\x02\x01\x03\x12\x04\xce\t\
    56\n\x0e\n\x06\x04S\x03\0\x02\x02\x12\x04\xcf\t\x10/\n\x0f\n\x07\x04S\
    \x03\0\x02\x02\x04\x12\x04\xcf\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x02\
    \x05\x12\x04\xcf\t\x19\x1f\n\x0f\n\x07\x04S\x03\0\x02\x02\x01\x12\x04\
    \xcf\t\x20*\n\x0f\n\x07\x04S\x03\0\x02\x02\x03\x12\x04\xcf\t-.\n\x0e\n\
    \x06\x04S\x03\0\x02\x03\x12\x04\xd0\t\x101\n\x0f\n\x07\x04S\x03\0\x02\
    \x03\x04\x12\x04\xd0\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x03\x05\x12\
    \x04\xd0\t\x19\x1f\n\x0f\n\x07\x04S\x03\0\x02\x03\x01\x12\x04\xd0\t\x20+\
    \n\x0f\n\x07\x04S\x03\0\x02\x03\x03\x12\x04\xd0\t.0\n\x0e\n\x06\x04S\x03\
    \0\x02\x04\x12\x04\xd1\t\x10*\n\x0f\n\x07\x04S\x03\0\x02\x04\x04\x12\x04\
    \xd1\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x04\x05\x12\x04\xd1\t\x19\x1f\
    \n\x0f\n\x07\x04S\x03\0\x02\x04\x01\x12\x04\xd1\t\x20$\n\x0f\n\x07\x04S\
    \x03\0\x02\x04\x03\x12\x04\xd1\t')\n\x0e\n\x06\x04S\x03\0\x02\x05\x12\
    \x04\xd2\t\x10,\n\x0f\n\x07\x04S\x03\0\x02\x05\x04\x12\x04\xd2\t\x10\x18\
    \n\x0f\n\x07\x04S\x03\0\x02\x05\x05\x12\x04\xd2\t\x19\x1f\n\x0f\n\x07\
    \x04S\x03\0\x02\x05\x01\x12\x04\xd2\t\x20'\n\x0f\n\x07\x04S\x03\0\x02\
    \x05\x03\x12\x04\xd2\t*+\n\x0e\n\x06\x04S\x03\0\x02\x06\x12\x04\xd3\t\
    \x10)\n\x0f\n\x07\x04S\x03\0\x02\x06\x04\x12\x04\xd3\t\x10\x18\n\x0f\n\
    \x07\x04S\x03\0\x02\x06\x05\x12\x04\xd3\t\x19\x1f\n\x0f\n\x07\x04S\x03\0\
    \x02\x06\x01\x12\x04\xd3\t\x20$\n\x0f\n\x07\x04S\x03\0\x02\x06\x03\x12\
    \x04\xd3\t'(\n\x0e\n\x06\x04S\x03\0\x02\x07\x12\x04\xd4\t\x10)\n\x0f\n\
    \x07\x04S\x03\0\x02\x07\x04\x12\x04\xd4\t\x10\x18\n\x0f\n\x07\x04S\x03\0\
    \x02\x07\x05\x12\x04\xd4\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x07\x01\
    \x12\x04\xd4\t\x1f$\n\x0f\n\x07\x04S\x03\0\x02\x07\x03\x12\x04\xd4\t'(\n\
    \x0e\n\x06\x04S\x03\0\x02\x08\x12\x04\xd5\t\x10*\n\x0f\n\x07\x04S\x03\0\
    \x02\x08\x04\x12\x04\xd5\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x08\x05\
    \x12\x04\xd5\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x08\x01\x12\x04\xd5\t\
    \x1f%\n\x0f\n\x07\x04S\x03\0\x02\x08\x03\x12\x04\xd5\t()\n\x0e\n\x06\x04\
    S\x03\0\x02\t\x12\x04\xd6\t\x10+\n\x0f\n\x07\x04S\x03\0\x02\t\x04\x12\
    \x04\xd6\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\t\x05\x12\x04\xd6\t\x19\
    \x1e\n\x0f\n\x07\x04S\x03\0\x02\t\x01\x12\x04\xd6\t\x1f&\n\x0f\n\x07\x04\
    S\x03\0\x02\t\x03\x12\x04\xd6\t)*\n\x0e\n\x06\x04S\x03\0\x02\n\x12\x04\
    \xd7\t\x10&\n\x0f\n\x07\x04S\x03\0\x02\n\x04\x12\x04\xd7\t\x10\x18\n\x0f\
    \n\x07\x04S\x03\0\x02\n\x05\x12\x04\xd7\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\
    \x02\n\x01\x12\x04\xd7\t\x1f!\n\x0f\n\x07\x04S\x03\0\x02\n\x03\x12\x04\
    \xd7\t$%\n\x0e\n\x06\x04S\x03\0\x02\x0b\x12\x04\xd8\t\x10.\n\x0f\n\x07\
    \x04S\x03\0\x02\x0b\x04\x12\x04\xd8\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\
    \x0b\x05\x12\x04\xd8\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x0b\x01\x12\
    \x04\xd8\t\x1f(\n\x0f\n\x07\x04S\x03\0\x02\x0b\x03\x12\x04\xd8\t+-\n\x0e\
    \n\x06\x04S\x03\0\x02\x0c\x12\x04\xd9\t\x107\n\x0f\n\x07\x04S\x03\0\x02\
    \x0c\x04\x12\x04\xd9\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x0c\x05\x12\
    \x04\xd9\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x0c\x01\x12\x04\xd9\t\x1f1\
    \n\x0f\n\x07\x04S\x03\0\x02\x0c\x03\x12\x04\xd9\t46\n\x0e\n\x06\x04S\x03\
    \0\x02\r\x12\x04\xda\t\x101\n\x0f\n\x07\x04S\x03\0\x02\r\x04\x12\x04\xda\
    \t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\r\x05\x12\x04\xda\t\x19\x1e\n\x0f\
    \n\x07\x04S\x03\0\x02\r\x01\x12\x04\xda\t\x1f+\n\x0f\n\x07\x04S\x03\0\
    \x02\r\x03\x12\x04\xda\t.0\n\x0e\n\x06\x04S\x03\0\x02\x0e\x12\x04\xdb\t\
    \x10@\n\x0f\n\x07\x04S\x03\0\x02\x0e\x04\x12\x04\xdb\t\x10\x18\n\x0f\n\
    \x07\x04S\x03\0\x02\x0e\x05\x12\x04\xdb\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\
    \x02\x0e\x01\x12\x04\xdb\t\x1f:\n\x0f\n\x07\x04S\x03\0\x02\x0e\x03\x12\
    \x04\xdb\t=?\n\x0e\n\x06\x04S\x03\0\x02\x0f\x12\x04\xdc\t\x102\n\x0f\n\
    \x07\x04S\x03\0\x02\x0f\x04\x12\x04\xdc\t\x10\x18\n\x0f\n\x07\x04S\x03\0\
    \x02\x0f\x05\x12\x04\xdc\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x0f\x01\
    \x12\x04\xdc\t\x1f,\n\x0f\n\x07\x04S\x03\0\x02\x0f\x03\x12\x04\xdc\t/1\n\
    \x0e\n\x06\x04S\x03\0\x02\x10\x12\x04\xdd\t\x10.\n\x0f\n\x07\x04S\x03\0\
    \x02\x10\x04\x12\x04\xdd\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x10\x05\
    \x12\x04\xdd\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x10\x01\x12\x04\xdd\t\
    \x1f(\n\x0f\n\x07\x04S\x03\0\x02\x10\x03\x12\x04\xdd\t+-\n\x0e\n\x06\x04\
    S\x03\0\x02\x11\x12\x04\xde\t\x10+\n\x0f\n\x07\x04S\x03\0\x02\x11\x04\
    \x12\x04\xde\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x11\x05\x12\x04\xde\t\
    \x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x11\x01\x12\x04\xde\t\x1f%\n\x0f\n\
    \x07\x04S\x03\0\x02\x11\x03\x12\x04\xde\t(*\n\x0e\n\x06\x04S\x03\0\x02\
    \x12\x12\x04\xdf\t\x104\n\x0f\n\x07\x04S\x03\0\x02\x12\x04\x12\x04\xdf\t\
    \x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x12\x05\x12\x04\xdf\t\x19\x1e\n\x0f\
    \n\x07\x04S\x03\0\x02\x12\x01\x12\x04\xdf\t\x1f.\n\x0f\n\x07\x04S\x03\0\
    \x02\x12\x03\x12\x04\xdf\t13\n\x0e\n\x06\x04S\x03\0\x02\x13\x12\x04\xe0\
    \t\x101\n\x0f\n\x07\x04S\x03\0\x02\x13\x04\x12\x04\xe0\t\x10\x18\n\x0f\n\
    \x07\x04S\x03\0\x02\x13\x05\x12\x04\xe0\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\
    \x02\x13\x01\x12\x04\xe0\t\x1f+\n\x0f\n\x07\x04S\x03\0\x02\x13\x03\x12\
    \x04\xe0\t.0\n\x0e\n\x06\x04S\x03\0\x02\x14\x12\x04\xe1\t\x101\n\x0f\n\
    \x07\x04S\x03\0\x02\x14\x04\x12\x04\xe1\t\x10\x18\n\x0f\n\x07\x04S\x03\0\
    \x02\x14\x05\x12\x04\xe1\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x14\x01\
    \x12\x04\xe1\t\x1f+\n\x0f\n\x07\x04S\x03\0\x02\x14\x03\x12\x04\xe1\t.0\n\
    \x0e\n\x06\x04S\x03\0\x02\x15\x12\x04\xe2\t\x10-\n\x0f\n\x07\x04S\x03\0\
    \x02\x15\x04\x12\x04\xe2\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x15\x05\
    \x12\x04\xe2\t\x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x15\x01\x12\x04\xe2\t\
    \x1f'\n\x0f\n\x07\x04S\x03\0\x02\x15\x03\x12\x04\xe2\t*,\n\x0e\n\x06\x04\
    S\x03\0\x02\x16\x12\x04\xe3\t\x100\n\x0f\n\x07\x04S\x03\0\x02\x16\x04\
    \x12\x04\xe3\t\x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x16\x05\x12\x04\xe3\t\
    \x19\x1e\n\x0f\n\x07\x04S\x03\0\x02\x16\x01\x12\x04\xe3\t\x1f*\n\x0f\n\
    \x07\x04S\x03\0\x02\x16\x03\x12\x04\xe3\t-/\n\x0e\n\x06\x04S\x03\0\x02\
    \x17\x12\x04\xe4\t\x10Z\n\x0f\n\x07\x04S\x03\0\x02\x17\x04\x12\x04\xe4\t\
    \x10\x18\n\x0f\n\x07\x04S\x03\0\x02\x17\x06\x12\x04\xe4\t\x19B\n\x0f\n\
    \x07\x04S\x03\0\x02\x17\x01\x12\x04\xe4\tCT\n\x0f\n\x07\x04S\x03\0\x02\
    \x17\x03\x12\x04\xe4\tWY\n\x0e\n\x06\x04S\x03\0\x02\x18\x12\x04\xe5\t\
    \x108\n\x0f\n\x07\x04S\x03\0\x02\x18\x04\x12\x04\xe5\t\x10\x18\n\x0f\n\
    \x07\x04S\x03\0\x02\x18\x05\x12\x04\xe5\t\x19\x1f\n\x0f\n\x07\x04S\x03\0\
    \x02\x18\x01\x12\x04\xe5\t\x202\n\x0f\n\x07\x04S\x03\0\x02\x18\x03\x12\
    \x04\xe5\t57\n\x0c\n\x04\x04S\x02\0\x12\x04\xe8\t\x08%\n\r\n\x05\x04S\
    \x02\0\x04\x12\x04\xe8\t\x08\x10\n\r\n\x05\x04S\x02\0\x05\x12\x04\xe8\t\
    \x11\x17\n\r\n\x05\x04S\x02\0\x01\x12\x04\xe8\t\x18\x20\n\r\n\x05\x04S\
    \x02\0\x03\x12\x04\xe8\t#$\n\x0c\n\x04\x04S\x02\x01\x12\x04\xe9\t\x08&\n\
    \r\n\x05\x04S\x02\x01\x04\x12\x04\xe9\t\x08\x10\n\r\n\x05\x04S\x02\x01\
    \x05\x12\x04\xe9\t\x11\x17\n\r\n\x05\x04S\x02\x01\x01\x12\x04\xe9\t\x18!\
    \n\r\n\x05\x04S\x02\x01\x03\x12\x04\xe9\t$%\n\x0c\n\x04\x04S\x02\x02\x12\
    \x04\xea\t\x08)\n\r\n\x05\x04S\x02\x02\x04\x12\x04\xea\t\x08\x10\n\r\n\
    \x05\x04S\x02\x02\x05\x12\x04\xea\t\x11\x17\n\r\n\x05\x04S\x02\x02\x01\
    \x12\x04\xea\t\x18$\n\r\n\x05\x04S\x02\x02\x03\x12\x04\xea\t'(\n\x0c\n\
    \x04\x04S\x02\x03\x12\x04\xeb\t\x08%\n\r\n\x05\x04S\x02\x03\x04\x12\x04\
    \xeb\t\x08\x10\n\r\n\x05\x04S\x02\x03\x05\x12\x04\xeb\t\x11\x16\n\r\n\
    \x05\x04S\x02\x03\x01\x12\x04\xeb\t\x17\x20\n\r\n\x05\x04S\x02\x03\x03\
    \x12\x04\xeb\t#$\n\x0c\n\x04\x04S\x02\x04\x12\x04\xec\t\x088\n\r\n\x05\
    \x04S\x02\x04\x04\x12\x04\xec\t\x08\x10\n\r\n\x05\x04S\x02\x04\x06\x12\
    \x04\xec\t\x11+\n\r\n\x05\x04S\x02\x04\x01\x12\x04\xec\t,3\n\r\n\x05\x04\
    S\x02\x04\x03\x12\x04\xec\t67\n\x0c\n\x02\x04T\x12\x06\xef\t\0\xf1\t\x01\
    \n\x0b\n\x03\x04T\x01\x12\x04\xef\t\x08(\n\x0c\n\x04\x04T\x02\0\x12\x04\
    \xf0\t\x08!\n\r\n\x05\x04T\x02\0\x04\x12\x04\xf0\t\x08\x10\n\r\n\x05\x04\
    T\x02\0\x05\x12\x04\xf0\t\x11\x15\n\r\n\x05\x04T\x02\0\x01\x12\x04\xf0\t\
    \x16\x1c\n\r\n\x05\x04T\x02\0\x03\x12\x04\xf0\t\x1f\x20\n\x0c\n\x02\x04U\
    \x12\x06\xf3\t\0\xf5\t\x01\n\x0b\n\x03\x04U\x01\x12\x04\xf3\t\x08'\n\x0c\
    \n\x04\x04U\x02\0\x12\x04\xf4\t\x08(\n\r\n\x05\x04U\x02\0\x04\x12\x04\
    \xf4\t\x08\x10\n\r\n\x05\x04U\x02\0\x05\x12\x04\xf4\t\x11\x17\n\r\n\x05\
    \x04U\x02\0\x01\x12\x04\xf4\t\x18#\n\r\n\x05\x04U\x02\0\x03\x12\x04\xf4\
    \t&'\n\x0c\n\x02\x04V\x12\x06\xf7\t\0\x88\n\x01\n\x0b\n\x03\x04V\x01\x12\
    \x04\xf7\t\x08/\n\x0e\n\x04\x04V\x03\0\x12\x06\xf8\t\x08\xfe\t\t\n\r\n\
    \x05\x04V\x03\0\x01\x12\x04\xf8\t\x10\x1f\n\x0e\n\x06\x04V\x03\0\x02\0\
    \x12\x04\xf9\t\x100\n\x0f\n\x07\x04V\x03\0\x02\0\x04\x12\x04\xf9\t\x10\
    \x18\n\x0f\n\x07\x04V\x03\0\x02\0\x05\x12\x04\xf9\t\x19\x1f\n\x0f\n\x07\
    \x04V\x03\0\x02\0\x01\x12\x04\xf9\t\x20+\n\x0f\n\x07\x04V\x03\0\x02\0\
    \x03\x12\x04\xf9\t./\n\x0e\n\x06\x04V\x03\0\x02\x01\x12\x04\xfa\t\x10:\n\
    \x0f\n\x07\x04V\x03\0\x02\x01\x04\x12\x04\xfa\t\x10\x18\n\x0f\n\x07\x04V\
    \x03\0\x02\x01\x05\x12\x04\xfa\t\x19\x1f\n\x0f\n\x07\x04V\x03\0\x02\x01\
    \x01\x12\x04\xfa\t\x205\n\x0f\n\x07\x04V\x03\0\x02\x01\x03\x12\x04\xfa\t\
    89\n\x0e\n\x06\x04V\x03\0\x02\x02\x12\x04\xfb\t\x108\n\x0f\n\x07\x04V\
    \x03\0\x02\x02\x04\x12\x04\xfb\t\x10\x18\n\x0f\n\x07\x04V\x03\0\x02\x02\
    \x05\x12\x04\xfb\t\x19\x1f\n\x0f\n\x07\x04V\x03\0\x02\x02\x01\x12\x04\
    \xfb\t\x203\n\x0f\n\x07\x04V\x03\0\x02\x02\x03\x12\x04\xfb\t67\n\x0e\n\
    \x06\x04V\x03\0\x02\x03\x12\x04\xfc\t\x103\n\x0f\n\x07\x04V\x03\0\x02\
    \x03\x04\x12\x04\xfc\t\x10\x18\n\x0f\n\x07\x04V\x03\0\x02\x03\x05\x12\
    \x04\xfc\t\x19\x1f\n\x0f\n\x07\x04V\x03\0\x02\x03\x01\x12\x04\xfc\t\x20.\
    \n\x0f\n\x07\x04V\x03\0\x02\x03\x03\x12\x04\xfc\t12\n\x0e\n\x06\x04V\x03\
    \0\x02\x04\x12\x04\xfd\t\x102\n\x0f\n\x07\x04V\x03\0\x02\x04\x04\x12\x04\
    \xfd\t\x10\x18\n\x0f\n\x07\x04V\x03\0\x02\x04\x05\x12\x04\xfd\t\x19\x1f\
    \n\x0f\n\x07\x04V\x03\0\x02\x04\x01\x12\x04\xfd\t\x20-\n\x0f\n\x07\x04V\
    \x03\0\x02\x04\x03\x12\x04\xfd\t01\n\x0e\n\x04\x04V\x03\x01\x12\x06\x80\
    \n\x08\x85\n\t\n\r\n\x05\x04V\x03\x01\x01\x12\x04\x80\n\x10\x16\n\x0e\n\
    \x06\x04V\x03\x01\x02\0\x12\x04\x81\n\x10/\n\x0f\n\x07\x04V\x03\x01\x02\
    \0\x04\x12\x04\x81\n\x10\x18\n\x0f\n\x07\x04V\x03\x01\x02\0\x05\x12\x04\
    \x81\n\x19\x1f\n\x0f\n\x07\x04V\x03\x01\x02\0\x01\x12\x04\x81\n\x20*\n\
    \x0f\n\x07\x04V\x03\x01\x02\0\x03\x12\x04\x81\n-.\n\x0e\n\x06\x04V\x03\
    \x01\x02\x01\x12\x04\x82\n\x10-\n\x0f\n\x07\x04V\x03\x01\x02\x01\x04\x12\
    \x04\x82\n\x10\x18\n\x0f\n\x07\x04V\x03\x01\x02\x01\x05\x12\x04\x82\n\
    \x19\x1f\n\x0f\n\x07\x04V\x03\x01\x02\x01\x01\x12\x04\x82\n\x20(\n\x0f\n\
    \x07\x04V\x03\x01\x02\x01\x03\x12\x04\x82\n+,\n\x0e\n\x06\x04V\x03\x01\
    \x02\x02\x12\x04\x83\n\x10-\n\x0f\n\x07\x04V\x03\x01\x02\x02\x04\x12\x04\
    \x83\n\x10\x18\n\x0f\n\x07\x04V\x03\x01\x02\x02\x06\x12\x04\x83\n\x19\
    \x1f\n\x0f\n\x07\x04V\x03\x01\x02\x02\x01\x12\x04\x83\n\x20(\n\x0f\n\x07\
    \x04V\x03\x01\x02\x02\x03\x12\x04\x83\n+,\n\x0e\n\x06\x04V\x03\x01\x02\
    \x03\x12\x04\x84\n\x10_\n\x0f\n\x07\x04V\x03\x01\x02\x03\x04\x12\x04\x84\
    \n\x10\x18\n\x0f\n\x07\x04V\x03\x01\x02\x03\x06\x12\x04\x84\n\x19P\n\x0f\
    \n\x07\x04V\x03\x01\x02\x03\x01\x12\x04\x84\nQZ\n\x0f\n\x07\x04V\x03\x01\
    \x02\x03\x03\x12\x04\x84\n]^\n\x0c\n\x04\x04V\x02\0\x12\x04\x87\n\x08U\n\
    \r\n\x05\x04V\x02\0\x04\x12\x04\x87\n\x08\x10\n\r\n\x05\x04V\x02\0\x06\
    \x12\x04\x87\n\x11?\n\r\n\x05\x04V\x02\0\x01\x12\x04\x87\n@P\n\r\n\x05\
    \x04V\x02\0\x03\x12\x04\x87\nST\n\x0c\n\x02\x04W\x12\x06\x8a\n\0\x99\n\
    \x01\n\x0b\n\x03\x04W\x01\x12\x04\x8a\n\x08\x1e\n\x0e\n\x04\x04W\x03\0\
    \x12\x06\x8b\n\x08\x8e\n\t\n\r\n\x05\x04W\x03\0\x01\x12\x04\x8b\n\x10\
    \x1c\n\x0e\n\x06\x04W\x03\0\x02\0\x12\x04\x8c\n\x10+\n\x0f\n\x07\x04W\
    \x03\0\x02\0\x04\x12\x04\x8c\n\x10\x18\n\x0f\n\x07\x04W\x03\0\x02\0\x05\
    \x12\x04\x8c\n\x19\x1f\n\x0f\n\x07\x04W\x03\0\x02\0\x01\x12\x04\x8c\n\
    \x20&\n\x0f\n\x07\x04W\x03\0\x02\0\x03\x12\x04\x8c\n)*\n\x0e\n\x06\x04W\
    \x03\0\x02\x01\x12\x04\x8d\n\x10*\n\x0f\n\x07\x04W\x03\0\x02\x01\x04\x12\
    \x04\x8d\n\x10\x18\n\x0f\n\x07\x04W\x03\0\x02\x01\x05\x12\x04\x8d\n\x19\
    \x1f\n\x0f\n\x07\x04W\x03\0\x02\x01\x01\x12\x04\x8d\n\x20%\n\x0f\n\x07\
    \x04W\x03\0\x02\x01\x03\x12\x04\x8d\n()\n\x0e\n\x04\x04W\x03\x01\x12\x06\
    \x90\n\x08\x95\n\t\n\r\n\x05\x04W\x03\x01\x01\x12\x04\x90\n\x10\x1b\n\
    \x0e\n\x06\x04W\x03\x01\x02\0\x12\x04\x91\n\x10/\n\x0f\n\x07\x04W\x03\
    \x01\x02\0\x04\x12\x04\x91\n\x10\x18\n\x0f\n\x07\x04W\x03\x01\x02\0\x05\
    \x12\x04\x91\n\x19\x1f\n\x0f\n\x07\x04W\x03\x01\x02\0\x01\x12\x04\x91\n\
    \x20*\n\x0f\n\x07\x04W\x03\x01\x02\0\x03\x12\x04\x91\n-.\n\x0e\n\x06\x04\
    W\x03\x01\x02\x01\x12\x04\x92\n\x101\n\x0f\n\x07\x04W\x03\x01\x02\x01\
    \x04\x12\x04\x92\n\x10\x18\n\x0f\n\x07\x04W\x03\x01\x02\x01\x05\x12\x04\
    \x92\n\x19\x1f\n\x0f\n\x07\x04W\x03\x01\x02\x01\x01\x12\x04\x92\n\x20,\n\
    \x0f\n\x07\x04W\x03\x01\x02\x01\x03\x12\x04\x92\n/0\n\x0e\n\x06\x04W\x03\
    \x01\x02\x02\x12\x04\x93\n\x10=\n\x0f\n\x07\x04W\x03\x01\x02\x02\x04\x12\
    \x04\x93\n\x10\x18\n\x0f\n\x07\x04W\x03\x01\x02\x02\x05\x12\x04\x93\n\
    \x19\x1d\n\x0f\n\x07\x04W\x03\x01\x02\x02\x01\x12\x04\x93\n\x1e8\n\x0f\n\
    \x07\x04W\x03\x01\x02\x02\x03\x12\x04\x93\n;<\n\x0e\n\x06\x04W\x03\x01\
    \x02\x03\x12\x04\x94\n\x10Q\n\x0f\n\x07\x04W\x03\x01\x02\x03\x04\x12\x04\
    \x94\n\x10\x18\n\x0f\n\x07\x04W\x03\x01\x02\x03\x06\x12\x04\x94\n\x19<\n\
    \x0f\n\x07\x04W\x03\x01\x02\x03\x01\x12\x04\x94\n=L\n\x0f\n\x07\x04W\x03\
    \x01\x02\x03\x03\x12\x04\x94\nOP\n\x0c\n\x04\x04W\x02\0\x12\x04\x97\n\
    \x08J\n\r\n\x05\x04W\x02\0\x04\x12\x04\x97\n\x08\x10\n\r\n\x05\x04W\x02\
    \0\x06\x12\x04\x97\n\x113\n\r\n\x05\x04W\x02\0\x01\x12\x04\x97\n4E\n\r\n\
    \x05\x04W\x02\0\x03\x12\x04\x97\nHI\n\x0c\n\x04\x04W\x02\x01\x12\x04\x98\
    \n\x08%\n\r\n\x05\x04W\x02\x01\x04\x12\x04\x98\n\x08\x10\n\r\n\x05\x04W\
    \x02\x01\x06\x12\x04\x98\n\x11\x17\n\r\n\x05\x04W\x02\x01\x01\x12\x04\
    \x98\n\x18\x20\n\r\n\x05\x04W\x02\x01\x03\x12\x04\x98\n#$\n\x0c\n\x02\
    \x04X\x12\x06\x9b\n\0\xa2\n\x01\n\x0b\n\x03\x04X\x01\x12\x04\x9b\n\x08\
    \x1f\n\x0e\n\x04\x04X\x03\0\x12\x06\x9c\n\x08\x9f\n\t\n\r\n\x05\x04X\x03\
    \0\x01\x12\x04\x9c\n\x10\x1e\n\x0e\n\x06\x04X\x03\0\x02\0\x12\x04\x9d\n\
    \x10/\n\x0f\n\x07\x04X\x03\0\x02\0\x04\x12\x04\x9d\n\x10\x18\n\x0f\n\x07\
    \x04X\x03\0\x02\0\x05\x12\x04\x9d\n\x19\x1f\n\x0f\n\x07\x04X\x03\0\x02\0\
    \x01\x12\x04\x9d\n\x20*\n\x0f\n\x07\x04X\x03\0\x02\0\x03\x12\x04\x9d\n-.\
    \n\x0e\n\x06\x04X\x03\0\x02\x01\x12\x04\x9e\n\x100\n\x0f\n\x07\x04X\x03\
    \0\x02\x01\x04\x12\x04\x9e\n\x10\x18\n\x0f\n\x07\x04X\x03\0\x02\x01\x05\
    \x12\x04\x9e\n\x19\x1f\n\x0f\n\x07\x04X\x03\0\x02\x01\x01\x12\x04\x9e\n\
    \x20+\n\x0f\n\x07\x04X\x03\0\x02\x01\x03\x12\x04\x9e\n./\n\x0c\n\x04\x04\
    X\x02\0\x12\x04\xa1\n\x08H\n\r\n\x05\x04X\x02\0\x04\x12\x04\xa1\n\x08\
    \x10\n\r\n\x05\x04X\x02\0\x06\x12\x04\xa1\n\x117\n\r\n\x05\x04X\x02\0\
    \x01\x12\x04\xa1\n8C\n\r\n\x05\x04X\x02\0\x03\x12\x04\xa1\nFG\n\x0c\n\
    \x02\x04Y\x12\x06\xa4\n\0\xb7\n\x01\n\x0b\n\x03\x04Y\x01\x12\x04\xa4\n\
    \x08\x17\n\x0c\n\x04\x04Y\x02\0\x12\x04\xa5\n\x08)\n\r\n\x05\x04Y\x02\0\
    \x04\x12\x04\xa5\n\x08\x10\n\r\n\x05\x04Y\x02\0\x05\x12\x04\xa5\n\x11\
    \x15\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xa5\n\x16$\n\r\n\x05\x04Y\x02\0\
    \x03\x12\x04\xa5\n'(\n\x0c\n\x04\x04Y\x02\x01\x12\x04\xa6\n\x08-\n\r\n\
    \x05\x04Y\x02\x01\x04\x12\x04\xa6\n\x08\x10\n\r\n\x05\x04Y\x02\x01\x05\
    \x12\x04\xa6\n\x11\x15\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\xa6\n\x16(\n\r\
    \n\x05\x04Y\x02\x01\x03\x12\x04\xa6\n+,\n\x0c\n\x04\x04Y\x02\x02\x12\x04\
    \xa7\n\x08+\n\r\n\x05\x04Y\x02\x02\x04\x12\x04\xa7\n\x08\x10\n\r\n\x05\
    \x04Y\x02\x02\x05\x12\x04\xa7\n\x11\x16\n\r\n\x05\x04Y\x02\x02\x01\x12\
    \x04\xa7\n\x17&\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\xa7\n)*\n\x0c\n\x04\
    \x04Y\x02\x03\x12\x04\xa8\n\x080\n\r\n\x05\x04Y\x02\x03\x04\x12\x04\xa8\
    \n\x08\x10\n\r\n\x05\x04Y\x02\x03\x05\x12\x04\xa8\n\x11\x17\n\r\n\x05\
    \x04Y\x02\x03\x01\x12\x04\xa8\n\x18+\n\r\n\x05\x04Y\x02\x03\x03\x12\x04\
    \xa8\n./\n\x0c\n\x04\x04Y\x02\x04\x12\x04\xa9\n\x081\n\r\n\x05\x04Y\x02\
    \x04\x04\x12\x04\xa9\n\x08\x10\n\r\n\x05\x04Y\x02\x04\x05\x12\x04\xa9\n\
    \x11\x16\n\r\n\x05\x04Y\x02\x04\x01\x12\x04\xa9\n\x17,\n\r\n\x05\x04Y\
    \x02\x04\x03\x12\x04\xa9\n/0\n\x0c\n\x04\x04Y\x02\x05\x12\x04\xaa\n\x08-\
    \n\r\n\x05\x04Y\x02\x05\x04\x12\x04\xaa\n\x08\x10\n\r\n\x05\x04Y\x02\x05\
    \x05\x12\x04\xaa\n\x11\x17\n\r\n\x05\x04Y\x02\x05\x01\x12\x04\xaa\n\x18'\
    \n\r\n\x05\x04Y\x02\x05\x03\x12\x04\xaa\n*,\n\x0c\n\x04\x04Y\x02\x06\x12\
    \x04\xab\n\x080\n\r\n\x05\x04Y\x02\x06\x04\x12\x04\xab\n\x08\x10\n\r\n\
    \x05\x04Y\x02\x06\x05\x12\x04\xab\n\x11\x17\n\r\n\x05\x04Y\x02\x06\x01\
    \x12\x04\xab\n\x18*\n\r\n\x05\x04Y\x02\x06\x03\x12\x04\xab\n-/\n\x0c\n\
    \x04\x04Y\x02\x07\x12\x04\xac\n\x08.\n\r\n\x05\x04Y\x02\x07\x04\x12\x04\
    \xac\n\x08\x10\n\r\n\x05\x04Y\x02\x07\x05\x12\x04\xac\n\x11\x17\n\r\n\
    \x05\x04Y\x02\x07\x01\x12\x04\xac\n\x18(\n\r\n\x05\x04Y\x02\x07\x03\x12\
    \x04\xac\n+-\n\x0c\n\x04\x04Y\x02\x08\x12\x04\xad\n\x08.\n\r\n\x05\x04Y\
    \x02\x08\x04\x12\x04\xad\n\x08\x10\n\r\n\x05\x04Y\x02\x08\x05\x12\x04\
    \xad\n\x11\x16\n\r\n\x05\x04Y\x02\x08\x01\x12\x04\xad\n\x17(\n\r\n\x05\
    \x04Y\x02\x08\x03\x12\x04\xad\n+-\n\x0c\n\x04\x04Y\x02\t\x12\x04\xae\n\
    \x08.\n\r\n\x05\x04Y\x02\t\x04\x12\x04\xae\n\x08\x10\n\r\n\x05\x04Y\x02\
    \t\x05\x12\x04\xae\n\x11\x16\n\r\n\x05\x04Y\x02\t\x01\x12\x04\xae\n\x17(\
    \n\r\n\x05\x04Y\x02\t\x03\x12\x04\xae\n+-\n\x0c\n\x04\x04Y\x02\n\x12\x04\
    \xaf\n\x083\n\r\n\x05\x04Y\x02\n\x04\x12\x04\xaf\n\x08\x10\n\r\n\x05\x04\
    Y\x02\n\x05\x12\x04\xaf\n\x11\x17\n\r\n\x05\x04Y\x02\n\x01\x12\x04\xaf\n\
    \x18-\n\r\n\x05\x04Y\x02\n\x03\x12\x04\xaf\n02\n\x0c\n\x04\x04Y\x02\x0b\
    \x12\x04\xb0\n\x083\n\r\n\x05\x04Y\x02\x0b\x04\x12\x04\xb0\n\x08\x10\n\r\
    \n\x05\x04Y\x02\x0b\x05\x12\x04\xb0\n\x11\x17\n\r\n\x05\x04Y\x02\x0b\x01\
    \x12\x04\xb0\n\x18-\n\r\n\x05\x04Y\x02\x0b\x03\x12\x04\xb0\n02\n\x0c\n\
    \x04\x04Y\x02\x0c\x12\x04\xb1\n\x08=\n\r\n\x05\x04Y\x02\x0c\x04\x12\x04\
    \xb1\n\x08\x10\n\r\n\x05\x04Y\x02\x0c\x05\x12\x04\xb1\n\x11\x16\n\r\n\
    \x05\x04Y\x02\x0c\x01\x12\x04\xb1\n\x177\n\r\n\x05\x04Y\x02\x0c\x03\x12\
    \x04\xb1\n:<\n\x0c\n\x04\x04Y\x02\r\x12\x04\xb2\n\x087\n\r\n\x05\x04Y\
    \x02\r\x04\x12\x04\xb2\n\x08\x10\n\r\n\x05\x04Y\x02\r\x05\x12\x04\xb2\n\
    \x11\x16\n\r\n\x05\x04Y\x02\r\x01\x12\x04\xb2\n\x171\n\r\n\x05\x04Y\x02\
    \r\x03\x12\x04\xb2\n46\n\x0c\n\x04\x04Y\x02\x0e\x12\x04\xb3\n\x08<\n\r\n\
    \x05\x04Y\x02\x0e\x04\x12\x04\xb3\n\x08\x10\n\r\n\x05\x04Y\x02\x0e\x05\
    \x12\x04\xb3\n\x11\x17\n\r\n\x05\x04Y\x02\x0e\x01\x12\x04\xb3\n\x186\n\r\
    \n\x05\x04Y\x02\x0e\x03\x12\x04\xb3\n9;\n\x0c\n\x04\x04Y\x02\x0f\x12\x04\
    \xb4\n\x080\n\r\n\x05\x04Y\x02\x0f\x04\x12\x04\xb4\n\x08\x10\n\r\n\x05\
    \x04Y\x02\x0f\x05\x12\x04\xb4\n\x11\x16\n\r\n\x05\x04Y\x02\x0f\x01\x12\
    \x04\xb4\n\x17*\n\r\n\x05\x04Y\x02\x0f\x03\x12\x04\xb4\n-/\n\x0c\n\x04\
    \x04Y\x02\x10\x12\x04\xb5\n\x080\n\r\n\x05\x04Y\x02\x10\x04\x12\x04\xb5\
    \n\x08\x10\n\r\n\x05\x04Y\x02\x10\x05\x12\x04\xb5\n\x11\x16\n\r\n\x05\
    \x04Y\x02\x10\x01\x12\x04\xb5\n\x17*\n\r\n\x05\x04Y\x02\x10\x03\x12\x04\
    \xb5\n-/\n\x0c\n\x04\x04Y\x02\x11\x12\x04\xb6\n\x08.\n\r\n\x05\x04Y\x02\
    \x11\x04\x12\x04\xb6\n\x08\x10\n\r\n\x05\x04Y\x02\x11\x05\x12\x04\xb6\n\
    \x11\x16\n\r\n\x05\x04Y\x02\x11\x01\x12\x04\xb6\n\x17(\n\r\n\x05\x04Y\
    \x02\x11\x03\x12\x04\xb6\n+-\n\x0c\n\x02\x04Z\x12\x06\xb9\n\0\xbb\n\x01\
    \n\x0b\n\x03\x04Z\x01\x12\x04\xb9\n\x08!\n\x0c\n\x04\x04Z\x02\0\x12\x04\
    \xba\n\x082\n\r\n\x05\x04Z\x02\0\x04\x12\x04\xba\n\x08\x10\n\r\n\x05\x04\
    Z\x02\0\x06\x12\x04\xba\n\x11\x20\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xba\n\
    !-\n\r\n\x05\x04Z\x02\0\x03\x12\x04\xba\n01\n\x0c\n\x02\x04[\x12\x06\xbd\
    \n\0\xbf\n\x01\n\x0b\n\x03\x04[\x01\x12\x04\xbd\n\x08$\n\x0c\n\x04\x04[\
    \x02\0\x12\x04\xbe\n\x08&\n\r\n\x05\x04[\x02\0\x04\x12\x04\xbe\n\x08\x10\
    \n\r\n\x05\x04[\x02\0\x05\x12\x04\xbe\n\x11\x17\n\r\n\x05\x04[\x02\0\x01\
    \x12\x04\xbe\n\x18!\n\r\n\x05\x04[\x02\0\x03\x12\x04\xbe\n$%\n\x0c\n\x02\
    \x04\\\x12\x06\xc1\n\0\xc3\n\x01\n\x0b\n\x03\x04\\\x01\x12\x04\xc1\n\x08\
    ,\n\x0c\n\x04\x04\\\x02\0\x12\x04\xc2\n\x082\n\r\n\x05\x04\\\x02\0\x04\
    \x12\x04\xc2\n\x08\x10\n\r\n\x05\x04\\\x02\0\x06\x12\x04\xc2\n\x11\x20\n\
    \r\n\x05\x04\\\x02\0\x01\x12\x04\xc2\n!-\n\r\n\x05\x04\\\x02\0\x03\x12\
    \x04\xc2\n01\n\x0c\n\x02\x04]\x12\x06\xc5\n\0\xc7\n\x01\n\x0b\n\x03\x04]\
    \x01\x12\x04\xc5\n\x08)\n\x0c\n\x04\x04]\x02\0\x12\x04\xc6\n\x08\"\n\r\n\
    \x05\x04]\x02\0\x04\x12\x04\xc6\n\x08\x10\n\r\n\x05\x04]\x02\0\x05\x12\
    \x04\xc6\n\x11\x16\n\r\n\x05\x04]\x02\0\x01\x12\x04\xc6\n\x17\x1d\n\r\n\
    \x05\x04]\x02\0\x03\x12\x04\xc6\n\x20!\n\x0c\n\x02\x04^\x12\x06\xc9\n\0\
    \xca\n\x01\n\x0b\n\x03\x04^\x01\x12\x04\xc9\n\x08#\n\x0c\n\x02\x04_\x12\
    \x06\xcc\n\0\xd1\n\x01\n\x0b\n\x03\x04_\x01\x12\x04\xcc\n\x08\x1a\n\x0c\
    \n\x04\x04_\x02\0\x12\x04\xcd\n\x08)\n\r\n\x05\x04_\x02\0\x04\x12\x04\
    \xcd\n\x08\x10\n\r\n\x05\x04_\x02\0\x05\x12\x04\xcd\n\x11\x17\n\r\n\x05\
    \x04_\x02\0\x01\x12\x04\xcd\n\x18$\n\r\n\x05\x04_\x02\0\x03\x12\x04\xcd\
    \n'(\n\x0c\n\x04\x04_\x02\x01\x12\x04\xce\n\x08*\n\r\n\x05\x04_\x02\x01\
    \x04\x12\x04\xce\n\x08\x10\n\r\n\x05\x04_\x02\x01\x05\x12\x04\xce\n\x11\
    \x16\n\r\n\x05\x04_\x02\x01\x01\x12\x04\xce\n\x17%\n\r\n\x05\x04_\x02\
    \x01\x03\x12\x04\xce\n()\n\x0c\n\x04\x04_\x02\x02\x12\x04\xcf\n\x08'\n\r\
    \n\x05\x04_\x02\x02\x04\x12\x04\xcf\n\x08\x10\n\r\n\x05\x04_\x02\x02\x05\
    \x12\x04\xcf\n\x11\x16\n\r\n\x05\x04_\x02\x02\x01\x12\x04\xcf\n\x17\"\n\
    \r\n\x05\x04_\x02\x02\x03\x12\x04\xcf\n%&\n\x0c\n\x04\x04_\x02\x03\x12\
    \x04\xd0\n\x08*\n\r\n\x05\x04_\x02\x03\x04\x12\x04\xd0\n\x08\x10\n\r\n\
    \x05\x04_\x02\x03\x05\x12\x04\xd0\n\x11\x16\n\r\n\x05\x04_\x02\x03\x01\
    \x12\x04\xd0\n\x17%\n\r\n\x05\x04_\x02\x03\x03\x12\x04\xd0\n()\n\x0c\n\
    \x02\x04`\x12\x06\xd3\n\0\xd7\n\x01\n\x0b\n\x03\x04`\x01\x12\x04\xd3\n\
    \x08\x16\n\x0c\n\x04\x04`\x02\0\x12\x04\xd4\n\x084\n\r\n\x05\x04`\x02\0\
    \x04\x12\x04\xd4\n\x08\x10\n\r\n\x05\x04`\x02\0\x06\x12\x04\xd4\n\x11#\n\
    \r\n\x05\x04`\x02\0\x01\x12\x04\xd4\n$/\n\r\n\x05\x04`\x02\0\x03\x12\x04\
    \xd4\n23\n\x0c\n\x04\x04`\x02\x01\x12\x04\xd5\n\x080\n\r\n\x05\x04`\x02\
    \x01\x04\x12\x04\xd5\n\x08\x10\n\r\n\x05\x04`\x02\x01\x05\x12\x04\xd5\n\
    \x11\x17\n\r\n\x05\x04`\x02\x01\x01\x12\x04\xd5\n\x18+\n\r\n\x05\x04`\
    \x02\x01\x03\x12\x04\xd5\n./\n\x0c\n\x04\x04`\x02\x02\x12\x04\xd6\n\x08-\
    \n\r\n\x05\x04`\x02\x02\x04\x12\x04\xd6\n\x08\x10\n\r\n\x05\x04`\x02\x02\
    \x05\x12\x04\xd6\n\x11\x17\n\r\n\x05\x04`\x02\x02\x01\x12\x04\xd6\n\x18(\
    \n\r\n\x05\x04`\x02\x02\x03\x12\x04\xd6\n+,\n\x0c\n\x02\x04a\x12\x06\xd9\
    \n\0\xdc\n\x01\n\x0b\n\x03\x04a\x01\x12\x04\xd9\n\x08&\n\x0c\n\x04\x04a\
    \x02\0\x12\x04\xda\n\x082\n\r\n\x05\x04a\x02\0\x04\x12\x04\xda\n\x08\x10\
    \n\r\n\x05\x04a\x02\0\x06\x12\x04\xda\n\x11\x20\n\r\n\x05\x04a\x02\0\x01\
    \x12\x04\xda\n!-\n\r\n\x05\x04a\x02\0\x03\x12\x04\xda\n01\n\x0c\n\x04\
    \x04a\x02\x01\x12\x04\xdb\n\x080\n\r\n\x05\x04a\x02\x01\x04\x12\x04\xdb\
    \n\x08\x10\n\r\n\x05\x04a\x02\x01\x06\x12\x04\xdb\n\x11\x1f\n\r\n\x05\
    \x04a\x02\x01\x01\x12\x04\xdb\n\x20+\n\r\n\x05\x04a\x02\x01\x03\x12\x04\
    \xdb\n./\n\x0c\n\x02\x04b\x12\x06\xde\n\0\xe0\n\x01\n\x0b\n\x03\x04b\x01\
    \x12\x04\xde\n\x08&\n\x0c\n\x04\x04b\x02\0\x12\x04\xdf\n\x08(\n\r\n\x05\
    \x04b\x02\0\x04\x12\x04\xdf\n\x08\x10\n\r\n\x05\x04b\x02\0\x05\x12\x04\
    \xdf\n\x11\x17\n\r\n\x05\x04b\x02\0\x01\x12\x04\xdf\n\x18#\n\r\n\x05\x04\
    b\x02\0\x03\x12\x04\xdf\n&'\n\x0c\n\x02\x04c\x12\x06\xe2\n\0\xe9\n\x01\n\
    \x0b\n\x03\x04c\x01\x12\x04\xe2\n\x08.\n\x0e\n\x04\x04c\x03\0\x12\x06\
    \xe3\n\x08\xe6\n\t\n\r\n\x05\x04c\x03\0\x01\x12\x04\xe3\n\x10\x16\n\x0e\
    \n\x06\x04c\x03\0\x02\0\x12\x04\xe4\n\x10/\n\x0f\n\x07\x04c\x03\0\x02\0\
    \x04\x12\x04\xe4\n\x10\x18\n\x0f\n\x07\x04c\x03\0\x02\0\x05\x12\x04\xe4\
    \n\x19\x1f\n\x0f\n\x07\x04c\x03\0\x02\0\x01\x12\x04\xe4\n\x20*\n\x0f\n\
    \x07\x04c\x03\0\x02\0\x03\x12\x04\xe4\n-.\n\x0e\n\x06\x04c\x03\0\x02\x01\
    \x12\x04\xe5\n\x108\n\x0f\n\x07\x04c\x03\0\x02\x01\x04\x12\x04\xe5\n\x10\
    \x18\n\x0f\n\x07\x04c\x03\0\x02\x01\x06\x12\x04\xe5\n\x19*\n\x0f\n\x07\
    \x04c\x03\0\x02\x01\x01\x12\x04\xe5\n+3\n\x0f\n\x07\x04c\x03\0\x02\x01\
    \x03\x12\x04\xe5\n67\n\x0c\n\x04\x04c\x02\0\x12\x04\xe8\n\x08K\n\r\n\x05\
    \x04c\x02\0\x04\x12\x04\xe8\n\x08\x10\n\r\n\x05\x04c\x02\0\x06\x12\x04\
    \xe8\n\x11>\n\r\n\x05\x04c\x02\0\x01\x12\x04\xe8\n?F\n\r\n\x05\x04c\x02\
    \0\x03\x12\x04\xe8\nIJ\n\x0c\n\x02\x04d\x12\x06\xeb\n\0\xec\n\x01\n\x0b\
    \n\x03\x04d\x01\x12\x04\xeb\n\x08*\n\x0c\n\x02\x04e\x12\x06\xee\n\0\xf3\
    \n\x01\n\x0b\n\x03\x04e\x01\x12\x04\xee\n\x08.\n\x0c\n\x04\x04e\x02\0\
    \x12\x04\xef\n\x08!\n\r\n\x05\x04e\x02\0\x04\x12\x04\xef\n\x08\x10\n\r\n\
    \x05\x04e\x02\0\x05\x12\x04\xef\n\x11\x15\n\r\n\x05\x04e\x02\0\x01\x12\
    \x04\xef\n\x16\x1c\n\r\n\x05\x04e\x02\0\x03\x12\x04\xef\n\x1f\x20\n\x0c\
    \n\x04\x04e\x02\x01\x12\x04\xf0\n\x08'\n\r\n\x05\x04e\x02\x01\x04\x12\
    \x04\xf0\n\x08\x10\n\r\n\x05\x04e\x02\x01\x05\x12\x04\xf0\n\x11\x17\n\r\
    \n\x05\x04e\x02\x01\x01\x12\x04\xf0\n\x18\"\n\r\n\x05\x04e\x02\x01\x03\
    \x12\x04\xf0\n%&\n\x0c\n\x04\x04e\x02\x02\x12\x04\xf1\n\x08.\n\r\n\x05\
    \x04e\x02\x02\x04\x12\x04\xf1\n\x08\x10\n\r\n\x05\x04e\x02\x02\x05\x12\
    \x04\xf1\n\x11\x17\n\r\n\x05\x04e\x02\x02\x01\x12\x04\xf1\n\x18)\n\r\n\
    \x05\x04e\x02\x02\x03\x12\x04\xf1\n,-\n\x0c\n\x04\x04e\x02\x03\x12\x04\
    \xf2\n\x08%\n\r\n\x05\x04e\x02\x03\x04\x12\x04\xf2\n\x08\x10\n\r\n\x05\
    \x04e\x02\x03\x05\x12\x04\xf2\n\x11\x17\n\r\n\x05\x04e\x02\x03\x01\x12\
    \x04\xf2\n\x18\x20\n\r\n\x05\x04e\x02\x03\x03\x12\x04\xf2\n#$\n\x0c\n\
    \x02\x04f\x12\x06\xf5\n\0\xf7\n\x01\n\x0b\n\x03\x04f\x01\x12\x04\xf5\n\
    \x08.\n\x0c\n\x04\x04f\x02\0\x12\x04\xf6\n\x081\n\r\n\x05\x04f\x02\0\x04\
    \x12\x04\xf6\n\x08\x10\n\r\n\x05\x04f\x02\0\x06\x12\x04\xf6\n\x11'\n\r\n\
    \x05\x04f\x02\0\x01\x12\x04\xf6\n(,\n\r\n\x05\x04f\x02\0\x03\x12\x04\xf6\
    \n/0\n\x0c\n\x02\x04g\x12\x06\xf9\n\0\xff\n\x01\n\x0b\n\x03\x04g\x01\x12\
    \x04\xf9\n\x08\x1f\n\x0c\n\x04\x04g\x02\0\x12\x04\xfa\n\x08(\n\r\n\x05\
    \x04g\x02\0\x04\x12\x04\xfa\n\x08\x10\n\r\n\x05\x04g\x02\0\x05\x12\x04\
    \xfa\n\x11\x17\n\r\n\x05\x04g\x02\0\x01\x12\x04\xfa\n\x18#\n\r\n\x05\x04\
    g\x02\0\x03\x12\x04\xfa\n&'\n\x0c\n\x04\x04g\x02\x01\x12\x04\xfb\n\x08&\
    \n\r\n\x05\x04g\x02\x01\x04\x12\x04\xfb\n\x08\x10\n\r\n\x05\x04g\x02\x01\
    \x05\x12\x04\xfb\n\x11\x15\n\r\n\x05\x04g\x02\x01\x01\x12\x04\xfb\n\x16!\
    \n\r\n\x05\x04g\x02\x01\x03\x12\x04\xfb\n$%\n\x0c\n\x04\x04g\x02\x02\x12\
    \x04\xfc\n\x08%\n\r\n\x05\x04g\x02\x02\x04\x12\x04\xfc\n\x08\x10\n\r\n\
    \x05\x04g\x02\x02\x05\x12\x04\xfc\n\x11\x17\n\r\n\x05\x04g\x02\x02\x01\
    \x12\x04\xfc\n\x18\x20\n\r\n\x05\x04g\x02\x02\x03\x12\x04\xfc\n#$\n\x0c\
    \n\x04\x04g\x02\x03\x12\x04\xfd\n\x08&\n\r\n\x05\x04g\x02\x03\x04\x12\
    \x04\xfd\n\x08\x10\n\r\n\x05\x04g\x02\x03\x05\x12\x04\xfd\n\x11\x17\n\r\
    \n\x05\x04g\x02\x03\x01\x12\x04\xfd\n\x18!\n\r\n\x05\x04g\x02\x03\x03\
    \x12\x04\xfd\n$%\n\x0c\n\x04\x04g\x02\x04\x12\x04\xfe\n\x08'\n\r\n\x05\
    \x04g\x02\x04\x04\x12\x04\xfe\n\x08\x10\n\r\n\x05\x04g\x02\x04\x05\x12\
    \x04\xfe\n\x11\x17\n\r\n\x05\x04g\x02\x04\x01\x12\x04\xfe\n\x18\"\n\r\n\
    \x05\x04g\x02\x04\x03\x12\x04\xfe\n%&\n\x0c\n\x02\x04h\x12\x06\x81\x0b\0\
    \x87\x0b\x01\n\x0b\n\x03\x04h\x01\x12\x04\x81\x0b\x08%\n\x0c\n\x04\x04h\
    \x02\0\x12\x04\x82\x0b\x08(\n\r\n\x05\x04h\x02\0\x04\x12\x04\x82\x0b\x08\
    \x10\n\r\n\x05\x04h\x02\0\x05\x12\x04\x82\x0b\x11\x17\n\r\n\x05\x04h\x02\
    \0\x01\x12\x04\x82\x0b\x18#\n\r\n\x05\x04h\x02\0\x03\x12\x04\x82\x0b&'\n\
    \x0c\n\x04\x04h\x02\x01\x12\x04\x83\x0b\x08#\n\r\n\x05\x04h\x02\x01\x04\
    \x12\x04\x83\x0b\x08\x10\n\r\n\x05\x04h\x02\x01\x05\x12\x04\x83\x0b\x11\
    \x15\n\r\n\x05\x04h\x02\x01\x01\x12\x04\x83\x0b\x16\x1e\n\r\n\x05\x04h\
    \x02\x01\x03\x12\x04\x83\x0b!\"\n\x0c\n\x04\x04h\x02\x02\x12\x04\x84\x0b\
    \x08%\n\r\n\x05\x04h\x02\x02\x04\x12\x04\x84\x0b\x08\x10\n\r\n\x05\x04h\
    \x02\x02\x05\x12\x04\x84\x0b\x11\x17\n\r\n\x05\x04h\x02\x02\x01\x12\x04\
    \x84\x0b\x18\x20\n\r\n\x05\x04h\x02\x02\x03\x12\x04\x84\x0b#$\n\x0c\n\
    \x04\x04h\x02\x03\x12\x04\x85\x0b\x08&\n\r\n\x05\x04h\x02\x03\x04\x12\
    \x04\x85\x0b\x08\x10\n\r\n\x05\x04h\x02\x03\x05\x12\x04\x85\x0b\x11\x17\
    \n\r\n\x05\x04h\x02\x03\x01\x12\x04\x85\x0b\x18!\n\r\n\x05\x04h\x02\x03\
    \x03\x12\x04\x85\x0b$%\n\x0c\n\x04\x04h\x02\x04\x12\x04\x86\x0b\x08'\n\r\
    \n\x05\x04h\x02\x04\x04\x12\x04\x86\x0b\x08\x10\n\r\n\x05\x04h\x02\x04\
    \x05\x12\x04\x86\x0b\x11\x17\n\r\n\x05\x04h\x02\x04\x01\x12\x04\x86\x0b\
    \x18\"\n\r\n\x05\x04h\x02\x04\x03\x12\x04\x86\x0b%&\n\x0c\n\x02\x04i\x12\
    \x06\x89\x0b\0\x8e\x0b\x01\n\x0b\n\x03\x04i\x01\x12\x04\x89\x0b\x08!\n\
    \x0c\n\x04\x04i\x02\0\x12\x04\x8a\x0b\x08-\n\r\n\x05\x04i\x02\0\x04\x12\
    \x04\x8a\x0b\x08\x10\n\r\n\x05\x04i\x02\0\x05\x12\x04\x8a\x0b\x11\x17\n\
    \r\n\x05\x04i\x02\0\x01\x12\x04\x8a\x0b\x18(\n\r\n\x05\x04i\x02\0\x03\
    \x12\x04\x8a\x0b+,\n\x0c\n\x04\x04i\x02\x01\x12\x04\x8b\x0b\x08*\n\r\n\
    \x05\x04i\x02\x01\x04\x12\x04\x8b\x0b\x08\x10\n\r\n\x05\x04i\x02\x01\x05\
    \x12\x04\x8b\x0b\x11\x17\n\r\n\x05\x04i\x02\x01\x01\x12\x04\x8b\x0b\x18%\
    \n\r\n\x05\x04i\x02\x01\x03\x12\x04\x8b\x0b()\n\x0c\n\x04\x04i\x02\x02\
    \x12\x04\x8c\x0b\x08*\n\r\n\x05\x04i\x02\x02\x04\x12\x04\x8c\x0b\x08\x10\
    \n\r\n\x05\x04i\x02\x02\x05\x12\x04\x8c\x0b\x11\x17\n\r\n\x05\x04i\x02\
    \x02\x01\x12\x04\x8c\x0b\x18%\n\r\n\x05\x04i\x02\x02\x03\x12\x04\x8c\x0b\
    ()\n\x0c\n\x04\x04i\x02\x03\x12\x04\x8d\x0b\x08'\n\r\n\x05\x04i\x02\x03\
    \x04\x12\x04\x8d\x0b\x08\x10\n\r\n\x05\x04i\x02\x03\x05\x12\x04\x8d\x0b\
    \x11\x17\n\r\n\x05\x04i\x02\x03\x01\x12\x04\x8d\x0b\x18\"\n\r\n\x05\x04i\
    \x02\x03\x03\x12\x04\x8d\x0b%&\n\x0c\n\x02\x04j\x12\x06\x90\x0b\0\x95\
    \x0b\x01\n\x0b\n\x03\x04j\x01\x12\x04\x90\x0b\x08\x1f\n\x0c\n\x04\x04j\
    \x02\0\x12\x04\x91\x0b\x08$\n\r\n\x05\x04j\x02\0\x04\x12\x04\x91\x0b\x08\
    \x10\n\r\n\x05\x04j\x02\0\x05\x12\x04\x91\x0b\x11\x17\n\r\n\x05\x04j\x02\
    \0\x01\x12\x04\x91\x0b\x18\x1f\n\r\n\x05\x04j\x02\0\x03\x12\x04\x91\x0b\
    \"#\n\x0c\n\x04\x04j\x02\x01\x12\x04\x92\x0b\x08!\n\r\n\x05\x04j\x02\x01\
    \x04\x12\x04\x92\x0b\x08\x10\n\r\n\x05\x04j\x02\x01\x05\x12\x04\x92\x0b\
    \x11\x17\n\r\n\x05\x04j\x02\x01\x01\x12\x04\x92\x0b\x18\x1c\n\r\n\x05\
    \x04j\x02\x01\x03\x12\x04\x92\x0b\x1f\x20\n\x0c\n\x04\x04j\x02\x02\x12\
    \x04\x93\x0b\x08,\n\r\n\x05\x04j\x02\x02\x04\x12\x04\x93\x0b\x08\x10\n\r\
    \n\x05\x04j\x02\x02\x05\x12\x04\x93\x0b\x11\x17\n\r\n\x05\x04j\x02\x02\
    \x01\x12\x04\x93\x0b\x18'\n\r\n\x05\x04j\x02\x02\x03\x12\x04\x93\x0b*+\n\
    \x0c\n\x04\x04j\x02\x03\x12\x04\x94\x0b\x08+\n\r\n\x05\x04j\x02\x03\x04\
    \x12\x04\x94\x0b\x08\x10\n\r\n\x05\x04j\x02\x03\x05\x12\x04\x94\x0b\x11\
    \x17\n\r\n\x05\x04j\x02\x03\x01\x12\x04\x94\x0b\x18&\n\r\n\x05\x04j\x02\
    \x03\x03\x12\x04\x94\x0b)*\n\x0c\n\x02\x04k\x12\x06\x97\x0b\0\xb4\x0b\
    \x01\n\x0b\n\x03\x04k\x01\x12\x04\x97\x0b\x08\x20\n\x0e\n\x04\x04k\x03\0\
    \x12\x06\x98\x0b\x08\xa2\x0b\t\n\r\n\x05\x04k\x03\0\x01\x12\x04\x98\x0b\
    \x10\x1b\n\x0e\n\x06\x04k\x03\0\x02\0\x12\x04\x99\x0b\x10,\n\x0f\n\x07\
    \x04k\x03\0\x02\0\x04\x12\x04\x99\x0b\x10\x18\n\x0f\n\x07\x04k\x03\0\x02\
    \0\x05\x12\x04\x99\x0b\x19\x1f\n\x0f\n\x07\x04k\x03\0\x02\0\x01\x12\x04\
    \x99\x0b\x20'\n\x0f\n\x07\x04k\x03\0\x02\0\x03\x12\x04\x99\x0b*+\n\x0e\n\
    \x06\x04k\x03\0\x02\x01\x12\x04\x9a\x0b\x10.\n\x0f\n\x07\x04k\x03\0\x02\
    \x01\x04\x12\x04\x9a\x0b\x10\x18\n\x0f\n\x07\x04k\x03\0\x02\x01\x05\x12\
    \x04\x9a\x0b\x19\x1f\n\x0f\n\x07\x04k\x03\0\x02\x01\x01\x12\x04\x9a\x0b\
    \x20)\n\x0f\n\x07\x04k\x03\0\x02\x01\x03\x12\x04\x9a\x0b,-\n\x0e\n\x06\
    \x04k\x03\0\x02\x02\x12\x04\x9b\x0b\x10*\n\x0f\n\x07\x04k\x03\0\x02\x02\
    \x04\x12\x04\x9b\x0b\x10\x18\n\x0f\n\x07\x04k\x03\0\x02\x02\x05\x12\x04\
    \x9b\x0b\x19\x1f\n\x0f\n\x07\x04k\x03\0\x02\x02\x01\x12\x04\x9b\x0b\x20%\
    \n\x0f\n\x07\x04k\x03\0\x02\x02\x03\x12\x04\x9b\x0b()\n\x0e\n\x06\x04k\
    \x03\0\x02\x03\x12\x04\x9c\x0b\x10+\n\x0f\n\x07\x04k\x03\0\x02\x03\x04\
    \x12\x04\x9c\x0b\x10\x18\n\x0f\n\x07\x04k\x03\0\x02\x03\x05\x12\x04\x9c\
    \x0b\x19\x1f\n\x0f\n\x07\x04k\x03\0\x02\x03\x01\x12\x04\x9c\x0b\x20&\n\
    \x0f\n\x07\x04k\x03\0\x02\x03\x03\x12\x04\x9c\x0b)*\n\x0e\n\x06\x04k\x03\
    \0\x02\x04\x12\x04\x9d\x0b\x101\n\x0f\n\x07\x04k\x03\0\x02\x04\x04\x12\
    \x04\x9d\x0b\x10\x18\n\x0f\n\x07\x04k\x03\0\x02\x04\x05\x12\x04\x9d\x0b\
    \x19\x1f\n\x0f\n\x07\x04k\x03\0\x02\x04\x01\x12\x04\x9d\x0b\x20,\n\x0f\n\
    \x07\x04k\x03\0\x02\x04\x03\x12\x04\x9d\x0b/0\n\x0e\n\x06\x04k\x03\0\x02\
    \x05\x12\x04\x9e\x0b\x10.\n\x0f\n\x07\x04k\x03\0\x02\x05\x04\x12\x04\x9e\
    \x0b\x10\x18\n\x0f\n\x07\x04k\x03\0\x02\x05\x05\x12\x04\x9e\x0b\x19\x1d\
    \n\x0f\n\x07\x04k\x03\0\x02\x05\x01\x12\x04\x9e\x0b\x1e)\n\x0f\n\x07\x04\
    k\x03\0\x02\x05\x03\x12\x04\x9e\x0b,-\n\x0e\n\x06\x04k\x03\0\x02\x06\x12\
    \x04\x9f\x0b\x10,\n\x0f\n\x07\x04k\x03\0\x02\x06\x04\x12\x04\x9f\x0b\x10\
    \x18\n\x0f\n\x07\x04k\x03\0\x02\x06\x05\x12\x04\x9f\x0b\x19\x1d\n\x0f\n\
    \x07\x04k\x03\0\x02\x06\x01\x12\x04\x9f\x0b\x1e'\n\x0f\n\x07\x04k\x03\0\
    \x02\x06\x03\x12\x04\x9f\x0b*+\n\x0e\n\x06\x04k\x03\0\x02\x07\x12\x04\
    \xa0\x0b\x10-\n\x0f\n\x07\x04k\x03\0\x02\x07\x04\x12\x04\xa0\x0b\x10\x18\
    \n\x0f\n\x07\x04k\x03\0\x02\x07\x05\x12\x04\xa0\x0b\x19\x1d\n\x0f\n\x07\
    \x04k\x03\0\x02\x07\x01\x12\x04\xa0\x0b\x1e(\n\x0f\n\x07\x04k\x03\0\x02\
    \x07\x03\x12\x04\xa0\x0b+,\n\x0e\n\x06\x04k\x03\0\x02\x08\x12\x04\xa1\
    \x0b\x10-\n\x0f\n\x07\x04k\x03\0\x02\x08\x04\x12\x04\xa1\x0b\x10\x18\n\
    \x0f\n\x07\x04k\x03\0\x02\x08\x05\x12\x04\xa1\x0b\x19\x1f\n\x0f\n\x07\
    \x04k\x03\0\x02\x08\x01\x12\x04\xa1\x0b\x20(\n\x0f\n\x07\x04k\x03\0\x02\
    \x08\x03\x12\x04\xa1\x0b+,\n\x0e\n\x04\x04k\x03\x01\x12\x06\xa4\x0b\x08\
    \xaf\x0b\t\n\r\n\x05\x04k\x03\x01\x01\x12\x04\xa4\x0b\x10\x19\n\x0e\n\
    \x06\x04k\x03\x01\x02\0\x12\x04\xa5\x0b\x10)\n\x0f\n\x07\x04k\x03\x01\
    \x02\0\x04\x12\x04\xa5\x0b\x10\x18\n\x0f\n\x07\x04k\x03\x01\x02\0\x05\
    \x12\x04\xa5\x0b\x19\x1f\n\x0f\n\x07\x04k\x03\x01\x02\0\x01\x12\x04\xa5\
    \x0b\x20$\n\x0f\n\x07\x04k\x03\x01\x02\0\x03\x12\x04\xa5\x0b'(\n\x0e\n\
    \x06\x04k\x03\x01\x02\x01\x12\x04\xa6\x0b\x10P\n\x0f\n\x07\x04k\x03\x01\
    \x02\x01\x04\x12\x04\xa6\x0b\x10\x18\n\x0f\n\x07\x04k\x03\x01\x02\x01\
    \x06\x12\x04\xa6\x0b\x19=\n\x0f\n\x07\x04k\x03\x01\x02\x01\x01\x12\x04\
    \xa6\x0b>K\n\x0f\n\x07\x04k\x03\x01\x02\x01\x03\x12\x04\xa6\x0bNO\n\x0e\
    \n\x06\x04k\x03\x01\x02\x02\x12\x04\xa7\x0b\x105\n\x0f\n\x07\x04k\x03\
    \x01\x02\x02\x04\x12\x04\xa7\x0b\x10\x18\n\x0f\n\x07\x04k\x03\x01\x02\
    \x02\x05\x12\x04\xa7\x0b\x19\x1f\n\x0f\n\x07\x04k\x03\x01\x02\x02\x01\
    \x12\x04\xa7\x0b\x200\n\x0f\n\x07\x04k\x03\x01\x02\x02\x03\x12\x04\xa7\
    \x0b34\n\x0e\n\x06\x04k\x03\x01\x02\x03\x12\x04\xa8\x0b\x108\n\x0f\n\x07\
    \x04k\x03\x01\x02\x03\x04\x12\x04\xa8\x0b\x10\x18\n\x0f\n\x07\x04k\x03\
    \x01\x02\x03\x05\x12\x04\xa8\x0b\x19\x1f\n\x0f\n\x07\x04k\x03\x01\x02\
    \x03\x01\x12\x04\xa8\x0b\x203\n\x0f\n\x07\x04k\x03\x01\x02\x03\x03\x12\
    \x04\xa8\x0b67\n\x0e\n\x06\x04k\x03\x01\x02\x04\x12\x04\xa9\x0b\x107\n\
    \x0f\n\x07\x04k\x03\x01\x02\x04\x04\x12\x04\xa9\x0b\x10\x18\n\x0f\n\x07\
    \x04k\x03\x01\x02\x04\x05\x12\x04\xa9\x0b\x19\x1f\n\x0f\n\x07\x04k\x03\
    \x01\x02\x04\x01\x12\x04\xa9\x0b\x202\n\x0f\n\x07\x04k\x03\x01\x02\x04\
    \x03\x12\x04\xa9\x0b56\n\x0e\n\x06\x04k\x03\x01\x02\x05\x12\x04\xaa\x0b\
    \x103\n\x0f\n\x07\x04k\x03\x01\x02\x05\x04\x12\x04\xaa\x0b\x10\x18\n\x0f\
    \n\x07\x04k\x03\x01\x02\x05\x05\x12\x04\xaa\x0b\x19\x1f\n\x0f\n\x07\x04k\
    \x03\x01\x02\x05\x01\x12\x04\xaa\x0b\x20.\n\x0f\n\x07\x04k\x03\x01\x02\
    \x05\x03\x12\x04\xaa\x0b12\n\x0e\n\x06\x04k\x03\x01\x02\x06\x12\x04\xab\
    \x0b\x10*\n\x0f\n\x07\x04k\x03\x01\x02\x06\x04\x12\x04\xab\x0b\x10\x18\n\
    \x0f\n\x07\x04k\x03\x01\x02\x06\x05\x12\x04\xab\x0b\x19\x1f\n\x0f\n\x07\
    \x04k\x03\x01\x02\x06\x01\x12\x04\xab\x0b\x20%\n\x0f\n\x07\x04k\x03\x01\
    \x02\x06\x03\x12\x04\xab\x0b()\n\x0e\n\x06\x04k\x03\x01\x02\x07\x12\x04\
    \xac\x0b\x108\n\x0f\n\x07\x04k\x03\x01\x02\x07\x04\x12\x04\xac\x0b\x10\
    \x18\n\x0f\n\x07\x04k\x03\x01\x02\x07\x05\x12\x04\xac\x0b\x19\x1f\n\x0f\
    \n\x07\x04k\x03\x01\x02\x07\x01\x12\x04\xac\x0b\x203\n\x0f\n\x07\x04k\
    \x03\x01\x02\x07\x03\x12\x04\xac\x0b67\n\x0e\n\x06\x04k\x03\x01\x02\x08\
    \x12\x04\xad\x0b\x107\n\x0f\n\x07\x04k\x03\x01\x02\x08\x04\x12\x04\xad\
    \x0b\x10\x18\n\x0f\n\x07\x04k\x03\x01\x02\x08\x05\x12\x04\xad\x0b\x19\
    \x1f\n\x0f\n\x07\x04k\x03\x01\x02\x08\x01\x12\x04\xad\x0b\x202\n\x0f\n\
    \x07\x04k\x03\x01\x02\x08\x03\x12\x04\xad\x0b56\n\x0e\n\x06\x04k\x03\x01\
    \x02\t\x12\x04\xae\x0b\x108\n\x0f\n\x07\x04k\x03\x01\x02\t\x04\x12\x04\
    \xae\x0b\x10\x18\n\x0f\n\x07\x04k\x03\x01\x02\t\x05\x12\x04\xae\x0b\x19\
    \x1f\n\x0f\n\x07\x04k\x03\x01\x02\t\x01\x12\x04\xae\x0b\x202\n\x0f\n\x07\
    \x04k\x03\x01\x02\t\x03\x12\x04\xae\x0b57\n\x0c\n\x04\x04k\x02\0\x12\x04\
    \xb1\x0b\x08%\n\r\n\x05\x04k\x02\0\x04\x12\x04\xb1\x0b\x08\x10\n\r\n\x05\
    \x04k\x02\0\x05\x12\x04\xb1\x0b\x11\x16\n\r\n\x05\x04k\x02\0\x01\x12\x04\
    \xb1\x0b\x17\x20\n\r\n\x05\x04k\x02\0\x03\x12\x04\xb1\x0b#$\n\x0c\n\x04\
    \x04k\x02\x01\x12\x04\xb2\x0b\x08F\n\r\n\x05\x04k\x02\x01\x04\x12\x04\
    \xb2\x0b\x08\x10\n\r\n\x05\x04k\x02\x01\x06\x12\x04\xb2\x0b\x113\n\r\n\
    \x05\x04k\x02\x01\x01\x12\x04\xb2\x0b4A\n\r\n\x05\x04k\x02\x01\x03\x12\
    \x04\xb2\x0bDE\n\x0c\n\x04\x04k\x02\x02\x12\x04\xb3\x0b\x08C\n\r\n\x05\
    \x04k\x02\x02\x04\x12\x04\xb3\x0b\x08\x10\n\r\n\x05\x04k\x02\x02\x06\x12\
    \x04\xb3\x0b\x113\n\r\n\x05\x04k\x02\x02\x01\x12\x04\xb3\x0b4>\n\r\n\x05\
    \x04k\x02\x02\x03\x12\x04\xb3\x0bAB\n\x0c\n\x02\x04l\x12\x06\xb6\x0b\0\
    \xbf\x0b\x01\n\x0b\n\x03\x04l\x01\x12\x04\xb6\x0b\x08\"\n\x0c\n\x04\x04l\
    \x02\0\x12\x04\xb7\x0b\x08#\n\r\n\x05\x04l\x02\0\x04\x12\x04\xb7\x0b\x08\
    \x10\n\r\n\x05\x04l\x02\0\x05\x12\x04\xb7\x0b\x11\x16\n\r\n\x05\x04l\x02\
    \0\x01\x12\x04\xb7\x0b\x17\x1e\n\r\n\x05\x04l\x02\0\x03\x12\x04\xb7\x0b!\
    \"\n\x0c\n\x04\x04l\x02\x01\x12\x04\xb8\x0b\x08+\n\r\n\x05\x04l\x02\x01\
    \x04\x12\x04\xb8\x0b\x08\x10\n\r\n\x05\x04l\x02\x01\x05\x12\x04\xb8\x0b\
    \x11\x16\n\r\n\x05\x04l\x02\x01\x01\x12\x04\xb8\x0b\x17&\n\r\n\x05\x04l\
    \x02\x01\x03\x12\x04\xb8\x0b)*\n\x0c\n\x04\x04l\x02\x02\x12\x04\xb9\x0b\
    \x08,\n\r\n\x05\x04l\x02\x02\x04\x12\x04\xb9\x0b\x08\x10\n\r\n\x05\x04l\
    \x02\x02\x05\x12\x04\xb9\x0b\x11\x16\n\r\n\x05\x04l\x02\x02\x01\x12\x04\
    \xb9\x0b\x17'\n\r\n\x05\x04l\x02\x02\x03\x12\x04\xb9\x0b*+\n\x0c\n\x04\
    \x04l\x02\x03\x12\x04\xba\x0b\x08!\n\r\n\x05\x04l\x02\x03\x04\x12\x04\
    \xba\x0b\x08\x10\n\r\n\x05\x04l\x02\x03\x05\x12\x04\xba\x0b\x11\x17\n\r\
    \n\x05\x04l\x02\x03\x01\x12\x04\xba\x0b\x18\x1c\n\r\n\x05\x04l\x02\x03\
    \x03\x12\x04\xba\x0b\x1f\x20\n\x0c\n\x04\x04l\x02\x04\x12\x04\xbb\x0b\
    \x08&\n\r\n\x05\x04l\x02\x04\x04\x12\x04\xbb\x0b\x08\x10\n\r\n\x05\x04l\
    \x02\x04\x05\x12\x04\xbb\x0b\x11\x17\n\r\n\x05\x04l\x02\x04\x01\x12\x04\
    \xbb\x0b\x18!\n\r\n\x05\x04l\x02\x04\x03\x12\x04\xbb\x0b$%\n\x0c\n\x04\
    \x04l\x02\x05\x12\x04\xbc\x0b\x08,\n\r\n\x05\x04l\x02\x05\x04\x12\x04\
    \xbc\x0b\x08\x10\n\r\n\x05\x04l\x02\x05\x05\x12\x04\xbc\x0b\x11\x17\n\r\
    \n\x05\x04l\x02\x05\x01\x12\x04\xbc\x0b\x18'\n\r\n\x05\x04l\x02\x05\x03\
    \x12\x04\xbc\x0b*+\n\x0c\n\x04\x04l\x02\x06\x12\x04\xbd\x0b\x08%\n\r\n\
    \x05\x04l\x02\x06\x04\x12\x04\xbd\x0b\x08\x10\n\r\n\x05\x04l\x02\x06\x05\
    \x12\x04\xbd\x0b\x11\x16\n\r\n\x05\x04l\x02\x06\x01\x12\x04\xbd\x0b\x17\
    \x20\n\r\n\x05\x04l\x02\x06\x03\x12\x04\xbd\x0b#$\n\x0c\n\x04\x04l\x02\
    \x07\x12\x04\xbe\x0b\x08-\n\r\n\x05\x04l\x02\x07\x04\x12\x04\xbe\x0b\x08\
    \x10\n\r\n\x05\x04l\x02\x07\x05\x12\x04\xbe\x0b\x11\x15\n\r\n\x05\x04l\
    \x02\x07\x01\x12\x04\xbe\x0b\x16(\n\r\n\x05\x04l\x02\x07\x03\x12\x04\xbe\
    \x0b+,\n\x0c\n\x02\x04m\x12\x06\xc1\x0b\0\xc5\x0b\x01\n\x0b\n\x03\x04m\
    \x01\x12\x04\xc1\x0b\x08*\n\x0c\n\x04\x04m\x02\0\x12\x04\xc2\x0b\x08$\n\
    \r\n\x05\x04m\x02\0\x04\x12\x04\xc2\x0b\x08\x10\n\r\n\x05\x04m\x02\0\x05\
    \x12\x04\xc2\x0b\x11\x16\n\r\n\x05\x04m\x02\0\x01\x12\x04\xc2\x0b\x17\
    \x1f\n\r\n\x05\x04m\x02\0\x03\x12\x04\xc2\x0b\"#\n\x0c\n\x04\x04m\x02\
    \x01\x12\x04\xc3\x0b\x08,\n\r\n\x05\x04m\x02\x01\x04\x12\x04\xc3\x0b\x08\
    \x10\n\r\n\x05\x04m\x02\x01\x05\x12\x04\xc3\x0b\x11\x17\n\r\n\x05\x04m\
    \x02\x01\x01\x12\x04\xc3\x0b\x18'\n\r\n\x05\x04m\x02\x01\x03\x12\x04\xc3\
    \x0b*+\n\x0c\n\x04\x04m\x02\x02\x12\x04\xc4\x0b\x08-\n\r\n\x05\x04m\x02\
    \x02\x04\x12\x04\xc4\x0b\x08\x10\n\r\n\x05\x04m\x02\x02\x05\x12\x04\xc4\
    \x0b\x11\x15\n\r\n\x05\x04m\x02\x02\x01\x12\x04\xc4\x0b\x16(\n\r\n\x05\
    \x04m\x02\x02\x03\x12\x04\xc4\x0b+,\n\x0c\n\x02\x04n\x12\x06\xc7\x0b\0\
    \xcc\x0b\x01\n\x0b\n\x03\x04n\x01\x12\x04\xc7\x0b\x08\"\n\x0c\n\x04\x04n\
    \x02\0\x12\x04\xc8\x0b\x08&\n\r\n\x05\x04n\x02\0\x04\x12\x04\xc8\x0b\x08\
    \x10\n\r\n\x05\x04n\x02\0\x05\x12\x04\xc8\x0b\x11\x16\n\r\n\x05\x04n\x02\
    \0\x01\x12\x04\xc8\x0b\x17!\n\r\n\x05\x04n\x02\0\x03\x12\x04\xc8\x0b$%\n\
    \x0c\n\x04\x04n\x02\x01\x12\x04\xc9\x0b\x08-\n\r\n\x05\x04n\x02\x01\x04\
    \x12\x04\xc9\x0b\x08\x10\n\r\n\x05\x04n\x02\x01\x05\x12\x04\xc9\x0b\x11\
    \x16\n\r\n\x05\x04n\x02\x01\x01\x12\x04\xc9\x0b\x17(\n\r\n\x05\x04n\x02\
    \x01\x03\x12\x04\xc9\x0b+,\n\x0c\n\x04\x04n\x02\x02\x12\x04\xca\x0b\x08%\
    \n\r\n\x05\x04n\x02\x02\x04\x12\x04\xca\x0b\x08\x10\n\r\n\x05\x04n\x02\
    \x02\x05\x12\x04\xca\x0b\x11\x16\n\r\n\x05\x04n\x02\x02\x01\x12\x04\xca\
    \x0b\x17\x20\n\r\n\x05\x04n\x02\x02\x03\x12\x04\xca\x0b#$\n\x0c\n\x04\
    \x04n\x02\x03\x12\x04\xcb\x0b\x08-\n\r\n\x05\x04n\x02\x03\x04\x12\x04\
    \xcb\x0b\x08\x10\n\r\n\x05\x04n\x02\x03\x05\x12\x04\xcb\x0b\x11\x15\n\r\
    \n\x05\x04n\x02\x03\x01\x12\x04\xcb\x0b\x16(\n\r\n\x05\x04n\x02\x03\x03\
    \x12\x04\xcb\x0b+,\n\x0c\n\x02\x04o\x12\x06\xce\x0b\0\xd7\x0b\x01\n\x0b\
    \n\x03\x04o\x01\x12\x04\xce\x0b\x08#\n\x0e\n\x04\x04o\x03\0\x12\x06\xcf\
    \x0b\x08\xd2\x0b\t\n\r\n\x05\x04o\x03\0\x01\x12\x04\xcf\x0b\x10\x18\n\
    \x0e\n\x06\x04o\x03\0\x02\0\x12\x04\xd0\x0b\x10%\n\x0f\n\x07\x04o\x03\0\
    \x02\0\x04\x12\x04\xd0\x0b\x10\x18\n\x0f\n\x07\x04o\x03\0\x02\0\x05\x12\
    \x04\xd0\x0b\x19\x1e\n\x0f\n\x07\x04o\x03\0\x02\0\x01\x12\x04\xd0\x0b\
    \x1f\x20\n\x0f\n\x07\x04o\x03\0\x02\0\x03\x12\x04\xd0\x0b#$\n\x0e\n\x06\
    \x04o\x03\0\x02\x01\x12\x04\xd1\x0b\x10%\n\x0f\n\x07\x04o\x03\0\x02\x01\
    \x04\x12\x04\xd1\x0b\x10\x18\n\x0f\n\x07\x04o\x03\0\x02\x01\x05\x12\x04\
    \xd1\x0b\x19\x1e\n\x0f\n\x07\x04o\x03\0\x02\x01\x01\x12\x04\xd1\x0b\x1f\
    \x20\n\x0f\n\x07\x04o\x03\0\x02\x01\x03\x12\x04\xd1\x0b#$\n\x0c\n\x04\
    \x04o\x02\0\x12\x04\xd4\x0b\x08C\n\r\n\x05\x04o\x02\0\x04\x12\x04\xd4\
    \x0b\x08\x10\n\r\n\x05\x04o\x02\0\x06\x12\x04\xd4\x0b\x115\n\r\n\x05\x04\
    o\x02\0\x01\x12\x04\xd4\x0b6>\n\r\n\x05\x04o\x02\0\x03\x12\x04\xd4\x0bAB\
    \n\x0c\n\x04\x04o\x02\x01\x12\x04\xd5\x0b\x08M\n\r\n\x05\x04o\x02\x01\
    \x04\x12\x04\xd5\x0b\x08\x10\n\r\n\x05\x04o\x02\x01\x06\x12\x04\xd5\x0b\
    \x115\n\r\n\x05\x04o\x02\x01\x01\x12\x04\xd5\x0b6H\n\r\n\x05\x04o\x02\
    \x01\x03\x12\x04\xd5\x0bKL\n\x0c\n\x04\x04o\x02\x02\x12\x04\xd6\x0b\x08!\
    \n\r\n\x05\x04o\x02\x02\x04\x12\x04\xd6\x0b\x08\x10\n\r\n\x05\x04o\x02\
    \x02\x05\x12\x04\xd6\x0b\x11\x17\n\r\n\x05\x04o\x02\x02\x01\x12\x04\xd6\
    \x0b\x18\x1c\n\r\n\x05\x04o\x02\x02\x03\x12\x04\xd6\x0b\x1f\x20\n\x0c\n\
    \x02\x04p\x12\x06\xd9\x0b\0\xdb\x0b\x01\n\x0b\n\x03\x04p\x01\x12\x04\xd9\
    \x0b\x08!\n\x0c\n\x04\x04p\x02\0\x12\x04\xda\x0b\x08+\n\r\n\x05\x04p\x02\
    \0\x04\x12\x04\xda\x0b\x08\x10\n\r\n\x05\x04p\x02\0\x05\x12\x04\xda\x0b\
    \x11\x16\n\r\n\x05\x04p\x02\0\x01\x12\x04\xda\x0b\x17&\n\r\n\x05\x04p\
    \x02\0\x03\x12\x04\xda\x0b)*\n\x0c\n\x02\x04q\x12\x06\xdd\x0b\0\xe5\x0b\
    \x01\n\x0b\n\x03\x04q\x01\x12\x04\xdd\x0b\x08\x1b\n\x0e\n\x04\x04q\x03\0\
    \x12\x06\xde\x0b\x08\xe1\x0b\t\n\r\n\x05\x04q\x03\0\x01\x12\x04\xde\x0b\
    \x10\x16\n\x0e\n\x06\x04q\x03\0\x02\0\x12\x04\xdf\x0b\x10/\n\x0f\n\x07\
    \x04q\x03\0\x02\0\x04\x12\x04\xdf\x0b\x10\x18\n\x0f\n\x07\x04q\x03\0\x02\
    \0\x05\x12\x04\xdf\x0b\x19\x1f\n\x0f\n\x07\x04q\x03\0\x02\0\x01\x12\x04\
    \xdf\x0b\x20*\n\x0f\n\x07\x04q\x03\0\x02\0\x03\x12\x04\xdf\x0b-.\n\x0e\n\
    \x06\x04q\x03\0\x02\x01\x12\x04\xe0\x0b\x10A\n\x0f\n\x07\x04q\x03\0\x02\
    \x01\x04\x12\x04\xe0\x0b\x10\x18\n\x0f\n\x07\x04q\x03\0\x02\x01\x06\x12\
    \x04\xe0\x0b\x19-\n\x0f\n\x07\x04q\x03\0\x02\x01\x01\x12\x04\xe0\x0b.<\n\
    \x0f\n\x07\x04q\x03\0\x02\x01\x03\x12\x04\xe0\x0b?@\n\x0c\n\x04\x04q\x02\
    \0\x12\x04\xe3\x0b\x088\n\r\n\x05\x04q\x02\0\x04\x12\x04\xe3\x0b\x08\x10\
    \n\r\n\x05\x04q\x02\0\x06\x12\x04\xe3\x0b\x11+\n\r\n\x05\x04q\x02\0\x01\
    \x12\x04\xe3\x0b,3\n\r\n\x05\x04q\x02\0\x03\x12\x04\xe3\x0b67\n\x0c\n\
    \x04\x04q\x02\x01\x12\x04\xe4\x0b\x087\n\r\n\x05\x04q\x02\x01\x04\x12\
    \x04\xe4\x0b\x08\x10\n\r\n\x05\x04q\x02\x01\x06\x12\x04\xe4\x0b\x11%\n\r\
    \n\x05\x04q\x02\x01\x01\x12\x04\xe4\x0b&2\n\r\n\x05\x04q\x02\x01\x03\x12\
    \x04\xe4\x0b56\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(10);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::valveextensions::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common::file_descriptor().clone());
            deps.push(super::econ_gcmessages::file_descriptor().clone());
            deps.push(super::network_connection::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common_lobby::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common_match_management::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            deps.push(super::steammessages_steamlearn_steamworkssdk::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(180);
            messages.push(CMsgPoorNetworkConditions::generated_message_descriptor_data());
            messages.push(CMsgGameserverCrash::generated_message_descriptor_data());
            messages.push(CMsgConnectedPlayers::generated_message_descriptor_data());
            messages.push(CMsgGameServerInfo::generated_message_descriptor_data());
            messages.push(CMsgLeaverDetected::generated_message_descriptor_data());
            messages.push(CMsgLeaverDetectedResponse::generated_message_descriptor_data());
            messages.push(CMsgDOTAFantasyFinalPlayerStats::generated_message_descriptor_data());
            messages.push(CMsgDOTAFantasyLivePlayerStats::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRealtimeStats::generated_message_descriptor_data());
            messages.push(CMsgGCToServerRealtimeStatsStartStop::generated_message_descriptor_data());
            messages.push(CMsgGCToServerUpdateSteamBroadcasting::generated_message_descriptor_data());
            messages.push(CMsgSignOutGameplayStats::generated_message_descriptor_data());
            messages.push(CMsgGameMatchSignOut::generated_message_descriptor_data());
            messages.push(CMsgSignOutDraftInfo::generated_message_descriptor_data());
            messages.push(CMsgSignOutBotInfo::generated_message_descriptor_data());
            messages.push(CMsgSignOutTextMuteInfo::generated_message_descriptor_data());
            messages.push(CMsgSignOutPlayerStats::generated_message_descriptor_data());
            messages.push(CMsgSignOutCommunicationSummary::generated_message_descriptor_data());
            messages.push(CMsgGameMatchSignoutResponse::generated_message_descriptor_data());
            messages.push(CMsgTimedRewardContainer::generated_message_descriptor_data());
            messages.push(CMsgGameMatchSignOutPermissionRequest::generated_message_descriptor_data());
            messages.push(CMsgGameMatchSignOutPermissionResponse::generated_message_descriptor_data());
            messages.push(CMsgGameMatchSignOutEventGameData::generated_message_descriptor_data());
            messages.push(CMsgGameMatchSignOutPerfData::generated_message_descriptor_data());
            messages.push(CMsgGameMatchSignOutBanData::generated_message_descriptor_data());
            messages.push(CMsgDOTALiveScoreboardUpdate::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRequestBatchPlayerResources::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRequestBatchPlayerResourcesResponse::generated_message_descriptor_data());
            messages.push(CMsgDOTAPlayerFailedToConnect::generated_message_descriptor_data());
            messages.push(CMsgGCToRelayConnect::generated_message_descriptor_data());
            messages.push(CMsgGCGCToLANServerRelayConnect::generated_message_descriptor_data());
            messages.push(CMsgGCBanStatusRequest::generated_message_descriptor_data());
            messages.push(CMsgGCBanStatusResponse::generated_message_descriptor_data());
            messages.push(CMsgTournamentItemEvent::generated_message_descriptor_data());
            messages.push(CMsgTournamentItemEventResponse::generated_message_descriptor_data());
            messages.push(CMsgTeamFanfare::generated_message_descriptor_data());
            messages.push(CMsgResponseTeamFanfare::generated_message_descriptor_data());
            messages.push(CMsgGameServerUploadSaveGame::generated_message_descriptor_data());
            messages.push(CMsgGameServerSaveGameResult::generated_message_descriptor_data());
            messages.push(CMsgGameServerGetLoadGame::generated_message_descriptor_data());
            messages.push(CMsgGameServerGetLoadGameResult::generated_message_descriptor_data());
            messages.push(CMsgDOTAAwardEventPoints::generated_message_descriptor_data());
            messages.push(CMsgGCToServerPingRequest::generated_message_descriptor_data());
            messages.push(CMsgGCToServerPingResponse::generated_message_descriptor_data());
            messages.push(CMsgServerToGCMatchConnectionStats::generated_message_descriptor_data());
            messages.push(CMsgServerGCUpdateSpectatorCount::generated_message_descriptor_data());
            messages.push(CSerializedCombatLog::generated_message_descriptor_data());
            messages.push(CMsgServerToGCVictoryPredictions::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRequestStatus::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRequestStatus_Response::generated_message_descriptor_data());
            messages.push(CMsgSignOutAssassinMiniGameInfo::generated_message_descriptor_data());
            messages.push(CMsgServerToGCKillSummaries::generated_message_descriptor_data());
            messages.push(CMsgGCToServerPredictionResult::generated_message_descriptor_data());
            messages.push(CMsgServerToGCLockCharmTrading::generated_message_descriptor_data());
            messages.push(CMsgSignOutUpdatePlayerChallenge::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRerollPlayerChallenge::generated_message_descriptor_data());
            messages.push(CMsgSpendWager::generated_message_descriptor_data());
            messages.push(CMsgSignOutXPCoins::generated_message_descriptor_data());
            messages.push(CMsgSignOutBounties::generated_message_descriptor_data());
            messages.push(CMsgSignOutCommunityGoalProgress::generated_message_descriptor_data());
            messages.push(CMsgServerToGCCloseCompendiumInGamePredictionVoting::generated_message_descriptor_data());
            messages.push(CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse::generated_message_descriptor_data());
            messages.push(CMsgServerToGCCompendiumInGamePredictionResults::generated_message_descriptor_data());
            messages.push(CMsgServerToGCCompendiumChosenInGamePredictions::generated_message_descriptor_data());
            messages.push(CMsgGCToGCCompendiumInGamePredictionResults::generated_message_descriptor_data());
            messages.push(CMsgServerToGCMatchPlayerItemPurchaseHistory::generated_message_descriptor_data());
            messages.push(CMsgServerToGCMatchPlayerNeutralItemEquipHistory::generated_message_descriptor_data());
            messages.push(CMsgServerToGCMatchStateHistory::generated_message_descriptor_data());
            messages.push(CMsgMatchStateSteamMLEntry::generated_message_descriptor_data());
            messages.push(CMsgLaneSelectionSteamMLEntry::generated_message_descriptor_data());
            messages.push(CMsgAbilitySelectionSteamMLEntry::generated_message_descriptor_data());
            messages.push(CMsgItemPurchasePregameSteamMLEntry::generated_message_descriptor_data());
            messages.push(CMsgItemPurchaseSteamMLEntry::generated_message_descriptor_data());
            messages.push(CMsgItemPurchaseSequenceSteamMLEntry::generated_message_descriptor_data());
            messages.push(CMsgServerToGCCavernCrawlIsHeroActive::generated_message_descriptor_data());
            messages.push(CMsgServerToGCPlayerChallengeHistory::generated_message_descriptor_data());
            messages.push(CMsgServerToGCCavernCrawlIsHeroActiveResponse::generated_message_descriptor_data());
            messages.push(CMsgGCtoServerTensorflowInstance::generated_message_descriptor_data());
            messages.push(CMsgDetailedGameStats::generated_message_descriptor_data());
            messages.push(CMsgNeutralItemStats::generated_message_descriptor_data());
            messages.push(CMsgGCToServerLobbyHeroBanRates::generated_message_descriptor_data());
            messages.push(CMsgSignOutGuildContractProgress::generated_message_descriptor_data());
            messages.push(CMsgSignOutGuildChallengeProgress::generated_message_descriptor_data());
            messages.push(CMsgSignOutMVPStats::generated_message_descriptor_data());
            messages.push(CMsgGCToServerRecordTrainingData::generated_message_descriptor_data());
            messages.push(CMsgServerToGCGetGuildContracts::generated_message_descriptor_data());
            messages.push(CMsgServerToGCGetGuildContractsResponse::generated_message_descriptor_data());
            messages.push(CMsgMatchDiretideCandy::generated_message_descriptor_data());
            messages.push(CMsgGCToServerCheerData::generated_message_descriptor_data());
            messages.push(CMsgCheerConfig::generated_message_descriptor_data());
            messages.push(CMsgGCToServerCheerConfig::generated_message_descriptor_data());
            messages.push(CMsgServerToGCGetCheerConfig::generated_message_descriptor_data());
            messages.push(CMsgServerToGCGetCheerConfigResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToServerCheerScalesOverride::generated_message_descriptor_data());
            messages.push(CMsgGCToServerGetCheerState::generated_message_descriptor_data());
            messages.push(CMsgCheerTypeState::generated_message_descriptor_data());
            messages.push(CMsgCheerState::generated_message_descriptor_data());
            messages.push(CMsgServerToGCReportCheerState::generated_message_descriptor_data());
            messages.push(CMsgServerToGCGetStickerHeroes::generated_message_descriptor_data());
            messages.push(CMsgServerToGCGetStickerHeroesResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToServerSetSteamLearnDisable::generated_message_descriptor_data());
            messages.push(CMsgGCToServerSetSteamLearnInferencing::generated_message_descriptor_data());
            messages.push(CMsgGCToServerSetSteamLearnKeysChanged::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnMatchInfo::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnMatchInfoPlayer::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnMatchHeroes::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnMatchHero::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnMatchState::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnItemPurchase::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnPreGameItemPurchases::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnAbilitySkill::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnWardPlacement::generated_message_descriptor_data());
            messages.push(CMsgSignOutMuertaMinigame::generated_message_descriptor_data());
            messages.push(CMsgSignOutMapStats::generated_message_descriptor_data());
            messages.push(cmsg_poor_network_conditions::Player::generated_message_descriptor_data());
            messages.push(cmsg_connected_players::Player::generated_message_descriptor_data());
            messages.push(cmsg_connected_players::PlayerDraft::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_gameplay_stats::CPlayer::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_gameplay_stats::CTeam::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::CTeam::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::CAdditionalSignoutMsg::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::CSocialFeedMatchEvent::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::CCustomGameData::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::EventGameLeaderboardEntry::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::WardPlacement::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::cteam::CPlayer::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::cteam::cplayer::CCustomGameData::generated_message_descriptor_data());
            messages.push(cmsg_game_match_sign_out::cteam::cplayer::HeroDamageReceived::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_text_mute_info::TextMuteMessage::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_communication_summary::PlayerCommunication::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_communication_summary::player_communication::PingDetail::generated_message_descriptor_data());
            messages.push(cmsg_game_match_signout_response::PlayerMetadata::generated_message_descriptor_data());
            messages.push(cmsg_dotalive_scoreboard_update::Team::generated_message_descriptor_data());
            messages.push(cmsg_dotalive_scoreboard_update::team::Player::generated_message_descriptor_data());
            messages.push(cmsg_dotalive_scoreboard_update::team::player::HeroAbility::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcrequest_batch_player_resources_response::Result::generated_message_descriptor_data());
            messages.push(cmsg_dotaaward_event_points::AwardPoints::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_connection_stats::Player::generated_message_descriptor_data());
            messages.push(cserialized_combat_log::Dictionary::generated_message_descriptor_data());
            messages.push(cserialized_combat_log::dictionary::DictString::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcvictory_predictions::Record::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gckill_summaries::KillSummary::generated_message_descriptor_data());
            messages.push(cmsg_gcto_server_prediction_result::Prediction::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_update_player_challenge::Challenge::generated_message_descriptor_data());
            messages.push(cmsg_spend_wager::Player::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_xpcoins::Player::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_bounties::Bounty::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_community_goal_progress::EventGoalIncrement::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gccompendium_in_game_prediction_results::PredictionResult::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gccompendium_chosen_in_game_predictions::Prediction::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_player_item_purchase_history::ItemPurchase::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_player_item_purchase_history::Player::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_player_neutral_item_equip_history::ItemEquip::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_player_neutral_item_equip_history::Player::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_state_history::PlayerState::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_state_history::TeamState::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcmatch_state_history::MatchState::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcplayer_challenge_history::PlayerChallenge::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gccavern_crawl_is_hero_active_response::MapResults::generated_message_descriptor_data());
            messages.push(cmsg_detailed_game_stats::PlayerStatEntry::generated_message_descriptor_data());
            messages.push(cmsg_detailed_game_stats::GameStats::generated_message_descriptor_data());
            messages.push(cmsg_detailed_game_stats::MinuteEntry::generated_message_descriptor_data());
            messages.push(cmsg_detailed_game_stats::PlayerInfo::generated_message_descriptor_data());
            messages.push(cmsg_neutral_item_stats::NeutralItem::generated_message_descriptor_data());
            messages.push(cmsg_gcto_server_lobby_hero_ban_rates::HeroBanEntry::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_guild_contract_progress::CompletedGuildEventContracts::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_guild_contract_progress::PlayerContract::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_guild_challenge_progress::ChallengeProgress::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_mvpstats::Player::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_mvpstats::player::KillEaterEvent::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcget_guild_contracts_response::ContractDetails::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcget_guild_contracts_response::Player::generated_message_descriptor_data());
            messages.push(cmsg_match_diretide_candy::CandyDetails::generated_message_descriptor_data());
            messages.push(cmsg_match_diretide_candy::PlayerCandy::generated_message_descriptor_data());
            messages.push(cmsg_gcto_server_cheer_data::CheerTypeCount::generated_message_descriptor_data());
            messages.push(cmsg_server_to_gcget_sticker_heroes_response::Player::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_match_state::PlayerState::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_match_state::TeamState::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_ward_placement::Location::generated_message_descriptor_data());
            messages.push(cmsg_sign_out_map_stats::Player::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(8);
            enums.push(EPoorNetworkConditionsType::generated_enum_descriptor_data());
            enums.push(cmsg_connected_players::SendReason::generated_enum_descriptor_data());
            enums.push(cmsg_game_server_info::ServerType::generated_enum_descriptor_data());
            enums.push(cmsg_game_server_info::CustomGames::generated_enum_descriptor_data());
            enums.push(cmsg_game_match_sign_out::cteam::cplayer::HeroDamageType::generated_enum_descriptor_data());
            enums.push(cmsg_dotalive_scoreboard_update::team::player::DOTAUltimateState::generated_enum_descriptor_data());
            enums.push(cmsg_game_server_save_game_result::Result::generated_enum_descriptor_data());
            enums.push(cmsg_gcto_server_prediction_result::prediction::EResult::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
