// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_match_management.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgStartFindingMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartFindingMatch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.matchgroups)
    pub matchgroups: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.game_modes)
    pub game_modes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.match_type)
    pub match_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchType>>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.matchlanguages)
    pub matchlanguages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.game_language_enum)
    pub game_language_enum: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchLanguages>>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.game_language_name)
    pub game_language_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.ping_data)
    pub ping_data: ::protobuf::MessageField<super::base_gcmessages::CMsgClientPingData>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.region_select_flags)
    pub region_select_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.solo_queue)
    pub solo_queue: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.steam_clan_account_id)
    pub steam_clan_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.is_challenge_match)
    pub is_challenge_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.high_priority_disabled)
    pub high_priority_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.disable_experimental_gameplay)
    pub disable_experimental_gameplay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.custom_game_difficulty_mask)
    pub custom_game_difficulty_mask: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.bot_difficulty_mask)
    pub bot_difficulty_mask: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatch.bot_script_index_mask)
    pub bot_script_index_mask: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStartFindingMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartFindingMatch {
    fn default() -> &'a CMsgStartFindingMatch {
        <CMsgStartFindingMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartFindingMatch {
    pub fn new() -> CMsgStartFindingMatch {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 matchgroups = 2;

    pub fn matchgroups(&self) -> u32 {
        self.matchgroups.unwrap_or(0)
    }

    pub fn clear_matchgroups(&mut self) {
        self.matchgroups = ::std::option::Option::None;
    }

    pub fn has_matchgroups(&self) -> bool {
        self.matchgroups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups(&mut self, v: u32) {
        self.matchgroups = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 game_modes = 4;

    pub fn game_modes(&self) -> u32 {
        self.game_modes.unwrap_or(0)
    }

    pub fn clear_game_modes(&mut self) {
        self.game_modes = ::std::option::Option::None;
    }

    pub fn has_game_modes(&self) -> bool {
        self.game_modes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_modes(&mut self, v: u32) {
        self.game_modes = ::std::option::Option::Some(v);
    }

    // optional .dota.MatchType match_type = 6;

    pub fn match_type(&self) -> super::dota_shared_enums::MatchType {
        match self.match_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL),
            None => super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL,
        }
    }

    pub fn clear_match_type(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_match_type(&self) -> bool {
        self.match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.match_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 matchlanguages = 7;

    pub fn matchlanguages(&self) -> u32 {
        self.matchlanguages.unwrap_or(0)
    }

    pub fn clear_matchlanguages(&mut self) {
        self.matchlanguages = ::std::option::Option::None;
    }

    pub fn has_matchlanguages(&self) -> bool {
        self.matchlanguages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchlanguages(&mut self, v: u32) {
        self.matchlanguages = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 8;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional .dota.MatchLanguages game_language_enum = 10;

    pub fn game_language_enum(&self) -> super::dota_shared_enums::MatchLanguages {
        match self.game_language_enum {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID),
            None => super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID,
        }
    }

    pub fn clear_game_language_enum(&mut self) {
        self.game_language_enum = ::std::option::Option::None;
    }

    pub fn has_game_language_enum(&self) -> bool {
        self.game_language_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_language_enum(&mut self, v: super::dota_shared_enums::MatchLanguages) {
        self.game_language_enum = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string game_language_name = 11;

    pub fn game_language_name(&self) -> &str {
        match self.game_language_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_language_name(&mut self) {
        self.game_language_name = ::std::option::Option::None;
    }

    pub fn has_game_language_name(&self) -> bool {
        self.game_language_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_language_name(&mut self, v: ::std::string::String) {
        self.game_language_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_language_name(&mut self) -> &mut ::std::string::String {
        if self.game_language_name.is_none() {
            self.game_language_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_language_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_language_name(&mut self) -> ::std::string::String {
        self.game_language_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 region_select_flags = 13;

    pub fn region_select_flags(&self) -> u32 {
        self.region_select_flags.unwrap_or(0)
    }

    pub fn clear_region_select_flags(&mut self) {
        self.region_select_flags = ::std::option::Option::None;
    }

    pub fn has_region_select_flags(&self) -> bool {
        self.region_select_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_select_flags(&mut self, v: u32) {
        self.region_select_flags = ::std::option::Option::Some(v);
    }

    // optional bool solo_queue = 14;

    pub fn solo_queue(&self) -> bool {
        self.solo_queue.unwrap_or(false)
    }

    pub fn clear_solo_queue(&mut self) {
        self.solo_queue = ::std::option::Option::None;
    }

    pub fn has_solo_queue(&self) -> bool {
        self.solo_queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_queue(&mut self, v: bool) {
        self.solo_queue = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_clan_account_id = 16;

    pub fn steam_clan_account_id(&self) -> u32 {
        self.steam_clan_account_id.unwrap_or(0)
    }

    pub fn clear_steam_clan_account_id(&mut self) {
        self.steam_clan_account_id = ::std::option::Option::None;
    }

    pub fn has_steam_clan_account_id(&self) -> bool {
        self.steam_clan_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_clan_account_id(&mut self, v: u32) {
        self.steam_clan_account_id = ::std::option::Option::Some(v);
    }

    // optional bool is_challenge_match = 17;

    pub fn is_challenge_match(&self) -> bool {
        self.is_challenge_match.unwrap_or(false)
    }

    pub fn clear_is_challenge_match(&mut self) {
        self.is_challenge_match = ::std::option::Option::None;
    }

    pub fn has_is_challenge_match(&self) -> bool {
        self.is_challenge_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_challenge_match(&mut self, v: bool) {
        self.is_challenge_match = ::std::option::Option::Some(v);
    }

    // optional uint32 lane_selection_flags = 18;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool high_priority_disabled = 19;

    pub fn high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.unwrap_or(false)
    }

    pub fn clear_high_priority_disabled(&mut self) {
        self.high_priority_disabled = ::std::option::Option::None;
    }

    pub fn has_high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority_disabled(&mut self, v: bool) {
        self.high_priority_disabled = ::std::option::Option::Some(v);
    }

    // optional bool disable_experimental_gameplay = 20;

    pub fn disable_experimental_gameplay(&self) -> bool {
        self.disable_experimental_gameplay.unwrap_or(false)
    }

    pub fn clear_disable_experimental_gameplay(&mut self) {
        self.disable_experimental_gameplay = ::std::option::Option::None;
    }

    pub fn has_disable_experimental_gameplay(&self) -> bool {
        self.disable_experimental_gameplay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_experimental_gameplay(&mut self, v: bool) {
        self.disable_experimental_gameplay = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_game_difficulty_mask = 21;

    pub fn custom_game_difficulty_mask(&self) -> u32 {
        self.custom_game_difficulty_mask.unwrap_or(0)
    }

    pub fn clear_custom_game_difficulty_mask(&mut self) {
        self.custom_game_difficulty_mask = ::std::option::Option::None;
    }

    pub fn has_custom_game_difficulty_mask(&self) -> bool {
        self.custom_game_difficulty_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_difficulty_mask(&mut self, v: u32) {
        self.custom_game_difficulty_mask = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_difficulty_mask = 22;

    pub fn bot_difficulty_mask(&self) -> u32 {
        self.bot_difficulty_mask.unwrap_or(0)
    }

    pub fn clear_bot_difficulty_mask(&mut self) {
        self.bot_difficulty_mask = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_mask(&self) -> bool {
        self.bot_difficulty_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_mask(&mut self, v: u32) {
        self.bot_difficulty_mask = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_script_index_mask = 23;

    pub fn bot_script_index_mask(&self) -> u32 {
        self.bot_script_index_mask.unwrap_or(0)
    }

    pub fn clear_bot_script_index_mask(&mut self) {
        self.bot_script_index_mask = ::std::option::Option::None;
    }

    pub fn has_bot_script_index_mask(&self) -> bool {
        self.bot_script_index_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_script_index_mask(&mut self, v: u32) {
        self.bot_script_index_mask = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CMsgStartFindingMatch| { &m.key },
            |m: &mut CMsgStartFindingMatch| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchgroups",
            |m: &CMsgStartFindingMatch| { &m.matchgroups },
            |m: &mut CMsgStartFindingMatch| { &mut m.matchgroups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgStartFindingMatch| { &m.client_version },
            |m: &mut CMsgStartFindingMatch| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_modes",
            |m: &CMsgStartFindingMatch| { &m.game_modes },
            |m: &mut CMsgStartFindingMatch| { &mut m.game_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_type",
            |m: &CMsgStartFindingMatch| { &m.match_type },
            |m: &mut CMsgStartFindingMatch| { &mut m.match_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchlanguages",
            |m: &CMsgStartFindingMatch| { &m.matchlanguages },
            |m: &mut CMsgStartFindingMatch| { &mut m.matchlanguages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CMsgStartFindingMatch| { &m.team_id },
            |m: &mut CMsgStartFindingMatch| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_language_enum",
            |m: &CMsgStartFindingMatch| { &m.game_language_enum },
            |m: &mut CMsgStartFindingMatch| { &mut m.game_language_enum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_language_name",
            |m: &CMsgStartFindingMatch| { &m.game_language_name },
            |m: &mut CMsgStartFindingMatch| { &mut m.game_language_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::base_gcmessages::CMsgClientPingData>(
            "ping_data",
            |m: &CMsgStartFindingMatch| { &m.ping_data },
            |m: &mut CMsgStartFindingMatch| { &mut m.ping_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_select_flags",
            |m: &CMsgStartFindingMatch| { &m.region_select_flags },
            |m: &mut CMsgStartFindingMatch| { &mut m.region_select_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "solo_queue",
            |m: &CMsgStartFindingMatch| { &m.solo_queue },
            |m: &mut CMsgStartFindingMatch| { &mut m.solo_queue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_clan_account_id",
            |m: &CMsgStartFindingMatch| { &m.steam_clan_account_id },
            |m: &mut CMsgStartFindingMatch| { &mut m.steam_clan_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_challenge_match",
            |m: &CMsgStartFindingMatch| { &m.is_challenge_match },
            |m: &mut CMsgStartFindingMatch| { &mut m.is_challenge_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane_selection_flags",
            |m: &CMsgStartFindingMatch| { &m.lane_selection_flags },
            |m: &mut CMsgStartFindingMatch| { &mut m.lane_selection_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_priority_disabled",
            |m: &CMsgStartFindingMatch| { &m.high_priority_disabled },
            |m: &mut CMsgStartFindingMatch| { &mut m.high_priority_disabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_experimental_gameplay",
            |m: &CMsgStartFindingMatch| { &m.disable_experimental_gameplay },
            |m: &mut CMsgStartFindingMatch| { &mut m.disable_experimental_gameplay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_difficulty_mask",
            |m: &CMsgStartFindingMatch| { &m.custom_game_difficulty_mask },
            |m: &mut CMsgStartFindingMatch| { &mut m.custom_game_difficulty_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty_mask",
            |m: &CMsgStartFindingMatch| { &m.bot_difficulty_mask },
            |m: &mut CMsgStartFindingMatch| { &mut m.bot_difficulty_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_script_index_mask",
            |m: &CMsgStartFindingMatch| { &m.bot_script_index_mask },
            |m: &mut CMsgStartFindingMatch| { &mut m.bot_script_index_mask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartFindingMatch>(
            "CMsgStartFindingMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStartFindingMatch {
    const NAME: &'static str = "CMsgStartFindingMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.matchgroups = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_modes = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.match_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.matchlanguages = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.game_language_enum = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.game_language_name = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                104 => {
                    self.region_select_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.solo_queue = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.steam_clan_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.is_challenge_match = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.high_priority_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.disable_experimental_gameplay = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.custom_game_difficulty_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.bot_difficulty_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.bot_script_index_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.matchgroups {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_modes {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.match_type {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.matchlanguages {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_language_enum {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.game_language_name.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.region_select_flags {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.solo_queue {
            my_size += 1 + 1;
        }
        if let Some(v) = self.steam_clan_account_id {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.is_challenge_match {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lane_selection_flags {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.high_priority_disabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.disable_experimental_gameplay {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_difficulty_mask {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.bot_difficulty_mask {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.bot_script_index_mask {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.matchgroups {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_modes {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.match_type {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.matchlanguages {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_language_enum {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.game_language_name.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.ping_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.region_select_flags {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.solo_queue {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.steam_clan_account_id {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.is_challenge_match {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.high_priority_disabled {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.disable_experimental_gameplay {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.custom_game_difficulty_mask {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.bot_difficulty_mask {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.bot_script_index_mask {
            os.write_uint32(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartFindingMatch {
        CMsgStartFindingMatch::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.matchgroups = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.game_modes = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.matchlanguages = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.game_language_enum = ::std::option::Option::None;
        self.game_language_name = ::std::option::Option::None;
        self.ping_data.clear();
        self.region_select_flags = ::std::option::Option::None;
        self.solo_queue = ::std::option::Option::None;
        self.steam_clan_account_id = ::std::option::Option::None;
        self.is_challenge_match = ::std::option::Option::None;
        self.lane_selection_flags = ::std::option::Option::None;
        self.high_priority_disabled = ::std::option::Option::None;
        self.disable_experimental_gameplay = ::std::option::Option::None;
        self.custom_game_difficulty_mask = ::std::option::Option::None;
        self.bot_difficulty_mask = ::std::option::Option::None;
        self.bot_script_index_mask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartFindingMatch {
        static instance: CMsgStartFindingMatch = CMsgStartFindingMatch {
            key: ::std::option::Option::None,
            matchgroups: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            game_modes: ::std::option::Option::None,
            match_type: ::std::option::Option::None,
            matchlanguages: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            game_language_enum: ::std::option::Option::None,
            game_language_name: ::std::option::Option::None,
            ping_data: ::protobuf::MessageField::none(),
            region_select_flags: ::std::option::Option::None,
            solo_queue: ::std::option::Option::None,
            steam_clan_account_id: ::std::option::Option::None,
            is_challenge_match: ::std::option::Option::None,
            lane_selection_flags: ::std::option::Option::None,
            high_priority_disabled: ::std::option::Option::None,
            disable_experimental_gameplay: ::std::option::Option::None,
            custom_game_difficulty_mask: ::std::option::Option::None,
            bot_difficulty_mask: ::std::option::Option::None,
            bot_script_index_mask: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStartFindingMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartFindingMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartFindingMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartFindingMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStartFindingMatchResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartFindingMatchResult {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatchResult.legacy_generic_eresult)
    pub legacy_generic_eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatchResult.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<EStartFindingMatchResult>>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatchResult.error_token)
    pub error_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatchResult.debug_message)
    pub debug_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatchResult.responsible_party_members)
    pub responsible_party_members: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgStartFindingMatchResult.result_metadata)
    pub result_metadata: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStartFindingMatchResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartFindingMatchResult {
    fn default() -> &'a CMsgStartFindingMatchResult {
        <CMsgStartFindingMatchResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartFindingMatchResult {
    pub fn new() -> CMsgStartFindingMatchResult {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_generic_eresult = 1;

    pub fn legacy_generic_eresult(&self) -> u32 {
        self.legacy_generic_eresult.unwrap_or(0)
    }

    pub fn clear_legacy_generic_eresult(&mut self) {
        self.legacy_generic_eresult = ::std::option::Option::None;
    }

    pub fn has_legacy_generic_eresult(&self) -> bool {
        self.legacy_generic_eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_generic_eresult(&mut self, v: u32) {
        self.legacy_generic_eresult = ::std::option::Option::Some(v);
    }

    // optional .dota.EStartFindingMatchResult result = 2;

    pub fn result(&self) -> EStartFindingMatchResult {
        match self.result {
            Some(e) => e.enum_value_or(EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid),
            None => EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EStartFindingMatchResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_token = 3;

    pub fn error_token(&self) -> &str {
        match self.error_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_token(&mut self) {
        self.error_token = ::std::option::Option::None;
    }

    pub fn has_error_token(&self) -> bool {
        self.error_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_token(&mut self, v: ::std::string::String) {
        self.error_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_token(&mut self) -> &mut ::std::string::String {
        if self.error_token.is_none() {
            self.error_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_token(&mut self) -> ::std::string::String {
        self.error_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string debug_message = 4;

    pub fn debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_message(&mut self) {
        self.debug_message = ::std::option::Option::None;
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 result_metadata = 6;

    pub fn result_metadata(&self) -> u32 {
        self.result_metadata.unwrap_or(0)
    }

    pub fn clear_result_metadata(&mut self) {
        self.result_metadata = ::std::option::Option::None;
    }

    pub fn has_result_metadata(&self) -> bool {
        self.result_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_metadata(&mut self, v: u32) {
        self.result_metadata = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_generic_eresult",
            |m: &CMsgStartFindingMatchResult| { &m.legacy_generic_eresult },
            |m: &mut CMsgStartFindingMatchResult| { &mut m.legacy_generic_eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgStartFindingMatchResult| { &m.result },
            |m: &mut CMsgStartFindingMatchResult| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_token",
            |m: &CMsgStartFindingMatchResult| { &m.error_token },
            |m: &mut CMsgStartFindingMatchResult| { &mut m.error_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_message",
            |m: &CMsgStartFindingMatchResult| { &m.debug_message },
            |m: &mut CMsgStartFindingMatchResult| { &mut m.debug_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "responsible_party_members",
            |m: &CMsgStartFindingMatchResult| { &m.responsible_party_members },
            |m: &mut CMsgStartFindingMatchResult| { &mut m.responsible_party_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result_metadata",
            |m: &CMsgStartFindingMatchResult| { &m.result_metadata },
            |m: &mut CMsgStartFindingMatchResult| { &mut m.result_metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartFindingMatchResult>(
            "CMsgStartFindingMatchResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStartFindingMatchResult {
    const NAME: &'static str = "CMsgStartFindingMatchResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_generic_eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.error_token = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.debug_message = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    is.read_repeated_packed_fixed64_into(&mut self.responsible_party_members)?;
                },
                41 => {
                    self.responsible_party_members.push(is.read_fixed64()?);
                },
                48 => {
                    self.result_metadata = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_generic_eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.error_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.debug_message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += 9 * self.responsible_party_members.len() as u64;
        if let Some(v) = self.result_metadata {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.legacy_generic_eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_token.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.debug_message.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.responsible_party_members {
            os.write_fixed64(5, *v)?;
        };
        if let Some(v) = self.result_metadata {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartFindingMatchResult {
        CMsgStartFindingMatchResult::new()
    }

    fn clear(&mut self) {
        self.legacy_generic_eresult = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error_token = ::std::option::Option::None;
        self.debug_message = ::std::option::Option::None;
        self.responsible_party_members.clear();
        self.result_metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartFindingMatchResult {
        static instance: CMsgStartFindingMatchResult = CMsgStartFindingMatchResult {
            legacy_generic_eresult: ::std::option::Option::None,
            result: ::std::option::Option::None,
            error_token: ::std::option::Option::None,
            debug_message: ::std::option::Option::None,
            responsible_party_members: ::std::vec::Vec::new(),
            result_metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStartFindingMatchResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartFindingMatchResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartFindingMatchResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartFindingMatchResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStopFindingMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopFindingMatch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStopFindingMatch.accept_cooldown)
    pub accept_cooldown: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStopFindingMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopFindingMatch {
    fn default() -> &'a CMsgStopFindingMatch {
        <CMsgStopFindingMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStopFindingMatch {
    pub fn new() -> CMsgStopFindingMatch {
        ::std::default::Default::default()
    }

    // optional bool accept_cooldown = 1;

    pub fn accept_cooldown(&self) -> bool {
        self.accept_cooldown.unwrap_or(false)
    }

    pub fn clear_accept_cooldown(&mut self) {
        self.accept_cooldown = ::std::option::Option::None;
    }

    pub fn has_accept_cooldown(&self) -> bool {
        self.accept_cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept_cooldown(&mut self, v: bool) {
        self.accept_cooldown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accept_cooldown",
            |m: &CMsgStopFindingMatch| { &m.accept_cooldown },
            |m: &mut CMsgStopFindingMatch| { &mut m.accept_cooldown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStopFindingMatch>(
            "CMsgStopFindingMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStopFindingMatch {
    const NAME: &'static str = "CMsgStopFindingMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accept_cooldown = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accept_cooldown {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accept_cooldown {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopFindingMatch {
        CMsgStopFindingMatch::new()
    }

    fn clear(&mut self) {
        self.accept_cooldown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopFindingMatch {
        static instance: CMsgStopFindingMatch = CMsgStopFindingMatch {
            accept_cooldown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStopFindingMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStopFindingMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStopFindingMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStopFindingMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPartyBuilderOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyBuilderOptions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPartyBuilderOptions.additional_slots)
    pub additional_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPartyBuilderOptions.match_type)
    pub match_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchType>>,
    // @@protoc_insertion_point(field:dota.CMsgPartyBuilderOptions.matchgroups)
    pub matchgroups: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPartyBuilderOptions.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPartyBuilderOptions.language)
    pub language: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchLanguages>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPartyBuilderOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyBuilderOptions {
    fn default() -> &'a CMsgPartyBuilderOptions {
        <CMsgPartyBuilderOptions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyBuilderOptions {
    pub fn new() -> CMsgPartyBuilderOptions {
        ::std::default::Default::default()
    }

    // optional uint32 additional_slots = 1;

    pub fn additional_slots(&self) -> u32 {
        self.additional_slots.unwrap_or(0)
    }

    pub fn clear_additional_slots(&mut self) {
        self.additional_slots = ::std::option::Option::None;
    }

    pub fn has_additional_slots(&self) -> bool {
        self.additional_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_slots(&mut self, v: u32) {
        self.additional_slots = ::std::option::Option::Some(v);
    }

    // optional .dota.MatchType match_type = 2;

    pub fn match_type(&self) -> super::dota_shared_enums::MatchType {
        match self.match_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL),
            None => super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL,
        }
    }

    pub fn clear_match_type(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_match_type(&self) -> bool {
        self.match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.match_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 matchgroups = 3;

    pub fn matchgroups(&self) -> u32 {
        self.matchgroups.unwrap_or(0)
    }

    pub fn clear_matchgroups(&mut self) {
        self.matchgroups = ::std::option::Option::None;
    }

    pub fn has_matchgroups(&self) -> bool {
        self.matchgroups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups(&mut self, v: u32) {
        self.matchgroups = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 4;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional .dota.MatchLanguages language = 5;

    pub fn language(&self) -> super::dota_shared_enums::MatchLanguages {
        match self.language {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID),
            None => super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID,
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: super::dota_shared_enums::MatchLanguages) {
        self.language = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_slots",
            |m: &CMsgPartyBuilderOptions| { &m.additional_slots },
            |m: &mut CMsgPartyBuilderOptions| { &mut m.additional_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_type",
            |m: &CMsgPartyBuilderOptions| { &m.match_type },
            |m: &mut CMsgPartyBuilderOptions| { &mut m.match_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchgroups",
            |m: &CMsgPartyBuilderOptions| { &m.matchgroups },
            |m: &mut CMsgPartyBuilderOptions| { &mut m.matchgroups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgPartyBuilderOptions| { &m.client_version },
            |m: &mut CMsgPartyBuilderOptions| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgPartyBuilderOptions| { &m.language },
            |m: &mut CMsgPartyBuilderOptions| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyBuilderOptions>(
            "CMsgPartyBuilderOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyBuilderOptions {
    const NAME: &'static str = "CMsgPartyBuilderOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.matchgroups = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.language = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_slots {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.matchgroups {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.additional_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.matchgroups {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.language {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyBuilderOptions {
        CMsgPartyBuilderOptions::new()
    }

    fn clear(&mut self) {
        self.additional_slots = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.matchgroups = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyBuilderOptions {
        static instance: CMsgPartyBuilderOptions = CMsgPartyBuilderOptions {
            additional_slots: ::std::option::Option::None,
            match_type: ::std::option::Option::None,
            matchgroups: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyBuilderOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyBuilderOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyBuilderOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyBuilderOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgReadyUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReadyUp {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgReadyUp.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALobbyReadyState>>,
    // @@protoc_insertion_point(field:dota.CMsgReadyUp.ready_up_key)
    pub ready_up_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgReadyUp.hardware_specs)
    pub hardware_specs: ::protobuf::MessageField<super::dota_shared_enums::CDOTAClientHardwareSpecs>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgReadyUp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReadyUp {
    fn default() -> &'a CMsgReadyUp {
        <CMsgReadyUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReadyUp {
    pub fn new() -> CMsgReadyUp {
        ::std::default::Default::default()
    }

    // optional .dota.DOTALobbyReadyState state = 1;

    pub fn state(&self) -> super::dota_shared_enums::DOTALobbyReadyState {
        match self.state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED),
            None => super::dota_shared_enums::DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::dota_shared_enums::DOTALobbyReadyState) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 ready_up_key = 2;

    pub fn ready_up_key(&self) -> u64 {
        self.ready_up_key.unwrap_or(0)
    }

    pub fn clear_ready_up_key(&mut self) {
        self.ready_up_key = ::std::option::Option::None;
    }

    pub fn has_ready_up_key(&self) -> bool {
        self.ready_up_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ready_up_key(&mut self, v: u64) {
        self.ready_up_key = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CMsgReadyUp| { &m.state },
            |m: &mut CMsgReadyUp| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ready_up_key",
            |m: &CMsgReadyUp| { &m.ready_up_key },
            |m: &mut CMsgReadyUp| { &mut m.ready_up_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_shared_enums::CDOTAClientHardwareSpecs>(
            "hardware_specs",
            |m: &CMsgReadyUp| { &m.hardware_specs },
            |m: &mut CMsgReadyUp| { &mut m.hardware_specs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReadyUp>(
            "CMsgReadyUp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReadyUp {
    const NAME: &'static str = "CMsgReadyUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.ready_up_key = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hardware_specs)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ready_up_key {
            my_size += 1 + 8;
        }
        if let Some(v) = self.hardware_specs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ready_up_key {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.hardware_specs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReadyUp {
        CMsgReadyUp::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.ready_up_key = ::std::option::Option::None;
        self.hardware_specs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReadyUp {
        static instance: CMsgReadyUp = CMsgReadyUp {
            state: ::std::option::Option::None,
            ready_up_key: ::std::option::Option::None,
            hardware_specs: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReadyUp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReadyUp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReadyUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReadyUp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgReadyUpStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReadyUpStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgReadyUpStatus.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgReadyUpStatus.accepted_ids)
    pub accepted_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgReadyUpStatus.declined_ids)
    pub declined_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgReadyUpStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReadyUpStatus {
    fn default() -> &'a CMsgReadyUpStatus {
        <CMsgReadyUpStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReadyUpStatus {
    pub fn new() -> CMsgReadyUpStatus {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgReadyUpStatus| { &m.lobby_id },
            |m: &mut CMsgReadyUpStatus| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accepted_ids",
            |m: &CMsgReadyUpStatus| { &m.accepted_ids },
            |m: &mut CMsgReadyUpStatus| { &mut m.accepted_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "declined_ids",
            |m: &CMsgReadyUpStatus| { &m.declined_ids },
            |m: &mut CMsgReadyUpStatus| { &mut m.declined_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReadyUpStatus>(
            "CMsgReadyUpStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReadyUpStatus {
    const NAME: &'static str = "CMsgReadyUpStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.accepted_ids)?;
                },
                16 => {
                    self.accepted_ids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.declined_ids)?;
                },
                24 => {
                    self.declined_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        for value in &self.accepted_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.declined_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.accepted_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.declined_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReadyUpStatus {
        CMsgReadyUpStatus::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.accepted_ids.clear();
        self.declined_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReadyUpStatus {
        static instance: CMsgReadyUpStatus = CMsgReadyUpStatus {
            lobby_id: ::std::option::Option::None,
            accepted_ids: ::std::vec::Vec::new(),
            declined_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReadyUpStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReadyUpStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReadyUpStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReadyUpStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAbandonCurrentGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAbandonCurrentGame {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAbandonCurrentGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAbandonCurrentGame {
    fn default() -> &'a CMsgAbandonCurrentGame {
        <CMsgAbandonCurrentGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAbandonCurrentGame {
    pub fn new() -> CMsgAbandonCurrentGame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAbandonCurrentGame>(
            "CMsgAbandonCurrentGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAbandonCurrentGame {
    const NAME: &'static str = "CMsgAbandonCurrentGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAbandonCurrentGame {
        CMsgAbandonCurrentGame::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAbandonCurrentGame {
        static instance: CMsgAbandonCurrentGame = CMsgAbandonCurrentGame {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAbandonCurrentGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAbandonCurrentGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAbandonCurrentGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAbandonCurrentGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyScenarioSave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyScenarioSave {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyScenarioSave.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyScenarioSave.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyScenarioSave.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyScenarioSave {
    fn default() -> &'a CMsgLobbyScenarioSave {
        <CMsgLobbyScenarioSave as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyScenarioSave {
    pub fn new() -> CMsgLobbyScenarioSave {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgLobbyScenarioSave| { &m.version },
            |m: &mut CMsgLobbyScenarioSave| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CMsgLobbyScenarioSave| { &m.data },
            |m: &mut CMsgLobbyScenarioSave| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyScenarioSave>(
            "CMsgLobbyScenarioSave",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyScenarioSave {
    const NAME: &'static str = "CMsgLobbyScenarioSave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyScenarioSave {
        CMsgLobbyScenarioSave::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyScenarioSave {
        static instance: CMsgLobbyScenarioSave = CMsgLobbyScenarioSave {
            version: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyScenarioSave {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyScenarioSave").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyScenarioSave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyScenarioSave {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbySetDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbySetDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.team_details)
    pub team_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CLobbyTeamDetails>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.cm_pick)
    pub cm_pick: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_CM_PICK>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.bot_difficulty_radiant)
    pub bot_difficulty_radiant: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.allow_cheats)
    pub allow_cheats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.fill_with_bots)
    pub fill_with_bots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.intro_mode)
    pub intro_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.allow_spectating)
    pub allow_spectating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.penalty_level_radiant)
    pub penalty_level_radiant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.penalty_level_dire)
    pub penalty_level_dire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.load_game_id)
    pub load_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.radiant_series_wins)
    pub radiant_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.dire_series_wins)
    pub dire_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.allchat)
    pub allchat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.dota_tv_delay)
    pub dota_tv_delay: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_gcmessages_common_lobby::LobbyDotaTVDelay>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.lan)
    pub lan: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_game_mode)
    pub custom_game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_difficulty)
    pub custom_difficulty: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_min_players)
    pub custom_min_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_max_players)
    pub custom_max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.visibility)
    pub visibility: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALobbyVisibility>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.previous_match_override)
    pub previous_match_override: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.pause_setting)
    pub pause_setting: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.bot_difficulty_dire)
    pub bot_difficulty_dire: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.bot_radiant)
    pub bot_radiant: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.bot_dire)
    pub bot_dire: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.selection_priority_rules)
    pub selection_priority_rules: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityRules>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.custom_game_penalties)
    pub custom_game_penalties: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.league_node_id)
    pub league_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.requested_hero_ids)
    pub requested_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.scenario_save)
    pub scenario_save: ::protobuf::MessageField<CMsgLobbyScenarioSave>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.ability_draft_specific_details)
    pub ability_draft_specific_details: ::protobuf::MessageField<cmsg_practice_lobby_set_details::AbilityDraftSpecificDetails>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.do_player_draft)
    pub do_player_draft: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbySetDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbySetDetails {
    fn default() -> &'a CMsgPracticeLobbySetDetails {
        <CMsgPracticeLobbySetDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbySetDetails {
    pub fn new() -> CMsgPracticeLobbySetDetails {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_region = 4;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 5;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_CM_PICK cm_pick = 6;

    pub fn cm_pick(&self) -> super::dota_shared_enums::DOTA_CM_PICK {
        match self.cm_pick {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM),
            None => super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM,
        }
    }

    pub fn clear_cm_pick(&mut self) {
        self.cm_pick = ::std::option::Option::None;
    }

    pub fn has_cm_pick(&self) -> bool {
        self.cm_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_pick(&mut self, v: super::dota_shared_enums::DOTA_CM_PICK) {
        self.cm_pick = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.DOTABotDifficulty bot_difficulty_radiant = 9;

    pub fn bot_difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_radiant(&mut self) {
        self.bot_difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_radiant(&self) -> bool {
        self.bot_difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_radiant = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool allow_cheats = 10;

    pub fn allow_cheats(&self) -> bool {
        self.allow_cheats.unwrap_or(false)
    }

    pub fn clear_allow_cheats(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
    }

    pub fn has_allow_cheats(&self) -> bool {
        self.allow_cheats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheats(&mut self, v: bool) {
        self.allow_cheats = ::std::option::Option::Some(v);
    }

    // optional bool fill_with_bots = 11;

    pub fn fill_with_bots(&self) -> bool {
        self.fill_with_bots.unwrap_or(false)
    }

    pub fn clear_fill_with_bots(&mut self) {
        self.fill_with_bots = ::std::option::Option::None;
    }

    pub fn has_fill_with_bots(&self) -> bool {
        self.fill_with_bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fill_with_bots(&mut self, v: bool) {
        self.fill_with_bots = ::std::option::Option::Some(v);
    }

    // optional bool intro_mode = 12;

    pub fn intro_mode(&self) -> bool {
        self.intro_mode.unwrap_or(false)
    }

    pub fn clear_intro_mode(&mut self) {
        self.intro_mode = ::std::option::Option::None;
    }

    pub fn has_intro_mode(&self) -> bool {
        self.intro_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intro_mode(&mut self, v: bool) {
        self.intro_mode = ::std::option::Option::Some(v);
    }

    // optional bool allow_spectating = 13;

    pub fn allow_spectating(&self) -> bool {
        self.allow_spectating.unwrap_or(false)
    }

    pub fn clear_allow_spectating(&mut self) {
        self.allow_spectating = ::std::option::Option::None;
    }

    pub fn has_allow_spectating(&self) -> bool {
        self.allow_spectating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_spectating(&mut self, v: bool) {
        self.allow_spectating = ::std::option::Option::Some(v);
    }

    // optional string pass_key = 15;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 leagueid = 16;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_radiant = 17;

    pub fn penalty_level_radiant(&self) -> u32 {
        self.penalty_level_radiant.unwrap_or(0)
    }

    pub fn clear_penalty_level_radiant(&mut self) {
        self.penalty_level_radiant = ::std::option::Option::None;
    }

    pub fn has_penalty_level_radiant(&self) -> bool {
        self.penalty_level_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_radiant(&mut self, v: u32) {
        self.penalty_level_radiant = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_dire = 18;

    pub fn penalty_level_dire(&self) -> u32 {
        self.penalty_level_dire.unwrap_or(0)
    }

    pub fn clear_penalty_level_dire(&mut self) {
        self.penalty_level_dire = ::std::option::Option::None;
    }

    pub fn has_penalty_level_dire(&self) -> bool {
        self.penalty_level_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_dire(&mut self, v: u32) {
        self.penalty_level_dire = ::std::option::Option::Some(v);
    }

    // optional uint32 load_game_id = 19;

    pub fn load_game_id(&self) -> u32 {
        self.load_game_id.unwrap_or(0)
    }

    pub fn clear_load_game_id(&mut self) {
        self.load_game_id = ::std::option::Option::None;
    }

    pub fn has_load_game_id(&self) -> bool {
        self.load_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_game_id(&mut self, v: u32) {
        self.load_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 20;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_series_wins = 21;

    pub fn radiant_series_wins(&self) -> u32 {
        self.radiant_series_wins.unwrap_or(0)
    }

    pub fn clear_radiant_series_wins(&mut self) {
        self.radiant_series_wins = ::std::option::Option::None;
    }

    pub fn has_radiant_series_wins(&self) -> bool {
        self.radiant_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_series_wins(&mut self, v: u32) {
        self.radiant_series_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_series_wins = 22;

    pub fn dire_series_wins(&self) -> u32 {
        self.dire_series_wins.unwrap_or(0)
    }

    pub fn clear_dire_series_wins(&mut self) {
        self.dire_series_wins = ::std::option::Option::None;
    }

    pub fn has_dire_series_wins(&self) -> bool {
        self.dire_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_series_wins(&mut self, v: u32) {
        self.dire_series_wins = ::std::option::Option::Some(v);
    }

    // optional bool allchat = 23;

    pub fn allchat(&self) -> bool {
        self.allchat.unwrap_or(false)
    }

    pub fn clear_allchat(&mut self) {
        self.allchat = ::std::option::Option::None;
    }

    pub fn has_allchat(&self) -> bool {
        self.allchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allchat(&mut self, v: bool) {
        self.allchat = ::std::option::Option::Some(v);
    }

    // optional .dota.LobbyDotaTVDelay dota_tv_delay = 24;

    pub fn dota_tv_delay(&self) -> super::dota_gcmessages_common_lobby::LobbyDotaTVDelay {
        match self.dota_tv_delay {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common_lobby::LobbyDotaTVDelay::LobbyDotaTV_10),
            None => super::dota_gcmessages_common_lobby::LobbyDotaTVDelay::LobbyDotaTV_10,
        }
    }

    pub fn clear_dota_tv_delay(&mut self) {
        self.dota_tv_delay = ::std::option::Option::None;
    }

    pub fn has_dota_tv_delay(&self) -> bool {
        self.dota_tv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_tv_delay(&mut self, v: super::dota_gcmessages_common_lobby::LobbyDotaTVDelay) {
        self.dota_tv_delay = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool lan = 25;

    pub fn lan(&self) -> bool {
        self.lan.unwrap_or(false)
    }

    pub fn clear_lan(&mut self) {
        self.lan = ::std::option::Option::None;
    }

    pub fn has_lan(&self) -> bool {
        self.lan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan(&mut self, v: bool) {
        self.lan = ::std::option::Option::Some(v);
    }

    // optional string custom_game_mode = 26;

    pub fn custom_game_mode(&self) -> &str {
        match self.custom_game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_game_mode(&mut self) {
        self.custom_game_mode = ::std::option::Option::None;
    }

    pub fn has_custom_game_mode(&self) -> bool {
        self.custom_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_mode(&mut self, v: ::std::string::String) {
        self.custom_game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_mode(&mut self) -> &mut ::std::string::String {
        if self.custom_game_mode.is_none() {
            self.custom_game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_mode(&mut self) -> ::std::string::String {
        self.custom_game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_map_name = 27;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 custom_difficulty = 28;

    pub fn custom_difficulty(&self) -> u32 {
        self.custom_difficulty.unwrap_or(0)
    }

    pub fn clear_custom_difficulty(&mut self) {
        self.custom_difficulty = ::std::option::Option::None;
    }

    pub fn has_custom_difficulty(&self) -> bool {
        self.custom_difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_difficulty(&mut self, v: u32) {
        self.custom_difficulty = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 29;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_min_players = 30;

    pub fn custom_min_players(&self) -> u32 {
        self.custom_min_players.unwrap_or(0)
    }

    pub fn clear_custom_min_players(&mut self) {
        self.custom_min_players = ::std::option::Option::None;
    }

    pub fn has_custom_min_players(&self) -> bool {
        self.custom_min_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_min_players(&mut self, v: u32) {
        self.custom_min_players = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_max_players = 31;

    pub fn custom_max_players(&self) -> u32 {
        self.custom_max_players.unwrap_or(0)
    }

    pub fn clear_custom_max_players(&mut self) {
        self.custom_max_players = ::std::option::Option::None;
    }

    pub fn has_custom_max_players(&self) -> bool {
        self.custom_max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_max_players(&mut self, v: u32) {
        self.custom_max_players = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTALobbyVisibility visibility = 33;

    pub fn visibility(&self) -> super::dota_shared_enums::DOTALobbyVisibility {
        match self.visibility {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public),
            None => super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public,
        }
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: super::dota_shared_enums::DOTALobbyVisibility) {
        self.visibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 custom_game_crc = 34;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 37;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 previous_match_override = 38;

    pub fn previous_match_override(&self) -> u64 {
        self.previous_match_override.unwrap_or(0)
    }

    pub fn clear_previous_match_override(&mut self) {
        self.previous_match_override = ::std::option::Option::None;
    }

    pub fn has_previous_match_override(&self) -> bool {
        self.previous_match_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_match_override(&mut self, v: u64) {
        self.previous_match_override = ::std::option::Option::Some(v);
    }

    // optional .dota.LobbyDotaPauseSetting pause_setting = 42;

    pub fn pause_setting(&self) -> super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting {
        match self.pause_setting {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            None => super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited,
        }
    }

    pub fn clear_pause_setting(&mut self) {
        self.pause_setting = ::std::option::Option::None;
    }

    pub fn has_pause_setting(&self) -> bool {
        self.pause_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_setting(&mut self, v: super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting) {
        self.pause_setting = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.DOTABotDifficulty bot_difficulty_dire = 43;

    pub fn bot_difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_dire(&mut self) {
        self.bot_difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_dire(&self) -> bool {
        self.bot_difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_dire = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 bot_radiant = 44;

    pub fn bot_radiant(&self) -> u64 {
        self.bot_radiant.unwrap_or(0)
    }

    pub fn clear_bot_radiant(&mut self) {
        self.bot_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_radiant(&self) -> bool {
        self.bot_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_radiant(&mut self, v: u64) {
        self.bot_radiant = ::std::option::Option::Some(v);
    }

    // optional uint64 bot_dire = 45;

    pub fn bot_dire(&self) -> u64 {
        self.bot_dire.unwrap_or(0)
    }

    pub fn clear_bot_dire(&mut self) {
        self.bot_dire = ::std::option::Option::None;
    }

    pub fn has_bot_dire(&self) -> bool {
        self.bot_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_dire(&mut self, v: u64) {
        self.bot_dire = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTASelectionPriorityRules selection_priority_rules = 46;

    pub fn selection_priority_rules(&self) -> super::dota_shared_enums::DOTASelectionPriorityRules {
        match self.selection_priority_rules {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            None => super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual,
        }
    }

    pub fn clear_selection_priority_rules(&mut self) {
        self.selection_priority_rules = ::std::option::Option::None;
    }

    pub fn has_selection_priority_rules(&self) -> bool {
        self.selection_priority_rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_priority_rules(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityRules) {
        self.selection_priority_rules = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool custom_game_penalties = 47;

    pub fn custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.unwrap_or(false)
    }

    pub fn clear_custom_game_penalties(&mut self) {
        self.custom_game_penalties = ::std::option::Option::None;
    }

    pub fn has_custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_penalties(&mut self, v: bool) {
        self.custom_game_penalties = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 48;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 league_node_id = 49;

    pub fn league_node_id(&self) -> u32 {
        self.league_node_id.unwrap_or(0)
    }

    pub fn clear_league_node_id(&mut self) {
        self.league_node_id = ::std::option::Option::None;
    }

    pub fn has_league_node_id(&self) -> bool {
        self.league_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_node_id(&mut self, v: u32) {
        self.league_node_id = ::std::option::Option::Some(v);
    }

    // optional bool do_player_draft = 53;

    pub fn do_player_draft(&self) -> bool {
        self.do_player_draft.unwrap_or(false)
    }

    pub fn clear_do_player_draft(&mut self) {
        self.do_player_draft = ::std::option::Option::None;
    }

    pub fn has_do_player_draft(&self) -> bool {
        self.do_player_draft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_player_draft(&mut self, v: bool) {
        self.do_player_draft = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(44);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgPracticeLobbySetDetails| { &m.lobby_id },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &CMsgPracticeLobbySetDetails| { &m.game_name },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.game_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_details",
            |m: &CMsgPracticeLobbySetDetails| { &m.team_details },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.team_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgPracticeLobbySetDetails| { &m.server_region },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgPracticeLobbySetDetails| { &m.game_mode },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cm_pick",
            |m: &CMsgPracticeLobbySetDetails| { &m.cm_pick },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.cm_pick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty_radiant",
            |m: &CMsgPracticeLobbySetDetails| { &m.bot_difficulty_radiant },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.bot_difficulty_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_cheats",
            |m: &CMsgPracticeLobbySetDetails| { &m.allow_cheats },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.allow_cheats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fill_with_bots",
            |m: &CMsgPracticeLobbySetDetails| { &m.fill_with_bots },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.fill_with_bots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "intro_mode",
            |m: &CMsgPracticeLobbySetDetails| { &m.intro_mode },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.intro_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_spectating",
            |m: &CMsgPracticeLobbySetDetails| { &m.allow_spectating },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.allow_spectating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pass_key",
            |m: &CMsgPracticeLobbySetDetails| { &m.pass_key },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leagueid",
            |m: &CMsgPracticeLobbySetDetails| { &m.leagueid },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.leagueid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_level_radiant",
            |m: &CMsgPracticeLobbySetDetails| { &m.penalty_level_radiant },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.penalty_level_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_level_dire",
            |m: &CMsgPracticeLobbySetDetails| { &m.penalty_level_dire },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.penalty_level_dire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "load_game_id",
            |m: &CMsgPracticeLobbySetDetails| { &m.load_game_id },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.load_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_type",
            |m: &CMsgPracticeLobbySetDetails| { &m.series_type },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.series_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_series_wins",
            |m: &CMsgPracticeLobbySetDetails| { &m.radiant_series_wins },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.radiant_series_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_series_wins",
            |m: &CMsgPracticeLobbySetDetails| { &m.dire_series_wins },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.dire_series_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allchat",
            |m: &CMsgPracticeLobbySetDetails| { &m.allchat },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.allchat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dota_tv_delay",
            |m: &CMsgPracticeLobbySetDetails| { &m.dota_tv_delay },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.dota_tv_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lan",
            |m: &CMsgPracticeLobbySetDetails| { &m.lan },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.lan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_mode",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_game_mode },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_map_name",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_map_name },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_difficulty",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_difficulty },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_game_id },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_min_players",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_min_players },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_min_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_max_players",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_max_players },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_max_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &CMsgPracticeLobbySetDetails| { &m.visibility },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_crc",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_game_crc },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_game_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_timestamp",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_game_timestamp },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_game_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previous_match_override",
            |m: &CMsgPracticeLobbySetDetails| { &m.previous_match_override },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.previous_match_override },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pause_setting",
            |m: &CMsgPracticeLobbySetDetails| { &m.pause_setting },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.pause_setting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty_dire",
            |m: &CMsgPracticeLobbySetDetails| { &m.bot_difficulty_dire },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.bot_difficulty_dire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_radiant",
            |m: &CMsgPracticeLobbySetDetails| { &m.bot_radiant },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.bot_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_dire",
            |m: &CMsgPracticeLobbySetDetails| { &m.bot_dire },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.bot_dire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selection_priority_rules",
            |m: &CMsgPracticeLobbySetDetails| { &m.selection_priority_rules },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.selection_priority_rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_penalties",
            |m: &CMsgPracticeLobbySetDetails| { &m.custom_game_penalties },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.custom_game_penalties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lan_host_ping_location",
            |m: &CMsgPracticeLobbySetDetails| { &m.lan_host_ping_location },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.lan_host_ping_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_node_id",
            |m: &CMsgPracticeLobbySetDetails| { &m.league_node_id },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.league_node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requested_hero_ids",
            |m: &CMsgPracticeLobbySetDetails| { &m.requested_hero_ids },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.requested_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgLobbyScenarioSave>(
            "scenario_save",
            |m: &CMsgPracticeLobbySetDetails| { &m.scenario_save },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.scenario_save },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_practice_lobby_set_details::AbilityDraftSpecificDetails>(
            "ability_draft_specific_details",
            |m: &CMsgPracticeLobbySetDetails| { &m.ability_draft_specific_details },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.ability_draft_specific_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "do_player_draft",
            |m: &CMsgPracticeLobbySetDetails| { &m.do_player_draft },
            |m: &mut CMsgPracticeLobbySetDetails| { &mut m.do_player_draft },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbySetDetails>(
            "CMsgPracticeLobbySetDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbySetDetails {
    const NAME: &'static str = "CMsgPracticeLobbySetDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.team_details.push(is.read_message()?);
                },
                32 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.cm_pick = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.bot_difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.allow_cheats = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.fill_with_bots = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.intro_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.allow_spectating = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.penalty_level_radiant = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.penalty_level_dire = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.load_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.radiant_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.dire_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.allchat = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.dota_tv_delay = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.lan = ::std::option::Option::Some(is.read_bool()?);
                },
                210 => {
                    self.custom_game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                218 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                224 => {
                    self.custom_difficulty = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                240 => {
                    self.custom_min_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.custom_max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.visibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                273 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                301 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                304 => {
                    self.previous_match_override = ::std::option::Option::Some(is.read_uint64()?);
                },
                336 => {
                    self.pause_setting = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                344 => {
                    self.bot_difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                352 => {
                    self.bot_radiant = ::std::option::Option::Some(is.read_uint64()?);
                },
                360 => {
                    self.bot_dire = ::std::option::Option::Some(is.read_uint64()?);
                },
                368 => {
                    self.selection_priority_rules = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                376 => {
                    self.custom_game_penalties = ::std::option::Option::Some(is.read_bool()?);
                },
                386 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                392 => {
                    self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                402 => {
                    is.read_repeated_packed_uint32_into(&mut self.requested_hero_ids)?;
                },
                400 => {
                    self.requested_hero_ids.push(is.read_uint32()?);
                },
                410 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scenario_save)?;
                },
                418 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ability_draft_specific_details)?;
                },
                424 => {
                    self.do_player_draft = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.team_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.cm_pick {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.bot_difficulty_radiant {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.allow_cheats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_with_bots {
            my_size += 1 + 1;
        }
        if let Some(v) = self.intro_mode {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_spectating {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.penalty_level_radiant {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.penalty_level_dire {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.load_game_id {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.radiant_series_wins {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.dire_series_wins {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.allchat {
            my_size += 2 + 1;
        }
        if let Some(v) = self.dota_tv_delay {
            my_size += ::protobuf::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.lan {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.custom_difficulty {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::uint64_size(29, v);
        }
        if let Some(v) = self.custom_min_players {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.custom_max_players {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(33, v.value());
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 2 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 2 + 4;
        }
        if let Some(v) = self.previous_match_override {
            my_size += ::protobuf::rt::uint64_size(38, v);
        }
        if let Some(v) = self.pause_setting {
            my_size += ::protobuf::rt::int32_size(42, v.value());
        }
        if let Some(v) = self.bot_difficulty_dire {
            my_size += ::protobuf::rt::int32_size(43, v.value());
        }
        if let Some(v) = self.bot_radiant {
            my_size += ::protobuf::rt::uint64_size(44, v);
        }
        if let Some(v) = self.bot_dire {
            my_size += ::protobuf::rt::uint64_size(45, v);
        }
        if let Some(v) = self.selection_priority_rules {
            my_size += ::protobuf::rt::int32_size(46, v.value());
        }
        if let Some(v) = self.custom_game_penalties {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::protobuf::rt::string_size(48, &v);
        }
        if let Some(v) = self.league_node_id {
            my_size += ::protobuf::rt::uint32_size(49, v);
        }
        for value in &self.requested_hero_ids {
            my_size += ::protobuf::rt::uint32_size(50, *value);
        };
        if let Some(v) = self.scenario_save.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ability_draft_specific_details.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.do_player_draft {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.team_details {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.server_region {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cm_pick {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.allow_cheats {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.fill_with_bots {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.intro_mode {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.allow_spectating {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.penalty_level_radiant {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.penalty_level_dire {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.load_game_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.radiant_series_wins {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.dire_series_wins {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.allchat {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.dota_tv_delay {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lan {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            os.write_string(26, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.custom_difficulty {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(29, v)?;
        }
        if let Some(v) = self.custom_min_players {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.custom_max_players {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(33, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(34, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(37, v)?;
        }
        if let Some(v) = self.previous_match_override {
            os.write_uint64(38, v)?;
        }
        if let Some(v) = self.pause_setting {
            os.write_enum(42, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_difficulty_dire {
            os.write_enum(43, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_radiant {
            os.write_uint64(44, v)?;
        }
        if let Some(v) = self.bot_dire {
            os.write_uint64(45, v)?;
        }
        if let Some(v) = self.selection_priority_rules {
            os.write_enum(46, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_penalties {
            os.write_bool(47, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(48, v)?;
        }
        if let Some(v) = self.league_node_id {
            os.write_uint32(49, v)?;
        }
        for v in &self.requested_hero_ids {
            os.write_uint32(50, *v)?;
        };
        if let Some(v) = self.scenario_save.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        }
        if let Some(v) = self.ability_draft_specific_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
        }
        if let Some(v) = self.do_player_draft {
            os.write_bool(53, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbySetDetails {
        CMsgPracticeLobbySetDetails::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.team_details.clear();
        self.server_region = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.cm_pick = ::std::option::Option::None;
        self.bot_difficulty_radiant = ::std::option::Option::None;
        self.allow_cheats = ::std::option::Option::None;
        self.fill_with_bots = ::std::option::Option::None;
        self.intro_mode = ::std::option::Option::None;
        self.allow_spectating = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.penalty_level_radiant = ::std::option::Option::None;
        self.penalty_level_dire = ::std::option::Option::None;
        self.load_game_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.radiant_series_wins = ::std::option::Option::None;
        self.dire_series_wins = ::std::option::Option::None;
        self.allchat = ::std::option::Option::None;
        self.dota_tv_delay = ::std::option::Option::None;
        self.lan = ::std::option::Option::None;
        self.custom_game_mode = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.custom_difficulty = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.custom_min_players = ::std::option::Option::None;
        self.custom_max_players = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.previous_match_override = ::std::option::Option::None;
        self.pause_setting = ::std::option::Option::None;
        self.bot_difficulty_dire = ::std::option::Option::None;
        self.bot_radiant = ::std::option::Option::None;
        self.bot_dire = ::std::option::Option::None;
        self.selection_priority_rules = ::std::option::Option::None;
        self.custom_game_penalties = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.league_node_id = ::std::option::Option::None;
        self.requested_hero_ids.clear();
        self.scenario_save.clear();
        self.ability_draft_specific_details.clear();
        self.do_player_draft = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbySetDetails {
        static instance: CMsgPracticeLobbySetDetails = CMsgPracticeLobbySetDetails {
            lobby_id: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            team_details: ::std::vec::Vec::new(),
            server_region: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            cm_pick: ::std::option::Option::None,
            bot_difficulty_radiant: ::std::option::Option::None,
            allow_cheats: ::std::option::Option::None,
            fill_with_bots: ::std::option::Option::None,
            intro_mode: ::std::option::Option::None,
            allow_spectating: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            penalty_level_radiant: ::std::option::Option::None,
            penalty_level_dire: ::std::option::Option::None,
            load_game_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            radiant_series_wins: ::std::option::Option::None,
            dire_series_wins: ::std::option::Option::None,
            allchat: ::std::option::Option::None,
            dota_tv_delay: ::std::option::Option::None,
            lan: ::std::option::Option::None,
            custom_game_mode: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            custom_difficulty: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            custom_min_players: ::std::option::Option::None,
            custom_max_players: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            previous_match_override: ::std::option::Option::None,
            pause_setting: ::std::option::Option::None,
            bot_difficulty_dire: ::std::option::Option::None,
            bot_radiant: ::std::option::Option::None,
            bot_dire: ::std::option::Option::None,
            selection_priority_rules: ::std::option::Option::None,
            custom_game_penalties: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            league_node_id: ::std::option::Option::None,
            requested_hero_ids: ::std::vec::Vec::new(),
            scenario_save: ::protobuf::MessageField::none(),
            ability_draft_specific_details: ::protobuf::MessageField::none(),
            do_player_draft: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbySetDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbySetDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbySetDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbySetDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPracticeLobbySetDetails`
pub mod cmsg_practice_lobby_set_details {
    // @@protoc_insertion_point(message:dota.CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AbilityDraftSpecificDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails.shuffle_draft_order)
        pub shuffle_draft_order: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AbilityDraftSpecificDetails {
        fn default() -> &'a AbilityDraftSpecificDetails {
            <AbilityDraftSpecificDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl AbilityDraftSpecificDetails {
        pub fn new() -> AbilityDraftSpecificDetails {
            ::std::default::Default::default()
        }

        // optional bool shuffle_draft_order = 1;

        pub fn shuffle_draft_order(&self) -> bool {
            self.shuffle_draft_order.unwrap_or(false)
        }

        pub fn clear_shuffle_draft_order(&mut self) {
            self.shuffle_draft_order = ::std::option::Option::None;
        }

        pub fn has_shuffle_draft_order(&self) -> bool {
            self.shuffle_draft_order.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shuffle_draft_order(&mut self, v: bool) {
            self.shuffle_draft_order = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "shuffle_draft_order",
                |m: &AbilityDraftSpecificDetails| { &m.shuffle_draft_order },
                |m: &mut AbilityDraftSpecificDetails| { &mut m.shuffle_draft_order },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AbilityDraftSpecificDetails>(
                "CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AbilityDraftSpecificDetails {
        const NAME: &'static str = "AbilityDraftSpecificDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.shuffle_draft_order = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.shuffle_draft_order {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.shuffle_draft_order {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AbilityDraftSpecificDetails {
            AbilityDraftSpecificDetails::new()
        }

        fn clear(&mut self) {
            self.shuffle_draft_order = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AbilityDraftSpecificDetails {
            static instance: AbilityDraftSpecificDetails = AbilityDraftSpecificDetails {
                shuffle_draft_order: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AbilityDraftSpecificDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AbilityDraftSpecificDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AbilityDraftSpecificDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyCreate {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.search_key)
    pub search_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.lobby_details)
    pub lobby_details: ::protobuf::MessageField<CMsgPracticeLobbySetDetails>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.save_game)
    pub save_game: ::protobuf::MessageField<cmsg_practice_lobby_create::SaveGame>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyCreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyCreate {
    fn default() -> &'a CMsgPracticeLobbyCreate {
        <CMsgPracticeLobbyCreate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyCreate {
    pub fn new() -> CMsgPracticeLobbyCreate {
        ::std::default::Default::default()
    }

    // optional string search_key = 1;

    pub fn search_key(&self) -> &str {
        match self.search_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_key(&mut self) {
        self.search_key = ::std::option::Option::None;
    }

    pub fn has_search_key(&self) -> bool {
        self.search_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_key(&mut self, v: ::std::string::String) {
        self.search_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_key(&mut self) -> &mut ::std::string::String {
        if self.search_key.is_none() {
            self.search_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_key(&mut self) -> ::std::string::String {
        self.search_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pass_key = 5;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 6;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_key",
            |m: &CMsgPracticeLobbyCreate| { &m.search_key },
            |m: &mut CMsgPracticeLobbyCreate| { &mut m.search_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pass_key",
            |m: &CMsgPracticeLobbyCreate| { &m.pass_key },
            |m: &mut CMsgPracticeLobbyCreate| { &mut m.pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgPracticeLobbyCreate| { &m.client_version },
            |m: &mut CMsgPracticeLobbyCreate| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPracticeLobbySetDetails>(
            "lobby_details",
            |m: &CMsgPracticeLobbyCreate| { &m.lobby_details },
            |m: &mut CMsgPracticeLobbyCreate| { &mut m.lobby_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_practice_lobby_create::SaveGame>(
            "save_game",
            |m: &CMsgPracticeLobbyCreate| { &m.save_game },
            |m: &mut CMsgPracticeLobbyCreate| { &mut m.save_game },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyCreate>(
            "CMsgPracticeLobbyCreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyCreate {
    const NAME: &'static str = "CMsgPracticeLobbyCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search_key = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lobby_details)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.save_game)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.search_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.lobby_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.save_game.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.search_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.lobby_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.save_game.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyCreate {
        CMsgPracticeLobbyCreate::new()
    }

    fn clear(&mut self) {
        self.search_key = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.lobby_details.clear();
        self.save_game.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyCreate {
        static instance: CMsgPracticeLobbyCreate = CMsgPracticeLobbyCreate {
            search_key: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            lobby_details: ::protobuf::MessageField::none(),
            save_game: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyCreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyCreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyCreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPracticeLobbyCreate`
pub mod cmsg_practice_lobby_create {
    // @@protoc_insertion_point(message:dota.CMsgPracticeLobbyCreate.SaveGame)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SaveGame {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.SaveGame.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.SaveGame.version)
        pub version: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.SaveGame.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCreate.SaveGame.signature)
        pub signature: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyCreate.SaveGame.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SaveGame {
        fn default() -> &'a SaveGame {
            <SaveGame as ::protobuf::Message>::default_instance()
        }
    }

    impl SaveGame {
        pub fn new() -> SaveGame {
            ::std::default::Default::default()
        }

        // optional bytes data = 1;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int32 version = 2;

        pub fn version(&self) -> i32 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: i32) {
            self.version = ::std::option::Option::Some(v);
        }

        // optional fixed64 steam_id = 3;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional fixed64 signature = 4;

        pub fn signature(&self) -> u64 {
            self.signature.unwrap_or(0)
        }

        pub fn clear_signature(&mut self) {
            self.signature = ::std::option::Option::None;
        }

        pub fn has_signature(&self) -> bool {
            self.signature.is_some()
        }

        // Param is passed by value, moved
        pub fn set_signature(&mut self, v: u64) {
            self.signature = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &SaveGame| { &m.data },
                |m: &mut SaveGame| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &SaveGame| { &m.version },
                |m: &mut SaveGame| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &SaveGame| { &m.steam_id },
                |m: &mut SaveGame| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "signature",
                |m: &SaveGame| { &m.signature },
                |m: &mut SaveGame| { &mut m.signature },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SaveGame>(
                "CMsgPracticeLobbyCreate.SaveGame",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SaveGame {
        const NAME: &'static str = "SaveGame";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    16 => {
                        self.version = ::std::option::Option::Some(is.read_int32()?);
                    },
                    25 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    33 => {
                        self.signature = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.signature {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.version {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_fixed64(3, v)?;
            }
            if let Some(v) = self.signature {
                os.write_fixed64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SaveGame {
            SaveGame::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.signature = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SaveGame {
            static instance: SaveGame = SaveGame {
                data: ::std::option::Option::None,
                version: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                signature: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SaveGame {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyCreate.SaveGame").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SaveGame {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SaveGame {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbySetTeamSlot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbySetTeamSlot {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetTeamSlot.team)
    pub team: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetTeamSlot.slot)
    pub slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetTeamSlot.bot_difficulty)
    pub bot_difficulty: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbySetTeamSlot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbySetTeamSlot {
    fn default() -> &'a CMsgPracticeLobbySetTeamSlot {
        <CMsgPracticeLobbySetTeamSlot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbySetTeamSlot {
    pub fn new() -> CMsgPracticeLobbySetTeamSlot {
        ::std::default::Default::default()
    }

    // optional .dota.DOTA_GC_TEAM team = 1;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 slot = 2;

    pub fn slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTABotDifficulty bot_difficulty = 3;

    pub fn bot_difficulty(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty(&mut self) {
        self.bot_difficulty = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty(&self) -> bool {
        self.bot_difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CMsgPracticeLobbySetTeamSlot| { &m.team },
            |m: &mut CMsgPracticeLobbySetTeamSlot| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CMsgPracticeLobbySetTeamSlot| { &m.slot },
            |m: &mut CMsgPracticeLobbySetTeamSlot| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty",
            |m: &CMsgPracticeLobbySetTeamSlot| { &m.bot_difficulty },
            |m: &mut CMsgPracticeLobbySetTeamSlot| { &mut m.bot_difficulty },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbySetTeamSlot>(
            "CMsgPracticeLobbySetTeamSlot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbySetTeamSlot {
    const NAME: &'static str = "CMsgPracticeLobbySetTeamSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bot_difficulty = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bot_difficulty {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bot_difficulty {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbySetTeamSlot {
        CMsgPracticeLobbySetTeamSlot::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.bot_difficulty = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbySetTeamSlot {
        static instance: CMsgPracticeLobbySetTeamSlot = CMsgPracticeLobbySetTeamSlot {
            team: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            bot_difficulty: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbySetTeamSlot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbySetTeamSlot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbySetTeamSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbySetTeamSlot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbySetCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbySetCoach {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbySetCoach.team)
    pub team: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbySetCoach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbySetCoach {
    fn default() -> &'a CMsgPracticeLobbySetCoach {
        <CMsgPracticeLobbySetCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbySetCoach {
    pub fn new() -> CMsgPracticeLobbySetCoach {
        ::std::default::Default::default()
    }

    // optional .dota.DOTA_GC_TEAM team = 1;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CMsgPracticeLobbySetCoach| { &m.team },
            |m: &mut CMsgPracticeLobbySetCoach| { &mut m.team },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbySetCoach>(
            "CMsgPracticeLobbySetCoach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbySetCoach {
    const NAME: &'static str = "CMsgPracticeLobbySetCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbySetCoach {
        CMsgPracticeLobbySetCoach::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbySetCoach {
        static instance: CMsgPracticeLobbySetCoach = CMsgPracticeLobbySetCoach {
            team: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbySetCoach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbySetCoach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbySetCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbySetCoach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyJoinBroadcastChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyJoinBroadcastChannel {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoinBroadcastChannel.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
    pub preferred_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
    pub preferred_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
    pub preferred_language_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyJoinBroadcastChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyJoinBroadcastChannel {
    fn default() -> &'a CMsgPracticeLobbyJoinBroadcastChannel {
        <CMsgPracticeLobbyJoinBroadcastChannel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyJoinBroadcastChannel {
    pub fn new() -> CMsgPracticeLobbyJoinBroadcastChannel {
        ::std::default::Default::default()
    }

    // optional uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional string preferred_description = 2;

    pub fn preferred_description(&self) -> &str {
        match self.preferred_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_description(&mut self) {
        self.preferred_description = ::std::option::Option::None;
    }

    pub fn has_preferred_description(&self) -> bool {
        self.preferred_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_description(&mut self, v: ::std::string::String) {
        self.preferred_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_description(&mut self) -> &mut ::std::string::String {
        if self.preferred_description.is_none() {
            self.preferred_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_description(&mut self) -> ::std::string::String {
        self.preferred_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preferred_country_code = 3;

    pub fn preferred_country_code(&self) -> &str {
        match self.preferred_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_country_code(&mut self) {
        self.preferred_country_code = ::std::option::Option::None;
    }

    pub fn has_preferred_country_code(&self) -> bool {
        self.preferred_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_country_code(&mut self, v: ::std::string::String) {
        self.preferred_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_country_code(&mut self) -> &mut ::std::string::String {
        if self.preferred_country_code.is_none() {
            self.preferred_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_country_code(&mut self) -> ::std::string::String {
        self.preferred_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preferred_language_code = 4;

    pub fn preferred_language_code(&self) -> &str {
        match self.preferred_language_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_language_code(&mut self) {
        self.preferred_language_code = ::std::option::Option::None;
    }

    pub fn has_preferred_language_code(&self) -> bool {
        self.preferred_language_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_language_code(&mut self, v: ::std::string::String) {
        self.preferred_language_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_language_code(&mut self) -> &mut ::std::string::String {
        if self.preferred_language_code.is_none() {
            self.preferred_language_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_language_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_language_code(&mut self) -> ::std::string::String {
        self.preferred_language_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CMsgPracticeLobbyJoinBroadcastChannel| { &m.channel },
            |m: &mut CMsgPracticeLobbyJoinBroadcastChannel| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preferred_description",
            |m: &CMsgPracticeLobbyJoinBroadcastChannel| { &m.preferred_description },
            |m: &mut CMsgPracticeLobbyJoinBroadcastChannel| { &mut m.preferred_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preferred_country_code",
            |m: &CMsgPracticeLobbyJoinBroadcastChannel| { &m.preferred_country_code },
            |m: &mut CMsgPracticeLobbyJoinBroadcastChannel| { &mut m.preferred_country_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preferred_language_code",
            |m: &CMsgPracticeLobbyJoinBroadcastChannel| { &m.preferred_language_code },
            |m: &mut CMsgPracticeLobbyJoinBroadcastChannel| { &mut m.preferred_language_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyJoinBroadcastChannel>(
            "CMsgPracticeLobbyJoinBroadcastChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyJoinBroadcastChannel {
    const NAME: &'static str = "CMsgPracticeLobbyJoinBroadcastChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.preferred_description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.preferred_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.preferred_language_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.preferred_description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.preferred_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preferred_language_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preferred_description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.preferred_country_code.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preferred_language_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyJoinBroadcastChannel {
        CMsgPracticeLobbyJoinBroadcastChannel::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.preferred_description = ::std::option::Option::None;
        self.preferred_country_code = ::std::option::Option::None;
        self.preferred_language_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyJoinBroadcastChannel {
        static instance: CMsgPracticeLobbyJoinBroadcastChannel = CMsgPracticeLobbyJoinBroadcastChannel {
            channel: ::std::option::Option::None,
            preferred_description: ::std::option::Option::None,
            preferred_country_code: ::std::option::Option::None,
            preferred_language_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyJoinBroadcastChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyJoinBroadcastChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyJoinBroadcastChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyJoinBroadcastChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyCloseBroadcastChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyCloseBroadcastChannel {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyCloseBroadcastChannel.channel)
    pub channel: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyCloseBroadcastChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyCloseBroadcastChannel {
    fn default() -> &'a CMsgPracticeLobbyCloseBroadcastChannel {
        <CMsgPracticeLobbyCloseBroadcastChannel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyCloseBroadcastChannel {
    pub fn new() -> CMsgPracticeLobbyCloseBroadcastChannel {
        ::std::default::Default::default()
    }

    // optional uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CMsgPracticeLobbyCloseBroadcastChannel| { &m.channel },
            |m: &mut CMsgPracticeLobbyCloseBroadcastChannel| { &mut m.channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyCloseBroadcastChannel>(
            "CMsgPracticeLobbyCloseBroadcastChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyCloseBroadcastChannel {
    const NAME: &'static str = "CMsgPracticeLobbyCloseBroadcastChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyCloseBroadcastChannel {
        CMsgPracticeLobbyCloseBroadcastChannel::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyCloseBroadcastChannel {
        static instance: CMsgPracticeLobbyCloseBroadcastChannel = CMsgPracticeLobbyCloseBroadcastChannel {
            channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyCloseBroadcastChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyCloseBroadcastChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyCloseBroadcastChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyCloseBroadcastChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    fn default() -> &'a CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        <CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    pub fn new() -> CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus>(
            "CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    const NAME: &'static str = "CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        static instance: CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus = CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyKick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyKick {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyKick.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyKick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyKick {
    fn default() -> &'a CMsgPracticeLobbyKick {
        <CMsgPracticeLobbyKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyKick {
    pub fn new() -> CMsgPracticeLobbyKick {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgPracticeLobbyKick| { &m.account_id },
            |m: &mut CMsgPracticeLobbyKick| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyKick>(
            "CMsgPracticeLobbyKick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyKick {
    const NAME: &'static str = "CMsgPracticeLobbyKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyKick {
        CMsgPracticeLobbyKick::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyKick {
        static instance: CMsgPracticeLobbyKick = CMsgPracticeLobbyKick {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyKick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyKick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyKick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyKickFromTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyKickFromTeam {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyKickFromTeam.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyKickFromTeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyKickFromTeam {
    fn default() -> &'a CMsgPracticeLobbyKickFromTeam {
        <CMsgPracticeLobbyKickFromTeam as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyKickFromTeam {
    pub fn new() -> CMsgPracticeLobbyKickFromTeam {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgPracticeLobbyKickFromTeam| { &m.account_id },
            |m: &mut CMsgPracticeLobbyKickFromTeam| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyKickFromTeam>(
            "CMsgPracticeLobbyKickFromTeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyKickFromTeam {
    const NAME: &'static str = "CMsgPracticeLobbyKickFromTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyKickFromTeam {
        CMsgPracticeLobbyKickFromTeam::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyKickFromTeam {
        static instance: CMsgPracticeLobbyKickFromTeam = CMsgPracticeLobbyKickFromTeam {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyKickFromTeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyKickFromTeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyKickFromTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyKickFromTeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyLeave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyLeave {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyLeave.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyLeave {
    fn default() -> &'a CMsgPracticeLobbyLeave {
        <CMsgPracticeLobbyLeave as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyLeave {
    pub fn new() -> CMsgPracticeLobbyLeave {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyLeave>(
            "CMsgPracticeLobbyLeave",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyLeave {
    const NAME: &'static str = "CMsgPracticeLobbyLeave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyLeave {
        CMsgPracticeLobbyLeave::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyLeave {
        static instance: CMsgPracticeLobbyLeave = CMsgPracticeLobbyLeave {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyLeave {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyLeave").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyLeave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyLeave {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyLaunch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyLaunch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyLaunch.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyLaunch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyLaunch {
    fn default() -> &'a CMsgPracticeLobbyLaunch {
        <CMsgPracticeLobbyLaunch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyLaunch {
    pub fn new() -> CMsgPracticeLobbyLaunch {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 5;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgPracticeLobbyLaunch| { &m.client_version },
            |m: &mut CMsgPracticeLobbyLaunch| { &mut m.client_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyLaunch>(
            "CMsgPracticeLobbyLaunch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyLaunch {
    const NAME: &'static str = "CMsgPracticeLobbyLaunch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyLaunch {
        CMsgPracticeLobbyLaunch::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyLaunch {
        static instance: CMsgPracticeLobbyLaunch = CMsgPracticeLobbyLaunch {
            client_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyLaunch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyLaunch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyLaunch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyLaunch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgApplyTeamToPracticeLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyTeamToPracticeLobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgApplyTeamToPracticeLobby.team_id)
    pub team_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgApplyTeamToPracticeLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyTeamToPracticeLobby {
    fn default() -> &'a CMsgApplyTeamToPracticeLobby {
        <CMsgApplyTeamToPracticeLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyTeamToPracticeLobby {
    pub fn new() -> CMsgApplyTeamToPracticeLobby {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CMsgApplyTeamToPracticeLobby| { &m.team_id },
            |m: &mut CMsgApplyTeamToPracticeLobby| { &mut m.team_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyTeamToPracticeLobby>(
            "CMsgApplyTeamToPracticeLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyTeamToPracticeLobby {
    const NAME: &'static str = "CMsgApplyTeamToPracticeLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyTeamToPracticeLobby {
        CMsgApplyTeamToPracticeLobby::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyTeamToPracticeLobby {
        static instance: CMsgApplyTeamToPracticeLobby = CMsgApplyTeamToPracticeLobby {
            team_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyTeamToPracticeLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyTeamToPracticeLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyTeamToPracticeLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyTeamToPracticeLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyList.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyList.region)
    pub region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyList.game_mode)
    pub game_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyList {
    fn default() -> &'a CMsgPracticeLobbyList {
        <CMsgPracticeLobbyList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyList {
    pub fn new() -> CMsgPracticeLobbyList {
        ::std::default::Default::default()
    }

    // optional string pass_key = 2;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 region = 3;

    pub fn region(&self) -> u32 {
        self.region.unwrap_or(0)
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: u32) {
        self.region = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GameMode game_mode = 4;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pass_key",
            |m: &CMsgPracticeLobbyList| { &m.pass_key },
            |m: &mut CMsgPracticeLobbyList| { &mut m.pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region",
            |m: &CMsgPracticeLobbyList| { &m.region },
            |m: &mut CMsgPracticeLobbyList| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgPracticeLobbyList| { &m.game_mode },
            |m: &mut CMsgPracticeLobbyList| { &mut m.game_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyList>(
            "CMsgPracticeLobbyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyList {
    const NAME: &'static str = "CMsgPracticeLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.region = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.region {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.region {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyList {
        CMsgPracticeLobbyList::new()
    }

    fn clear(&mut self) {
        self.pass_key = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyList {
        static instance: CMsgPracticeLobbyList = CMsgPracticeLobbyList {
            pass_key: ::std::option::Option::None,
            region: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyListResponseEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyListResponseEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.members)
    pub members: ::std::vec::Vec<cmsg_practice_lobby_list_response_entry::CLobbyMember>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.requires_pass_key)
    pub requires_pass_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.leader_account_id)
    pub leader_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
    pub custom_game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.game_mode)
    pub game_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.friend_present)
    pub friend_present: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.players)
    pub players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.max_player_count)
    pub max_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.min_player_count)
    pub min_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.penalties_enabled)
    pub penalties_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyListResponseEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyListResponseEntry {
    fn default() -> &'a CMsgPracticeLobbyListResponseEntry {
        <CMsgPracticeLobbyListResponseEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyListResponseEntry {
    pub fn new() -> CMsgPracticeLobbyListResponseEntry {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional bool requires_pass_key = 6;

    pub fn requires_pass_key(&self) -> bool {
        self.requires_pass_key.unwrap_or(false)
    }

    pub fn clear_requires_pass_key(&mut self) {
        self.requires_pass_key = ::std::option::Option::None;
    }

    pub fn has_requires_pass_key(&self) -> bool {
        self.requires_pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_pass_key(&mut self, v: bool) {
        self.requires_pass_key = ::std::option::Option::Some(v);
    }

    // optional uint32 leader_account_id = 7;

    pub fn leader_account_id(&self) -> u32 {
        self.leader_account_id.unwrap_or(0)
    }

    pub fn clear_leader_account_id(&mut self) {
        self.leader_account_id = ::std::option::Option::None;
    }

    pub fn has_leader_account_id(&self) -> bool {
        self.leader_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_account_id(&mut self, v: u32) {
        self.leader_account_id = ::std::option::Option::Some(v);
    }

    // optional string name = 10;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_game_mode = 11;

    pub fn custom_game_mode(&self) -> &str {
        match self.custom_game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_game_mode(&mut self) {
        self.custom_game_mode = ::std::option::Option::None;
    }

    pub fn has_custom_game_mode(&self) -> bool {
        self.custom_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_mode(&mut self, v: ::std::string::String) {
        self.custom_game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_mode(&mut self) -> &mut ::std::string::String {
        if self.custom_game_mode.is_none() {
            self.custom_game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_mode(&mut self) -> ::std::string::String {
        self.custom_game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .dota.DOTA_GameMode game_mode = 12;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool friend_present = 13;

    pub fn friend_present(&self) -> bool {
        self.friend_present.unwrap_or(false)
    }

    pub fn clear_friend_present(&mut self) {
        self.friend_present = ::std::option::Option::None;
    }

    pub fn has_friend_present(&self) -> bool {
        self.friend_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_present(&mut self, v: bool) {
        self.friend_present = ::std::option::Option::Some(v);
    }

    // optional uint32 players = 14;

    pub fn players(&self) -> u32 {
        self.players.unwrap_or(0)
    }

    pub fn clear_players(&mut self) {
        self.players = ::std::option::Option::None;
    }

    pub fn has_players(&self) -> bool {
        self.players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: u32) {
        self.players = ::std::option::Option::Some(v);
    }

    // optional string custom_map_name = 15;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_player_count = 16;

    pub fn max_player_count(&self) -> u32 {
        self.max_player_count.unwrap_or(0)
    }

    pub fn clear_max_player_count(&mut self) {
        self.max_player_count = ::std::option::Option::None;
    }

    pub fn has_max_player_count(&self) -> bool {
        self.max_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_player_count(&mut self, v: u32) {
        self.max_player_count = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 17;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 19;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 20;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 min_player_count = 21;

    pub fn min_player_count(&self) -> u32 {
        self.min_player_count.unwrap_or(0)
    }

    pub fn clear_min_player_count(&mut self) {
        self.min_player_count = ::std::option::Option::None;
    }

    pub fn has_min_player_count(&self) -> bool {
        self.min_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_player_count(&mut self, v: u32) {
        self.min_player_count = ::std::option::Option::Some(v);
    }

    // optional bool penalties_enabled = 22;

    pub fn penalties_enabled(&self) -> bool {
        self.penalties_enabled.unwrap_or(false)
    }

    pub fn clear_penalties_enabled(&mut self) {
        self.penalties_enabled = ::std::option::Option::None;
    }

    pub fn has_penalties_enabled(&self) -> bool {
        self.penalties_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalties_enabled(&mut self, v: bool) {
        self.penalties_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.id },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.members },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_pass_key",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.requires_pass_key },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.requires_pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leader_account_id",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.leader_account_id },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.leader_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.name },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_mode",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.custom_game_mode },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.custom_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.game_mode },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friend_present",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.friend_present },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.friend_present },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.players },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_map_name",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.custom_map_name },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.custom_map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_player_count",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.max_player_count },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.max_player_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.server_region },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.league_id },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lan_host_ping_location",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.lan_host_ping_location },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.lan_host_ping_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_player_count",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.min_player_count },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.min_player_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalties_enabled",
            |m: &CMsgPracticeLobbyListResponseEntry| { &m.penalties_enabled },
            |m: &mut CMsgPracticeLobbyListResponseEntry| { &mut m.penalties_enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyListResponseEntry>(
            "CMsgPracticeLobbyListResponseEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyListResponseEntry {
    const NAME: &'static str = "CMsgPracticeLobbyListResponseEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.members.push(is.read_message()?);
                },
                48 => {
                    self.requires_pass_key = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.leader_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.custom_game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.friend_present = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.players = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.max_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                168 => {
                    self.min_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.penalties_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.requires_pass_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.leader_account_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.friend_present {
            my_size += 1 + 1;
        }
        if let Some(v) = self.players {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.max_player_count {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.min_player_count {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.penalties_enabled {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.requires_pass_key {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.leader_account_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.friend_present {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.players {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.max_player_count {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.min_player_count {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.penalties_enabled {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyListResponseEntry {
        CMsgPracticeLobbyListResponseEntry::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.members.clear();
        self.requires_pass_key = ::std::option::Option::None;
        self.leader_account_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.custom_game_mode = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.friend_present = ::std::option::Option::None;
        self.players = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.max_player_count = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.min_player_count = ::std::option::Option::None;
        self.penalties_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyListResponseEntry {
        static instance: CMsgPracticeLobbyListResponseEntry = CMsgPracticeLobbyListResponseEntry {
            id: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            requires_pass_key: ::std::option::Option::None,
            leader_account_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            custom_game_mode: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            friend_present: ::std::option::Option::None,
            players: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            max_player_count: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            min_player_count: ::std::option::Option::None,
            penalties_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyListResponseEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyListResponseEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyListResponseEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyListResponseEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPracticeLobbyListResponseEntry`
pub mod cmsg_practice_lobby_list_response_entry {
    // @@protoc_insertion_point(message:dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CLobbyMember {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CLobbyMember {
        fn default() -> &'a CLobbyMember {
            <CLobbyMember as ::protobuf::Message>::default_instance()
        }
    }

    impl CLobbyMember {
        pub fn new() -> CLobbyMember {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string player_name = 2;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &CLobbyMember| { &m.account_id },
                |m: &mut CLobbyMember| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name",
                |m: &CLobbyMember| { &m.player_name },
                |m: &mut CLobbyMember| { &mut m.player_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CLobbyMember>(
                "CMsgPracticeLobbyListResponseEntry.CLobbyMember",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CLobbyMember {
        const NAME: &'static str = "CLobbyMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CLobbyMember {
            CLobbyMember::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CLobbyMember {
            static instance: CLobbyMember = CLobbyMember {
                account_id: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CLobbyMember {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyListResponseEntry.CLobbyMember").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CLobbyMember {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CLobbyMember {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgPracticeLobbyListResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyListResponse {
    fn default() -> &'a CMsgPracticeLobbyListResponse {
        <CMsgPracticeLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyListResponse {
    pub fn new() -> CMsgPracticeLobbyListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobbies",
            |m: &CMsgPracticeLobbyListResponse| { &m.lobbies },
            |m: &mut CMsgPracticeLobbyListResponse| { &mut m.lobbies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyListResponse>(
            "CMsgPracticeLobbyListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyListResponse {
    const NAME: &'static str = "CMsgPracticeLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyListResponse {
        CMsgPracticeLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyListResponse {
        static instance: CMsgPracticeLobbyListResponse = CMsgPracticeLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyList.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyList.game_mode)
    pub game_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyList {
    fn default() -> &'a CMsgLobbyList {
        <CMsgLobbyList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyList {
    pub fn new() -> CMsgLobbyList {
        ::std::default::Default::default()
    }

    // optional uint32 server_region = 1;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GameMode game_mode = 2;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgLobbyList| { &m.server_region },
            |m: &mut CMsgLobbyList| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgLobbyList| { &m.game_mode },
            |m: &mut CMsgLobbyList| { &mut m.game_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyList>(
            "CMsgLobbyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyList {
    const NAME: &'static str = "CMsgLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_region {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyList {
        CMsgLobbyList::new()
    }

    fn clear(&mut self) {
        self.server_region = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyList {
        static instance: CMsgLobbyList = CMsgLobbyList {
            server_region: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgPracticeLobbyListResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyListResponse {
    fn default() -> &'a CMsgLobbyListResponse {
        <CMsgLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyListResponse {
    pub fn new() -> CMsgLobbyListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobbies",
            |m: &CMsgLobbyListResponse| { &m.lobbies },
            |m: &mut CMsgLobbyListResponse| { &mut m.lobbies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyListResponse>(
            "CMsgLobbyListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyListResponse {
    const NAME: &'static str = "CMsgLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyListResponse {
        CMsgLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyListResponse {
        static instance: CMsgLobbyListResponse = CMsgLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyJoin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyJoin {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoin.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoin.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoin.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoin.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoin.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyJoin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyJoin {
    fn default() -> &'a CMsgPracticeLobbyJoin {
        <CMsgPracticeLobbyJoin as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyJoin {
    pub fn new() -> CMsgPracticeLobbyJoin {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional string pass_key = 3;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 custom_game_crc = 4;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 5;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgPracticeLobbyJoin| { &m.lobby_id },
            |m: &mut CMsgPracticeLobbyJoin| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgPracticeLobbyJoin| { &m.client_version },
            |m: &mut CMsgPracticeLobbyJoin| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pass_key",
            |m: &CMsgPracticeLobbyJoin| { &m.pass_key },
            |m: &mut CMsgPracticeLobbyJoin| { &mut m.pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_crc",
            |m: &CMsgPracticeLobbyJoin| { &m.custom_game_crc },
            |m: &mut CMsgPracticeLobbyJoin| { &mut m.custom_game_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_timestamp",
            |m: &CMsgPracticeLobbyJoin| { &m.custom_game_timestamp },
            |m: &mut CMsgPracticeLobbyJoin| { &mut m.custom_game_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyJoin>(
            "CMsgPracticeLobbyJoin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyJoin {
    const NAME: &'static str = "CMsgPracticeLobbyJoin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                33 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyJoin {
        CMsgPracticeLobbyJoin::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyJoin {
        static instance: CMsgPracticeLobbyJoin = CMsgPracticeLobbyJoin {
            lobby_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyJoin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyJoin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyJoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyJoin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPracticeLobbyJoinResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyJoinResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPracticeLobbyJoinResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTAJoinLobbyResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPracticeLobbyJoinResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyJoinResponse {
    fn default() -> &'a CMsgPracticeLobbyJoinResponse {
        <CMsgPracticeLobbyJoinResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyJoinResponse {
    pub fn new() -> CMsgPracticeLobbyJoinResponse {
        ::std::default::Default::default()
    }

    // optional .dota.DOTAJoinLobbyResult result = 1;

    pub fn result(&self) -> super::dota_shared_enums::DOTAJoinLobbyResult {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            None => super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_shared_enums::DOTAJoinLobbyResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgPracticeLobbyJoinResponse| { &m.result },
            |m: &mut CMsgPracticeLobbyJoinResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPracticeLobbyJoinResponse>(
            "CMsgPracticeLobbyJoinResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPracticeLobbyJoinResponse {
    const NAME: &'static str = "CMsgPracticeLobbyJoinResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyJoinResponse {
        CMsgPracticeLobbyJoinResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyJoinResponse {
        static instance: CMsgPracticeLobbyJoinResponse = CMsgPracticeLobbyJoinResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPracticeLobbyJoinResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPracticeLobbyJoinResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPracticeLobbyJoinResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPracticeLobbyJoinResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgFriendPracticeLobbyListRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFriendPracticeLobbyListRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgFriendPracticeLobbyListRequest.friends)
    pub friends: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgFriendPracticeLobbyListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFriendPracticeLobbyListRequest {
    fn default() -> &'a CMsgFriendPracticeLobbyListRequest {
        <CMsgFriendPracticeLobbyListRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFriendPracticeLobbyListRequest {
    pub fn new() -> CMsgFriendPracticeLobbyListRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends",
            |m: &CMsgFriendPracticeLobbyListRequest| { &m.friends },
            |m: &mut CMsgFriendPracticeLobbyListRequest| { &mut m.friends },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFriendPracticeLobbyListRequest>(
            "CMsgFriendPracticeLobbyListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFriendPracticeLobbyListRequest {
    const NAME: &'static str = "CMsgFriendPracticeLobbyListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.friends)?;
                },
                8 => {
                    self.friends.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.friends {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.friends {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFriendPracticeLobbyListRequest {
        CMsgFriendPracticeLobbyListRequest::new()
    }

    fn clear(&mut self) {
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFriendPracticeLobbyListRequest {
        static instance: CMsgFriendPracticeLobbyListRequest = CMsgFriendPracticeLobbyListRequest {
            friends: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFriendPracticeLobbyListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFriendPracticeLobbyListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFriendPracticeLobbyListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFriendPracticeLobbyListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgFriendPracticeLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFriendPracticeLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgFriendPracticeLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgPracticeLobbyListResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgFriendPracticeLobbyListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFriendPracticeLobbyListResponse {
    fn default() -> &'a CMsgFriendPracticeLobbyListResponse {
        <CMsgFriendPracticeLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFriendPracticeLobbyListResponse {
    pub fn new() -> CMsgFriendPracticeLobbyListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobbies",
            |m: &CMsgFriendPracticeLobbyListResponse| { &m.lobbies },
            |m: &mut CMsgFriendPracticeLobbyListResponse| { &mut m.lobbies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFriendPracticeLobbyListResponse>(
            "CMsgFriendPracticeLobbyListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFriendPracticeLobbyListResponse {
    const NAME: &'static str = "CMsgFriendPracticeLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFriendPracticeLobbyListResponse {
        CMsgFriendPracticeLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFriendPracticeLobbyListResponse {
        static instance: CMsgFriendPracticeLobbyListResponse = CMsgFriendPracticeLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFriendPracticeLobbyListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFriendPracticeLobbyListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFriendPracticeLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFriendPracticeLobbyListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgJoinableCustomGameModesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomGameModesRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomGameModesRequest.server_region)
    pub server_region: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgJoinableCustomGameModesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomGameModesRequest {
    fn default() -> &'a CMsgJoinableCustomGameModesRequest {
        <CMsgJoinableCustomGameModesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomGameModesRequest {
    pub fn new() -> CMsgJoinableCustomGameModesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 server_region = 1;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgJoinableCustomGameModesRequest| { &m.server_region },
            |m: &mut CMsgJoinableCustomGameModesRequest| { &mut m.server_region },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJoinableCustomGameModesRequest>(
            "CMsgJoinableCustomGameModesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJoinableCustomGameModesRequest {
    const NAME: &'static str = "CMsgJoinableCustomGameModesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_region {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomGameModesRequest {
        CMsgJoinableCustomGameModesRequest::new()
    }

    fn clear(&mut self) {
        self.server_region = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomGameModesRequest {
        static instance: CMsgJoinableCustomGameModesRequest = CMsgJoinableCustomGameModesRequest {
            server_region: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJoinableCustomGameModesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJoinableCustomGameModesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJoinableCustomGameModesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJoinableCustomGameModesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgJoinableCustomGameModesResponseEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomGameModesResponseEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomGameModesResponseEntry.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomGameModesResponseEntry.lobby_count)
    pub lobby_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomGameModesResponseEntry.player_count)
    pub player_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgJoinableCustomGameModesResponseEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomGameModesResponseEntry {
    fn default() -> &'a CMsgJoinableCustomGameModesResponseEntry {
        <CMsgJoinableCustomGameModesResponseEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomGameModesResponseEntry {
    pub fn new() -> CMsgJoinableCustomGameModesResponseEntry {
        ::std::default::Default::default()
    }

    // optional uint64 custom_game_id = 1;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_count = 2;

    pub fn lobby_count(&self) -> u32 {
        self.lobby_count.unwrap_or(0)
    }

    pub fn clear_lobby_count(&mut self) {
        self.lobby_count = ::std::option::Option::None;
    }

    pub fn has_lobby_count(&self) -> bool {
        self.lobby_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_count(&mut self, v: u32) {
        self.lobby_count = ::std::option::Option::Some(v);
    }

    // optional uint32 player_count = 3;

    pub fn player_count(&self) -> u32 {
        self.player_count.unwrap_or(0)
    }

    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: u32) {
        self.player_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CMsgJoinableCustomGameModesResponseEntry| { &m.custom_game_id },
            |m: &mut CMsgJoinableCustomGameModesResponseEntry| { &mut m.custom_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_count",
            |m: &CMsgJoinableCustomGameModesResponseEntry| { &m.lobby_count },
            |m: &mut CMsgJoinableCustomGameModesResponseEntry| { &mut m.lobby_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_count",
            |m: &CMsgJoinableCustomGameModesResponseEntry| { &m.player_count },
            |m: &mut CMsgJoinableCustomGameModesResponseEntry| { &mut m.player_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJoinableCustomGameModesResponseEntry>(
            "CMsgJoinableCustomGameModesResponseEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJoinableCustomGameModesResponseEntry {
    const NAME: &'static str = "CMsgJoinableCustomGameModesResponseEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.lobby_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.player_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomGameModesResponseEntry {
        CMsgJoinableCustomGameModesResponseEntry::new()
    }

    fn clear(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
        self.lobby_count = ::std::option::Option::None;
        self.player_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomGameModesResponseEntry {
        static instance: CMsgJoinableCustomGameModesResponseEntry = CMsgJoinableCustomGameModesResponseEntry {
            custom_game_id: ::std::option::Option::None,
            lobby_count: ::std::option::Option::None,
            player_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJoinableCustomGameModesResponseEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJoinableCustomGameModesResponseEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJoinableCustomGameModesResponseEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJoinableCustomGameModesResponseEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgJoinableCustomGameModesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomGameModesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomGameModesResponse.game_modes)
    pub game_modes: ::std::vec::Vec<CMsgJoinableCustomGameModesResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgJoinableCustomGameModesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomGameModesResponse {
    fn default() -> &'a CMsgJoinableCustomGameModesResponse {
        <CMsgJoinableCustomGameModesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomGameModesResponse {
    pub fn new() -> CMsgJoinableCustomGameModesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "game_modes",
            |m: &CMsgJoinableCustomGameModesResponse| { &m.game_modes },
            |m: &mut CMsgJoinableCustomGameModesResponse| { &mut m.game_modes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJoinableCustomGameModesResponse>(
            "CMsgJoinableCustomGameModesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJoinableCustomGameModesResponse {
    const NAME: &'static str = "CMsgJoinableCustomGameModesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.game_modes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.game_modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.game_modes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomGameModesResponse {
        CMsgJoinableCustomGameModesResponse::new()
    }

    fn clear(&mut self) {
        self.game_modes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomGameModesResponse {
        static instance: CMsgJoinableCustomGameModesResponse = CMsgJoinableCustomGameModesResponse {
            game_modes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJoinableCustomGameModesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJoinableCustomGameModesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJoinableCustomGameModesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJoinableCustomGameModesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgJoinableCustomLobbiesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomLobbiesRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesRequest.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesRequest.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgJoinableCustomLobbiesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomLobbiesRequest {
    fn default() -> &'a CMsgJoinableCustomLobbiesRequest {
        <CMsgJoinableCustomLobbiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomLobbiesRequest {
    pub fn new() -> CMsgJoinableCustomLobbiesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 server_region = 1;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 2;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgJoinableCustomLobbiesRequest| { &m.server_region },
            |m: &mut CMsgJoinableCustomLobbiesRequest| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CMsgJoinableCustomLobbiesRequest| { &m.custom_game_id },
            |m: &mut CMsgJoinableCustomLobbiesRequest| { &mut m.custom_game_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJoinableCustomLobbiesRequest>(
            "CMsgJoinableCustomLobbiesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJoinableCustomLobbiesRequest {
    const NAME: &'static str = "CMsgJoinableCustomLobbiesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_region {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomLobbiesRequest {
        CMsgJoinableCustomLobbiesRequest::new()
    }

    fn clear(&mut self) {
        self.server_region = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomLobbiesRequest {
        static instance: CMsgJoinableCustomLobbiesRequest = CMsgJoinableCustomLobbiesRequest {
            server_region: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJoinableCustomLobbiesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJoinableCustomLobbiesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJoinableCustomLobbiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJoinableCustomLobbiesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgJoinableCustomLobbiesResponseEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomLobbiesResponseEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
    pub lobby_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.member_count)
    pub member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.leader_account_id)
    pub leader_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
    pub leader_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.max_player_count)
    pub max_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.has_pass_key)
    pub has_pass_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_creation_time)
    pub lobby_creation_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.min_player_count)
    pub min_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponseEntry.penalties_enabled)
    pub penalties_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgJoinableCustomLobbiesResponseEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomLobbiesResponseEntry {
    fn default() -> &'a CMsgJoinableCustomLobbiesResponseEntry {
        <CMsgJoinableCustomLobbiesResponseEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomLobbiesResponseEntry {
    pub fn new() -> CMsgJoinableCustomLobbiesResponseEntry {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 2;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional string lobby_name = 3;

    pub fn lobby_name(&self) -> &str {
        match self.lobby_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lobby_name(&mut self) {
        self.lobby_name = ::std::option::Option::None;
    }

    pub fn has_lobby_name(&self) -> bool {
        self.lobby_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_name(&mut self, v: ::std::string::String) {
        self.lobby_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_name(&mut self) -> &mut ::std::string::String {
        if self.lobby_name.is_none() {
            self.lobby_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lobby_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_name(&mut self) -> ::std::string::String {
        self.lobby_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 member_count = 4;

    pub fn member_count(&self) -> u32 {
        self.member_count.unwrap_or(0)
    }

    pub fn clear_member_count(&mut self) {
        self.member_count = ::std::option::Option::None;
    }

    pub fn has_member_count(&self) -> bool {
        self.member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_count(&mut self, v: u32) {
        self.member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 leader_account_id = 5;

    pub fn leader_account_id(&self) -> u32 {
        self.leader_account_id.unwrap_or(0)
    }

    pub fn clear_leader_account_id(&mut self) {
        self.leader_account_id = ::std::option::Option::None;
    }

    pub fn has_leader_account_id(&self) -> bool {
        self.leader_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_account_id(&mut self, v: u32) {
        self.leader_account_id = ::std::option::Option::Some(v);
    }

    // optional string leader_name = 6;

    pub fn leader_name(&self) -> &str {
        match self.leader_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leader_name(&mut self) {
        self.leader_name = ::std::option::Option::None;
    }

    pub fn has_leader_name(&self) -> bool {
        self.leader_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_name(&mut self, v: ::std::string::String) {
        self.leader_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leader_name(&mut self) -> &mut ::std::string::String {
        if self.leader_name.is_none() {
            self.leader_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.leader_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leader_name(&mut self) -> ::std::string::String {
        self.leader_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_map_name = 7;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_player_count = 8;

    pub fn max_player_count(&self) -> u32 {
        self.max_player_count.unwrap_or(0)
    }

    pub fn clear_max_player_count(&mut self) {
        self.max_player_count = ::std::option::Option::None;
    }

    pub fn has_max_player_count(&self) -> bool {
        self.max_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_player_count(&mut self, v: u32) {
        self.max_player_count = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 9;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional bool has_pass_key = 11;

    pub fn has_pass_key(&self) -> bool {
        self.has_pass_key.unwrap_or(false)
    }

    pub fn clear_has_pass_key(&mut self) {
        self.has_pass_key = ::std::option::Option::None;
    }

    pub fn has_has_pass_key(&self) -> bool {
        self.has_pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_pass_key(&mut self, v: bool) {
        self.has_pass_key = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 12;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 lobby_creation_time = 13;

    pub fn lobby_creation_time(&self) -> u32 {
        self.lobby_creation_time.unwrap_or(0)
    }

    pub fn clear_lobby_creation_time(&mut self) {
        self.lobby_creation_time = ::std::option::Option::None;
    }

    pub fn has_lobby_creation_time(&self) -> bool {
        self.lobby_creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_creation_time(&mut self, v: u32) {
        self.lobby_creation_time = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_game_timestamp = 14;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_crc = 15;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 min_player_count = 16;

    pub fn min_player_count(&self) -> u32 {
        self.min_player_count.unwrap_or(0)
    }

    pub fn clear_min_player_count(&mut self) {
        self.min_player_count = ::std::option::Option::None;
    }

    pub fn has_min_player_count(&self) -> bool {
        self.min_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_player_count(&mut self, v: u32) {
        self.min_player_count = ::std::option::Option::Some(v);
    }

    // optional bool penalties_enabled = 17;

    pub fn penalties_enabled(&self) -> bool {
        self.penalties_enabled.unwrap_or(false)
    }

    pub fn clear_penalties_enabled(&mut self) {
        self.penalties_enabled = ::std::option::Option::None;
    }

    pub fn has_penalties_enabled(&self) -> bool {
        self.penalties_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalties_enabled(&mut self, v: bool) {
        self.penalties_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.lobby_id },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.custom_game_id },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.custom_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_name",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.lobby_name },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.lobby_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_count",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.member_count },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.member_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leader_account_id",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.leader_account_id },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.leader_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leader_name",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.leader_name },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.leader_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_map_name",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.custom_map_name },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.custom_map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_player_count",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.max_player_count },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.max_player_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.server_region },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_pass_key",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.has_pass_key },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.has_pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lan_host_ping_location",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.lan_host_ping_location },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.lan_host_ping_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_creation_time",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.lobby_creation_time },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.lobby_creation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_timestamp",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.custom_game_timestamp },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.custom_game_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_crc",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.custom_game_crc },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.custom_game_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_player_count",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.min_player_count },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.min_player_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalties_enabled",
            |m: &CMsgJoinableCustomLobbiesResponseEntry| { &m.penalties_enabled },
            |m: &mut CMsgJoinableCustomLobbiesResponseEntry| { &mut m.penalties_enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJoinableCustomLobbiesResponseEntry>(
            "CMsgJoinableCustomLobbiesResponseEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJoinableCustomLobbiesResponseEntry {
    const NAME: &'static str = "CMsgJoinableCustomLobbiesResponseEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.lobby_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.leader_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.leader_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.max_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.has_pass_key = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.lobby_creation_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_uint64()?);
                },
                128 => {
                    self.min_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.penalties_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.lobby_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.member_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.leader_account_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.leader_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.max_player_count {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.has_pass_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.lobby_creation_time {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.custom_game_crc {
            my_size += ::protobuf::rt::uint64_size(15, v);
        }
        if let Some(v) = self.min_player_count {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.penalties_enabled {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.lobby_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.member_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.leader_account_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.leader_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.max_player_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.has_pass_key {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.lobby_creation_time {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.min_player_count {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.penalties_enabled {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomLobbiesResponseEntry {
        CMsgJoinableCustomLobbiesResponseEntry::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.lobby_name = ::std::option::Option::None;
        self.member_count = ::std::option::Option::None;
        self.leader_account_id = ::std::option::Option::None;
        self.leader_name = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.max_player_count = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.has_pass_key = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.lobby_creation_time = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.min_player_count = ::std::option::Option::None;
        self.penalties_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomLobbiesResponseEntry {
        static instance: CMsgJoinableCustomLobbiesResponseEntry = CMsgJoinableCustomLobbiesResponseEntry {
            lobby_id: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            lobby_name: ::std::option::Option::None,
            member_count: ::std::option::Option::None,
            leader_account_id: ::std::option::Option::None,
            leader_name: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            max_player_count: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            has_pass_key: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            lobby_creation_time: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            min_player_count: ::std::option::Option::None,
            penalties_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJoinableCustomLobbiesResponseEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJoinableCustomLobbiesResponseEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJoinableCustomLobbiesResponseEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJoinableCustomLobbiesResponseEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgJoinableCustomLobbiesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomLobbiesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgJoinableCustomLobbiesResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgJoinableCustomLobbiesResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgJoinableCustomLobbiesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomLobbiesResponse {
    fn default() -> &'a CMsgJoinableCustomLobbiesResponse {
        <CMsgJoinableCustomLobbiesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomLobbiesResponse {
    pub fn new() -> CMsgJoinableCustomLobbiesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobbies",
            |m: &CMsgJoinableCustomLobbiesResponse| { &m.lobbies },
            |m: &mut CMsgJoinableCustomLobbiesResponse| { &mut m.lobbies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJoinableCustomLobbiesResponse>(
            "CMsgJoinableCustomLobbiesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJoinableCustomLobbiesResponse {
    const NAME: &'static str = "CMsgJoinableCustomLobbiesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomLobbiesResponse {
        CMsgJoinableCustomLobbiesResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomLobbiesResponse {
        static instance: CMsgJoinableCustomLobbiesResponse = CMsgJoinableCustomLobbiesResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJoinableCustomLobbiesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJoinableCustomLobbiesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJoinableCustomLobbiesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJoinableCustomLobbiesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgQuickJoinCustomLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuickJoinCustomLobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.legacy_server_region)
    pub legacy_server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.create_lobby_details)
    pub create_lobby_details: ::protobuf::MessageField<CMsgPracticeLobbySetDetails>,
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.allow_any_map)
    pub allow_any_map: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.legacy_region_pings)
    pub legacy_region_pings: ::std::vec::Vec<cmsg_quick_join_custom_lobby::LegacyRegionPing>,
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.ping_data)
    pub ping_data: ::protobuf::MessageField<super::base_gcmessages::CMsgClientPingData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgQuickJoinCustomLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuickJoinCustomLobby {
    fn default() -> &'a CMsgQuickJoinCustomLobby {
        <CMsgQuickJoinCustomLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuickJoinCustomLobby {
    pub fn new() -> CMsgQuickJoinCustomLobby {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_server_region = 1;

    pub fn legacy_server_region(&self) -> u32 {
        self.legacy_server_region.unwrap_or(0)
    }

    pub fn clear_legacy_server_region(&mut self) {
        self.legacy_server_region = ::std::option::Option::None;
    }

    pub fn has_legacy_server_region(&self) -> bool {
        self.legacy_server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_server_region(&mut self, v: u32) {
        self.legacy_server_region = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 2;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional bool allow_any_map = 5;

    pub fn allow_any_map(&self) -> bool {
        self.allow_any_map.unwrap_or(false)
    }

    pub fn clear_allow_any_map(&mut self) {
        self.allow_any_map = ::std::option::Option::None;
    }

    pub fn has_allow_any_map(&self) -> bool {
        self.allow_any_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_any_map(&mut self, v: bool) {
        self.allow_any_map = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_server_region",
            |m: &CMsgQuickJoinCustomLobby| { &m.legacy_server_region },
            |m: &mut CMsgQuickJoinCustomLobby| { &mut m.legacy_server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CMsgQuickJoinCustomLobby| { &m.custom_game_id },
            |m: &mut CMsgQuickJoinCustomLobby| { &mut m.custom_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgQuickJoinCustomLobby| { &m.client_version },
            |m: &mut CMsgQuickJoinCustomLobby| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPracticeLobbySetDetails>(
            "create_lobby_details",
            |m: &CMsgQuickJoinCustomLobby| { &m.create_lobby_details },
            |m: &mut CMsgQuickJoinCustomLobby| { &mut m.create_lobby_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_any_map",
            |m: &CMsgQuickJoinCustomLobby| { &m.allow_any_map },
            |m: &mut CMsgQuickJoinCustomLobby| { &mut m.allow_any_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_region_pings",
            |m: &CMsgQuickJoinCustomLobby| { &m.legacy_region_pings },
            |m: &mut CMsgQuickJoinCustomLobby| { &mut m.legacy_region_pings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::base_gcmessages::CMsgClientPingData>(
            "ping_data",
            |m: &CMsgQuickJoinCustomLobby| { &m.ping_data },
            |m: &mut CMsgQuickJoinCustomLobby| { &mut m.ping_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuickJoinCustomLobby>(
            "CMsgQuickJoinCustomLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuickJoinCustomLobby {
    const NAME: &'static str = "CMsgQuickJoinCustomLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.create_lobby_details)?;
                },
                40 => {
                    self.allow_any_map = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.legacy_region_pings.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_server_region {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.create_lobby_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allow_any_map {
            my_size += 1 + 1;
        }
        for value in &self.legacy_region_pings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.legacy_server_region {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.create_lobby_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.allow_any_map {
            os.write_bool(5, v)?;
        }
        for v in &self.legacy_region_pings {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.ping_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuickJoinCustomLobby {
        CMsgQuickJoinCustomLobby::new()
    }

    fn clear(&mut self) {
        self.legacy_server_region = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.create_lobby_details.clear();
        self.allow_any_map = ::std::option::Option::None;
        self.legacy_region_pings.clear();
        self.ping_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuickJoinCustomLobby {
        static instance: CMsgQuickJoinCustomLobby = CMsgQuickJoinCustomLobby {
            legacy_server_region: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            create_lobby_details: ::protobuf::MessageField::none(),
            allow_any_map: ::std::option::Option::None,
            legacy_region_pings: ::std::vec::Vec::new(),
            ping_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuickJoinCustomLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuickJoinCustomLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuickJoinCustomLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuickJoinCustomLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgQuickJoinCustomLobby`
pub mod cmsg_quick_join_custom_lobby {
    // @@protoc_insertion_point(message:dota.CMsgQuickJoinCustomLobby.LegacyRegionPing)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LegacyRegionPing {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.server_region)
        pub server_region: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.ping)
        pub ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.region_code)
        pub region_code: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LegacyRegionPing {
        fn default() -> &'a LegacyRegionPing {
            <LegacyRegionPing as ::protobuf::Message>::default_instance()
        }
    }

    impl LegacyRegionPing {
        pub fn new() -> LegacyRegionPing {
            ::std::default::Default::default()
        }

        // optional uint32 server_region = 1;

        pub fn server_region(&self) -> u32 {
            self.server_region.unwrap_or(0)
        }

        pub fn clear_server_region(&mut self) {
            self.server_region = ::std::option::Option::None;
        }

        pub fn has_server_region(&self) -> bool {
            self.server_region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_region(&mut self, v: u32) {
            self.server_region = ::std::option::Option::Some(v);
        }

        // optional uint32 ping = 2;

        pub fn ping(&self) -> u32 {
            self.ping.unwrap_or(0)
        }

        pub fn clear_ping(&mut self) {
            self.ping = ::std::option::Option::None;
        }

        pub fn has_ping(&self) -> bool {
            self.ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping(&mut self, v: u32) {
            self.ping = ::std::option::Option::Some(v);
        }

        // optional fixed32 region_code = 3;

        pub fn region_code(&self) -> u32 {
            self.region_code.unwrap_or(0)
        }

        pub fn clear_region_code(&mut self) {
            self.region_code = ::std::option::Option::None;
        }

        pub fn has_region_code(&self) -> bool {
            self.region_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region_code(&mut self, v: u32) {
            self.region_code = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_region",
                |m: &LegacyRegionPing| { &m.server_region },
                |m: &mut LegacyRegionPing| { &mut m.server_region },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping",
                |m: &LegacyRegionPing| { &m.ping },
                |m: &mut LegacyRegionPing| { &mut m.ping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region_code",
                |m: &LegacyRegionPing| { &m.region_code },
                |m: &mut LegacyRegionPing| { &mut m.region_code },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LegacyRegionPing>(
                "CMsgQuickJoinCustomLobby.LegacyRegionPing",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LegacyRegionPing {
        const NAME: &'static str = "LegacyRegionPing";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.region_code = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_region {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ping {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.region_code {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_region {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ping {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.region_code {
                os.write_fixed32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LegacyRegionPing {
            LegacyRegionPing::new()
        }

        fn clear(&mut self) {
            self.server_region = ::std::option::Option::None;
            self.ping = ::std::option::Option::None;
            self.region_code = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LegacyRegionPing {
            static instance: LegacyRegionPing = LegacyRegionPing {
                server_region: ::std::option::Option::None,
                ping: ::std::option::Option::None,
                region_code: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LegacyRegionPing {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgQuickJoinCustomLobby.LegacyRegionPing").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LegacyRegionPing {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LegacyRegionPing {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgQuickJoinCustomLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuickJoinCustomLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgQuickJoinCustomLobbyResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTAJoinLobbyResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgQuickJoinCustomLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuickJoinCustomLobbyResponse {
    fn default() -> &'a CMsgQuickJoinCustomLobbyResponse {
        <CMsgQuickJoinCustomLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuickJoinCustomLobbyResponse {
    pub fn new() -> CMsgQuickJoinCustomLobbyResponse {
        ::std::default::Default::default()
    }

    // optional .dota.DOTAJoinLobbyResult result = 1;

    pub fn result(&self) -> super::dota_shared_enums::DOTAJoinLobbyResult {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            None => super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_shared_enums::DOTAJoinLobbyResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgQuickJoinCustomLobbyResponse| { &m.result },
            |m: &mut CMsgQuickJoinCustomLobbyResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuickJoinCustomLobbyResponse>(
            "CMsgQuickJoinCustomLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuickJoinCustomLobbyResponse {
    const NAME: &'static str = "CMsgQuickJoinCustomLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuickJoinCustomLobbyResponse {
        CMsgQuickJoinCustomLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuickJoinCustomLobbyResponse {
        static instance: CMsgQuickJoinCustomLobbyResponse = CMsgQuickJoinCustomLobbyResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuickJoinCustomLobbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuickJoinCustomLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuickJoinCustomLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuickJoinCustomLobbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgBotGameCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBotGameCreate {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBotGameCreate.search_key)
    pub search_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgBotGameCreate.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBotGameCreate.difficulty_radiant)
    pub difficulty_radiant: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:dota.CMsgBotGameCreate.team)
    pub team: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:dota.CMsgBotGameCreate.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBotGameCreate.difficulty_dire)
    pub difficulty_dire: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBotGameCreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBotGameCreate {
    fn default() -> &'a CMsgBotGameCreate {
        <CMsgBotGameCreate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBotGameCreate {
    pub fn new() -> CMsgBotGameCreate {
        ::std::default::Default::default()
    }

    // optional string search_key = 1;

    pub fn search_key(&self) -> &str {
        match self.search_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_key(&mut self) {
        self.search_key = ::std::option::Option::None;
    }

    pub fn has_search_key(&self) -> bool {
        self.search_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_key(&mut self, v: ::std::string::String) {
        self.search_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_key(&mut self) -> &mut ::std::string::String {
        if self.search_key.is_none() {
            self.search_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_key(&mut self) -> ::std::string::String {
        self.search_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTABotDifficulty difficulty_radiant = 3;

    pub fn difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_difficulty_radiant(&mut self) {
        self.difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_difficulty_radiant(&self) -> bool {
        self.difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.difficulty_radiant = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.DOTA_GC_TEAM team = 4;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 game_mode = 5;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTABotDifficulty difficulty_dire = 6;

    pub fn difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_difficulty_dire(&mut self) {
        self.difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_difficulty_dire(&self) -> bool {
        self.difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.difficulty_dire = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_key",
            |m: &CMsgBotGameCreate| { &m.search_key },
            |m: &mut CMsgBotGameCreate| { &mut m.search_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgBotGameCreate| { &m.client_version },
            |m: &mut CMsgBotGameCreate| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "difficulty_radiant",
            |m: &CMsgBotGameCreate| { &m.difficulty_radiant },
            |m: &mut CMsgBotGameCreate| { &mut m.difficulty_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CMsgBotGameCreate| { &m.team },
            |m: &mut CMsgBotGameCreate| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgBotGameCreate| { &m.game_mode },
            |m: &mut CMsgBotGameCreate| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "difficulty_dire",
            |m: &CMsgBotGameCreate| { &m.difficulty_dire },
            |m: &mut CMsgBotGameCreate| { &mut m.difficulty_dire },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBotGameCreate>(
            "CMsgBotGameCreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBotGameCreate {
    const NAME: &'static str = "CMsgBotGameCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search_key = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.search_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.difficulty_radiant {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.difficulty_dire {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.search_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.difficulty_radiant {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.team {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.difficulty_dire {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBotGameCreate {
        CMsgBotGameCreate::new()
    }

    fn clear(&mut self) {
        self.search_key = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.difficulty_radiant = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.difficulty_dire = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBotGameCreate {
        static instance: CMsgBotGameCreate = CMsgBotGameCreate {
            search_key: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            difficulty_radiant: ::std::option::Option::None,
            team: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            difficulty_dire: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBotGameCreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBotGameCreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBotGameCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBotGameCreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAPartyMemberSetCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPartyMemberSetCoach {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAPartyMemberSetCoach.wants_coach)
    pub wants_coach: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAPartyMemberSetCoach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPartyMemberSetCoach {
    fn default() -> &'a CMsgDOTAPartyMemberSetCoach {
        <CMsgDOTAPartyMemberSetCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPartyMemberSetCoach {
    pub fn new() -> CMsgDOTAPartyMemberSetCoach {
        ::std::default::Default::default()
    }

    // optional bool wants_coach = 1;

    pub fn wants_coach(&self) -> bool {
        self.wants_coach.unwrap_or(false)
    }

    pub fn clear_wants_coach(&mut self) {
        self.wants_coach = ::std::option::Option::None;
    }

    pub fn has_wants_coach(&self) -> bool {
        self.wants_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_coach(&mut self, v: bool) {
        self.wants_coach = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wants_coach",
            |m: &CMsgDOTAPartyMemberSetCoach| { &m.wants_coach },
            |m: &mut CMsgDOTAPartyMemberSetCoach| { &mut m.wants_coach },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAPartyMemberSetCoach>(
            "CMsgDOTAPartyMemberSetCoach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAPartyMemberSetCoach {
    const NAME: &'static str = "CMsgDOTAPartyMemberSetCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wants_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wants_coach {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.wants_coach {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPartyMemberSetCoach {
        CMsgDOTAPartyMemberSetCoach::new()
    }

    fn clear(&mut self) {
        self.wants_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPartyMemberSetCoach {
        static instance: CMsgDOTAPartyMemberSetCoach = CMsgDOTAPartyMemberSetCoach {
            wants_coach: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAPartyMemberSetCoach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAPartyMemberSetCoach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAPartyMemberSetCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPartyMemberSetCoach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTASetGroupLeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetGroupLeader {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTASetGroupLeader.new_leader_steamid)
    pub new_leader_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTASetGroupLeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetGroupLeader {
    fn default() -> &'a CMsgDOTASetGroupLeader {
        <CMsgDOTASetGroupLeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetGroupLeader {
    pub fn new() -> CMsgDOTASetGroupLeader {
        ::std::default::Default::default()
    }

    // optional fixed64 new_leader_steamid = 1;

    pub fn new_leader_steamid(&self) -> u64 {
        self.new_leader_steamid.unwrap_or(0)
    }

    pub fn clear_new_leader_steamid(&mut self) {
        self.new_leader_steamid = ::std::option::Option::None;
    }

    pub fn has_new_leader_steamid(&self) -> bool {
        self.new_leader_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_leader_steamid(&mut self, v: u64) {
        self.new_leader_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_leader_steamid",
            |m: &CMsgDOTASetGroupLeader| { &m.new_leader_steamid },
            |m: &mut CMsgDOTASetGroupLeader| { &mut m.new_leader_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTASetGroupLeader>(
            "CMsgDOTASetGroupLeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTASetGroupLeader {
    const NAME: &'static str = "CMsgDOTASetGroupLeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.new_leader_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_leader_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_leader_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetGroupLeader {
        CMsgDOTASetGroupLeader::new()
    }

    fn clear(&mut self) {
        self.new_leader_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetGroupLeader {
        static instance: CMsgDOTASetGroupLeader = CMsgDOTASetGroupLeader {
            new_leader_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTASetGroupLeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTASetGroupLeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTASetGroupLeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASetGroupLeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTACancelGroupInvites)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACancelGroupInvites {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTACancelGroupInvites.invited_steamids)
    pub invited_steamids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACancelGroupInvites.invited_groupids)
    pub invited_groupids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTACancelGroupInvites.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACancelGroupInvites {
    fn default() -> &'a CMsgDOTACancelGroupInvites {
        <CMsgDOTACancelGroupInvites as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACancelGroupInvites {
    pub fn new() -> CMsgDOTACancelGroupInvites {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invited_steamids",
            |m: &CMsgDOTACancelGroupInvites| { &m.invited_steamids },
            |m: &mut CMsgDOTACancelGroupInvites| { &mut m.invited_steamids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invited_groupids",
            |m: &CMsgDOTACancelGroupInvites| { &m.invited_groupids },
            |m: &mut CMsgDOTACancelGroupInvites| { &mut m.invited_groupids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTACancelGroupInvites>(
            "CMsgDOTACancelGroupInvites",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTACancelGroupInvites {
    const NAME: &'static str = "CMsgDOTACancelGroupInvites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.invited_steamids)?;
                },
                9 => {
                    self.invited_steamids.push(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.invited_groupids)?;
                },
                17 => {
                    self.invited_groupids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.invited_steamids.len() as u64;
        my_size += 9 * self.invited_groupids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.invited_steamids {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.invited_groupids {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACancelGroupInvites {
        CMsgDOTACancelGroupInvites::new()
    }

    fn clear(&mut self) {
        self.invited_steamids.clear();
        self.invited_groupids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACancelGroupInvites {
        static instance: CMsgDOTACancelGroupInvites = CMsgDOTACancelGroupInvites {
            invited_steamids: ::std::vec::Vec::new(),
            invited_groupids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTACancelGroupInvites {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTACancelGroupInvites").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTACancelGroupInvites {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACancelGroupInvites {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTASetGroupOpenStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetGroupOpenStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTASetGroupOpenStatus.open)
    pub open: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTASetGroupOpenStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetGroupOpenStatus {
    fn default() -> &'a CMsgDOTASetGroupOpenStatus {
        <CMsgDOTASetGroupOpenStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetGroupOpenStatus {
    pub fn new() -> CMsgDOTASetGroupOpenStatus {
        ::std::default::Default::default()
    }

    // optional bool open = 1;

    pub fn open(&self) -> bool {
        self.open.unwrap_or(false)
    }

    pub fn clear_open(&mut self) {
        self.open = ::std::option::Option::None;
    }

    pub fn has_open(&self) -> bool {
        self.open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: bool) {
        self.open = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "open",
            |m: &CMsgDOTASetGroupOpenStatus| { &m.open },
            |m: &mut CMsgDOTASetGroupOpenStatus| { &mut m.open },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTASetGroupOpenStatus>(
            "CMsgDOTASetGroupOpenStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTASetGroupOpenStatus {
    const NAME: &'static str = "CMsgDOTASetGroupOpenStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.open = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.open {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.open {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetGroupOpenStatus {
        CMsgDOTASetGroupOpenStatus::new()
    }

    fn clear(&mut self) {
        self.open = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetGroupOpenStatus {
        static instance: CMsgDOTASetGroupOpenStatus = CMsgDOTASetGroupOpenStatus {
            open: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTASetGroupOpenStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTASetGroupOpenStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTASetGroupOpenStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASetGroupOpenStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAGroupMergeInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGroupMergeInvite {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAGroupMergeInvite.other_group_id)
    pub other_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAGroupMergeInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGroupMergeInvite {
    fn default() -> &'a CMsgDOTAGroupMergeInvite {
        <CMsgDOTAGroupMergeInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGroupMergeInvite {
    pub fn new() -> CMsgDOTAGroupMergeInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 other_group_id = 1;

    pub fn other_group_id(&self) -> u64 {
        self.other_group_id.unwrap_or(0)
    }

    pub fn clear_other_group_id(&mut self) {
        self.other_group_id = ::std::option::Option::None;
    }

    pub fn has_other_group_id(&self) -> bool {
        self.other_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_group_id(&mut self, v: u64) {
        self.other_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_group_id",
            |m: &CMsgDOTAGroupMergeInvite| { &m.other_group_id },
            |m: &mut CMsgDOTAGroupMergeInvite| { &mut m.other_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAGroupMergeInvite>(
            "CMsgDOTAGroupMergeInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAGroupMergeInvite {
    const NAME: &'static str = "CMsgDOTAGroupMergeInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.other_group_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_group_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.other_group_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGroupMergeInvite {
        CMsgDOTAGroupMergeInvite::new()
    }

    fn clear(&mut self) {
        self.other_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGroupMergeInvite {
        static instance: CMsgDOTAGroupMergeInvite = CMsgDOTAGroupMergeInvite {
            other_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAGroupMergeInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAGroupMergeInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAGroupMergeInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGroupMergeInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAGroupMergeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGroupMergeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAGroupMergeResponse.initiator_group_id)
    pub initiator_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAGroupMergeResponse.accept)
    pub accept: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAGroupMergeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGroupMergeResponse {
    fn default() -> &'a CMsgDOTAGroupMergeResponse {
        <CMsgDOTAGroupMergeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGroupMergeResponse {
    pub fn new() -> CMsgDOTAGroupMergeResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 initiator_group_id = 1;

    pub fn initiator_group_id(&self) -> u64 {
        self.initiator_group_id.unwrap_or(0)
    }

    pub fn clear_initiator_group_id(&mut self) {
        self.initiator_group_id = ::std::option::Option::None;
    }

    pub fn has_initiator_group_id(&self) -> bool {
        self.initiator_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_group_id(&mut self, v: u64) {
        self.initiator_group_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;

    pub fn accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }

    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator_group_id",
            |m: &CMsgDOTAGroupMergeResponse| { &m.initiator_group_id },
            |m: &mut CMsgDOTAGroupMergeResponse| { &mut m.initiator_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accept",
            |m: &CMsgDOTAGroupMergeResponse| { &m.accept },
            |m: &mut CMsgDOTAGroupMergeResponse| { &mut m.accept },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAGroupMergeResponse>(
            "CMsgDOTAGroupMergeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAGroupMergeResponse {
    const NAME: &'static str = "CMsgDOTAGroupMergeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.initiator_group_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.accept = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator_group_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accept {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.initiator_group_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGroupMergeResponse {
        CMsgDOTAGroupMergeResponse::new()
    }

    fn clear(&mut self) {
        self.initiator_group_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGroupMergeResponse {
        static instance: CMsgDOTAGroupMergeResponse = CMsgDOTAGroupMergeResponse {
            initiator_group_id: ::std::option::Option::None,
            accept: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAGroupMergeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAGroupMergeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAGroupMergeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGroupMergeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAGroupMergeReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGroupMergeReply {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAGroupMergeReply.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_client_enums::EDOTAGroupMergeResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAGroupMergeReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGroupMergeReply {
    fn default() -> &'a CMsgDOTAGroupMergeReply {
        <CMsgDOTAGroupMergeReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGroupMergeReply {
    pub fn new() -> CMsgDOTAGroupMergeReply {
        ::std::default::Default::default()
    }

    // optional .dota.EDOTAGroupMergeResult result = 1;

    pub fn result(&self) -> super::dota_client_enums::EDOTAGroupMergeResult {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_client_enums::EDOTAGroupMergeResult::k_EDOTAGroupMergeResult_OK),
            None => super::dota_client_enums::EDOTAGroupMergeResult::k_EDOTAGroupMergeResult_OK,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_client_enums::EDOTAGroupMergeResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgDOTAGroupMergeReply| { &m.result },
            |m: &mut CMsgDOTAGroupMergeReply| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAGroupMergeReply>(
            "CMsgDOTAGroupMergeReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAGroupMergeReply {
    const NAME: &'static str = "CMsgDOTAGroupMergeReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGroupMergeReply {
        CMsgDOTAGroupMergeReply::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGroupMergeReply {
        static instance: CMsgDOTAGroupMergeReply = CMsgDOTAGroupMergeReply {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAGroupMergeReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAGroupMergeReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAGroupMergeReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGroupMergeReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSpectatorLobbyGameDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpectatorLobbyGameDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.stream_url)
    pub stream_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.stream_name)
    pub stream_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.series_game)
    pub series_game: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.radiant_team)
    pub radiant_team: ::protobuf::MessageField<cmsg_spectator_lobby_game_details::Team>,
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.dire_team)
    pub dire_team: ::protobuf::MessageField<cmsg_spectator_lobby_game_details::Team>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSpectatorLobbyGameDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpectatorLobbyGameDetails {
    fn default() -> &'a CMsgSpectatorLobbyGameDetails {
        <CMsgSpectatorLobbyGameDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSpectatorLobbyGameDetails {
    pub fn new() -> CMsgSpectatorLobbyGameDetails {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_steam_id = 3;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional string stream_url = 4;

    pub fn stream_url(&self) -> &str {
        match self.stream_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stream_url(&mut self) {
        self.stream_url = ::std::option::Option::None;
    }

    pub fn has_stream_url(&self) -> bool {
        self.stream_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_url(&mut self, v: ::std::string::String) {
        self.stream_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_url(&mut self) -> &mut ::std::string::String {
        if self.stream_url.is_none() {
            self.stream_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stream_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_url(&mut self) -> ::std::string::String {
        self.stream_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stream_name = 5;

    pub fn stream_name(&self) -> &str {
        match self.stream_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stream_name(&mut self) {
        self.stream_name = ::std::option::Option::None;
    }

    pub fn has_stream_name(&self) -> bool {
        self.stream_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_name(&mut self, v: ::std::string::String) {
        self.stream_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_name(&mut self) -> &mut ::std::string::String {
        if self.stream_name.is_none() {
            self.stream_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stream_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_name(&mut self) -> ::std::string::String {
        self.stream_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 league_id = 6;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 7;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 series_game = 8;

    pub fn series_game(&self) -> u32 {
        self.series_game.unwrap_or(0)
    }

    pub fn clear_series_game(&mut self) {
        self.series_game = ::std::option::Option::None;
    }

    pub fn has_series_game(&self) -> bool {
        self.series_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_game(&mut self, v: u32) {
        self.series_game = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.language },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.match_id },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_steam_id",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.server_steam_id },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_url",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.stream_url },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.stream_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_name",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.stream_name },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.stream_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.league_id },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_type",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.series_type },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.series_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_game",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.series_game },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.series_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_spectator_lobby_game_details::Team>(
            "radiant_team",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.radiant_team },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.radiant_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_spectator_lobby_game_details::Team>(
            "dire_team",
            |m: &CMsgSpectatorLobbyGameDetails| { &m.dire_team },
            |m: &mut CMsgSpectatorLobbyGameDetails| { &mut m.dire_team },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSpectatorLobbyGameDetails>(
            "CMsgSpectatorLobbyGameDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSpectatorLobbyGameDetails {
    const NAME: &'static str = "CMsgSpectatorLobbyGameDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.stream_url = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.stream_name = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.series_game = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_team)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_team)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stream_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.stream_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.series_game {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.radiant_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dire_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.stream_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.stream_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.series_game {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.radiant_team.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.dire_team.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpectatorLobbyGameDetails {
        CMsgSpectatorLobbyGameDetails::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.stream_url = ::std::option::Option::None;
        self.stream_name = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.series_game = ::std::option::Option::None;
        self.radiant_team.clear();
        self.dire_team.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpectatorLobbyGameDetails {
        static instance: CMsgSpectatorLobbyGameDetails = CMsgSpectatorLobbyGameDetails {
            language: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            server_steam_id: ::std::option::Option::None,
            stream_url: ::std::option::Option::None,
            stream_name: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            series_game: ::std::option::Option::None,
            radiant_team: ::protobuf::MessageField::none(),
            dire_team: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSpectatorLobbyGameDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSpectatorLobbyGameDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSpectatorLobbyGameDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSpectatorLobbyGameDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSpectatorLobbyGameDetails`
pub mod cmsg_spectator_lobby_game_details {
    // @@protoc_insertion_point(message:dota.CMsgSpectatorLobbyGameDetails.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.Team.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyGameDetails.Team.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSpectatorLobbyGameDetails.Team.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 2;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 team_logo = 3;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Team| { &m.team_id },
                |m: &mut Team| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &Team| { &m.team_name },
                |m: &mut Team| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo",
                |m: &Team| { &m.team_logo },
                |m: &mut Team| { &mut m.team_logo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Team>(
                "CMsgSpectatorLobbyGameDetails.Team",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    25 => {
                        self.team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Team {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSpectatorLobbyGameDetails.Team").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Team {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Team {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSetSpectatorLobbyDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetSpectatorLobbyDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSetSpectatorLobbyDetails.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSetSpectatorLobbyDetails.lobby_name)
    pub lobby_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgSetSpectatorLobbyDetails.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgSetSpectatorLobbyDetails.game_details)
    pub game_details: ::protobuf::MessageField<CMsgSpectatorLobbyGameDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSetSpectatorLobbyDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetSpectatorLobbyDetails {
    fn default() -> &'a CMsgSetSpectatorLobbyDetails {
        <CMsgSetSpectatorLobbyDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetSpectatorLobbyDetails {
    pub fn new() -> CMsgSetSpectatorLobbyDetails {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional string lobby_name = 2;

    pub fn lobby_name(&self) -> &str {
        match self.lobby_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lobby_name(&mut self) {
        self.lobby_name = ::std::option::Option::None;
    }

    pub fn has_lobby_name(&self) -> bool {
        self.lobby_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_name(&mut self, v: ::std::string::String) {
        self.lobby_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_name(&mut self) -> &mut ::std::string::String {
        if self.lobby_name.is_none() {
            self.lobby_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lobby_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_name(&mut self) -> ::std::string::String {
        self.lobby_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pass_key = 3;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgSetSpectatorLobbyDetails| { &m.lobby_id },
            |m: &mut CMsgSetSpectatorLobbyDetails| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_name",
            |m: &CMsgSetSpectatorLobbyDetails| { &m.lobby_name },
            |m: &mut CMsgSetSpectatorLobbyDetails| { &mut m.lobby_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pass_key",
            |m: &CMsgSetSpectatorLobbyDetails| { &m.pass_key },
            |m: &mut CMsgSetSpectatorLobbyDetails| { &mut m.pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSpectatorLobbyGameDetails>(
            "game_details",
            |m: &CMsgSetSpectatorLobbyDetails| { &m.game_details },
            |m: &mut CMsgSetSpectatorLobbyDetails| { &mut m.game_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetSpectatorLobbyDetails>(
            "CMsgSetSpectatorLobbyDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetSpectatorLobbyDetails {
    const NAME: &'static str = "CMsgSetSpectatorLobbyDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.lobby_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_details)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.game_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.game_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetSpectatorLobbyDetails {
        CMsgSetSpectatorLobbyDetails::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.lobby_name = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.game_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetSpectatorLobbyDetails {
        static instance: CMsgSetSpectatorLobbyDetails = CMsgSetSpectatorLobbyDetails {
            lobby_id: ::std::option::Option::None,
            lobby_name: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            game_details: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetSpectatorLobbyDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetSpectatorLobbyDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetSpectatorLobbyDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetSpectatorLobbyDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCreateSpectatorLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCreateSpectatorLobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCreateSpectatorLobby.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCreateSpectatorLobby.details)
    pub details: ::protobuf::MessageField<CMsgSetSpectatorLobbyDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCreateSpectatorLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCreateSpectatorLobby {
    fn default() -> &'a CMsgCreateSpectatorLobby {
        <CMsgCreateSpectatorLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCreateSpectatorLobby {
    pub fn new() -> CMsgCreateSpectatorLobby {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgCreateSpectatorLobby| { &m.client_version },
            |m: &mut CMsgCreateSpectatorLobby| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSetSpectatorLobbyDetails>(
            "details",
            |m: &CMsgCreateSpectatorLobby| { &m.details },
            |m: &mut CMsgCreateSpectatorLobby| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCreateSpectatorLobby>(
            "CMsgCreateSpectatorLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCreateSpectatorLobby {
    const NAME: &'static str = "CMsgCreateSpectatorLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.details)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCreateSpectatorLobby {
        CMsgCreateSpectatorLobby::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCreateSpectatorLobby {
        static instance: CMsgCreateSpectatorLobby = CMsgCreateSpectatorLobby {
            client_version: ::std::option::Option::None,
            details: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCreateSpectatorLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCreateSpectatorLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCreateSpectatorLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCreateSpectatorLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSpectatorLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpectatorLobbyList {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSpectatorLobbyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpectatorLobbyList {
    fn default() -> &'a CMsgSpectatorLobbyList {
        <CMsgSpectatorLobbyList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSpectatorLobbyList {
    pub fn new() -> CMsgSpectatorLobbyList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSpectatorLobbyList>(
            "CMsgSpectatorLobbyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSpectatorLobbyList {
    const NAME: &'static str = "CMsgSpectatorLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpectatorLobbyList {
        CMsgSpectatorLobbyList::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpectatorLobbyList {
        static instance: CMsgSpectatorLobbyList = CMsgSpectatorLobbyList {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSpectatorLobbyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSpectatorLobbyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSpectatorLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSpectatorLobbyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSpectatorLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpectatorLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<cmsg_spectator_lobby_list_response::SpectatorLobby>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSpectatorLobbyListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpectatorLobbyListResponse {
    fn default() -> &'a CMsgSpectatorLobbyListResponse {
        <CMsgSpectatorLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSpectatorLobbyListResponse {
    pub fn new() -> CMsgSpectatorLobbyListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobbies",
            |m: &CMsgSpectatorLobbyListResponse| { &m.lobbies },
            |m: &mut CMsgSpectatorLobbyListResponse| { &mut m.lobbies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSpectatorLobbyListResponse>(
            "CMsgSpectatorLobbyListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSpectatorLobbyListResponse {
    const NAME: &'static str = "CMsgSpectatorLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpectatorLobbyListResponse {
        CMsgSpectatorLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpectatorLobbyListResponse {
        static instance: CMsgSpectatorLobbyListResponse = CMsgSpectatorLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSpectatorLobbyListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSpectatorLobbyListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSpectatorLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSpectatorLobbyListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSpectatorLobbyListResponse`
pub mod cmsg_spectator_lobby_list_response {
    // @@protoc_insertion_point(message:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SpectatorLobby {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.lobby_id)
        pub lobby_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
        pub game_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.requires_pass_key)
        pub requires_pass_key: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.leader_account_id)
        pub leader_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.member_count)
        pub member_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_details)
        pub game_details: ::protobuf::MessageField<super::CMsgSpectatorLobbyGameDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpectatorLobby {
        fn default() -> &'a SpectatorLobby {
            <SpectatorLobby as ::protobuf::Message>::default_instance()
        }
    }

    impl SpectatorLobby {
        pub fn new() -> SpectatorLobby {
            ::std::default::Default::default()
        }

        // optional uint64 lobby_id = 1;

        pub fn lobby_id(&self) -> u64 {
            self.lobby_id.unwrap_or(0)
        }

        pub fn clear_lobby_id(&mut self) {
            self.lobby_id = ::std::option::Option::None;
        }

        pub fn has_lobby_id(&self) -> bool {
            self.lobby_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_id(&mut self, v: u64) {
            self.lobby_id = ::std::option::Option::Some(v);
        }

        // optional string game_name = 2;

        pub fn game_name(&self) -> &str {
            match self.game_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_name(&mut self) {
            self.game_name = ::std::option::Option::None;
        }

        pub fn has_game_name(&self) -> bool {
            self.game_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_name(&mut self, v: ::std::string::String) {
            self.game_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
            if self.game_name.is_none() {
                self.game_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_name(&mut self) -> ::std::string::String {
            self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool requires_pass_key = 3;

        pub fn requires_pass_key(&self) -> bool {
            self.requires_pass_key.unwrap_or(false)
        }

        pub fn clear_requires_pass_key(&mut self) {
            self.requires_pass_key = ::std::option::Option::None;
        }

        pub fn has_requires_pass_key(&self) -> bool {
            self.requires_pass_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_requires_pass_key(&mut self, v: bool) {
            self.requires_pass_key = ::std::option::Option::Some(v);
        }

        // optional uint32 leader_account_id = 4;

        pub fn leader_account_id(&self) -> u32 {
            self.leader_account_id.unwrap_or(0)
        }

        pub fn clear_leader_account_id(&mut self) {
            self.leader_account_id = ::std::option::Option::None;
        }

        pub fn has_leader_account_id(&self) -> bool {
            self.leader_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leader_account_id(&mut self, v: u32) {
            self.leader_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 member_count = 5;

        pub fn member_count(&self) -> u32 {
            self.member_count.unwrap_or(0)
        }

        pub fn clear_member_count(&mut self) {
            self.member_count = ::std::option::Option::None;
        }

        pub fn has_member_count(&self) -> bool {
            self.member_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_count(&mut self, v: u32) {
            self.member_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_id",
                |m: &SpectatorLobby| { &m.lobby_id },
                |m: &mut SpectatorLobby| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_name",
                |m: &SpectatorLobby| { &m.game_name },
                |m: &mut SpectatorLobby| { &mut m.game_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "requires_pass_key",
                |m: &SpectatorLobby| { &m.requires_pass_key },
                |m: &mut SpectatorLobby| { &mut m.requires_pass_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "leader_account_id",
                |m: &SpectatorLobby| { &m.leader_account_id },
                |m: &mut SpectatorLobby| { &mut m.leader_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "member_count",
                |m: &SpectatorLobby| { &m.member_count },
                |m: &mut SpectatorLobby| { &mut m.member_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgSpectatorLobbyGameDetails>(
                "game_details",
                |m: &SpectatorLobby| { &m.game_details },
                |m: &mut SpectatorLobby| { &mut m.game_details },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpectatorLobby>(
                "CMsgSpectatorLobbyListResponse.SpectatorLobby",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SpectatorLobby {
        const NAME: &'static str = "SpectatorLobby";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.game_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.requires_pass_key = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.leader_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_details)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.lobby_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.requires_pass_key {
                my_size += 1 + 1;
            }
            if let Some(v) = self.leader_account_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.member_count {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.game_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.lobby_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.requires_pass_key {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.leader_account_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.member_count {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.game_details.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpectatorLobby {
            SpectatorLobby::new()
        }

        fn clear(&mut self) {
            self.lobby_id = ::std::option::Option::None;
            self.game_name = ::std::option::Option::None;
            self.requires_pass_key = ::std::option::Option::None;
            self.leader_account_id = ::std::option::Option::None;
            self.member_count = ::std::option::Option::None;
            self.game_details.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpectatorLobby {
            static instance: SpectatorLobby = SpectatorLobby {
                lobby_id: ::std::option::Option::None,
                game_name: ::std::option::Option::None,
                requires_pass_key: ::std::option::Option::None,
                leader_account_id: ::std::option::Option::None,
                member_count: ::std::option::Option::None,
                game_details: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SpectatorLobby {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSpectatorLobbyListResponse.SpectatorLobby").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SpectatorLobby {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SpectatorLobby {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestSteamDatagramTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestSteamDatagramTicket {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestSteamDatagramTicket.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestSteamDatagramTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestSteamDatagramTicket {
    fn default() -> &'a CMsgClientToGCRequestSteamDatagramTicket {
        <CMsgClientToGCRequestSteamDatagramTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestSteamDatagramTicket {
    pub fn new() -> CMsgClientToGCRequestSteamDatagramTicket {
        ::std::default::Default::default()
    }

    // optional fixed64 server_steam_id = 1;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_steam_id",
            |m: &CMsgClientToGCRequestSteamDatagramTicket| { &m.server_steam_id },
            |m: &mut CMsgClientToGCRequestSteamDatagramTicket| { &mut m.server_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestSteamDatagramTicket>(
            "CMsgClientToGCRequestSteamDatagramTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestSteamDatagramTicket {
    const NAME: &'static str = "CMsgClientToGCRequestSteamDatagramTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestSteamDatagramTicket {
        CMsgClientToGCRequestSteamDatagramTicket::new()
    }

    fn clear(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestSteamDatagramTicket {
        static instance: CMsgClientToGCRequestSteamDatagramTicket = CMsgClientToGCRequestSteamDatagramTicket {
            server_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestSteamDatagramTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestSteamDatagramTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestSteamDatagramTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestSteamDatagramTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestSteamDatagramTicketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestSteamDatagramTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
    pub serialized_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestSteamDatagramTicketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestSteamDatagramTicketResponse {
    fn default() -> &'a CMsgClientToGCRequestSteamDatagramTicketResponse {
        <CMsgClientToGCRequestSteamDatagramTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestSteamDatagramTicketResponse {
    pub fn new() -> CMsgClientToGCRequestSteamDatagramTicketResponse {
        ::std::default::Default::default()
    }

    // optional bytes serialized_ticket = 1;

    pub fn serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_ticket",
            |m: &CMsgClientToGCRequestSteamDatagramTicketResponse| { &m.serialized_ticket },
            |m: &mut CMsgClientToGCRequestSteamDatagramTicketResponse| { &mut m.serialized_ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgClientToGCRequestSteamDatagramTicketResponse| { &m.message },
            |m: &mut CMsgClientToGCRequestSteamDatagramTicketResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestSteamDatagramTicketResponse>(
            "CMsgClientToGCRequestSteamDatagramTicketResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestSteamDatagramTicketResponse {
    const NAME: &'static str = "CMsgClientToGCRequestSteamDatagramTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serialized_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serialized_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serialized_ticket.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestSteamDatagramTicketResponse {
        CMsgClientToGCRequestSteamDatagramTicketResponse::new()
    }

    fn clear(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestSteamDatagramTicketResponse {
        static instance: CMsgClientToGCRequestSteamDatagramTicketResponse = CMsgClientToGCRequestSteamDatagramTicketResponse {
            serialized_ticket: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestSteamDatagramTicketResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestSteamDatagramTicketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestSteamDatagramTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestSteamDatagramTicketResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientSteamDatagramTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientSteamDatagramTicket {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_time_expiry)
    pub legacy_time_expiry: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_authorized_steam_id)
    pub legacy_authorized_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_authorized_public_ip)
    pub legacy_authorized_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_gameserver_steam_id)
    pub legacy_gameserver_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_gameserver_net_id)
    pub legacy_gameserver_net_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
    pub legacy_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_app_id)
    pub legacy_app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
    pub legacy_extra_fields: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
    pub serialized_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientSteamDatagramTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientSteamDatagramTicket {
    fn default() -> &'a CMsgGCToClientSteamDatagramTicket {
        <CMsgGCToClientSteamDatagramTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientSteamDatagramTicket {
    pub fn new() -> CMsgGCToClientSteamDatagramTicket {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_time_expiry = 1;

    pub fn legacy_time_expiry(&self) -> u32 {
        self.legacy_time_expiry.unwrap_or(0)
    }

    pub fn clear_legacy_time_expiry(&mut self) {
        self.legacy_time_expiry = ::std::option::Option::None;
    }

    pub fn has_legacy_time_expiry(&self) -> bool {
        self.legacy_time_expiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_time_expiry(&mut self, v: u32) {
        self.legacy_time_expiry = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_authorized_steam_id = 2;

    pub fn legacy_authorized_steam_id(&self) -> u64 {
        self.legacy_authorized_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_authorized_steam_id(&mut self) {
        self.legacy_authorized_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_authorized_steam_id(&self) -> bool {
        self.legacy_authorized_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_authorized_steam_id(&mut self, v: u64) {
        self.legacy_authorized_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_authorized_public_ip = 3;

    pub fn legacy_authorized_public_ip(&self) -> u32 {
        self.legacy_authorized_public_ip.unwrap_or(0)
    }

    pub fn clear_legacy_authorized_public_ip(&mut self) {
        self.legacy_authorized_public_ip = ::std::option::Option::None;
    }

    pub fn has_legacy_authorized_public_ip(&self) -> bool {
        self.legacy_authorized_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_authorized_public_ip(&mut self, v: u32) {
        self.legacy_authorized_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_gameserver_steam_id = 4;

    pub fn legacy_gameserver_steam_id(&self) -> u64 {
        self.legacy_gameserver_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_gameserver_steam_id(&mut self) {
        self.legacy_gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_steam_id(&self) -> bool {
        self.legacy_gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_steam_id(&mut self, v: u64) {
        self.legacy_gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_gameserver_net_id = 5;

    pub fn legacy_gameserver_net_id(&self) -> u64 {
        self.legacy_gameserver_net_id.unwrap_or(0)
    }

    pub fn clear_legacy_gameserver_net_id(&mut self) {
        self.legacy_gameserver_net_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_net_id(&self) -> bool {
        self.legacy_gameserver_net_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_net_id(&mut self, v: u64) {
        self.legacy_gameserver_net_id = ::std::option::Option::Some(v);
    }

    // optional bytes legacy_signature = 6;

    pub fn legacy_signature(&self) -> &[u8] {
        match self.legacy_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_legacy_signature(&mut self) {
        self.legacy_signature = ::std::option::Option::None;
    }

    pub fn has_legacy_signature(&self) -> bool {
        self.legacy_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacy_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacy_signature.is_none() {
            self.legacy_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.legacy_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.legacy_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 legacy_app_id = 7;

    pub fn legacy_app_id(&self) -> u32 {
        self.legacy_app_id.unwrap_or(0)
    }

    pub fn clear_legacy_app_id(&mut self) {
        self.legacy_app_id = ::std::option::Option::None;
    }

    pub fn has_legacy_app_id(&self) -> bool {
        self.legacy_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_app_id(&mut self, v: u32) {
        self.legacy_app_id = ::std::option::Option::Some(v);
    }

    // optional bytes serialized_ticket = 16;

    pub fn serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_time_expiry",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_time_expiry },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_time_expiry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_authorized_steam_id",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_authorized_steam_id },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_authorized_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_authorized_public_ip",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_authorized_public_ip },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_authorized_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_gameserver_steam_id",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_gameserver_steam_id },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_gameserver_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_gameserver_net_id",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_gameserver_net_id },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_gameserver_net_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_signature",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_signature },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_app_id",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_app_id },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_extra_fields",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.legacy_extra_fields },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.legacy_extra_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_ticket",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.serialized_ticket },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.serialized_ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientSteamDatagramTicket>(
            "CMsgGCToClientSteamDatagramTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientSteamDatagramTicket {
    const NAME: &'static str = "CMsgGCToClientSteamDatagramTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.legacy_time_expiry = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.legacy_authorized_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.legacy_authorized_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.legacy_gameserver_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.legacy_gameserver_net_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.legacy_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.legacy_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.legacy_extra_fields.push(is.read_bytes()?);
                },
                130 => {
                    self.serialized_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_time_expiry {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_authorized_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_authorized_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_gameserver_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_gameserver_net_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.legacy_app_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        for value in &self.legacy_extra_fields {
            my_size += ::protobuf::rt::bytes_size(8, &value);
        };
        if let Some(v) = self.serialized_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.legacy_time_expiry {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.legacy_authorized_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.legacy_authorized_public_ip {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_gameserver_steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.legacy_gameserver_net_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.legacy_signature.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.legacy_app_id {
            os.write_uint32(7, v)?;
        }
        for v in &self.legacy_extra_fields {
            os.write_bytes(8, &v)?;
        };
        if let Some(v) = self.serialized_ticket.as_ref() {
            os.write_bytes(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientSteamDatagramTicket {
        CMsgGCToClientSteamDatagramTicket::new()
    }

    fn clear(&mut self) {
        self.legacy_time_expiry = ::std::option::Option::None;
        self.legacy_authorized_steam_id = ::std::option::Option::None;
        self.legacy_authorized_public_ip = ::std::option::Option::None;
        self.legacy_gameserver_steam_id = ::std::option::Option::None;
        self.legacy_gameserver_net_id = ::std::option::Option::None;
        self.legacy_signature = ::std::option::Option::None;
        self.legacy_app_id = ::std::option::Option::None;
        self.legacy_extra_fields.clear();
        self.serialized_ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientSteamDatagramTicket {
        static instance: CMsgGCToClientSteamDatagramTicket = CMsgGCToClientSteamDatagramTicket {
            legacy_time_expiry: ::std::option::Option::None,
            legacy_authorized_steam_id: ::std::option::Option::None,
            legacy_authorized_public_ip: ::std::option::Option::None,
            legacy_gameserver_steam_id: ::std::option::Option::None,
            legacy_gameserver_net_id: ::std::option::Option::None,
            legacy_signature: ::std::option::Option::None,
            legacy_app_id: ::std::option::Option::None,
            legacy_extra_fields: ::std::vec::Vec::new(),
            serialized_ticket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientSteamDatagramTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientSteamDatagramTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientSteamDatagramTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSteamDatagramTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientRequestLaneSelection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestLaneSelection {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientRequestLaneSelection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestLaneSelection {
    fn default() -> &'a CMsgGCToClientRequestLaneSelection {
        <CMsgGCToClientRequestLaneSelection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestLaneSelection {
    pub fn new() -> CMsgGCToClientRequestLaneSelection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientRequestLaneSelection>(
            "CMsgGCToClientRequestLaneSelection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientRequestLaneSelection {
    const NAME: &'static str = "CMsgGCToClientRequestLaneSelection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestLaneSelection {
        CMsgGCToClientRequestLaneSelection::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestLaneSelection {
        static instance: CMsgGCToClientRequestLaneSelection = CMsgGCToClientRequestLaneSelection {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientRequestLaneSelection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientRequestLaneSelection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientRequestLaneSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientRequestLaneSelection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientRequestLaneSelectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestLaneSelectionResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientRequestLaneSelectionResponse.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientRequestLaneSelectionResponse.high_priority_disabled)
    pub high_priority_disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientRequestLaneSelectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestLaneSelectionResponse {
    fn default() -> &'a CMsgGCToClientRequestLaneSelectionResponse {
        <CMsgGCToClientRequestLaneSelectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestLaneSelectionResponse {
    pub fn new() -> CMsgGCToClientRequestLaneSelectionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 lane_selection_flags = 1;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool high_priority_disabled = 2;

    pub fn high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.unwrap_or(false)
    }

    pub fn clear_high_priority_disabled(&mut self) {
        self.high_priority_disabled = ::std::option::Option::None;
    }

    pub fn has_high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority_disabled(&mut self, v: bool) {
        self.high_priority_disabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane_selection_flags",
            |m: &CMsgGCToClientRequestLaneSelectionResponse| { &m.lane_selection_flags },
            |m: &mut CMsgGCToClientRequestLaneSelectionResponse| { &mut m.lane_selection_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_priority_disabled",
            |m: &CMsgGCToClientRequestLaneSelectionResponse| { &m.high_priority_disabled },
            |m: &mut CMsgGCToClientRequestLaneSelectionResponse| { &mut m.high_priority_disabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientRequestLaneSelectionResponse>(
            "CMsgGCToClientRequestLaneSelectionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientRequestLaneSelectionResponse {
    const NAME: &'static str = "CMsgGCToClientRequestLaneSelectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.high_priority_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lane_selection_flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.high_priority_disabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.high_priority_disabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestLaneSelectionResponse {
        CMsgGCToClientRequestLaneSelectionResponse::new()
    }

    fn clear(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
        self.high_priority_disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestLaneSelectionResponse {
        static instance: CMsgGCToClientRequestLaneSelectionResponse = CMsgGCToClientRequestLaneSelectionResponse {
            lane_selection_flags: ::std::option::Option::None,
            high_priority_disabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientRequestLaneSelectionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientRequestLaneSelectionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientRequestLaneSelectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientRequestLaneSelectionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientRequestMMInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestMMInfo {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientRequestMMInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestMMInfo {
    fn default() -> &'a CMsgGCToClientRequestMMInfo {
        <CMsgGCToClientRequestMMInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestMMInfo {
    pub fn new() -> CMsgGCToClientRequestMMInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientRequestMMInfo>(
            "CMsgGCToClientRequestMMInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientRequestMMInfo {
    const NAME: &'static str = "CMsgGCToClientRequestMMInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestMMInfo {
        CMsgGCToClientRequestMMInfo::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestMMInfo {
        static instance: CMsgGCToClientRequestMMInfo = CMsgGCToClientRequestMMInfo {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientRequestMMInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientRequestMMInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientRequestMMInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientRequestMMInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCMMInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCMMInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCMMInfo.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCMMInfo.high_priority_disabled)
    pub high_priority_disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCMMInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCMMInfo {
    fn default() -> &'a CMsgClientToGCMMInfo {
        <CMsgClientToGCMMInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCMMInfo {
    pub fn new() -> CMsgClientToGCMMInfo {
        ::std::default::Default::default()
    }

    // optional uint32 lane_selection_flags = 1;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool high_priority_disabled = 2;

    pub fn high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.unwrap_or(false)
    }

    pub fn clear_high_priority_disabled(&mut self) {
        self.high_priority_disabled = ::std::option::Option::None;
    }

    pub fn has_high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority_disabled(&mut self, v: bool) {
        self.high_priority_disabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane_selection_flags",
            |m: &CMsgClientToGCMMInfo| { &m.lane_selection_flags },
            |m: &mut CMsgClientToGCMMInfo| { &mut m.lane_selection_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_priority_disabled",
            |m: &CMsgClientToGCMMInfo| { &m.high_priority_disabled },
            |m: &mut CMsgClientToGCMMInfo| { &mut m.high_priority_disabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCMMInfo>(
            "CMsgClientToGCMMInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCMMInfo {
    const NAME: &'static str = "CMsgClientToGCMMInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.high_priority_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lane_selection_flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.high_priority_disabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.high_priority_disabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCMMInfo {
        CMsgClientToGCMMInfo::new()
    }

    fn clear(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
        self.high_priority_disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCMMInfo {
        static instance: CMsgClientToGCMMInfo = CMsgClientToGCMMInfo {
            lane_selection_flags: ::std::option::Option::None,
            high_priority_disabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCMMInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCMMInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCMMInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCMMInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EStartFindingMatchResult)
pub enum EStartFindingMatchResult {
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_Invalid)
    k_EStartFindingMatchResult_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_OK)
    k_EStartFindingMatchResult_OK = 1,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_AlreadySearching)
    k_EStartFindingMatchResult_AlreadySearching = 2,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_FailGeneric)
    k_EStartFindingMatchResult_FailGeneric = 100,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_FailedIgnore)
    k_EStartFindingMatchResult_FailedIgnore = 101,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingDisabled)
    k_EStartFindingMatchResult_MatchmakingDisabled = 102,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_RegionOffline)
    k_EStartFindingMatchResult_RegionOffline = 103,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingCooldown)
    k_EStartFindingMatchResult_MatchmakingCooldown = 104,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_ClientOutOfDate)
    k_EStartFindingMatchResult_ClientOutOfDate = 105,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNoLowPriority)
    k_EStartFindingMatchResult_CompetitiveNoLowPriority = 106,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotUnlocked)
    k_EStartFindingMatchResult_CompetitiveNotUnlocked = 107,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_GameModeNotUnlocked)
    k_EStartFindingMatchResult_GameModeNotUnlocked = 108,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime)
    k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime = 109,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MissingInitialSkill)
    k_EStartFindingMatchResult_MissingInitialSkill = 110,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge)
    k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge = 111,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MemberAlreadyInLobby)
    k_EStartFindingMatchResult_MemberAlreadyInLobby = 112,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MemberNotVACVerified)
    k_EStartFindingMatchResult_MemberNotVACVerified = 113,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyBadPartySize)
    k_EStartFindingMatchResult_WeekendTourneyBadPartySize = 114,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall)
    k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall = 115,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge)
    k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge = 116,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge)
    k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge = 117,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingEventOwnership)
    k_EStartFindingMatchResult_MemberMissingEventOwnership = 118,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyNotUnlocked)
    k_EStartFindingMatchResult_WeekendTourneyNotUnlocked = 119,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyRecentParticipation)
    k_EStartFindingMatchResult_WeekendTourneyRecentParticipation = 120,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber)
    k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber = 121,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_NotMemberOfClan)
    k_EStartFindingMatchResult_NotMemberOfClan = 122,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeBadPartySize)
    k_EStartFindingMatchResult_CoachesChallengeBadPartySize = 123,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet)
    k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet = 124,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_InvalidRoleSelections)
    k_EStartFindingMatchResult_InvalidRoleSelections = 125,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_PhoneNumberDiscrepancy)
    k_EStartFindingMatchResult_PhoneNumberDiscrepancy = 126,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_NoQueuePoints)
    k_EStartFindingMatchResult_NoQueuePoints = 127,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingGauntletFlag)
    k_EStartFindingMatchResult_MemberMissingGauntletFlag = 128,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MemberGauntletTooRecent)
    k_EStartFindingMatchResult_MemberGauntletTooRecent = 129,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_DifficultyNotUnlocked)
    k_EStartFindingMatchResult_DifficultyNotUnlocked = 130,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesNotAllowedInParty)
    k_EStartFindingMatchResult_CoachesNotAllowedInParty = 131,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingBusy)
    k_EStartFindingMatchResult_MatchmakingBusy = 132,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaBanned)
    k_EStartFindingMatchResult_SteamChinaBanned = 133,
    // @@protoc_insertion_point(enum_value:dota.EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaInvalidMixedParty)
    k_EStartFindingMatchResult_SteamChinaInvalidMixedParty = 134,
}

impl ::protobuf::Enum for EStartFindingMatchResult {
    const NAME: &'static str = "EStartFindingMatchResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStartFindingMatchResult> {
        match value {
            0 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid),
            1 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_OK),
            2 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_AlreadySearching),
            100 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailGeneric),
            101 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailedIgnore),
            102 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingDisabled),
            103 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_RegionOffline),
            104 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingCooldown),
            105 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_ClientOutOfDate),
            106 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNoLowPriority),
            107 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotUnlocked),
            108 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_GameModeNotUnlocked),
            109 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime),
            110 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MissingInitialSkill),
            111 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge),
            112 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberAlreadyInLobby),
            113 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberNotVACVerified),
            114 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyBadPartySize),
            115 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall),
            116 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge),
            117 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge),
            118 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingEventOwnership),
            119 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyNotUnlocked),
            120 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyRecentParticipation),
            121 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber),
            122 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NotMemberOfClan),
            123 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeBadPartySize),
            124 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet),
            125 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_InvalidRoleSelections),
            126 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_PhoneNumberDiscrepancy),
            127 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NoQueuePoints),
            128 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingGauntletFlag),
            129 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberGauntletTooRecent),
            130 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_DifficultyNotUnlocked),
            131 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesNotAllowedInParty),
            132 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingBusy),
            133 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaBanned),
            134 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaInvalidMixedParty),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStartFindingMatchResult> {
        match str {
            "k_EStartFindingMatchResult_Invalid" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid),
            "k_EStartFindingMatchResult_OK" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_OK),
            "k_EStartFindingMatchResult_AlreadySearching" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_AlreadySearching),
            "k_EStartFindingMatchResult_FailGeneric" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailGeneric),
            "k_EStartFindingMatchResult_FailedIgnore" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailedIgnore),
            "k_EStartFindingMatchResult_MatchmakingDisabled" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingDisabled),
            "k_EStartFindingMatchResult_RegionOffline" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_RegionOffline),
            "k_EStartFindingMatchResult_MatchmakingCooldown" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingCooldown),
            "k_EStartFindingMatchResult_ClientOutOfDate" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_ClientOutOfDate),
            "k_EStartFindingMatchResult_CompetitiveNoLowPriority" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNoLowPriority),
            "k_EStartFindingMatchResult_CompetitiveNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotUnlocked),
            "k_EStartFindingMatchResult_GameModeNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_GameModeNotUnlocked),
            "k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime),
            "k_EStartFindingMatchResult_MissingInitialSkill" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MissingInitialSkill),
            "k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge),
            "k_EStartFindingMatchResult_MemberAlreadyInLobby" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberAlreadyInLobby),
            "k_EStartFindingMatchResult_MemberNotVACVerified" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberNotVACVerified),
            "k_EStartFindingMatchResult_WeekendTourneyBadPartySize" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyBadPartySize),
            "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall),
            "k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge),
            "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge),
            "k_EStartFindingMatchResult_MemberMissingEventOwnership" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingEventOwnership),
            "k_EStartFindingMatchResult_WeekendTourneyNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyNotUnlocked),
            "k_EStartFindingMatchResult_WeekendTourneyRecentParticipation" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyRecentParticipation),
            "k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber),
            "k_EStartFindingMatchResult_NotMemberOfClan" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NotMemberOfClan),
            "k_EStartFindingMatchResult_CoachesChallengeBadPartySize" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeBadPartySize),
            "k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet),
            "k_EStartFindingMatchResult_InvalidRoleSelections" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_InvalidRoleSelections),
            "k_EStartFindingMatchResult_PhoneNumberDiscrepancy" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_PhoneNumberDiscrepancy),
            "k_EStartFindingMatchResult_NoQueuePoints" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NoQueuePoints),
            "k_EStartFindingMatchResult_MemberMissingGauntletFlag" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingGauntletFlag),
            "k_EStartFindingMatchResult_MemberGauntletTooRecent" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberGauntletTooRecent),
            "k_EStartFindingMatchResult_DifficultyNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_DifficultyNotUnlocked),
            "k_EStartFindingMatchResult_CoachesNotAllowedInParty" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesNotAllowedInParty),
            "k_EStartFindingMatchResult_MatchmakingBusy" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingBusy),
            "k_EStartFindingMatchResult_SteamChinaBanned" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaBanned),
            "k_EStartFindingMatchResult_SteamChinaInvalidMixedParty" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaInvalidMixedParty),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStartFindingMatchResult] = &[
        EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid,
        EStartFindingMatchResult::k_EStartFindingMatchResult_OK,
        EStartFindingMatchResult::k_EStartFindingMatchResult_AlreadySearching,
        EStartFindingMatchResult::k_EStartFindingMatchResult_FailGeneric,
        EStartFindingMatchResult::k_EStartFindingMatchResult_FailedIgnore,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingDisabled,
        EStartFindingMatchResult::k_EStartFindingMatchResult_RegionOffline,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingCooldown,
        EStartFindingMatchResult::k_EStartFindingMatchResult_ClientOutOfDate,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNoLowPriority,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_GameModeNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MissingInitialSkill,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberAlreadyInLobby,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberNotVACVerified,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyBadPartySize,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingEventOwnership,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyRecentParticipation,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber,
        EStartFindingMatchResult::k_EStartFindingMatchResult_NotMemberOfClan,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeBadPartySize,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet,
        EStartFindingMatchResult::k_EStartFindingMatchResult_InvalidRoleSelections,
        EStartFindingMatchResult::k_EStartFindingMatchResult_PhoneNumberDiscrepancy,
        EStartFindingMatchResult::k_EStartFindingMatchResult_NoQueuePoints,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingGauntletFlag,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberGauntletTooRecent,
        EStartFindingMatchResult::k_EStartFindingMatchResult_DifficultyNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesNotAllowedInParty,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingBusy,
        EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaBanned,
        EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaInvalidMixedParty,
    ];
}

impl ::protobuf::EnumFull for EStartFindingMatchResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStartFindingMatchResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid => 0,
            EStartFindingMatchResult::k_EStartFindingMatchResult_OK => 1,
            EStartFindingMatchResult::k_EStartFindingMatchResult_AlreadySearching => 2,
            EStartFindingMatchResult::k_EStartFindingMatchResult_FailGeneric => 3,
            EStartFindingMatchResult::k_EStartFindingMatchResult_FailedIgnore => 4,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingDisabled => 5,
            EStartFindingMatchResult::k_EStartFindingMatchResult_RegionOffline => 6,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingCooldown => 7,
            EStartFindingMatchResult::k_EStartFindingMatchResult_ClientOutOfDate => 8,
            EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNoLowPriority => 9,
            EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotUnlocked => 10,
            EStartFindingMatchResult::k_EStartFindingMatchResult_GameModeNotUnlocked => 11,
            EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime => 12,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MissingInitialSkill => 13,
            EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge => 14,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MemberAlreadyInLobby => 15,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MemberNotVACVerified => 16,
            EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyBadPartySize => 17,
            EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall => 18,
            EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge => 19,
            EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge => 20,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingEventOwnership => 21,
            EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyNotUnlocked => 22,
            EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyRecentParticipation => 23,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber => 24,
            EStartFindingMatchResult::k_EStartFindingMatchResult_NotMemberOfClan => 25,
            EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeBadPartySize => 26,
            EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet => 27,
            EStartFindingMatchResult::k_EStartFindingMatchResult_InvalidRoleSelections => 28,
            EStartFindingMatchResult::k_EStartFindingMatchResult_PhoneNumberDiscrepancy => 29,
            EStartFindingMatchResult::k_EStartFindingMatchResult_NoQueuePoints => 30,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingGauntletFlag => 31,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MemberGauntletTooRecent => 32,
            EStartFindingMatchResult::k_EStartFindingMatchResult_DifficultyNotUnlocked => 33,
            EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesNotAllowedInParty => 34,
            EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingBusy => 35,
            EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaBanned => 36,
            EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaInvalidMixedParty => 37,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStartFindingMatchResult {
    fn default() -> Self {
        EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid
    }
}

impl EStartFindingMatchResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStartFindingMatchResult>("EStartFindingMatchResult")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-dota_gcmessages_client_match_management.proto\x12\x04dota\x1a\x13stea\
    mmessages.proto\x1a\x17dota_shared_enums.proto\x1a\x17dota_client_enums.\
    proto\x1a\x15base_gcmessages.proto\x1a\"dota_gcmessages_common_lobby.pro\
    to\"\xa9\x07\n\x15CMsgStartFindingMatch\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x20\n\x0bmatchgroups\x18\x02\x20\x01(\rR\x0bmatchgroups\
    \x12%\n\x0eclient_version\x18\x03\x20\x01(\rR\rclientVersion\x12\x1d\n\n\
    game_modes\x18\x04\x20\x01(\rR\tgameModes\x12.\n\nmatch_type\x18\x06\x20\
    \x01(\x0e2\x0f.dota.MatchTypeR\tmatchType\x12&\n\x0ematchlanguages\x18\
    \x07\x20\x01(\rR\x0ematchlanguages\x12\x17\n\x07team_id\x18\x08\x20\x01(\
    \rR\x06teamId\x12B\n\x12game_language_enum\x18\n\x20\x01(\x0e2\x14.dota.\
    MatchLanguagesR\x10gameLanguageEnum\x12,\n\x12game_language_name\x18\x0b\
    \x20\x01(\tR\x10gameLanguageName\x125\n\tping_data\x18\x0c\x20\x01(\x0b2\
    \x18.dota.CMsgClientPingDataR\x08pingData\x12.\n\x13region_select_flags\
    \x18\r\x20\x01(\rR\x11regionSelectFlags\x12\x1d\n\nsolo_queue\x18\x0e\
    \x20\x01(\x08R\tsoloQueue\x121\n\x15steam_clan_account_id\x18\x10\x20\
    \x01(\rR\x12steamClanAccountId\x12,\n\x12is_challenge_match\x18\x11\x20\
    \x01(\x08R\x10isChallengeMatch\x120\n\x14lane_selection_flags\x18\x12\
    \x20\x01(\rR\x12laneSelectionFlags\x124\n\x16high_priority_disabled\x18\
    \x13\x20\x01(\x08R\x14highPriorityDisabled\x12B\n\x1ddisable_experimenta\
    l_gameplay\x18\x14\x20\x01(\x08R\x1bdisableExperimentalGameplay\x12=\n\
    \x1bcustom_game_difficulty_mask\x18\x15\x20\x01(\rR\x18customGameDifficu\
    ltyMask\x12.\n\x13bot_difficulty_mask\x18\x16\x20\x01(\rR\x11botDifficul\
    tyMask\x121\n\x15bot_script_index_mask\x18\x17\x20\x01(\rR\x12botScriptI\
    ndexMask\"\xb6\x02\n\x1bCMsgStartFindingMatchResult\x124\n\x16legacy_gen\
    eric_eresult\x18\x01\x20\x01(\rR\x14legacyGenericEresult\x126\n\x06resul\
    t\x18\x02\x20\x01(\x0e2\x1e.dota.EStartFindingMatchResultR\x06result\x12\
    \x1f\n\x0berror_token\x18\x03\x20\x01(\tR\nerrorToken\x12#\n\rdebug_mess\
    age\x18\x04\x20\x01(\tR\x0cdebugMessage\x12:\n\x19responsible_party_memb\
    ers\x18\x05\x20\x03(\x06R\x17responsiblePartyMembers\x12'\n\x0fresult_me\
    tadata\x18\x06\x20\x01(\rR\x0eresultMetadata\"?\n\x14CMsgStopFindingMatc\
    h\x12'\n\x0faccept_cooldown\x18\x01\x20\x01(\x08R\x0eacceptCooldown\"\
    \xef\x01\n\x17CMsgPartyBuilderOptions\x12)\n\x10additional_slots\x18\x01\
    \x20\x01(\rR\x0fadditionalSlots\x12.\n\nmatch_type\x18\x02\x20\x01(\x0e2\
    \x0f.dota.MatchTypeR\tmatchType\x12\x20\n\x0bmatchgroups\x18\x03\x20\x01\
    (\rR\x0bmatchgroups\x12%\n\x0eclient_version\x18\x04\x20\x01(\rR\rclient\
    Version\x120\n\x08language\x18\x05\x20\x01(\x0e2\x14.dota.MatchLanguages\
    R\x08language\"\xa7\x01\n\x0bCMsgReadyUp\x12/\n\x05state\x18\x01\x20\x01\
    (\x0e2\x19.dota.DOTALobbyReadyStateR\x05state\x12\x20\n\x0cready_up_key\
    \x18\x02\x20\x01(\x06R\nreadyUpKey\x12E\n\x0ehardware_specs\x18\x03\x20\
    \x01(\x0b2\x1e.dota.CDOTAClientHardwareSpecsR\rhardwareSpecs\"t\n\x11CMs\
    gReadyUpStatus\x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyId\
    \x12!\n\x0caccepted_ids\x18\x02\x20\x03(\rR\x0bacceptedIds\x12!\n\x0cdec\
    lined_ids\x18\x03\x20\x03(\rR\x0bdeclinedIds\"\x18\n\x16CMsgAbandonCurre\
    ntGame\"E\n\x15CMsgLobbyScenarioSave\x12\x18\n\x07version\x18\x01\x20\
    \x01(\x05R\x07version\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"\
    \xee\x10\n\x1bCMsgPracticeLobbySetDetails\x12\x19\n\x08lobby_id\x18\x01\
    \x20\x01(\x04R\x07lobbyId\x12\x1b\n\tgame_name\x18\x02\x20\x01(\tR\x08ga\
    meName\x12:\n\x0cteam_details\x18\x03\x20\x03(\x0b2\x17.dota.CLobbyTeamD\
    etailsR\x0bteamDetails\x12#\n\rserver_region\x18\x04\x20\x01(\rR\x0cserv\
    erRegion\x12\x1b\n\tgame_mode\x18\x05\x20\x01(\rR\x08gameMode\x12+\n\x07\
    cm_pick\x18\x06\x20\x01(\x0e2\x12.dota.DOTA_CM_PICKR\x06cmPick\x12M\n\
    \x16bot_difficulty_radiant\x18\t\x20\x01(\x0e2\x17.dota.DOTABotDifficult\
    yR\x14botDifficultyRadiant\x12!\n\x0callow_cheats\x18\n\x20\x01(\x08R\
    \x0ballowCheats\x12$\n\x0efill_with_bots\x18\x0b\x20\x01(\x08R\x0cfillWi\
    thBots\x12\x1d\n\nintro_mode\x18\x0c\x20\x01(\x08R\tintroMode\x12)\n\x10\
    allow_spectating\x18\r\x20\x01(\x08R\x0fallowSpectating\x12\x19\n\x08pas\
    s_key\x18\x0f\x20\x01(\tR\x07passKey\x12\x1a\n\x08leagueid\x18\x10\x20\
    \x01(\rR\x08leagueid\x122\n\x15penalty_level_radiant\x18\x11\x20\x01(\rR\
    \x13penaltyLevelRadiant\x12,\n\x12penalty_level_dire\x18\x12\x20\x01(\rR\
    \x10penaltyLevelDire\x12\x20\n\x0cload_game_id\x18\x13\x20\x01(\rR\nload\
    GameId\x12\x1f\n\x0bseries_type\x18\x14\x20\x01(\rR\nseriesType\x12.\n\
    \x13radiant_series_wins\x18\x15\x20\x01(\rR\x11radiantSeriesWins\x12(\n\
    \x10dire_series_wins\x18\x16\x20\x01(\rR\x0edireSeriesWins\x12\x18\n\x07\
    allchat\x18\x17\x20\x01(\x08R\x07allchat\x12:\n\rdota_tv_delay\x18\x18\
    \x20\x01(\x0e2\x16.dota.LobbyDotaTVDelayR\x0bdotaTvDelay\x12\x10\n\x03la\
    n\x18\x19\x20\x01(\x08R\x03lan\x12(\n\x10custom_game_mode\x18\x1a\x20\
    \x01(\tR\x0ecustomGameMode\x12&\n\x0fcustom_map_name\x18\x1b\x20\x01(\tR\
    \rcustomMapName\x12+\n\x11custom_difficulty\x18\x1c\x20\x01(\rR\x10custo\
    mDifficulty\x12$\n\x0ecustom_game_id\x18\x1d\x20\x01(\x04R\x0ccustomGame\
    Id\x12,\n\x12custom_min_players\x18\x1e\x20\x01(\rR\x10customMinPlayers\
    \x12,\n\x12custom_max_players\x18\x1f\x20\x01(\rR\x10customMaxPlayers\
    \x129\n\nvisibility\x18!\x20\x01(\x0e2\x19.dota.DOTALobbyVisibilityR\nvi\
    sibility\x12&\n\x0fcustom_game_crc\x18\"\x20\x01(\x06R\rcustomGameCrc\
    \x122\n\x15custom_game_timestamp\x18%\x20\x01(\x07R\x13customGameTimesta\
    mp\x126\n\x17previous_match_override\x18&\x20\x01(\x04R\x15previousMatch\
    Override\x12@\n\rpause_setting\x18*\x20\x01(\x0e2\x1b.dota.LobbyDotaPaus\
    eSettingR\x0cpauseSetting\x12G\n\x13bot_difficulty_dire\x18+\x20\x01(\
    \x0e2\x17.dota.DOTABotDifficultyR\x11botDifficultyDire\x12\x1f\n\x0bbot_\
    radiant\x18,\x20\x01(\x04R\nbotRadiant\x12\x19\n\x08bot_dire\x18-\x20\
    \x01(\x04R\x07botDire\x12Z\n\x18selection_priority_rules\x18.\x20\x01(\
    \x0e2\x20.dota.DOTASelectionPriorityRulesR\x16selectionPriorityRules\x12\
    2\n\x15custom_game_penalties\x18/\x20\x01(\x08R\x13customGamePenalties\
    \x123\n\x16lan_host_ping_location\x180\x20\x01(\tR\x13lanHostPingLocatio\
    n\x12$\n\x0eleague_node_id\x181\x20\x01(\rR\x0cleagueNodeId\x12,\n\x12re\
    quested_hero_ids\x182\x20\x03(\rR\x10requestedHeroIds\x12@\n\rscenario_s\
    ave\x183\x20\x01(\x0b2\x1b.dota.CMsgLobbyScenarioSaveR\x0cscenarioSave\
    \x12\x82\x01\n\x1eability_draft_specific_details\x184\x20\x01(\x0b2=.dot\
    a.CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetailsR\x1babilityDra\
    ftSpecificDetails\x12&\n\x0fdo_player_draft\x185\x20\x01(\x08R\rdoPlayer\
    Draft\x1aM\n\x1bAbilityDraftSpecificDetails\x12.\n\x13shuffle_draft_orde\
    r\x18\x01\x20\x01(\x08R\x11shuffleDraftOrder\"\xfa\x02\n\x17CMsgPractice\
    LobbyCreate\x12\x1d\n\nsearch_key\x18\x01\x20\x01(\tR\tsearchKey\x12\x19\
    \n\x08pass_key\x18\x05\x20\x01(\tR\x07passKey\x12%\n\x0eclient_version\
    \x18\x06\x20\x01(\rR\rclientVersion\x12F\n\rlobby_details\x18\x07\x20\
    \x01(\x0b2!.dota.CMsgPracticeLobbySetDetailsR\x0clobbyDetails\x12C\n\tsa\
    ve_game\x18\x08\x20\x01(\x0b2&.dota.CMsgPracticeLobbyCreate.SaveGameR\
    \x08saveGame\x1aq\n\x08SaveGame\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12\x18\n\x07version\x18\x02\x20\x01(\x05R\x07version\x12\x19\n\
    \x08steam_id\x18\x03\x20\x01(\x06R\x07steamId\x12\x1c\n\tsignature\x18\
    \x04\x20\x01(\x06R\tsignature\"\x9a\x01\n\x1cCMsgPracticeLobbySetTeamSlo\
    t\x12&\n\x04team\x18\x01\x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\x04team\
    \x12\x12\n\x04slot\x18\x02\x20\x01(\rR\x04slot\x12>\n\x0ebot_difficulty\
    \x18\x03\x20\x01(\x0e2\x17.dota.DOTABotDifficultyR\rbotDifficulty\"C\n\
    \x19CMsgPracticeLobbySetCoach\x12&\n\x04team\x18\x01\x20\x01(\x0e2\x12.d\
    ota.DOTA_GC_TEAMR\x04team\"\xe4\x01\n%CMsgPracticeLobbyJoinBroadcastChan\
    nel\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\x07channel\x123\n\x15prefer\
    red_description\x18\x02\x20\x01(\tR\x14preferredDescription\x124\n\x16pr\
    eferred_country_code\x18\x03\x20\x01(\tR\x14preferredCountryCode\x126\n\
    \x17preferred_language_code\x18\x04\x20\x01(\tR\x15preferredLanguageCode\
    \"B\n&CMsgPracticeLobbyCloseBroadcastChannel\x12\x18\n\x07channel\x18\
    \x01\x20\x01(\rR\x07channel\"8\n6CMsgPracticeLobbyToggleBroadcastChannel\
    CameramanStatus\"6\n\x15CMsgPracticeLobbyKick\x12\x1d\n\naccount_id\x18\
    \x03\x20\x01(\rR\taccountId\">\n\x1dCMsgPracticeLobbyKickFromTeam\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"\x18\n\x16CMsgPractic\
    eLobbyLeave\"@\n\x17CMsgPracticeLobbyLaunch\x12%\n\x0eclient_version\x18\
    \x05\x20\x01(\rR\rclientVersion\"7\n\x1cCMsgApplyTeamToPracticeLobby\x12\
    \x17\n\x07team_id\x18\x01\x20\x01(\rR\x06teamId\"|\n\x15CMsgPracticeLobb\
    yList\x12\x19\n\x08pass_key\x18\x02\x20\x01(\tR\x07passKey\x12\x16\n\x06\
    region\x18\x03\x20\x01(\rR\x06region\x120\n\tgame_mode\x18\x04\x20\x01(\
    \x0e2\x13.dota.DOTA_GameModeR\x08gameMode\"\xfe\x05\n\"CMsgPracticeLobby\
    ListResponseEntry\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12O\n\x07\
    members\x18\x05\x20\x03(\x0b25.dota.CMsgPracticeLobbyListResponseEntry.C\
    LobbyMemberR\x07members\x12*\n\x11requires_pass_key\x18\x06\x20\x01(\x08\
    R\x0frequiresPassKey\x12*\n\x11leader_account_id\x18\x07\x20\x01(\rR\x0f\
    leaderAccountId\x12\x12\n\x04name\x18\n\x20\x01(\tR\x04name\x12(\n\x10cu\
    stom_game_mode\x18\x0b\x20\x01(\tR\x0ecustomGameMode\x120\n\tgame_mode\
    \x18\x0c\x20\x01(\x0e2\x13.dota.DOTA_GameModeR\x08gameMode\x12%\n\x0efri\
    end_present\x18\r\x20\x01(\x08R\rfriendPresent\x12\x18\n\x07players\x18\
    \x0e\x20\x01(\rR\x07players\x12&\n\x0fcustom_map_name\x18\x0f\x20\x01(\t\
    R\rcustomMapName\x12(\n\x10max_player_count\x18\x10\x20\x01(\rR\x0emaxPl\
    ayerCount\x12#\n\rserver_region\x18\x11\x20\x01(\rR\x0cserverRegion\x12\
    \x1b\n\tleague_id\x18\x13\x20\x01(\rR\x08leagueId\x123\n\x16lan_host_pin\
    g_location\x18\x14\x20\x01(\tR\x13lanHostPingLocation\x12(\n\x10min_play\
    er_count\x18\x15\x20\x01(\rR\x0eminPlayerCount\x12+\n\x11penalties_enabl\
    ed\x18\x16\x20\x01(\x08R\x10penaltiesEnabled\x1aN\n\x0cCLobbyMember\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\x0bplayer_na\
    me\x18\x02\x20\x01(\tR\nplayerName\"c\n\x1dCMsgPracticeLobbyListResponse\
    \x12B\n\x07lobbies\x18\x02\x20\x03(\x0b2(.dota.CMsgPracticeLobbyListResp\
    onseEntryR\x07lobbies\"f\n\rCMsgLobbyList\x12#\n\rserver_region\x18\x01\
    \x20\x01(\rR\x0cserverRegion\x120\n\tgame_mode\x18\x02\x20\x01(\x0e2\x13\
    .dota.DOTA_GameModeR\x08gameMode\"[\n\x15CMsgLobbyListResponse\x12B\n\
    \x07lobbies\x18\x01\x20\x03(\x0b2(.dota.CMsgPracticeLobbyListResponseEnt\
    ryR\x07lobbies\"\xd0\x01\n\x15CMsgPracticeLobbyJoin\x12\x19\n\x08lobby_i\
    d\x18\x01\x20\x01(\x04R\x07lobbyId\x12%\n\x0eclient_version\x18\x02\x20\
    \x01(\rR\rclientVersion\x12\x19\n\x08pass_key\x18\x03\x20\x01(\tR\x07pas\
    sKey\x12&\n\x0fcustom_game_crc\x18\x04\x20\x01(\x06R\rcustomGameCrc\x122\
    \n\x15custom_game_timestamp\x18\x05\x20\x01(\x07R\x13customGameTimestamp\
    \"R\n\x1dCMsgPracticeLobbyJoinResponse\x121\n\x06result\x18\x01\x20\x01(\
    \x0e2\x19.dota.DOTAJoinLobbyResultR\x06result\">\n\"CMsgFriendPracticeLo\
    bbyListRequest\x12\x18\n\x07friends\x18\x01\x20\x03(\rR\x07friends\"i\n#\
    CMsgFriendPracticeLobbyListResponse\x12B\n\x07lobbies\x18\x01\x20\x03(\
    \x0b2(.dota.CMsgPracticeLobbyListResponseEntryR\x07lobbies\"I\n\"CMsgJoi\
    nableCustomGameModesRequest\x12#\n\rserver_region\x18\x01\x20\x01(\rR\
    \x0cserverRegion\"\x94\x01\n(CMsgJoinableCustomGameModesResponseEntry\
    \x12$\n\x0ecustom_game_id\x18\x01\x20\x01(\x04R\x0ccustomGameId\x12\x1f\
    \n\x0blobby_count\x18\x02\x20\x01(\rR\nlobbyCount\x12!\n\x0cplayer_count\
    \x18\x03\x20\x01(\rR\x0bplayerCount\"t\n#CMsgJoinableCustomGameModesResp\
    onse\x12M\n\ngame_modes\x18\x01\x20\x03(\x0b2..dota.CMsgJoinableCustomGa\
    meModesResponseEntryR\tgameModes\"m\n\x20CMsgJoinableCustomLobbiesReques\
    t\x12#\n\rserver_region\x18\x01\x20\x01(\rR\x0cserverRegion\x12$\n\x0ecu\
    stom_game_id\x18\x02\x20\x01(\x04R\x0ccustomGameId\"\xa9\x05\n&CMsgJoina\
    bleCustomLobbiesResponseEntry\x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x06\
    R\x07lobbyId\x12$\n\x0ecustom_game_id\x18\x02\x20\x01(\x04R\x0ccustomGam\
    eId\x12\x1d\n\nlobby_name\x18\x03\x20\x01(\tR\tlobbyName\x12!\n\x0cmembe\
    r_count\x18\x04\x20\x01(\rR\x0bmemberCount\x12*\n\x11leader_account_id\
    \x18\x05\x20\x01(\rR\x0fleaderAccountId\x12\x1f\n\x0bleader_name\x18\x06\
    \x20\x01(\tR\nleaderName\x12&\n\x0fcustom_map_name\x18\x07\x20\x01(\tR\r\
    customMapName\x12(\n\x10max_player_count\x18\x08\x20\x01(\rR\x0emaxPlaye\
    rCount\x12#\n\rserver_region\x18\t\x20\x01(\rR\x0cserverRegion\x12\x20\n\
    \x0chas_pass_key\x18\x0b\x20\x01(\x08R\nhasPassKey\x123\n\x16lan_host_pi\
    ng_location\x18\x0c\x20\x01(\tR\x13lanHostPingLocation\x12.\n\x13lobby_c\
    reation_time\x18\r\x20\x01(\rR\x11lobbyCreationTime\x122\n\x15custom_gam\
    e_timestamp\x18\x0e\x20\x01(\rR\x13customGameTimestamp\x12&\n\x0fcustom_\
    game_crc\x18\x0f\x20\x01(\x04R\rcustomGameCrc\x12(\n\x10min_player_count\
    \x18\x10\x20\x01(\rR\x0eminPlayerCount\x12+\n\x11penalties_enabled\x18\
    \x11\x20\x01(\x08R\x10penaltiesEnabled\"k\n!CMsgJoinableCustomLobbiesRes\
    ponse\x12F\n\x07lobbies\x18\x01\x20\x03(\x0b2,.dota.CMsgJoinableCustomLo\
    bbiesResponseEntryR\x07lobbies\"\x98\x04\n\x18CMsgQuickJoinCustomLobby\
    \x120\n\x14legacy_server_region\x18\x01\x20\x01(\rR\x12legacyServerRegio\
    n\x12$\n\x0ecustom_game_id\x18\x02\x20\x01(\x04R\x0ccustomGameId\x12%\n\
    \x0eclient_version\x18\x03\x20\x01(\rR\rclientVersion\x12S\n\x14create_l\
    obby_details\x18\x04\x20\x01(\x0b2!.dota.CMsgPracticeLobbySetDetailsR\
    \x12createLobbyDetails\x12\"\n\rallow_any_map\x18\x05\x20\x01(\x08R\x0ba\
    llowAnyMap\x12_\n\x13legacy_region_pings\x18\x06\x20\x03(\x0b2/.dota.CMs\
    gQuickJoinCustomLobby.LegacyRegionPingR\x11legacyRegionPings\x125\n\tpin\
    g_data\x18\x07\x20\x01(\x0b2\x18.dota.CMsgClientPingDataR\x08pingData\
    \x1al\n\x10LegacyRegionPing\x12#\n\rserver_region\x18\x01\x20\x01(\rR\
    \x0cserverRegion\x12\x12\n\x04ping\x18\x02\x20\x01(\rR\x04ping\x12\x1f\n\
    \x0bregion_code\x18\x03\x20\x01(\x07R\nregionCode\"U\n\x20CMsgQuickJoinC\
    ustomLobbyResponse\x121\n\x06result\x18\x01\x20\x01(\x0e2\x19.dota.DOTAJ\
    oinLobbyResultR\x06result\"\xa8\x02\n\x11CMsgBotGameCreate\x12\x1d\n\nse\
    arch_key\x18\x01\x20\x01(\tR\tsearchKey\x12%\n\x0eclient_version\x18\x02\
    \x20\x01(\rR\rclientVersion\x12F\n\x12difficulty_radiant\x18\x03\x20\x01\
    (\x0e2\x17.dota.DOTABotDifficultyR\x11difficultyRadiant\x12&\n\x04team\
    \x18\x04\x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\x04team\x12\x1b\n\tgame_mo\
    de\x18\x05\x20\x01(\rR\x08gameMode\x12@\n\x0fdifficulty_dire\x18\x06\x20\
    \x01(\x0e2\x17.dota.DOTABotDifficultyR\x0edifficultyDire\">\n\x1bCMsgDOT\
    APartyMemberSetCoach\x12\x1f\n\x0bwants_coach\x18\x01\x20\x01(\x08R\nwan\
    tsCoach\"F\n\x16CMsgDOTASetGroupLeader\x12,\n\x12new_leader_steamid\x18\
    \x01\x20\x01(\x06R\x10newLeaderSteamid\"r\n\x1aCMsgDOTACancelGroupInvite\
    s\x12)\n\x10invited_steamids\x18\x01\x20\x03(\x06R\x0finvitedSteamids\
    \x12)\n\x10invited_groupids\x18\x02\x20\x03(\x06R\x0finvitedGroupids\"0\
    \n\x1aCMsgDOTASetGroupOpenStatus\x12\x12\n\x04open\x18\x01\x20\x01(\x08R\
    \x04open\"@\n\x18CMsgDOTAGroupMergeInvite\x12$\n\x0eother_group_id\x18\
    \x01\x20\x01(\x06R\x0cotherGroupId\"b\n\x1aCMsgDOTAGroupMergeResponse\
    \x12,\n\x12initiator_group_id\x18\x01\x20\x01(\x06R\x10initiatorGroupId\
    \x12\x16\n\x06accept\x18\x02\x20\x01(\x08R\x06accept\"N\n\x17CMsgDOTAGro\
    upMergeReply\x123\n\x06result\x18\x01\x20\x01(\x0e2\x1b.dota.EDOTAGroupM\
    ergeResultR\x06result\"\x8c\x04\n\x1dCMsgSpectatorLobbyGameDetails\x12\
    \x1a\n\x08language\x18\x01\x20\x01(\rR\x08language\x12\x19\n\x08match_id\
    \x18\x02\x20\x01(\x04R\x07matchId\x12&\n\x0fserver_steam_id\x18\x03\x20\
    \x01(\x06R\rserverSteamId\x12\x1d\n\nstream_url\x18\x04\x20\x01(\tR\tstr\
    eamUrl\x12\x1f\n\x0bstream_name\x18\x05\x20\x01(\tR\nstreamName\x12\x1b\
    \n\tleague_id\x18\x06\x20\x01(\rR\x08leagueId\x12\x1f\n\x0bseries_type\
    \x18\x07\x20\x01(\rR\nseriesType\x12\x1f\n\x0bseries_game\x18\x08\x20\
    \x01(\rR\nseriesGame\x12K\n\x0cradiant_team\x18\t\x20\x01(\x0b2(.dota.CM\
    sgSpectatorLobbyGameDetails.TeamR\x0bradiantTeam\x12E\n\tdire_team\x18\n\
    \x20\x01(\x0b2(.dota.CMsgSpectatorLobbyGameDetails.TeamR\x08direTeam\x1a\
    Y\n\x04Team\x12\x17\n\x07team_id\x18\x01\x20\x01(\rR\x06teamId\x12\x1b\n\
    \tteam_name\x18\x02\x20\x01(\tR\x08teamName\x12\x1b\n\tteam_logo\x18\x03\
    \x20\x01(\x06R\x08teamLogo\"\xbb\x01\n\x1cCMsgSetSpectatorLobbyDetails\
    \x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x04R\x07lobbyId\x12\x1d\n\nlobby\
    _name\x18\x02\x20\x01(\tR\tlobbyName\x12\x19\n\x08pass_key\x18\x03\x20\
    \x01(\tR\x07passKey\x12F\n\x0cgame_details\x18\x04\x20\x01(\x0b2#.dota.C\
    MsgSpectatorLobbyGameDetailsR\x0bgameDetails\"\x7f\n\x18CMsgCreateSpecta\
    torLobby\x12%\n\x0eclient_version\x18\x01\x20\x01(\rR\rclientVersion\x12\
    <\n\x07details\x18\x02\x20\x01(\x0b2\".dota.CMsgSetSpectatorLobbyDetails\
    R\x07details\"\x18\n\x16CMsgSpectatorLobbyList\"\xfd\x02\n\x1eCMsgSpecta\
    torLobbyListResponse\x12M\n\x07lobbies\x18\x01\x20\x03(\x0b23.dota.CMsgS\
    pectatorLobbyListResponse.SpectatorLobbyR\x07lobbies\x1a\x8b\x02\n\x0eSp\
    ectatorLobby\x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x04R\x07lobbyId\x12\
    \x1b\n\tgame_name\x18\x02\x20\x01(\tR\x08gameName\x12*\n\x11requires_pas\
    s_key\x18\x03\x20\x01(\x08R\x0frequiresPassKey\x12*\n\x11leader_account_\
    id\x18\x04\x20\x01(\rR\x0fleaderAccountId\x12!\n\x0cmember_count\x18\x05\
    \x20\x01(\rR\x0bmemberCount\x12F\n\x0cgame_details\x18\x07\x20\x01(\x0b2\
    #.dota.CMsgSpectatorLobbyGameDetailsR\x0bgameDetails\"R\n(CMsgClientToGC\
    RequestSteamDatagramTicket\x12&\n\x0fserver_steam_id\x18\x01\x20\x01(\
    \x06R\rserverSteamId\"y\n0CMsgClientToGCRequestSteamDatagramTicketRespon\
    se\x12+\n\x11serialized_ticket\x18\x01\x20\x01(\x0cR\x10serializedTicket\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\xef\x03\n!CMsgGCT\
    oClientSteamDatagramTicket\x12,\n\x12legacy_time_expiry\x18\x01\x20\x01(\
    \x07R\x10legacyTimeExpiry\x12;\n\x1alegacy_authorized_steam_id\x18\x02\
    \x20\x01(\x06R\x17legacyAuthorizedSteamId\x12=\n\x1blegacy_authorized_pu\
    blic_ip\x18\x03\x20\x01(\x07R\x18legacyAuthorizedPublicIp\x12;\n\x1alega\
    cy_gameserver_steam_id\x18\x04\x20\x01(\x06R\x17legacyGameserverSteamId\
    \x127\n\x18legacy_gameserver_net_id\x18\x05\x20\x01(\x06R\x15legacyGames\
    erverNetId\x12)\n\x10legacy_signature\x18\x06\x20\x01(\x0cR\x0flegacySig\
    nature\x12\"\n\rlegacy_app_id\x18\x07\x20\x01(\rR\x0blegacyAppId\x12.\n\
    \x13legacy_extra_fields\x18\x08\x20\x03(\x0cR\x11legacyExtraFields\x12+\
    \n\x11serialized_ticket\x18\x10\x20\x01(\x0cR\x10serializedTicket\"$\n\"\
    CMsgGCToClientRequestLaneSelection\"\x94\x01\n*CMsgGCToClientRequestLane\
    SelectionResponse\x120\n\x14lane_selection_flags\x18\x01\x20\x01(\rR\x12\
    laneSelectionFlags\x124\n\x16high_priority_disabled\x18\x02\x20\x01(\x08\
    R\x14highPriorityDisabled\"\x1d\n\x1bCMsgGCToClientRequestMMInfo\"~\n\
    \x14CMsgClientToGCMMInfo\x120\n\x14lane_selection_flags\x18\x01\x20\x01(\
    \rR\x12laneSelectionFlags\x124\n\x16high_priority_disabled\x18\x02\x20\
    \x01(\x08R\x14highPriorityDisabled*\xbc\x10\n\x18EStartFindingMatchResul\
    t\x12&\n\"k_EStartFindingMatchResult_Invalid\x10\0\x12!\n\x1dk_EStartFin\
    dingMatchResult_OK\x10\x01\x12/\n+k_EStartFindingMatchResult_AlreadySear\
    ching\x10\x02\x12*\n&k_EStartFindingMatchResult_FailGeneric\x10d\x12+\n'\
    k_EStartFindingMatchResult_FailedIgnore\x10e\x122\n.k_EStartFindingMatch\
    Result_MatchmakingDisabled\x10f\x12,\n(k_EStartFindingMatchResult_Region\
    Offline\x10g\x122\n.k_EStartFindingMatchResult_MatchmakingCooldown\x10h\
    \x12.\n*k_EStartFindingMatchResult_ClientOutOfDate\x10i\x127\n3k_EStartF\
    indingMatchResult_CompetitiveNoLowPriority\x10j\x125\n1k_EStartFindingMa\
    tchResult_CompetitiveNotUnlocked\x10k\x122\n.k_EStartFindingMatchResult_\
    GameModeNotUnlocked\x10l\x12;\n7k_EStartFindingMatchResult_CompetitiveNo\
    tEnoughPlayTime\x10m\x122\n.k_EStartFindingMatchResult_MissingInitialSki\
    ll\x10n\x12<\n8k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge\
    \x10o\x123\n/k_EStartFindingMatchResult_MemberAlreadyInLobby\x10p\x123\n\
    /k_EStartFindingMatchResult_MemberNotVACVerified\x10q\x129\n5k_EStartFin\
    dingMatchResult_WeekendTourneyBadPartySize\x10r\x12>\n:k_EStartFindingMa\
    tchResult_WeekendTourneyTeamBuyInTooSmall\x10s\x12D\n@k_EStartFindingMat\
    chResult_WeekendTourneyIndividualBuyInTooLarge\x10t\x12>\n:k_EStartFindi\
    ngMatchResult_WeekendTourneyTeamBuyInTooLarge\x10u\x12:\n6k_EStartFindin\
    gMatchResult_MemberMissingEventOwnership\x10v\x128\n4k_EStartFindingMatc\
    hResult_WeekendTourneyNotUnlocked\x10w\x12@\n<k_EStartFindingMatchResult\
    _WeekendTourneyRecentParticipation\x10x\x12?\n;k_EStartFindingMatchResul\
    t_MemberMissingAnchoredPhoneNumber\x10y\x12.\n*k_EStartFindingMatchResul\
    t_NotMemberOfClan\x10z\x12;\n7k_EStartFindingMatchResult_CoachesChalleng\
    eBadPartySize\x10{\x12A\n=k_EStartFindingMatchResult_CoachesChallengeReq\
    uirementsNotMet\x10|\x124\n0k_EStartFindingMatchResult_InvalidRoleSelect\
    ions\x10}\x125\n1k_EStartFindingMatchResult_PhoneNumberDiscrepancy\x10~\
    \x12,\n(k_EStartFindingMatchResult_NoQueuePoints\x10\x7f\x129\n4k_EStart\
    FindingMatchResult_MemberMissingGauntletFlag\x10\x80\x01\x127\n2k_EStart\
    FindingMatchResult_MemberGauntletTooRecent\x10\x81\x01\x125\n0k_EStartFi\
    ndingMatchResult_DifficultyNotUnlocked\x10\x82\x01\x128\n3k_EStartFindin\
    gMatchResult_CoachesNotAllowedInParty\x10\x83\x01\x12/\n*k_EStartFinding\
    MatchResult_MatchmakingBusy\x10\x84\x01\x120\n+k_EStartFindingMatchResul\
    t_SteamChinaBanned\x10\x85\x01\x12;\n6k_EStartFindingMatchResult_SteamCh\
    inaInvalidMixedParty\x10\x86\x01B%Z#github.com/dotabuff/manta/dota;dotaJ\
    \x95\xa0\x01\n\x07\x12\x05\0\0\xd7\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\
    \n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\n\
    \t\n\x02\x03\x01\x12\x03\x06\x07\x20\n\t\n\x02\x03\x02\x12\x03\x07\x07\
    \x20\n\t\n\x02\x03\x03\x12\x03\x08\x07\x1e\n\t\n\x02\x03\x04\x12\x03\t\
    \x07+\n\n\n\x02\x05\0\x12\x04\x0b\02\x01\n\n\n\x03\x05\0\x01\x12\x03\x0b\
    \x05\x1d\n\x0b\n\x04\x05\0\x02\0\x12\x03\x0c\x08/\n\x0c\n\x05\x05\0\x02\
    \0\x01\x12\x03\x0c\x08*\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x0c-.\n\x0b\
    \n\x04\x05\0\x02\x01\x12\x03\r\x08*\n\x0c\n\x05\x05\0\x02\x01\x01\x12\
    \x03\r\x08%\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\r()\n\x0b\n\x04\x05\0\
    \x02\x02\x12\x03\x0e\x088\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0e\x083\
    \n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0e67\n\x0b\n\x04\x05\0\x02\x03\
    \x12\x03\x0f\x085\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x0f\x08.\n\x0c\n\
    \x05\x05\0\x02\x03\x02\x12\x03\x0f14\n\x0b\n\x04\x05\0\x02\x04\x12\x03\
    \x10\x086\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x10\x08/\n\x0c\n\x05\x05\
    \0\x02\x04\x02\x12\x03\x1025\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x11\x08=\
    \n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x11\x086\n\x0c\n\x05\x05\0\x02\
    \x05\x02\x12\x03\x119<\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x12\x087\n\x0c\
    \n\x05\x05\0\x02\x06\x01\x12\x03\x12\x080\n\x0c\n\x05\x05\0\x02\x06\x02\
    \x12\x03\x1236\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x13\x08=\n\x0c\n\x05\
    \x05\0\x02\x07\x01\x12\x03\x13\x086\n\x0c\n\x05\x05\0\x02\x07\x02\x12\
    \x03\x139<\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x14\x089\n\x0c\n\x05\x05\0\
    \x02\x08\x01\x12\x03\x14\x082\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x145\
    8\n\x0b\n\x04\x05\0\x02\t\x12\x03\x15\x08B\n\x0c\n\x05\x05\0\x02\t\x01\
    \x12\x03\x15\x08;\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x15>A\n\x0b\n\x04\
    \x05\0\x02\n\x12\x03\x16\x08@\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x16\
    \x089\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x16<?\n\x0b\n\x04\x05\0\x02\
    \x0b\x12\x03\x17\x08=\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x17\x086\n\
    \x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x179<\n\x0b\n\x04\x05\0\x02\x0c\x12\
    \x03\x18\x08F\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x18\x08?\n\x0c\n\x05\
    \x05\0\x02\x0c\x02\x12\x03\x18BE\n\x0b\n\x04\x05\0\x02\r\x12\x03\x19\x08\
    =\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x19\x086\n\x0c\n\x05\x05\0\x02\r\
    \x02\x12\x03\x199<\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x1a\x08G\n\x0c\n\
    \x05\x05\0\x02\x0e\x01\x12\x03\x1a\x08@\n\x0c\n\x05\x05\0\x02\x0e\x02\
    \x12\x03\x1aCF\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x1b\x08>\n\x0c\n\x05\
    \x05\0\x02\x0f\x01\x12\x03\x1b\x087\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\
    \x03\x1b:=\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x1c\x08>\n\x0c\n\x05\x05\0\
    \x02\x10\x01\x12\x03\x1c\x087\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x1c:\
    =\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x1d\x08D\n\x0c\n\x05\x05\0\x02\x11\
    \x01\x12\x03\x1d\x08=\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x1d@C\n\x0b\
    \n\x04\x05\0\x02\x12\x12\x03\x1e\x08I\n\x0c\n\x05\x05\0\x02\x12\x01\x12\
    \x03\x1e\x08B\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x1eEH\n\x0b\n\x04\
    \x05\0\x02\x13\x12\x03\x1f\x08O\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\
    \x1f\x08H\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\x1fKN\n\x0b\n\x04\x05\0\
    \x02\x14\x12\x03\x20\x08I\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x20\x08B\
    \n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x20EH\n\x0b\n\x04\x05\0\x02\x15\
    \x12\x03!\x08E\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03!\x08>\n\x0c\n\x05\
    \x05\0\x02\x15\x02\x12\x03!AD\n\x0b\n\x04\x05\0\x02\x16\x12\x03\"\x08C\n\
    \x0c\n\x05\x05\0\x02\x16\x01\x12\x03\"\x08<\n\x0c\n\x05\x05\0\x02\x16\
    \x02\x12\x03\"?B\n\x0b\n\x04\x05\0\x02\x17\x12\x03#\x08K\n\x0c\n\x05\x05\
    \0\x02\x17\x01\x12\x03#\x08D\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03#GJ\n\
    \x0b\n\x04\x05\0\x02\x18\x12\x03$\x08J\n\x0c\n\x05\x05\0\x02\x18\x01\x12\
    \x03$\x08C\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03$FI\n\x0b\n\x04\x05\0\
    \x02\x19\x12\x03%\x089\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03%\x082\n\x0c\
    \n\x05\x05\0\x02\x19\x02\x12\x03%58\n\x0b\n\x04\x05\0\x02\x1a\x12\x03&\
    \x08F\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03&\x08?\n\x0c\n\x05\x05\0\x02\
    \x1a\x02\x12\x03&BE\n\x0b\n\x04\x05\0\x02\x1b\x12\x03'\x08L\n\x0c\n\x05\
    \x05\0\x02\x1b\x01\x12\x03'\x08E\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03'H\
    K\n\x0b\n\x04\x05\0\x02\x1c\x12\x03(\x08?\n\x0c\n\x05\x05\0\x02\x1c\x01\
    \x12\x03(\x088\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03(;>\n\x0b\n\x04\x05\
    \0\x02\x1d\x12\x03)\x08@\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x03)\x089\n\
    \x0c\n\x05\x05\0\x02\x1d\x02\x12\x03)<?\n\x0b\n\x04\x05\0\x02\x1e\x12\
    \x03*\x087\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x03*\x080\n\x0c\n\x05\x05\0\
    \x02\x1e\x02\x12\x03*36\n\x0b\n\x04\x05\0\x02\x1f\x12\x03+\x08C\n\x0c\n\
    \x05\x05\0\x02\x1f\x01\x12\x03+\x08<\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\
    \x03+?B\n\x0b\n\x04\x05\0\x02\x20\x12\x03,\x08A\n\x0c\n\x05\x05\0\x02\
    \x20\x01\x12\x03,\x08:\n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03,=@\n\x0b\n\
    \x04\x05\0\x02!\x12\x03-\x08?\n\x0c\n\x05\x05\0\x02!\x01\x12\x03-\x088\n\
    \x0c\n\x05\x05\0\x02!\x02\x12\x03-;>\n\x0b\n\x04\x05\0\x02\"\x12\x03.\
    \x08B\n\x0c\n\x05\x05\0\x02\"\x01\x12\x03.\x08;\n\x0c\n\x05\x05\0\x02\"\
    \x02\x12\x03.>A\n\x0b\n\x04\x05\0\x02#\x12\x03/\x089\n\x0c\n\x05\x05\0\
    \x02#\x01\x12\x03/\x082\n\x0c\n\x05\x05\0\x02#\x02\x12\x03/58\n\x0b\n\
    \x04\x05\0\x02$\x12\x030\x08:\n\x0c\n\x05\x05\0\x02$\x01\x12\x030\x083\n\
    \x0c\n\x05\x05\0\x02$\x02\x12\x03069\n\x0b\n\x04\x05\0\x02%\x12\x031\x08\
    E\n\x0c\n\x05\x05\0\x02%\x01\x12\x031\x08>\n\x0c\n\x05\x05\0\x02%\x02\
    \x12\x031AD\n\n\n\x02\x04\0\x12\x044\0I\x01\n\n\n\x03\x04\0\x01\x12\x034\
    \x08\x1d\n\x0b\n\x04\x04\0\x02\0\x12\x035\x08\x20\n\x0c\n\x05\x04\0\x02\
    \0\x04\x12\x035\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x035\x11\x17\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x035\x18\x1b\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x035\x1e\x1f\n\x0b\n\x04\x04\0\x02\x01\x12\x036\x08(\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x036\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x036\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x036\x18#\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x036&'\n\x0b\n\x04\x04\0\x02\x02\x12\x037\x08+\n\
    \x0c\n\x05\x04\0\x02\x02\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x037\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x037\x18&\n\x0c\
    \n\x05\x04\0\x02\x02\x03\x12\x037)*\n\x0b\n\x04\x04\0\x02\x03\x12\x038\
    \x08'\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\0\
    \x02\x03\x05\x12\x038\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x038\x18\
    \"\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x038%&\n\x0b\n\x04\x04\0\x02\x04\
    \x12\x039\x08*\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x039\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x04\x06\x12\x039\x11\x1a\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x039\x1b%\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x039()\n\x0b\n\x04\x04\
    \0\x02\x05\x12\x03:\x08+\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03:\x08\x10\
    \n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\0\x02\
    \x05\x01\x12\x03:\x18&\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03:)*\n\x0b\n\
    \x04\x04\0\x02\x06\x12\x03;\x08$\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03;\
    \x08\x10\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03;\x11\x17\n\x0c\n\x05\x04\
    \0\x02\x06\x01\x12\x03;\x18\x1f\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03;\"\
    #\n\x0b\n\x04\x04\0\x02\x07\x12\x03<\x088\n\x0c\n\x05\x04\0\x02\x07\x04\
    \x12\x03<\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03<\x11\x1f\n\x0c\n\
    \x05\x04\0\x02\x07\x01\x12\x03<\x202\n\x0c\n\x05\x04\0\x02\x07\x03\x12\
    \x03<57\n\x0b\n\x04\x04\0\x02\x08\x12\x03=\x080\n\x0c\n\x05\x04\0\x02\
    \x08\x04\x12\x03=\x08\x10\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03=\x11\x17\
    \n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03=\x18*\n\x0c\n\x05\x04\0\x02\x08\
    \x03\x12\x03=-/\n\x0b\n\x04\x04\0\x02\t\x12\x03>\x083\n\x0c\n\x05\x04\0\
    \x02\t\x04\x12\x03>\x08\x10\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03>\x11#\n\
    \x0c\n\x05\x04\0\x02\t\x01\x12\x03>$-\n\x0c\n\x05\x04\0\x02\t\x03\x12\
    \x03>02\n\x0b\n\x04\x04\0\x02\n\x12\x03?\x081\n\x0c\n\x05\x04\0\x02\n\
    \x04\x12\x03?\x08\x10\n\x0c\n\x05\x04\0\x02\n\x05\x12\x03?\x11\x17\n\x0c\
    \n\x05\x04\0\x02\n\x01\x12\x03?\x18+\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03\
    ?.0\n\x0b\n\x04\x04\0\x02\x0b\x12\x03@\x08&\n\x0c\n\x05\x04\0\x02\x0b\
    \x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\0\x02\x0b\x05\x12\x03@\x11\x15\n\
    \x0c\n\x05\x04\0\x02\x0b\x01\x12\x03@\x16\x20\n\x0c\n\x05\x04\0\x02\x0b\
    \x03\x12\x03@#%\n\x0b\n\x04\x04\0\x02\x0c\x12\x03A\x083\n\x0c\n\x05\x04\
    \0\x02\x0c\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x03A\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03A\x18-\n\x0c\n\x05\x04\0\
    \x02\x0c\x03\x12\x03A02\n\x0b\n\x04\x04\0\x02\r\x12\x03B\x08.\n\x0c\n\
    \x05\x04\0\x02\r\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\0\x02\r\x05\x12\
    \x03B\x11\x15\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03B\x16(\n\x0c\n\x05\x04\
    \0\x02\r\x03\x12\x03B+-\n\x0b\n\x04\x04\0\x02\x0e\x12\x03C\x082\n\x0c\n\
    \x05\x04\0\x02\x0e\x04\x12\x03C\x08\x10\n\x0c\n\x05\x04\0\x02\x0e\x05\
    \x12\x03C\x11\x17\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03C\x18,\n\x0c\n\
    \x05\x04\0\x02\x0e\x03\x12\x03C/1\n\x0b\n\x04\x04\0\x02\x0f\x12\x03D\x08\
    2\n\x0c\n\x05\x04\0\x02\x0f\x04\x12\x03D\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x0f\x05\x12\x03D\x11\x15\n\x0c\n\x05\x04\0\x02\x0f\x01\x12\x03D\x16,\n\
    \x0c\n\x05\x04\0\x02\x0f\x03\x12\x03D/1\n\x0b\n\x04\x04\0\x02\x10\x12\
    \x03E\x089\n\x0c\n\x05\x04\0\x02\x10\x04\x12\x03E\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x10\x05\x12\x03E\x11\x15\n\x0c\n\x05\x04\0\x02\x10\x01\x12\
    \x03E\x163\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x03E68\n\x0b\n\x04\x04\0\
    \x02\x11\x12\x03F\x089\n\x0c\n\x05\x04\0\x02\x11\x04\x12\x03F\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x11\x05\x12\x03F\x11\x17\n\x0c\n\x05\x04\0\x02\x11\
    \x01\x12\x03F\x183\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x03F68\n\x0b\n\x04\
    \x04\0\x02\x12\x12\x03G\x081\n\x0c\n\x05\x04\0\x02\x12\x04\x12\x03G\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x12\x05\x12\x03G\x11\x17\n\x0c\n\x05\x04\0\
    \x02\x12\x01\x12\x03G\x18+\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x03G.0\n\
    \x0b\n\x04\x04\0\x02\x13\x12\x03H\x083\n\x0c\n\x05\x04\0\x02\x13\x04\x12\
    \x03H\x08\x10\n\x0c\n\x05\x04\0\x02\x13\x05\x12\x03H\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x13\x01\x12\x03H\x18-\n\x0c\n\x05\x04\0\x02\x13\x03\x12\x03H0\
    2\n\n\n\x02\x04\x01\x12\x04K\0R\x01\n\n\n\x03\x04\x01\x01\x12\x03K\x08#\
    \n\x0b\n\x04\x04\x01\x02\0\x12\x03L\x083\n\x0c\n\x05\x04\x01\x02\0\x04\
    \x12\x03L\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03L\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03L\x18.\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03L12\n\x0b\n\x04\x04\x01\x02\x01\x12\x03M\x085\n\x0c\n\x05\x04\x01\
    \x02\x01\x04\x12\x03M\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03M\
    \x11)\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03M*0\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x03M34\n\x0b\n\x04\x04\x01\x02\x02\x12\x03N\x08(\n\x0c\n\
    \x05\x04\x01\x02\x02\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\
    \x05\x12\x03N\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03N\x18#\n\
    \x0c\n\x05\x04\x01\x02\x02\x03\x12\x03N&'\n\x0b\n\x04\x04\x01\x02\x03\
    \x12\x03O\x08*\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03O\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x03\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03O\x18%\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03O()\n\x0b\n\
    \x04\x04\x01\x02\x04\x12\x03P\x087\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\
    \x03P\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03P\x11\x18\n\x0c\n\
    \x05\x04\x01\x02\x04\x01\x12\x03P\x192\n\x0c\n\x05\x04\x01\x02\x04\x03\
    \x12\x03P56\n\x0b\n\x04\x04\x01\x02\x05\x12\x03Q\x08,\n\x0c\n\x05\x04\
    \x01\x02\x05\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\
    \x03Q\x11\x17\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03Q\x18'\n\x0c\n\x05\
    \x04\x01\x02\x05\x03\x12\x03Q*+\n\n\n\x02\x04\x02\x12\x04T\0V\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03T\x08\x1c\n\x0b\n\x04\x04\x02\x02\0\x12\x03U\x08\
    *\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \0\x05\x12\x03U\x11\x15\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03U\x16%\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03U()\n\n\n\x02\x04\x03\x12\x04X\0^\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03X\x08\x1f\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x03Y\x08-\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03Y\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\0\x05\x12\x03Y\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x03Y\x18(\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03Y+,\n\x0b\n\x04\x04\
    \x03\x02\x01\x12\x03Z\x08*\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03Z\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03Z\x11\x1a\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03Z\x1b%\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03Z(\
    )\n\x0b\n\x04\x04\x03\x02\x02\x12\x03[\x08(\n\x0c\n\x05\x04\x03\x02\x02\
    \x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03[\x11\x17\n\
    \x0c\n\x05\x04\x03\x02\x02\x01\x12\x03[\x18#\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x03[&'\n\x0b\n\x04\x04\x03\x02\x03\x12\x03\\\x08+\n\x0c\n\x05\
    \x04\x03\x02\x03\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\
    \x12\x03\\\x11\x17\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03\\\x18&\n\x0c\
    \n\x05\x04\x03\x02\x03\x03\x12\x03\\)*\n\x0b\n\x04\x04\x03\x02\x04\x12\
    \x03]\x08-\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03]\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\x04\x06\x12\x03]\x11\x1f\n\x0c\n\x05\x04\x03\x02\x04\x01\
    \x12\x03]\x20(\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03]+,\n\n\n\x02\x04\
    \x04\x12\x04`\0d\x01\n\n\n\x03\x04\x04\x01\x12\x03`\x08\x13\n\x0b\n\x04\
    \x04\x04\x02\0\x12\x03a\x08/\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03a\x08\
    \x10\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03a\x11$\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03a%*\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03a-.\n\x0b\n\x04\
    \x04\x04\x02\x01\x12\x03b\x08*\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03b\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03b\x11\x18\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03b\x19%\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03b()\n\x0b\n\x04\x04\x04\x02\x02\x12\x03c\x08=\n\x0c\n\x05\x04\x04\
    \x02\x02\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x06\x12\x03c\
    \x11)\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03c*8\n\x0c\n\x05\x04\x04\x02\
    \x02\x03\x12\x03c;<\n\n\n\x02\x04\x05\x12\x04f\0j\x01\n\n\n\x03\x04\x05\
    \x01\x12\x03f\x08\x19\n\x0b\n\x04\x04\x05\x02\0\x12\x03g\x08&\n\x0c\n\
    \x05\x04\x05\x02\0\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\
    \x12\x03g\x11\x18\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03g\x19!\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03g$%\n\x0b\n\x04\x04\x05\x02\x01\x12\x03h\
    \x08)\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03h\x11\x17\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\
    \x03h\x18$\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03h'(\n\x0b\n\x04\x04\
    \x05\x02\x02\x12\x03i\x08)\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03i\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03i\x11\x17\n\x0c\n\x05\x04\
    \x05\x02\x02\x01\x12\x03i\x18$\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03i'\
    (\n\n\n\x02\x04\x06\x12\x04l\0m\x01\n\n\n\x03\x04\x06\x01\x12\x03l\x08\
    \x1e\n\n\n\x02\x04\x07\x12\x04o\0r\x01\n\n\n\x03\x04\x07\x01\x12\x03o\
    \x08\x1d\n\x0b\n\x04\x04\x07\x02\0\x12\x03p\x08#\n\x0c\n\x05\x04\x07\x02\
    \0\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03p\x11\x16\n\
    \x0c\n\x05\x04\x07\x02\0\x01\x12\x03p\x17\x1e\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03p!\"\n\x0b\n\x04\x04\x07\x02\x01\x12\x03q\x08\x20\n\x0c\n\
    \x05\x04\x07\x02\x01\x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\
    \x05\x12\x03q\x11\x16\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03q\x17\x1b\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x03q\x1e\x1f\n\x0b\n\x02\x04\x08\x12\
    \x05t\0\xa5\x01\x01\n\n\n\x03\x04\x08\x01\x12\x03t\x08#\n\x0c\n\x04\x04\
    \x08\x03\0\x12\x04u\x08w\t\n\x0c\n\x05\x04\x08\x03\0\x01\x12\x03u\x10+\n\
    \r\n\x06\x04\x08\x03\0\x02\0\x12\x03v\x106\n\x0e\n\x07\x04\x08\x03\0\x02\
    \0\x04\x12\x03v\x10\x18\n\x0e\n\x07\x04\x08\x03\0\x02\0\x05\x12\x03v\x19\
    \x1d\n\x0e\n\x07\x04\x08\x03\0\x02\0\x01\x12\x03v\x1e1\n\x0e\n\x07\x04\
    \x08\x03\0\x02\0\x03\x12\x03v45\n\x0b\n\x04\x04\x08\x02\0\x12\x03y\x08%\
    \n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\x08\x02\
    \0\x05\x12\x03y\x11\x17\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03y\x18\x20\n\
    \x0c\n\x05\x04\x08\x02\0\x03\x12\x03y#$\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03z\x08&\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03z\x08\x10\n\x0c\n\x05\
    \x04\x08\x02\x01\x05\x12\x03z\x11\x17\n\x0c\n\x05\x04\x08\x02\x01\x01\
    \x12\x03z\x18!\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03z$%\n\x0b\n\x04\
    \x04\x08\x02\x02\x12\x03{\x084\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03{\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\x02\x06\x12\x03{\x11\"\n\x0c\n\x05\x04\
    \x08\x02\x02\x01\x12\x03{#/\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03{23\n\
    \x0b\n\x04\x04\x08\x02\x03\x12\x03|\x08*\n\x0c\n\x05\x04\x08\x02\x03\x04\
    \x12\x03|\x08\x10\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03|\x11\x17\n\x0c\
    \n\x05\x04\x08\x02\x03\x01\x12\x03|\x18%\n\x0c\n\x05\x04\x08\x02\x03\x03\
    \x12\x03|()\n\x0b\n\x04\x04\x08\x02\x04\x12\x03}\x08&\n\x0c\n\x05\x04\
    \x08\x02\x04\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\
    \x03}\x11\x17\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03}\x18!\n\x0c\n\x05\
    \x04\x08\x02\x04\x03\x12\x03}$%\n\x0b\n\x04\x04\x08\x02\x05\x12\x03~\x08\
    *\n\x0c\n\x05\x04\x08\x02\x05\x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\x08\
    \x02\x05\x06\x12\x03~\x11\x1d\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\x03~\
    \x1e%\n\x0c\n\x05\x04\x08\x02\x05\x03\x12\x03~()\n\x0b\n\x04\x04\x08\x02\
    \x06\x12\x03\x7f\x08>\n\x0c\n\x05\x04\x08\x02\x06\x04\x12\x03\x7f\x08\
    \x10\n\x0c\n\x05\x04\x08\x02\x06\x06\x12\x03\x7f\x11\"\n\x0c\n\x05\x04\
    \x08\x02\x06\x01\x12\x03\x7f#9\n\x0c\n\x05\x04\x08\x02\x06\x03\x12\x03\
    \x7f<=\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\x80\x01\x08(\n\r\n\x05\x04\
    \x08\x02\x07\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\x08\x02\x07\x05\
    \x12\x04\x80\x01\x11\x15\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\x80\x01\
    \x16\"\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\x80\x01%'\n\x0c\n\x04\x04\
    \x08\x02\x08\x12\x04\x81\x01\x08*\n\r\n\x05\x04\x08\x02\x08\x04\x12\x04\
    \x81\x01\x08\x10\n\r\n\x05\x04\x08\x02\x08\x05\x12\x04\x81\x01\x11\x15\n\
    \r\n\x05\x04\x08\x02\x08\x01\x12\x04\x81\x01\x16$\n\r\n\x05\x04\x08\x02\
    \x08\x03\x12\x04\x81\x01')\n\x0c\n\x04\x04\x08\x02\t\x12\x04\x82\x01\x08\
    &\n\r\n\x05\x04\x08\x02\t\x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\x08\
    \x02\t\x05\x12\x04\x82\x01\x11\x15\n\r\n\x05\x04\x08\x02\t\x01\x12\x04\
    \x82\x01\x16\x20\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\x82\x01#%\n\x0c\n\
    \x04\x04\x08\x02\n\x12\x04\x83\x01\x08,\n\r\n\x05\x04\x08\x02\n\x04\x12\
    \x04\x83\x01\x08\x10\n\r\n\x05\x04\x08\x02\n\x05\x12\x04\x83\x01\x11\x15\
    \n\r\n\x05\x04\x08\x02\n\x01\x12\x04\x83\x01\x16&\n\r\n\x05\x04\x08\x02\
    \n\x03\x12\x04\x83\x01)+\n\x0c\n\x04\x04\x08\x02\x0b\x12\x04\x84\x01\x08\
    &\n\r\n\x05\x04\x08\x02\x0b\x04\x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\
    \x08\x02\x0b\x05\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\x08\x02\x0b\x01\
    \x12\x04\x84\x01\x18\x20\n\r\n\x05\x04\x08\x02\x0b\x03\x12\x04\x84\x01#%\
    \n\x0c\n\x04\x04\x08\x02\x0c\x12\x04\x85\x01\x08&\n\r\n\x05\x04\x08\x02\
    \x0c\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x08\x02\x0c\x05\x12\x04\
    \x85\x01\x11\x17\n\r\n\x05\x04\x08\x02\x0c\x01\x12\x04\x85\x01\x18\x20\n\
    \r\n\x05\x04\x08\x02\x0c\x03\x12\x04\x85\x01#%\n\x0c\n\x04\x04\x08\x02\r\
    \x12\x04\x86\x01\x083\n\r\n\x05\x04\x08\x02\r\x04\x12\x04\x86\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\r\x05\x12\x04\x86\x01\x11\x17\n\r\n\x05\x04\
    \x08\x02\r\x01\x12\x04\x86\x01\x18-\n\r\n\x05\x04\x08\x02\r\x03\x12\x04\
    \x86\x0102\n\x0c\n\x04\x04\x08\x02\x0e\x12\x04\x87\x01\x080\n\r\n\x05\
    \x04\x08\x02\x0e\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x08\x02\x0e\
    \x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x08\x02\x0e\x01\x12\x04\x87\
    \x01\x18*\n\r\n\x05\x04\x08\x02\x0e\x03\x12\x04\x87\x01-/\n\x0c\n\x04\
    \x04\x08\x02\x0f\x12\x04\x88\x01\x08*\n\r\n\x05\x04\x08\x02\x0f\x04\x12\
    \x04\x88\x01\x08\x10\n\r\n\x05\x04\x08\x02\x0f\x05\x12\x04\x88\x01\x11\
    \x17\n\r\n\x05\x04\x08\x02\x0f\x01\x12\x04\x88\x01\x18$\n\r\n\x05\x04\
    \x08\x02\x0f\x03\x12\x04\x88\x01')\n\x0c\n\x04\x04\x08\x02\x10\x12\x04\
    \x89\x01\x08)\n\r\n\x05\x04\x08\x02\x10\x04\x12\x04\x89\x01\x08\x10\n\r\
    \n\x05\x04\x08\x02\x10\x05\x12\x04\x89\x01\x11\x17\n\r\n\x05\x04\x08\x02\
    \x10\x01\x12\x04\x89\x01\x18#\n\r\n\x05\x04\x08\x02\x10\x03\x12\x04\x89\
    \x01&(\n\x0c\n\x04\x04\x08\x02\x11\x12\x04\x8a\x01\x081\n\r\n\x05\x04\
    \x08\x02\x11\x04\x12\x04\x8a\x01\x08\x10\n\r\n\x05\x04\x08\x02\x11\x05\
    \x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x08\x02\x11\x01\x12\x04\x8a\x01\
    \x18+\n\r\n\x05\x04\x08\x02\x11\x03\x12\x04\x8a\x01.0\n\x0c\n\x04\x04\
    \x08\x02\x12\x12\x04\x8b\x01\x08.\n\r\n\x05\x04\x08\x02\x12\x04\x12\x04\
    \x8b\x01\x08\x10\n\r\n\x05\x04\x08\x02\x12\x05\x12\x04\x8b\x01\x11\x17\n\
    \r\n\x05\x04\x08\x02\x12\x01\x12\x04\x8b\x01\x18(\n\r\n\x05\x04\x08\x02\
    \x12\x03\x12\x04\x8b\x01+-\n\x0c\n\x04\x04\x08\x02\x13\x12\x04\x8c\x01\
    \x08#\n\r\n\x05\x04\x08\x02\x13\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02\x13\x05\x12\x04\x8c\x01\x11\x15\n\r\n\x05\x04\x08\x02\x13\
    \x01\x12\x04\x8c\x01\x16\x1d\n\r\n\x05\x04\x08\x02\x13\x03\x12\x04\x8c\
    \x01\x20\"\n\x0c\n\x04\x04\x08\x02\x14\x12\x04\x8d\x01\x085\n\r\n\x05\
    \x04\x08\x02\x14\x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x08\x02\x14\
    \x06\x12\x04\x8d\x01\x11!\n\r\n\x05\x04\x08\x02\x14\x01\x12\x04\x8d\x01\
    \"/\n\r\n\x05\x04\x08\x02\x14\x03\x12\x04\x8d\x0124\n\x0c\n\x04\x04\x08\
    \x02\x15\x12\x04\x8e\x01\x08\x1f\n\r\n\x05\x04\x08\x02\x15\x04\x12\x04\
    \x8e\x01\x08\x10\n\r\n\x05\x04\x08\x02\x15\x05\x12\x04\x8e\x01\x11\x15\n\
    \r\n\x05\x04\x08\x02\x15\x01\x12\x04\x8e\x01\x16\x19\n\r\n\x05\x04\x08\
    \x02\x15\x03\x12\x04\x8e\x01\x1c\x1e\n\x0c\n\x04\x04\x08\x02\x16\x12\x04\
    \x8f\x01\x08.\n\r\n\x05\x04\x08\x02\x16\x04\x12\x04\x8f\x01\x08\x10\n\r\
    \n\x05\x04\x08\x02\x16\x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x08\x02\
    \x16\x01\x12\x04\x8f\x01\x18(\n\r\n\x05\x04\x08\x02\x16\x03\x12\x04\x8f\
    \x01+-\n\x0c\n\x04\x04\x08\x02\x17\x12\x04\x90\x01\x08-\n\r\n\x05\x04\
    \x08\x02\x17\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\x08\x02\x17\x05\
    \x12\x04\x90\x01\x11\x17\n\r\n\x05\x04\x08\x02\x17\x01\x12\x04\x90\x01\
    \x18'\n\r\n\x05\x04\x08\x02\x17\x03\x12\x04\x90\x01*,\n\x0c\n\x04\x04\
    \x08\x02\x18\x12\x04\x91\x01\x08/\n\r\n\x05\x04\x08\x02\x18\x04\x12\x04\
    \x91\x01\x08\x10\n\r\n\x05\x04\x08\x02\x18\x05\x12\x04\x91\x01\x11\x17\n\
    \r\n\x05\x04\x08\x02\x18\x01\x12\x04\x91\x01\x18)\n\r\n\x05\x04\x08\x02\
    \x18\x03\x12\x04\x91\x01,.\n\x0c\n\x04\x04\x08\x02\x19\x12\x04\x92\x01\
    \x08,\n\r\n\x05\x04\x08\x02\x19\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02\x19\x05\x12\x04\x92\x01\x11\x17\n\r\n\x05\x04\x08\x02\x19\
    \x01\x12\x04\x92\x01\x18&\n\r\n\x05\x04\x08\x02\x19\x03\x12\x04\x92\x01)\
    +\n\x0c\n\x04\x04\x08\x02\x1a\x12\x04\x93\x01\x080\n\r\n\x05\x04\x08\x02\
    \x1a\x04\x12\x04\x93\x01\x08\x10\n\r\n\x05\x04\x08\x02\x1a\x05\x12\x04\
    \x93\x01\x11\x17\n\r\n\x05\x04\x08\x02\x1a\x01\x12\x04\x93\x01\x18*\n\r\
    \n\x05\x04\x08\x02\x1a\x03\x12\x04\x93\x01-/\n\x0c\n\x04\x04\x08\x02\x1b\
    \x12\x04\x94\x01\x080\n\r\n\x05\x04\x08\x02\x1b\x04\x12\x04\x94\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\x1b\x05\x12\x04\x94\x01\x11\x17\n\r\n\x05\x04\
    \x08\x02\x1b\x01\x12\x04\x94\x01\x18*\n\r\n\x05\x04\x08\x02\x1b\x03\x12\
    \x04\x94\x01-/\n\x0c\n\x04\x04\x08\x02\x1c\x12\x04\x95\x01\x085\n\r\n\
    \x05\x04\x08\x02\x1c\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x1c\x06\x12\x04\x95\x01\x11$\n\r\n\x05\x04\x08\x02\x1c\x01\x12\x04\x95\
    \x01%/\n\r\n\x05\x04\x08\x02\x1c\x03\x12\x04\x95\x0124\n\x0c\n\x04\x04\
    \x08\x02\x1d\x12\x04\x96\x01\x08.\n\r\n\x05\x04\x08\x02\x1d\x04\x12\x04\
    \x96\x01\x08\x10\n\r\n\x05\x04\x08\x02\x1d\x05\x12\x04\x96\x01\x11\x18\n\
    \r\n\x05\x04\x08\x02\x1d\x01\x12\x04\x96\x01\x19(\n\r\n\x05\x04\x08\x02\
    \x1d\x03\x12\x04\x96\x01+-\n\x0c\n\x04\x04\x08\x02\x1e\x12\x04\x97\x01\
    \x084\n\r\n\x05\x04\x08\x02\x1e\x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02\x1e\x05\x12\x04\x97\x01\x11\x18\n\r\n\x05\x04\x08\x02\x1e\
    \x01\x12\x04\x97\x01\x19.\n\r\n\x05\x04\x08\x02\x1e\x03\x12\x04\x97\x011\
    3\n\x0c\n\x04\x04\x08\x02\x1f\x12\x04\x98\x01\x085\n\r\n\x05\x04\x08\x02\
    \x1f\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\x08\x02\x1f\x05\x12\x04\
    \x98\x01\x11\x17\n\r\n\x05\x04\x08\x02\x1f\x01\x12\x04\x98\x01\x18/\n\r\
    \n\x05\x04\x08\x02\x1f\x03\x12\x04\x98\x0124\n\x0c\n\x04\x04\x08\x02\x20\
    \x12\x04\x99\x01\x08:\n\r\n\x05\x04\x08\x02\x20\x04\x12\x04\x99\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\x20\x06\x12\x04\x99\x01\x11&\n\r\n\x05\x04\
    \x08\x02\x20\x01\x12\x04\x99\x01'4\n\r\n\x05\x04\x08\x02\x20\x03\x12\x04\
    \x99\x0179\n\x0c\n\x04\x04\x08\x02!\x12\x04\x9a\x01\x08<\n\r\n\x05\x04\
    \x08\x02!\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x08\x02!\x06\x12\x04\
    \x9a\x01\x11\"\n\r\n\x05\x04\x08\x02!\x01\x12\x04\x9a\x01#6\n\r\n\x05\
    \x04\x08\x02!\x03\x12\x04\x9a\x019;\n\x0c\n\x04\x04\x08\x02\"\x12\x04\
    \x9b\x01\x08)\n\r\n\x05\x04\x08\x02\"\x04\x12\x04\x9b\x01\x08\x10\n\r\n\
    \x05\x04\x08\x02\"\x05\x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\x08\x02\"\
    \x01\x12\x04\x9b\x01\x18#\n\r\n\x05\x04\x08\x02\"\x03\x12\x04\x9b\x01&(\
    \n\x0c\n\x04\x04\x08\x02#\x12\x04\x9c\x01\x08&\n\r\n\x05\x04\x08\x02#\
    \x04\x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\x08\x02#\x05\x12\x04\x9c\x01\
    \x11\x17\n\r\n\x05\x04\x08\x02#\x01\x12\x04\x9c\x01\x18\x20\n\r\n\x05\
    \x04\x08\x02#\x03\x12\x04\x9c\x01#%\n\x0c\n\x04\x04\x08\x02$\x12\x04\x9d\
    \x01\x08J\n\r\n\x05\x04\x08\x02$\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02$\x06\x12\x04\x9d\x01\x11+\n\r\n\x05\x04\x08\x02$\x01\x12\
    \x04\x9d\x01,D\n\r\n\x05\x04\x08\x02$\x03\x12\x04\x9d\x01GI\n\x0c\n\x04\
    \x04\x08\x02%\x12\x04\x9e\x01\x081\n\r\n\x05\x04\x08\x02%\x04\x12\x04\
    \x9e\x01\x08\x10\n\r\n\x05\x04\x08\x02%\x05\x12\x04\x9e\x01\x11\x15\n\r\
    \n\x05\x04\x08\x02%\x01\x12\x04\x9e\x01\x16+\n\r\n\x05\x04\x08\x02%\x03\
    \x12\x04\x9e\x01.0\n\x0c\n\x04\x04\x08\x02&\x12\x04\x9f\x01\x084\n\r\n\
    \x05\x04\x08\x02&\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\x08\x02&\x05\
    \x12\x04\x9f\x01\x11\x17\n\r\n\x05\x04\x08\x02&\x01\x12\x04\x9f\x01\x18.\
    \n\r\n\x05\x04\x08\x02&\x03\x12\x04\x9f\x0113\n\x0c\n\x04\x04\x08\x02'\
    \x12\x04\xa0\x01\x08,\n\r\n\x05\x04\x08\x02'\x04\x12\x04\xa0\x01\x08\x10\
    \n\r\n\x05\x04\x08\x02'\x05\x12\x04\xa0\x01\x11\x17\n\r\n\x05\x04\x08\
    \x02'\x01\x12\x04\xa0\x01\x18&\n\r\n\x05\x04\x08\x02'\x03\x12\x04\xa0\
    \x01)+\n\x0c\n\x04\x04\x08\x02(\x12\x04\xa1\x01\x080\n\r\n\x05\x04\x08\
    \x02(\x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\x04\x08\x02(\x05\x12\x04\xa1\
    \x01\x11\x17\n\r\n\x05\x04\x08\x02(\x01\x12\x04\xa1\x01\x18*\n\r\n\x05\
    \x04\x08\x02(\x03\x12\x04\xa1\x01-/\n\x0c\n\x04\x04\x08\x02)\x12\x04\xa2\
    \x01\x08:\n\r\n\x05\x04\x08\x02)\x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02)\x06\x12\x04\xa2\x01\x11&\n\r\n\x05\x04\x08\x02)\x01\x12\
    \x04\xa2\x01'4\n\r\n\x05\x04\x08\x02)\x03\x12\x04\xa2\x0179\n\x0c\n\x04\
    \x04\x08\x02*\x12\x04\xa3\x01\x08m\n\r\n\x05\x04\x08\x02*\x04\x12\x04\
    \xa3\x01\x08\x10\n\r\n\x05\x04\x08\x02*\x06\x12\x04\xa3\x01\x11H\n\r\n\
    \x05\x04\x08\x02*\x01\x12\x04\xa3\x01Ig\n\r\n\x05\x04\x08\x02*\x03\x12\
    \x04\xa3\x01jl\n\x0c\n\x04\x04\x08\x02+\x12\x04\xa4\x01\x08+\n\r\n\x05\
    \x04\x08\x02+\x04\x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\x08\x02+\x05\x12\
    \x04\xa4\x01\x11\x15\n\r\n\x05\x04\x08\x02+\x01\x12\x04\xa4\x01\x16%\n\r\
    \n\x05\x04\x08\x02+\x03\x12\x04\xa4\x01(*\n\x0c\n\x02\x04\t\x12\x06\xa7\
    \x01\0\xb4\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xa7\x01\x08\x1f\n\x0e\n\
    \x04\x04\t\x03\0\x12\x06\xa8\x01\x08\xad\x01\t\n\r\n\x05\x04\t\x03\0\x01\
    \x12\x04\xa8\x01\x10\x18\n\x0e\n\x06\x04\t\x03\0\x02\0\x12\x04\xa9\x01\
    \x10(\n\x0f\n\x07\x04\t\x03\0\x02\0\x04\x12\x04\xa9\x01\x10\x18\n\x0f\n\
    \x07\x04\t\x03\0\x02\0\x05\x12\x04\xa9\x01\x19\x1e\n\x0f\n\x07\x04\t\x03\
    \0\x02\0\x01\x12\x04\xa9\x01\x1f#\n\x0f\n\x07\x04\t\x03\0\x02\0\x03\x12\
    \x04\xa9\x01&'\n\x0e\n\x06\x04\t\x03\0\x02\x01\x12\x04\xaa\x01\x10+\n\
    \x0f\n\x07\x04\t\x03\0\x02\x01\x04\x12\x04\xaa\x01\x10\x18\n\x0f\n\x07\
    \x04\t\x03\0\x02\x01\x05\x12\x04\xaa\x01\x19\x1e\n\x0f\n\x07\x04\t\x03\0\
    \x02\x01\x01\x12\x04\xaa\x01\x1f&\n\x0f\n\x07\x04\t\x03\0\x02\x01\x03\
    \x12\x04\xaa\x01)*\n\x0e\n\x06\x04\t\x03\0\x02\x02\x12\x04\xab\x01\x10.\
    \n\x0f\n\x07\x04\t\x03\0\x02\x02\x04\x12\x04\xab\x01\x10\x18\n\x0f\n\x07\
    \x04\t\x03\0\x02\x02\x05\x12\x04\xab\x01\x19\x20\n\x0f\n\x07\x04\t\x03\0\
    \x02\x02\x01\x12\x04\xab\x01!)\n\x0f\n\x07\x04\t\x03\0\x02\x02\x03\x12\
    \x04\xab\x01,-\n\x0e\n\x06\x04\t\x03\0\x02\x03\x12\x04\xac\x01\x10/\n\
    \x0f\n\x07\x04\t\x03\0\x02\x03\x04\x12\x04\xac\x01\x10\x18\n\x0f\n\x07\
    \x04\t\x03\0\x02\x03\x05\x12\x04\xac\x01\x19\x20\n\x0f\n\x07\x04\t\x03\0\
    \x02\x03\x01\x12\x04\xac\x01!*\n\x0f\n\x07\x04\t\x03\0\x02\x03\x03\x12\
    \x04\xac\x01-.\n\x0c\n\x04\x04\t\x02\0\x12\x04\xaf\x01\x08'\n\r\n\x05\
    \x04\t\x02\0\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\
    \x04\xaf\x01\x11\x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xaf\x01\x18\"\n\r\
    \n\x05\x04\t\x02\0\x03\x12\x04\xaf\x01%&\n\x0c\n\x04\x04\t\x02\x01\x12\
    \x04\xb0\x01\x08%\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xb0\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x01\x05\x12\x04\xb0\x01\x11\x17\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\xb0\x01\x18\x20\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xb0\
    \x01#$\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xb1\x01\x08+\n\r\n\x05\x04\t\
    \x02\x02\x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\
    \xb1\x01\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xb1\x01\x18&\n\r\n\
    \x05\x04\t\x02\x02\x03\x12\x04\xb1\x01)*\n\x0c\n\x04\x04\t\x02\x03\x12\
    \x04\xb2\x01\x08?\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xb2\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x03\x06\x12\x04\xb2\x01\x11,\n\r\n\x05\x04\t\x02\x03\
    \x01\x12\x04\xb2\x01-:\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xb2\x01=>\n\
    \x0c\n\x04\x04\t\x02\x04\x12\x04\xb3\x01\x08@\n\r\n\x05\x04\t\x02\x04\
    \x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\t\x02\x04\x06\x12\x04\xb3\x01\
    \x111\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xb3\x012;\n\r\n\x05\x04\t\x02\
    \x04\x03\x12\x04\xb3\x01>?\n\x0c\n\x02\x04\n\x12\x06\xb6\x01\0\xba\x01\
    \x01\n\x0b\n\x03\x04\n\x01\x12\x04\xb6\x01\x08$\n\x0c\n\x04\x04\n\x02\0\
    \x12\x04\xb7\x01\x08'\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xb7\x01\x08\x10\
    \n\r\n\x05\x04\n\x02\0\x06\x12\x04\xb7\x01\x11\x1d\n\r\n\x05\x04\n\x02\0\
    \x01\x12\x04\xb7\x01\x1e\"\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb7\x01%&\n\
    \x0c\n\x04\x04\n\x02\x01\x12\x04\xb8\x01\x08!\n\r\n\x05\x04\n\x02\x01\
    \x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xb8\x01\
    \x11\x17\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xb8\x01\x18\x1c\n\r\n\x05\
    \x04\n\x02\x01\x03\x12\x04\xb8\x01\x1f\x20\n\x0c\n\x04\x04\n\x02\x02\x12\
    \x04\xb9\x01\x086\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\xb9\x01\x08\x10\n\
    \r\n\x05\x04\n\x02\x02\x06\x12\x04\xb9\x01\x11\"\n\r\n\x05\x04\n\x02\x02\
    \x01\x12\x04\xb9\x01#1\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xb9\x0145\n\
    \x0c\n\x02\x04\x0b\x12\x06\xbc\x01\0\xbe\x01\x01\n\x0b\n\x03\x04\x0b\x01\
    \x12\x04\xbc\x01\x08!\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xbd\x01\x08'\n\r\
    \n\x05\x04\x0b\x02\0\x04\x12\x04\xbd\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\
    \x06\x12\x04\xbd\x01\x11\x1d\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xbd\x01\
    \x1e\"\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xbd\x01%&\n\x0c\n\x02\x04\x0c\
    \x12\x06\xc0\x01\0\xc5\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xc0\x01\
    \x08-\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xc1\x01\x08$\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\
    \xc1\x01\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xc1\x01\x18\x1f\n\r\
    \n\x05\x04\x0c\x02\0\x03\x12\x04\xc1\x01\"#\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\xc2\x01\x082\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xc2\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xc2\x01\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\xc2\x01\x18-\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\xc2\x0101\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xc3\x01\x083\n\r\n\
    \x05\x04\x0c\x02\x02\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x02\x05\x12\x04\xc3\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\
    \xc3\x01\x18.\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xc3\x0112\n\x0c\n\
    \x04\x04\x0c\x02\x03\x12\x04\xc4\x01\x084\n\r\n\x05\x04\x0c\x02\x03\x04\
    \x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xc4\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xc4\x01\x18/\n\r\n\x05\
    \x04\x0c\x02\x03\x03\x12\x04\xc4\x0123\n\x0c\n\x02\x04\r\x12\x06\xc7\x01\
    \0\xc9\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xc7\x01\x08.\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\xc8\x01\x08$\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xc8\
    \x01\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xc8\x01\x11\x17\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\xc8\x01\x18\x1f\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\xc8\x01\"#\n\x0c\n\x02\x04\x0e\x12\x06\xcb\x01\0\xcc\x01\x01\n\x0b\
    \n\x03\x04\x0e\x01\x12\x04\xcb\x01\x08>\n\x0c\n\x02\x04\x0f\x12\x06\xce\
    \x01\0\xd0\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xce\x01\x08\x1d\n\x0c\
    \n\x04\x04\x0f\x02\0\x12\x04\xcf\x01\x08'\n\r\n\x05\x04\x0f\x02\0\x04\
    \x12\x04\xcf\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xcf\x01\x11\
    \x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xcf\x01\x18\"\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xcf\x01%&\n\x0c\n\x02\x04\x10\x12\x06\xd2\x01\0\xd4\
    \x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xd2\x01\x08%\n\x0c\n\x04\x04\
    \x10\x02\0\x12\x04\xd3\x01\x08'\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xd3\
    \x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xd3\x01\x11\x17\n\r\n\
    \x05\x04\x10\x02\0\x01\x12\x04\xd3\x01\x18\"\n\r\n\x05\x04\x10\x02\0\x03\
    \x12\x04\xd3\x01%&\n\x0c\n\x02\x04\x11\x12\x06\xd6\x01\0\xd7\x01\x01\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xd6\x01\x08\x1e\n\x0c\n\x02\x04\x12\x12\
    \x06\xd9\x01\0\xdb\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xd9\x01\x08\
    \x1f\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xda\x01\x08+\n\r\n\x05\x04\x12\
    \x02\0\x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\
    \xda\x01\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xda\x01\x18&\n\r\n\
    \x05\x04\x12\x02\0\x03\x12\x04\xda\x01)*\n\x0c\n\x02\x04\x13\x12\x06\xdd\
    \x01\0\xdf\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xdd\x01\x08$\n\x0c\n\
    \x04\x04\x13\x02\0\x12\x04\xde\x01\x08$\n\r\n\x05\x04\x13\x02\0\x04\x12\
    \x04\xde\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xde\x01\x11\x17\
    \n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xde\x01\x18\x1f\n\r\n\x05\x04\x13\
    \x02\0\x03\x12\x04\xde\x01\"#\n\x0c\n\x02\x04\x14\x12\x06\xe1\x01\0\xe5\
    \x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xe1\x01\x08\x1d\n\x0c\n\x04\x04\
    \x14\x02\0\x12\x04\xe2\x01\x08%\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xe2\
    \x01\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xe2\x01\x11\x17\n\r\n\
    \x05\x04\x14\x02\0\x01\x12\x04\xe2\x01\x18\x20\n\r\n\x05\x04\x14\x02\0\
    \x03\x12\x04\xe2\x01#$\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xe3\x01\x08#\
    \n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x14\
    \x02\x01\x05\x12\x04\xe3\x01\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\
    \x04\xe3\x01\x18\x1e\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xe3\x01!\"\n\
    \x0c\n\x04\x04\x14\x02\x02\x12\x04\xe4\x01\x08-\n\r\n\x05\x04\x14\x02\
    \x02\x04\x12\x04\xe4\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\
    \xe4\x01\x11\x1e\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xe4\x01\x1f(\n\r\
    \n\x05\x04\x14\x02\x02\x03\x12\x04\xe4\x01+,\n\x0c\n\x02\x04\x15\x12\x06\
    \xe7\x01\0\xfd\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xe7\x01\x08*\n\
    \x0e\n\x04\x04\x15\x03\0\x12\x06\xe8\x01\x08\xeb\x01\t\n\r\n\x05\x04\x15\
    \x03\0\x01\x12\x04\xe8\x01\x10\x1c\n\x0e\n\x06\x04\x15\x03\0\x02\0\x12\
    \x04\xe9\x01\x10/\n\x0f\n\x07\x04\x15\x03\0\x02\0\x04\x12\x04\xe9\x01\
    \x10\x18\n\x0f\n\x07\x04\x15\x03\0\x02\0\x05\x12\x04\xe9\x01\x19\x1f\n\
    \x0f\n\x07\x04\x15\x03\0\x02\0\x01\x12\x04\xe9\x01\x20*\n\x0f\n\x07\x04\
    \x15\x03\0\x02\0\x03\x12\x04\xe9\x01-.\n\x0e\n\x06\x04\x15\x03\0\x02\x01\
    \x12\x04\xea\x01\x100\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x04\x12\x04\xea\
    \x01\x10\x18\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x05\x12\x04\xea\x01\x19\
    \x1f\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x01\x12\x04\xea\x01\x20+\n\x0f\n\
    \x07\x04\x15\x03\0\x02\x01\x03\x12\x04\xea\x01./\n\x0c\n\x04\x04\x15\x02\
    \0\x12\x04\xed\x01\x08\x1f\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xed\x01\
    \x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xed\x01\x11\x17\n\r\n\x05\
    \x04\x15\x02\0\x01\x12\x04\xed\x01\x18\x1a\n\r\n\x05\x04\x15\x02\0\x03\
    \x12\x04\xed\x01\x1d\x1e\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xee\x01\x08\
    M\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xee\x01\x08\x10\n\r\n\x05\x04\
    \x15\x02\x01\x06\x12\x04\xee\x01\x11@\n\r\n\x05\x04\x15\x02\x01\x01\x12\
    \x04\xee\x01AH\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xee\x01KL\n\x0c\n\
    \x04\x04\x15\x02\x02\x12\x04\xef\x01\x08,\n\r\n\x05\x04\x15\x02\x02\x04\
    \x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xef\x01\
    \x11\x15\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xef\x01\x16'\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\xef\x01*+\n\x0c\n\x04\x04\x15\x02\x03\x12\
    \x04\xf0\x01\x08.\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xf0\x01\x08\x10\
    \n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xf0\x01\x11\x17\n\r\n\x05\x04\x15\
    \x02\x03\x01\x12\x04\xf0\x01\x18)\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\
    \xf0\x01,-\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\xf1\x01\x08\"\n\r\n\x05\
    \x04\x15\x02\x04\x04\x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04\x15\x02\x04\
    \x05\x12\x04\xf1\x01\x11\x17\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xf1\
    \x01\x18\x1c\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xf1\x01\x1f!\n\x0c\n\
    \x04\x04\x15\x02\x05\x12\x04\xf2\x01\x08.\n\r\n\x05\x04\x15\x02\x05\x04\
    \x12\x04\xf2\x01\x08\x10\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\xf2\x01\
    \x11\x17\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xf2\x01\x18(\n\r\n\x05\
    \x04\x15\x02\x05\x03\x12\x04\xf2\x01+-\n\x0c\n\x04\x04\x15\x02\x06\x12\
    \x04\xf3\x01\x08.\n\r\n\x05\x04\x15\x02\x06\x04\x12\x04\xf3\x01\x08\x10\
    \n\r\n\x05\x04\x15\x02\x06\x06\x12\x04\xf3\x01\x11\x1e\n\r\n\x05\x04\x15\
    \x02\x06\x01\x12\x04\xf3\x01\x1f(\n\r\n\x05\x04\x15\x02\x06\x03\x12\x04\
    \xf3\x01+-\n\x0c\n\x04\x04\x15\x02\x07\x12\x04\xf4\x01\x08*\n\r\n\x05\
    \x04\x15\x02\x07\x04\x12\x04\xf4\x01\x08\x10\n\r\n\x05\x04\x15\x02\x07\
    \x05\x12\x04\xf4\x01\x11\x15\n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\xf4\
    \x01\x16$\n\r\n\x05\x04\x15\x02\x07\x03\x12\x04\xf4\x01')\n\x0c\n\x04\
    \x04\x15\x02\x08\x12\x04\xf5\x01\x08%\n\r\n\x05\x04\x15\x02\x08\x04\x12\
    \x04\xf5\x01\x08\x10\n\r\n\x05\x04\x15\x02\x08\x05\x12\x04\xf5\x01\x11\
    \x17\n\r\n\x05\x04\x15\x02\x08\x01\x12\x04\xf5\x01\x18\x1f\n\r\n\x05\x04\
    \x15\x02\x08\x03\x12\x04\xf5\x01\"$\n\x0c\n\x04\x04\x15\x02\t\x12\x04\
    \xf6\x01\x08-\n\r\n\x05\x04\x15\x02\t\x04\x12\x04\xf6\x01\x08\x10\n\r\n\
    \x05\x04\x15\x02\t\x05\x12\x04\xf6\x01\x11\x17\n\r\n\x05\x04\x15\x02\t\
    \x01\x12\x04\xf6\x01\x18'\n\r\n\x05\x04\x15\x02\t\x03\x12\x04\xf6\x01*,\
    \n\x0c\n\x04\x04\x15\x02\n\x12\x04\xf7\x01\x08.\n\r\n\x05\x04\x15\x02\n\
    \x04\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\x15\x02\n\x05\x12\x04\xf7\x01\
    \x11\x17\n\r\n\x05\x04\x15\x02\n\x01\x12\x04\xf7\x01\x18(\n\r\n\x05\x04\
    \x15\x02\n\x03\x12\x04\xf7\x01+-\n\x0c\n\x04\x04\x15\x02\x0b\x12\x04\xf8\
    \x01\x08+\n\r\n\x05\x04\x15\x02\x0b\x04\x12\x04\xf8\x01\x08\x10\n\r\n\
    \x05\x04\x15\x02\x0b\x05\x12\x04\xf8\x01\x11\x17\n\r\n\x05\x04\x15\x02\
    \x0b\x01\x12\x04\xf8\x01\x18%\n\r\n\x05\x04\x15\x02\x0b\x03\x12\x04\xf8\
    \x01(*\n\x0c\n\x04\x04\x15\x02\x0c\x12\x04\xf9\x01\x08'\n\r\n\x05\x04\
    \x15\x02\x0c\x04\x12\x04\xf9\x01\x08\x10\n\r\n\x05\x04\x15\x02\x0c\x05\
    \x12\x04\xf9\x01\x11\x17\n\r\n\x05\x04\x15\x02\x0c\x01\x12\x04\xf9\x01\
    \x18!\n\r\n\x05\x04\x15\x02\x0c\x03\x12\x04\xf9\x01$&\n\x0c\n\x04\x04\
    \x15\x02\r\x12\x04\xfa\x01\x084\n\r\n\x05\x04\x15\x02\r\x04\x12\x04\xfa\
    \x01\x08\x10\n\r\n\x05\x04\x15\x02\r\x05\x12\x04\xfa\x01\x11\x17\n\r\n\
    \x05\x04\x15\x02\r\x01\x12\x04\xfa\x01\x18.\n\r\n\x05\x04\x15\x02\r\x03\
    \x12\x04\xfa\x0113\n\x0c\n\x04\x04\x15\x02\x0e\x12\x04\xfb\x01\x08.\n\r\
    \n\x05\x04\x15\x02\x0e\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x15\x02\
    \x0e\x05\x12\x04\xfb\x01\x11\x17\n\r\n\x05\x04\x15\x02\x0e\x01\x12\x04\
    \xfb\x01\x18(\n\r\n\x05\x04\x15\x02\x0e\x03\x12\x04\xfb\x01+-\n\x0c\n\
    \x04\x04\x15\x02\x0f\x12\x04\xfc\x01\x08-\n\r\n\x05\x04\x15\x02\x0f\x04\
    \x12\x04\xfc\x01\x08\x10\n\r\n\x05\x04\x15\x02\x0f\x05\x12\x04\xfc\x01\
    \x11\x15\n\r\n\x05\x04\x15\x02\x0f\x01\x12\x04\xfc\x01\x16'\n\r\n\x05\
    \x04\x15\x02\x0f\x03\x12\x04\xfc\x01*,\n\x0c\n\x02\x04\x16\x12\x06\xff\
    \x01\0\x81\x02\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xff\x01\x08%\n\x0c\n\
    \x04\x04\x16\x02\0\x12\x04\x80\x02\x08@\n\r\n\x05\x04\x16\x02\0\x04\x12\
    \x04\x80\x02\x08\x10\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x80\x02\x113\n\
    \r\n\x05\x04\x16\x02\0\x01\x12\x04\x80\x024;\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\x80\x02>?\n\x0c\n\x02\x04\x17\x12\x06\x83\x02\0\x86\x02\x01\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\x83\x02\x08\x15\n\x0c\n\x04\x04\x17\x02\0\
    \x12\x04\x84\x02\x08*\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\x84\x02\x08\
    \x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x84\x02\x11\x17\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\x84\x02\x18%\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\
    \x84\x02()\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x85\x02\x08-\n\r\n\x05\
    \x04\x17\x02\x01\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x17\x02\x01\
    \x06\x12\x04\x85\x02\x11\x1e\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x85\
    \x02\x1f(\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x85\x02+,\n\x0c\n\x02\
    \x04\x18\x12\x06\x88\x02\0\x8a\x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \x88\x02\x08\x1d\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x89\x02\x08@\n\r\n\
    \x05\x04\x18\x02\0\x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\x04\x18\x02\0\
    \x06\x12\x04\x89\x02\x113\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x89\x024;\
    \n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x89\x02>?\n\x0c\n\x02\x04\x19\x12\
    \x06\x8c\x02\0\x92\x02\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\x8c\x02\x08\
    \x1d\n\x0c\n\x04\x04\x19\x02\0\x12\x04\x8d\x02\x08%\n\r\n\x05\x04\x19\
    \x02\0\x04\x12\x04\x8d\x02\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\
    \x8d\x02\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x8d\x02\x18\x20\n\r\
    \n\x05\x04\x19\x02\0\x03\x12\x04\x8d\x02#$\n\x0c\n\x04\x04\x19\x02\x01\
    \x12\x04\x8e\x02\x08+\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\x8e\x02\x08\
    \x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\x8e\x02\x11\x17\n\r\n\x05\x04\
    \x19\x02\x01\x01\x12\x04\x8e\x02\x18&\n\r\n\x05\x04\x19\x02\x01\x03\x12\
    \x04\x8e\x02)*\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\x8f\x02\x08%\n\r\n\
    \x05\x04\x19\x02\x02\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\x04\x19\x02\
    \x02\x05\x12\x04\x8f\x02\x11\x17\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\
    \x8f\x02\x18\x20\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\x8f\x02#$\n\x0c\n\
    \x04\x04\x19\x02\x03\x12\x04\x90\x02\x08-\n\r\n\x05\x04\x19\x02\x03\x04\
    \x12\x04\x90\x02\x08\x10\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\x90\x02\
    \x11\x18\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\x90\x02\x19(\n\r\n\x05\
    \x04\x19\x02\x03\x03\x12\x04\x90\x02+,\n\x0c\n\x04\x04\x19\x02\x04\x12\
    \x04\x91\x02\x083\n\r\n\x05\x04\x19\x02\x04\x04\x12\x04\x91\x02\x08\x10\
    \n\r\n\x05\x04\x19\x02\x04\x05\x12\x04\x91\x02\x11\x18\n\r\n\x05\x04\x19\
    \x02\x04\x01\x12\x04\x91\x02\x19.\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\
    \x91\x0212\n\x0c\n\x02\x04\x1a\x12\x06\x94\x02\0\x96\x02\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\x94\x02\x08%\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x95\
    \x02\x080\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\
    \x04\x1a\x02\0\x06\x12\x04\x95\x02\x11$\n\r\n\x05\x04\x1a\x02\0\x01\x12\
    \x04\x95\x02%+\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x95\x02./\n\x0c\n\x02\
    \x04\x1b\x12\x06\x98\x02\0\x9a\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\
    \x98\x02\x08*\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x99\x02\x08$\n\r\n\x05\
    \x04\x1b\x02\0\x04\x12\x04\x99\x02\x08\x10\n\r\n\x05\x04\x1b\x02\0\x05\
    \x12\x04\x99\x02\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x99\x02\x18\
    \x1f\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x99\x02\"#\n\x0c\n\x02\x04\x1c\
    \x12\x06\x9c\x02\0\x9e\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x9c\x02\
    \x08+\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\x9d\x02\x08@\n\r\n\x05\x04\x1c\
    \x02\0\x04\x12\x04\x9d\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\
    \x9d\x02\x113\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\x9d\x024;\n\r\n\x05\
    \x04\x1c\x02\0\x03\x12\x04\x9d\x02>?\n\x0c\n\x02\x04\x1d\x12\x06\xa0\x02\
    \0\xa2\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xa0\x02\x08*\n\x0c\n\x04\
    \x04\x1d\x02\0\x12\x04\xa1\x02\x08*\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\
    \xa1\x02\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xa1\x02\x11\x17\n\r\
    \n\x05\x04\x1d\x02\0\x01\x12\x04\xa1\x02\x18%\n\r\n\x05\x04\x1d\x02\0\
    \x03\x12\x04\xa1\x02()\n\x0c\n\x02\x04\x1e\x12\x06\xa4\x02\0\xa8\x02\x01\
    \n\x0b\n\x03\x04\x1e\x01\x12\x04\xa4\x02\x080\n\x0c\n\x04\x04\x1e\x02\0\
    \x12\x04\xa5\x02\x08+\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xa5\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xa5\x02\x11\x17\n\r\n\x05\x04\
    \x1e\x02\0\x01\x12\x04\xa5\x02\x18&\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xa5\x02)*\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xa6\x02\x08(\n\r\n\x05\
    \x04\x1e\x02\x01\x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\
    \x05\x12\x04\xa6\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xa6\
    \x02\x18#\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xa6\x02&'\n\x0c\n\x04\
    \x04\x1e\x02\x02\x12\x04\xa7\x02\x08)\n\r\n\x05\x04\x1e\x02\x02\x04\x12\
    \x04\xa7\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xa7\x02\x11\
    \x17\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xa7\x02\x18$\n\r\n\x05\x04\
    \x1e\x02\x02\x03\x12\x04\xa7\x02'(\n\x0c\n\x02\x04\x1f\x12\x06\xaa\x02\0\
    \xac\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xaa\x02\x08+\n\x0c\n\x04\
    \x04\x1f\x02\0\x12\x04\xab\x02\x08I\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\
    \xab\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xab\x02\x119\n\r\n\
    \x05\x04\x1f\x02\0\x01\x12\x04\xab\x02:D\n\r\n\x05\x04\x1f\x02\0\x03\x12\
    \x04\xab\x02GH\n\x0c\n\x02\x04\x20\x12\x06\xae\x02\0\xb1\x02\x01\n\x0b\n\
    \x03\x04\x20\x01\x12\x04\xae\x02\x08(\n\x0c\n\x04\x04\x20\x02\0\x12\x04\
    \xaf\x02\x08*\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xaf\x02\x08\x10\n\r\n\
    \x05\x04\x20\x02\0\x05\x12\x04\xaf\x02\x11\x17\n\r\n\x05\x04\x20\x02\0\
    \x01\x12\x04\xaf\x02\x18%\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xaf\x02()\
    \n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xb0\x02\x08+\n\r\n\x05\x04\x20\x02\
    \x01\x04\x12\x04\xb0\x02\x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\
    \xb0\x02\x11\x17\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xb0\x02\x18&\n\r\
    \n\x05\x04\x20\x02\x01\x03\x12\x04\xb0\x02)*\n\x0c\n\x02\x04!\x12\x06\
    \xb3\x02\0\xc4\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\xb3\x02\x08.\n\x0c\n\
    \x04\x04!\x02\0\x12\x04\xb4\x02\x08&\n\r\n\x05\x04!\x02\0\x04\x12\x04\
    \xb4\x02\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\xb4\x02\x11\x18\n\r\n\
    \x05\x04!\x02\0\x01\x12\x04\xb4\x02\x19!\n\r\n\x05\x04!\x02\0\x03\x12\
    \x04\xb4\x02$%\n\x0c\n\x04\x04!\x02\x01\x12\x04\xb5\x02\x08+\n\r\n\x05\
    \x04!\x02\x01\x04\x12\x04\xb5\x02\x08\x10\n\r\n\x05\x04!\x02\x01\x05\x12\
    \x04\xb5\x02\x11\x17\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xb5\x02\x18&\n\r\
    \n\x05\x04!\x02\x01\x03\x12\x04\xb5\x02)*\n\x0c\n\x04\x04!\x02\x02\x12\
    \x04\xb6\x02\x08'\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xb6\x02\x08\x10\n\r\
    \n\x05\x04!\x02\x02\x05\x12\x04\xb6\x02\x11\x17\n\r\n\x05\x04!\x02\x02\
    \x01\x12\x04\xb6\x02\x18\"\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xb6\x02%&\
    \n\x0c\n\x04\x04!\x02\x03\x12\x04\xb7\x02\x08)\n\r\n\x05\x04!\x02\x03\
    \x04\x12\x04\xb7\x02\x08\x10\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xb7\x02\
    \x11\x17\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xb7\x02\x18$\n\r\n\x05\x04!\
    \x02\x03\x03\x12\x04\xb7\x02'(\n\x0c\n\x04\x04!\x02\x04\x12\x04\xb8\x02\
    \x08.\n\r\n\x05\x04!\x02\x04\x04\x12\x04\xb8\x02\x08\x10\n\r\n\x05\x04!\
    \x02\x04\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04!\x02\x04\x01\x12\x04\
    \xb8\x02\x18)\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xb8\x02,-\n\x0c\n\x04\
    \x04!\x02\x05\x12\x04\xb9\x02\x08(\n\r\n\x05\x04!\x02\x05\x04\x12\x04\
    \xb9\x02\x08\x10\n\r\n\x05\x04!\x02\x05\x05\x12\x04\xb9\x02\x11\x17\n\r\
    \n\x05\x04!\x02\x05\x01\x12\x04\xb9\x02\x18#\n\r\n\x05\x04!\x02\x05\x03\
    \x12\x04\xb9\x02&'\n\x0c\n\x04\x04!\x02\x06\x12\x04\xba\x02\x08,\n\r\n\
    \x05\x04!\x02\x06\x04\x12\x04\xba\x02\x08\x10\n\r\n\x05\x04!\x02\x06\x05\
    \x12\x04\xba\x02\x11\x17\n\r\n\x05\x04!\x02\x06\x01\x12\x04\xba\x02\x18'\
    \n\r\n\x05\x04!\x02\x06\x03\x12\x04\xba\x02*+\n\x0c\n\x04\x04!\x02\x07\
    \x12\x04\xbb\x02\x08-\n\r\n\x05\x04!\x02\x07\x04\x12\x04\xbb\x02\x08\x10\
    \n\r\n\x05\x04!\x02\x07\x05\x12\x04\xbb\x02\x11\x17\n\r\n\x05\x04!\x02\
    \x07\x01\x12\x04\xbb\x02\x18(\n\r\n\x05\x04!\x02\x07\x03\x12\x04\xbb\x02\
    +,\n\x0c\n\x04\x04!\x02\x08\x12\x04\xbc\x02\x08*\n\r\n\x05\x04!\x02\x08\
    \x04\x12\x04\xbc\x02\x08\x10\n\r\n\x05\x04!\x02\x08\x05\x12\x04\xbc\x02\
    \x11\x17\n\r\n\x05\x04!\x02\x08\x01\x12\x04\xbc\x02\x18%\n\r\n\x05\x04!\
    \x02\x08\x03\x12\x04\xbc\x02()\n\x0c\n\x04\x04!\x02\t\x12\x04\xbd\x02\
    \x08(\n\r\n\x05\x04!\x02\t\x04\x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04!\
    \x02\t\x05\x12\x04\xbd\x02\x11\x15\n\r\n\x05\x04!\x02\t\x01\x12\x04\xbd\
    \x02\x16\"\n\r\n\x05\x04!\x02\t\x03\x12\x04\xbd\x02%'\n\x0c\n\x04\x04!\
    \x02\n\x12\x04\xbe\x02\x084\n\r\n\x05\x04!\x02\n\x04\x12\x04\xbe\x02\x08\
    \x10\n\r\n\x05\x04!\x02\n\x05\x12\x04\xbe\x02\x11\x17\n\r\n\x05\x04!\x02\
    \n\x01\x12\x04\xbe\x02\x18.\n\r\n\x05\x04!\x02\n\x03\x12\x04\xbe\x0213\n\
    \x0c\n\x04\x04!\x02\x0b\x12\x04\xbf\x02\x081\n\r\n\x05\x04!\x02\x0b\x04\
    \x12\x04\xbf\x02\x08\x10\n\r\n\x05\x04!\x02\x0b\x05\x12\x04\xbf\x02\x11\
    \x17\n\r\n\x05\x04!\x02\x0b\x01\x12\x04\xbf\x02\x18+\n\r\n\x05\x04!\x02\
    \x0b\x03\x12\x04\xbf\x02.0\n\x0c\n\x04\x04!\x02\x0c\x12\x04\xc0\x02\x083\
    \n\r\n\x05\x04!\x02\x0c\x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04!\x02\
    \x0c\x05\x12\x04\xc0\x02\x11\x17\n\r\n\x05\x04!\x02\x0c\x01\x12\x04\xc0\
    \x02\x18-\n\r\n\x05\x04!\x02\x0c\x03\x12\x04\xc0\x0202\n\x0c\n\x04\x04!\
    \x02\r\x12\x04\xc1\x02\x08-\n\r\n\x05\x04!\x02\r\x04\x12\x04\xc1\x02\x08\
    \x10\n\r\n\x05\x04!\x02\r\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04!\x02\
    \r\x01\x12\x04\xc1\x02\x18'\n\r\n\x05\x04!\x02\r\x03\x12\x04\xc1\x02*,\n\
    \x0c\n\x04\x04!\x02\x0e\x12\x04\xc2\x02\x08.\n\r\n\x05\x04!\x02\x0e\x04\
    \x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04!\x02\x0e\x05\x12\x04\xc2\x02\x11\
    \x17\n\r\n\x05\x04!\x02\x0e\x01\x12\x04\xc2\x02\x18(\n\r\n\x05\x04!\x02\
    \x0e\x03\x12\x04\xc2\x02+-\n\x0c\n\x04\x04!\x02\x0f\x12\x04\xc3\x02\x08-\
    \n\r\n\x05\x04!\x02\x0f\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04!\x02\
    \x0f\x05\x12\x04\xc3\x02\x11\x15\n\r\n\x05\x04!\x02\x0f\x01\x12\x04\xc3\
    \x02\x16'\n\r\n\x05\x04!\x02\x0f\x03\x12\x04\xc3\x02*,\n\x0c\n\x02\x04\"\
    \x12\x06\xc6\x02\0\xc8\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xc6\x02\x08\
    )\n\x0c\n\x04\x04\"\x02\0\x12\x04\xc7\x02\x08D\n\r\n\x05\x04\"\x02\0\x04\
    \x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\"\x02\0\x06\x12\x04\xc7\x02\x117\
    \n\r\n\x05\x04\"\x02\0\x01\x12\x04\xc7\x028?\n\r\n\x05\x04\"\x02\0\x03\
    \x12\x04\xc7\x02BC\n\x0c\n\x02\x04#\x12\x06\xca\x02\0\xd8\x02\x01\n\x0b\
    \n\x03\x04#\x01\x12\x04\xca\x02\x08\x20\n\x0e\n\x04\x04#\x03\0\x12\x06\
    \xcb\x02\x08\xcf\x02\t\n\r\n\x05\x04#\x03\0\x01\x12\x04\xcb\x02\x10\x20\
    \n\x0e\n\x06\x04#\x03\0\x02\0\x12\x04\xcc\x02\x102\n\x0f\n\x07\x04#\x03\
    \0\x02\0\x04\x12\x04\xcc\x02\x10\x18\n\x0f\n\x07\x04#\x03\0\x02\0\x05\
    \x12\x04\xcc\x02\x19\x1f\n\x0f\n\x07\x04#\x03\0\x02\0\x01\x12\x04\xcc\
    \x02\x20-\n\x0f\n\x07\x04#\x03\0\x02\0\x03\x12\x04\xcc\x0201\n\x0e\n\x06\
    \x04#\x03\0\x02\x01\x12\x04\xcd\x02\x10)\n\x0f\n\x07\x04#\x03\0\x02\x01\
    \x04\x12\x04\xcd\x02\x10\x18\n\x0f\n\x07\x04#\x03\0\x02\x01\x05\x12\x04\
    \xcd\x02\x19\x1f\n\x0f\n\x07\x04#\x03\0\x02\x01\x01\x12\x04\xcd\x02\x20$\
    \n\x0f\n\x07\x04#\x03\0\x02\x01\x03\x12\x04\xcd\x02'(\n\x0e\n\x06\x04#\
    \x03\0\x02\x02\x12\x04\xce\x02\x101\n\x0f\n\x07\x04#\x03\0\x02\x02\x04\
    \x12\x04\xce\x02\x10\x18\n\x0f\n\x07\x04#\x03\0\x02\x02\x05\x12\x04\xce\
    \x02\x19\x20\n\x0f\n\x07\x04#\x03\0\x02\x02\x01\x12\x04\xce\x02!,\n\x0f\
    \n\x07\x04#\x03\0\x02\x02\x03\x12\x04\xce\x02/0\n\x0c\n\x04\x04#\x02\0\
    \x12\x04\xd1\x02\x081\n\r\n\x05\x04#\x02\0\x04\x12\x04\xd1\x02\x08\x10\n\
    \r\n\x05\x04#\x02\0\x05\x12\x04\xd1\x02\x11\x17\n\r\n\x05\x04#\x02\0\x01\
    \x12\x04\xd1\x02\x18,\n\r\n\x05\x04#\x02\0\x03\x12\x04\xd1\x02/0\n\x0c\n\
    \x04\x04#\x02\x01\x12\x04\xd2\x02\x08+\n\r\n\x05\x04#\x02\x01\x04\x12\
    \x04\xd2\x02\x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xd2\x02\x11\x17\
    \n\r\n\x05\x04#\x02\x01\x01\x12\x04\xd2\x02\x18&\n\r\n\x05\x04#\x02\x01\
    \x03\x12\x04\xd2\x02)*\n\x0c\n\x04\x04#\x02\x02\x12\x04\xd3\x02\x08+\n\r\
    \n\x05\x04#\x02\x02\x04\x12\x04\xd3\x02\x08\x10\n\r\n\x05\x04#\x02\x02\
    \x05\x12\x04\xd3\x02\x11\x17\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xd3\x02\
    \x18&\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xd3\x02)*\n\x0c\n\x04\x04#\x02\
    \x03\x12\x04\xd4\x02\x08F\n\r\n\x05\x04#\x02\x03\x04\x12\x04\xd4\x02\x08\
    \x10\n\r\n\x05\x04#\x02\x03\x06\x12\x04\xd4\x02\x11,\n\r\n\x05\x04#\x02\
    \x03\x01\x12\x04\xd4\x02-A\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xd4\x02DE\
    \n\x0c\n\x04\x04#\x02\x04\x12\x04\xd5\x02\x08(\n\r\n\x05\x04#\x02\x04\
    \x04\x12\x04\xd5\x02\x08\x10\n\r\n\x05\x04#\x02\x04\x05\x12\x04\xd5\x02\
    \x11\x15\n\r\n\x05\x04#\x02\x04\x01\x12\x04\xd5\x02\x16#\n\r\n\x05\x04#\
    \x02\x04\x03\x12\x04\xd5\x02&'\n\x0c\n\x04\x04#\x02\x05\x12\x04\xd6\x02\
    \x08S\n\r\n\x05\x04#\x02\x05\x04\x12\x04\xd6\x02\x08\x10\n\r\n\x05\x04#\
    \x02\x05\x06\x12\x04\xd6\x02\x11:\n\r\n\x05\x04#\x02\x05\x01\x12\x04\xd6\
    \x02;N\n\r\n\x05\x04#\x02\x05\x03\x12\x04\xd6\x02QR\n\x0c\n\x04\x04#\x02\
    \x06\x12\x04\xd7\x02\x082\n\r\n\x05\x04#\x02\x06\x04\x12\x04\xd7\x02\x08\
    \x10\n\r\n\x05\x04#\x02\x06\x06\x12\x04\xd7\x02\x11#\n\r\n\x05\x04#\x02\
    \x06\x01\x12\x04\xd7\x02$-\n\r\n\x05\x04#\x02\x06\x03\x12\x04\xd7\x0201\
    \n\x0c\n\x02\x04$\x12\x06\xda\x02\0\xdc\x02\x01\n\x0b\n\x03\x04$\x01\x12\
    \x04\xda\x02\x08(\n\x0c\n\x04\x04$\x02\0\x12\x04\xdb\x02\x080\n\r\n\x05\
    \x04$\x02\0\x04\x12\x04\xdb\x02\x08\x10\n\r\n\x05\x04$\x02\0\x06\x12\x04\
    \xdb\x02\x11$\n\r\n\x05\x04$\x02\0\x01\x12\x04\xdb\x02%+\n\r\n\x05\x04$\
    \x02\0\x03\x12\x04\xdb\x02./\n\x0c\n\x02\x04%\x12\x06\xde\x02\0\xe5\x02\
    \x01\n\x0b\n\x03\x04%\x01\x12\x04\xde\x02\x08\x19\n\x0c\n\x04\x04%\x02\0\
    \x12\x04\xdf\x02\x08'\n\r\n\x05\x04%\x02\0\x04\x12\x04\xdf\x02\x08\x10\n\
    \r\n\x05\x04%\x02\0\x05\x12\x04\xdf\x02\x11\x17\n\r\n\x05\x04%\x02\0\x01\
    \x12\x04\xdf\x02\x18\"\n\r\n\x05\x04%\x02\0\x03\x12\x04\xdf\x02%&\n\x0c\
    \n\x04\x04%\x02\x01\x12\x04\xe0\x02\x08+\n\r\n\x05\x04%\x02\x01\x04\x12\
    \x04\xe0\x02\x08\x10\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xe0\x02\x11\x17\
    \n\r\n\x05\x04%\x02\x01\x01\x12\x04\xe0\x02\x18&\n\r\n\x05\x04%\x02\x01\
    \x03\x12\x04\xe0\x02)*\n\x0c\n\x04\x04%\x02\x02\x12\x04\xe1\x02\x08:\n\r\
    \n\x05\x04%\x02\x02\x04\x12\x04\xe1\x02\x08\x10\n\r\n\x05\x04%\x02\x02\
    \x06\x12\x04\xe1\x02\x11\"\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xe1\x02#5\
    \n\r\n\x05\x04%\x02\x02\x03\x12\x04\xe1\x0289\n\x0c\n\x04\x04%\x02\x03\
    \x12\x04\xe2\x02\x08'\n\r\n\x05\x04%\x02\x03\x04\x12\x04\xe2\x02\x08\x10\
    \n\r\n\x05\x04%\x02\x03\x06\x12\x04\xe2\x02\x11\x1d\n\r\n\x05\x04%\x02\
    \x03\x01\x12\x04\xe2\x02\x1e\"\n\r\n\x05\x04%\x02\x03\x03\x12\x04\xe2\
    \x02%&\n\x0c\n\x04\x04%\x02\x04\x12\x04\xe3\x02\x08&\n\r\n\x05\x04%\x02\
    \x04\x04\x12\x04\xe3\x02\x08\x10\n\r\n\x05\x04%\x02\x04\x05\x12\x04\xe3\
    \x02\x11\x17\n\r\n\x05\x04%\x02\x04\x01\x12\x04\xe3\x02\x18!\n\r\n\x05\
    \x04%\x02\x04\x03\x12\x04\xe3\x02$%\n\x0c\n\x04\x04%\x02\x05\x12\x04\xe4\
    \x02\x087\n\r\n\x05\x04%\x02\x05\x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\
    \x04%\x02\x05\x06\x12\x04\xe4\x02\x11\"\n\r\n\x05\x04%\x02\x05\x01\x12\
    \x04\xe4\x02#2\n\r\n\x05\x04%\x02\x05\x03\x12\x04\xe4\x0256\n\x0c\n\x02\
    \x04&\x12\x06\xe7\x02\0\xe9\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xe7\x02\
    \x08#\n\x0c\n\x04\x04&\x02\0\x12\x04\xe8\x02\x08&\n\r\n\x05\x04&\x02\0\
    \x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\xe8\x02\
    \x11\x15\n\r\n\x05\x04&\x02\0\x01\x12\x04\xe8\x02\x16!\n\r\n\x05\x04&\
    \x02\0\x03\x12\x04\xe8\x02$%\n\x0c\n\x02\x04'\x12\x06\xeb\x02\0\xed\x02\
    \x01\n\x0b\n\x03\x04'\x01\x12\x04\xeb\x02\x08\x1e\n\x0c\n\x04\x04'\x02\0\
    \x12\x04\xec\x02\x080\n\r\n\x05\x04'\x02\0\x04\x12\x04\xec\x02\x08\x10\n\
    \r\n\x05\x04'\x02\0\x05\x12\x04\xec\x02\x11\x18\n\r\n\x05\x04'\x02\0\x01\
    \x12\x04\xec\x02\x19+\n\r\n\x05\x04'\x02\0\x03\x12\x04\xec\x02./\n\x0c\n\
    \x02\x04(\x12\x06\xef\x02\0\xf2\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xef\
    \x02\x08\"\n\x0c\n\x04\x04(\x02\0\x12\x04\xf0\x02\x08.\n\r\n\x05\x04(\
    \x02\0\x04\x12\x04\xf0\x02\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xf0\
    \x02\x11\x18\n\r\n\x05\x04(\x02\0\x01\x12\x04\xf0\x02\x19)\n\r\n\x05\x04\
    (\x02\0\x03\x12\x04\xf0\x02,-\n\x0c\n\x04\x04(\x02\x01\x12\x04\xf1\x02\
    \x08.\n\r\n\x05\x04(\x02\x01\x04\x12\x04\xf1\x02\x08\x10\n\r\n\x05\x04(\
    \x02\x01\x05\x12\x04\xf1\x02\x11\x18\n\r\n\x05\x04(\x02\x01\x01\x12\x04\
    \xf1\x02\x19)\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xf1\x02,-\n\x0c\n\x02\
    \x04)\x12\x06\xf4\x02\0\xf6\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xf4\x02\
    \x08\"\n\x0c\n\x04\x04)\x02\0\x12\x04\xf5\x02\x08\x1f\n\r\n\x05\x04)\x02\
    \0\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\xf5\x02\
    \x11\x15\n\r\n\x05\x04)\x02\0\x01\x12\x04\xf5\x02\x16\x1a\n\r\n\x05\x04)\
    \x02\0\x03\x12\x04\xf5\x02\x1d\x1e\n\x0c\n\x02\x04*\x12\x06\xf8\x02\0\
    \xfa\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\xf8\x02\x08\x20\n\x0c\n\x04\
    \x04*\x02\0\x12\x04\xf9\x02\x08,\n\r\n\x05\x04*\x02\0\x04\x12\x04\xf9\
    \x02\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\xf9\x02\x11\x18\n\r\n\x05\
    \x04*\x02\0\x01\x12\x04\xf9\x02\x19'\n\r\n\x05\x04*\x02\0\x03\x12\x04\
    \xf9\x02*+\n\x0c\n\x02\x04+\x12\x06\xfc\x02\0\xff\x02\x01\n\x0b\n\x03\
    \x04+\x01\x12\x04\xfc\x02\x08\"\n\x0c\n\x04\x04+\x02\0\x12\x04\xfd\x02\
    \x080\n\r\n\x05\x04+\x02\0\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04+\
    \x02\0\x05\x12\x04\xfd\x02\x11\x18\n\r\n\x05\x04+\x02\0\x01\x12\x04\xfd\
    \x02\x19+\n\r\n\x05\x04+\x02\0\x03\x12\x04\xfd\x02./\n\x0c\n\x04\x04+\
    \x02\x01\x12\x04\xfe\x02\x08!\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xfe\x02\
    \x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xfe\x02\x11\x15\n\r\n\x05\
    \x04+\x02\x01\x01\x12\x04\xfe\x02\x16\x1c\n\r\n\x05\x04+\x02\x01\x03\x12\
    \x04\xfe\x02\x1f\x20\n\x0c\n\x02\x04,\x12\x06\x81\x03\0\x83\x03\x01\n\
    \x0b\n\x03\x04,\x01\x12\x04\x81\x03\x08\x1f\n\x0c\n\x04\x04,\x02\0\x12\
    \x04\x82\x03\x082\n\r\n\x05\x04,\x02\0\x04\x12\x04\x82\x03\x08\x10\n\r\n\
    \x05\x04,\x02\0\x06\x12\x04\x82\x03\x11&\n\r\n\x05\x04,\x02\0\x01\x12\
    \x04\x82\x03'-\n\r\n\x05\x04,\x02\0\x03\x12\x04\x82\x0301\n\x0c\n\x02\
    \x04-\x12\x06\x85\x03\0\x96\x03\x01\n\x0b\n\x03\x04-\x01\x12\x04\x85\x03\
    \x08%\n\x0e\n\x04\x04-\x03\0\x12\x06\x86\x03\x08\x8a\x03\t\n\r\n\x05\x04\
    -\x03\0\x01\x12\x04\x86\x03\x10\x14\n\x0e\n\x06\x04-\x03\0\x02\0\x12\x04\
    \x87\x03\x10,\n\x0f\n\x07\x04-\x03\0\x02\0\x04\x12\x04\x87\x03\x10\x18\n\
    \x0f\n\x07\x04-\x03\0\x02\0\x05\x12\x04\x87\x03\x19\x1f\n\x0f\n\x07\x04-\
    \x03\0\x02\0\x01\x12\x04\x87\x03\x20'\n\x0f\n\x07\x04-\x03\0\x02\0\x03\
    \x12\x04\x87\x03*+\n\x0e\n\x06\x04-\x03\0\x02\x01\x12\x04\x88\x03\x10.\n\
    \x0f\n\x07\x04-\x03\0\x02\x01\x04\x12\x04\x88\x03\x10\x18\n\x0f\n\x07\
    \x04-\x03\0\x02\x01\x05\x12\x04\x88\x03\x19\x1f\n\x0f\n\x07\x04-\x03\0\
    \x02\x01\x01\x12\x04\x88\x03\x20)\n\x0f\n\x07\x04-\x03\0\x02\x01\x03\x12\
    \x04\x88\x03,-\n\x0e\n\x06\x04-\x03\0\x02\x02\x12\x04\x89\x03\x10/\n\x0f\
    \n\x07\x04-\x03\0\x02\x02\x04\x12\x04\x89\x03\x10\x18\n\x0f\n\x07\x04-\
    \x03\0\x02\x02\x05\x12\x04\x89\x03\x19\x20\n\x0f\n\x07\x04-\x03\0\x02\
    \x02\x01\x12\x04\x89\x03!*\n\x0f\n\x07\x04-\x03\0\x02\x02\x03\x12\x04\
    \x89\x03-.\n\x0c\n\x04\x04-\x02\0\x12\x04\x8c\x03\x08%\n\r\n\x05\x04-\
    \x02\0\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\x8c\
    \x03\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\x04\x8c\x03\x18\x20\n\r\n\x05\
    \x04-\x02\0\x03\x12\x04\x8c\x03#$\n\x0c\n\x04\x04-\x02\x01\x12\x04\x8d\
    \x03\x08%\n\r\n\x05\x04-\x02\x01\x04\x12\x04\x8d\x03\x08\x10\n\r\n\x05\
    \x04-\x02\x01\x05\x12\x04\x8d\x03\x11\x17\n\r\n\x05\x04-\x02\x01\x01\x12\
    \x04\x8d\x03\x18\x20\n\r\n\x05\x04-\x02\x01\x03\x12\x04\x8d\x03#$\n\x0c\
    \n\x04\x04-\x02\x02\x12\x04\x8e\x03\x08-\n\r\n\x05\x04-\x02\x02\x04\x12\
    \x04\x8e\x03\x08\x10\n\r\n\x05\x04-\x02\x02\x05\x12\x04\x8e\x03\x11\x18\
    \n\r\n\x05\x04-\x02\x02\x01\x12\x04\x8e\x03\x19(\n\r\n\x05\x04-\x02\x02\
    \x03\x12\x04\x8e\x03+,\n\x0c\n\x04\x04-\x02\x03\x12\x04\x8f\x03\x08'\n\r\
    \n\x05\x04-\x02\x03\x04\x12\x04\x8f\x03\x08\x10\n\r\n\x05\x04-\x02\x03\
    \x05\x12\x04\x8f\x03\x11\x17\n\r\n\x05\x04-\x02\x03\x01\x12\x04\x8f\x03\
    \x18\"\n\r\n\x05\x04-\x02\x03\x03\x12\x04\x8f\x03%&\n\x0c\n\x04\x04-\x02\
    \x04\x12\x04\x90\x03\x08(\n\r\n\x05\x04-\x02\x04\x04\x12\x04\x90\x03\x08\
    \x10\n\r\n\x05\x04-\x02\x04\x05\x12\x04\x90\x03\x11\x17\n\r\n\x05\x04-\
    \x02\x04\x01\x12\x04\x90\x03\x18#\n\r\n\x05\x04-\x02\x04\x03\x12\x04\x90\
    \x03&'\n\x0c\n\x04\x04-\x02\x05\x12\x04\x91\x03\x08&\n\r\n\x05\x04-\x02\
    \x05\x04\x12\x04\x91\x03\x08\x10\n\r\n\x05\x04-\x02\x05\x05\x12\x04\x91\
    \x03\x11\x17\n\r\n\x05\x04-\x02\x05\x01\x12\x04\x91\x03\x18!\n\r\n\x05\
    \x04-\x02\x05\x03\x12\x04\x91\x03$%\n\x0c\n\x04\x04-\x02\x06\x12\x04\x92\
    \x03\x08(\n\r\n\x05\x04-\x02\x06\x04\x12\x04\x92\x03\x08\x10\n\r\n\x05\
    \x04-\x02\x06\x05\x12\x04\x92\x03\x11\x17\n\r\n\x05\x04-\x02\x06\x01\x12\
    \x04\x92\x03\x18#\n\r\n\x05\x04-\x02\x06\x03\x12\x04\x92\x03&'\n\x0c\n\
    \x04\x04-\x02\x07\x12\x04\x93\x03\x08(\n\r\n\x05\x04-\x02\x07\x04\x12\
    \x04\x93\x03\x08\x10\n\r\n\x05\x04-\x02\x07\x05\x12\x04\x93\x03\x11\x17\
    \n\r\n\x05\x04-\x02\x07\x01\x12\x04\x93\x03\x18#\n\r\n\x05\x04-\x02\x07\
    \x03\x12\x04\x93\x03&'\n\x0c\n\x04\x04-\x02\x08\x12\x04\x94\x03\x08E\n\r\
    \n\x05\x04-\x02\x08\x04\x12\x04\x94\x03\x08\x10\n\r\n\x05\x04-\x02\x08\
    \x06\x12\x04\x94\x03\x113\n\r\n\x05\x04-\x02\x08\x01\x12\x04\x94\x034@\n\
    \r\n\x05\x04-\x02\x08\x03\x12\x04\x94\x03CD\n\x0c\n\x04\x04-\x02\t\x12\
    \x04\x95\x03\x08C\n\r\n\x05\x04-\x02\t\x04\x12\x04\x95\x03\x08\x10\n\r\n\
    \x05\x04-\x02\t\x06\x12\x04\x95\x03\x113\n\r\n\x05\x04-\x02\t\x01\x12\
    \x04\x95\x034=\n\r\n\x05\x04-\x02\t\x03\x12\x04\x95\x03@B\n\x0c\n\x02\
    \x04.\x12\x06\x98\x03\0\x9d\x03\x01\n\x0b\n\x03\x04.\x01\x12\x04\x98\x03\
    \x08$\n\x0c\n\x04\x04.\x02\0\x12\x04\x99\x03\x08%\n\r\n\x05\x04.\x02\0\
    \x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\x99\x03\
    \x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\x99\x03\x18\x20\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\x99\x03#$\n\x0c\n\x04\x04.\x02\x01\x12\x04\x9a\x03\
    \x08'\n\r\n\x05\x04.\x02\x01\x04\x12\x04\x9a\x03\x08\x10\n\r\n\x05\x04.\
    \x02\x01\x05\x12\x04\x9a\x03\x11\x17\n\r\n\x05\x04.\x02\x01\x01\x12\x04\
    \x9a\x03\x18\"\n\r\n\x05\x04.\x02\x01\x03\x12\x04\x9a\x03%&\n\x0c\n\x04\
    \x04.\x02\x02\x12\x04\x9b\x03\x08%\n\r\n\x05\x04.\x02\x02\x04\x12\x04\
    \x9b\x03\x08\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\x9b\x03\x11\x17\n\r\
    \n\x05\x04.\x02\x02\x01\x12\x04\x9b\x03\x18\x20\n\r\n\x05\x04.\x02\x02\
    \x03\x12\x04\x9b\x03#$\n\x0c\n\x04\x04.\x02\x03\x12\x04\x9c\x03\x08@\n\r\
    \n\x05\x04.\x02\x03\x04\x12\x04\x9c\x03\x08\x10\n\r\n\x05\x04.\x02\x03\
    \x06\x12\x04\x9c\x03\x11.\n\r\n\x05\x04.\x02\x03\x01\x12\x04\x9c\x03/;\n\
    \r\n\x05\x04.\x02\x03\x03\x12\x04\x9c\x03>?\n\x0c\n\x02\x04/\x12\x06\x9f\
    \x03\0\xa2\x03\x01\n\x0b\n\x03\x04/\x01\x12\x04\x9f\x03\x08\x20\n\x0c\n\
    \x04\x04/\x02\0\x12\x04\xa0\x03\x08+\n\r\n\x05\x04/\x02\0\x04\x12\x04\
    \xa0\x03\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xa0\x03\x11\x17\n\r\n\
    \x05\x04/\x02\0\x01\x12\x04\xa0\x03\x18&\n\r\n\x05\x04/\x02\0\x03\x12\
    \x04\xa0\x03)*\n\x0c\n\x04\x04/\x02\x01\x12\x04\xa1\x03\x08:\n\r\n\x05\
    \x04/\x02\x01\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04/\x02\x01\x06\x12\
    \x04\xa1\x03\x11-\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xa1\x03.5\n\r\n\x05\
    \x04/\x02\x01\x03\x12\x04\xa1\x0389\n\x0c\n\x02\x040\x12\x06\xa4\x03\0\
    \xa5\x03\x01\n\x0b\n\x03\x040\x01\x12\x04\xa4\x03\x08\x1e\n\x0c\n\x02\
    \x041\x12\x06\xa7\x03\0\xb2\x03\x01\n\x0b\n\x03\x041\x01\x12\x04\xa7\x03\
    \x08&\n\x0e\n\x04\x041\x03\0\x12\x06\xa8\x03\x08\xaf\x03\t\n\r\n\x05\x04\
    1\x03\0\x01\x12\x04\xa8\x03\x10\x1e\n\x0e\n\x06\x041\x03\0\x02\0\x12\x04\
    \xa9\x03\x10-\n\x0f\n\x07\x041\x03\0\x02\0\x04\x12\x04\xa9\x03\x10\x18\n\
    \x0f\n\x07\x041\x03\0\x02\0\x05\x12\x04\xa9\x03\x19\x1f\n\x0f\n\x07\x041\
    \x03\0\x02\0\x01\x12\x04\xa9\x03\x20(\n\x0f\n\x07\x041\x03\0\x02\0\x03\
    \x12\x04\xa9\x03+,\n\x0e\n\x06\x041\x03\0\x02\x01\x12\x04\xaa\x03\x10.\n\
    \x0f\n\x07\x041\x03\0\x02\x01\x04\x12\x04\xaa\x03\x10\x18\n\x0f\n\x07\
    \x041\x03\0\x02\x01\x05\x12\x04\xaa\x03\x19\x1f\n\x0f\n\x07\x041\x03\0\
    \x02\x01\x01\x12\x04\xaa\x03\x20)\n\x0f\n\x07\x041\x03\0\x02\x01\x03\x12\
    \x04\xaa\x03,-\n\x0e\n\x06\x041\x03\0\x02\x02\x12\x04\xab\x03\x104\n\x0f\
    \n\x07\x041\x03\0\x02\x02\x04\x12\x04\xab\x03\x10\x18\n\x0f\n\x07\x041\
    \x03\0\x02\x02\x05\x12\x04\xab\x03\x19\x1d\n\x0f\n\x07\x041\x03\0\x02\
    \x02\x01\x12\x04\xab\x03\x1e/\n\x0f\n\x07\x041\x03\0\x02\x02\x03\x12\x04\
    \xab\x0323\n\x0e\n\x06\x041\x03\0\x02\x03\x12\x04\xac\x03\x106\n\x0f\n\
    \x07\x041\x03\0\x02\x03\x04\x12\x04\xac\x03\x10\x18\n\x0f\n\x07\x041\x03\
    \0\x02\x03\x05\x12\x04\xac\x03\x19\x1f\n\x0f\n\x07\x041\x03\0\x02\x03\
    \x01\x12\x04\xac\x03\x201\n\x0f\n\x07\x041\x03\0\x02\x03\x03\x12\x04\xac\
    \x0345\n\x0e\n\x06\x041\x03\0\x02\x04\x12\x04\xad\x03\x101\n\x0f\n\x07\
    \x041\x03\0\x02\x04\x04\x12\x04\xad\x03\x10\x18\n\x0f\n\x07\x041\x03\0\
    \x02\x04\x05\x12\x04\xad\x03\x19\x1f\n\x0f\n\x07\x041\x03\0\x02\x04\x01\
    \x12\x04\xad\x03\x20,\n\x0f\n\x07\x041\x03\0\x02\x04\x03\x12\x04\xad\x03\
    /0\n\x0e\n\x06\x041\x03\0\x02\x05\x12\x04\xae\x03\x10H\n\x0f\n\x07\x041\
    \x03\0\x02\x05\x04\x12\x04\xae\x03\x10\x18\n\x0f\n\x07\x041\x03\0\x02\
    \x05\x06\x12\x04\xae\x03\x196\n\x0f\n\x07\x041\x03\0\x02\x05\x01\x12\x04\
    \xae\x037C\n\x0f\n\x07\x041\x03\0\x02\x05\x03\x12\x04\xae\x03FG\n\x0c\n\
    \x04\x041\x02\0\x12\x04\xb1\x03\x08K\n\r\n\x05\x041\x02\0\x04\x12\x04\
    \xb1\x03\x08\x10\n\r\n\x05\x041\x02\0\x06\x12\x04\xb1\x03\x11>\n\r\n\x05\
    \x041\x02\0\x01\x12\x04\xb1\x03?F\n\r\n\x05\x041\x02\0\x03\x12\x04\xb1\
    \x03IJ\n\x0c\n\x02\x042\x12\x06\xb4\x03\0\xb6\x03\x01\n\x0b\n\x03\x042\
    \x01\x12\x04\xb4\x03\x080\n\x0c\n\x04\x042\x02\0\x12\x04\xb5\x03\x08-\n\
    \r\n\x05\x042\x02\0\x04\x12\x04\xb5\x03\x08\x10\n\r\n\x05\x042\x02\0\x05\
    \x12\x04\xb5\x03\x11\x18\n\r\n\x05\x042\x02\0\x01\x12\x04\xb5\x03\x19(\n\
    \r\n\x05\x042\x02\0\x03\x12\x04\xb5\x03+,\n\x0c\n\x02\x043\x12\x06\xb8\
    \x03\0\xbb\x03\x01\n\x0b\n\x03\x043\x01\x12\x04\xb8\x03\x088\n\x0c\n\x04\
    \x043\x02\0\x12\x04\xb9\x03\x08-\n\r\n\x05\x043\x02\0\x04\x12\x04\xb9\
    \x03\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\xb9\x03\x11\x16\n\r\n\x05\
    \x043\x02\0\x01\x12\x04\xb9\x03\x17(\n\r\n\x05\x043\x02\0\x03\x12\x04\
    \xb9\x03+,\n\x0c\n\x04\x043\x02\x01\x12\x04\xba\x03\x08$\n\r\n\x05\x043\
    \x02\x01\x04\x12\x04\xba\x03\x08\x10\n\r\n\x05\x043\x02\x01\x05\x12\x04\
    \xba\x03\x11\x17\n\r\n\x05\x043\x02\x01\x01\x12\x04\xba\x03\x18\x1f\n\r\
    \n\x05\x043\x02\x01\x03\x12\x04\xba\x03\"#\n\x0c\n\x02\x044\x12\x06\xbd\
    \x03\0\xc7\x03\x01\n\x0b\n\x03\x044\x01\x12\x04\xbd\x03\x08)\n\x0c\n\x04\
    \x044\x02\0\x12\x04\xbe\x03\x080\n\r\n\x05\x044\x02\0\x04\x12\x04\xbe\
    \x03\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\x04\xbe\x03\x11\x18\n\r\n\x05\
    \x044\x02\0\x01\x12\x04\xbe\x03\x19+\n\r\n\x05\x044\x02\0\x03\x12\x04\
    \xbe\x03./\n\x0c\n\x04\x044\x02\x01\x12\x04\xbf\x03\x088\n\r\n\x05\x044\
    \x02\x01\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x044\x02\x01\x05\x12\x04\
    \xbf\x03\x11\x18\n\r\n\x05\x044\x02\x01\x01\x12\x04\xbf\x03\x193\n\r\n\
    \x05\x044\x02\x01\x03\x12\x04\xbf\x0367\n\x0c\n\x04\x044\x02\x02\x12\x04\
    \xc0\x03\x089\n\r\n\x05\x044\x02\x02\x04\x12\x04\xc0\x03\x08\x10\n\r\n\
    \x05\x044\x02\x02\x05\x12\x04\xc0\x03\x11\x18\n\r\n\x05\x044\x02\x02\x01\
    \x12\x04\xc0\x03\x194\n\r\n\x05\x044\x02\x02\x03\x12\x04\xc0\x0378\n\x0c\
    \n\x04\x044\x02\x03\x12\x04\xc1\x03\x088\n\r\n\x05\x044\x02\x03\x04\x12\
    \x04\xc1\x03\x08\x10\n\r\n\x05\x044\x02\x03\x05\x12\x04\xc1\x03\x11\x18\
    \n\r\n\x05\x044\x02\x03\x01\x12\x04\xc1\x03\x193\n\r\n\x05\x044\x02\x03\
    \x03\x12\x04\xc1\x0367\n\x0c\n\x04\x044\x02\x04\x12\x04\xc2\x03\x086\n\r\
    \n\x05\x044\x02\x04\x04\x12\x04\xc2\x03\x08\x10\n\r\n\x05\x044\x02\x04\
    \x05\x12\x04\xc2\x03\x11\x18\n\r\n\x05\x044\x02\x04\x01\x12\x04\xc2\x03\
    \x191\n\r\n\x05\x044\x02\x04\x03\x12\x04\xc2\x0345\n\x0c\n\x04\x044\x02\
    \x05\x12\x04\xc3\x03\x08,\n\r\n\x05\x044\x02\x05\x04\x12\x04\xc3\x03\x08\
    \x10\n\r\n\x05\x044\x02\x05\x05\x12\x04\xc3\x03\x11\x16\n\r\n\x05\x044\
    \x02\x05\x01\x12\x04\xc3\x03\x17'\n\r\n\x05\x044\x02\x05\x03\x12\x04\xc3\
    \x03*+\n\x0c\n\x04\x044\x02\x06\x12\x04\xc4\x03\x08*\n\r\n\x05\x044\x02\
    \x06\x04\x12\x04\xc4\x03\x08\x10\n\r\n\x05\x044\x02\x06\x05\x12\x04\xc4\
    \x03\x11\x17\n\r\n\x05\x044\x02\x06\x01\x12\x04\xc4\x03\x18%\n\r\n\x05\
    \x044\x02\x06\x03\x12\x04\xc4\x03()\n\x0c\n\x04\x044\x02\x07\x12\x04\xc5\
    \x03\x08/\n\r\n\x05\x044\x02\x07\x04\x12\x04\xc5\x03\x08\x10\n\r\n\x05\
    \x044\x02\x07\x05\x12\x04\xc5\x03\x11\x16\n\r\n\x05\x044\x02\x07\x01\x12\
    \x04\xc5\x03\x17*\n\r\n\x05\x044\x02\x07\x03\x12\x04\xc5\x03-.\n\x0c\n\
    \x04\x044\x02\x08\x12\x04\xc6\x03\x08.\n\r\n\x05\x044\x02\x08\x04\x12\
    \x04\xc6\x03\x08\x10\n\r\n\x05\x044\x02\x08\x05\x12\x04\xc6\x03\x11\x16\
    \n\r\n\x05\x044\x02\x08\x01\x12\x04\xc6\x03\x17(\n\r\n\x05\x044\x02\x08\
    \x03\x12\x04\xc6\x03+-\n\x0c\n\x02\x045\x12\x06\xc9\x03\0\xca\x03\x01\n\
    \x0b\n\x03\x045\x01\x12\x04\xc9\x03\x08*\n\x0c\n\x02\x046\x12\x06\xcc\
    \x03\0\xcf\x03\x01\n\x0b\n\x03\x046\x01\x12\x04\xcc\x03\x082\n\x0c\n\x04\
    \x046\x02\0\x12\x04\xcd\x03\x081\n\r\n\x05\x046\x02\0\x04\x12\x04\xcd\
    \x03\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xcd\x03\x11\x17\n\r\n\x05\
    \x046\x02\0\x01\x12\x04\xcd\x03\x18,\n\r\n\x05\x046\x02\0\x03\x12\x04\
    \xcd\x03/0\n\x0c\n\x04\x046\x02\x01\x12\x04\xce\x03\x081\n\r\n\x05\x046\
    \x02\x01\x04\x12\x04\xce\x03\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\x04\
    \xce\x03\x11\x15\n\r\n\x05\x046\x02\x01\x01\x12\x04\xce\x03\x16,\n\r\n\
    \x05\x046\x02\x01\x03\x12\x04\xce\x03/0\n\x0c\n\x02\x047\x12\x06\xd1\x03\
    \0\xd2\x03\x01\n\x0b\n\x03\x047\x01\x12\x04\xd1\x03\x08#\n\x0c\n\x02\x04\
    8\x12\x06\xd4\x03\0\xd7\x03\x01\n\x0b\n\x03\x048\x01\x12\x04\xd4\x03\x08\
    \x1c\n\x0c\n\x04\x048\x02\0\x12\x04\xd5\x03\x081\n\r\n\x05\x048\x02\0\
    \x04\x12\x04\xd5\x03\x08\x10\n\r\n\x05\x048\x02\0\x05\x12\x04\xd5\x03\
    \x11\x17\n\r\n\x05\x048\x02\0\x01\x12\x04\xd5\x03\x18,\n\r\n\x05\x048\
    \x02\0\x03\x12\x04\xd5\x03/0\n\x0c\n\x04\x048\x02\x01\x12\x04\xd6\x03\
    \x081\n\r\n\x05\x048\x02\x01\x04\x12\x04\xd6\x03\x08\x10\n\r\n\x05\x048\
    \x02\x01\x05\x12\x04\xd6\x03\x11\x15\n\r\n\x05\x048\x02\x01\x01\x12\x04\
    \xd6\x03\x16,\n\r\n\x05\x048\x02\x01\x03\x12\x04\xd6\x03/0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            deps.push(super::dota_client_enums::file_descriptor().clone());
            deps.push(super::base_gcmessages::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common_lobby::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(63);
            messages.push(CMsgStartFindingMatch::generated_message_descriptor_data());
            messages.push(CMsgStartFindingMatchResult::generated_message_descriptor_data());
            messages.push(CMsgStopFindingMatch::generated_message_descriptor_data());
            messages.push(CMsgPartyBuilderOptions::generated_message_descriptor_data());
            messages.push(CMsgReadyUp::generated_message_descriptor_data());
            messages.push(CMsgReadyUpStatus::generated_message_descriptor_data());
            messages.push(CMsgAbandonCurrentGame::generated_message_descriptor_data());
            messages.push(CMsgLobbyScenarioSave::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbySetDetails::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyCreate::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbySetTeamSlot::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbySetCoach::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyJoinBroadcastChannel::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyCloseBroadcastChannel::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyKick::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyKickFromTeam::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyLeave::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyLaunch::generated_message_descriptor_data());
            messages.push(CMsgApplyTeamToPracticeLobby::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyList::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyListResponseEntry::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyListResponse::generated_message_descriptor_data());
            messages.push(CMsgLobbyList::generated_message_descriptor_data());
            messages.push(CMsgLobbyListResponse::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyJoin::generated_message_descriptor_data());
            messages.push(CMsgPracticeLobbyJoinResponse::generated_message_descriptor_data());
            messages.push(CMsgFriendPracticeLobbyListRequest::generated_message_descriptor_data());
            messages.push(CMsgFriendPracticeLobbyListResponse::generated_message_descriptor_data());
            messages.push(CMsgJoinableCustomGameModesRequest::generated_message_descriptor_data());
            messages.push(CMsgJoinableCustomGameModesResponseEntry::generated_message_descriptor_data());
            messages.push(CMsgJoinableCustomGameModesResponse::generated_message_descriptor_data());
            messages.push(CMsgJoinableCustomLobbiesRequest::generated_message_descriptor_data());
            messages.push(CMsgJoinableCustomLobbiesResponseEntry::generated_message_descriptor_data());
            messages.push(CMsgJoinableCustomLobbiesResponse::generated_message_descriptor_data());
            messages.push(CMsgQuickJoinCustomLobby::generated_message_descriptor_data());
            messages.push(CMsgQuickJoinCustomLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgBotGameCreate::generated_message_descriptor_data());
            messages.push(CMsgDOTAPartyMemberSetCoach::generated_message_descriptor_data());
            messages.push(CMsgDOTASetGroupLeader::generated_message_descriptor_data());
            messages.push(CMsgDOTACancelGroupInvites::generated_message_descriptor_data());
            messages.push(CMsgDOTASetGroupOpenStatus::generated_message_descriptor_data());
            messages.push(CMsgDOTAGroupMergeInvite::generated_message_descriptor_data());
            messages.push(CMsgDOTAGroupMergeResponse::generated_message_descriptor_data());
            messages.push(CMsgDOTAGroupMergeReply::generated_message_descriptor_data());
            messages.push(CMsgSpectatorLobbyGameDetails::generated_message_descriptor_data());
            messages.push(CMsgSetSpectatorLobbyDetails::generated_message_descriptor_data());
            messages.push(CMsgCreateSpectatorLobby::generated_message_descriptor_data());
            messages.push(CMsgSpectatorLobbyList::generated_message_descriptor_data());
            messages.push(CMsgSpectatorLobbyListResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestSteamDatagramTicket::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestSteamDatagramTicketResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientSteamDatagramTicket::generated_message_descriptor_data());
            messages.push(CMsgGCToClientRequestLaneSelection::generated_message_descriptor_data());
            messages.push(CMsgGCToClientRequestLaneSelectionResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientRequestMMInfo::generated_message_descriptor_data());
            messages.push(CMsgClientToGCMMInfo::generated_message_descriptor_data());
            messages.push(cmsg_practice_lobby_set_details::AbilityDraftSpecificDetails::generated_message_descriptor_data());
            messages.push(cmsg_practice_lobby_create::SaveGame::generated_message_descriptor_data());
            messages.push(cmsg_practice_lobby_list_response_entry::CLobbyMember::generated_message_descriptor_data());
            messages.push(cmsg_quick_join_custom_lobby::LegacyRegionPing::generated_message_descriptor_data());
            messages.push(cmsg_spectator_lobby_game_details::Team::generated_message_descriptor_data());
            messages.push(cmsg_spectator_lobby_list_response::SpectatorLobby::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(EStartFindingMatchResult::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
