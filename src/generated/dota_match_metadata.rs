// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_match_metadata.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CDOTAMatchMetadataFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAMatchMetadataFile {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadataFile.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadataFile.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadataFile.metadata)
    pub metadata: ::protobuf::MessageField<CDOTAMatchMetadata>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadataFile.private_metadata)
    pub private_metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadataFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAMatchMetadataFile {
    fn default() -> &'a CDOTAMatchMetadataFile {
        <CDOTAMatchMetadataFile as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAMatchMetadataFile {
    pub fn new() -> CDOTAMatchMetadataFile {
        ::std::default::Default::default()
    }

    // required int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // required uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bytes private_metadata = 5;

    pub fn private_metadata(&self) -> &[u8] {
        match self.private_metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_private_metadata(&mut self) {
        self.private_metadata = ::std::option::Option::None;
    }

    pub fn has_private_metadata(&self) -> bool {
        self.private_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.private_metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.private_metadata.is_none() {
            self.private_metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.private_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_private_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.private_metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CDOTAMatchMetadataFile| { &m.version },
            |m: &mut CDOTAMatchMetadataFile| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CDOTAMatchMetadataFile| { &m.match_id },
            |m: &mut CDOTAMatchMetadataFile| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDOTAMatchMetadata>(
            "metadata",
            |m: &CDOTAMatchMetadataFile| { &m.metadata },
            |m: &mut CDOTAMatchMetadataFile| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "private_metadata",
            |m: &CDOTAMatchMetadataFile| { &m.private_metadata },
            |m: &mut CDOTAMatchMetadataFile| { &mut m.private_metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAMatchMetadataFile>(
            "CDOTAMatchMetadataFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAMatchMetadataFile {
    const NAME: &'static str = "CDOTAMatchMetadataFile";

    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        if self.match_id.is_none() {
            return false;
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                42 => {
                    self.private_metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.private_metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.private_metadata.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAMatchMetadataFile {
        CDOTAMatchMetadataFile::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.metadata.clear();
        self.private_metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAMatchMetadataFile {
        static instance: CDOTAMatchMetadataFile = CDOTAMatchMetadataFile {
            version: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            metadata: ::protobuf::MessageField::none(),
            private_metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAMatchMetadataFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAMatchMetadataFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAMatchMetadataFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAMatchMetadataFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAMatchMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAMatchMetadata {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.teams)
    pub teams: ::std::vec::Vec<cdotamatch_metadata::Team>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.report_until_time)
    pub report_until_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.event_game_custom_table)
    pub event_game_custom_table: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.primary_event_id)
    pub primary_event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.matchmaking_stats)
    pub matchmaking_stats: ::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMsgMatchMatchmakingStats>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.mvp_data)
    pub mvp_data: ::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMvpData>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.guild_challenge_progress)
    pub guild_challenge_progress: ::std::vec::Vec<cdotamatch_metadata::GuildChallengeProgress>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.custom_post_game_table)
    pub custom_post_game_table: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.match_tips)
    pub match_tips: ::std::vec::Vec<cdotamatch_metadata::Tip>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAMatchMetadata {
    fn default() -> &'a CDOTAMatchMetadata {
        <CDOTAMatchMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAMatchMetadata {
    pub fn new() -> CDOTAMatchMetadata {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 report_until_time = 4;

    pub fn report_until_time(&self) -> u64 {
        self.report_until_time.unwrap_or(0)
    }

    pub fn clear_report_until_time(&mut self) {
        self.report_until_time = ::std::option::Option::None;
    }

    pub fn has_report_until_time(&self) -> bool {
        self.report_until_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_until_time(&mut self, v: u64) {
        self.report_until_time = ::std::option::Option::Some(v);
    }

    // optional bytes event_game_custom_table = 5;

    pub fn event_game_custom_table(&self) -> &[u8] {
        match self.event_game_custom_table.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_event_game_custom_table(&mut self) {
        self.event_game_custom_table = ::std::option::Option::None;
    }

    pub fn has_event_game_custom_table(&self) -> bool {
        self.event_game_custom_table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_custom_table(&mut self, v: ::std::vec::Vec<u8>) {
        self.event_game_custom_table = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_custom_table(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.event_game_custom_table.is_none() {
            self.event_game_custom_table = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.event_game_custom_table.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_custom_table(&mut self) -> ::std::vec::Vec<u8> {
        self.event_game_custom_table.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 primary_event_id = 6;

    pub fn primary_event_id(&self) -> u32 {
        self.primary_event_id.unwrap_or(0)
    }

    pub fn clear_primary_event_id(&mut self) {
        self.primary_event_id = ::std::option::Option::None;
    }

    pub fn has_primary_event_id(&self) -> bool {
        self.primary_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_event_id(&mut self, v: u32) {
        self.primary_event_id = ::std::option::Option::Some(v);
    }

    // optional bytes custom_post_game_table = 11;

    pub fn custom_post_game_table(&self) -> &[u8] {
        match self.custom_post_game_table.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_custom_post_game_table(&mut self) {
        self.custom_post_game_table = ::std::option::Option::None;
    }

    pub fn has_custom_post_game_table(&self) -> bool {
        self.custom_post_game_table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_post_game_table(&mut self, v: ::std::vec::Vec<u8>) {
        self.custom_post_game_table = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_post_game_table(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.custom_post_game_table.is_none() {
            self.custom_post_game_table = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.custom_post_game_table.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_post_game_table(&mut self) -> ::std::vec::Vec<u8> {
        self.custom_post_game_table.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CDOTAMatchMetadata| { &m.teams },
            |m: &mut CDOTAMatchMetadata| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CDOTAMatchMetadata| { &m.lobby_id },
            |m: &mut CDOTAMatchMetadata| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "report_until_time",
            |m: &CDOTAMatchMetadata| { &m.report_until_time },
            |m: &mut CDOTAMatchMetadata| { &mut m.report_until_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_game_custom_table",
            |m: &CDOTAMatchMetadata| { &m.event_game_custom_table },
            |m: &mut CDOTAMatchMetadata| { &mut m.event_game_custom_table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_event_id",
            |m: &CDOTAMatchMetadata| { &m.primary_event_id },
            |m: &mut CDOTAMatchMetadata| { &mut m.primary_event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common_match_management::CMsgMatchMatchmakingStats>(
            "matchmaking_stats",
            |m: &CDOTAMatchMetadata| { &m.matchmaking_stats },
            |m: &mut CDOTAMatchMetadata| { &mut m.matchmaking_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common_match_management::CMvpData>(
            "mvp_data",
            |m: &CDOTAMatchMetadata| { &m.mvp_data },
            |m: &mut CDOTAMatchMetadata| { &mut m.mvp_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_challenge_progress",
            |m: &CDOTAMatchMetadata| { &m.guild_challenge_progress },
            |m: &mut CDOTAMatchMetadata| { &mut m.guild_challenge_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_post_game_table",
            |m: &CDOTAMatchMetadata| { &m.custom_post_game_table },
            |m: &mut CDOTAMatchMetadata| { &mut m.custom_post_game_table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "match_tips",
            |m: &CDOTAMatchMetadata| { &m.match_tips },
            |m: &mut CDOTAMatchMetadata| { &mut m.match_tips },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAMatchMetadata>(
            "CDOTAMatchMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAMatchMetadata {
    const NAME: &'static str = "CDOTAMatchMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.teams.push(is.read_message()?);
                },
                25 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.report_until_time = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    self.event_game_custom_table = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.primary_event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matchmaking_stats)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mvp_data)?;
                },
                82 => {
                    self.guild_challenge_progress.push(is.read_message()?);
                },
                90 => {
                    self.custom_post_game_table = ::std::option::Option::Some(is.read_bytes()?);
                },
                98 => {
                    self.match_tips.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.report_until_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_game_custom_table.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.primary_event_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.matchmaking_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mvp_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.guild_challenge_progress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.custom_post_game_table.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        for value in &self.match_tips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.lobby_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.report_until_time {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.event_game_custom_table.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.primary_event_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.matchmaking_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.mvp_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.guild_challenge_progress {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.custom_post_game_table.as_ref() {
            os.write_bytes(11, v)?;
        }
        for v in &self.match_tips {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAMatchMetadata {
        CDOTAMatchMetadata::new()
    }

    fn clear(&mut self) {
        self.teams.clear();
        self.lobby_id = ::std::option::Option::None;
        self.report_until_time = ::std::option::Option::None;
        self.event_game_custom_table = ::std::option::Option::None;
        self.primary_event_id = ::std::option::Option::None;
        self.matchmaking_stats.clear();
        self.mvp_data.clear();
        self.guild_challenge_progress.clear();
        self.custom_post_game_table = ::std::option::Option::None;
        self.match_tips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAMatchMetadata {
        static instance: CDOTAMatchMetadata = CDOTAMatchMetadata {
            teams: ::std::vec::Vec::new(),
            lobby_id: ::std::option::Option::None,
            report_until_time: ::std::option::Option::None,
            event_game_custom_table: ::std::option::Option::None,
            primary_event_id: ::std::option::Option::None,
            matchmaking_stats: ::protobuf::MessageField::none(),
            mvp_data: ::protobuf::MessageField::none(),
            guild_challenge_progress: ::std::vec::Vec::new(),
            custom_post_game_table: ::std::option::Option::None,
            match_tips: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAMatchMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAMatchMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAMatchMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAMatchMetadata`
pub mod cdotamatch_metadata {
    // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.EconItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EconItem {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.EconItem.def_index)
        pub def_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.EconItem.quality)
        pub quality: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.EconItem.attribute)
        pub attribute: ::std::vec::Vec<super::super::base_gcmessages::CSOEconItemAttribute>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.EconItem.style)
        pub style: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.EconItem.equipped_state)
        pub equipped_state: ::std::vec::Vec<super::super::base_gcmessages::CSOEconItemEquipped>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.EconItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EconItem {
        fn default() -> &'a EconItem {
            <EconItem as ::protobuf::Message>::default_instance()
        }
    }

    impl EconItem {
        pub fn new() -> EconItem {
            ::std::default::Default::default()
        }

        // optional uint32 def_index = 1;

        pub fn def_index(&self) -> u32 {
            self.def_index.unwrap_or(0)
        }

        pub fn clear_def_index(&mut self) {
            self.def_index = ::std::option::Option::None;
        }

        pub fn has_def_index(&self) -> bool {
            self.def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_def_index(&mut self, v: u32) {
            self.def_index = ::std::option::Option::Some(v);
        }

        // optional uint32 quality = 2;

        pub fn quality(&self) -> u32 {
            self.quality.unwrap_or(0)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: u32) {
            self.quality = ::std::option::Option::Some(v);
        }

        // optional uint32 style = 4;

        pub fn style(&self) -> u32 {
            self.style.unwrap_or(0)
        }

        pub fn clear_style(&mut self) {
            self.style = ::std::option::Option::None;
        }

        pub fn has_style(&self) -> bool {
            self.style.is_some()
        }

        // Param is passed by value, moved
        pub fn set_style(&mut self, v: u32) {
            self.style = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "def_index",
                |m: &EconItem| { &m.def_index },
                |m: &mut EconItem| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quality",
                |m: &EconItem| { &m.quality },
                |m: &mut EconItem| { &mut m.quality },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "attribute",
                |m: &EconItem| { &m.attribute },
                |m: &mut EconItem| { &mut m.attribute },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "style",
                |m: &EconItem| { &m.style },
                |m: &mut EconItem| { &mut m.style },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "equipped_state",
                |m: &EconItem| { &m.equipped_state },
                |m: &mut EconItem| { &mut m.equipped_state },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EconItem>(
                "CDOTAMatchMetadata.EconItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EconItem {
        const NAME: &'static str = "EconItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.attribute.push(is.read_message()?);
                    },
                    32 => {
                        self.style = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.equipped_state.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.def_index {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quality {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.attribute {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.style {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.equipped_state {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.def_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quality {
                os.write_uint32(2, v)?;
            }
            for v in &self.attribute {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.style {
                os.write_uint32(4, v)?;
            }
            for v in &self.equipped_state {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EconItem {
            EconItem::new()
        }

        fn clear(&mut self) {
            self.def_index = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.attribute.clear();
            self.style = ::std::option::Option::None;
            self.equipped_state.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EconItem {
            static instance: EconItem = EconItem {
                def_index: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                attribute: ::std::vec::Vec::new(),
                style: ::std::option::Option::None,
                equipped_state: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EconItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.EconItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EconItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EconItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.dota_team)
        pub dota_team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.players)
        pub players: ::std::vec::Vec<team::Player>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.graph_experience)
        pub graph_experience: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.graph_gold_earned)
        pub graph_gold_earned: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.graph_net_worth)
        pub graph_net_worth: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.cm_first_pick)
        pub cm_first_pick: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.cm_captain_player_id)
        pub cm_captain_player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.cm_penalty)
        pub cm_penalty: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 dota_team = 1;

        pub fn dota_team(&self) -> u32 {
            self.dota_team.unwrap_or(0)
        }

        pub fn clear_dota_team(&mut self) {
            self.dota_team = ::std::option::Option::None;
        }

        pub fn has_dota_team(&self) -> bool {
            self.dota_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dota_team(&mut self, v: u32) {
            self.dota_team = ::std::option::Option::Some(v);
        }

        // optional bool cm_first_pick = 6;

        pub fn cm_first_pick(&self) -> bool {
            self.cm_first_pick.unwrap_or(false)
        }

        pub fn clear_cm_first_pick(&mut self) {
            self.cm_first_pick = ::std::option::Option::None;
        }

        pub fn has_cm_first_pick(&self) -> bool {
            self.cm_first_pick.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cm_first_pick(&mut self, v: bool) {
            self.cm_first_pick = ::std::option::Option::Some(v);
        }

        // optional int32 cm_captain_player_id = 7;

        pub fn cm_captain_player_id(&self) -> i32 {
            self.cm_captain_player_id.unwrap_or(0)
        }

        pub fn clear_cm_captain_player_id(&mut self) {
            self.cm_captain_player_id = ::std::option::Option::None;
        }

        pub fn has_cm_captain_player_id(&self) -> bool {
            self.cm_captain_player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cm_captain_player_id(&mut self, v: i32) {
            self.cm_captain_player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 cm_penalty = 10;

        pub fn cm_penalty(&self) -> u32 {
            self.cm_penalty.unwrap_or(0)
        }

        pub fn clear_cm_penalty(&mut self) {
            self.cm_penalty = ::std::option::Option::None;
        }

        pub fn has_cm_penalty(&self) -> bool {
            self.cm_penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cm_penalty(&mut self, v: u32) {
            self.cm_penalty = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dota_team",
                |m: &Team| { &m.dota_team },
                |m: &mut Team| { &mut m.dota_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "players",
                |m: &Team| { &m.players },
                |m: &mut Team| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_experience",
                |m: &Team| { &m.graph_experience },
                |m: &mut Team| { &mut m.graph_experience },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_gold_earned",
                |m: &Team| { &m.graph_gold_earned },
                |m: &mut Team| { &mut m.graph_gold_earned },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_net_worth",
                |m: &Team| { &m.graph_net_worth },
                |m: &mut Team| { &mut m.graph_net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cm_first_pick",
                |m: &Team| { &m.cm_first_pick },
                |m: &mut Team| { &mut m.cm_first_pick },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cm_captain_player_id",
                |m: &Team| { &m.cm_captain_player_id },
                |m: &mut Team| { &mut m.cm_captain_player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cm_penalty",
                |m: &Team| { &m.cm_penalty },
                |m: &mut Team| { &mut m.cm_penalty },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Team>(
                "CDOTAMatchMetadata.Team",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.players.push(is.read_message()?);
                    },
                    26 => {
                        is.read_repeated_packed_float_into(&mut self.graph_experience)?;
                    },
                    29 => {
                        self.graph_experience.push(is.read_float()?);
                    },
                    34 => {
                        is.read_repeated_packed_float_into(&mut self.graph_gold_earned)?;
                    },
                    37 => {
                        self.graph_gold_earned.push(is.read_float()?);
                    },
                    42 => {
                        is.read_repeated_packed_float_into(&mut self.graph_net_worth)?;
                    },
                    45 => {
                        self.graph_net_worth.push(is.read_float()?);
                    },
                    48 => {
                        self.cm_first_pick = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.cm_captain_player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.cm_penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dota_team {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += 5 * self.graph_experience.len() as u64;
            my_size += 5 * self.graph_gold_earned.len() as u64;
            my_size += 5 * self.graph_net_worth.len() as u64;
            if let Some(v) = self.cm_first_pick {
                my_size += 1 + 1;
            }
            if let Some(v) = self.cm_captain_player_id {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.cm_penalty {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.dota_team {
                os.write_uint32(1, v)?;
            }
            for v in &self.players {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.graph_experience {
                os.write_float(3, *v)?;
            };
            for v in &self.graph_gold_earned {
                os.write_float(4, *v)?;
            };
            for v in &self.graph_net_worth {
                os.write_float(5, *v)?;
            };
            if let Some(v) = self.cm_first_pick {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.cm_captain_player_id {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.cm_penalty {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.dota_team = ::std::option::Option::None;
            self.players.clear();
            self.graph_experience.clear();
            self.graph_gold_earned.clear();
            self.graph_net_worth.clear();
            self.cm_first_pick = ::std::option::Option::None;
            self.cm_captain_player_id = ::std::option::Option::None;
            self.cm_penalty = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                dota_team: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                graph_experience: ::std::vec::Vec::new(),
                graph_gold_earned: ::std::vec::Vec::new(),
                graph_net_worth: ::std::vec::Vec::new(),
                cm_first_pick: ::std::option::Option::None,
                cm_captain_player_id: ::std::option::Option::None,
                cm_penalty: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Team {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Team {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Team {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Team`
    pub mod team {
        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.PlayerKill)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PlayerKill {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.PlayerKill.victim_slot)
            pub victim_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.PlayerKill.count)
            pub count: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.PlayerKill.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PlayerKill {
            fn default() -> &'a PlayerKill {
                <PlayerKill as ::protobuf::Message>::default_instance()
            }
        }

        impl PlayerKill {
            pub fn new() -> PlayerKill {
                ::std::default::Default::default()
            }

            // optional uint32 victim_slot = 1;

            pub fn victim_slot(&self) -> u32 {
                self.victim_slot.unwrap_or(0)
            }

            pub fn clear_victim_slot(&mut self) {
                self.victim_slot = ::std::option::Option::None;
            }

            pub fn has_victim_slot(&self) -> bool {
                self.victim_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_victim_slot(&mut self, v: u32) {
                self.victim_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 count = 2;

            pub fn count(&self) -> u32 {
                self.count.unwrap_or(0)
            }

            pub fn clear_count(&mut self) {
                self.count = ::std::option::Option::None;
            }

            pub fn has_count(&self) -> bool {
                self.count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_count(&mut self, v: u32) {
                self.count = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "victim_slot",
                    |m: &PlayerKill| { &m.victim_slot },
                    |m: &mut PlayerKill| { &mut m.victim_slot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "count",
                    |m: &PlayerKill| { &m.count },
                    |m: &mut PlayerKill| { &mut m.count },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerKill>(
                    "CDOTAMatchMetadata.Team.PlayerKill",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PlayerKill {
            const NAME: &'static str = "PlayerKill";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.victim_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.victim_slot {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.count {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.victim_slot {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.count {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PlayerKill {
                PlayerKill::new()
            }

            fn clear(&mut self) {
                self.victim_slot = ::std::option::Option::None;
                self.count = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PlayerKill {
                static instance: PlayerKill = PlayerKill {
                    victim_slot: ::std::option::Option::None,
                    count: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for PlayerKill {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.PlayerKill").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PlayerKill {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PlayerKill {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.ItemPurchase)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ItemPurchase {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.ItemPurchase.item_id)
            pub item_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.ItemPurchase.purchase_time)
            pub purchase_time: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.ItemPurchase.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ItemPurchase {
            fn default() -> &'a ItemPurchase {
                <ItemPurchase as ::protobuf::Message>::default_instance()
            }
        }

        impl ItemPurchase {
            pub fn new() -> ItemPurchase {
                ::std::default::Default::default()
            }

            // optional int32 item_id = 1;

            pub fn item_id(&self) -> i32 {
                self.item_id.unwrap_or(0)
            }

            pub fn clear_item_id(&mut self) {
                self.item_id = ::std::option::Option::None;
            }

            pub fn has_item_id(&self) -> bool {
                self.item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_id(&mut self, v: i32) {
                self.item_id = ::std::option::Option::Some(v);
            }

            // optional int32 purchase_time = 2;

            pub fn purchase_time(&self) -> i32 {
                self.purchase_time.unwrap_or(0)
            }

            pub fn clear_purchase_time(&mut self) {
                self.purchase_time = ::std::option::Option::None;
            }

            pub fn has_purchase_time(&self) -> bool {
                self.purchase_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_purchase_time(&mut self, v: i32) {
                self.purchase_time = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item_id",
                    |m: &ItemPurchase| { &m.item_id },
                    |m: &mut ItemPurchase| { &mut m.item_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "purchase_time",
                    |m: &ItemPurchase| { &m.purchase_time },
                    |m: &mut ItemPurchase| { &mut m.purchase_time },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemPurchase>(
                    "CDOTAMatchMetadata.Team.ItemPurchase",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ItemPurchase {
            const NAME: &'static str = "ItemPurchase";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.item_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.purchase_time = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.item_id {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.purchase_time {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.item_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.purchase_time {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ItemPurchase {
                ItemPurchase::new()
            }

            fn clear(&mut self) {
                self.item_id = ::std::option::Option::None;
                self.purchase_time = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ItemPurchase {
                static instance: ItemPurchase = ItemPurchase {
                    item_id: ::std::option::Option::None,
                    purchase_time: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ItemPurchase {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.ItemPurchase").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ItemPurchase {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ItemPurchase {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.InventorySnapshot)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct InventorySnapshot {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.item_id)
            pub item_id: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.game_time)
            pub game_time: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.kills)
            pub kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.deaths)
            pub deaths: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.assists)
            pub assists: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.level)
            pub level: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.backpack_item_id)
            pub backpack_item_id: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.neutral_item_id)
            pub neutral_item_id: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.InventorySnapshot.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a InventorySnapshot {
            fn default() -> &'a InventorySnapshot {
                <InventorySnapshot as ::protobuf::Message>::default_instance()
            }
        }

        impl InventorySnapshot {
            pub fn new() -> InventorySnapshot {
                ::std::default::Default::default()
            }

            // optional int32 game_time = 2;

            pub fn game_time(&self) -> i32 {
                self.game_time.unwrap_or(0)
            }

            pub fn clear_game_time(&mut self) {
                self.game_time = ::std::option::Option::None;
            }

            pub fn has_game_time(&self) -> bool {
                self.game_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_time(&mut self, v: i32) {
                self.game_time = ::std::option::Option::Some(v);
            }

            // optional uint32 kills = 3;

            pub fn kills(&self) -> u32 {
                self.kills.unwrap_or(0)
            }

            pub fn clear_kills(&mut self) {
                self.kills = ::std::option::Option::None;
            }

            pub fn has_kills(&self) -> bool {
                self.kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kills(&mut self, v: u32) {
                self.kills = ::std::option::Option::Some(v);
            }

            // optional uint32 deaths = 4;

            pub fn deaths(&self) -> u32 {
                self.deaths.unwrap_or(0)
            }

            pub fn clear_deaths(&mut self) {
                self.deaths = ::std::option::Option::None;
            }

            pub fn has_deaths(&self) -> bool {
                self.deaths.is_some()
            }

            // Param is passed by value, moved
            pub fn set_deaths(&mut self, v: u32) {
                self.deaths = ::std::option::Option::Some(v);
            }

            // optional uint32 assists = 5;

            pub fn assists(&self) -> u32 {
                self.assists.unwrap_or(0)
            }

            pub fn clear_assists(&mut self) {
                self.assists = ::std::option::Option::None;
            }

            pub fn has_assists(&self) -> bool {
                self.assists.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assists(&mut self, v: u32) {
                self.assists = ::std::option::Option::Some(v);
            }

            // optional uint32 level = 6;

            pub fn level(&self) -> u32 {
                self.level.unwrap_or(0)
            }

            pub fn clear_level(&mut self) {
                self.level = ::std::option::Option::None;
            }

            pub fn has_level(&self) -> bool {
                self.level.is_some()
            }

            // Param is passed by value, moved
            pub fn set_level(&mut self, v: u32) {
                self.level = ::std::option::Option::Some(v);
            }

            // optional int32 neutral_item_id = 8;

            pub fn neutral_item_id(&self) -> i32 {
                self.neutral_item_id.unwrap_or(0)
            }

            pub fn clear_neutral_item_id(&mut self) {
                self.neutral_item_id = ::std::option::Option::None;
            }

            pub fn has_neutral_item_id(&self) -> bool {
                self.neutral_item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_neutral_item_id(&mut self, v: i32) {
                self.neutral_item_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(8);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "item_id",
                    |m: &InventorySnapshot| { &m.item_id },
                    |m: &mut InventorySnapshot| { &mut m.item_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "game_time",
                    |m: &InventorySnapshot| { &m.game_time },
                    |m: &mut InventorySnapshot| { &mut m.game_time },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "kills",
                    |m: &InventorySnapshot| { &m.kills },
                    |m: &mut InventorySnapshot| { &mut m.kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "deaths",
                    |m: &InventorySnapshot| { &m.deaths },
                    |m: &mut InventorySnapshot| { &mut m.deaths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "assists",
                    |m: &InventorySnapshot| { &m.assists },
                    |m: &mut InventorySnapshot| { &mut m.assists },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "level",
                    |m: &InventorySnapshot| { &m.level },
                    |m: &mut InventorySnapshot| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "backpack_item_id",
                    |m: &InventorySnapshot| { &m.backpack_item_id },
                    |m: &mut InventorySnapshot| { &mut m.backpack_item_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "neutral_item_id",
                    |m: &InventorySnapshot| { &m.neutral_item_id },
                    |m: &mut InventorySnapshot| { &mut m.neutral_item_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InventorySnapshot>(
                    "CDOTAMatchMetadata.Team.InventorySnapshot",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for InventorySnapshot {
            const NAME: &'static str = "InventorySnapshot";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            is.read_repeated_packed_int32_into(&mut self.item_id)?;
                        },
                        8 => {
                            self.item_id.push(is.read_int32()?);
                        },
                        16 => {
                            self.game_time = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.assists = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.level = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        58 => {
                            is.read_repeated_packed_int32_into(&mut self.backpack_item_id)?;
                        },
                        56 => {
                            self.backpack_item_id.push(is.read_int32()?);
                        },
                        64 => {
                            self.neutral_item_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.item_id {
                    my_size += ::protobuf::rt::int32_size(1, *value);
                };
                if let Some(v) = self.game_time {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                if let Some(v) = self.kills {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.deaths {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.assists {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.level {
                    my_size += ::protobuf::rt::uint32_size(6, v);
                }
                for value in &self.backpack_item_id {
                    my_size += ::protobuf::rt::int32_size(7, *value);
                };
                if let Some(v) = self.neutral_item_id {
                    my_size += ::protobuf::rt::int32_size(8, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.item_id {
                    os.write_int32(1, *v)?;
                };
                if let Some(v) = self.game_time {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.kills {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.deaths {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.assists {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.level {
                    os.write_uint32(6, v)?;
                }
                for v in &self.backpack_item_id {
                    os.write_int32(7, *v)?;
                };
                if let Some(v) = self.neutral_item_id {
                    os.write_int32(8, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> InventorySnapshot {
                InventorySnapshot::new()
            }

            fn clear(&mut self) {
                self.item_id.clear();
                self.game_time = ::std::option::Option::None;
                self.kills = ::std::option::Option::None;
                self.deaths = ::std::option::Option::None;
                self.assists = ::std::option::Option::None;
                self.level = ::std::option::Option::None;
                self.backpack_item_id.clear();
                self.neutral_item_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static InventorySnapshot {
                static instance: InventorySnapshot = InventorySnapshot {
                    item_id: ::std::vec::Vec::new(),
                    game_time: ::std::option::Option::None,
                    kills: ::std::option::Option::None,
                    deaths: ::std::option::Option::None,
                    assists: ::std::option::Option::None,
                    level: ::std::option::Option::None,
                    backpack_item_id: ::std::vec::Vec::new(),
                    neutral_item_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for InventorySnapshot {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.InventorySnapshot").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for InventorySnapshot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for InventorySnapshot {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.AutoStyleCriteria)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AutoStyleCriteria {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.AutoStyleCriteria.name_token)
            pub name_token: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.AutoStyleCriteria.value)
            pub value: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.AutoStyleCriteria.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AutoStyleCriteria {
            fn default() -> &'a AutoStyleCriteria {
                <AutoStyleCriteria as ::protobuf::Message>::default_instance()
            }
        }

        impl AutoStyleCriteria {
            pub fn new() -> AutoStyleCriteria {
                ::std::default::Default::default()
            }

            // optional uint32 name_token = 1;

            pub fn name_token(&self) -> u32 {
                self.name_token.unwrap_or(0)
            }

            pub fn clear_name_token(&mut self) {
                self.name_token = ::std::option::Option::None;
            }

            pub fn has_name_token(&self) -> bool {
                self.name_token.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name_token(&mut self, v: u32) {
                self.name_token = ::std::option::Option::Some(v);
            }

            // optional float value = 2;

            pub fn value(&self) -> f32 {
                self.value.unwrap_or(0.)
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: f32) {
                self.value = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name_token",
                    |m: &AutoStyleCriteria| { &m.name_token },
                    |m: &mut AutoStyleCriteria| { &mut m.name_token },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value",
                    |m: &AutoStyleCriteria| { &m.value },
                    |m: &mut AutoStyleCriteria| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutoStyleCriteria>(
                    "CDOTAMatchMetadata.Team.AutoStyleCriteria",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AutoStyleCriteria {
            const NAME: &'static str = "AutoStyleCriteria";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.name_token = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        21 => {
                            self.value = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name_token {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value {
                    my_size += 1 + 4;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name_token {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value {
                    os.write_float(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AutoStyleCriteria {
                AutoStyleCriteria::new()
            }

            fn clear(&mut self) {
                self.name_token = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AutoStyleCriteria {
                static instance: AutoStyleCriteria = AutoStyleCriteria {
                    name_token: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AutoStyleCriteria {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.AutoStyleCriteria").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AutoStyleCriteria {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AutoStyleCriteria {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.StrangeGemProgress)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct StrangeGemProgress {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.kill_eater_type)
            pub kill_eater_type: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.gem_item_def_index)
            pub gem_item_def_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.required_hero_id)
            pub required_hero_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.starting_value)
            pub starting_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.ending_value)
            pub ending_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.owner_item_def_index)
            pub owner_item_def_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.owner_item_id)
            pub owner_item_id: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.StrangeGemProgress.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StrangeGemProgress {
            fn default() -> &'a StrangeGemProgress {
                <StrangeGemProgress as ::protobuf::Message>::default_instance()
            }
        }

        impl StrangeGemProgress {
            pub fn new() -> StrangeGemProgress {
                ::std::default::Default::default()
            }

            // optional uint32 kill_eater_type = 1;

            pub fn kill_eater_type(&self) -> u32 {
                self.kill_eater_type.unwrap_or(0)
            }

            pub fn clear_kill_eater_type(&mut self) {
                self.kill_eater_type = ::std::option::Option::None;
            }

            pub fn has_kill_eater_type(&self) -> bool {
                self.kill_eater_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kill_eater_type(&mut self, v: u32) {
                self.kill_eater_type = ::std::option::Option::Some(v);
            }

            // optional uint32 gem_item_def_index = 2;

            pub fn gem_item_def_index(&self) -> u32 {
                self.gem_item_def_index.unwrap_or(0)
            }

            pub fn clear_gem_item_def_index(&mut self) {
                self.gem_item_def_index = ::std::option::Option::None;
            }

            pub fn has_gem_item_def_index(&self) -> bool {
                self.gem_item_def_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gem_item_def_index(&mut self, v: u32) {
                self.gem_item_def_index = ::std::option::Option::Some(v);
            }

            // optional uint32 required_hero_id = 3;

            pub fn required_hero_id(&self) -> u32 {
                self.required_hero_id.unwrap_or(0)
            }

            pub fn clear_required_hero_id(&mut self) {
                self.required_hero_id = ::std::option::Option::None;
            }

            pub fn has_required_hero_id(&self) -> bool {
                self.required_hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_required_hero_id(&mut self, v: u32) {
                self.required_hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 starting_value = 4;

            pub fn starting_value(&self) -> u32 {
                self.starting_value.unwrap_or(0)
            }

            pub fn clear_starting_value(&mut self) {
                self.starting_value = ::std::option::Option::None;
            }

            pub fn has_starting_value(&self) -> bool {
                self.starting_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_starting_value(&mut self, v: u32) {
                self.starting_value = ::std::option::Option::Some(v);
            }

            // optional uint32 ending_value = 5;

            pub fn ending_value(&self) -> u32 {
                self.ending_value.unwrap_or(0)
            }

            pub fn clear_ending_value(&mut self) {
                self.ending_value = ::std::option::Option::None;
            }

            pub fn has_ending_value(&self) -> bool {
                self.ending_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ending_value(&mut self, v: u32) {
                self.ending_value = ::std::option::Option::Some(v);
            }

            // optional uint32 owner_item_def_index = 6;

            pub fn owner_item_def_index(&self) -> u32 {
                self.owner_item_def_index.unwrap_or(0)
            }

            pub fn clear_owner_item_def_index(&mut self) {
                self.owner_item_def_index = ::std::option::Option::None;
            }

            pub fn has_owner_item_def_index(&self) -> bool {
                self.owner_item_def_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_owner_item_def_index(&mut self, v: u32) {
                self.owner_item_def_index = ::std::option::Option::Some(v);
            }

            // optional uint64 owner_item_id = 7;

            pub fn owner_item_id(&self) -> u64 {
                self.owner_item_id.unwrap_or(0)
            }

            pub fn clear_owner_item_id(&mut self) {
                self.owner_item_id = ::std::option::Option::None;
            }

            pub fn has_owner_item_id(&self) -> bool {
                self.owner_item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_owner_item_id(&mut self, v: u64) {
                self.owner_item_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(7);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "kill_eater_type",
                    |m: &StrangeGemProgress| { &m.kill_eater_type },
                    |m: &mut StrangeGemProgress| { &mut m.kill_eater_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "gem_item_def_index",
                    |m: &StrangeGemProgress| { &m.gem_item_def_index },
                    |m: &mut StrangeGemProgress| { &mut m.gem_item_def_index },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "required_hero_id",
                    |m: &StrangeGemProgress| { &m.required_hero_id },
                    |m: &mut StrangeGemProgress| { &mut m.required_hero_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "starting_value",
                    |m: &StrangeGemProgress| { &m.starting_value },
                    |m: &mut StrangeGemProgress| { &mut m.starting_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ending_value",
                    |m: &StrangeGemProgress| { &m.ending_value },
                    |m: &mut StrangeGemProgress| { &mut m.ending_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "owner_item_def_index",
                    |m: &StrangeGemProgress| { &m.owner_item_def_index },
                    |m: &mut StrangeGemProgress| { &mut m.owner_item_def_index },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "owner_item_id",
                    |m: &StrangeGemProgress| { &m.owner_item_id },
                    |m: &mut StrangeGemProgress| { &mut m.owner_item_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StrangeGemProgress>(
                    "CDOTAMatchMetadata.Team.StrangeGemProgress",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for StrangeGemProgress {
            const NAME: &'static str = "StrangeGemProgress";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.kill_eater_type = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.gem_item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.required_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.starting_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.ending_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.owner_item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        56 => {
                            self.owner_item_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.kill_eater_type {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.gem_item_def_index {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.required_hero_id {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.starting_value {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.ending_value {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.owner_item_def_index {
                    my_size += ::protobuf::rt::uint32_size(6, v);
                }
                if let Some(v) = self.owner_item_id {
                    my_size += ::protobuf::rt::uint64_size(7, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.kill_eater_type {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.gem_item_def_index {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.required_hero_id {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.starting_value {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.ending_value {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.owner_item_def_index {
                    os.write_uint32(6, v)?;
                }
                if let Some(v) = self.owner_item_id {
                    os.write_uint64(7, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StrangeGemProgress {
                StrangeGemProgress::new()
            }

            fn clear(&mut self) {
                self.kill_eater_type = ::std::option::Option::None;
                self.gem_item_def_index = ::std::option::Option::None;
                self.required_hero_id = ::std::option::Option::None;
                self.starting_value = ::std::option::Option::None;
                self.ending_value = ::std::option::Option::None;
                self.owner_item_def_index = ::std::option::Option::None;
                self.owner_item_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StrangeGemProgress {
                static instance: StrangeGemProgress = StrangeGemProgress {
                    kill_eater_type: ::std::option::Option::None,
                    gem_item_def_index: ::std::option::Option::None,
                    required_hero_id: ::std::option::Option::None,
                    starting_value: ::std::option::Option::None,
                    ending_value: ::std::option::Option::None,
                    owner_item_def_index: ::std::option::Option::None,
                    owner_item_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for StrangeGemProgress {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.StrangeGemProgress").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for StrangeGemProgress {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for StrangeGemProgress {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.VictoryPrediction)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VictoryPrediction {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.VictoryPrediction.item_id)
            pub item_id: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.VictoryPrediction.item_def_index)
            pub item_def_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.VictoryPrediction.starting_value)
            pub starting_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.VictoryPrediction.is_victory)
            pub is_victory: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.VictoryPrediction.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VictoryPrediction {
            fn default() -> &'a VictoryPrediction {
                <VictoryPrediction as ::protobuf::Message>::default_instance()
            }
        }

        impl VictoryPrediction {
            pub fn new() -> VictoryPrediction {
                ::std::default::Default::default()
            }

            // optional uint64 item_id = 1;

            pub fn item_id(&self) -> u64 {
                self.item_id.unwrap_or(0)
            }

            pub fn clear_item_id(&mut self) {
                self.item_id = ::std::option::Option::None;
            }

            pub fn has_item_id(&self) -> bool {
                self.item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_id(&mut self, v: u64) {
                self.item_id = ::std::option::Option::Some(v);
            }

            // optional uint32 item_def_index = 2;

            pub fn item_def_index(&self) -> u32 {
                self.item_def_index.unwrap_or(0)
            }

            pub fn clear_item_def_index(&mut self) {
                self.item_def_index = ::std::option::Option::None;
            }

            pub fn has_item_def_index(&self) -> bool {
                self.item_def_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_def_index(&mut self, v: u32) {
                self.item_def_index = ::std::option::Option::Some(v);
            }

            // optional uint32 starting_value = 3;

            pub fn starting_value(&self) -> u32 {
                self.starting_value.unwrap_or(0)
            }

            pub fn clear_starting_value(&mut self) {
                self.starting_value = ::std::option::Option::None;
            }

            pub fn has_starting_value(&self) -> bool {
                self.starting_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_starting_value(&mut self, v: u32) {
                self.starting_value = ::std::option::Option::Some(v);
            }

            // optional bool is_victory = 4;

            pub fn is_victory(&self) -> bool {
                self.is_victory.unwrap_or(false)
            }

            pub fn clear_is_victory(&mut self) {
                self.is_victory = ::std::option::Option::None;
            }

            pub fn has_is_victory(&self) -> bool {
                self.is_victory.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_victory(&mut self, v: bool) {
                self.is_victory = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item_id",
                    |m: &VictoryPrediction| { &m.item_id },
                    |m: &mut VictoryPrediction| { &mut m.item_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item_def_index",
                    |m: &VictoryPrediction| { &m.item_def_index },
                    |m: &mut VictoryPrediction| { &mut m.item_def_index },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "starting_value",
                    |m: &VictoryPrediction| { &m.starting_value },
                    |m: &mut VictoryPrediction| { &mut m.starting_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_victory",
                    |m: &VictoryPrediction| { &m.is_victory },
                    |m: &mut VictoryPrediction| { &mut m.is_victory },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VictoryPrediction>(
                    "CDOTAMatchMetadata.Team.VictoryPrediction",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for VictoryPrediction {
            const NAME: &'static str = "VictoryPrediction";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        16 => {
                            self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.starting_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.is_victory = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.item_id {
                    my_size += ::protobuf::rt::uint64_size(1, v);
                }
                if let Some(v) = self.item_def_index {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.starting_value {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.is_victory {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.item_id {
                    os.write_uint64(1, v)?;
                }
                if let Some(v) = self.item_def_index {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.starting_value {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.is_victory {
                    os.write_bool(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VictoryPrediction {
                VictoryPrediction::new()
            }

            fn clear(&mut self) {
                self.item_id = ::std::option::Option::None;
                self.item_def_index = ::std::option::Option::None;
                self.starting_value = ::std::option::Option::None;
                self.is_victory = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VictoryPrediction {
                static instance: VictoryPrediction = VictoryPrediction {
                    item_id: ::std::option::Option::None,
                    item_def_index: ::std::option::Option::None,
                    starting_value: ::std::option::Option::None,
                    is_victory: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for VictoryPrediction {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.VictoryPrediction").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for VictoryPrediction {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for VictoryPrediction {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.SubChallenge)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SubChallenge {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.SubChallenge.slot_id)
            pub slot_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.SubChallenge.start_value)
            pub start_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.SubChallenge.end_value)
            pub end_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.SubChallenge.completed)
            pub completed: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.SubChallenge.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SubChallenge {
            fn default() -> &'a SubChallenge {
                <SubChallenge as ::protobuf::Message>::default_instance()
            }
        }

        impl SubChallenge {
            pub fn new() -> SubChallenge {
                ::std::default::Default::default()
            }

            // optional uint32 slot_id = 1;

            pub fn slot_id(&self) -> u32 {
                self.slot_id.unwrap_or(0)
            }

            pub fn clear_slot_id(&mut self) {
                self.slot_id = ::std::option::Option::None;
            }

            pub fn has_slot_id(&self) -> bool {
                self.slot_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_slot_id(&mut self, v: u32) {
                self.slot_id = ::std::option::Option::Some(v);
            }

            // optional uint32 start_value = 2;

            pub fn start_value(&self) -> u32 {
                self.start_value.unwrap_or(0)
            }

            pub fn clear_start_value(&mut self) {
                self.start_value = ::std::option::Option::None;
            }

            pub fn has_start_value(&self) -> bool {
                self.start_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_start_value(&mut self, v: u32) {
                self.start_value = ::std::option::Option::Some(v);
            }

            // optional uint32 end_value = 3;

            pub fn end_value(&self) -> u32 {
                self.end_value.unwrap_or(0)
            }

            pub fn clear_end_value(&mut self) {
                self.end_value = ::std::option::Option::None;
            }

            pub fn has_end_value(&self) -> bool {
                self.end_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_end_value(&mut self, v: u32) {
                self.end_value = ::std::option::Option::Some(v);
            }

            // optional bool completed = 4;

            pub fn completed(&self) -> bool {
                self.completed.unwrap_or(false)
            }

            pub fn clear_completed(&mut self) {
                self.completed = ::std::option::Option::None;
            }

            pub fn has_completed(&self) -> bool {
                self.completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_completed(&mut self, v: bool) {
                self.completed = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "slot_id",
                    |m: &SubChallenge| { &m.slot_id },
                    |m: &mut SubChallenge| { &mut m.slot_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "start_value",
                    |m: &SubChallenge| { &m.start_value },
                    |m: &mut SubChallenge| { &mut m.start_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "end_value",
                    |m: &SubChallenge| { &m.end_value },
                    |m: &mut SubChallenge| { &mut m.end_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "completed",
                    |m: &SubChallenge| { &m.completed },
                    |m: &mut SubChallenge| { &mut m.completed },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubChallenge>(
                    "CDOTAMatchMetadata.Team.SubChallenge",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SubChallenge {
            const NAME: &'static str = "SubChallenge";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.start_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.end_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.completed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.slot_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.start_value {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.end_value {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.completed {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.slot_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.start_value {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.end_value {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.completed {
                    os.write_bool(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SubChallenge {
                SubChallenge::new()
            }

            fn clear(&mut self) {
                self.slot_id = ::std::option::Option::None;
                self.start_value = ::std::option::Option::None;
                self.end_value = ::std::option::Option::None;
                self.completed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SubChallenge {
                static instance: SubChallenge = SubChallenge {
                    slot_id: ::std::option::Option::None,
                    start_value: ::std::option::Option::None,
                    end_value: ::std::option::Option::None,
                    completed: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SubChallenge {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.SubChallenge").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SubChallenge {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SubChallenge {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.CavernChallengeResult)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CavernChallengeResult {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.CavernChallengeResult.completed_path_id)
            pub completed_path_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.CavernChallengeResult.claimed_room_id)
            pub claimed_room_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.CavernChallengeResult.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CavernChallengeResult {
            fn default() -> &'a CavernChallengeResult {
                <CavernChallengeResult as ::protobuf::Message>::default_instance()
            }
        }

        impl CavernChallengeResult {
            pub fn new() -> CavernChallengeResult {
                ::std::default::Default::default()
            }

            // optional uint32 completed_path_id = 1;

            pub fn completed_path_id(&self) -> u32 {
                self.completed_path_id.unwrap_or(0)
            }

            pub fn clear_completed_path_id(&mut self) {
                self.completed_path_id = ::std::option::Option::None;
            }

            pub fn has_completed_path_id(&self) -> bool {
                self.completed_path_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_completed_path_id(&mut self, v: u32) {
                self.completed_path_id = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_room_id = 2;

            pub fn claimed_room_id(&self) -> u32 {
                self.claimed_room_id.unwrap_or(0)
            }

            pub fn clear_claimed_room_id(&mut self) {
                self.claimed_room_id = ::std::option::Option::None;
            }

            pub fn has_claimed_room_id(&self) -> bool {
                self.claimed_room_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_room_id(&mut self, v: u32) {
                self.claimed_room_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "completed_path_id",
                    |m: &CavernChallengeResult| { &m.completed_path_id },
                    |m: &mut CavernChallengeResult| { &mut m.completed_path_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "claimed_room_id",
                    |m: &CavernChallengeResult| { &m.claimed_room_id },
                    |m: &mut CavernChallengeResult| { &mut m.claimed_room_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CavernChallengeResult>(
                    "CDOTAMatchMetadata.Team.CavernChallengeResult",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CavernChallengeResult {
            const NAME: &'static str = "CavernChallengeResult";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.completed_path_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.claimed_room_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.completed_path_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.claimed_room_id {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.completed_path_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.claimed_room_id {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CavernChallengeResult {
                CavernChallengeResult::new()
            }

            fn clear(&mut self) {
                self.completed_path_id = ::std::option::Option::None;
                self.claimed_room_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CavernChallengeResult {
                static instance: CavernChallengeResult = CavernChallengeResult {
                    completed_path_id: ::std::option::Option::None,
                    claimed_room_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CavernChallengeResult {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.CavernChallengeResult").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CavernChallengeResult {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CavernChallengeResult {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.ActionGrant)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionGrant {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.ActionGrant.action_id)
            pub action_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.ActionGrant.quantity)
            pub quantity: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.ActionGrant.audit)
            pub audit: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.ActionGrant.requires_win)
            pub requires_win: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.ActionGrant.audit_data)
            pub audit_data: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.ActionGrant.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionGrant {
            fn default() -> &'a ActionGrant {
                <ActionGrant as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionGrant {
            pub fn new() -> ActionGrant {
                ::std::default::Default::default()
            }

            // optional uint32 action_id = 1;

            pub fn action_id(&self) -> u32 {
                self.action_id.unwrap_or(0)
            }

            pub fn clear_action_id(&mut self) {
                self.action_id = ::std::option::Option::None;
            }

            pub fn has_action_id(&self) -> bool {
                self.action_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_action_id(&mut self, v: u32) {
                self.action_id = ::std::option::Option::Some(v);
            }

            // optional uint32 quantity = 2;

            pub fn quantity(&self) -> u32 {
                self.quantity.unwrap_or(0)
            }

            pub fn clear_quantity(&mut self) {
                self.quantity = ::std::option::Option::None;
            }

            pub fn has_quantity(&self) -> bool {
                self.quantity.is_some()
            }

            // Param is passed by value, moved
            pub fn set_quantity(&mut self, v: u32) {
                self.quantity = ::std::option::Option::Some(v);
            }

            // optional uint32 audit = 3;

            pub fn audit(&self) -> u32 {
                self.audit.unwrap_or(0)
            }

            pub fn clear_audit(&mut self) {
                self.audit = ::std::option::Option::None;
            }

            pub fn has_audit(&self) -> bool {
                self.audit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit(&mut self, v: u32) {
                self.audit = ::std::option::Option::Some(v);
            }

            // optional bool requires_win = 4;

            pub fn requires_win(&self) -> bool {
                self.requires_win.unwrap_or(false)
            }

            pub fn clear_requires_win(&mut self) {
                self.requires_win = ::std::option::Option::None;
            }

            pub fn has_requires_win(&self) -> bool {
                self.requires_win.is_some()
            }

            // Param is passed by value, moved
            pub fn set_requires_win(&mut self, v: bool) {
                self.requires_win = ::std::option::Option::Some(v);
            }

            // optional uint64 audit_data = 5;

            pub fn audit_data(&self) -> u64 {
                self.audit_data.unwrap_or(0)
            }

            pub fn clear_audit_data(&mut self) {
                self.audit_data = ::std::option::Option::None;
            }

            pub fn has_audit_data(&self) -> bool {
                self.audit_data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit_data(&mut self, v: u64) {
                self.audit_data = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "action_id",
                    |m: &ActionGrant| { &m.action_id },
                    |m: &mut ActionGrant| { &mut m.action_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "quantity",
                    |m: &ActionGrant| { &m.quantity },
                    |m: &mut ActionGrant| { &mut m.quantity },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "audit",
                    |m: &ActionGrant| { &m.audit },
                    |m: &mut ActionGrant| { &mut m.audit },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "requires_win",
                    |m: &ActionGrant| { &m.requires_win },
                    |m: &mut ActionGrant| { &mut m.requires_win },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "audit_data",
                    |m: &ActionGrant| { &m.audit_data },
                    |m: &mut ActionGrant| { &mut m.audit_data },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionGrant>(
                    "CDOTAMatchMetadata.Team.ActionGrant",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionGrant {
            const NAME: &'static str = "ActionGrant";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.audit = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.requires_win = ::std::option::Option::Some(is.read_bool()?);
                        },
                        40 => {
                            self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.action_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.quantity {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.audit {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.requires_win {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.audit_data {
                    my_size += ::protobuf::rt::uint64_size(5, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.action_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.quantity {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.audit {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.requires_win {
                    os.write_bool(4, v)?;
                }
                if let Some(v) = self.audit_data {
                    os.write_uint64(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionGrant {
                ActionGrant::new()
            }

            fn clear(&mut self) {
                self.action_id = ::std::option::Option::None;
                self.quantity = ::std::option::Option::None;
                self.audit = ::std::option::Option::None;
                self.requires_win = ::std::option::Option::None;
                self.audit_data = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionGrant {
                static instance: ActionGrant = ActionGrant {
                    action_id: ::std::option::Option::None,
                    quantity: ::std::option::Option::None,
                    audit: ::std::option::Option::None,
                    requires_win: ::std::option::Option::None,
                    audit_data: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionGrant {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.ActionGrant").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionGrant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionGrant {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.CandyGrant)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CandyGrant {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.CandyGrant.points)
            pub points: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.CandyGrant.reason)
            pub reason: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.CandyGrant.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CandyGrant {
            fn default() -> &'a CandyGrant {
                <CandyGrant as ::protobuf::Message>::default_instance()
            }
        }

        impl CandyGrant {
            pub fn new() -> CandyGrant {
                ::std::default::Default::default()
            }

            // optional uint32 points = 1;

            pub fn points(&self) -> u32 {
                self.points.unwrap_or(0)
            }

            pub fn clear_points(&mut self) {
                self.points = ::std::option::Option::None;
            }

            pub fn has_points(&self) -> bool {
                self.points.is_some()
            }

            // Param is passed by value, moved
            pub fn set_points(&mut self, v: u32) {
                self.points = ::std::option::Option::Some(v);
            }

            // optional uint32 reason = 2;

            pub fn reason(&self) -> u32 {
                self.reason.unwrap_or(0)
            }

            pub fn clear_reason(&mut self) {
                self.reason = ::std::option::Option::None;
            }

            pub fn has_reason(&self) -> bool {
                self.reason.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reason(&mut self, v: u32) {
                self.reason = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "points",
                    |m: &CandyGrant| { &m.points },
                    |m: &mut CandyGrant| { &mut m.points },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "reason",
                    |m: &CandyGrant| { &m.reason },
                    |m: &mut CandyGrant| { &mut m.reason },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CandyGrant>(
                    "CDOTAMatchMetadata.Team.CandyGrant",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CandyGrant {
            const NAME: &'static str = "CandyGrant";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.points = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.reason = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.points {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.reason {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.points {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.reason {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CandyGrant {
                CandyGrant::new()
            }

            fn clear(&mut self) {
                self.points = ::std::option::Option::None;
                self.reason = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CandyGrant {
                static instance: CandyGrant = CandyGrant {
                    points: ::std::option::Option::None,
                    reason: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CandyGrant {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.CandyGrant").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CandyGrant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CandyGrant {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.PeriodicResourceData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PeriodicResourceData {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.PeriodicResourceData.periodic_resource_id)
            pub periodic_resource_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.PeriodicResourceData.remaining)
            pub remaining: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.PeriodicResourceData.max)
            pub max: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.PeriodicResourceData.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PeriodicResourceData {
            fn default() -> &'a PeriodicResourceData {
                <PeriodicResourceData as ::protobuf::Message>::default_instance()
            }
        }

        impl PeriodicResourceData {
            pub fn new() -> PeriodicResourceData {
                ::std::default::Default::default()
            }

            // optional uint32 periodic_resource_id = 1;

            pub fn periodic_resource_id(&self) -> u32 {
                self.periodic_resource_id.unwrap_or(0)
            }

            pub fn clear_periodic_resource_id(&mut self) {
                self.periodic_resource_id = ::std::option::Option::None;
            }

            pub fn has_periodic_resource_id(&self) -> bool {
                self.periodic_resource_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_periodic_resource_id(&mut self, v: u32) {
                self.periodic_resource_id = ::std::option::Option::Some(v);
            }

            // optional uint32 remaining = 2;

            pub fn remaining(&self) -> u32 {
                self.remaining.unwrap_or(0)
            }

            pub fn clear_remaining(&mut self) {
                self.remaining = ::std::option::Option::None;
            }

            pub fn has_remaining(&self) -> bool {
                self.remaining.is_some()
            }

            // Param is passed by value, moved
            pub fn set_remaining(&mut self, v: u32) {
                self.remaining = ::std::option::Option::Some(v);
            }

            // optional uint32 max = 3;

            pub fn max(&self) -> u32 {
                self.max.unwrap_or(0)
            }

            pub fn clear_max(&mut self) {
                self.max = ::std::option::Option::None;
            }

            pub fn has_max(&self) -> bool {
                self.max.is_some()
            }

            // Param is passed by value, moved
            pub fn set_max(&mut self, v: u32) {
                self.max = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "periodic_resource_id",
                    |m: &PeriodicResourceData| { &m.periodic_resource_id },
                    |m: &mut PeriodicResourceData| { &mut m.periodic_resource_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "remaining",
                    |m: &PeriodicResourceData| { &m.remaining },
                    |m: &mut PeriodicResourceData| { &mut m.remaining },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "max",
                    |m: &PeriodicResourceData| { &m.max },
                    |m: &mut PeriodicResourceData| { &mut m.max },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeriodicResourceData>(
                    "CDOTAMatchMetadata.Team.PeriodicResourceData",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PeriodicResourceData {
            const NAME: &'static str = "PeriodicResourceData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.remaining = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.max = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.periodic_resource_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.remaining {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.max {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.periodic_resource_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.remaining {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.max {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PeriodicResourceData {
                PeriodicResourceData::new()
            }

            fn clear(&mut self) {
                self.periodic_resource_id = ::std::option::Option::None;
                self.remaining = ::std::option::Option::None;
                self.max = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PeriodicResourceData {
                static instance: PeriodicResourceData = PeriodicResourceData {
                    periodic_resource_id: ::std::option::Option::None,
                    remaining: ::std::option::Option::None,
                    max: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for PeriodicResourceData {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.PeriodicResourceData").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PeriodicResourceData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PeriodicResourceData {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.EventData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct EventData {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.event_id)
            pub event_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.event_points)
            pub event_points: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.challenge_instance_id)
            pub challenge_instance_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.challenge_quest_id)
            pub challenge_quest_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.challenge_quest_challenge_id)
            pub challenge_quest_challenge_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.challenge_completed)
            pub challenge_completed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.challenge_rank_completed)
            pub challenge_rank_completed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.challenge_rank_previously_completed)
            pub challenge_rank_previously_completed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.event_owned)
            pub event_owned: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.sub_challenges_with_progress)
            pub sub_challenges_with_progress: ::std::vec::Vec<SubChallenge>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.wager_winnings)
            pub wager_winnings: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.cavern_challenge_active)
            pub cavern_challenge_active: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.cavern_challenge_winnings)
            pub cavern_challenge_winnings: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.amount_wagered)
            pub amount_wagered: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.periodic_point_adjustments)
            pub periodic_point_adjustments: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.cavern_challenge_map_results)
            pub cavern_challenge_map_results: ::std::vec::Vec<CavernChallengeResult>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.cavern_challenge_plus_shard_winnings)
            pub cavern_challenge_plus_shard_winnings: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.actions_granted)
            pub actions_granted: ::std::vec::Vec<ActionGrant>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.cavern_crawl_map_variant)
            pub cavern_crawl_map_variant: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.team_wager_bonus_pct)
            pub team_wager_bonus_pct: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.wager_streak_pct)
            pub wager_streak_pct: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.candy_points_granted)
            pub candy_points_granted: ::std::vec::Vec<CandyGrant>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.active_season_id)
            pub active_season_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.cavern_crawl_half_credit)
            pub cavern_crawl_half_credit: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.EventData.periodic_resources)
            pub periodic_resources: ::std::vec::Vec<PeriodicResourceData>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.EventData.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a EventData {
            fn default() -> &'a EventData {
                <EventData as ::protobuf::Message>::default_instance()
            }
        }

        impl EventData {
            pub fn new() -> EventData {
                ::std::default::Default::default()
            }

            // optional uint32 event_id = 1;

            pub fn event_id(&self) -> u32 {
                self.event_id.unwrap_or(0)
            }

            pub fn clear_event_id(&mut self) {
                self.event_id = ::std::option::Option::None;
            }

            pub fn has_event_id(&self) -> bool {
                self.event_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_id(&mut self, v: u32) {
                self.event_id = ::std::option::Option::Some(v);
            }

            // optional uint32 event_points = 2;

            pub fn event_points(&self) -> u32 {
                self.event_points.unwrap_or(0)
            }

            pub fn clear_event_points(&mut self) {
                self.event_points = ::std::option::Option::None;
            }

            pub fn has_event_points(&self) -> bool {
                self.event_points.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_points(&mut self, v: u32) {
                self.event_points = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_instance_id = 3;

            pub fn challenge_instance_id(&self) -> u32 {
                self.challenge_instance_id.unwrap_or(0)
            }

            pub fn clear_challenge_instance_id(&mut self) {
                self.challenge_instance_id = ::std::option::Option::None;
            }

            pub fn has_challenge_instance_id(&self) -> bool {
                self.challenge_instance_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_instance_id(&mut self, v: u32) {
                self.challenge_instance_id = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_quest_id = 4;

            pub fn challenge_quest_id(&self) -> u32 {
                self.challenge_quest_id.unwrap_or(0)
            }

            pub fn clear_challenge_quest_id(&mut self) {
                self.challenge_quest_id = ::std::option::Option::None;
            }

            pub fn has_challenge_quest_id(&self) -> bool {
                self.challenge_quest_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_quest_id(&mut self, v: u32) {
                self.challenge_quest_id = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_quest_challenge_id = 5;

            pub fn challenge_quest_challenge_id(&self) -> u32 {
                self.challenge_quest_challenge_id.unwrap_or(0)
            }

            pub fn clear_challenge_quest_challenge_id(&mut self) {
                self.challenge_quest_challenge_id = ::std::option::Option::None;
            }

            pub fn has_challenge_quest_challenge_id(&self) -> bool {
                self.challenge_quest_challenge_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_quest_challenge_id(&mut self, v: u32) {
                self.challenge_quest_challenge_id = ::std::option::Option::Some(v);
            }

            // optional bool challenge_completed = 6;

            pub fn challenge_completed(&self) -> bool {
                self.challenge_completed.unwrap_or(false)
            }

            pub fn clear_challenge_completed(&mut self) {
                self.challenge_completed = ::std::option::Option::None;
            }

            pub fn has_challenge_completed(&self) -> bool {
                self.challenge_completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_completed(&mut self, v: bool) {
                self.challenge_completed = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_rank_completed = 7;

            pub fn challenge_rank_completed(&self) -> u32 {
                self.challenge_rank_completed.unwrap_or(0)
            }

            pub fn clear_challenge_rank_completed(&mut self) {
                self.challenge_rank_completed = ::std::option::Option::None;
            }

            pub fn has_challenge_rank_completed(&self) -> bool {
                self.challenge_rank_completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_rank_completed(&mut self, v: u32) {
                self.challenge_rank_completed = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_rank_previously_completed = 8;

            pub fn challenge_rank_previously_completed(&self) -> u32 {
                self.challenge_rank_previously_completed.unwrap_or(0)
            }

            pub fn clear_challenge_rank_previously_completed(&mut self) {
                self.challenge_rank_previously_completed = ::std::option::Option::None;
            }

            pub fn has_challenge_rank_previously_completed(&self) -> bool {
                self.challenge_rank_previously_completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_rank_previously_completed(&mut self, v: u32) {
                self.challenge_rank_previously_completed = ::std::option::Option::Some(v);
            }

            // optional bool event_owned = 9;

            pub fn event_owned(&self) -> bool {
                self.event_owned.unwrap_or(false)
            }

            pub fn clear_event_owned(&mut self) {
                self.event_owned = ::std::option::Option::None;
            }

            pub fn has_event_owned(&self) -> bool {
                self.event_owned.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_owned(&mut self, v: bool) {
                self.event_owned = ::std::option::Option::Some(v);
            }

            // optional uint32 wager_winnings = 11;

            pub fn wager_winnings(&self) -> u32 {
                self.wager_winnings.unwrap_or(0)
            }

            pub fn clear_wager_winnings(&mut self) {
                self.wager_winnings = ::std::option::Option::None;
            }

            pub fn has_wager_winnings(&self) -> bool {
                self.wager_winnings.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wager_winnings(&mut self, v: u32) {
                self.wager_winnings = ::std::option::Option::Some(v);
            }

            // optional bool cavern_challenge_active = 12;

            pub fn cavern_challenge_active(&self) -> bool {
                self.cavern_challenge_active.unwrap_or(false)
            }

            pub fn clear_cavern_challenge_active(&mut self) {
                self.cavern_challenge_active = ::std::option::Option::None;
            }

            pub fn has_cavern_challenge_active(&self) -> bool {
                self.cavern_challenge_active.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_challenge_active(&mut self, v: bool) {
                self.cavern_challenge_active = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_challenge_winnings = 13;

            pub fn cavern_challenge_winnings(&self) -> u32 {
                self.cavern_challenge_winnings.unwrap_or(0)
            }

            pub fn clear_cavern_challenge_winnings(&mut self) {
                self.cavern_challenge_winnings = ::std::option::Option::None;
            }

            pub fn has_cavern_challenge_winnings(&self) -> bool {
                self.cavern_challenge_winnings.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_challenge_winnings(&mut self, v: u32) {
                self.cavern_challenge_winnings = ::std::option::Option::Some(v);
            }

            // optional uint32 amount_wagered = 14;

            pub fn amount_wagered(&self) -> u32 {
                self.amount_wagered.unwrap_or(0)
            }

            pub fn clear_amount_wagered(&mut self) {
                self.amount_wagered = ::std::option::Option::None;
            }

            pub fn has_amount_wagered(&self) -> bool {
                self.amount_wagered.is_some()
            }

            // Param is passed by value, moved
            pub fn set_amount_wagered(&mut self, v: u32) {
                self.amount_wagered = ::std::option::Option::Some(v);
            }

            // optional uint32 periodic_point_adjustments = 16;

            pub fn periodic_point_adjustments(&self) -> u32 {
                self.periodic_point_adjustments.unwrap_or(0)
            }

            pub fn clear_periodic_point_adjustments(&mut self) {
                self.periodic_point_adjustments = ::std::option::Option::None;
            }

            pub fn has_periodic_point_adjustments(&self) -> bool {
                self.periodic_point_adjustments.is_some()
            }

            // Param is passed by value, moved
            pub fn set_periodic_point_adjustments(&mut self, v: u32) {
                self.periodic_point_adjustments = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_challenge_plus_shard_winnings = 18;

            pub fn cavern_challenge_plus_shard_winnings(&self) -> u32 {
                self.cavern_challenge_plus_shard_winnings.unwrap_or(0)
            }

            pub fn clear_cavern_challenge_plus_shard_winnings(&mut self) {
                self.cavern_challenge_plus_shard_winnings = ::std::option::Option::None;
            }

            pub fn has_cavern_challenge_plus_shard_winnings(&self) -> bool {
                self.cavern_challenge_plus_shard_winnings.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_challenge_plus_shard_winnings(&mut self, v: u32) {
                self.cavern_challenge_plus_shard_winnings = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_crawl_map_variant = 20;

            pub fn cavern_crawl_map_variant(&self) -> u32 {
                self.cavern_crawl_map_variant.unwrap_or(0)
            }

            pub fn clear_cavern_crawl_map_variant(&mut self) {
                self.cavern_crawl_map_variant = ::std::option::Option::None;
            }

            pub fn has_cavern_crawl_map_variant(&self) -> bool {
                self.cavern_crawl_map_variant.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_crawl_map_variant(&mut self, v: u32) {
                self.cavern_crawl_map_variant = ::std::option::Option::Some(v);
            }

            // optional uint32 team_wager_bonus_pct = 21;

            pub fn team_wager_bonus_pct(&self) -> u32 {
                self.team_wager_bonus_pct.unwrap_or(0)
            }

            pub fn clear_team_wager_bonus_pct(&mut self) {
                self.team_wager_bonus_pct = ::std::option::Option::None;
            }

            pub fn has_team_wager_bonus_pct(&self) -> bool {
                self.team_wager_bonus_pct.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_wager_bonus_pct(&mut self, v: u32) {
                self.team_wager_bonus_pct = ::std::option::Option::Some(v);
            }

            // optional uint32 wager_streak_pct = 22;

            pub fn wager_streak_pct(&self) -> u32 {
                self.wager_streak_pct.unwrap_or(0)
            }

            pub fn clear_wager_streak_pct(&mut self) {
                self.wager_streak_pct = ::std::option::Option::None;
            }

            pub fn has_wager_streak_pct(&self) -> bool {
                self.wager_streak_pct.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wager_streak_pct(&mut self, v: u32) {
                self.wager_streak_pct = ::std::option::Option::Some(v);
            }

            // optional uint32 active_season_id = 24;

            pub fn active_season_id(&self) -> u32 {
                self.active_season_id.unwrap_or(0)
            }

            pub fn clear_active_season_id(&mut self) {
                self.active_season_id = ::std::option::Option::None;
            }

            pub fn has_active_season_id(&self) -> bool {
                self.active_season_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_active_season_id(&mut self, v: u32) {
                self.active_season_id = ::std::option::Option::Some(v);
            }

            // optional bool cavern_crawl_half_credit = 25;

            pub fn cavern_crawl_half_credit(&self) -> bool {
                self.cavern_crawl_half_credit.unwrap_or(false)
            }

            pub fn clear_cavern_crawl_half_credit(&mut self) {
                self.cavern_crawl_half_credit = ::std::option::Option::None;
            }

            pub fn has_cavern_crawl_half_credit(&self) -> bool {
                self.cavern_crawl_half_credit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_crawl_half_credit(&mut self, v: bool) {
                self.cavern_crawl_half_credit = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(25);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "event_id",
                    |m: &EventData| { &m.event_id },
                    |m: &mut EventData| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "event_points",
                    |m: &EventData| { &m.event_points },
                    |m: &mut EventData| { &mut m.event_points },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "challenge_instance_id",
                    |m: &EventData| { &m.challenge_instance_id },
                    |m: &mut EventData| { &mut m.challenge_instance_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "challenge_quest_id",
                    |m: &EventData| { &m.challenge_quest_id },
                    |m: &mut EventData| { &mut m.challenge_quest_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "challenge_quest_challenge_id",
                    |m: &EventData| { &m.challenge_quest_challenge_id },
                    |m: &mut EventData| { &mut m.challenge_quest_challenge_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "challenge_completed",
                    |m: &EventData| { &m.challenge_completed },
                    |m: &mut EventData| { &mut m.challenge_completed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "challenge_rank_completed",
                    |m: &EventData| { &m.challenge_rank_completed },
                    |m: &mut EventData| { &mut m.challenge_rank_completed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "challenge_rank_previously_completed",
                    |m: &EventData| { &m.challenge_rank_previously_completed },
                    |m: &mut EventData| { &mut m.challenge_rank_previously_completed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "event_owned",
                    |m: &EventData| { &m.event_owned },
                    |m: &mut EventData| { &mut m.event_owned },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "sub_challenges_with_progress",
                    |m: &EventData| { &m.sub_challenges_with_progress },
                    |m: &mut EventData| { &mut m.sub_challenges_with_progress },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "wager_winnings",
                    |m: &EventData| { &m.wager_winnings },
                    |m: &mut EventData| { &mut m.wager_winnings },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "cavern_challenge_active",
                    |m: &EventData| { &m.cavern_challenge_active },
                    |m: &mut EventData| { &mut m.cavern_challenge_active },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "cavern_challenge_winnings",
                    |m: &EventData| { &m.cavern_challenge_winnings },
                    |m: &mut EventData| { &mut m.cavern_challenge_winnings },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "amount_wagered",
                    |m: &EventData| { &m.amount_wagered },
                    |m: &mut EventData| { &mut m.amount_wagered },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "periodic_point_adjustments",
                    |m: &EventData| { &m.periodic_point_adjustments },
                    |m: &mut EventData| { &mut m.periodic_point_adjustments },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "cavern_challenge_map_results",
                    |m: &EventData| { &m.cavern_challenge_map_results },
                    |m: &mut EventData| { &mut m.cavern_challenge_map_results },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "cavern_challenge_plus_shard_winnings",
                    |m: &EventData| { &m.cavern_challenge_plus_shard_winnings },
                    |m: &mut EventData| { &mut m.cavern_challenge_plus_shard_winnings },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "actions_granted",
                    |m: &EventData| { &m.actions_granted },
                    |m: &mut EventData| { &mut m.actions_granted },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "cavern_crawl_map_variant",
                    |m: &EventData| { &m.cavern_crawl_map_variant },
                    |m: &mut EventData| { &mut m.cavern_crawl_map_variant },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_wager_bonus_pct",
                    |m: &EventData| { &m.team_wager_bonus_pct },
                    |m: &mut EventData| { &mut m.team_wager_bonus_pct },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "wager_streak_pct",
                    |m: &EventData| { &m.wager_streak_pct },
                    |m: &mut EventData| { &mut m.wager_streak_pct },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "candy_points_granted",
                    |m: &EventData| { &m.candy_points_granted },
                    |m: &mut EventData| { &mut m.candy_points_granted },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "active_season_id",
                    |m: &EventData| { &m.active_season_id },
                    |m: &mut EventData| { &mut m.active_season_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "cavern_crawl_half_credit",
                    |m: &EventData| { &m.cavern_crawl_half_credit },
                    |m: &mut EventData| { &mut m.cavern_crawl_half_credit },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "periodic_resources",
                    |m: &EventData| { &m.periodic_resources },
                    |m: &mut EventData| { &mut m.periodic_resources },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventData>(
                    "CDOTAMatchMetadata.Team.EventData",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for EventData {
            const NAME: &'static str = "EventData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.event_points = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.challenge_quest_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.challenge_quest_challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.challenge_completed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        56 => {
                            self.challenge_rank_completed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.challenge_rank_previously_completed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.event_owned = ::std::option::Option::Some(is.read_bool()?);
                        },
                        82 => {
                            self.sub_challenges_with_progress.push(is.read_message()?);
                        },
                        88 => {
                            self.wager_winnings = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        96 => {
                            self.cavern_challenge_active = ::std::option::Option::Some(is.read_bool()?);
                        },
                        104 => {
                            self.cavern_challenge_winnings = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        112 => {
                            self.amount_wagered = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        128 => {
                            self.periodic_point_adjustments = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        138 => {
                            self.cavern_challenge_map_results.push(is.read_message()?);
                        },
                        144 => {
                            self.cavern_challenge_plus_shard_winnings = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        154 => {
                            self.actions_granted.push(is.read_message()?);
                        },
                        160 => {
                            self.cavern_crawl_map_variant = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        168 => {
                            self.team_wager_bonus_pct = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        176 => {
                            self.wager_streak_pct = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        186 => {
                            self.candy_points_granted.push(is.read_message()?);
                        },
                        192 => {
                            self.active_season_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        200 => {
                            self.cavern_crawl_half_credit = ::std::option::Option::Some(is.read_bool()?);
                        },
                        210 => {
                            self.periodic_resources.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.event_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.event_points {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.challenge_instance_id {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.challenge_quest_id {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.challenge_quest_challenge_id {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.challenge_completed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.challenge_rank_completed {
                    my_size += ::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.challenge_rank_previously_completed {
                    my_size += ::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.event_owned {
                    my_size += 1 + 1;
                }
                for value in &self.sub_challenges_with_progress {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.wager_winnings {
                    my_size += ::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.cavern_challenge_active {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.cavern_challenge_winnings {
                    my_size += ::protobuf::rt::uint32_size(13, v);
                }
                if let Some(v) = self.amount_wagered {
                    my_size += ::protobuf::rt::uint32_size(14, v);
                }
                if let Some(v) = self.periodic_point_adjustments {
                    my_size += ::protobuf::rt::uint32_size(16, v);
                }
                for value in &self.cavern_challenge_map_results {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.cavern_challenge_plus_shard_winnings {
                    my_size += ::protobuf::rt::uint32_size(18, v);
                }
                for value in &self.actions_granted {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.cavern_crawl_map_variant {
                    my_size += ::protobuf::rt::uint32_size(20, v);
                }
                if let Some(v) = self.team_wager_bonus_pct {
                    my_size += ::protobuf::rt::uint32_size(21, v);
                }
                if let Some(v) = self.wager_streak_pct {
                    my_size += ::protobuf::rt::uint32_size(22, v);
                }
                for value in &self.candy_points_granted {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.active_season_id {
                    my_size += ::protobuf::rt::uint32_size(24, v);
                }
                if let Some(v) = self.cavern_crawl_half_credit {
                    my_size += 2 + 1;
                }
                for value in &self.periodic_resources {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.event_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.event_points {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.challenge_instance_id {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.challenge_quest_id {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.challenge_quest_challenge_id {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.challenge_completed {
                    os.write_bool(6, v)?;
                }
                if let Some(v) = self.challenge_rank_completed {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.challenge_rank_previously_completed {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.event_owned {
                    os.write_bool(9, v)?;
                }
                for v in &self.sub_challenges_with_progress {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                };
                if let Some(v) = self.wager_winnings {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.cavern_challenge_active {
                    os.write_bool(12, v)?;
                }
                if let Some(v) = self.cavern_challenge_winnings {
                    os.write_uint32(13, v)?;
                }
                if let Some(v) = self.amount_wagered {
                    os.write_uint32(14, v)?;
                }
                if let Some(v) = self.periodic_point_adjustments {
                    os.write_uint32(16, v)?;
                }
                for v in &self.cavern_challenge_map_results {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                };
                if let Some(v) = self.cavern_challenge_plus_shard_winnings {
                    os.write_uint32(18, v)?;
                }
                for v in &self.actions_granted {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                };
                if let Some(v) = self.cavern_crawl_map_variant {
                    os.write_uint32(20, v)?;
                }
                if let Some(v) = self.team_wager_bonus_pct {
                    os.write_uint32(21, v)?;
                }
                if let Some(v) = self.wager_streak_pct {
                    os.write_uint32(22, v)?;
                }
                for v in &self.candy_points_granted {
                    ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
                };
                if let Some(v) = self.active_season_id {
                    os.write_uint32(24, v)?;
                }
                if let Some(v) = self.cavern_crawl_half_credit {
                    os.write_bool(25, v)?;
                }
                for v in &self.periodic_resources {
                    ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> EventData {
                EventData::new()
            }

            fn clear(&mut self) {
                self.event_id = ::std::option::Option::None;
                self.event_points = ::std::option::Option::None;
                self.challenge_instance_id = ::std::option::Option::None;
                self.challenge_quest_id = ::std::option::Option::None;
                self.challenge_quest_challenge_id = ::std::option::Option::None;
                self.challenge_completed = ::std::option::Option::None;
                self.challenge_rank_completed = ::std::option::Option::None;
                self.challenge_rank_previously_completed = ::std::option::Option::None;
                self.event_owned = ::std::option::Option::None;
                self.sub_challenges_with_progress.clear();
                self.wager_winnings = ::std::option::Option::None;
                self.cavern_challenge_active = ::std::option::Option::None;
                self.cavern_challenge_winnings = ::std::option::Option::None;
                self.amount_wagered = ::std::option::Option::None;
                self.periodic_point_adjustments = ::std::option::Option::None;
                self.cavern_challenge_map_results.clear();
                self.cavern_challenge_plus_shard_winnings = ::std::option::Option::None;
                self.actions_granted.clear();
                self.cavern_crawl_map_variant = ::std::option::Option::None;
                self.team_wager_bonus_pct = ::std::option::Option::None;
                self.wager_streak_pct = ::std::option::Option::None;
                self.candy_points_granted.clear();
                self.active_season_id = ::std::option::Option::None;
                self.cavern_crawl_half_credit = ::std::option::Option::None;
                self.periodic_resources.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static EventData {
                static instance: EventData = EventData {
                    event_id: ::std::option::Option::None,
                    event_points: ::std::option::Option::None,
                    challenge_instance_id: ::std::option::Option::None,
                    challenge_quest_id: ::std::option::Option::None,
                    challenge_quest_challenge_id: ::std::option::Option::None,
                    challenge_completed: ::std::option::Option::None,
                    challenge_rank_completed: ::std::option::Option::None,
                    challenge_rank_previously_completed: ::std::option::Option::None,
                    event_owned: ::std::option::Option::None,
                    sub_challenges_with_progress: ::std::vec::Vec::new(),
                    wager_winnings: ::std::option::Option::None,
                    cavern_challenge_active: ::std::option::Option::None,
                    cavern_challenge_winnings: ::std::option::Option::None,
                    amount_wagered: ::std::option::Option::None,
                    periodic_point_adjustments: ::std::option::Option::None,
                    cavern_challenge_map_results: ::std::vec::Vec::new(),
                    cavern_challenge_plus_shard_winnings: ::std::option::Option::None,
                    actions_granted: ::std::vec::Vec::new(),
                    cavern_crawl_map_variant: ::std::option::Option::None,
                    team_wager_bonus_pct: ::std::option::Option::None,
                    wager_streak_pct: ::std::option::Option::None,
                    candy_points_granted: ::std::vec::Vec::new(),
                    active_season_id: ::std::option::Option::None,
                    cavern_crawl_half_credit: ::std::option::Option::None,
                    periodic_resources: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for EventData {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.EventData").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for EventData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for EventData {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.FeaturedGamemodeProgress)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FeaturedGamemodeProgress {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.start_value)
            pub start_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.end_value)
            pub end_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.max_value)
            pub max_value: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FeaturedGamemodeProgress {
            fn default() -> &'a FeaturedGamemodeProgress {
                <FeaturedGamemodeProgress as ::protobuf::Message>::default_instance()
            }
        }

        impl FeaturedGamemodeProgress {
            pub fn new() -> FeaturedGamemodeProgress {
                ::std::default::Default::default()
            }

            // optional uint32 start_value = 1;

            pub fn start_value(&self) -> u32 {
                self.start_value.unwrap_or(0)
            }

            pub fn clear_start_value(&mut self) {
                self.start_value = ::std::option::Option::None;
            }

            pub fn has_start_value(&self) -> bool {
                self.start_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_start_value(&mut self, v: u32) {
                self.start_value = ::std::option::Option::Some(v);
            }

            // optional uint32 end_value = 2;

            pub fn end_value(&self) -> u32 {
                self.end_value.unwrap_or(0)
            }

            pub fn clear_end_value(&mut self) {
                self.end_value = ::std::option::Option::None;
            }

            pub fn has_end_value(&self) -> bool {
                self.end_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_end_value(&mut self, v: u32) {
                self.end_value = ::std::option::Option::Some(v);
            }

            // optional uint32 max_value = 3;

            pub fn max_value(&self) -> u32 {
                self.max_value.unwrap_or(0)
            }

            pub fn clear_max_value(&mut self) {
                self.max_value = ::std::option::Option::None;
            }

            pub fn has_max_value(&self) -> bool {
                self.max_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_max_value(&mut self, v: u32) {
                self.max_value = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "start_value",
                    |m: &FeaturedGamemodeProgress| { &m.start_value },
                    |m: &mut FeaturedGamemodeProgress| { &mut m.start_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "end_value",
                    |m: &FeaturedGamemodeProgress| { &m.end_value },
                    |m: &mut FeaturedGamemodeProgress| { &mut m.end_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "max_value",
                    |m: &FeaturedGamemodeProgress| { &m.max_value },
                    |m: &mut FeaturedGamemodeProgress| { &mut m.max_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeaturedGamemodeProgress>(
                    "CDOTAMatchMetadata.Team.FeaturedGamemodeProgress",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for FeaturedGamemodeProgress {
            const NAME: &'static str = "FeaturedGamemodeProgress";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.start_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.end_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.max_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.start_value {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.end_value {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.max_value {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.start_value {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.end_value {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.max_value {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FeaturedGamemodeProgress {
                FeaturedGamemodeProgress::new()
            }

            fn clear(&mut self) {
                self.start_value = ::std::option::Option::None;
                self.end_value = ::std::option::Option::None;
                self.max_value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FeaturedGamemodeProgress {
                static instance: FeaturedGamemodeProgress = FeaturedGamemodeProgress {
                    start_value: ::std::option::Option::None,
                    end_value: ::std::option::Option::None,
                    max_value: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for FeaturedGamemodeProgress {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.FeaturedGamemodeProgress").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for FeaturedGamemodeProgress {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for FeaturedGamemodeProgress {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.Player)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Player {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ability_upgrades)
            pub ability_upgrades: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.kills)
            pub kills: ::std::vec::Vec<PlayerKill>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.items)
            pub items: ::std::vec::Vec<ItemPurchase>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.avg_kills_x16)
            pub avg_kills_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.avg_deaths_x16)
            pub avg_deaths_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.avg_assists_x16)
            pub avg_assists_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.avg_gpm_x16)
            pub avg_gpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.avg_xpm_x16)
            pub avg_xpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.best_kills_x16)
            pub best_kills_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.best_assists_x16)
            pub best_assists_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.best_gpm_x16)
            pub best_gpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.best_xpm_x16)
            pub best_xpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.win_streak)
            pub win_streak: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.best_win_streak)
            pub best_win_streak: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.fight_score)
            pub fight_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.farm_score)
            pub farm_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.support_score)
            pub support_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.push_score)
            pub push_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.level_up_times)
            pub level_up_times: ::std::vec::Vec<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.graph_net_worth)
            pub graph_net_worth: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.inventory_snapshot)
            pub inventory_snapshot: ::std::vec::Vec<InventorySnapshot>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.avg_stats_calibrated)
            pub avg_stats_calibrated: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.auto_style_criteria)
            pub auto_style_criteria: ::std::vec::Vec<AutoStyleCriteria>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.event_data)
            pub event_data: ::std::vec::Vec<EventData>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.strange_gem_progress)
            pub strange_gem_progress: ::std::vec::Vec<StrangeGemProgress>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.hero_xp)
            pub hero_xp: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.camps_stacked)
            pub camps_stacked: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.victory_prediction)
            pub victory_prediction: ::std::vec::Vec<VictoryPrediction>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.lane_selection_flags)
            pub lane_selection_flags: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.rampages)
            pub rampages: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.triple_kills)
            pub triple_kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.aegis_snatched)
            pub aegis_snatched: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.rapiers_purchased)
            pub rapiers_purchased: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.couriers_killed)
            pub couriers_killed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.net_worth_rank)
            pub net_worth_rank: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.support_gold_spent)
            pub support_gold_spent: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.observer_wards_placed)
            pub observer_wards_placed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.sentry_wards_placed)
            pub sentry_wards_placed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.wards_dewarded)
            pub wards_dewarded: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.stun_duration)
            pub stun_duration: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.rank_mmr_boost_type)
            pub rank_mmr_boost_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::EDOTAMMRBoostType>>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.contract_progress)
            pub contract_progress: ::std::vec::Vec<player::ContractProgress>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.guild_ids)
            pub guild_ids: ::std::vec::Vec<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.graph_hero_damage)
            pub graph_hero_damage: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.team_number)
            pub team_number: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::DOTA_GC_TEAM>>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.team_slot)
            pub team_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.featured_gamemode_progress)
            pub featured_gamemode_progress: ::protobuf::MessageField<FeaturedGamemodeProgress>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.featured_hero_sticker_index)
            pub featured_hero_sticker_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.featured_hero_sticker_quality)
            pub featured_hero_sticker_quality: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.equipped_econ_items)
            pub equipped_econ_items: ::std::vec::Vec<super::EconItem>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.game_player_id)
            pub game_player_id: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.Player.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Player {
            fn default() -> &'a Player {
                <Player as ::protobuf::Message>::default_instance()
            }
        }

        impl Player {
            pub fn new() -> Player {
                ::std::default::Default::default()
            }

            // optional uint32 player_slot = 3;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_kills_x16 = 7;

            pub fn avg_kills_x16(&self) -> u32 {
                self.avg_kills_x16.unwrap_or(0)
            }

            pub fn clear_avg_kills_x16(&mut self) {
                self.avg_kills_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_kills_x16(&self) -> bool {
                self.avg_kills_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_kills_x16(&mut self, v: u32) {
                self.avg_kills_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_deaths_x16 = 8;

            pub fn avg_deaths_x16(&self) -> u32 {
                self.avg_deaths_x16.unwrap_or(0)
            }

            pub fn clear_avg_deaths_x16(&mut self) {
                self.avg_deaths_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_deaths_x16(&self) -> bool {
                self.avg_deaths_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_deaths_x16(&mut self, v: u32) {
                self.avg_deaths_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_assists_x16 = 9;

            pub fn avg_assists_x16(&self) -> u32 {
                self.avg_assists_x16.unwrap_or(0)
            }

            pub fn clear_avg_assists_x16(&mut self) {
                self.avg_assists_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_assists_x16(&self) -> bool {
                self.avg_assists_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_assists_x16(&mut self, v: u32) {
                self.avg_assists_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_gpm_x16 = 10;

            pub fn avg_gpm_x16(&self) -> u32 {
                self.avg_gpm_x16.unwrap_or(0)
            }

            pub fn clear_avg_gpm_x16(&mut self) {
                self.avg_gpm_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_gpm_x16(&self) -> bool {
                self.avg_gpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_gpm_x16(&mut self, v: u32) {
                self.avg_gpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_xpm_x16 = 11;

            pub fn avg_xpm_x16(&self) -> u32 {
                self.avg_xpm_x16.unwrap_or(0)
            }

            pub fn clear_avg_xpm_x16(&mut self) {
                self.avg_xpm_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_xpm_x16(&self) -> bool {
                self.avg_xpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_xpm_x16(&mut self, v: u32) {
                self.avg_xpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_kills_x16 = 12;

            pub fn best_kills_x16(&self) -> u32 {
                self.best_kills_x16.unwrap_or(0)
            }

            pub fn clear_best_kills_x16(&mut self) {
                self.best_kills_x16 = ::std::option::Option::None;
            }

            pub fn has_best_kills_x16(&self) -> bool {
                self.best_kills_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_kills_x16(&mut self, v: u32) {
                self.best_kills_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_assists_x16 = 13;

            pub fn best_assists_x16(&self) -> u32 {
                self.best_assists_x16.unwrap_or(0)
            }

            pub fn clear_best_assists_x16(&mut self) {
                self.best_assists_x16 = ::std::option::Option::None;
            }

            pub fn has_best_assists_x16(&self) -> bool {
                self.best_assists_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_assists_x16(&mut self, v: u32) {
                self.best_assists_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_gpm_x16 = 14;

            pub fn best_gpm_x16(&self) -> u32 {
                self.best_gpm_x16.unwrap_or(0)
            }

            pub fn clear_best_gpm_x16(&mut self) {
                self.best_gpm_x16 = ::std::option::Option::None;
            }

            pub fn has_best_gpm_x16(&self) -> bool {
                self.best_gpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_gpm_x16(&mut self, v: u32) {
                self.best_gpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_xpm_x16 = 15;

            pub fn best_xpm_x16(&self) -> u32 {
                self.best_xpm_x16.unwrap_or(0)
            }

            pub fn clear_best_xpm_x16(&mut self) {
                self.best_xpm_x16 = ::std::option::Option::None;
            }

            pub fn has_best_xpm_x16(&self) -> bool {
                self.best_xpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_xpm_x16(&mut self, v: u32) {
                self.best_xpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 win_streak = 16;

            pub fn win_streak(&self) -> u32 {
                self.win_streak.unwrap_or(0)
            }

            pub fn clear_win_streak(&mut self) {
                self.win_streak = ::std::option::Option::None;
            }

            pub fn has_win_streak(&self) -> bool {
                self.win_streak.is_some()
            }

            // Param is passed by value, moved
            pub fn set_win_streak(&mut self, v: u32) {
                self.win_streak = ::std::option::Option::Some(v);
            }

            // optional uint32 best_win_streak = 17;

            pub fn best_win_streak(&self) -> u32 {
                self.best_win_streak.unwrap_or(0)
            }

            pub fn clear_best_win_streak(&mut self) {
                self.best_win_streak = ::std::option::Option::None;
            }

            pub fn has_best_win_streak(&self) -> bool {
                self.best_win_streak.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_win_streak(&mut self, v: u32) {
                self.best_win_streak = ::std::option::Option::Some(v);
            }

            // optional float fight_score = 18;

            pub fn fight_score(&self) -> f32 {
                self.fight_score.unwrap_or(0.)
            }

            pub fn clear_fight_score(&mut self) {
                self.fight_score = ::std::option::Option::None;
            }

            pub fn has_fight_score(&self) -> bool {
                self.fight_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_fight_score(&mut self, v: f32) {
                self.fight_score = ::std::option::Option::Some(v);
            }

            // optional float farm_score = 19;

            pub fn farm_score(&self) -> f32 {
                self.farm_score.unwrap_or(0.)
            }

            pub fn clear_farm_score(&mut self) {
                self.farm_score = ::std::option::Option::None;
            }

            pub fn has_farm_score(&self) -> bool {
                self.farm_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_farm_score(&mut self, v: f32) {
                self.farm_score = ::std::option::Option::Some(v);
            }

            // optional float support_score = 20;

            pub fn support_score(&self) -> f32 {
                self.support_score.unwrap_or(0.)
            }

            pub fn clear_support_score(&mut self) {
                self.support_score = ::std::option::Option::None;
            }

            pub fn has_support_score(&self) -> bool {
                self.support_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_score(&mut self, v: f32) {
                self.support_score = ::std::option::Option::Some(v);
            }

            // optional float push_score = 21;

            pub fn push_score(&self) -> f32 {
                self.push_score.unwrap_or(0.)
            }

            pub fn clear_push_score(&mut self) {
                self.push_score = ::std::option::Option::None;
            }

            pub fn has_push_score(&self) -> bool {
                self.push_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_push_score(&mut self, v: f32) {
                self.push_score = ::std::option::Option::Some(v);
            }

            // optional bool avg_stats_calibrated = 25;

            pub fn avg_stats_calibrated(&self) -> bool {
                self.avg_stats_calibrated.unwrap_or(false)
            }

            pub fn clear_avg_stats_calibrated(&mut self) {
                self.avg_stats_calibrated = ::std::option::Option::None;
            }

            pub fn has_avg_stats_calibrated(&self) -> bool {
                self.avg_stats_calibrated.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_stats_calibrated(&mut self, v: bool) {
                self.avg_stats_calibrated = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_xp = 31;

            pub fn hero_xp(&self) -> u32 {
                self.hero_xp.unwrap_or(0)
            }

            pub fn clear_hero_xp(&mut self) {
                self.hero_xp = ::std::option::Option::None;
            }

            pub fn has_hero_xp(&self) -> bool {
                self.hero_xp.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_xp(&mut self, v: u32) {
                self.hero_xp = ::std::option::Option::Some(v);
            }

            // optional uint32 camps_stacked = 32;

            pub fn camps_stacked(&self) -> u32 {
                self.camps_stacked.unwrap_or(0)
            }

            pub fn clear_camps_stacked(&mut self) {
                self.camps_stacked = ::std::option::Option::None;
            }

            pub fn has_camps_stacked(&self) -> bool {
                self.camps_stacked.is_some()
            }

            // Param is passed by value, moved
            pub fn set_camps_stacked(&mut self, v: u32) {
                self.camps_stacked = ::std::option::Option::Some(v);
            }

            // optional uint32 lane_selection_flags = 34;

            pub fn lane_selection_flags(&self) -> u32 {
                self.lane_selection_flags.unwrap_or(0)
            }

            pub fn clear_lane_selection_flags(&mut self) {
                self.lane_selection_flags = ::std::option::Option::None;
            }

            pub fn has_lane_selection_flags(&self) -> bool {
                self.lane_selection_flags.is_some()
            }

            // Param is passed by value, moved
            pub fn set_lane_selection_flags(&mut self, v: u32) {
                self.lane_selection_flags = ::std::option::Option::Some(v);
            }

            // optional uint32 rampages = 35;

            pub fn rampages(&self) -> u32 {
                self.rampages.unwrap_or(0)
            }

            pub fn clear_rampages(&mut self) {
                self.rampages = ::std::option::Option::None;
            }

            pub fn has_rampages(&self) -> bool {
                self.rampages.is_some()
            }

            // Param is passed by value, moved
            pub fn set_rampages(&mut self, v: u32) {
                self.rampages = ::std::option::Option::Some(v);
            }

            // optional uint32 triple_kills = 36;

            pub fn triple_kills(&self) -> u32 {
                self.triple_kills.unwrap_or(0)
            }

            pub fn clear_triple_kills(&mut self) {
                self.triple_kills = ::std::option::Option::None;
            }

            pub fn has_triple_kills(&self) -> bool {
                self.triple_kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_triple_kills(&mut self, v: u32) {
                self.triple_kills = ::std::option::Option::Some(v);
            }

            // optional uint32 aegis_snatched = 37;

            pub fn aegis_snatched(&self) -> u32 {
                self.aegis_snatched.unwrap_or(0)
            }

            pub fn clear_aegis_snatched(&mut self) {
                self.aegis_snatched = ::std::option::Option::None;
            }

            pub fn has_aegis_snatched(&self) -> bool {
                self.aegis_snatched.is_some()
            }

            // Param is passed by value, moved
            pub fn set_aegis_snatched(&mut self, v: u32) {
                self.aegis_snatched = ::std::option::Option::Some(v);
            }

            // optional uint32 rapiers_purchased = 38;

            pub fn rapiers_purchased(&self) -> u32 {
                self.rapiers_purchased.unwrap_or(0)
            }

            pub fn clear_rapiers_purchased(&mut self) {
                self.rapiers_purchased = ::std::option::Option::None;
            }

            pub fn has_rapiers_purchased(&self) -> bool {
                self.rapiers_purchased.is_some()
            }

            // Param is passed by value, moved
            pub fn set_rapiers_purchased(&mut self, v: u32) {
                self.rapiers_purchased = ::std::option::Option::Some(v);
            }

            // optional uint32 couriers_killed = 39;

            pub fn couriers_killed(&self) -> u32 {
                self.couriers_killed.unwrap_or(0)
            }

            pub fn clear_couriers_killed(&mut self) {
                self.couriers_killed = ::std::option::Option::None;
            }

            pub fn has_couriers_killed(&self) -> bool {
                self.couriers_killed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_couriers_killed(&mut self, v: u32) {
                self.couriers_killed = ::std::option::Option::Some(v);
            }

            // optional uint32 net_worth_rank = 40;

            pub fn net_worth_rank(&self) -> u32 {
                self.net_worth_rank.unwrap_or(0)
            }

            pub fn clear_net_worth_rank(&mut self) {
                self.net_worth_rank = ::std::option::Option::None;
            }

            pub fn has_net_worth_rank(&self) -> bool {
                self.net_worth_rank.is_some()
            }

            // Param is passed by value, moved
            pub fn set_net_worth_rank(&mut self, v: u32) {
                self.net_worth_rank = ::std::option::Option::Some(v);
            }

            // optional uint32 support_gold_spent = 41;

            pub fn support_gold_spent(&self) -> u32 {
                self.support_gold_spent.unwrap_or(0)
            }

            pub fn clear_support_gold_spent(&mut self) {
                self.support_gold_spent = ::std::option::Option::None;
            }

            pub fn has_support_gold_spent(&self) -> bool {
                self.support_gold_spent.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_gold_spent(&mut self, v: u32) {
                self.support_gold_spent = ::std::option::Option::Some(v);
            }

            // optional uint32 observer_wards_placed = 42;

            pub fn observer_wards_placed(&self) -> u32 {
                self.observer_wards_placed.unwrap_or(0)
            }

            pub fn clear_observer_wards_placed(&mut self) {
                self.observer_wards_placed = ::std::option::Option::None;
            }

            pub fn has_observer_wards_placed(&self) -> bool {
                self.observer_wards_placed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_observer_wards_placed(&mut self, v: u32) {
                self.observer_wards_placed = ::std::option::Option::Some(v);
            }

            // optional uint32 sentry_wards_placed = 43;

            pub fn sentry_wards_placed(&self) -> u32 {
                self.sentry_wards_placed.unwrap_or(0)
            }

            pub fn clear_sentry_wards_placed(&mut self) {
                self.sentry_wards_placed = ::std::option::Option::None;
            }

            pub fn has_sentry_wards_placed(&self) -> bool {
                self.sentry_wards_placed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sentry_wards_placed(&mut self, v: u32) {
                self.sentry_wards_placed = ::std::option::Option::Some(v);
            }

            // optional uint32 wards_dewarded = 44;

            pub fn wards_dewarded(&self) -> u32 {
                self.wards_dewarded.unwrap_or(0)
            }

            pub fn clear_wards_dewarded(&mut self) {
                self.wards_dewarded = ::std::option::Option::None;
            }

            pub fn has_wards_dewarded(&self) -> bool {
                self.wards_dewarded.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wards_dewarded(&mut self, v: u32) {
                self.wards_dewarded = ::std::option::Option::Some(v);
            }

            // optional float stun_duration = 45;

            pub fn stun_duration(&self) -> f32 {
                self.stun_duration.unwrap_or(0.)
            }

            pub fn clear_stun_duration(&mut self) {
                self.stun_duration = ::std::option::Option::None;
            }

            pub fn has_stun_duration(&self) -> bool {
                self.stun_duration.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stun_duration(&mut self, v: f32) {
                self.stun_duration = ::std::option::Option::Some(v);
            }

            // optional .dota.EDOTAMMRBoostType rank_mmr_boost_type = 46;

            pub fn rank_mmr_boost_type(&self) -> super::super::super::dota_shared_enums::EDOTAMMRBoostType {
                match self.rank_mmr_boost_type {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
                    None => super::super::super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None,
                }
            }

            pub fn clear_rank_mmr_boost_type(&mut self) {
                self.rank_mmr_boost_type = ::std::option::Option::None;
            }

            pub fn has_rank_mmr_boost_type(&self) -> bool {
                self.rank_mmr_boost_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_rank_mmr_boost_type(&mut self, v: super::super::super::dota_shared_enums::EDOTAMMRBoostType) {
                self.rank_mmr_boost_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional .dota.DOTA_GC_TEAM team_number = 51;

            pub fn team_number(&self) -> super::super::super::dota_shared_enums::DOTA_GC_TEAM {
                match self.team_number {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                    None => super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
                }
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: super::super::super::dota_shared_enums::DOTA_GC_TEAM) {
                self.team_number = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 team_slot = 52;

            pub fn team_slot(&self) -> u32 {
                self.team_slot.unwrap_or(0)
            }

            pub fn clear_team_slot(&mut self) {
                self.team_slot = ::std::option::Option::None;
            }

            pub fn has_team_slot(&self) -> bool {
                self.team_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_slot(&mut self, v: u32) {
                self.team_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 featured_hero_sticker_index = 54;

            pub fn featured_hero_sticker_index(&self) -> u32 {
                self.featured_hero_sticker_index.unwrap_or(0)
            }

            pub fn clear_featured_hero_sticker_index(&mut self) {
                self.featured_hero_sticker_index = ::std::option::Option::None;
            }

            pub fn has_featured_hero_sticker_index(&self) -> bool {
                self.featured_hero_sticker_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_featured_hero_sticker_index(&mut self, v: u32) {
                self.featured_hero_sticker_index = ::std::option::Option::Some(v);
            }

            // optional uint32 featured_hero_sticker_quality = 55;

            pub fn featured_hero_sticker_quality(&self) -> u32 {
                self.featured_hero_sticker_quality.unwrap_or(0)
            }

            pub fn clear_featured_hero_sticker_quality(&mut self) {
                self.featured_hero_sticker_quality = ::std::option::Option::None;
            }

            pub fn has_featured_hero_sticker_quality(&self) -> bool {
                self.featured_hero_sticker_quality.is_some()
            }

            // Param is passed by value, moved
            pub fn set_featured_hero_sticker_quality(&mut self, v: u32) {
                self.featured_hero_sticker_quality = ::std::option::Option::Some(v);
            }

            // optional int32 game_player_id = 57;

            pub fn game_player_id(&self) -> i32 {
                self.game_player_id.unwrap_or(0)
            }

            pub fn clear_game_player_id(&mut self) {
                self.game_player_id = ::std::option::Option::None;
            }

            pub fn has_game_player_id(&self) -> bool {
                self.game_player_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_player_id(&mut self, v: i32) {
                self.game_player_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(52);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "ability_upgrades",
                    |m: &Player| { &m.ability_upgrades },
                    |m: &mut Player| { &mut m.ability_upgrades },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "player_slot",
                    |m: &Player| { &m.player_slot },
                    |m: &mut Player| { &mut m.player_slot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "kills",
                    |m: &Player| { &m.kills },
                    |m: &mut Player| { &mut m.kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "items",
                    |m: &Player| { &m.items },
                    |m: &mut Player| { &mut m.items },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "avg_kills_x16",
                    |m: &Player| { &m.avg_kills_x16 },
                    |m: &mut Player| { &mut m.avg_kills_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "avg_deaths_x16",
                    |m: &Player| { &m.avg_deaths_x16 },
                    |m: &mut Player| { &mut m.avg_deaths_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "avg_assists_x16",
                    |m: &Player| { &m.avg_assists_x16 },
                    |m: &mut Player| { &mut m.avg_assists_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "avg_gpm_x16",
                    |m: &Player| { &m.avg_gpm_x16 },
                    |m: &mut Player| { &mut m.avg_gpm_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "avg_xpm_x16",
                    |m: &Player| { &m.avg_xpm_x16 },
                    |m: &mut Player| { &mut m.avg_xpm_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "best_kills_x16",
                    |m: &Player| { &m.best_kills_x16 },
                    |m: &mut Player| { &mut m.best_kills_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "best_assists_x16",
                    |m: &Player| { &m.best_assists_x16 },
                    |m: &mut Player| { &mut m.best_assists_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "best_gpm_x16",
                    |m: &Player| { &m.best_gpm_x16 },
                    |m: &mut Player| { &mut m.best_gpm_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "best_xpm_x16",
                    |m: &Player| { &m.best_xpm_x16 },
                    |m: &mut Player| { &mut m.best_xpm_x16 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "win_streak",
                    |m: &Player| { &m.win_streak },
                    |m: &mut Player| { &mut m.win_streak },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "best_win_streak",
                    |m: &Player| { &m.best_win_streak },
                    |m: &mut Player| { &mut m.best_win_streak },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "fight_score",
                    |m: &Player| { &m.fight_score },
                    |m: &mut Player| { &mut m.fight_score },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "farm_score",
                    |m: &Player| { &m.farm_score },
                    |m: &mut Player| { &mut m.farm_score },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "support_score",
                    |m: &Player| { &m.support_score },
                    |m: &mut Player| { &mut m.support_score },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "push_score",
                    |m: &Player| { &m.push_score },
                    |m: &mut Player| { &mut m.push_score },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "level_up_times",
                    |m: &Player| { &m.level_up_times },
                    |m: &mut Player| { &mut m.level_up_times },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "graph_net_worth",
                    |m: &Player| { &m.graph_net_worth },
                    |m: &mut Player| { &mut m.graph_net_worth },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "inventory_snapshot",
                    |m: &Player| { &m.inventory_snapshot },
                    |m: &mut Player| { &mut m.inventory_snapshot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "avg_stats_calibrated",
                    |m: &Player| { &m.avg_stats_calibrated },
                    |m: &mut Player| { &mut m.avg_stats_calibrated },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "auto_style_criteria",
                    |m: &Player| { &m.auto_style_criteria },
                    |m: &mut Player| { &mut m.auto_style_criteria },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "event_data",
                    |m: &Player| { &m.event_data },
                    |m: &mut Player| { &mut m.event_data },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "strange_gem_progress",
                    |m: &Player| { &m.strange_gem_progress },
                    |m: &mut Player| { &mut m.strange_gem_progress },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_xp",
                    |m: &Player| { &m.hero_xp },
                    |m: &mut Player| { &mut m.hero_xp },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "camps_stacked",
                    |m: &Player| { &m.camps_stacked },
                    |m: &mut Player| { &mut m.camps_stacked },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "victory_prediction",
                    |m: &Player| { &m.victory_prediction },
                    |m: &mut Player| { &mut m.victory_prediction },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "lane_selection_flags",
                    |m: &Player| { &m.lane_selection_flags },
                    |m: &mut Player| { &mut m.lane_selection_flags },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "rampages",
                    |m: &Player| { &m.rampages },
                    |m: &mut Player| { &mut m.rampages },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "triple_kills",
                    |m: &Player| { &m.triple_kills },
                    |m: &mut Player| { &mut m.triple_kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "aegis_snatched",
                    |m: &Player| { &m.aegis_snatched },
                    |m: &mut Player| { &mut m.aegis_snatched },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "rapiers_purchased",
                    |m: &Player| { &m.rapiers_purchased },
                    |m: &mut Player| { &mut m.rapiers_purchased },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "couriers_killed",
                    |m: &Player| { &m.couriers_killed },
                    |m: &mut Player| { &mut m.couriers_killed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "net_worth_rank",
                    |m: &Player| { &m.net_worth_rank },
                    |m: &mut Player| { &mut m.net_worth_rank },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "support_gold_spent",
                    |m: &Player| { &m.support_gold_spent },
                    |m: &mut Player| { &mut m.support_gold_spent },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "observer_wards_placed",
                    |m: &Player| { &m.observer_wards_placed },
                    |m: &mut Player| { &mut m.observer_wards_placed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "sentry_wards_placed",
                    |m: &Player| { &m.sentry_wards_placed },
                    |m: &mut Player| { &mut m.sentry_wards_placed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "wards_dewarded",
                    |m: &Player| { &m.wards_dewarded },
                    |m: &mut Player| { &mut m.wards_dewarded },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "stun_duration",
                    |m: &Player| { &m.stun_duration },
                    |m: &mut Player| { &mut m.stun_duration },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "rank_mmr_boost_type",
                    |m: &Player| { &m.rank_mmr_boost_type },
                    |m: &mut Player| { &mut m.rank_mmr_boost_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "contract_progress",
                    |m: &Player| { &m.contract_progress },
                    |m: &mut Player| { &mut m.contract_progress },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "guild_ids",
                    |m: &Player| { &m.guild_ids },
                    |m: &mut Player| { &mut m.guild_ids },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "graph_hero_damage",
                    |m: &Player| { &m.graph_hero_damage },
                    |m: &mut Player| { &mut m.graph_hero_damage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_number",
                    |m: &Player| { &m.team_number },
                    |m: &mut Player| { &mut m.team_number },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_slot",
                    |m: &Player| { &m.team_slot },
                    |m: &mut Player| { &mut m.team_slot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeaturedGamemodeProgress>(
                    "featured_gamemode_progress",
                    |m: &Player| { &m.featured_gamemode_progress },
                    |m: &mut Player| { &mut m.featured_gamemode_progress },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "featured_hero_sticker_index",
                    |m: &Player| { &m.featured_hero_sticker_index },
                    |m: &mut Player| { &mut m.featured_hero_sticker_index },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "featured_hero_sticker_quality",
                    |m: &Player| { &m.featured_hero_sticker_quality },
                    |m: &mut Player| { &mut m.featured_hero_sticker_quality },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "equipped_econ_items",
                    |m: &Player| { &m.equipped_econ_items },
                    |m: &mut Player| { &mut m.equipped_econ_items },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "game_player_id",
                    |m: &Player| { &m.game_player_id },
                    |m: &mut Player| { &mut m.game_player_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                    "CDOTAMatchMetadata.Team.Player",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Player {
            const NAME: &'static str = "Player";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        18 => {
                            is.read_repeated_packed_int32_into(&mut self.ability_upgrades)?;
                        },
                        16 => {
                            self.ability_upgrades.push(is.read_int32()?);
                        },
                        24 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        42 => {
                            self.kills.push(is.read_message()?);
                        },
                        50 => {
                            self.items.push(is.read_message()?);
                        },
                        56 => {
                            self.avg_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.avg_deaths_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.avg_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        80 => {
                            self.avg_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        88 => {
                            self.avg_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        96 => {
                            self.best_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        104 => {
                            self.best_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        112 => {
                            self.best_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        120 => {
                            self.best_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        128 => {
                            self.win_streak = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        136 => {
                            self.best_win_streak = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        149 => {
                            self.fight_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        157 => {
                            self.farm_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        165 => {
                            self.support_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        173 => {
                            self.push_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        178 => {
                            is.read_repeated_packed_uint32_into(&mut self.level_up_times)?;
                        },
                        176 => {
                            self.level_up_times.push(is.read_uint32()?);
                        },
                        186 => {
                            is.read_repeated_packed_float_into(&mut self.graph_net_worth)?;
                        },
                        189 => {
                            self.graph_net_worth.push(is.read_float()?);
                        },
                        194 => {
                            self.inventory_snapshot.push(is.read_message()?);
                        },
                        200 => {
                            self.avg_stats_calibrated = ::std::option::Option::Some(is.read_bool()?);
                        },
                        210 => {
                            self.auto_style_criteria.push(is.read_message()?);
                        },
                        234 => {
                            self.event_data.push(is.read_message()?);
                        },
                        242 => {
                            self.strange_gem_progress.push(is.read_message()?);
                        },
                        248 => {
                            self.hero_xp = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        256 => {
                            self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        266 => {
                            self.victory_prediction.push(is.read_message()?);
                        },
                        272 => {
                            self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        280 => {
                            self.rampages = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        288 => {
                            self.triple_kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        296 => {
                            self.aegis_snatched = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        304 => {
                            self.rapiers_purchased = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        312 => {
                            self.couriers_killed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        320 => {
                            self.net_worth_rank = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        328 => {
                            self.support_gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        336 => {
                            self.observer_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        344 => {
                            self.sentry_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        352 => {
                            self.wards_dewarded = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        365 => {
                            self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                        },
                        368 => {
                            self.rank_mmr_boost_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        386 => {
                            self.contract_progress.push(is.read_message()?);
                        },
                        394 => {
                            is.read_repeated_packed_uint32_into(&mut self.guild_ids)?;
                        },
                        392 => {
                            self.guild_ids.push(is.read_uint32()?);
                        },
                        402 => {
                            is.read_repeated_packed_float_into(&mut self.graph_hero_damage)?;
                        },
                        405 => {
                            self.graph_hero_damage.push(is.read_float()?);
                        },
                        408 => {
                            self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        416 => {
                            self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        426 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.featured_gamemode_progress)?;
                        },
                        432 => {
                            self.featured_hero_sticker_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        440 => {
                            self.featured_hero_sticker_quality = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        450 => {
                            self.equipped_econ_items.push(is.read_message()?);
                        },
                        456 => {
                            self.game_player_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.ability_upgrades {
                    my_size += ::protobuf::rt::int32_size(2, *value);
                };
                if let Some(v) = self.player_slot {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                for value in &self.kills {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.items {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.avg_kills_x16 {
                    my_size += ::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.avg_deaths_x16 {
                    my_size += ::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.avg_assists_x16 {
                    my_size += ::protobuf::rt::uint32_size(9, v);
                }
                if let Some(v) = self.avg_gpm_x16 {
                    my_size += ::protobuf::rt::uint32_size(10, v);
                }
                if let Some(v) = self.avg_xpm_x16 {
                    my_size += ::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.best_kills_x16 {
                    my_size += ::protobuf::rt::uint32_size(12, v);
                }
                if let Some(v) = self.best_assists_x16 {
                    my_size += ::protobuf::rt::uint32_size(13, v);
                }
                if let Some(v) = self.best_gpm_x16 {
                    my_size += ::protobuf::rt::uint32_size(14, v);
                }
                if let Some(v) = self.best_xpm_x16 {
                    my_size += ::protobuf::rt::uint32_size(15, v);
                }
                if let Some(v) = self.win_streak {
                    my_size += ::protobuf::rt::uint32_size(16, v);
                }
                if let Some(v) = self.best_win_streak {
                    my_size += ::protobuf::rt::uint32_size(17, v);
                }
                if let Some(v) = self.fight_score {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.farm_score {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.support_score {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.push_score {
                    my_size += 2 + 4;
                }
                for value in &self.level_up_times {
                    my_size += ::protobuf::rt::uint32_size(22, *value);
                };
                my_size += 6 * self.graph_net_worth.len() as u64;
                for value in &self.inventory_snapshot {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.avg_stats_calibrated {
                    my_size += 2 + 1;
                }
                for value in &self.auto_style_criteria {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.event_data {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.strange_gem_progress {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.hero_xp {
                    my_size += ::protobuf::rt::uint32_size(31, v);
                }
                if let Some(v) = self.camps_stacked {
                    my_size += ::protobuf::rt::uint32_size(32, v);
                }
                for value in &self.victory_prediction {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.lane_selection_flags {
                    my_size += ::protobuf::rt::uint32_size(34, v);
                }
                if let Some(v) = self.rampages {
                    my_size += ::protobuf::rt::uint32_size(35, v);
                }
                if let Some(v) = self.triple_kills {
                    my_size += ::protobuf::rt::uint32_size(36, v);
                }
                if let Some(v) = self.aegis_snatched {
                    my_size += ::protobuf::rt::uint32_size(37, v);
                }
                if let Some(v) = self.rapiers_purchased {
                    my_size += ::protobuf::rt::uint32_size(38, v);
                }
                if let Some(v) = self.couriers_killed {
                    my_size += ::protobuf::rt::uint32_size(39, v);
                }
                if let Some(v) = self.net_worth_rank {
                    my_size += ::protobuf::rt::uint32_size(40, v);
                }
                if let Some(v) = self.support_gold_spent {
                    my_size += ::protobuf::rt::uint32_size(41, v);
                }
                if let Some(v) = self.observer_wards_placed {
                    my_size += ::protobuf::rt::uint32_size(42, v);
                }
                if let Some(v) = self.sentry_wards_placed {
                    my_size += ::protobuf::rt::uint32_size(43, v);
                }
                if let Some(v) = self.wards_dewarded {
                    my_size += ::protobuf::rt::uint32_size(44, v);
                }
                if let Some(v) = self.stun_duration {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.rank_mmr_boost_type {
                    my_size += ::protobuf::rt::int32_size(46, v.value());
                }
                for value in &self.contract_progress {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.guild_ids {
                    my_size += ::protobuf::rt::uint32_size(49, *value);
                };
                my_size += 6 * self.graph_hero_damage.len() as u64;
                if let Some(v) = self.team_number {
                    my_size += ::protobuf::rt::int32_size(51, v.value());
                }
                if let Some(v) = self.team_slot {
                    my_size += ::protobuf::rt::uint32_size(52, v);
                }
                if let Some(v) = self.featured_gamemode_progress.as_ref() {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.featured_hero_sticker_index {
                    my_size += ::protobuf::rt::uint32_size(54, v);
                }
                if let Some(v) = self.featured_hero_sticker_quality {
                    my_size += ::protobuf::rt::uint32_size(55, v);
                }
                for value in &self.equipped_econ_items {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.game_player_id {
                    my_size += ::protobuf::rt::int32_size(57, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.ability_upgrades {
                    os.write_int32(2, *v)?;
                };
                if let Some(v) = self.player_slot {
                    os.write_uint32(3, v)?;
                }
                for v in &self.kills {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                };
                for v in &self.items {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                };
                if let Some(v) = self.avg_kills_x16 {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.avg_deaths_x16 {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.avg_assists_x16 {
                    os.write_uint32(9, v)?;
                }
                if let Some(v) = self.avg_gpm_x16 {
                    os.write_uint32(10, v)?;
                }
                if let Some(v) = self.avg_xpm_x16 {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.best_kills_x16 {
                    os.write_uint32(12, v)?;
                }
                if let Some(v) = self.best_assists_x16 {
                    os.write_uint32(13, v)?;
                }
                if let Some(v) = self.best_gpm_x16 {
                    os.write_uint32(14, v)?;
                }
                if let Some(v) = self.best_xpm_x16 {
                    os.write_uint32(15, v)?;
                }
                if let Some(v) = self.win_streak {
                    os.write_uint32(16, v)?;
                }
                if let Some(v) = self.best_win_streak {
                    os.write_uint32(17, v)?;
                }
                if let Some(v) = self.fight_score {
                    os.write_float(18, v)?;
                }
                if let Some(v) = self.farm_score {
                    os.write_float(19, v)?;
                }
                if let Some(v) = self.support_score {
                    os.write_float(20, v)?;
                }
                if let Some(v) = self.push_score {
                    os.write_float(21, v)?;
                }
                for v in &self.level_up_times {
                    os.write_uint32(22, *v)?;
                };
                for v in &self.graph_net_worth {
                    os.write_float(23, *v)?;
                };
                for v in &self.inventory_snapshot {
                    ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                };
                if let Some(v) = self.avg_stats_calibrated {
                    os.write_bool(25, v)?;
                }
                for v in &self.auto_style_criteria {
                    ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                };
                for v in &self.event_data {
                    ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
                };
                for v in &self.strange_gem_progress {
                    ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
                };
                if let Some(v) = self.hero_xp {
                    os.write_uint32(31, v)?;
                }
                if let Some(v) = self.camps_stacked {
                    os.write_uint32(32, v)?;
                }
                for v in &self.victory_prediction {
                    ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
                };
                if let Some(v) = self.lane_selection_flags {
                    os.write_uint32(34, v)?;
                }
                if let Some(v) = self.rampages {
                    os.write_uint32(35, v)?;
                }
                if let Some(v) = self.triple_kills {
                    os.write_uint32(36, v)?;
                }
                if let Some(v) = self.aegis_snatched {
                    os.write_uint32(37, v)?;
                }
                if let Some(v) = self.rapiers_purchased {
                    os.write_uint32(38, v)?;
                }
                if let Some(v) = self.couriers_killed {
                    os.write_uint32(39, v)?;
                }
                if let Some(v) = self.net_worth_rank {
                    os.write_uint32(40, v)?;
                }
                if let Some(v) = self.support_gold_spent {
                    os.write_uint32(41, v)?;
                }
                if let Some(v) = self.observer_wards_placed {
                    os.write_uint32(42, v)?;
                }
                if let Some(v) = self.sentry_wards_placed {
                    os.write_uint32(43, v)?;
                }
                if let Some(v) = self.wards_dewarded {
                    os.write_uint32(44, v)?;
                }
                if let Some(v) = self.stun_duration {
                    os.write_float(45, v)?;
                }
                if let Some(v) = self.rank_mmr_boost_type {
                    os.write_enum(46, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                for v in &self.contract_progress {
                    ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
                };
                for v in &self.guild_ids {
                    os.write_uint32(49, *v)?;
                };
                for v in &self.graph_hero_damage {
                    os.write_float(50, *v)?;
                };
                if let Some(v) = self.team_number {
                    os.write_enum(51, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.team_slot {
                    os.write_uint32(52, v)?;
                }
                if let Some(v) = self.featured_gamemode_progress.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
                }
                if let Some(v) = self.featured_hero_sticker_index {
                    os.write_uint32(54, v)?;
                }
                if let Some(v) = self.featured_hero_sticker_quality {
                    os.write_uint32(55, v)?;
                }
                for v in &self.equipped_econ_items {
                    ::protobuf::rt::write_message_field_with_cached_size(56, v, os)?;
                };
                if let Some(v) = self.game_player_id {
                    os.write_int32(57, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Player {
                Player::new()
            }

            fn clear(&mut self) {
                self.ability_upgrades.clear();
                self.player_slot = ::std::option::Option::None;
                self.kills.clear();
                self.items.clear();
                self.avg_kills_x16 = ::std::option::Option::None;
                self.avg_deaths_x16 = ::std::option::Option::None;
                self.avg_assists_x16 = ::std::option::Option::None;
                self.avg_gpm_x16 = ::std::option::Option::None;
                self.avg_xpm_x16 = ::std::option::Option::None;
                self.best_kills_x16 = ::std::option::Option::None;
                self.best_assists_x16 = ::std::option::Option::None;
                self.best_gpm_x16 = ::std::option::Option::None;
                self.best_xpm_x16 = ::std::option::Option::None;
                self.win_streak = ::std::option::Option::None;
                self.best_win_streak = ::std::option::Option::None;
                self.fight_score = ::std::option::Option::None;
                self.farm_score = ::std::option::Option::None;
                self.support_score = ::std::option::Option::None;
                self.push_score = ::std::option::Option::None;
                self.level_up_times.clear();
                self.graph_net_worth.clear();
                self.inventory_snapshot.clear();
                self.avg_stats_calibrated = ::std::option::Option::None;
                self.auto_style_criteria.clear();
                self.event_data.clear();
                self.strange_gem_progress.clear();
                self.hero_xp = ::std::option::Option::None;
                self.camps_stacked = ::std::option::Option::None;
                self.victory_prediction.clear();
                self.lane_selection_flags = ::std::option::Option::None;
                self.rampages = ::std::option::Option::None;
                self.triple_kills = ::std::option::Option::None;
                self.aegis_snatched = ::std::option::Option::None;
                self.rapiers_purchased = ::std::option::Option::None;
                self.couriers_killed = ::std::option::Option::None;
                self.net_worth_rank = ::std::option::Option::None;
                self.support_gold_spent = ::std::option::Option::None;
                self.observer_wards_placed = ::std::option::Option::None;
                self.sentry_wards_placed = ::std::option::Option::None;
                self.wards_dewarded = ::std::option::Option::None;
                self.stun_duration = ::std::option::Option::None;
                self.rank_mmr_boost_type = ::std::option::Option::None;
                self.contract_progress.clear();
                self.guild_ids.clear();
                self.graph_hero_damage.clear();
                self.team_number = ::std::option::Option::None;
                self.team_slot = ::std::option::Option::None;
                self.featured_gamemode_progress.clear();
                self.featured_hero_sticker_index = ::std::option::Option::None;
                self.featured_hero_sticker_quality = ::std::option::Option::None;
                self.equipped_econ_items.clear();
                self.game_player_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Player {
                static instance: Player = Player {
                    ability_upgrades: ::std::vec::Vec::new(),
                    player_slot: ::std::option::Option::None,
                    kills: ::std::vec::Vec::new(),
                    items: ::std::vec::Vec::new(),
                    avg_kills_x16: ::std::option::Option::None,
                    avg_deaths_x16: ::std::option::Option::None,
                    avg_assists_x16: ::std::option::Option::None,
                    avg_gpm_x16: ::std::option::Option::None,
                    avg_xpm_x16: ::std::option::Option::None,
                    best_kills_x16: ::std::option::Option::None,
                    best_assists_x16: ::std::option::Option::None,
                    best_gpm_x16: ::std::option::Option::None,
                    best_xpm_x16: ::std::option::Option::None,
                    win_streak: ::std::option::Option::None,
                    best_win_streak: ::std::option::Option::None,
                    fight_score: ::std::option::Option::None,
                    farm_score: ::std::option::Option::None,
                    support_score: ::std::option::Option::None,
                    push_score: ::std::option::Option::None,
                    level_up_times: ::std::vec::Vec::new(),
                    graph_net_worth: ::std::vec::Vec::new(),
                    inventory_snapshot: ::std::vec::Vec::new(),
                    avg_stats_calibrated: ::std::option::Option::None,
                    auto_style_criteria: ::std::vec::Vec::new(),
                    event_data: ::std::vec::Vec::new(),
                    strange_gem_progress: ::std::vec::Vec::new(),
                    hero_xp: ::std::option::Option::None,
                    camps_stacked: ::std::option::Option::None,
                    victory_prediction: ::std::vec::Vec::new(),
                    lane_selection_flags: ::std::option::Option::None,
                    rampages: ::std::option::Option::None,
                    triple_kills: ::std::option::Option::None,
                    aegis_snatched: ::std::option::Option::None,
                    rapiers_purchased: ::std::option::Option::None,
                    couriers_killed: ::std::option::Option::None,
                    net_worth_rank: ::std::option::Option::None,
                    support_gold_spent: ::std::option::Option::None,
                    observer_wards_placed: ::std::option::Option::None,
                    sentry_wards_placed: ::std::option::Option::None,
                    wards_dewarded: ::std::option::Option::None,
                    stun_duration: ::std::option::Option::None,
                    rank_mmr_boost_type: ::std::option::Option::None,
                    contract_progress: ::std::vec::Vec::new(),
                    guild_ids: ::std::vec::Vec::new(),
                    graph_hero_damage: ::std::vec::Vec::new(),
                    team_number: ::std::option::Option::None,
                    team_slot: ::std::option::Option::None,
                    featured_gamemode_progress: ::protobuf::MessageField::none(),
                    featured_hero_sticker_index: ::std::option::Option::None,
                    featured_hero_sticker_quality: ::std::option::Option::None,
                    equipped_econ_items: ::std::vec::Vec::new(),
                    game_player_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Player {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.Player").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Player {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Player {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `Player`
        pub mod player {
            // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Team.Player.ContractProgress)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct ContractProgress {
                // message fields
                // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.guild_id)
                pub guild_id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.event_id)
                pub event_id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.challenge_instance_id)
                pub challenge_instance_id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.challenge_parameter)
                pub challenge_parameter: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.contract_stars)
                pub contract_stars: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.contract_slot)
                pub contract_slot: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.completed)
                pub completed: ::std::option::Option<bool>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Team.Player.ContractProgress.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a ContractProgress {
                fn default() -> &'a ContractProgress {
                    <ContractProgress as ::protobuf::Message>::default_instance()
                }
            }

            impl ContractProgress {
                pub fn new() -> ContractProgress {
                    ::std::default::Default::default()
                }

                // optional uint32 guild_id = 1;

                pub fn guild_id(&self) -> u32 {
                    self.guild_id.unwrap_or(0)
                }

                pub fn clear_guild_id(&mut self) {
                    self.guild_id = ::std::option::Option::None;
                }

                pub fn has_guild_id(&self) -> bool {
                    self.guild_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_guild_id(&mut self, v: u32) {
                    self.guild_id = ::std::option::Option::Some(v);
                }

                // optional uint32 event_id = 2;

                pub fn event_id(&self) -> u32 {
                    self.event_id.unwrap_or(0)
                }

                pub fn clear_event_id(&mut self) {
                    self.event_id = ::std::option::Option::None;
                }

                pub fn has_event_id(&self) -> bool {
                    self.event_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_event_id(&mut self, v: u32) {
                    self.event_id = ::std::option::Option::Some(v);
                }

                // optional uint32 challenge_instance_id = 3;

                pub fn challenge_instance_id(&self) -> u32 {
                    self.challenge_instance_id.unwrap_or(0)
                }

                pub fn clear_challenge_instance_id(&mut self) {
                    self.challenge_instance_id = ::std::option::Option::None;
                }

                pub fn has_challenge_instance_id(&self) -> bool {
                    self.challenge_instance_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_challenge_instance_id(&mut self, v: u32) {
                    self.challenge_instance_id = ::std::option::Option::Some(v);
                }

                // optional uint32 challenge_parameter = 4;

                pub fn challenge_parameter(&self) -> u32 {
                    self.challenge_parameter.unwrap_or(0)
                }

                pub fn clear_challenge_parameter(&mut self) {
                    self.challenge_parameter = ::std::option::Option::None;
                }

                pub fn has_challenge_parameter(&self) -> bool {
                    self.challenge_parameter.is_some()
                }

                // Param is passed by value, moved
                pub fn set_challenge_parameter(&mut self, v: u32) {
                    self.challenge_parameter = ::std::option::Option::Some(v);
                }

                // optional uint32 contract_stars = 5;

                pub fn contract_stars(&self) -> u32 {
                    self.contract_stars.unwrap_or(0)
                }

                pub fn clear_contract_stars(&mut self) {
                    self.contract_stars = ::std::option::Option::None;
                }

                pub fn has_contract_stars(&self) -> bool {
                    self.contract_stars.is_some()
                }

                // Param is passed by value, moved
                pub fn set_contract_stars(&mut self, v: u32) {
                    self.contract_stars = ::std::option::Option::Some(v);
                }

                // optional uint32 contract_slot = 6;

                pub fn contract_slot(&self) -> u32 {
                    self.contract_slot.unwrap_or(0)
                }

                pub fn clear_contract_slot(&mut self) {
                    self.contract_slot = ::std::option::Option::None;
                }

                pub fn has_contract_slot(&self) -> bool {
                    self.contract_slot.is_some()
                }

                // Param is passed by value, moved
                pub fn set_contract_slot(&mut self, v: u32) {
                    self.contract_slot = ::std::option::Option::Some(v);
                }

                // optional bool completed = 7;

                pub fn completed(&self) -> bool {
                    self.completed.unwrap_or(false)
                }

                pub fn clear_completed(&mut self) {
                    self.completed = ::std::option::Option::None;
                }

                pub fn has_completed(&self) -> bool {
                    self.completed.is_some()
                }

                // Param is passed by value, moved
                pub fn set_completed(&mut self, v: bool) {
                    self.completed = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(7);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "guild_id",
                        |m: &ContractProgress| { &m.guild_id },
                        |m: &mut ContractProgress| { &mut m.guild_id },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "event_id",
                        |m: &ContractProgress| { &m.event_id },
                        |m: &mut ContractProgress| { &mut m.event_id },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "challenge_instance_id",
                        |m: &ContractProgress| { &m.challenge_instance_id },
                        |m: &mut ContractProgress| { &mut m.challenge_instance_id },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "challenge_parameter",
                        |m: &ContractProgress| { &m.challenge_parameter },
                        |m: &mut ContractProgress| { &mut m.challenge_parameter },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "contract_stars",
                        |m: &ContractProgress| { &m.contract_stars },
                        |m: &mut ContractProgress| { &mut m.contract_stars },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "contract_slot",
                        |m: &ContractProgress| { &m.contract_slot },
                        |m: &mut ContractProgress| { &mut m.contract_slot },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "completed",
                        |m: &ContractProgress| { &m.completed },
                        |m: &mut ContractProgress| { &mut m.completed },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContractProgress>(
                        "CDOTAMatchMetadata.Team.Player.ContractProgress",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for ContractProgress {
                const NAME: &'static str = "ContractProgress";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            32 => {
                                self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            40 => {
                                self.contract_stars = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            48 => {
                                self.contract_slot = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            56 => {
                                self.completed = ::std::option::Option::Some(is.read_bool()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.guild_id {
                        my_size += ::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.event_id {
                        my_size += ::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.challenge_instance_id {
                        my_size += ::protobuf::rt::uint32_size(3, v);
                    }
                    if let Some(v) = self.challenge_parameter {
                        my_size += ::protobuf::rt::uint32_size(4, v);
                    }
                    if let Some(v) = self.contract_stars {
                        my_size += ::protobuf::rt::uint32_size(5, v);
                    }
                    if let Some(v) = self.contract_slot {
                        my_size += ::protobuf::rt::uint32_size(6, v);
                    }
                    if let Some(v) = self.completed {
                        my_size += 1 + 1;
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.guild_id {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.event_id {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.challenge_instance_id {
                        os.write_uint32(3, v)?;
                    }
                    if let Some(v) = self.challenge_parameter {
                        os.write_uint32(4, v)?;
                    }
                    if let Some(v) = self.contract_stars {
                        os.write_uint32(5, v)?;
                    }
                    if let Some(v) = self.contract_slot {
                        os.write_uint32(6, v)?;
                    }
                    if let Some(v) = self.completed {
                        os.write_bool(7, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> ContractProgress {
                    ContractProgress::new()
                }

                fn clear(&mut self) {
                    self.guild_id = ::std::option::Option::None;
                    self.event_id = ::std::option::Option::None;
                    self.challenge_instance_id = ::std::option::Option::None;
                    self.challenge_parameter = ::std::option::Option::None;
                    self.contract_stars = ::std::option::Option::None;
                    self.contract_slot = ::std::option::Option::None;
                    self.completed = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static ContractProgress {
                    static instance: ContractProgress = ContractProgress {
                        guild_id: ::std::option::Option::None,
                        event_id: ::std::option::Option::None,
                        challenge_instance_id: ::std::option::Option::None,
                        challenge_parameter: ::std::option::Option::None,
                        contract_stars: ::std::option::Option::None,
                        contract_slot: ::std::option::Option::None,
                        completed: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for ContractProgress {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Team.Player.ContractProgress").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for ContractProgress {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for ContractProgress {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }
    }

    // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.GuildChallengeProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GuildChallengeProgress {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.event_id)
        pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.challenge_instance_id)
        pub challenge_instance_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.challenge_parameter)
        pub challenge_parameter: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.challenge_timestamp)
        pub challenge_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.challenge_progress_at_start)
        pub challenge_progress_at_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.challenge_progress_accumulated)
        pub challenge_progress_accumulated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.individual_progress)
        pub individual_progress: ::std::vec::Vec<guild_challenge_progress::IndividualProgress>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.GuildChallengeProgress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GuildChallengeProgress {
        fn default() -> &'a GuildChallengeProgress {
            <GuildChallengeProgress as ::protobuf::Message>::default_instance()
        }
    }

    impl GuildChallengeProgress {
        pub fn new() -> GuildChallengeProgress {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional .dota.EEvent event_id = 2;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 challenge_instance_id = 3;

        pub fn challenge_instance_id(&self) -> u32 {
            self.challenge_instance_id.unwrap_or(0)
        }

        pub fn clear_challenge_instance_id(&mut self) {
            self.challenge_instance_id = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_id(&self) -> bool {
            self.challenge_instance_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_id(&mut self, v: u32) {
            self.challenge_instance_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_parameter = 4;

        pub fn challenge_parameter(&self) -> u32 {
            self.challenge_parameter.unwrap_or(0)
        }

        pub fn clear_challenge_parameter(&mut self) {
            self.challenge_parameter = ::std::option::Option::None;
        }

        pub fn has_challenge_parameter(&self) -> bool {
            self.challenge_parameter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_parameter(&mut self, v: u32) {
            self.challenge_parameter = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_timestamp = 5;

        pub fn challenge_timestamp(&self) -> u32 {
            self.challenge_timestamp.unwrap_or(0)
        }

        pub fn clear_challenge_timestamp(&mut self) {
            self.challenge_timestamp = ::std::option::Option::None;
        }

        pub fn has_challenge_timestamp(&self) -> bool {
            self.challenge_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_timestamp(&mut self, v: u32) {
            self.challenge_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_progress_at_start = 6;

        pub fn challenge_progress_at_start(&self) -> u32 {
            self.challenge_progress_at_start.unwrap_or(0)
        }

        pub fn clear_challenge_progress_at_start(&mut self) {
            self.challenge_progress_at_start = ::std::option::Option::None;
        }

        pub fn has_challenge_progress_at_start(&self) -> bool {
            self.challenge_progress_at_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_progress_at_start(&mut self, v: u32) {
            self.challenge_progress_at_start = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_progress_accumulated = 7;

        pub fn challenge_progress_accumulated(&self) -> u32 {
            self.challenge_progress_accumulated.unwrap_or(0)
        }

        pub fn clear_challenge_progress_accumulated(&mut self) {
            self.challenge_progress_accumulated = ::std::option::Option::None;
        }

        pub fn has_challenge_progress_accumulated(&self) -> bool {
            self.challenge_progress_accumulated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_progress_accumulated(&mut self, v: u32) {
            self.challenge_progress_accumulated = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_id",
                |m: &GuildChallengeProgress| { &m.guild_id },
                |m: &mut GuildChallengeProgress| { &mut m.guild_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &GuildChallengeProgress| { &m.event_id },
                |m: &mut GuildChallengeProgress| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_instance_id",
                |m: &GuildChallengeProgress| { &m.challenge_instance_id },
                |m: &mut GuildChallengeProgress| { &mut m.challenge_instance_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_parameter",
                |m: &GuildChallengeProgress| { &m.challenge_parameter },
                |m: &mut GuildChallengeProgress| { &mut m.challenge_parameter },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_timestamp",
                |m: &GuildChallengeProgress| { &m.challenge_timestamp },
                |m: &mut GuildChallengeProgress| { &mut m.challenge_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_progress_at_start",
                |m: &GuildChallengeProgress| { &m.challenge_progress_at_start },
                |m: &mut GuildChallengeProgress| { &mut m.challenge_progress_at_start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_progress_accumulated",
                |m: &GuildChallengeProgress| { &m.challenge_progress_accumulated },
                |m: &mut GuildChallengeProgress| { &mut m.challenge_progress_accumulated },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "individual_progress",
                |m: &GuildChallengeProgress| { &m.individual_progress },
                |m: &mut GuildChallengeProgress| { &mut m.individual_progress },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GuildChallengeProgress>(
                "CDOTAMatchMetadata.GuildChallengeProgress",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GuildChallengeProgress {
        const NAME: &'static str = "GuildChallengeProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.challenge_progress_at_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.challenge_progress_accumulated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.individual_progress.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.challenge_instance_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.challenge_parameter {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.challenge_timestamp {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.challenge_progress_at_start {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.challenge_progress_accumulated {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            for value in &self.individual_progress {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.challenge_instance_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.challenge_parameter {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.challenge_timestamp {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.challenge_progress_at_start {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.challenge_progress_accumulated {
                os.write_uint32(7, v)?;
            }
            for v in &self.individual_progress {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GuildChallengeProgress {
            GuildChallengeProgress::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.challenge_instance_id = ::std::option::Option::None;
            self.challenge_parameter = ::std::option::Option::None;
            self.challenge_timestamp = ::std::option::Option::None;
            self.challenge_progress_at_start = ::std::option::Option::None;
            self.challenge_progress_accumulated = ::std::option::Option::None;
            self.individual_progress.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GuildChallengeProgress {
            static instance: GuildChallengeProgress = GuildChallengeProgress {
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                challenge_instance_id: ::std::option::Option::None,
                challenge_parameter: ::std::option::Option::None,
                challenge_timestamp: ::std::option::Option::None,
                challenge_progress_at_start: ::std::option::Option::None,
                challenge_progress_accumulated: ::std::option::Option::None,
                individual_progress: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GuildChallengeProgress {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.GuildChallengeProgress").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GuildChallengeProgress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GuildChallengeProgress {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `GuildChallengeProgress`
    pub mod guild_challenge_progress {
        // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct IndividualProgress {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress.progress)
            pub progress: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a IndividualProgress {
            fn default() -> &'a IndividualProgress {
                <IndividualProgress as ::protobuf::Message>::default_instance()
            }
        }

        impl IndividualProgress {
            pub fn new() -> IndividualProgress {
                ::std::default::Default::default()
            }

            // optional uint32 progress = 2;

            pub fn progress(&self) -> u32 {
                self.progress.unwrap_or(0)
            }

            pub fn clear_progress(&mut self) {
                self.progress = ::std::option::Option::None;
            }

            pub fn has_progress(&self) -> bool {
                self.progress.is_some()
            }

            // Param is passed by value, moved
            pub fn set_progress(&mut self, v: u32) {
                self.progress = ::std::option::Option::Some(v);
            }

            // optional uint32 player_slot = 3;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "progress",
                    |m: &IndividualProgress| { &m.progress },
                    |m: &mut IndividualProgress| { &mut m.progress },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "player_slot",
                    |m: &IndividualProgress| { &m.player_slot },
                    |m: &mut IndividualProgress| { &mut m.player_slot },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IndividualProgress>(
                    "CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for IndividualProgress {
            const NAME: &'static str = "IndividualProgress";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        16 => {
                            self.progress = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.progress {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.player_slot {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.progress {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.player_slot {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> IndividualProgress {
                IndividualProgress::new()
            }

            fn clear(&mut self) {
                self.progress = ::std::option::Option::None;
                self.player_slot = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static IndividualProgress {
                static instance: IndividualProgress = IndividualProgress {
                    progress: ::std::option::Option::None,
                    player_slot: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for IndividualProgress {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for IndividualProgress {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for IndividualProgress {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:dota.CDOTAMatchMetadata.Tip)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tip {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Tip.source_player_slot)
        pub source_player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Tip.target_player_slot)
        pub target_player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Tip.tip_amount)
        pub tip_amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchMetadata.Tip.event_id)
        pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAMatchMetadata.Tip.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tip {
        fn default() -> &'a Tip {
            <Tip as ::protobuf::Message>::default_instance()
        }
    }

    impl Tip {
        pub fn new() -> Tip {
            ::std::default::Default::default()
        }

        // optional uint32 source_player_slot = 1;

        pub fn source_player_slot(&self) -> u32 {
            self.source_player_slot.unwrap_or(0)
        }

        pub fn clear_source_player_slot(&mut self) {
            self.source_player_slot = ::std::option::Option::None;
        }

        pub fn has_source_player_slot(&self) -> bool {
            self.source_player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_player_slot(&mut self, v: u32) {
            self.source_player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 target_player_slot = 2;

        pub fn target_player_slot(&self) -> u32 {
            self.target_player_slot.unwrap_or(0)
        }

        pub fn clear_target_player_slot(&mut self) {
            self.target_player_slot = ::std::option::Option::None;
        }

        pub fn has_target_player_slot(&self) -> bool {
            self.target_player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_player_slot(&mut self, v: u32) {
            self.target_player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 tip_amount = 3;

        pub fn tip_amount(&self) -> u32 {
            self.tip_amount.unwrap_or(0)
        }

        pub fn clear_tip_amount(&mut self) {
            self.tip_amount = ::std::option::Option::None;
        }

        pub fn has_tip_amount(&self) -> bool {
            self.tip_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tip_amount(&mut self, v: u32) {
            self.tip_amount = ::std::option::Option::Some(v);
        }

        // optional .dota.EEvent event_id = 4;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_player_slot",
                |m: &Tip| { &m.source_player_slot },
                |m: &mut Tip| { &mut m.source_player_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "target_player_slot",
                |m: &Tip| { &m.target_player_slot },
                |m: &mut Tip| { &mut m.target_player_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tip_amount",
                |m: &Tip| { &m.tip_amount },
                |m: &mut Tip| { &mut m.tip_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &Tip| { &m.event_id },
                |m: &mut Tip| { &mut m.event_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tip>(
                "CDOTAMatchMetadata.Tip",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Tip {
        const NAME: &'static str = "Tip";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.target_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tip_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_player_slot {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.target_player_slot {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tip_amount {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.source_player_slot {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.target_player_slot {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tip_amount {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tip {
            Tip::new()
        }

        fn clear(&mut self) {
            self.source_player_slot = ::std::option::Option::None;
            self.target_player_slot = ::std::option::Option::None;
            self.tip_amount = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tip {
            static instance: Tip = Tip {
                source_player_slot: ::std::option::Option::None,
                target_player_slot: ::std::option::Option::None,
                tip_amount: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Tip {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAMatchMetadata.Tip").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tip {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tip {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAMatchPrivateMetadata {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.teams)
    pub teams: ::std::vec::Vec<cdotamatch_private_metadata::Team>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.graph_win_probability)
    pub graph_win_probability: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.string_names)
    pub string_names: ::std::vec::Vec<cdotamatch_private_metadata::StringName>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAMatchPrivateMetadata {
    fn default() -> &'a CDOTAMatchPrivateMetadata {
        <CDOTAMatchPrivateMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAMatchPrivateMetadata {
    pub fn new() -> CDOTAMatchPrivateMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CDOTAMatchPrivateMetadata| { &m.teams },
            |m: &mut CDOTAMatchPrivateMetadata| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "graph_win_probability",
            |m: &CDOTAMatchPrivateMetadata| { &m.graph_win_probability },
            |m: &mut CDOTAMatchPrivateMetadata| { &mut m.graph_win_probability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_names",
            |m: &CDOTAMatchPrivateMetadata| { &m.string_names },
            |m: &mut CDOTAMatchPrivateMetadata| { &mut m.string_names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAMatchPrivateMetadata>(
            "CDOTAMatchPrivateMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAMatchPrivateMetadata {
    const NAME: &'static str = "CDOTAMatchPrivateMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.teams.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.graph_win_probability)?;
                },
                21 => {
                    self.graph_win_probability.push(is.read_float()?);
                },
                26 => {
                    self.string_names.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 5 * self.graph_win_probability.len() as u64;
        for value in &self.string_names {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.graph_win_probability {
            os.write_float(2, *v)?;
        };
        for v in &self.string_names {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAMatchPrivateMetadata {
        CDOTAMatchPrivateMetadata::new()
    }

    fn clear(&mut self) {
        self.teams.clear();
        self.graph_win_probability.clear();
        self.string_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAMatchPrivateMetadata {
        static instance: CDOTAMatchPrivateMetadata = CDOTAMatchPrivateMetadata {
            teams: ::std::vec::Vec::new(),
            graph_win_probability: ::std::vec::Vec::new(),
            string_names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAMatchPrivateMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAMatchPrivateMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAMatchPrivateMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAMatchPrivateMetadata`
pub mod cdotamatch_private_metadata {
    // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.StringName)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StringName {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.StringName.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.StringName.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.StringName.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StringName {
        fn default() -> &'a StringName {
            <StringName as ::protobuf::Message>::default_instance()
        }
    }

    impl StringName {
        pub fn new() -> StringName {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &StringName| { &m.id },
                |m: &mut StringName| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &StringName| { &m.name },
                |m: &mut StringName| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringName>(
                "CDOTAMatchPrivateMetadata.StringName",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StringName {
        const NAME: &'static str = "StringName";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StringName {
            StringName::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StringName {
            static instance: StringName = StringName {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StringName {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.StringName").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StringName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StringName {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.dota_team)
        pub dota_team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.players)
        pub players: ::std::vec::Vec<team::Player>,
        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.buildings)
        pub buildings: ::std::vec::Vec<team::Building>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 dota_team = 1;

        pub fn dota_team(&self) -> u32 {
            self.dota_team.unwrap_or(0)
        }

        pub fn clear_dota_team(&mut self) {
            self.dota_team = ::std::option::Option::None;
        }

        pub fn has_dota_team(&self) -> bool {
            self.dota_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dota_team(&mut self, v: u32) {
            self.dota_team = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dota_team",
                |m: &Team| { &m.dota_team },
                |m: &mut Team| { &mut m.dota_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "players",
                |m: &Team| { &m.players },
                |m: &mut Team| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "buildings",
                |m: &Team| { &m.buildings },
                |m: &mut Team| { &mut m.buildings },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Team>(
                "CDOTAMatchPrivateMetadata.Team",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.players.push(is.read_message()?);
                    },
                    26 => {
                        self.buildings.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dota_team {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.buildings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.dota_team {
                os.write_uint32(1, v)?;
            }
            for v in &self.players {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.buildings {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.dota_team = ::std::option::Option::None;
            self.players.clear();
            self.buildings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                dota_team: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                buildings: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Team {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Team {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Team {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Team`
    pub mod team {
        // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Player {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.position_stream)
            pub position_stream: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.combat_segments)
            pub combat_segments: ::std::vec::Vec<player::CombatSegment>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.damage_unit_names)
            pub damage_unit_names: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.buff_records)
            pub buff_records: ::std::vec::Vec<player::BuffRecord>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.graph_kills)
            pub graph_kills: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.graph_deaths)
            pub graph_deaths: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.graph_assists)
            pub graph_assists: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.graph_lasthits)
            pub graph_lasthits: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.graph_denies)
            pub graph_denies: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.gold_received)
            pub gold_received: ::protobuf::MessageField<player::GoldReceived>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.xp_received)
            pub xp_received: ::protobuf::MessageField<player::XPReceived>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.team_number)
            pub team_number: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::DOTA_GC_TEAM>>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.team_slot)
            pub team_slot: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Player {
            fn default() -> &'a Player {
                <Player as ::protobuf::Message>::default_instance()
            }
        }

        impl Player {
            pub fn new() -> Player {
                ::std::default::Default::default()
            }

            // optional uint32 player_slot = 2;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional bytes position_stream = 3;

            pub fn position_stream(&self) -> &[u8] {
                match self.position_stream.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_position_stream(&mut self) {
                self.position_stream = ::std::option::Option::None;
            }

            pub fn has_position_stream(&self) -> bool {
                self.position_stream.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_stream(&mut self, v: ::std::vec::Vec<u8>) {
                self.position_stream = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_position_stream(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.position_stream.is_none() {
                    self.position_stream = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.position_stream.as_mut().unwrap()
            }

            // Take field
            pub fn take_position_stream(&mut self) -> ::std::vec::Vec<u8> {
                self.position_stream.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional .dota.DOTA_GC_TEAM team_number = 14;

            pub fn team_number(&self) -> super::super::super::dota_shared_enums::DOTA_GC_TEAM {
                match self.team_number {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                    None => super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
                }
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: super::super::super::dota_shared_enums::DOTA_GC_TEAM) {
                self.team_number = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 team_slot = 15;

            pub fn team_slot(&self) -> u32 {
                self.team_slot.unwrap_or(0)
            }

            pub fn clear_team_slot(&mut self) {
                self.team_slot = ::std::option::Option::None;
            }

            pub fn has_team_slot(&self) -> bool {
                self.team_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_slot(&mut self, v: u32) {
                self.team_slot = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(14);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "player_slot",
                    |m: &Player| { &m.player_slot },
                    |m: &mut Player| { &mut m.player_slot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "position_stream",
                    |m: &Player| { &m.position_stream },
                    |m: &mut Player| { &mut m.position_stream },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "combat_segments",
                    |m: &Player| { &m.combat_segments },
                    |m: &mut Player| { &mut m.combat_segments },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "damage_unit_names",
                    |m: &Player| { &m.damage_unit_names },
                    |m: &mut Player| { &mut m.damage_unit_names },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "buff_records",
                    |m: &Player| { &m.buff_records },
                    |m: &mut Player| { &mut m.buff_records },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "graph_kills",
                    |m: &Player| { &m.graph_kills },
                    |m: &mut Player| { &mut m.graph_kills },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "graph_deaths",
                    |m: &Player| { &m.graph_deaths },
                    |m: &mut Player| { &mut m.graph_deaths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "graph_assists",
                    |m: &Player| { &m.graph_assists },
                    |m: &mut Player| { &mut m.graph_assists },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "graph_lasthits",
                    |m: &Player| { &m.graph_lasthits },
                    |m: &mut Player| { &mut m.graph_lasthits },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "graph_denies",
                    |m: &Player| { &m.graph_denies },
                    |m: &mut Player| { &mut m.graph_denies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, player::GoldReceived>(
                    "gold_received",
                    |m: &Player| { &m.gold_received },
                    |m: &mut Player| { &mut m.gold_received },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, player::XPReceived>(
                    "xp_received",
                    |m: &Player| { &m.xp_received },
                    |m: &mut Player| { &mut m.xp_received },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_number",
                    |m: &Player| { &m.team_number },
                    |m: &mut Player| { &mut m.team_number },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_slot",
                    |m: &Player| { &m.team_slot },
                    |m: &mut Player| { &mut m.team_slot },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                    "CDOTAMatchPrivateMetadata.Team.Player",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Player {
            const NAME: &'static str = "Player";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        16 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        26 => {
                            self.position_stream = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        34 => {
                            self.combat_segments.push(is.read_message()?);
                        },
                        42 => {
                            self.damage_unit_names.push(is.read_string()?);
                        },
                        50 => {
                            self.buff_records.push(is.read_message()?);
                        },
                        58 => {
                            is.read_repeated_packed_float_into(&mut self.graph_kills)?;
                        },
                        61 => {
                            self.graph_kills.push(is.read_float()?);
                        },
                        66 => {
                            is.read_repeated_packed_float_into(&mut self.graph_deaths)?;
                        },
                        69 => {
                            self.graph_deaths.push(is.read_float()?);
                        },
                        74 => {
                            is.read_repeated_packed_float_into(&mut self.graph_assists)?;
                        },
                        77 => {
                            self.graph_assists.push(is.read_float()?);
                        },
                        82 => {
                            is.read_repeated_packed_float_into(&mut self.graph_lasthits)?;
                        },
                        85 => {
                            self.graph_lasthits.push(is.read_float()?);
                        },
                        90 => {
                            is.read_repeated_packed_float_into(&mut self.graph_denies)?;
                        },
                        93 => {
                            self.graph_denies.push(is.read_float()?);
                        },
                        98 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.gold_received)?;
                        },
                        106 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.xp_received)?;
                        },
                        112 => {
                            self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        120 => {
                            self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.player_slot {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.position_stream.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                }
                for value in &self.combat_segments {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.damage_unit_names {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                for value in &self.buff_records {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += 5 * self.graph_kills.len() as u64;
                my_size += 5 * self.graph_deaths.len() as u64;
                my_size += 5 * self.graph_assists.len() as u64;
                my_size += 5 * self.graph_lasthits.len() as u64;
                my_size += 5 * self.graph_denies.len() as u64;
                if let Some(v) = self.gold_received.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.xp_received.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.team_number {
                    my_size += ::protobuf::rt::int32_size(14, v.value());
                }
                if let Some(v) = self.team_slot {
                    my_size += ::protobuf::rt::uint32_size(15, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.player_slot {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.position_stream.as_ref() {
                    os.write_bytes(3, v)?;
                }
                for v in &self.combat_segments {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                for v in &self.damage_unit_names {
                    os.write_string(5, &v)?;
                };
                for v in &self.buff_records {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                };
                for v in &self.graph_kills {
                    os.write_float(7, *v)?;
                };
                for v in &self.graph_deaths {
                    os.write_float(8, *v)?;
                };
                for v in &self.graph_assists {
                    os.write_float(9, *v)?;
                };
                for v in &self.graph_lasthits {
                    os.write_float(10, *v)?;
                };
                for v in &self.graph_denies {
                    os.write_float(11, *v)?;
                };
                if let Some(v) = self.gold_received.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                }
                if let Some(v) = self.xp_received.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                }
                if let Some(v) = self.team_number {
                    os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.team_slot {
                    os.write_uint32(15, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Player {
                Player::new()
            }

            fn clear(&mut self) {
                self.player_slot = ::std::option::Option::None;
                self.position_stream = ::std::option::Option::None;
                self.combat_segments.clear();
                self.damage_unit_names.clear();
                self.buff_records.clear();
                self.graph_kills.clear();
                self.graph_deaths.clear();
                self.graph_assists.clear();
                self.graph_lasthits.clear();
                self.graph_denies.clear();
                self.gold_received.clear();
                self.xp_received.clear();
                self.team_number = ::std::option::Option::None;
                self.team_slot = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Player {
                static instance: Player = Player {
                    player_slot: ::std::option::Option::None,
                    position_stream: ::std::option::Option::None,
                    combat_segments: ::std::vec::Vec::new(),
                    damage_unit_names: ::std::vec::Vec::new(),
                    buff_records: ::std::vec::Vec::new(),
                    graph_kills: ::std::vec::Vec::new(),
                    graph_deaths: ::std::vec::Vec::new(),
                    graph_assists: ::std::vec::Vec::new(),
                    graph_lasthits: ::std::vec::Vec::new(),
                    graph_denies: ::std::vec::Vec::new(),
                    gold_received: ::protobuf::MessageField::none(),
                    xp_received: ::protobuf::MessageField::none(),
                    team_number: ::std::option::Option::None,
                    team_slot: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Player {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Player {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Player {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `Player`
        pub mod player {
            // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct CombatSegment {
                // message fields
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.game_time)
                pub game_time: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.damage_by_ability)
                pub damage_by_ability: ::std::vec::Vec<combat_segment::DamageByAbility>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.healing_by_ability)
                pub healing_by_ability: ::std::vec::Vec<combat_segment::HealingByAbility>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a CombatSegment {
                fn default() -> &'a CombatSegment {
                    <CombatSegment as ::protobuf::Message>::default_instance()
                }
            }

            impl CombatSegment {
                pub fn new() -> CombatSegment {
                    ::std::default::Default::default()
                }

                // optional int32 game_time = 1;

                pub fn game_time(&self) -> i32 {
                    self.game_time.unwrap_or(0)
                }

                pub fn clear_game_time(&mut self) {
                    self.game_time = ::std::option::Option::None;
                }

                pub fn has_game_time(&self) -> bool {
                    self.game_time.is_some()
                }

                // Param is passed by value, moved
                pub fn set_game_time(&mut self, v: i32) {
                    self.game_time = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(3);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "game_time",
                        |m: &CombatSegment| { &m.game_time },
                        |m: &mut CombatSegment| { &mut m.game_time },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                        "damage_by_ability",
                        |m: &CombatSegment| { &m.damage_by_ability },
                        |m: &mut CombatSegment| { &mut m.damage_by_ability },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                        "healing_by_ability",
                        |m: &CombatSegment| { &m.healing_by_ability },
                        |m: &mut CombatSegment| { &mut m.healing_by_ability },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CombatSegment>(
                        "CDOTAMatchPrivateMetadata.Team.Player.CombatSegment",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for CombatSegment {
                const NAME: &'static str = "CombatSegment";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.game_time = ::std::option::Option::Some(is.read_int32()?);
                            },
                            18 => {
                                self.damage_by_ability.push(is.read_message()?);
                            },
                            26 => {
                                self.healing_by_ability.push(is.read_message()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.game_time {
                        my_size += ::protobuf::rt::int32_size(1, v);
                    }
                    for value in &self.damage_by_ability {
                        let len = value.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    for value in &self.healing_by_ability {
                        let len = value.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.game_time {
                        os.write_int32(1, v)?;
                    }
                    for v in &self.damage_by_ability {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    };
                    for v in &self.healing_by_ability {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    };
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> CombatSegment {
                    CombatSegment::new()
                }

                fn clear(&mut self) {
                    self.game_time = ::std::option::Option::None;
                    self.damage_by_ability.clear();
                    self.healing_by_ability.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static CombatSegment {
                    static instance: CombatSegment = CombatSegment {
                        game_time: ::std::option::Option::None,
                        damage_by_ability: ::std::vec::Vec::new(),
                        healing_by_ability: ::std::vec::Vec::new(),
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for CombatSegment {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.CombatSegment").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for CombatSegment {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for CombatSegment {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `CombatSegment`
            pub mod combat_segment {
                // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct DamageByAbility {
                    // message fields
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.source_unit_index)
                    pub source_unit_index: ::std::option::Option<u32>,
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ability_id)
                    pub ability_id: ::std::option::Option<i32>,
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.by_hero_targets)
                    pub by_hero_targets: ::std::vec::Vec<damage_by_ability::ByHeroTarget>,
                    // special fields
                    // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.special_fields)
                    pub special_fields: ::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a DamageByAbility {
                    fn default() -> &'a DamageByAbility {
                        <DamageByAbility as ::protobuf::Message>::default_instance()
                    }
                }

                impl DamageByAbility {
                    pub fn new() -> DamageByAbility {
                        ::std::default::Default::default()
                    }

                    // optional uint32 source_unit_index = 3;

                    pub fn source_unit_index(&self) -> u32 {
                        self.source_unit_index.unwrap_or(0)
                    }

                    pub fn clear_source_unit_index(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                    }

                    pub fn has_source_unit_index(&self) -> bool {
                        self.source_unit_index.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_source_unit_index(&mut self, v: u32) {
                        self.source_unit_index = ::std::option::Option::Some(v);
                    }

                    // optional int32 ability_id = 1;

                    pub fn ability_id(&self) -> i32 {
                        self.ability_id.unwrap_or(0)
                    }

                    pub fn clear_ability_id(&mut self) {
                        self.ability_id = ::std::option::Option::None;
                    }

                    pub fn has_ability_id(&self) -> bool {
                        self.ability_id.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_ability_id(&mut self, v: i32) {
                        self.ability_id = ::std::option::Option::Some(v);
                    }

                    pub(in super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                        let mut fields = ::std::vec::Vec::with_capacity(3);
                        let mut oneofs = ::std::vec::Vec::with_capacity(0);
                        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                            "source_unit_index",
                            |m: &DamageByAbility| { &m.source_unit_index },
                            |m: &mut DamageByAbility| { &mut m.source_unit_index },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                            "ability_id",
                            |m: &DamageByAbility| { &m.ability_id },
                            |m: &mut DamageByAbility| { &mut m.ability_id },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                            "by_hero_targets",
                            |m: &DamageByAbility| { &m.by_hero_targets },
                            |m: &mut DamageByAbility| { &mut m.by_hero_targets },
                        ));
                        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DamageByAbility>(
                            "CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility",
                            fields,
                            oneofs,
                        )
                    }
                }

                impl ::protobuf::Message for DamageByAbility {
                    const NAME: &'static str = "DamageByAbility";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                24 => {
                                    self.source_unit_index = ::std::option::Option::Some(is.read_uint32()?);
                                },
                                8 => {
                                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                                },
                                18 => {
                                    self.by_hero_targets.push(is.read_message()?);
                                },
                                tag => {
                                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let Some(v) = self.source_unit_index {
                            my_size += ::protobuf::rt::uint32_size(3, v);
                        }
                        if let Some(v) = self.ability_id {
                            my_size += ::protobuf::rt::int32_size(1, v);
                        }
                        for value in &self.by_hero_targets {
                            let len = value.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        };
                        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                        if let Some(v) = self.source_unit_index {
                            os.write_uint32(3, v)?;
                        }
                        if let Some(v) = self.ability_id {
                            os.write_int32(1, v)?;
                        }
                        for v in &self.by_hero_targets {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        };
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> DamageByAbility {
                        DamageByAbility::new()
                    }

                    fn clear(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                        self.ability_id = ::std::option::Option::None;
                        self.by_hero_targets.clear();
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static DamageByAbility {
                        static instance: DamageByAbility = DamageByAbility {
                            source_unit_index: ::std::option::Option::None,
                            ability_id: ::std::option::Option::None,
                            by_hero_targets: ::std::vec::Vec::new(),
                            special_fields: ::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                impl ::protobuf::MessageFull for DamageByAbility {
                    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility").unwrap()).clone()
                    }
                }

                impl ::std::fmt::Display for DamageByAbility {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                        ::protobuf::text_format::fmt(self, f)
                    }
                }

                impl ::protobuf::reflect::ProtobufValue for DamageByAbility {
                    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                }

                /// Nested message and enums of message `DamageByAbility`
                pub mod damage_by_ability {
                    // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget)
                    #[derive(PartialEq,Clone,Default,Debug)]
                    pub struct ByHeroTarget {
                        // message fields
                        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget.hero_id)
                        pub hero_id: ::std::option::Option<u32>,
                        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget.damage)
                        pub damage: ::std::option::Option<u32>,
                        // special fields
                        // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget.special_fields)
                        pub special_fields: ::protobuf::SpecialFields,
                    }

                    impl<'a> ::std::default::Default for &'a ByHeroTarget {
                        fn default() -> &'a ByHeroTarget {
                            <ByHeroTarget as ::protobuf::Message>::default_instance()
                        }
                    }

                    impl ByHeroTarget {
                        pub fn new() -> ByHeroTarget {
                            ::std::default::Default::default()
                        }

                        // optional uint32 hero_id = 1;

                        pub fn hero_id(&self) -> u32 {
                            self.hero_id.unwrap_or(0)
                        }

                        pub fn clear_hero_id(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                        }

                        pub fn has_hero_id(&self) -> bool {
                            self.hero_id.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_hero_id(&mut self, v: u32) {
                            self.hero_id = ::std::option::Option::Some(v);
                        }

                        // optional uint32 damage = 2;

                        pub fn damage(&self) -> u32 {
                            self.damage.unwrap_or(0)
                        }

                        pub fn clear_damage(&mut self) {
                            self.damage = ::std::option::Option::None;
                        }

                        pub fn has_damage(&self) -> bool {
                            self.damage.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_damage(&mut self, v: u32) {
                            self.damage = ::std::option::Option::Some(v);
                        }

                        pub(in super::super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                            let mut fields = ::std::vec::Vec::with_capacity(2);
                            let mut oneofs = ::std::vec::Vec::with_capacity(0);
                            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                                "hero_id",
                                |m: &ByHeroTarget| { &m.hero_id },
                                |m: &mut ByHeroTarget| { &mut m.hero_id },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                                "damage",
                                |m: &ByHeroTarget| { &m.damage },
                                |m: &mut ByHeroTarget| { &mut m.damage },
                            ));
                            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ByHeroTarget>(
                                "CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget",
                                fields,
                                oneofs,
                            )
                        }
                    }

                    impl ::protobuf::Message for ByHeroTarget {
                        const NAME: &'static str = "ByHeroTarget";

                        fn is_initialized(&self) -> bool {
                            true
                        }

                        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    8 => {
                                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                                    },
                                    16 => {
                                        self.damage = ::std::option::Option::Some(is.read_uint32()?);
                                    },
                                    tag => {
                                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                    },
                                };
                            }
                            ::std::result::Result::Ok(())
                        }

                        // Compute sizes of nested messages
                        #[allow(unused_variables)]
                        fn compute_size(&self) -> u64 {
                            let mut my_size = 0;
                            if let Some(v) = self.hero_id {
                                my_size += ::protobuf::rt::uint32_size(1, v);
                            }
                            if let Some(v) = self.damage {
                                my_size += ::protobuf::rt::uint32_size(2, v);
                            }
                            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                            self.special_fields.cached_size().set(my_size as u32);
                            my_size
                        }

                        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                            if let Some(v) = self.hero_id {
                                os.write_uint32(1, v)?;
                            }
                            if let Some(v) = self.damage {
                                os.write_uint32(2, v)?;
                            }
                            os.write_unknown_fields(self.special_fields.unknown_fields())?;
                            ::std::result::Result::Ok(())
                        }

                        fn special_fields(&self) -> &::protobuf::SpecialFields {
                            &self.special_fields
                        }

                        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                            &mut self.special_fields
                        }

                        fn new() -> ByHeroTarget {
                            ByHeroTarget::new()
                        }

                        fn clear(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                            self.damage = ::std::option::Option::None;
                            self.special_fields.clear();
                        }

                        fn default_instance() -> &'static ByHeroTarget {
                            static instance: ByHeroTarget = ByHeroTarget {
                                hero_id: ::std::option::Option::None,
                                damage: ::std::option::Option::None,
                                special_fields: ::protobuf::SpecialFields::new(),
                            };
                            &instance
                        }
                    }

                    impl ::protobuf::MessageFull for ByHeroTarget {
                        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                            descriptor.get(|| super::super::super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget").unwrap()).clone()
                        }
                    }

                    impl ::std::fmt::Display for ByHeroTarget {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            ::protobuf::text_format::fmt(self, f)
                        }
                    }

                    impl ::protobuf::reflect::ProtobufValue for ByHeroTarget {
                        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                    }
                }

                // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct HealingByAbility {
                    // message fields
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.source_unit_index)
                    pub source_unit_index: ::std::option::Option<u32>,
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ability_id)
                    pub ability_id: ::std::option::Option<i32>,
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.by_hero_targets)
                    pub by_hero_targets: ::std::vec::Vec<healing_by_ability::ByHeroTarget>,
                    // special fields
                    // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.special_fields)
                    pub special_fields: ::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a HealingByAbility {
                    fn default() -> &'a HealingByAbility {
                        <HealingByAbility as ::protobuf::Message>::default_instance()
                    }
                }

                impl HealingByAbility {
                    pub fn new() -> HealingByAbility {
                        ::std::default::Default::default()
                    }

                    // optional uint32 source_unit_index = 3;

                    pub fn source_unit_index(&self) -> u32 {
                        self.source_unit_index.unwrap_or(0)
                    }

                    pub fn clear_source_unit_index(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                    }

                    pub fn has_source_unit_index(&self) -> bool {
                        self.source_unit_index.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_source_unit_index(&mut self, v: u32) {
                        self.source_unit_index = ::std::option::Option::Some(v);
                    }

                    // optional int32 ability_id = 1;

                    pub fn ability_id(&self) -> i32 {
                        self.ability_id.unwrap_or(0)
                    }

                    pub fn clear_ability_id(&mut self) {
                        self.ability_id = ::std::option::Option::None;
                    }

                    pub fn has_ability_id(&self) -> bool {
                        self.ability_id.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_ability_id(&mut self, v: i32) {
                        self.ability_id = ::std::option::Option::Some(v);
                    }

                    pub(in super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                        let mut fields = ::std::vec::Vec::with_capacity(3);
                        let mut oneofs = ::std::vec::Vec::with_capacity(0);
                        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                            "source_unit_index",
                            |m: &HealingByAbility| { &m.source_unit_index },
                            |m: &mut HealingByAbility| { &mut m.source_unit_index },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                            "ability_id",
                            |m: &HealingByAbility| { &m.ability_id },
                            |m: &mut HealingByAbility| { &mut m.ability_id },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                            "by_hero_targets",
                            |m: &HealingByAbility| { &m.by_hero_targets },
                            |m: &mut HealingByAbility| { &mut m.by_hero_targets },
                        ));
                        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HealingByAbility>(
                            "CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility",
                            fields,
                            oneofs,
                        )
                    }
                }

                impl ::protobuf::Message for HealingByAbility {
                    const NAME: &'static str = "HealingByAbility";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                24 => {
                                    self.source_unit_index = ::std::option::Option::Some(is.read_uint32()?);
                                },
                                8 => {
                                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                                },
                                18 => {
                                    self.by_hero_targets.push(is.read_message()?);
                                },
                                tag => {
                                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let Some(v) = self.source_unit_index {
                            my_size += ::protobuf::rt::uint32_size(3, v);
                        }
                        if let Some(v) = self.ability_id {
                            my_size += ::protobuf::rt::int32_size(1, v);
                        }
                        for value in &self.by_hero_targets {
                            let len = value.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        };
                        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                        if let Some(v) = self.source_unit_index {
                            os.write_uint32(3, v)?;
                        }
                        if let Some(v) = self.ability_id {
                            os.write_int32(1, v)?;
                        }
                        for v in &self.by_hero_targets {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        };
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> HealingByAbility {
                        HealingByAbility::new()
                    }

                    fn clear(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                        self.ability_id = ::std::option::Option::None;
                        self.by_hero_targets.clear();
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static HealingByAbility {
                        static instance: HealingByAbility = HealingByAbility {
                            source_unit_index: ::std::option::Option::None,
                            ability_id: ::std::option::Option::None,
                            by_hero_targets: ::std::vec::Vec::new(),
                            special_fields: ::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                impl ::protobuf::MessageFull for HealingByAbility {
                    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility").unwrap()).clone()
                    }
                }

                impl ::std::fmt::Display for HealingByAbility {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                        ::protobuf::text_format::fmt(self, f)
                    }
                }

                impl ::protobuf::reflect::ProtobufValue for HealingByAbility {
                    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                }

                /// Nested message and enums of message `HealingByAbility`
                pub mod healing_by_ability {
                    // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget)
                    #[derive(PartialEq,Clone,Default,Debug)]
                    pub struct ByHeroTarget {
                        // message fields
                        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget.hero_id)
                        pub hero_id: ::std::option::Option<u32>,
                        // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget.healing)
                        pub healing: ::std::option::Option<u32>,
                        // special fields
                        // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget.special_fields)
                        pub special_fields: ::protobuf::SpecialFields,
                    }

                    impl<'a> ::std::default::Default for &'a ByHeroTarget {
                        fn default() -> &'a ByHeroTarget {
                            <ByHeroTarget as ::protobuf::Message>::default_instance()
                        }
                    }

                    impl ByHeroTarget {
                        pub fn new() -> ByHeroTarget {
                            ::std::default::Default::default()
                        }

                        // optional uint32 hero_id = 1;

                        pub fn hero_id(&self) -> u32 {
                            self.hero_id.unwrap_or(0)
                        }

                        pub fn clear_hero_id(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                        }

                        pub fn has_hero_id(&self) -> bool {
                            self.hero_id.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_hero_id(&mut self, v: u32) {
                            self.hero_id = ::std::option::Option::Some(v);
                        }

                        // optional uint32 healing = 2;

                        pub fn healing(&self) -> u32 {
                            self.healing.unwrap_or(0)
                        }

                        pub fn clear_healing(&mut self) {
                            self.healing = ::std::option::Option::None;
                        }

                        pub fn has_healing(&self) -> bool {
                            self.healing.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_healing(&mut self, v: u32) {
                            self.healing = ::std::option::Option::Some(v);
                        }

                        pub(in super::super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                            let mut fields = ::std::vec::Vec::with_capacity(2);
                            let mut oneofs = ::std::vec::Vec::with_capacity(0);
                            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                                "hero_id",
                                |m: &ByHeroTarget| { &m.hero_id },
                                |m: &mut ByHeroTarget| { &mut m.hero_id },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                                "healing",
                                |m: &ByHeroTarget| { &m.healing },
                                |m: &mut ByHeroTarget| { &mut m.healing },
                            ));
                            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ByHeroTarget>(
                                "CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget",
                                fields,
                                oneofs,
                            )
                        }
                    }

                    impl ::protobuf::Message for ByHeroTarget {
                        const NAME: &'static str = "ByHeroTarget";

                        fn is_initialized(&self) -> bool {
                            true
                        }

                        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    8 => {
                                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                                    },
                                    16 => {
                                        self.healing = ::std::option::Option::Some(is.read_uint32()?);
                                    },
                                    tag => {
                                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                    },
                                };
                            }
                            ::std::result::Result::Ok(())
                        }

                        // Compute sizes of nested messages
                        #[allow(unused_variables)]
                        fn compute_size(&self) -> u64 {
                            let mut my_size = 0;
                            if let Some(v) = self.hero_id {
                                my_size += ::protobuf::rt::uint32_size(1, v);
                            }
                            if let Some(v) = self.healing {
                                my_size += ::protobuf::rt::uint32_size(2, v);
                            }
                            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                            self.special_fields.cached_size().set(my_size as u32);
                            my_size
                        }

                        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                            if let Some(v) = self.hero_id {
                                os.write_uint32(1, v)?;
                            }
                            if let Some(v) = self.healing {
                                os.write_uint32(2, v)?;
                            }
                            os.write_unknown_fields(self.special_fields.unknown_fields())?;
                            ::std::result::Result::Ok(())
                        }

                        fn special_fields(&self) -> &::protobuf::SpecialFields {
                            &self.special_fields
                        }

                        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                            &mut self.special_fields
                        }

                        fn new() -> ByHeroTarget {
                            ByHeroTarget::new()
                        }

                        fn clear(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                            self.healing = ::std::option::Option::None;
                            self.special_fields.clear();
                        }

                        fn default_instance() -> &'static ByHeroTarget {
                            static instance: ByHeroTarget = ByHeroTarget {
                                hero_id: ::std::option::Option::None,
                                healing: ::std::option::Option::None,
                                special_fields: ::protobuf::SpecialFields::new(),
                            };
                            &instance
                        }
                    }

                    impl ::protobuf::MessageFull for ByHeroTarget {
                        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                            descriptor.get(|| super::super::super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget").unwrap()).clone()
                        }
                    }

                    impl ::std::fmt::Display for ByHeroTarget {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            ::protobuf::text_format::fmt(self, f)
                        }
                    }

                    impl ::protobuf::reflect::ProtobufValue for ByHeroTarget {
                        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                    }
                }
            }

            // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct BuffRecord {
                // message fields
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.buff_ability_id)
                pub buff_ability_id: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.buff_modifier_name)
                pub buff_modifier_name: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.by_hero_targets)
                pub by_hero_targets: ::std::vec::Vec<buff_record::ByHeroTarget>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a BuffRecord {
                fn default() -> &'a BuffRecord {
                    <BuffRecord as ::protobuf::Message>::default_instance()
                }
            }

            impl BuffRecord {
                pub fn new() -> BuffRecord {
                    ::std::default::Default::default()
                }

                // optional int32 buff_ability_id = 1;

                pub fn buff_ability_id(&self) -> i32 {
                    self.buff_ability_id.unwrap_or(0)
                }

                pub fn clear_buff_ability_id(&mut self) {
                    self.buff_ability_id = ::std::option::Option::None;
                }

                pub fn has_buff_ability_id(&self) -> bool {
                    self.buff_ability_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_buff_ability_id(&mut self, v: i32) {
                    self.buff_ability_id = ::std::option::Option::Some(v);
                }

                // optional string buff_modifier_name = 3;

                pub fn buff_modifier_name(&self) -> &str {
                    match self.buff_modifier_name.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_buff_modifier_name(&mut self) {
                    self.buff_modifier_name = ::std::option::Option::None;
                }

                pub fn has_buff_modifier_name(&self) -> bool {
                    self.buff_modifier_name.is_some()
                }

                // Param is passed by value, moved
                pub fn set_buff_modifier_name(&mut self, v: ::std::string::String) {
                    self.buff_modifier_name = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_buff_modifier_name(&mut self) -> &mut ::std::string::String {
                    if self.buff_modifier_name.is_none() {
                        self.buff_modifier_name = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.buff_modifier_name.as_mut().unwrap()
                }

                // Take field
                pub fn take_buff_modifier_name(&mut self) -> ::std::string::String {
                    self.buff_modifier_name.take().unwrap_or_else(|| ::std::string::String::new())
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(3);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "buff_ability_id",
                        |m: &BuffRecord| { &m.buff_ability_id },
                        |m: &mut BuffRecord| { &mut m.buff_ability_id },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "buff_modifier_name",
                        |m: &BuffRecord| { &m.buff_modifier_name },
                        |m: &mut BuffRecord| { &mut m.buff_modifier_name },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                        "by_hero_targets",
                        |m: &BuffRecord| { &m.by_hero_targets },
                        |m: &mut BuffRecord| { &mut m.by_hero_targets },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuffRecord>(
                        "CDOTAMatchPrivateMetadata.Team.Player.BuffRecord",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for BuffRecord {
                const NAME: &'static str = "BuffRecord";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.buff_ability_id = ::std::option::Option::Some(is.read_int32()?);
                            },
                            26 => {
                                self.buff_modifier_name = ::std::option::Option::Some(is.read_string()?);
                            },
                            18 => {
                                self.by_hero_targets.push(is.read_message()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.buff_ability_id {
                        my_size += ::protobuf::rt::int32_size(1, v);
                    }
                    if let Some(v) = self.buff_modifier_name.as_ref() {
                        my_size += ::protobuf::rt::string_size(3, &v);
                    }
                    for value in &self.by_hero_targets {
                        let len = value.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.buff_ability_id {
                        os.write_int32(1, v)?;
                    }
                    if let Some(v) = self.buff_modifier_name.as_ref() {
                        os.write_string(3, v)?;
                    }
                    for v in &self.by_hero_targets {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    };
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> BuffRecord {
                    BuffRecord::new()
                }

                fn clear(&mut self) {
                    self.buff_ability_id = ::std::option::Option::None;
                    self.buff_modifier_name = ::std::option::Option::None;
                    self.by_hero_targets.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static BuffRecord {
                    static instance: BuffRecord = BuffRecord {
                        buff_ability_id: ::std::option::Option::None,
                        buff_modifier_name: ::std::option::Option::None,
                        by_hero_targets: ::std::vec::Vec::new(),
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for BuffRecord {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.BuffRecord").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for BuffRecord {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for BuffRecord {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `BuffRecord`
            pub mod buff_record {
                // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct ByHeroTarget {
                    // message fields
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.hero_id)
                    pub hero_id: ::std::option::Option<u32>,
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.elapsed_duration)
                    pub elapsed_duration: ::std::option::Option<f32>,
                    // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.is_hidden)
                    pub is_hidden: ::std::option::Option<bool>,
                    // special fields
                    // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.special_fields)
                    pub special_fields: ::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a ByHeroTarget {
                    fn default() -> &'a ByHeroTarget {
                        <ByHeroTarget as ::protobuf::Message>::default_instance()
                    }
                }

                impl ByHeroTarget {
                    pub fn new() -> ByHeroTarget {
                        ::std::default::Default::default()
                    }

                    // optional uint32 hero_id = 1;

                    pub fn hero_id(&self) -> u32 {
                        self.hero_id.unwrap_or(0)
                    }

                    pub fn clear_hero_id(&mut self) {
                        self.hero_id = ::std::option::Option::None;
                    }

                    pub fn has_hero_id(&self) -> bool {
                        self.hero_id.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_hero_id(&mut self, v: u32) {
                        self.hero_id = ::std::option::Option::Some(v);
                    }

                    // optional float elapsed_duration = 2;

                    pub fn elapsed_duration(&self) -> f32 {
                        self.elapsed_duration.unwrap_or(0.)
                    }

                    pub fn clear_elapsed_duration(&mut self) {
                        self.elapsed_duration = ::std::option::Option::None;
                    }

                    pub fn has_elapsed_duration(&self) -> bool {
                        self.elapsed_duration.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_elapsed_duration(&mut self, v: f32) {
                        self.elapsed_duration = ::std::option::Option::Some(v);
                    }

                    // optional bool is_hidden = 3;

                    pub fn is_hidden(&self) -> bool {
                        self.is_hidden.unwrap_or(false)
                    }

                    pub fn clear_is_hidden(&mut self) {
                        self.is_hidden = ::std::option::Option::None;
                    }

                    pub fn has_is_hidden(&self) -> bool {
                        self.is_hidden.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_is_hidden(&mut self, v: bool) {
                        self.is_hidden = ::std::option::Option::Some(v);
                    }

                    pub(in super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                        let mut fields = ::std::vec::Vec::with_capacity(3);
                        let mut oneofs = ::std::vec::Vec::with_capacity(0);
                        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                            "hero_id",
                            |m: &ByHeroTarget| { &m.hero_id },
                            |m: &mut ByHeroTarget| { &mut m.hero_id },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                            "elapsed_duration",
                            |m: &ByHeroTarget| { &m.elapsed_duration },
                            |m: &mut ByHeroTarget| { &mut m.elapsed_duration },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                            "is_hidden",
                            |m: &ByHeroTarget| { &m.is_hidden },
                            |m: &mut ByHeroTarget| { &mut m.is_hidden },
                        ));
                        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ByHeroTarget>(
                            "CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget",
                            fields,
                            oneofs,
                        )
                    }
                }

                impl ::protobuf::Message for ByHeroTarget {
                    const NAME: &'static str = "ByHeroTarget";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                8 => {
                                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                                },
                                21 => {
                                    self.elapsed_duration = ::std::option::Option::Some(is.read_float()?);
                                },
                                24 => {
                                    self.is_hidden = ::std::option::Option::Some(is.read_bool()?);
                                },
                                tag => {
                                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let Some(v) = self.hero_id {
                            my_size += ::protobuf::rt::uint32_size(1, v);
                        }
                        if let Some(v) = self.elapsed_duration {
                            my_size += 1 + 4;
                        }
                        if let Some(v) = self.is_hidden {
                            my_size += 1 + 1;
                        }
                        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                        if let Some(v) = self.hero_id {
                            os.write_uint32(1, v)?;
                        }
                        if let Some(v) = self.elapsed_duration {
                            os.write_float(2, v)?;
                        }
                        if let Some(v) = self.is_hidden {
                            os.write_bool(3, v)?;
                        }
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> ByHeroTarget {
                        ByHeroTarget::new()
                    }

                    fn clear(&mut self) {
                        self.hero_id = ::std::option::Option::None;
                        self.elapsed_duration = ::std::option::Option::None;
                        self.is_hidden = ::std::option::Option::None;
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static ByHeroTarget {
                        static instance: ByHeroTarget = ByHeroTarget {
                            hero_id: ::std::option::Option::None,
                            elapsed_duration: ::std::option::Option::None,
                            is_hidden: ::std::option::Option::None,
                            special_fields: ::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                impl ::protobuf::MessageFull for ByHeroTarget {
                    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget").unwrap()).clone()
                    }
                }

                impl ::std::fmt::Display for ByHeroTarget {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                        ::protobuf::text_format::fmt(self, f)
                    }
                }

                impl ::protobuf::reflect::ProtobufValue for ByHeroTarget {
                    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                }
            }

            // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct GoldReceived {
                // message fields
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.creep)
                pub creep: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.heroes)
                pub heroes: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.bounty_runes)
                pub bounty_runes: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.passive)
                pub passive: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.buildings)
                pub buildings: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.abilities)
                pub abilities: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.wards)
                pub wards: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.other)
                pub other: ::std::option::Option<u32>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a GoldReceived {
                fn default() -> &'a GoldReceived {
                    <GoldReceived as ::protobuf::Message>::default_instance()
                }
            }

            impl GoldReceived {
                pub fn new() -> GoldReceived {
                    ::std::default::Default::default()
                }

                // optional uint32 creep = 1;

                pub fn creep(&self) -> u32 {
                    self.creep.unwrap_or(0)
                }

                pub fn clear_creep(&mut self) {
                    self.creep = ::std::option::Option::None;
                }

                pub fn has_creep(&self) -> bool {
                    self.creep.is_some()
                }

                // Param is passed by value, moved
                pub fn set_creep(&mut self, v: u32) {
                    self.creep = ::std::option::Option::Some(v);
                }

                // optional uint32 heroes = 2;

                pub fn heroes(&self) -> u32 {
                    self.heroes.unwrap_or(0)
                }

                pub fn clear_heroes(&mut self) {
                    self.heroes = ::std::option::Option::None;
                }

                pub fn has_heroes(&self) -> bool {
                    self.heroes.is_some()
                }

                // Param is passed by value, moved
                pub fn set_heroes(&mut self, v: u32) {
                    self.heroes = ::std::option::Option::Some(v);
                }

                // optional uint32 bounty_runes = 3;

                pub fn bounty_runes(&self) -> u32 {
                    self.bounty_runes.unwrap_or(0)
                }

                pub fn clear_bounty_runes(&mut self) {
                    self.bounty_runes = ::std::option::Option::None;
                }

                pub fn has_bounty_runes(&self) -> bool {
                    self.bounty_runes.is_some()
                }

                // Param is passed by value, moved
                pub fn set_bounty_runes(&mut self, v: u32) {
                    self.bounty_runes = ::std::option::Option::Some(v);
                }

                // optional uint32 passive = 4;

                pub fn passive(&self) -> u32 {
                    self.passive.unwrap_or(0)
                }

                pub fn clear_passive(&mut self) {
                    self.passive = ::std::option::Option::None;
                }

                pub fn has_passive(&self) -> bool {
                    self.passive.is_some()
                }

                // Param is passed by value, moved
                pub fn set_passive(&mut self, v: u32) {
                    self.passive = ::std::option::Option::Some(v);
                }

                // optional uint32 buildings = 5;

                pub fn buildings(&self) -> u32 {
                    self.buildings.unwrap_or(0)
                }

                pub fn clear_buildings(&mut self) {
                    self.buildings = ::std::option::Option::None;
                }

                pub fn has_buildings(&self) -> bool {
                    self.buildings.is_some()
                }

                // Param is passed by value, moved
                pub fn set_buildings(&mut self, v: u32) {
                    self.buildings = ::std::option::Option::Some(v);
                }

                // optional uint32 abilities = 6;

                pub fn abilities(&self) -> u32 {
                    self.abilities.unwrap_or(0)
                }

                pub fn clear_abilities(&mut self) {
                    self.abilities = ::std::option::Option::None;
                }

                pub fn has_abilities(&self) -> bool {
                    self.abilities.is_some()
                }

                // Param is passed by value, moved
                pub fn set_abilities(&mut self, v: u32) {
                    self.abilities = ::std::option::Option::Some(v);
                }

                // optional uint32 wards = 7;

                pub fn wards(&self) -> u32 {
                    self.wards.unwrap_or(0)
                }

                pub fn clear_wards(&mut self) {
                    self.wards = ::std::option::Option::None;
                }

                pub fn has_wards(&self) -> bool {
                    self.wards.is_some()
                }

                // Param is passed by value, moved
                pub fn set_wards(&mut self, v: u32) {
                    self.wards = ::std::option::Option::Some(v);
                }

                // optional uint32 other = 8;

                pub fn other(&self) -> u32 {
                    self.other.unwrap_or(0)
                }

                pub fn clear_other(&mut self) {
                    self.other = ::std::option::Option::None;
                }

                pub fn has_other(&self) -> bool {
                    self.other.is_some()
                }

                // Param is passed by value, moved
                pub fn set_other(&mut self, v: u32) {
                    self.other = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(8);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "creep",
                        |m: &GoldReceived| { &m.creep },
                        |m: &mut GoldReceived| { &mut m.creep },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "heroes",
                        |m: &GoldReceived| { &m.heroes },
                        |m: &mut GoldReceived| { &mut m.heroes },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "bounty_runes",
                        |m: &GoldReceived| { &m.bounty_runes },
                        |m: &mut GoldReceived| { &mut m.bounty_runes },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "passive",
                        |m: &GoldReceived| { &m.passive },
                        |m: &mut GoldReceived| { &mut m.passive },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "buildings",
                        |m: &GoldReceived| { &m.buildings },
                        |m: &mut GoldReceived| { &mut m.buildings },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "abilities",
                        |m: &GoldReceived| { &m.abilities },
                        |m: &mut GoldReceived| { &mut m.abilities },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "wards",
                        |m: &GoldReceived| { &m.wards },
                        |m: &mut GoldReceived| { &mut m.wards },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "other",
                        |m: &GoldReceived| { &m.other },
                        |m: &mut GoldReceived| { &mut m.other },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoldReceived>(
                        "CDOTAMatchPrivateMetadata.Team.Player.GoldReceived",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for GoldReceived {
                const NAME: &'static str = "GoldReceived";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.creep = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.heroes = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            32 => {
                                self.passive = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            40 => {
                                self.buildings = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            48 => {
                                self.abilities = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            56 => {
                                self.wards = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            64 => {
                                self.other = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.creep {
                        my_size += ::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.heroes {
                        my_size += ::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.bounty_runes {
                        my_size += ::protobuf::rt::uint32_size(3, v);
                    }
                    if let Some(v) = self.passive {
                        my_size += ::protobuf::rt::uint32_size(4, v);
                    }
                    if let Some(v) = self.buildings {
                        my_size += ::protobuf::rt::uint32_size(5, v);
                    }
                    if let Some(v) = self.abilities {
                        my_size += ::protobuf::rt::uint32_size(6, v);
                    }
                    if let Some(v) = self.wards {
                        my_size += ::protobuf::rt::uint32_size(7, v);
                    }
                    if let Some(v) = self.other {
                        my_size += ::protobuf::rt::uint32_size(8, v);
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.creep {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.heroes {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.bounty_runes {
                        os.write_uint32(3, v)?;
                    }
                    if let Some(v) = self.passive {
                        os.write_uint32(4, v)?;
                    }
                    if let Some(v) = self.buildings {
                        os.write_uint32(5, v)?;
                    }
                    if let Some(v) = self.abilities {
                        os.write_uint32(6, v)?;
                    }
                    if let Some(v) = self.wards {
                        os.write_uint32(7, v)?;
                    }
                    if let Some(v) = self.other {
                        os.write_uint32(8, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> GoldReceived {
                    GoldReceived::new()
                }

                fn clear(&mut self) {
                    self.creep = ::std::option::Option::None;
                    self.heroes = ::std::option::Option::None;
                    self.bounty_runes = ::std::option::Option::None;
                    self.passive = ::std::option::Option::None;
                    self.buildings = ::std::option::Option::None;
                    self.abilities = ::std::option::Option::None;
                    self.wards = ::std::option::Option::None;
                    self.other = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static GoldReceived {
                    static instance: GoldReceived = GoldReceived {
                        creep: ::std::option::Option::None,
                        heroes: ::std::option::Option::None,
                        bounty_runes: ::std::option::Option::None,
                        passive: ::std::option::Option::None,
                        buildings: ::std::option::Option::None,
                        abilities: ::std::option::Option::None,
                        wards: ::std::option::Option::None,
                        other: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for GoldReceived {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.GoldReceived").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for GoldReceived {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for GoldReceived {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct XPReceived {
                // message fields
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived.creep)
                pub creep: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived.heroes)
                pub heroes: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived.roshan)
                pub roshan: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived.tome_of_knowledge)
                pub tome_of_knowledge: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived.outpost)
                pub outpost: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived.other)
                pub other: ::std::option::Option<u32>,
                // special fields
                // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Player.XPReceived.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a XPReceived {
                fn default() -> &'a XPReceived {
                    <XPReceived as ::protobuf::Message>::default_instance()
                }
            }

            impl XPReceived {
                pub fn new() -> XPReceived {
                    ::std::default::Default::default()
                }

                // optional uint32 creep = 1;

                pub fn creep(&self) -> u32 {
                    self.creep.unwrap_or(0)
                }

                pub fn clear_creep(&mut self) {
                    self.creep = ::std::option::Option::None;
                }

                pub fn has_creep(&self) -> bool {
                    self.creep.is_some()
                }

                // Param is passed by value, moved
                pub fn set_creep(&mut self, v: u32) {
                    self.creep = ::std::option::Option::Some(v);
                }

                // optional uint32 heroes = 2;

                pub fn heroes(&self) -> u32 {
                    self.heroes.unwrap_or(0)
                }

                pub fn clear_heroes(&mut self) {
                    self.heroes = ::std::option::Option::None;
                }

                pub fn has_heroes(&self) -> bool {
                    self.heroes.is_some()
                }

                // Param is passed by value, moved
                pub fn set_heroes(&mut self, v: u32) {
                    self.heroes = ::std::option::Option::Some(v);
                }

                // optional uint32 roshan = 3;

                pub fn roshan(&self) -> u32 {
                    self.roshan.unwrap_or(0)
                }

                pub fn clear_roshan(&mut self) {
                    self.roshan = ::std::option::Option::None;
                }

                pub fn has_roshan(&self) -> bool {
                    self.roshan.is_some()
                }

                // Param is passed by value, moved
                pub fn set_roshan(&mut self, v: u32) {
                    self.roshan = ::std::option::Option::Some(v);
                }

                // optional uint32 tome_of_knowledge = 4;

                pub fn tome_of_knowledge(&self) -> u32 {
                    self.tome_of_knowledge.unwrap_or(0)
                }

                pub fn clear_tome_of_knowledge(&mut self) {
                    self.tome_of_knowledge = ::std::option::Option::None;
                }

                pub fn has_tome_of_knowledge(&self) -> bool {
                    self.tome_of_knowledge.is_some()
                }

                // Param is passed by value, moved
                pub fn set_tome_of_knowledge(&mut self, v: u32) {
                    self.tome_of_knowledge = ::std::option::Option::Some(v);
                }

                // optional uint32 outpost = 5;

                pub fn outpost(&self) -> u32 {
                    self.outpost.unwrap_or(0)
                }

                pub fn clear_outpost(&mut self) {
                    self.outpost = ::std::option::Option::None;
                }

                pub fn has_outpost(&self) -> bool {
                    self.outpost.is_some()
                }

                // Param is passed by value, moved
                pub fn set_outpost(&mut self, v: u32) {
                    self.outpost = ::std::option::Option::Some(v);
                }

                // optional uint32 other = 6;

                pub fn other(&self) -> u32 {
                    self.other.unwrap_or(0)
                }

                pub fn clear_other(&mut self) {
                    self.other = ::std::option::Option::None;
                }

                pub fn has_other(&self) -> bool {
                    self.other.is_some()
                }

                // Param is passed by value, moved
                pub fn set_other(&mut self, v: u32) {
                    self.other = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(6);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "creep",
                        |m: &XPReceived| { &m.creep },
                        |m: &mut XPReceived| { &mut m.creep },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "heroes",
                        |m: &XPReceived| { &m.heroes },
                        |m: &mut XPReceived| { &mut m.heroes },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "roshan",
                        |m: &XPReceived| { &m.roshan },
                        |m: &mut XPReceived| { &mut m.roshan },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "tome_of_knowledge",
                        |m: &XPReceived| { &m.tome_of_knowledge },
                        |m: &mut XPReceived| { &mut m.tome_of_knowledge },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "outpost",
                        |m: &XPReceived| { &m.outpost },
                        |m: &mut XPReceived| { &mut m.outpost },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "other",
                        |m: &XPReceived| { &m.other },
                        |m: &mut XPReceived| { &mut m.other },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<XPReceived>(
                        "CDOTAMatchPrivateMetadata.Team.Player.XPReceived",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for XPReceived {
                const NAME: &'static str = "XPReceived";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.creep = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.heroes = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.roshan = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            32 => {
                                self.tome_of_knowledge = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            40 => {
                                self.outpost = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            48 => {
                                self.other = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.creep {
                        my_size += ::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.heroes {
                        my_size += ::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.roshan {
                        my_size += ::protobuf::rt::uint32_size(3, v);
                    }
                    if let Some(v) = self.tome_of_knowledge {
                        my_size += ::protobuf::rt::uint32_size(4, v);
                    }
                    if let Some(v) = self.outpost {
                        my_size += ::protobuf::rt::uint32_size(5, v);
                    }
                    if let Some(v) = self.other {
                        my_size += ::protobuf::rt::uint32_size(6, v);
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.creep {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.heroes {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.roshan {
                        os.write_uint32(3, v)?;
                    }
                    if let Some(v) = self.tome_of_knowledge {
                        os.write_uint32(4, v)?;
                    }
                    if let Some(v) = self.outpost {
                        os.write_uint32(5, v)?;
                    }
                    if let Some(v) = self.other {
                        os.write_uint32(6, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> XPReceived {
                    XPReceived::new()
                }

                fn clear(&mut self) {
                    self.creep = ::std::option::Option::None;
                    self.heroes = ::std::option::Option::None;
                    self.roshan = ::std::option::Option::None;
                    self.tome_of_knowledge = ::std::option::Option::None;
                    self.outpost = ::std::option::Option::None;
                    self.other = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static XPReceived {
                    static instance: XPReceived = XPReceived {
                        creep: ::std::option::Option::None,
                        heroes: ::std::option::Option::None,
                        roshan: ::std::option::Option::None,
                        tome_of_knowledge: ::std::option::Option::None,
                        outpost: ::std::option::Option::None,
                        other: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for XPReceived {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Player.XPReceived").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for XPReceived {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for XPReceived {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }

        // @@protoc_insertion_point(message:dota.CDOTAMatchPrivateMetadata.Team.Building)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Building {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Building.unit_name)
            pub unit_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Building.position_quant_x)
            pub position_quant_x: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Building.position_quant_y)
            pub position_quant_y: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CDOTAMatchPrivateMetadata.Team.Building.death_time)
            pub death_time: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAMatchPrivateMetadata.Team.Building.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Building {
            fn default() -> &'a Building {
                <Building as ::protobuf::Message>::default_instance()
            }
        }

        impl Building {
            pub fn new() -> Building {
                ::std::default::Default::default()
            }

            // optional string unit_name = 1;

            pub fn unit_name(&self) -> &str {
                match self.unit_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_unit_name(&mut self) {
                self.unit_name = ::std::option::Option::None;
            }

            pub fn has_unit_name(&self) -> bool {
                self.unit_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_unit_name(&mut self, v: ::std::string::String) {
                self.unit_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_unit_name(&mut self) -> &mut ::std::string::String {
                if self.unit_name.is_none() {
                    self.unit_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.unit_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_unit_name(&mut self) -> ::std::string::String {
                self.unit_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 position_quant_x = 2;

            pub fn position_quant_x(&self) -> u32 {
                self.position_quant_x.unwrap_or(0)
            }

            pub fn clear_position_quant_x(&mut self) {
                self.position_quant_x = ::std::option::Option::None;
            }

            pub fn has_position_quant_x(&self) -> bool {
                self.position_quant_x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_quant_x(&mut self, v: u32) {
                self.position_quant_x = ::std::option::Option::Some(v);
            }

            // optional uint32 position_quant_y = 3;

            pub fn position_quant_y(&self) -> u32 {
                self.position_quant_y.unwrap_or(0)
            }

            pub fn clear_position_quant_y(&mut self) {
                self.position_quant_y = ::std::option::Option::None;
            }

            pub fn has_position_quant_y(&self) -> bool {
                self.position_quant_y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_quant_y(&mut self, v: u32) {
                self.position_quant_y = ::std::option::Option::Some(v);
            }

            // optional float death_time = 4;

            pub fn death_time(&self) -> f32 {
                self.death_time.unwrap_or(0.)
            }

            pub fn clear_death_time(&mut self) {
                self.death_time = ::std::option::Option::None;
            }

            pub fn has_death_time(&self) -> bool {
                self.death_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_death_time(&mut self, v: f32) {
                self.death_time = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "unit_name",
                    |m: &Building| { &m.unit_name },
                    |m: &mut Building| { &mut m.unit_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "position_quant_x",
                    |m: &Building| { &m.position_quant_x },
                    |m: &mut Building| { &mut m.position_quant_x },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "position_quant_y",
                    |m: &Building| { &m.position_quant_y },
                    |m: &mut Building| { &mut m.position_quant_y },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "death_time",
                    |m: &Building| { &m.death_time },
                    |m: &mut Building| { &mut m.death_time },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Building>(
                    "CDOTAMatchPrivateMetadata.Team.Building",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Building {
            const NAME: &'static str = "Building";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.unit_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.position_quant_x = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.position_quant_y = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        37 => {
                            self.death_time = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.unit_name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.position_quant_x {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.position_quant_y {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.death_time {
                    my_size += 1 + 4;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.unit_name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.position_quant_x {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.position_quant_y {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.death_time {
                    os.write_float(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Building {
                Building::new()
            }

            fn clear(&mut self) {
                self.unit_name = ::std::option::Option::None;
                self.position_quant_x = ::std::option::Option::None;
                self.position_quant_y = ::std::option::Option::None;
                self.death_time = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Building {
                static instance: Building = Building {
                    unit_name: ::std::option::Option::None,
                    position_quant_x: ::std::option::Option::None,
                    position_quant_y: ::std::option::Option::None,
                    death_time: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Building {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAMatchPrivateMetadata.Team.Building").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Building {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Building {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19dota_match_metadata.proto\x12\x04dota\x1a\x15base_gcmessages.proto\
    \x1a-dota_gcmessages_common_match_management.proto\x1a\"dota_gcmessages_\
    common_lobby.proto\x1a\x1cdota_gcmessages_common.proto\x1a\x17dota_share\
    d_enums.proto\"\xae\x01\n\x16CDOTAMatchMetadataFile\x12\x18\n\x07version\
    \x18\x01\x20\x02(\x05R\x07version\x12\x19\n\x08match_id\x18\x02\x20\x02(\
    \x04R\x07matchId\x124\n\x08metadata\x18\x03\x20\x01(\x0b2\x18.dota.CDOTA\
    MatchMetadataR\x08metadata\x12)\n\x10private_metadata\x18\x05\x20\x01(\
    \x0cR\x0fprivateMetadata\"\x90>\n\x12CDOTAMatchMetadata\x123\n\x05teams\
    \x18\x01\x20\x03(\x0b2\x1d.dota.CDOTAMatchMetadata.TeamR\x05teams\x12\
    \x19\n\x08lobby_id\x18\x03\x20\x01(\x06R\x07lobbyId\x12*\n\x11report_unt\
    il_time\x18\x04\x20\x01(\x06R\x0freportUntilTime\x125\n\x17event_game_cu\
    stom_table\x18\x05\x20\x01(\x0cR\x14eventGameCustomTable\x12(\n\x10prima\
    ry_event_id\x18\x06\x20\x01(\rR\x0eprimaryEventId\x12L\n\x11matchmaking_\
    stats\x18\x08\x20\x01(\x0b2\x1f.dota.CMsgMatchMatchmakingStatsR\x10match\
    makingStats\x12)\n\x08mvp_data\x18\t\x20\x01(\x0b2\x0e.dota.CMvpDataR\
    \x07mvpData\x12i\n\x18guild_challenge_progress\x18\n\x20\x03(\x0b2/.dota\
    .CDOTAMatchMetadata.GuildChallengeProgressR\x16guildChallengeProgress\
    \x123\n\x16custom_post_game_table\x18\x0b\x20\x01(\x0cR\x13customPostGam\
    eTable\x12;\n\nmatch_tips\x18\x0c\x20\x03(\x0b2\x1c.dota.CDOTAMatchMetad\
    ata.TipR\tmatchTips\x1a\xd3\x01\n\x08EconItem\x12\x1b\n\tdef_index\x18\
    \x01\x20\x01(\rR\x08defIndex\x12\x18\n\x07quality\x18\x02\x20\x01(\rR\
    \x07quality\x128\n\tattribute\x18\x03\x20\x03(\x0b2\x1a.dota.CSOEconItem\
    AttributeR\tattribute\x12\x14\n\x05style\x18\x04\x20\x01(\rR\x05style\
    \x12@\n\x0eequipped_state\x18\x05\x20\x03(\x0b2\x19.dota.CSOEconItemEqui\
    ppedR\requippedState\x1a\x822\n\x04Team\x12\x1b\n\tdota_team\x18\x01\x20\
    \x01(\rR\x08dotaTeam\x12>\n\x07players\x18\x02\x20\x03(\x0b2$.dota.CDOTA\
    MatchMetadata.Team.PlayerR\x07players\x12)\n\x10graph_experience\x18\x03\
    \x20\x03(\x02R\x0fgraphExperience\x12*\n\x11graph_gold_earned\x18\x04\
    \x20\x03(\x02R\x0fgraphGoldEarned\x12&\n\x0fgraph_net_worth\x18\x05\x20\
    \x03(\x02R\rgraphNetWorth\x12\"\n\rcm_first_pick\x18\x06\x20\x01(\x08R\
    \x0bcmFirstPick\x12/\n\x14cm_captain_player_id\x18\x07\x20\x01(\x05R\x11\
    cmCaptainPlayerId\x12\x1d\n\ncm_penalty\x18\n\x20\x01(\rR\tcmPenalty\x1a\
    C\n\nPlayerKill\x12\x1f\n\x0bvictim_slot\x18\x01\x20\x01(\rR\nvictimSlot\
    \x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05count\x1aL\n\x0cItemPurchase\
    \x12\x17\n\x07item_id\x18\x01\x20\x01(\x05R\x06itemId\x12#\n\rpurchase_t\
    ime\x18\x02\x20\x01(\x05R\x0cpurchaseTime\x1a\xf9\x01\n\x11InventorySnap\
    shot\x12\x17\n\x07item_id\x18\x01\x20\x03(\x05R\x06itemId\x12\x1b\n\tgam\
    e_time\x18\x02\x20\x01(\x05R\x08gameTime\x12\x14\n\x05kills\x18\x03\x20\
    \x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x04\x20\x01(\rR\x06deaths\x12\
    \x18\n\x07assists\x18\x05\x20\x01(\rR\x07assists\x12\x14\n\x05level\x18\
    \x06\x20\x01(\rR\x05level\x12(\n\x10backpack_item_id\x18\x07\x20\x03(\
    \x05R\x0ebackpackItemId\x12&\n\x0fneutral_item_id\x18\x08\x20\x01(\x05R\
    \rneutralItemId\x1aH\n\x11AutoStyleCriteria\x12\x1d\n\nname_token\x18\
    \x01\x20\x01(\rR\tnameToken\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05\
    value\x1a\xb2\x02\n\x12StrangeGemProgress\x12&\n\x0fkill_eater_type\x18\
    \x01\x20\x01(\rR\rkillEaterType\x12+\n\x12gem_item_def_index\x18\x02\x20\
    \x01(\rR\x0fgemItemDefIndex\x12(\n\x10required_hero_id\x18\x03\x20\x01(\
    \rR\x0erequiredHeroId\x12%\n\x0estarting_value\x18\x04\x20\x01(\rR\rstar\
    tingValue\x12!\n\x0cending_value\x18\x05\x20\x01(\rR\x0bendingValue\x12/\
    \n\x14owner_item_def_index\x18\x06\x20\x01(\rR\x11ownerItemDefIndex\x12\
    \"\n\rowner_item_id\x18\x07\x20\x01(\x04R\x0bownerItemId\x1a\x98\x01\n\
    \x11VictoryPrediction\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06item\
    Id\x12$\n\x0eitem_def_index\x18\x02\x20\x01(\rR\x0citemDefIndex\x12%\n\
    \x0estarting_value\x18\x03\x20\x01(\rR\rstartingValue\x12\x1d\n\nis_vict\
    ory\x18\x04\x20\x01(\x08R\tisVictory\x1a\x83\x01\n\x0cSubChallenge\x12\
    \x17\n\x07slot_id\x18\x01\x20\x01(\rR\x06slotId\x12\x1f\n\x0bstart_value\
    \x18\x02\x20\x01(\rR\nstartValue\x12\x1b\n\tend_value\x18\x03\x20\x01(\r\
    R\x08endValue\x12\x1c\n\tcompleted\x18\x04\x20\x01(\x08R\tcompleted\x1ak\
    \n\x15CavernChallengeResult\x12*\n\x11completed_path_id\x18\x01\x20\x01(\
    \rR\x0fcompletedPathId\x12&\n\x0fclaimed_room_id\x18\x02\x20\x01(\rR\rcl\
    aimedRoomId\x1a\x9e\x01\n\x0bActionGrant\x12\x1b\n\taction_id\x18\x01\
    \x20\x01(\rR\x08actionId\x12\x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08qu\
    antity\x12\x14\n\x05audit\x18\x03\x20\x01(\rR\x05audit\x12!\n\x0crequire\
    s_win\x18\x04\x20\x01(\x08R\x0brequiresWin\x12\x1d\n\naudit_data\x18\x05\
    \x20\x01(\x04R\tauditData\x1a<\n\nCandyGrant\x12\x16\n\x06points\x18\x01\
    \x20\x01(\rR\x06points\x12\x16\n\x06reason\x18\x02\x20\x01(\rR\x06reason\
    \x1ax\n\x14PeriodicResourceData\x120\n\x14periodic_resource_id\x18\x01\
    \x20\x01(\rR\x12periodicResourceId\x12\x1c\n\tremaining\x18\x02\x20\x01(\
    \rR\tremaining\x12\x10\n\x03max\x18\x03\x20\x01(\rR\x03max\x1a\x84\x0c\n\
    \tEventData\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12!\n\
    \x0cevent_points\x18\x02\x20\x01(\rR\x0beventPoints\x122\n\x15challenge_\
    instance_id\x18\x03\x20\x01(\rR\x13challengeInstanceId\x12,\n\x12challen\
    ge_quest_id\x18\x04\x20\x01(\rR\x10challengeQuestId\x12?\n\x1cchallenge_\
    quest_challenge_id\x18\x05\x20\x01(\rR\x19challengeQuestChallengeId\x12/\
    \n\x13challenge_completed\x18\x06\x20\x01(\x08R\x12challengeCompleted\
    \x128\n\x18challenge_rank_completed\x18\x07\x20\x01(\rR\x16challengeRank\
    Completed\x12M\n#challenge_rank_previously_completed\x18\x08\x20\x01(\rR\
    \x20challengeRankPreviouslyCompleted\x12\x1f\n\x0bevent_owned\x18\t\x20\
    \x01(\x08R\neventOwned\x12k\n\x1csub_challenges_with_progress\x18\n\x20\
    \x03(\x0b2*.dota.CDOTAMatchMetadata.Team.SubChallengeR\x19subChallengesW\
    ithProgress\x12%\n\x0ewager_winnings\x18\x0b\x20\x01(\rR\rwagerWinnings\
    \x126\n\x17cavern_challenge_active\x18\x0c\x20\x01(\x08R\x15cavernChalle\
    ngeActive\x12:\n\x19cavern_challenge_winnings\x18\r\x20\x01(\rR\x17caver\
    nChallengeWinnings\x12%\n\x0eamount_wagered\x18\x0e\x20\x01(\rR\ramountW\
    agered\x12<\n\x1aperiodic_point_adjustments\x18\x10\x20\x01(\rR\x18perio\
    dicPointAdjustments\x12t\n\x1ccavern_challenge_map_results\x18\x11\x20\
    \x03(\x0b23.dota.CDOTAMatchMetadata.Team.CavernChallengeResultR\x19caver\
    nChallengeMapResults\x12N\n$cavern_challenge_plus_shard_winnings\x18\x12\
    \x20\x01(\rR\x20cavernChallengePlusShardWinnings\x12R\n\x0factions_grant\
    ed\x18\x13\x20\x03(\x0b2).dota.CDOTAMatchMetadata.Team.ActionGrantR\x0ea\
    ctionsGranted\x127\n\x18cavern_crawl_map_variant\x18\x14\x20\x01(\rR\x15\
    cavernCrawlMapVariant\x12/\n\x14team_wager_bonus_pct\x18\x15\x20\x01(\rR\
    \x11teamWagerBonusPct\x12(\n\x10wager_streak_pct\x18\x16\x20\x01(\rR\x0e\
    wagerStreakPct\x12Z\n\x14candy_points_granted\x18\x17\x20\x03(\x0b2(.dot\
    a.CDOTAMatchMetadata.Team.CandyGrantR\x12candyPointsGranted\x12(\n\x10ac\
    tive_season_id\x18\x18\x20\x01(\rR\x0eactiveSeasonId\x127\n\x18cavern_cr\
    awl_half_credit\x18\x19\x20\x01(\x08R\x15cavernCrawlHalfCredit\x12a\n\
    \x12periodic_resources\x18\x1a\x20\x03(\x0b22.dota.CDOTAMatchMetadata.Te\
    am.PeriodicResourceDataR\x11periodicResources\x1au\n\x18FeaturedGamemode\
    Progress\x12\x1f\n\x0bstart_value\x18\x01\x20\x01(\rR\nstartValue\x12\
    \x1b\n\tend_value\x18\x02\x20\x01(\rR\x08endValue\x12\x1b\n\tmax_value\
    \x18\x03\x20\x01(\rR\x08maxValue\x1a\xb6\x16\n\x06Player\x12)\n\x10abili\
    ty_upgrades\x18\x02\x20\x03(\x05R\x0fabilityUpgrades\x12\x1f\n\x0bplayer\
    _slot\x18\x03\x20\x01(\rR\nplayerSlot\x12>\n\x05kills\x18\x05\x20\x03(\
    \x0b2(.dota.CDOTAMatchMetadata.Team.PlayerKillR\x05kills\x12@\n\x05items\
    \x18\x06\x20\x03(\x0b2*.dota.CDOTAMatchMetadata.Team.ItemPurchaseR\x05it\
    ems\x12\"\n\ravg_kills_x16\x18\x07\x20\x01(\rR\x0bavgKillsX16\x12$\n\x0e\
    avg_deaths_x16\x18\x08\x20\x01(\rR\x0cavgDeathsX16\x12&\n\x0favg_assists\
    _x16\x18\t\x20\x01(\rR\ravgAssistsX16\x12\x1e\n\x0bavg_gpm_x16\x18\n\x20\
    \x01(\rR\tavgGpmX16\x12\x1e\n\x0bavg_xpm_x16\x18\x0b\x20\x01(\rR\tavgXpm\
    X16\x12$\n\x0ebest_kills_x16\x18\x0c\x20\x01(\rR\x0cbestKillsX16\x12(\n\
    \x10best_assists_x16\x18\r\x20\x01(\rR\x0ebestAssistsX16\x12\x20\n\x0cbe\
    st_gpm_x16\x18\x0e\x20\x01(\rR\nbestGpmX16\x12\x20\n\x0cbest_xpm_x16\x18\
    \x0f\x20\x01(\rR\nbestXpmX16\x12\x1d\n\nwin_streak\x18\x10\x20\x01(\rR\t\
    winStreak\x12&\n\x0fbest_win_streak\x18\x11\x20\x01(\rR\rbestWinStreak\
    \x12\x1f\n\x0bfight_score\x18\x12\x20\x01(\x02R\nfightScore\x12\x1d\n\nf\
    arm_score\x18\x13\x20\x01(\x02R\tfarmScore\x12#\n\rsupport_score\x18\x14\
    \x20\x01(\x02R\x0csupportScore\x12\x1d\n\npush_score\x18\x15\x20\x01(\
    \x02R\tpushScore\x12$\n\x0elevel_up_times\x18\x16\x20\x03(\rR\x0clevelUp\
    Times\x12&\n\x0fgraph_net_worth\x18\x17\x20\x03(\x02R\rgraphNetWorth\x12\
    ^\n\x12inventory_snapshot\x18\x18\x20\x03(\x0b2/.dota.CDOTAMatchMetadata\
    .Team.InventorySnapshotR\x11inventorySnapshot\x120\n\x14avg_stats_calibr\
    ated\x18\x19\x20\x01(\x08R\x12avgStatsCalibrated\x12_\n\x13auto_style_cr\
    iteria\x18\x1a\x20\x03(\x0b2/.dota.CDOTAMatchMetadata.Team.AutoStyleCrit\
    eriaR\x11autoStyleCriteria\x12F\n\nevent_data\x18\x1d\x20\x03(\x0b2'.dot\
    a.CDOTAMatchMetadata.Team.EventDataR\teventData\x12b\n\x14strange_gem_pr\
    ogress\x18\x1e\x20\x03(\x0b20.dota.CDOTAMatchMetadata.Team.StrangeGemPro\
    gressR\x12strangeGemProgress\x12\x17\n\x07hero_xp\x18\x1f\x20\x01(\rR\
    \x06heroXp\x12#\n\rcamps_stacked\x18\x20\x20\x01(\rR\x0ccampsStacked\x12\
    ^\n\x12victory_prediction\x18!\x20\x03(\x0b2/.dota.CDOTAMatchMetadata.Te\
    am.VictoryPredictionR\x11victoryPrediction\x120\n\x14lane_selection_flag\
    s\x18\"\x20\x01(\rR\x12laneSelectionFlags\x12\x1a\n\x08rampages\x18#\x20\
    \x01(\rR\x08rampages\x12!\n\x0ctriple_kills\x18$\x20\x01(\rR\x0btripleKi\
    lls\x12%\n\x0eaegis_snatched\x18%\x20\x01(\rR\raegisSnatched\x12+\n\x11r\
    apiers_purchased\x18&\x20\x01(\rR\x10rapiersPurchased\x12'\n\x0fcouriers\
    _killed\x18'\x20\x01(\rR\x0ecouriersKilled\x12$\n\x0enet_worth_rank\x18(\
    \x20\x01(\rR\x0cnetWorthRank\x12,\n\x12support_gold_spent\x18)\x20\x01(\
    \rR\x10supportGoldSpent\x122\n\x15observer_wards_placed\x18*\x20\x01(\rR\
    \x13observerWardsPlaced\x12.\n\x13sentry_wards_placed\x18+\x20\x01(\rR\
    \x11sentryWardsPlaced\x12%\n\x0ewards_dewarded\x18,\x20\x01(\rR\rwardsDe\
    warded\x12#\n\rstun_duration\x18-\x20\x01(\x02R\x0cstunDuration\x12F\n\
    \x13rank_mmr_boost_type\x18.\x20\x01(\x0e2\x17.dota.EDOTAMMRBoostTypeR\
    \x10rankMmrBoostType\x12b\n\x11contract_progress\x180\x20\x03(\x0b25.dot\
    a.CDOTAMatchMetadata.Team.Player.ContractProgressR\x10contractProgress\
    \x12\x1b\n\tguild_ids\x181\x20\x03(\rR\x08guildIds\x12*\n\x11graph_hero_\
    damage\x182\x20\x03(\x02R\x0fgraphHeroDamage\x123\n\x0bteam_number\x183\
    \x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\nteamNumber\x12\x1b\n\tteam_slot\
    \x184\x20\x01(\rR\x08teamSlot\x12t\n\x1afeatured_gamemode_progress\x185\
    \x20\x01(\x0b26.dota.CDOTAMatchMetadata.Team.FeaturedGamemodeProgressR\
    \x18featuredGamemodeProgress\x12=\n\x1bfeatured_hero_sticker_index\x186\
    \x20\x01(\rR\x18featuredHeroStickerIndex\x12A\n\x1dfeatured_hero_sticker\
    _quality\x187\x20\x01(\rR\x1afeaturedHeroStickerQuality\x12Q\n\x13equipp\
    ed_econ_items\x188\x20\x03(\x0b2!.dota.CDOTAMatchMetadata.EconItemR\x11e\
    quippedEconItems\x12$\n\x0egame_player_id\x189\x20\x01(\x05R\x0cgamePlay\
    erId\x1a\x97\x02\n\x10ContractProgress\x12\x19\n\x08guild_id\x18\x01\x20\
    \x01(\rR\x07guildId\x12\x19\n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\
    \x122\n\x15challenge_instance_id\x18\x03\x20\x01(\rR\x13challengeInstanc\
    eId\x12/\n\x13challenge_parameter\x18\x04\x20\x01(\rR\x12challengeParame\
    ter\x12%\n\x0econtract_stars\x18\x05\x20\x01(\rR\rcontractStars\x12#\n\r\
    contract_slot\x18\x06\x20\x01(\rR\x0ccontractSlot\x12\x1c\n\tcompleted\
    \x18\x07\x20\x01(\x08R\tcompleted\x1a\xbf\x04\n\x16GuildChallengeProgres\
    s\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12'\n\x08event_i\
    d\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x122\n\x15challenge_\
    instance_id\x18\x03\x20\x01(\rR\x13challengeInstanceId\x12/\n\x13challen\
    ge_parameter\x18\x04\x20\x01(\rR\x12challengeParameter\x12/\n\x13challen\
    ge_timestamp\x18\x05\x20\x01(\rR\x12challengeTimestamp\x12=\n\x1bchallen\
    ge_progress_at_start\x18\x06\x20\x01(\rR\x18challengeProgressAtStart\x12\
    D\n\x1echallenge_progress_accumulated\x18\x07\x20\x01(\rR\x1cchallengePr\
    ogressAccumulated\x12s\n\x13individual_progress\x18\x08\x20\x03(\x0b2B.d\
    ota.CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgressR\x12ind\
    ividualProgress\x1aQ\n\x12IndividualProgress\x12\x1a\n\x08progress\x18\
    \x02\x20\x01(\rR\x08progress\x12\x1f\n\x0bplayer_slot\x18\x03\x20\x01(\r\
    R\nplayerSlot\x1a\xa9\x01\n\x03Tip\x12,\n\x12source_player_slot\x18\x01\
    \x20\x01(\rR\x10sourcePlayerSlot\x12,\n\x12target_player_slot\x18\x02\
    \x20\x01(\rR\x10targetPlayerSlot\x12\x1d\n\ntip_amount\x18\x03\x20\x01(\
    \rR\ttipAmount\x12'\n\x08event_id\x18\x04\x20\x01(\x0e2\x0c.dota.EEventR\
    \x07eventId\"\x9c\x17\n\x19CDOTAMatchPrivateMetadata\x12:\n\x05teams\x18\
    \x01\x20\x03(\x0b2$.dota.CDOTAMatchPrivateMetadata.TeamR\x05teams\x122\n\
    \x15graph_win_probability\x18\x02\x20\x03(\x02R\x13graphWinProbability\
    \x12M\n\x0cstring_names\x18\x03\x20\x03(\x0b2*.dota.CDOTAMatchPrivateMet\
    adata.StringNameR\x0bstringNames\x1a0\n\nStringName\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x1a\
    \x8d\x15\n\x04Team\x12\x1b\n\tdota_team\x18\x01\x20\x01(\rR\x08dotaTeam\
    \x12E\n\x07players\x18\x02\x20\x03(\x0b2+.dota.CDOTAMatchPrivateMetadata\
    .Team.PlayerR\x07players\x12K\n\tbuildings\x18\x03\x20\x03(\x0b2-.dota.C\
    DOTAMatchPrivateMetadata.Team.BuildingR\tbuildings\x1a\xb6\x12\n\x06Play\
    er\x12\x1f\n\x0bplayer_slot\x18\x02\x20\x01(\rR\nplayerSlot\x12'\n\x0fpo\
    sition_stream\x18\x03\x20\x01(\x0cR\x0epositionStream\x12b\n\x0fcombat_s\
    egments\x18\x04\x20\x03(\x0b29.dota.CDOTAMatchPrivateMetadata.Team.Playe\
    r.CombatSegmentR\x0ecombatSegments\x12*\n\x11damage_unit_names\x18\x05\
    \x20\x03(\tR\x0fdamageUnitNames\x12Y\n\x0cbuff_records\x18\x06\x20\x03(\
    \x0b26.dota.CDOTAMatchPrivateMetadata.Team.Player.BuffRecordR\x0bbuffRec\
    ords\x12\x1f\n\x0bgraph_kills\x18\x07\x20\x03(\x02R\ngraphKills\x12!\n\
    \x0cgraph_deaths\x18\x08\x20\x03(\x02R\x0bgraphDeaths\x12#\n\rgraph_assi\
    sts\x18\t\x20\x03(\x02R\x0cgraphAssists\x12%\n\x0egraph_lasthits\x18\n\
    \x20\x03(\x02R\rgraphLasthits\x12!\n\x0cgraph_denies\x18\x0b\x20\x03(\
    \x02R\x0bgraphDenies\x12]\n\rgold_received\x18\x0c\x20\x01(\x0b28.dota.C\
    DOTAMatchPrivateMetadata.Team.Player.GoldReceivedR\x0cgoldReceived\x12W\
    \n\x0bxp_received\x18\r\x20\x01(\x0b26.dota.CDOTAMatchPrivateMetadata.Te\
    am.Player.XPReceivedR\nxpReceived\x123\n\x0bteam_number\x18\x0e\x20\x01(\
    \x0e2\x12.dota.DOTA_GC_TEAMR\nteamNumber\x12\x1b\n\tteam_slot\x18\x0f\
    \x20\x01(\rR\x08teamSlot\x1a\xe1\x06\n\rCombatSegment\x12\x1b\n\tgame_ti\
    me\x18\x01\x20\x01(\x05R\x08gameTime\x12u\n\x11damage_by_ability\x18\x02\
    \x20\x03(\x0b2I.dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSegment\
    .DamageByAbilityR\x0fdamageByAbility\x12x\n\x12healing_by_ability\x18\
    \x03\x20\x03(\x0b2J.dota.CDOTAMatchPrivateMetadata.Team.Player.CombatSeg\
    ment.HealingByAbilityR\x10healingByAbility\x1a\x9d\x02\n\x0fDamageByAbil\
    ity\x12*\n\x11source_unit_index\x18\x03\x20\x01(\rR\x0fsourceUnitIndex\
    \x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilityId\x12~\n\x0fby_her\
    o_targets\x18\x02\x20\x03(\x0b2V.dota.CDOTAMatchPrivateMetadata.Team.Pla\
    yer.CombatSegment.DamageByAbility.ByHeroTargetR\rbyHeroTargets\x1a?\n\
    \x0cByHeroTarget\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\
    \x16\n\x06damage\x18\x02\x20\x01(\rR\x06damage\x1a\xa1\x02\n\x10HealingB\
    yAbility\x12*\n\x11source_unit_index\x18\x03\x20\x01(\rR\x0fsourceUnitIn\
    dex\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilityId\x12\x7f\n\x0f\
    by_hero_targets\x18\x02\x20\x03(\x0b2W.dota.CDOTAMatchPrivateMetadata.Te\
    am.Player.CombatSegment.HealingByAbility.ByHeroTargetR\rbyHeroTargets\
    \x1aA\n\x0cByHeroTarget\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06hero\
    Id\x12\x18\n\x07healing\x18\x02\x20\x01(\rR\x07healing\x1a\xc0\x02\n\nBu\
    ffRecord\x12&\n\x0fbuff_ability_id\x18\x01\x20\x01(\x05R\rbuffAbilityId\
    \x12,\n\x12buff_modifier_name\x18\x03\x20\x01(\tR\x10buffModifierName\
    \x12k\n\x0fby_hero_targets\x18\x02\x20\x03(\x0b2C.dota.CDOTAMatchPrivate\
    Metadata.Team.Player.BuffRecord.ByHeroTargetR\rbyHeroTargets\x1ao\n\x0cB\
    yHeroTarget\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12)\n\
    \x10elapsed_duration\x18\x02\x20\x01(\x02R\x0felapsedDuration\x12\x1b\n\
    \tis_hidden\x18\x03\x20\x01(\x08R\x08isHidden\x1a\xe1\x01\n\x0cGoldRecei\
    ved\x12\x14\n\x05creep\x18\x01\x20\x01(\rR\x05creep\x12\x16\n\x06heroes\
    \x18\x02\x20\x01(\rR\x06heroes\x12!\n\x0cbounty_runes\x18\x03\x20\x01(\r\
    R\x0bbountyRunes\x12\x18\n\x07passive\x18\x04\x20\x01(\rR\x07passive\x12\
    \x1c\n\tbuildings\x18\x05\x20\x01(\rR\tbuildings\x12\x1c\n\tabilities\
    \x18\x06\x20\x01(\rR\tabilities\x12\x14\n\x05wards\x18\x07\x20\x01(\rR\
    \x05wards\x12\x14\n\x05other\x18\x08\x20\x01(\rR\x05other\x1a\xae\x01\n\
    \nXPReceived\x12\x14\n\x05creep\x18\x01\x20\x01(\rR\x05creep\x12\x16\n\
    \x06heroes\x18\x02\x20\x01(\rR\x06heroes\x12\x16\n\x06roshan\x18\x03\x20\
    \x01(\rR\x06roshan\x12*\n\x11tome_of_knowledge\x18\x04\x20\x01(\rR\x0fto\
    meOfKnowledge\x12\x18\n\x07outpost\x18\x05\x20\x01(\rR\x07outpost\x12\
    \x14\n\x05other\x18\x06\x20\x01(\rR\x05other\x1a\x9a\x01\n\x08Building\
    \x12\x1b\n\tunit_name\x18\x01\x20\x01(\tR\x08unitName\x12(\n\x10position\
    _quant_x\x18\x02\x20\x01(\rR\x0epositionQuantX\x12(\n\x10position_quant_\
    y\x18\x03\x20\x01(\rR\x0epositionQuantY\x12\x1d\n\ndeath_time\x18\x04\
    \x20\x01(\x02R\tdeathTimeB%Z#github.com/dotabuff/manta/dota;dotaJ\xca\
    \xae\x01\n\x07\x12\x05\0\0\xd9\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\
    \x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\
    \x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1e\n\t\n\
    \x02\x03\x01\x12\x03\x06\x076\n\t\n\x02\x03\x02\x12\x03\x07\x07+\n\t\n\
    \x02\x03\x03\x12\x03\x08\x07%\n\t\n\x02\x03\x04\x12\x03\t\x07\x20\n\n\n\
    \x02\x04\0\x12\x04\x0b\0\x10\x01\n\n\n\x03\x04\0\x01\x12\x03\x0b\x08\x1e\
    \n\x0b\n\x04\x04\0\x02\0\x12\x03\x0c\x08#\n\x0c\n\x05\x04\0\x02\0\x04\
    \x12\x03\x0c\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0c\x11\x16\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0c\x17\x1e\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x0c!\"\n\x0b\n\x04\x04\0\x02\x01\x12\x03\r\x08%\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03\r\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\r\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\r\x18\x20\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\r#$\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x0e\
    \x081\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x0e\x08\x10\n\x0c\n\x05\x04\
    \0\x02\x02\x06\x12\x03\x0e\x11#\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\
    \x0e$,\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x0e/0\n\x0b\n\x04\x04\0\x02\
    \x03\x12\x03\x0f\x08,\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x0f\x08\x10\
    \n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x0f\x11\x16\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03\x0f\x17'\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0f*+\n\
    \x0b\n\x02\x04\x01\x12\x05\x12\0\xf4\x01\x01\n\n\n\x03\x04\x01\x01\x12\
    \x03\x12\x08\x1a\n\x0c\n\x04\x04\x01\x03\0\x12\x04\x13\x08\x19\t\n\x0c\n\
    \x05\x04\x01\x03\0\x01\x12\x03\x13\x10\x18\n\r\n\x06\x04\x01\x03\0\x02\0\
    \x12\x03\x14\x10.\n\x0e\n\x07\x04\x01\x03\0\x02\0\x04\x12\x03\x14\x10\
    \x18\n\x0e\n\x07\x04\x01\x03\0\x02\0\x05\x12\x03\x14\x19\x1f\n\x0e\n\x07\
    \x04\x01\x03\0\x02\0\x01\x12\x03\x14\x20)\n\x0e\n\x07\x04\x01\x03\0\x02\
    \0\x03\x12\x03\x14,-\n\r\n\x06\x04\x01\x03\0\x02\x01\x12\x03\x15\x10,\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x03\x15\x10\x18\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x01\x05\x12\x03\x15\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x01\x01\x12\x03\x15\x20'\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x03\x12\x03\
    \x15*+\n\r\n\x06\x04\x01\x03\0\x02\x02\x12\x03\x16\x10<\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x02\x04\x12\x03\x16\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x02\x06\x12\x03\x16\x19-\n\x0e\n\x07\x04\x01\x03\0\x02\x02\x01\x12\x03\
    \x16.7\n\x0e\n\x07\x04\x01\x03\0\x02\x02\x03\x12\x03\x16:;\n\r\n\x06\x04\
    \x01\x03\0\x02\x03\x12\x03\x17\x10*\n\x0e\n\x07\x04\x01\x03\0\x02\x03\
    \x04\x12\x03\x17\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x05\x12\x03\
    \x17\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x01\x12\x03\x17\x20%\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x03\x03\x12\x03\x17()\n\r\n\x06\x04\x01\x03\
    \0\x02\x04\x12\x03\x18\x10@\n\x0e\n\x07\x04\x01\x03\0\x02\x04\x04\x12\
    \x03\x18\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x04\x06\x12\x03\x18\x19,\
    \n\x0e\n\x07\x04\x01\x03\0\x02\x04\x01\x12\x03\x18-;\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x04\x03\x12\x03\x18>?\n\r\n\x04\x04\x01\x03\x01\x12\x05\x1b\
    \x08\xd1\x01\t\n\x0c\n\x05\x04\x01\x03\x01\x01\x12\x03\x1b\x10\x14\n\x0e\
    \n\x06\x04\x01\x03\x01\x03\0\x12\x04\x1c\x10\x1f\x11\n\x0e\n\x07\x04\x01\
    \x03\x01\x03\0\x01\x12\x03\x1c\x18\"\n\x0f\n\x08\x04\x01\x03\x01\x03\0\
    \x02\0\x12\x03\x1d\x188\n\x10\n\t\x04\x01\x03\x01\x03\0\x02\0\x04\x12\
    \x03\x1d\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\0\x02\0\x05\x12\x03\x1d!'\
    \n\x10\n\t\x04\x01\x03\x01\x03\0\x02\0\x01\x12\x03\x1d(3\n\x10\n\t\x04\
    \x01\x03\x01\x03\0\x02\0\x03\x12\x03\x1d67\n\x0f\n\x08\x04\x01\x03\x01\
    \x03\0\x02\x01\x12\x03\x1e\x182\n\x10\n\t\x04\x01\x03\x01\x03\0\x02\x01\
    \x04\x12\x03\x1e\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\0\x02\x01\x05\x12\
    \x03\x1e!'\n\x10\n\t\x04\x01\x03\x01\x03\0\x02\x01\x01\x12\x03\x1e(-\n\
    \x10\n\t\x04\x01\x03\x01\x03\0\x02\x01\x03\x12\x03\x1e01\n\x0e\n\x06\x04\
    \x01\x03\x01\x03\x01\x12\x04!\x10$\x11\n\x0e\n\x07\x04\x01\x03\x01\x03\
    \x01\x01\x12\x03!\x18$\n\x0f\n\x08\x04\x01\x03\x01\x03\x01\x02\0\x12\x03\
    \"\x183\n\x10\n\t\x04\x01\x03\x01\x03\x01\x02\0\x04\x12\x03\"\x18\x20\n\
    \x10\n\t\x04\x01\x03\x01\x03\x01\x02\0\x05\x12\x03\"!&\n\x10\n\t\x04\x01\
    \x03\x01\x03\x01\x02\0\x01\x12\x03\"'.\n\x10\n\t\x04\x01\x03\x01\x03\x01\
    \x02\0\x03\x12\x03\"12\n\x0f\n\x08\x04\x01\x03\x01\x03\x01\x02\x01\x12\
    \x03#\x189\n\x10\n\t\x04\x01\x03\x01\x03\x01\x02\x01\x04\x12\x03#\x18\
    \x20\n\x10\n\t\x04\x01\x03\x01\x03\x01\x02\x01\x05\x12\x03#!&\n\x10\n\t\
    \x04\x01\x03\x01\x03\x01\x02\x01\x01\x12\x03#'4\n\x10\n\t\x04\x01\x03\
    \x01\x03\x01\x02\x01\x03\x12\x03#78\n\x0e\n\x06\x04\x01\x03\x01\x03\x02\
    \x12\x04&\x10/\x11\n\x0e\n\x07\x04\x01\x03\x01\x03\x02\x01\x12\x03&\x18)\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x02\x02\0\x12\x03'\x183\n\x10\n\t\x04\
    \x01\x03\x01\x03\x02\x02\0\x04\x12\x03'\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x02\x02\0\x05\x12\x03'!&\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\
    \0\x01\x12\x03''.\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\0\x03\x12\x03'12\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x02\x02\x01\x12\x03(\x185\n\x10\n\t\x04\
    \x01\x03\x01\x03\x02\x02\x01\x04\x12\x03(\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x02\x02\x01\x05\x12\x03(!&\n\x10\n\t\x04\x01\x03\x01\x03\x02\
    \x02\x01\x01\x12\x03('0\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x01\x03\
    \x12\x03(34\n\x0f\n\x08\x04\x01\x03\x01\x03\x02\x02\x02\x12\x03)\x182\n\
    \x10\n\t\x04\x01\x03\x01\x03\x02\x02\x02\x04\x12\x03)\x18\x20\n\x10\n\t\
    \x04\x01\x03\x01\x03\x02\x02\x02\x05\x12\x03)!'\n\x10\n\t\x04\x01\x03\
    \x01\x03\x02\x02\x02\x01\x12\x03)(-\n\x10\n\t\x04\x01\x03\x01\x03\x02\
    \x02\x02\x03\x12\x03)01\n\x0f\n\x08\x04\x01\x03\x01\x03\x02\x02\x03\x12\
    \x03*\x183\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x03\x04\x12\x03*\x18\
    \x20\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x03\x05\x12\x03*!'\n\x10\n\t\
    \x04\x01\x03\x01\x03\x02\x02\x03\x01\x12\x03*(.\n\x10\n\t\x04\x01\x03\
    \x01\x03\x02\x02\x03\x03\x12\x03*12\n\x0f\n\x08\x04\x01\x03\x01\x03\x02\
    \x02\x04\x12\x03+\x184\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x04\x04\x12\
    \x03+\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x04\x05\x12\x03+!'\n\
    \x10\n\t\x04\x01\x03\x01\x03\x02\x02\x04\x01\x12\x03+(/\n\x10\n\t\x04\
    \x01\x03\x01\x03\x02\x02\x04\x03\x12\x03+23\n\x0f\n\x08\x04\x01\x03\x01\
    \x03\x02\x02\x05\x12\x03,\x182\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x05\
    \x04\x12\x03,\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x05\x05\x12\
    \x03,!'\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x05\x01\x12\x03,(-\n\x10\n\
    \t\x04\x01\x03\x01\x03\x02\x02\x05\x03\x12\x03,01\n\x0f\n\x08\x04\x01\
    \x03\x01\x03\x02\x02\x06\x12\x03-\x18<\n\x10\n\t\x04\x01\x03\x01\x03\x02\
    \x02\x06\x04\x12\x03-\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x06\
    \x05\x12\x03-!&\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x06\x01\x12\x03-'7\
    \n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x06\x03\x12\x03-:;\n\x0f\n\x08\
    \x04\x01\x03\x01\x03\x02\x02\x07\x12\x03.\x18;\n\x10\n\t\x04\x01\x03\x01\
    \x03\x02\x02\x07\x04\x12\x03.\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x02\
    \x02\x07\x05\x12\x03.!&\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x07\x01\
    \x12\x03.'6\n\x10\n\t\x04\x01\x03\x01\x03\x02\x02\x07\x03\x12\x03.9:\n\
    \x0e\n\x06\x04\x01\x03\x01\x03\x03\x12\x041\x104\x11\n\x0e\n\x07\x04\x01\
    \x03\x01\x03\x03\x01\x12\x031\x18)\n\x0f\n\x08\x04\x01\x03\x01\x03\x03\
    \x02\0\x12\x032\x187\n\x10\n\t\x04\x01\x03\x01\x03\x03\x02\0\x04\x12\x03\
    2\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x03\x02\0\x05\x12\x032!'\n\x10\n\
    \t\x04\x01\x03\x01\x03\x03\x02\0\x01\x12\x032(2\n\x10\n\t\x04\x01\x03\
    \x01\x03\x03\x02\0\x03\x12\x03256\n\x0f\n\x08\x04\x01\x03\x01\x03\x03\
    \x02\x01\x12\x033\x181\n\x10\n\t\x04\x01\x03\x01\x03\x03\x02\x01\x04\x12\
    \x033\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x03\x02\x01\x05\x12\x033!&\n\
    \x10\n\t\x04\x01\x03\x01\x03\x03\x02\x01\x01\x12\x033',\n\x10\n\t\x04\
    \x01\x03\x01\x03\x03\x02\x01\x03\x12\x033/0\n\x0e\n\x06\x04\x01\x03\x01\
    \x03\x04\x12\x046\x10>\x11\n\x0e\n\x07\x04\x01\x03\x01\x03\x04\x01\x12\
    \x036\x18*\n\x0f\n\x08\x04\x01\x03\x01\x03\x04\x02\0\x12\x037\x18<\n\x10\
    \n\t\x04\x01\x03\x01\x03\x04\x02\0\x04\x12\x037\x18\x20\n\x10\n\t\x04\
    \x01\x03\x01\x03\x04\x02\0\x05\x12\x037!'\n\x10\n\t\x04\x01\x03\x01\x03\
    \x04\x02\0\x01\x12\x037(7\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\0\x03\
    \x12\x037:;\n\x0f\n\x08\x04\x01\x03\x01\x03\x04\x02\x01\x12\x038\x18?\n\
    \x10\n\t\x04\x01\x03\x01\x03\x04\x02\x01\x04\x12\x038\x18\x20\n\x10\n\t\
    \x04\x01\x03\x01\x03\x04\x02\x01\x05\x12\x038!'\n\x10\n\t\x04\x01\x03\
    \x01\x03\x04\x02\x01\x01\x12\x038(:\n\x10\n\t\x04\x01\x03\x01\x03\x04\
    \x02\x01\x03\x12\x038=>\n\x0f\n\x08\x04\x01\x03\x01\x03\x04\x02\x02\x12\
    \x039\x18=\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x02\x04\x12\x039\x18\
    \x20\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x02\x05\x12\x039!'\n\x10\n\t\
    \x04\x01\x03\x01\x03\x04\x02\x02\x01\x12\x039(8\n\x10\n\t\x04\x01\x03\
    \x01\x03\x04\x02\x02\x03\x12\x039;<\n\x0f\n\x08\x04\x01\x03\x01\x03\x04\
    \x02\x03\x12\x03:\x18;\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x03\x04\x12\
    \x03:\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x03\x05\x12\x03:!'\n\
    \x10\n\t\x04\x01\x03\x01\x03\x04\x02\x03\x01\x12\x03:(6\n\x10\n\t\x04\
    \x01\x03\x01\x03\x04\x02\x03\x03\x12\x03:9:\n\x0f\n\x08\x04\x01\x03\x01\
    \x03\x04\x02\x04\x12\x03;\x189\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x04\
    \x04\x12\x03;\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x04\x05\x12\
    \x03;!'\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x04\x01\x12\x03;(4\n\x10\n\
    \t\x04\x01\x03\x01\x03\x04\x02\x04\x03\x12\x03;78\n\x0f\n\x08\x04\x01\
    \x03\x01\x03\x04\x02\x05\x12\x03<\x18A\n\x10\n\t\x04\x01\x03\x01\x03\x04\
    \x02\x05\x04\x12\x03<\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x05\
    \x05\x12\x03<!'\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x05\x01\x12\x03<(<\
    \n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x05\x03\x12\x03<?@\n\x0f\n\x08\
    \x04\x01\x03\x01\x03\x04\x02\x06\x12\x03=\x18:\n\x10\n\t\x04\x01\x03\x01\
    \x03\x04\x02\x06\x04\x12\x03=\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x04\
    \x02\x06\x05\x12\x03=!'\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x06\x01\
    \x12\x03=(5\n\x10\n\t\x04\x01\x03\x01\x03\x04\x02\x06\x03\x12\x03=89\n\
    \x0e\n\x06\x04\x01\x03\x01\x03\x05\x12\x04@\x10E\x11\n\x0e\n\x07\x04\x01\
    \x03\x01\x03\x05\x01\x12\x03@\x18)\n\x0f\n\x08\x04\x01\x03\x01\x03\x05\
    \x02\0\x12\x03A\x184\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\0\x04\x12\x03\
    A\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\0\x05\x12\x03A!'\n\x10\n\
    \t\x04\x01\x03\x01\x03\x05\x02\0\x01\x12\x03A(/\n\x10\n\t\x04\x01\x03\
    \x01\x03\x05\x02\0\x03\x12\x03A23\n\x0f\n\x08\x04\x01\x03\x01\x03\x05\
    \x02\x01\x12\x03B\x18;\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x01\x04\x12\
    \x03B\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x01\x05\x12\x03B!'\n\
    \x10\n\t\x04\x01\x03\x01\x03\x05\x02\x01\x01\x12\x03B(6\n\x10\n\t\x04\
    \x01\x03\x01\x03\x05\x02\x01\x03\x12\x03B9:\n\x0f\n\x08\x04\x01\x03\x01\
    \x03\x05\x02\x02\x12\x03C\x18;\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x02\
    \x04\x12\x03C\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x02\x05\x12\
    \x03C!'\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x02\x01\x12\x03C(6\n\x10\n\
    \t\x04\x01\x03\x01\x03\x05\x02\x02\x03\x12\x03C9:\n\x0f\n\x08\x04\x01\
    \x03\x01\x03\x05\x02\x03\x12\x03D\x185\n\x10\n\t\x04\x01\x03\x01\x03\x05\
    \x02\x03\x04\x12\x03D\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x03\
    \x05\x12\x03D!%\n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x03\x01\x12\x03D&0\
    \n\x10\n\t\x04\x01\x03\x01\x03\x05\x02\x03\x03\x12\x03D34\n\x0e\n\x06\
    \x04\x01\x03\x01\x03\x06\x12\x04G\x10L\x11\n\x0e\n\x07\x04\x01\x03\x01\
    \x03\x06\x01\x12\x03G\x18$\n\x0f\n\x08\x04\x01\x03\x01\x03\x06\x02\0\x12\
    \x03H\x184\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\0\x04\x12\x03H\x18\x20\
    \n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\0\x05\x12\x03H!'\n\x10\n\t\x04\
    \x01\x03\x01\x03\x06\x02\0\x01\x12\x03H(/\n\x10\n\t\x04\x01\x03\x01\x03\
    \x06\x02\0\x03\x12\x03H23\n\x0f\n\x08\x04\x01\x03\x01\x03\x06\x02\x01\
    \x12\x03I\x188\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\x01\x04\x12\x03I\
    \x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\x01\x05\x12\x03I!'\n\x10\
    \n\t\x04\x01\x03\x01\x03\x06\x02\x01\x01\x12\x03I(3\n\x10\n\t\x04\x01\
    \x03\x01\x03\x06\x02\x01\x03\x12\x03I67\n\x0f\n\x08\x04\x01\x03\x01\x03\
    \x06\x02\x02\x12\x03J\x186\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\x02\x04\
    \x12\x03J\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\x02\x05\x12\x03J\
    !'\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\x02\x01\x12\x03J(1\n\x10\n\t\
    \x04\x01\x03\x01\x03\x06\x02\x02\x03\x12\x03J45\n\x0f\n\x08\x04\x01\x03\
    \x01\x03\x06\x02\x03\x12\x03K\x184\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\
    \x03\x04\x12\x03K\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\x03\x05\
    \x12\x03K!%\n\x10\n\t\x04\x01\x03\x01\x03\x06\x02\x03\x01\x12\x03K&/\n\
    \x10\n\t\x04\x01\x03\x01\x03\x06\x02\x03\x03\x12\x03K23\n\x0e\n\x06\x04\
    \x01\x03\x01\x03\x07\x12\x04N\x10Q\x11\n\x0e\n\x07\x04\x01\x03\x01\x03\
    \x07\x01\x12\x03N\x18-\n\x0f\n\x08\x04\x01\x03\x01\x03\x07\x02\0\x12\x03\
    O\x18>\n\x10\n\t\x04\x01\x03\x01\x03\x07\x02\0\x04\x12\x03O\x18\x20\n\
    \x10\n\t\x04\x01\x03\x01\x03\x07\x02\0\x05\x12\x03O!'\n\x10\n\t\x04\x01\
    \x03\x01\x03\x07\x02\0\x01\x12\x03O(9\n\x10\n\t\x04\x01\x03\x01\x03\x07\
    \x02\0\x03\x12\x03O<=\n\x0f\n\x08\x04\x01\x03\x01\x03\x07\x02\x01\x12\
    \x03P\x18<\n\x10\n\t\x04\x01\x03\x01\x03\x07\x02\x01\x04\x12\x03P\x18\
    \x20\n\x10\n\t\x04\x01\x03\x01\x03\x07\x02\x01\x05\x12\x03P!'\n\x10\n\t\
    \x04\x01\x03\x01\x03\x07\x02\x01\x01\x12\x03P(7\n\x10\n\t\x04\x01\x03\
    \x01\x03\x07\x02\x01\x03\x12\x03P:;\n\x0e\n\x06\x04\x01\x03\x01\x03\x08\
    \x12\x04S\x10Y\x11\n\x0e\n\x07\x04\x01\x03\x01\x03\x08\x01\x12\x03S\x18#\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x08\x02\0\x12\x03T\x186\n\x10\n\t\x04\
    \x01\x03\x01\x03\x08\x02\0\x04\x12\x03T\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x08\x02\0\x05\x12\x03T!'\n\x10\n\t\x04\x01\x03\x01\x03\x08\x02\
    \0\x01\x12\x03T(1\n\x10\n\t\x04\x01\x03\x01\x03\x08\x02\0\x03\x12\x03T45\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x08\x02\x01\x12\x03U\x185\n\x10\n\t\x04\
    \x01\x03\x01\x03\x08\x02\x01\x04\x12\x03U\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x08\x02\x01\x05\x12\x03U!'\n\x10\n\t\x04\x01\x03\x01\x03\x08\
    \x02\x01\x01\x12\x03U(0\n\x10\n\t\x04\x01\x03\x01\x03\x08\x02\x01\x03\
    \x12\x03U34\n\x0f\n\x08\x04\x01\x03\x01\x03\x08\x02\x02\x12\x03V\x182\n\
    \x10\n\t\x04\x01\x03\x01\x03\x08\x02\x02\x04\x12\x03V\x18\x20\n\x10\n\t\
    \x04\x01\x03\x01\x03\x08\x02\x02\x05\x12\x03V!'\n\x10\n\t\x04\x01\x03\
    \x01\x03\x08\x02\x02\x01\x12\x03V(-\n\x10\n\t\x04\x01\x03\x01\x03\x08\
    \x02\x02\x03\x12\x03V01\n\x0f\n\x08\x04\x01\x03\x01\x03\x08\x02\x03\x12\
    \x03W\x187\n\x10\n\t\x04\x01\x03\x01\x03\x08\x02\x03\x04\x12\x03W\x18\
    \x20\n\x10\n\t\x04\x01\x03\x01\x03\x08\x02\x03\x05\x12\x03W!%\n\x10\n\t\
    \x04\x01\x03\x01\x03\x08\x02\x03\x01\x12\x03W&2\n\x10\n\t\x04\x01\x03\
    \x01\x03\x08\x02\x03\x03\x12\x03W56\n\x0f\n\x08\x04\x01\x03\x01\x03\x08\
    \x02\x04\x12\x03X\x187\n\x10\n\t\x04\x01\x03\x01\x03\x08\x02\x04\x04\x12\
    \x03X\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x08\x02\x04\x05\x12\x03X!'\n\
    \x10\n\t\x04\x01\x03\x01\x03\x08\x02\x04\x01\x12\x03X(2\n\x10\n\t\x04\
    \x01\x03\x01\x03\x08\x02\x04\x03\x12\x03X56\n\x0e\n\x06\x04\x01\x03\x01\
    \x03\t\x12\x04[\x10^\x11\n\x0e\n\x07\x04\x01\x03\x01\x03\t\x01\x12\x03[\
    \x18\"\n\x0f\n\x08\x04\x01\x03\x01\x03\t\x02\0\x12\x03\\\x183\n\x10\n\t\
    \x04\x01\x03\x01\x03\t\x02\0\x04\x12\x03\\\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\t\x02\0\x05\x12\x03\\!'\n\x10\n\t\x04\x01\x03\x01\x03\t\x02\0\
    \x01\x12\x03\\(.\n\x10\n\t\x04\x01\x03\x01\x03\t\x02\0\x03\x12\x03\\12\n\
    \x0f\n\x08\x04\x01\x03\x01\x03\t\x02\x01\x12\x03]\x183\n\x10\n\t\x04\x01\
    \x03\x01\x03\t\x02\x01\x04\x12\x03]\x18\x20\n\x10\n\t\x04\x01\x03\x01\
    \x03\t\x02\x01\x05\x12\x03]!'\n\x10\n\t\x04\x01\x03\x01\x03\t\x02\x01\
    \x01\x12\x03](.\n\x10\n\t\x04\x01\x03\x01\x03\t\x02\x01\x03\x12\x03]12\n\
    \x0e\n\x06\x04\x01\x03\x01\x03\n\x12\x04`\x10d\x11\n\x0e\n\x07\x04\x01\
    \x03\x01\x03\n\x01\x12\x03`\x18,\n\x0f\n\x08\x04\x01\x03\x01\x03\n\x02\0\
    \x12\x03a\x18A\n\x10\n\t\x04\x01\x03\x01\x03\n\x02\0\x04\x12\x03a\x18\
    \x20\n\x10\n\t\x04\x01\x03\x01\x03\n\x02\0\x05\x12\x03a!'\n\x10\n\t\x04\
    \x01\x03\x01\x03\n\x02\0\x01\x12\x03a(<\n\x10\n\t\x04\x01\x03\x01\x03\n\
    \x02\0\x03\x12\x03a?@\n\x0f\n\x08\x04\x01\x03\x01\x03\n\x02\x01\x12\x03b\
    \x186\n\x10\n\t\x04\x01\x03\x01\x03\n\x02\x01\x04\x12\x03b\x18\x20\n\x10\
    \n\t\x04\x01\x03\x01\x03\n\x02\x01\x05\x12\x03b!'\n\x10\n\t\x04\x01\x03\
    \x01\x03\n\x02\x01\x01\x12\x03b(1\n\x10\n\t\x04\x01\x03\x01\x03\n\x02\
    \x01\x03\x12\x03b45\n\x0f\n\x08\x04\x01\x03\x01\x03\n\x02\x02\x12\x03c\
    \x180\n\x10\n\t\x04\x01\x03\x01\x03\n\x02\x02\x04\x12\x03c\x18\x20\n\x10\
    \n\t\x04\x01\x03\x01\x03\n\x02\x02\x05\x12\x03c!'\n\x10\n\t\x04\x01\x03\
    \x01\x03\n\x02\x02\x01\x12\x03c(+\n\x10\n\t\x04\x01\x03\x01\x03\n\x02\
    \x02\x03\x12\x03c./\n\x0f\n\x06\x04\x01\x03\x01\x03\x0b\x12\x05f\x10\x80\
    \x01\x11\n\x0e\n\x07\x04\x01\x03\x01\x03\x0b\x01\x12\x03f\x18!\n\x0f\n\
    \x08\x04\x01\x03\x01\x03\x0b\x02\0\x12\x03g\x185\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\0\x04\x12\x03g\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\
    \x0b\x02\0\x05\x12\x03g!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\0\x01\
    \x12\x03g(0\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\0\x03\x12\x03g34\n\x0f\
    \n\x08\x04\x01\x03\x01\x03\x0b\x02\x01\x12\x03h\x189\n\x10\n\t\x04\x01\
    \x03\x01\x03\x0b\x02\x01\x04\x12\x03h\x18\x20\n\x10\n\t\x04\x01\x03\x01\
    \x03\x0b\x02\x01\x05\x12\x03h!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \x01\x01\x12\x03h(4\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x01\x03\x12\
    \x03h78\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x02\x12\x03i\x18B\n\x10\
    \n\t\x04\x01\x03\x01\x03\x0b\x02\x02\x04\x12\x03i\x18\x20\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\x02\x05\x12\x03i!'\n\x10\n\t\x04\x01\x03\x01\
    \x03\x0b\x02\x02\x01\x12\x03i(=\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \x02\x03\x12\x03i@A\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x03\x12\x03j\
    \x18?\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x03\x04\x12\x03j\x18\x20\n\
    \x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x03\x05\x12\x03j!'\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\x03\x01\x12\x03j(:\n\x10\n\t\x04\x01\x03\x01\
    \x03\x0b\x02\x03\x03\x12\x03j=>\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\
    \x04\x12\x03k\x18I\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x04\x04\x12\x03\
    k\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x04\x05\x12\x03k!'\n\x10\
    \n\t\x04\x01\x03\x01\x03\x0b\x02\x04\x01\x12\x03k(D\n\x10\n\t\x04\x01\
    \x03\x01\x03\x0b\x02\x04\x03\x12\x03kGH\n\x0f\n\x08\x04\x01\x03\x01\x03\
    \x0b\x02\x05\x12\x03l\x18>\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x05\x04\
    \x12\x03l\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x05\x05\x12\x03l\
    !%\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x05\x01\x12\x03l&9\n\x10\n\t\
    \x04\x01\x03\x01\x03\x0b\x02\x05\x03\x12\x03l<=\n\x0f\n\x08\x04\x01\x03\
    \x01\x03\x0b\x02\x06\x12\x03m\x18E\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \x06\x04\x12\x03m\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x06\x05\
    \x12\x03m!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x06\x01\x12\x03m(@\n\
    \x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x06\x03\x12\x03mCD\n\x0f\n\x08\x04\
    \x01\x03\x01\x03\x0b\x02\x07\x12\x03n\x18P\n\x10\n\t\x04\x01\x03\x01\x03\
    \x0b\x02\x07\x04\x12\x03n\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \x07\x05\x12\x03n!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x07\x01\x12\
    \x03n(K\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x07\x03\x12\x03nNO\n\x0f\n\
    \x08\x04\x01\x03\x01\x03\x0b\x02\x08\x12\x03o\x186\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\x08\x04\x12\x03o\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\
    \x0b\x02\x08\x05\x12\x03o!%\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x08\
    \x01\x12\x03o&1\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x08\x03\x12\x03o45\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\t\x12\x03p\x18h\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\t\x04\x12\x03p\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\t\x06\x12\x03p!E\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \t\x01\x12\x03pFb\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\t\x03\x12\x03peg\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\n\x12\x03q\x18<\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\n\x04\x12\x03q\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\n\x05\x12\x03q!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \n\x01\x12\x03q(6\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\n\x03\x12\x03q9;\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x0b\x12\x03r\x18C\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\x0b\x04\x12\x03r\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\x0b\x05\x12\x03r!%\n\x10\n\t\x04\x01\x03\x01\x03\x0b\
    \x02\x0b\x01\x12\x03r&=\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x0b\x03\
    \x12\x03r@B\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x0c\x12\x03s\x18G\n\
    \x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x0c\x04\x12\x03s\x18\x20\n\x10\n\t\
    \x04\x01\x03\x01\x03\x0b\x02\x0c\x05\x12\x03s!'\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\x0c\x01\x12\x03s(A\n\x10\n\t\x04\x01\x03\x01\x03\x0b\
    \x02\x0c\x03\x12\x03sDF\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\r\x12\
    \x03t\x18<\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\r\x04\x12\x03t\x18\x20\
    \n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\r\x05\x12\x03t!'\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\r\x01\x12\x03t(6\n\x10\n\t\x04\x01\x03\x01\x03\
    \x0b\x02\r\x03\x12\x03t9;\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x0e\
    \x12\x03u\x18H\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x0e\x04\x12\x03u\
    \x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x0e\x05\x12\x03u!'\n\x10\
    \n\t\x04\x01\x03\x01\x03\x0b\x02\x0e\x01\x12\x03u(B\n\x10\n\t\x04\x01\
    \x03\x01\x03\x0b\x02\x0e\x03\x12\x03uEG\n\x0f\n\x08\x04\x01\x03\x01\x03\
    \x0b\x02\x0f\x12\x03v\x18q\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x0f\x04\
    \x12\x03v\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x0f\x06\x12\x03v\
    !N\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x0f\x01\x12\x03vOk\n\x10\n\t\
    \x04\x01\x03\x01\x03\x0b\x02\x0f\x03\x12\x03vnp\n\x0f\n\x08\x04\x01\x03\
    \x01\x03\x0b\x02\x10\x12\x03w\x18R\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \x10\x04\x12\x03w\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x10\x05\
    \x12\x03w!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x10\x01\x12\x03w(L\n\
    \x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x10\x03\x12\x03wOQ\n\x0f\n\x08\x04\
    \x01\x03\x01\x03\x0b\x02\x11\x12\x03x\x18Z\n\x10\n\t\x04\x01\x03\x01\x03\
    \x0b\x02\x11\x04\x12\x03x\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\
    \x11\x06\x12\x03x!D\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x11\x01\x12\
    \x03xET\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x11\x03\x12\x03xWY\n\x0f\n\
    \x08\x04\x01\x03\x01\x03\x0b\x02\x12\x12\x03y\x18F\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\x12\x04\x12\x03y\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\
    \x0b\x02\x12\x05\x12\x03y!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x12\
    \x01\x12\x03y(@\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x12\x03\x12\x03yCE\
    \n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x13\x12\x03z\x18B\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\x13\x04\x12\x03z\x18\x20\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\x13\x05\x12\x03z!'\n\x10\n\t\x04\x01\x03\x01\x03\x0b\
    \x02\x13\x01\x12\x03z(<\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x13\x03\
    \x12\x03z?A\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x14\x12\x03{\x18>\n\
    \x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x14\x04\x12\x03{\x18\x20\n\x10\n\t\
    \x04\x01\x03\x01\x03\x0b\x02\x14\x05\x12\x03{!'\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\x14\x01\x12\x03{(8\n\x10\n\t\x04\x01\x03\x01\x03\x0b\
    \x02\x14\x03\x12\x03{;=\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\x02\x15\x12\
    \x03|\x18^\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x15\x04\x12\x03|\x18\
    \x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x15\x06\x12\x03|!C\n\x10\n\t\
    \x04\x01\x03\x01\x03\x0b\x02\x15\x01\x12\x03|DX\n\x10\n\t\x04\x01\x03\
    \x01\x03\x0b\x02\x15\x03\x12\x03|[]\n\x0f\n\x08\x04\x01\x03\x01\x03\x0b\
    \x02\x16\x12\x03}\x18>\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x16\x04\x12\
    \x03}\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x16\x05\x12\x03}!'\n\
    \x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x16\x01\x12\x03}(8\n\x10\n\t\x04\
    \x01\x03\x01\x03\x0b\x02\x16\x03\x12\x03};=\n\x0f\n\x08\x04\x01\x03\x01\
    \x03\x0b\x02\x17\x12\x03~\x18D\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x17\
    \x04\x12\x03~\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x17\x05\x12\
    \x03~!%\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x17\x01\x12\x03~&>\n\x10\n\
    \t\x04\x01\x03\x01\x03\x0b\x02\x17\x03\x12\x03~AC\n\x0f\n\x08\x04\x01\
    \x03\x01\x03\x0b\x02\x18\x12\x03\x7f\x18f\n\x10\n\t\x04\x01\x03\x01\x03\
    \x0b\x02\x18\x04\x12\x03\x7f\x18\x20\n\x10\n\t\x04\x01\x03\x01\x03\x0b\
    \x02\x18\x06\x12\x03\x7f!M\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x18\x01\
    \x12\x03\x7fN`\n\x10\n\t\x04\x01\x03\x01\x03\x0b\x02\x18\x03\x12\x03\x7f\
    ce\n\x10\n\x06\x04\x01\x03\x01\x03\x0c\x12\x06\x82\x01\x10\x86\x01\x11\n\
    \x0f\n\x07\x04\x01\x03\x01\x03\x0c\x01\x12\x04\x82\x01\x180\n\x10\n\x08\
    \x04\x01\x03\x01\x03\x0c\x02\0\x12\x04\x83\x01\x188\n\x11\n\t\x04\x01\
    \x03\x01\x03\x0c\x02\0\x04\x12\x04\x83\x01\x18\x20\n\x11\n\t\x04\x01\x03\
    \x01\x03\x0c\x02\0\x05\x12\x04\x83\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\
    \x0c\x02\0\x01\x12\x04\x83\x01(3\n\x11\n\t\x04\x01\x03\x01\x03\x0c\x02\0\
    \x03\x12\x04\x83\x0167\n\x10\n\x08\x04\x01\x03\x01\x03\x0c\x02\x01\x12\
    \x04\x84\x01\x186\n\x11\n\t\x04\x01\x03\x01\x03\x0c\x02\x01\x04\x12\x04\
    \x84\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\x0c\x02\x01\x05\x12\x04\
    \x84\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\x0c\x02\x01\x01\x12\x04\x84\x01\
    (1\n\x11\n\t\x04\x01\x03\x01\x03\x0c\x02\x01\x03\x12\x04\x84\x0145\n\x10\
    \n\x08\x04\x01\x03\x01\x03\x0c\x02\x02\x12\x04\x85\x01\x186\n\x11\n\t\
    \x04\x01\x03\x01\x03\x0c\x02\x02\x04\x12\x04\x85\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\x0c\x02\x02\x05\x12\x04\x85\x01!'\n\x11\n\t\x04\x01\
    \x03\x01\x03\x0c\x02\x02\x01\x12\x04\x85\x01(1\n\x11\n\t\x04\x01\x03\x01\
    \x03\x0c\x02\x02\x03\x12\x04\x85\x0145\n\x10\n\x06\x04\x01\x03\x01\x03\r\
    \x12\x06\x88\x01\x10\xc7\x01\x11\n\x0f\n\x07\x04\x01\x03\x01\x03\r\x01\
    \x12\x04\x88\x01\x18\x1e\n\x12\n\x08\x04\x01\x03\x01\x03\r\x03\0\x12\x06\
    \x89\x01\x18\x91\x01\x19\n\x11\n\t\x04\x01\x03\x01\x03\r\x03\0\x01\x12\
    \x04\x89\x01\x200\n\x12\n\n\x04\x01\x03\x01\x03\r\x03\0\x02\0\x12\x04\
    \x8a\x01\x20=\n\x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\0\x04\x12\x04\
    \x8a\x01\x20(\n\x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\0\x05\x12\x04\
    \x8a\x01)/\n\x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\0\x01\x12\x04\x8a\
    \x0108\n\x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\0\x03\x12\x04\x8a\x01\
    ;<\n\x12\n\n\x04\x01\x03\x01\x03\r\x03\0\x02\x01\x12\x04\x8b\x01\x20=\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x01\x04\x12\x04\x8b\x01\x20(\
    \n\x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x01\x05\x12\x04\x8b\x01)/\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x01\x01\x12\x04\x8b\x0108\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x01\x03\x12\x04\x8b\x01;<\n\
    \x12\n\n\x04\x01\x03\x01\x03\r\x03\0\x02\x02\x12\x04\x8c\x01\x20J\n\x13\
    \n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x02\x04\x12\x04\x8c\x01\x20(\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x02\x05\x12\x04\x8c\x01)/\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x02\x01\x12\x04\x8c\x010E\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x02\x03\x12\x04\x8c\x01HI\n\
    \x12\n\n\x04\x01\x03\x01\x03\r\x03\0\x02\x03\x12\x04\x8d\x01\x20H\n\x13\
    \n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x03\x04\x12\x04\x8d\x01\x20(\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x03\x05\x12\x04\x8d\x01)/\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x03\x01\x12\x04\x8d\x010C\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x03\x03\x12\x04\x8d\x01FG\n\
    \x12\n\n\x04\x01\x03\x01\x03\r\x03\0\x02\x04\x12\x04\x8e\x01\x20C\n\x13\
    \n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x04\x04\x12\x04\x8e\x01\x20(\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x04\x05\x12\x04\x8e\x01)/\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x04\x01\x12\x04\x8e\x010>\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x04\x03\x12\x04\x8e\x01AB\n\
    \x12\n\n\x04\x01\x03\x01\x03\r\x03\0\x02\x05\x12\x04\x8f\x01\x20B\n\x13\
    \n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x05\x04\x12\x04\x8f\x01\x20(\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x05\x05\x12\x04\x8f\x01)/\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x05\x01\x12\x04\x8f\x010=\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x05\x03\x12\x04\x8f\x01@A\n\
    \x12\n\n\x04\x01\x03\x01\x03\r\x03\0\x02\x06\x12\x04\x90\x01\x20<\n\x13\
    \n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x06\x04\x12\x04\x90\x01\x20(\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x06\x05\x12\x04\x90\x01)-\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x06\x01\x12\x04\x90\x01.7\n\
    \x13\n\x0b\x04\x01\x03\x01\x03\r\x03\0\x02\x06\x03\x12\x04\x90\x01:;\n\
    \x10\n\x08\x04\x01\x03\x01\x03\r\x02\0\x12\x04\x93\x01\x18<\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\0\x04\x12\x04\x93\x01\x18\x20\n\x11\n\t\x04\
    \x01\x03\x01\x03\r\x02\0\x05\x12\x04\x93\x01!&\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\0\x01\x12\x04\x93\x01'7\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\0\
    \x03\x12\x04\x93\x01:;\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x01\x12\x04\
    \x94\x01\x188\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x01\x04\x12\x04\x94\
    \x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x01\x05\x12\x04\x94\x01\
    !'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x01\x01\x12\x04\x94\x01(3\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x01\x03\x12\x04\x94\x0167\n\x10\n\x08\x04\
    \x01\x03\x01\x03\r\x02\x02\x12\x04\x95\x01\x18N\n\x11\n\t\x04\x01\x03\
    \x01\x03\r\x02\x02\x04\x12\x04\x95\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x02\x06\x12\x04\x95\x01!C\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\
    \x02\x01\x12\x04\x95\x01DI\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x02\x03\
    \x12\x04\x95\x01LM\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x03\x12\x04\x96\
    \x01\x18P\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x03\x04\x12\x04\x96\x01\
    \x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x03\x06\x12\x04\x96\x01!E\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02\x03\x01\x12\x04\x96\x01FK\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x03\x03\x12\x04\x96\x01NO\n\x10\n\x08\x04\x01\
    \x03\x01\x03\r\x02\x04\x12\x04\x97\x01\x18:\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x04\x04\x12\x04\x97\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\
    \r\x02\x04\x05\x12\x04\x97\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x04\
    \x01\x12\x04\x97\x01(5\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x04\x03\x12\
    \x04\x97\x0189\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x05\x12\x04\x98\x01\
    \x18;\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x05\x04\x12\x04\x98\x01\x18\
    \x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x05\x05\x12\x04\x98\x01!'\n\x11\
    \n\t\x04\x01\x03\x01\x03\r\x02\x05\x01\x12\x04\x98\x01(6\n\x11\n\t\x04\
    \x01\x03\x01\x03\r\x02\x05\x03\x12\x04\x98\x019:\n\x10\n\x08\x04\x01\x03\
    \x01\x03\r\x02\x06\x12\x04\x99\x01\x18<\n\x11\n\t\x04\x01\x03\x01\x03\r\
    \x02\x06\x04\x12\x04\x99\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\
    \x06\x05\x12\x04\x99\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x06\x01\
    \x12\x04\x99\x01(7\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x06\x03\x12\x04\
    \x99\x01:;\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x07\x12\x04\x9a\x01\x18\
    9\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x07\x04\x12\x04\x9a\x01\x18\x20\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02\x07\x05\x12\x04\x9a\x01!'\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x07\x01\x12\x04\x9a\x01(3\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x07\x03\x12\x04\x9a\x0168\n\x10\n\x08\x04\x01\x03\x01\
    \x03\r\x02\x08\x12\x04\x9b\x01\x189\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\
    \x08\x04\x12\x04\x9b\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x08\
    \x05\x12\x04\x9b\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x08\x01\x12\
    \x04\x9b\x01(3\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x08\x03\x12\x04\x9b\
    \x0168\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\t\x12\x04\x9c\x01\x18<\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02\t\x04\x12\x04\x9c\x01\x18\x20\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\t\x05\x12\x04\x9c\x01!'\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\t\x01\x12\x04\x9c\x01(6\n\x11\n\t\x04\x01\x03\x01\x03\
    \r\x02\t\x03\x12\x04\x9c\x019;\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\n\
    \x12\x04\x9d\x01\x18>\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\n\x04\x12\x04\
    \x9d\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\n\x05\x12\x04\x9d\
    \x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\n\x01\x12\x04\x9d\x01(8\n\x11\
    \n\t\x04\x01\x03\x01\x03\r\x02\n\x03\x12\x04\x9d\x01;=\n\x10\n\x08\x04\
    \x01\x03\x01\x03\r\x02\x0b\x12\x04\x9e\x01\x18:\n\x11\n\t\x04\x01\x03\
    \x01\x03\r\x02\x0b\x04\x12\x04\x9e\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x0b\x05\x12\x04\x9e\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\
    \x0b\x01\x12\x04\x9e\x01(4\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x0b\x03\
    \x12\x04\x9e\x0179\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x0c\x12\x04\x9f\
    \x01\x18:\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x0c\x04\x12\x04\x9f\x01\
    \x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x0c\x05\x12\x04\x9f\x01!'\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02\x0c\x01\x12\x04\x9f\x01(4\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x0c\x03\x12\x04\x9f\x0179\n\x10\n\x08\x04\x01\
    \x03\x01\x03\r\x02\r\x12\x04\xa0\x01\x188\n\x11\n\t\x04\x01\x03\x01\x03\
    \r\x02\r\x04\x12\x04\xa0\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\
    \r\x05\x12\x04\xa0\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\r\x01\x12\
    \x04\xa0\x01(2\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\r\x03\x12\x04\xa0\x01\
    57\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x0e\x12\x04\xa1\x01\x18=\n\x11\
    \n\t\x04\x01\x03\x01\x03\r\x02\x0e\x04\x12\x04\xa1\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x0e\x05\x12\x04\xa1\x01!'\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x0e\x01\x12\x04\xa1\x01(7\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x0e\x03\x12\x04\xa1\x01:<\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x0f\x12\x04\xa2\x01\x188\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x0f\
    \x04\x12\x04\xa2\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x0f\x05\
    \x12\x04\xa2\x01!&\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x0f\x01\x12\x04\
    \xa2\x01'2\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x0f\x03\x12\x04\xa2\x0157\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x10\x12\x04\xa3\x01\x187\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x10\x04\x12\x04\xa3\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x10\x05\x12\x04\xa3\x01!&\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x10\x01\x12\x04\xa3\x01'1\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x10\x03\x12\x04\xa3\x0146\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x11\x12\x04\xa4\x01\x18:\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x11\
    \x04\x12\x04\xa4\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x11\x05\
    \x12\x04\xa4\x01!&\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x11\x01\x12\x04\
    \xa4\x01'4\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x11\x03\x12\x04\xa4\x0179\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x12\x12\x04\xa5\x01\x187\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x12\x04\x12\x04\xa5\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x12\x05\x12\x04\xa5\x01!&\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x12\x01\x12\x04\xa5\x01'1\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x12\x03\x12\x04\xa5\x0146\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x13\x12\x04\xa6\x01\x18<\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x13\
    \x04\x12\x04\xa6\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x13\x05\
    \x12\x04\xa6\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x13\x01\x12\x04\
    \xa6\x01(6\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x13\x03\x12\x04\xa6\x019;\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x14\x12\x04\xa7\x01\x18<\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x14\x04\x12\x04\xa7\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x14\x05\x12\x04\xa7\x01!&\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x14\x01\x12\x04\xa7\x01'6\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x14\x03\x12\x04\xa7\x019;\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x15\x12\x04\xa8\x01\x18c\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x15\
    \x04\x12\x04\xa8\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x15\x06\
    \x12\x04\xa8\x01!J\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x15\x01\x12\x04\
    \xa8\x01K]\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x15\x03\x12\x04\xa8\x01`b\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x16\x12\x04\xa9\x01\x18@\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x16\x04\x12\x04\xa9\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x16\x05\x12\x04\xa9\x01!%\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x16\x01\x12\x04\xa9\x01&:\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x16\x03\x12\x04\xa9\x01=?\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x17\x12\x04\xaa\x01\x18d\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x17\
    \x04\x12\x04\xaa\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x17\x06\
    \x12\x04\xaa\x01!J\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x17\x01\x12\x04\
    \xaa\x01K^\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x17\x03\x12\x04\xaa\x01ac\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x18\x12\x04\xab\x01\x18S\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x18\x04\x12\x04\xab\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x18\x06\x12\x04\xab\x01!B\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x18\x01\x12\x04\xab\x01CM\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x18\x03\x12\x04\xab\x01PR\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x19\x12\x04\xac\x01\x18f\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x19\
    \x04\x12\x04\xac\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x19\x06\
    \x12\x04\xac\x01!K\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x19\x01\x12\x04\
    \xac\x01L`\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x19\x03\x12\x04\xac\x01ce\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x1a\x12\x04\xad\x01\x185\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x1a\x04\x12\x04\xad\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x1a\x05\x12\x04\xad\x01!'\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x1a\x01\x12\x04\xad\x01(/\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x1a\x03\x12\x04\xad\x0124\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x1b\x12\x04\xae\x01\x18;\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1b\
    \x04\x12\x04\xae\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1b\x05\
    \x12\x04\xae\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1b\x01\x12\x04\
    \xae\x01(5\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1b\x03\x12\x04\xae\x018:\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x1c\x12\x04\xaf\x01\x18c\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x1c\x04\x12\x04\xaf\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x1c\x06\x12\x04\xaf\x01!J\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x1c\x01\x12\x04\xaf\x01K]\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x1c\x03\x12\x04\xaf\x01`b\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x1d\x12\x04\xb0\x01\x18B\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1d\
    \x04\x12\x04\xb0\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1d\x05\
    \x12\x04\xb0\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1d\x01\x12\x04\
    \xb0\x01(<\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1d\x03\x12\x04\xb0\x01?A\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x1e\x12\x04\xb1\x01\x186\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x1e\x04\x12\x04\xb1\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x1e\x05\x12\x04\xb1\x01!'\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x1e\x01\x12\x04\xb1\x01(0\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x1e\x03\x12\x04\xb1\x0135\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02\x1f\x12\x04\xb2\x01\x18:\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1f\
    \x04\x12\x04\xb2\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1f\x05\
    \x12\x04\xb2\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1f\x01\x12\x04\
    \xb2\x01(4\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\x1f\x03\x12\x04\xb2\x0179\
    \n\x10\n\x08\x04\x01\x03\x01\x03\r\x02\x20\x12\x04\xb3\x01\x18<\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02\x20\x04\x12\x04\xb3\x01\x18\x20\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02\x20\x05\x12\x04\xb3\x01!'\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02\x20\x01\x12\x04\xb3\x01(6\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\x20\x03\x12\x04\xb3\x019;\n\x10\n\x08\x04\x01\x03\x01\x03\r\
    \x02!\x12\x04\xb4\x01\x18?\n\x11\n\t\x04\x01\x03\x01\x03\r\x02!\x04\x12\
    \x04\xb4\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02!\x05\x12\x04\
    \xb4\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02!\x01\x12\x04\xb4\x01(9\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02!\x03\x12\x04\xb4\x01<>\n\x10\n\x08\
    \x04\x01\x03\x01\x03\r\x02\"\x12\x04\xb5\x01\x18=\n\x11\n\t\x04\x01\x03\
    \x01\x03\r\x02\"\x04\x12\x04\xb5\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02\"\x05\x12\x04\xb5\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\"\
    \x01\x12\x04\xb5\x01(7\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\"\x03\x12\x04\
    \xb5\x01:<\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02#\x12\x04\xb6\x01\x18<\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02#\x04\x12\x04\xb6\x01\x18\x20\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02#\x05\x12\x04\xb6\x01!'\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02#\x01\x12\x04\xb6\x01(6\n\x11\n\t\x04\x01\x03\x01\x03\
    \r\x02#\x03\x12\x04\xb6\x019;\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02$\x12\
    \x04\xb7\x01\x18@\n\x11\n\t\x04\x01\x03\x01\x03\r\x02$\x04\x12\x04\xb7\
    \x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02$\x05\x12\x04\xb7\x01!'\
    \n\x11\n\t\x04\x01\x03\x01\x03\r\x02$\x01\x12\x04\xb7\x01(:\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02$\x03\x12\x04\xb7\x01=?\n\x10\n\x08\x04\x01\
    \x03\x01\x03\r\x02%\x12\x04\xb8\x01\x18C\n\x11\n\t\x04\x01\x03\x01\x03\r\
    \x02%\x04\x12\x04\xb8\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02%\
    \x05\x12\x04\xb8\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02%\x01\x12\x04\
    \xb8\x01(=\n\x11\n\t\x04\x01\x03\x01\x03\r\x02%\x03\x12\x04\xb8\x01@B\n\
    \x10\n\x08\x04\x01\x03\x01\x03\r\x02&\x12\x04\xb9\x01\x18A\n\x11\n\t\x04\
    \x01\x03\x01\x03\r\x02&\x04\x12\x04\xb9\x01\x18\x20\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02&\x05\x12\x04\xb9\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\
    \r\x02&\x01\x12\x04\xb9\x01(;\n\x11\n\t\x04\x01\x03\x01\x03\r\x02&\x03\
    \x12\x04\xb9\x01>@\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02'\x12\x04\xba\
    \x01\x18<\n\x11\n\t\x04\x01\x03\x01\x03\r\x02'\x04\x12\x04\xba\x01\x18\
    \x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02'\x05\x12\x04\xba\x01!'\n\x11\n\
    \t\x04\x01\x03\x01\x03\r\x02'\x01\x12\x04\xba\x01(6\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02'\x03\x12\x04\xba\x019;\n\x10\n\x08\x04\x01\x03\x01\
    \x03\r\x02(\x12\x04\xbb\x01\x18:\n\x11\n\t\x04\x01\x03\x01\x03\r\x02(\
    \x04\x12\x04\xbb\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02(\x05\
    \x12\x04\xbb\x01!&\n\x11\n\t\x04\x01\x03\x01\x03\r\x02(\x01\x12\x04\xbb\
    \x01'4\n\x11\n\t\x04\x01\x03\x01\x03\r\x02(\x03\x12\x04\xbb\x0179\n\x10\
    \n\x08\x04\x01\x03\x01\x03\r\x02)\x12\x04\xbc\x01\x18L\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x02)\x04\x12\x04\xbc\x01\x18\x20\n\x11\n\t\x04\x01\x03\
    \x01\x03\r\x02)\x06\x12\x04\xbc\x01!2\n\x11\n\t\x04\x01\x03\x01\x03\r\
    \x02)\x01\x12\x04\xbc\x013F\n\x11\n\t\x04\x01\x03\x01\x03\r\x02)\x03\x12\
    \x04\xbc\x01IK\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02*\x12\x04\xbd\x01\
    \x18h\n\x11\n\t\x04\x01\x03\x01\x03\r\x02*\x04\x12\x04\xbd\x01\x18\x20\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02*\x06\x12\x04\xbd\x01!P\n\x11\n\t\x04\
    \x01\x03\x01\x03\r\x02*\x01\x12\x04\xbd\x01Qb\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02*\x03\x12\x04\xbd\x01eg\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02+\
    \x12\x04\xbe\x01\x187\n\x11\n\t\x04\x01\x03\x01\x03\r\x02+\x04\x12\x04\
    \xbe\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02+\x05\x12\x04\xbe\
    \x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\x02+\x01\x12\x04\xbe\x01(1\n\x11\
    \n\t\x04\x01\x03\x01\x03\r\x02+\x03\x12\x04\xbe\x0146\n\x10\n\x08\x04\
    \x01\x03\x01\x03\r\x02,\x12\x04\xbf\x01\x18>\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02,\x04\x12\x04\xbf\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\
    \x02,\x05\x12\x04\xbf\x01!&\n\x11\n\t\x04\x01\x03\x01\x03\r\x02,\x01\x12\
    \x04\xbf\x01'8\n\x11\n\t\x04\x01\x03\x01\x03\r\x02,\x03\x12\x04\xbf\x01;\
    =\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02-\x12\x04\xc0\x01\x18?\n\x11\n\t\
    \x04\x01\x03\x01\x03\r\x02-\x04\x12\x04\xc0\x01\x18\x20\n\x11\n\t\x04\
    \x01\x03\x01\x03\r\x02-\x06\x12\x04\xc0\x01!-\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x02-\x01\x12\x04\xc0\x01.9\n\x11\n\t\x04\x01\x03\x01\x03\r\x02-\
    \x03\x12\x04\xc0\x01<>\n\x10\n\x08\x04\x01\x03\x01\x03\r\x02.\x12\x04\
    \xc1\x01\x187\n\x11\n\t\x04\x01\x03\x01\x03\r\x02.\x04\x12\x04\xc1\x01\
    \x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02.\x05\x12\x04\xc1\x01!'\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x02.\x01\x12\x04\xc1\x01(1\n\x11\n\t\x04\
    \x01\x03\x01\x03\r\x02.\x03\x12\x04\xc1\x0146\n\x10\n\x08\x04\x01\x03\
    \x01\x03\r\x02/\x12\x04\xc2\x01\x18r\n\x11\n\t\x04\x01\x03\x01\x03\r\x02\
    /\x04\x12\x04\xc2\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x02/\x06\
    \x12\x04\xc2\x01!Q\n\x11\n\t\x04\x01\x03\x01\x03\r\x02/\x01\x12\x04\xc2\
    \x01Rl\n\x11\n\t\x04\x01\x03\x01\x03\r\x02/\x03\x12\x04\xc2\x01oq\n\x10\
    \n\x08\x04\x01\x03\x01\x03\r\x020\x12\x04\xc3\x01\x18I\n\x11\n\t\x04\x01\
    \x03\x01\x03\r\x020\x04\x12\x04\xc3\x01\x18\x20\n\x11\n\t\x04\x01\x03\
    \x01\x03\r\x020\x05\x12\x04\xc3\x01!'\n\x11\n\t\x04\x01\x03\x01\x03\r\
    \x020\x01\x12\x04\xc3\x01(C\n\x11\n\t\x04\x01\x03\x01\x03\r\x020\x03\x12\
    \x04\xc3\x01FH\n\x10\n\x08\x04\x01\x03\x01\x03\r\x021\x12\x04\xc4\x01\
    \x18K\n\x11\n\t\x04\x01\x03\x01\x03\r\x021\x04\x12\x04\xc4\x01\x18\x20\n\
    \x11\n\t\x04\x01\x03\x01\x03\r\x021\x05\x12\x04\xc4\x01!'\n\x11\n\t\x04\
    \x01\x03\x01\x03\r\x021\x01\x12\x04\xc4\x01(E\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x021\x03\x12\x04\xc4\x01HJ\n\x10\n\x08\x04\x01\x03\x01\x03\r\x022\
    \x12\x04\xc5\x01\x18V\n\x11\n\t\x04\x01\x03\x01\x03\r\x022\x04\x12\x04\
    \xc5\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\x022\x06\x12\x04\xc5\
    \x01!<\n\x11\n\t\x04\x01\x03\x01\x03\r\x022\x01\x12\x04\xc5\x01=P\n\x11\
    \n\t\x04\x01\x03\x01\x03\r\x022\x03\x12\x04\xc5\x01SU\n\x10\n\x08\x04\
    \x01\x03\x01\x03\r\x023\x12\x04\xc6\x01\x18;\n\x11\n\t\x04\x01\x03\x01\
    \x03\r\x023\x04\x12\x04\xc6\x01\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\r\
    \x023\x05\x12\x04\xc6\x01!&\n\x11\n\t\x04\x01\x03\x01\x03\r\x023\x01\x12\
    \x04\xc6\x01'5\n\x11\n\t\x04\x01\x03\x01\x03\r\x023\x03\x12\x04\xc6\x018\
    :\n\x0e\n\x06\x04\x01\x03\x01\x02\0\x12\x04\xc9\x01\x10.\n\x0f\n\x07\x04\
    \x01\x03\x01\x02\0\x04\x12\x04\xc9\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\
    \x01\x02\0\x05\x12\x04\xc9\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\x01\x02\0\
    \x01\x12\x04\xc9\x01\x20)\n\x0f\n\x07\x04\x01\x03\x01\x02\0\x03\x12\x04\
    \xc9\x01,-\n\x0e\n\x06\x04\x01\x03\x01\x02\x01\x12\x04\xca\x01\x10D\n\
    \x0f\n\x07\x04\x01\x03\x01\x02\x01\x04\x12\x04\xca\x01\x10\x18\n\x0f\n\
    \x07\x04\x01\x03\x01\x02\x01\x06\x12\x04\xca\x01\x197\n\x0f\n\x07\x04\
    \x01\x03\x01\x02\x01\x01\x12\x04\xca\x018?\n\x0f\n\x07\x04\x01\x03\x01\
    \x02\x01\x03\x12\x04\xca\x01BC\n\x0e\n\x06\x04\x01\x03\x01\x02\x02\x12\
    \x04\xcb\x01\x104\n\x0f\n\x07\x04\x01\x03\x01\x02\x02\x04\x12\x04\xcb\
    \x01\x10\x18\n\x0f\n\x07\x04\x01\x03\x01\x02\x02\x05\x12\x04\xcb\x01\x19\
    \x1e\n\x0f\n\x07\x04\x01\x03\x01\x02\x02\x01\x12\x04\xcb\x01\x1f/\n\x0f\
    \n\x07\x04\x01\x03\x01\x02\x02\x03\x12\x04\xcb\x0123\n\x0e\n\x06\x04\x01\
    \x03\x01\x02\x03\x12\x04\xcc\x01\x105\n\x0f\n\x07\x04\x01\x03\x01\x02\
    \x03\x04\x12\x04\xcc\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\x01\x02\x03\x05\
    \x12\x04\xcc\x01\x19\x1e\n\x0f\n\x07\x04\x01\x03\x01\x02\x03\x01\x12\x04\
    \xcc\x01\x1f0\n\x0f\n\x07\x04\x01\x03\x01\x02\x03\x03\x12\x04\xcc\x0134\
    \n\x0e\n\x06\x04\x01\x03\x01\x02\x04\x12\x04\xcd\x01\x103\n\x0f\n\x07\
    \x04\x01\x03\x01\x02\x04\x04\x12\x04\xcd\x01\x10\x18\n\x0f\n\x07\x04\x01\
    \x03\x01\x02\x04\x05\x12\x04\xcd\x01\x19\x1e\n\x0f\n\x07\x04\x01\x03\x01\
    \x02\x04\x01\x12\x04\xcd\x01\x1f.\n\x0f\n\x07\x04\x01\x03\x01\x02\x04\
    \x03\x12\x04\xcd\x0112\n\x0e\n\x06\x04\x01\x03\x01\x02\x05\x12\x04\xce\
    \x01\x100\n\x0f\n\x07\x04\x01\x03\x01\x02\x05\x04\x12\x04\xce\x01\x10\
    \x18\n\x0f\n\x07\x04\x01\x03\x01\x02\x05\x05\x12\x04\xce\x01\x19\x1d\n\
    \x0f\n\x07\x04\x01\x03\x01\x02\x05\x01\x12\x04\xce\x01\x1e+\n\x0f\n\x07\
    \x04\x01\x03\x01\x02\x05\x03\x12\x04\xce\x01./\n\x0e\n\x06\x04\x01\x03\
    \x01\x02\x06\x12\x04\xcf\x01\x108\n\x0f\n\x07\x04\x01\x03\x01\x02\x06\
    \x04\x12\x04\xcf\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\x01\x02\x06\x05\x12\
    \x04\xcf\x01\x19\x1e\n\x0f\n\x07\x04\x01\x03\x01\x02\x06\x01\x12\x04\xcf\
    \x01\x1f3\n\x0f\n\x07\x04\x01\x03\x01\x02\x06\x03\x12\x04\xcf\x0167\n\
    \x0e\n\x06\x04\x01\x03\x01\x02\x07\x12\x04\xd0\x01\x100\n\x0f\n\x07\x04\
    \x01\x03\x01\x02\x07\x04\x12\x04\xd0\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\
    \x01\x02\x07\x05\x12\x04\xd0\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\x01\x02\
    \x07\x01\x12\x04\xd0\x01\x20*\n\x0f\n\x07\x04\x01\x03\x01\x02\x07\x03\
    \x12\x04\xd0\x01-/\n\x0e\n\x04\x04\x01\x03\x02\x12\x06\xd3\x01\x08\xe1\
    \x01\t\n\r\n\x05\x04\x01\x03\x02\x01\x12\x04\xd3\x01\x10&\n\x10\n\x06\
    \x04\x01\x03\x02\x03\0\x12\x06\xd4\x01\x10\xd7\x01\x11\n\x0f\n\x07\x04\
    \x01\x03\x02\x03\0\x01\x12\x04\xd4\x01\x18*\n\x10\n\x08\x04\x01\x03\x02\
    \x03\0\x02\0\x12\x04\xd5\x01\x185\n\x11\n\t\x04\x01\x03\x02\x03\0\x02\0\
    \x04\x12\x04\xd5\x01\x18\x20\n\x11\n\t\x04\x01\x03\x02\x03\0\x02\0\x05\
    \x12\x04\xd5\x01!'\n\x11\n\t\x04\x01\x03\x02\x03\0\x02\0\x01\x12\x04\xd5\
    \x01(0\n\x11\n\t\x04\x01\x03\x02\x03\0\x02\0\x03\x12\x04\xd5\x0134\n\x10\
    \n\x08\x04\x01\x03\x02\x03\0\x02\x01\x12\x04\xd6\x01\x188\n\x11\n\t\x04\
    \x01\x03\x02\x03\0\x02\x01\x04\x12\x04\xd6\x01\x18\x20\n\x11\n\t\x04\x01\
    \x03\x02\x03\0\x02\x01\x05\x12\x04\xd6\x01!'\n\x11\n\t\x04\x01\x03\x02\
    \x03\0\x02\x01\x01\x12\x04\xd6\x01(3\n\x11\n\t\x04\x01\x03\x02\x03\0\x02\
    \x01\x03\x12\x04\xd6\x0167\n\x0e\n\x06\x04\x01\x03\x02\x02\0\x12\x04\xd9\
    \x01\x10-\n\x0f\n\x07\x04\x01\x03\x02\x02\0\x04\x12\x04\xd9\x01\x10\x18\
    \n\x0f\n\x07\x04\x01\x03\x02\x02\0\x05\x12\x04\xd9\x01\x19\x1f\n\x0f\n\
    \x07\x04\x01\x03\x02\x02\0\x01\x12\x04\xd9\x01\x20(\n\x0f\n\x07\x04\x01\
    \x03\x02\x02\0\x03\x12\x04\xd9\x01+,\n\x0e\n\x06\x04\x01\x03\x02\x02\x01\
    \x12\x04\xda\x01\x10-\n\x0f\n\x07\x04\x01\x03\x02\x02\x01\x04\x12\x04\
    \xda\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\x02\x02\x01\x06\x12\x04\xda\x01\
    \x19\x1f\n\x0f\n\x07\x04\x01\x03\x02\x02\x01\x01\x12\x04\xda\x01\x20(\n\
    \x0f\n\x07\x04\x01\x03\x02\x02\x01\x03\x12\x04\xda\x01+,\n\x0e\n\x06\x04\
    \x01\x03\x02\x02\x02\x12\x04\xdb\x01\x10:\n\x0f\n\x07\x04\x01\x03\x02\
    \x02\x02\x04\x12\x04\xdb\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\x02\x02\x02\
    \x05\x12\x04\xdb\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\x02\x02\x02\x01\x12\
    \x04\xdb\x01\x205\n\x0f\n\x07\x04\x01\x03\x02\x02\x02\x03\x12\x04\xdb\
    \x0189\n\x0e\n\x06\x04\x01\x03\x02\x02\x03\x12\x04\xdc\x01\x108\n\x0f\n\
    \x07\x04\x01\x03\x02\x02\x03\x04\x12\x04\xdc\x01\x10\x18\n\x0f\n\x07\x04\
    \x01\x03\x02\x02\x03\x05\x12\x04\xdc\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\
    \x02\x02\x03\x01\x12\x04\xdc\x01\x203\n\x0f\n\x07\x04\x01\x03\x02\x02\
    \x03\x03\x12\x04\xdc\x0167\n\x0e\n\x06\x04\x01\x03\x02\x02\x04\x12\x04\
    \xdd\x01\x108\n\x0f\n\x07\x04\x01\x03\x02\x02\x04\x04\x12\x04\xdd\x01\
    \x10\x18\n\x0f\n\x07\x04\x01\x03\x02\x02\x04\x05\x12\x04\xdd\x01\x19\x1f\
    \n\x0f\n\x07\x04\x01\x03\x02\x02\x04\x01\x12\x04\xdd\x01\x203\n\x0f\n\
    \x07\x04\x01\x03\x02\x02\x04\x03\x12\x04\xdd\x0167\n\x0e\n\x06\x04\x01\
    \x03\x02\x02\x05\x12\x04\xde\x01\x10@\n\x0f\n\x07\x04\x01\x03\x02\x02\
    \x05\x04\x12\x04\xde\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\x02\x02\x05\x05\
    \x12\x04\xde\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\x02\x02\x05\x01\x12\x04\
    \xde\x01\x20;\n\x0f\n\x07\x04\x01\x03\x02\x02\x05\x03\x12\x04\xde\x01>?\
    \n\x0e\n\x06\x04\x01\x03\x02\x02\x06\x12\x04\xdf\x01\x10C\n\x0f\n\x07\
    \x04\x01\x03\x02\x02\x06\x04\x12\x04\xdf\x01\x10\x18\n\x0f\n\x07\x04\x01\
    \x03\x02\x02\x06\x05\x12\x04\xdf\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\x02\
    \x02\x06\x01\x12\x04\xdf\x01\x20>\n\x0f\n\x07\x04\x01\x03\x02\x02\x06\
    \x03\x12\x04\xdf\x01AB\n\x0e\n\x06\x04\x01\x03\x02\x02\x07\x12\x04\xe0\
    \x01\x10n\n\x0f\n\x07\x04\x01\x03\x02\x02\x07\x04\x12\x04\xe0\x01\x10\
    \x18\n\x0f\n\x07\x04\x01\x03\x02\x02\x07\x06\x12\x04\xe0\x01\x19U\n\x0f\
    \n\x07\x04\x01\x03\x02\x02\x07\x01\x12\x04\xe0\x01Vi\n\x0f\n\x07\x04\x01\
    \x03\x02\x02\x07\x03\x12\x04\xe0\x01lm\n\x0e\n\x04\x04\x01\x03\x03\x12\
    \x06\xe3\x01\x08\xe8\x01\t\n\r\n\x05\x04\x01\x03\x03\x01\x12\x04\xe3\x01\
    \x10\x13\n\x0e\n\x06\x04\x01\x03\x03\x02\0\x12\x04\xe4\x01\x107\n\x0f\n\
    \x07\x04\x01\x03\x03\x02\0\x04\x12\x04\xe4\x01\x10\x18\n\x0f\n\x07\x04\
    \x01\x03\x03\x02\0\x05\x12\x04\xe4\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\
    \x03\x02\0\x01\x12\x04\xe4\x01\x202\n\x0f\n\x07\x04\x01\x03\x03\x02\0\
    \x03\x12\x04\xe4\x0156\n\x0e\n\x06\x04\x01\x03\x03\x02\x01\x12\x04\xe5\
    \x01\x107\n\x0f\n\x07\x04\x01\x03\x03\x02\x01\x04\x12\x04\xe5\x01\x10\
    \x18\n\x0f\n\x07\x04\x01\x03\x03\x02\x01\x05\x12\x04\xe5\x01\x19\x1f\n\
    \x0f\n\x07\x04\x01\x03\x03\x02\x01\x01\x12\x04\xe5\x01\x202\n\x0f\n\x07\
    \x04\x01\x03\x03\x02\x01\x03\x12\x04\xe5\x0156\n\x0e\n\x06\x04\x01\x03\
    \x03\x02\x02\x12\x04\xe6\x01\x10/\n\x0f\n\x07\x04\x01\x03\x03\x02\x02\
    \x04\x12\x04\xe6\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\x03\x02\x02\x05\x12\
    \x04\xe6\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\x03\x02\x02\x01\x12\x04\xe6\
    \x01\x20*\n\x0f\n\x07\x04\x01\x03\x03\x02\x02\x03\x12\x04\xe6\x01-.\n\
    \x0e\n\x06\x04\x01\x03\x03\x02\x03\x12\x04\xe7\x01\x10-\n\x0f\n\x07\x04\
    \x01\x03\x03\x02\x03\x04\x12\x04\xe7\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\
    \x03\x02\x03\x06\x12\x04\xe7\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\x03\x02\
    \x03\x01\x12\x04\xe7\x01\x20(\n\x0f\n\x07\x04\x01\x03\x03\x02\x03\x03\
    \x12\x04\xe7\x01+,\n\x0c\n\x04\x04\x01\x02\0\x12\x04\xea\x01\x083\n\r\n\
    \x05\x04\x01\x02\0\x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\x01\x02\0\
    \x06\x12\x04\xea\x01\x11(\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xea\x01).\
    \n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xea\x0112\n\x0c\n\x04\x04\x01\x02\
    \x01\x12\x04\xeb\x01\x08&\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\xeb\x01\
    \x08\x10\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\xeb\x01\x11\x18\n\r\n\x05\
    \x04\x01\x02\x01\x01\x12\x04\xeb\x01\x19!\n\r\n\x05\x04\x01\x02\x01\x03\
    \x12\x04\xeb\x01$%\n\x0c\n\x04\x04\x01\x02\x02\x12\x04\xec\x01\x08/\n\r\
    \n\x05\x04\x01\x02\x02\x04\x12\x04\xec\x01\x08\x10\n\r\n\x05\x04\x01\x02\
    \x02\x05\x12\x04\xec\x01\x11\x18\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\
    \xec\x01\x19*\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xec\x01-.\n\x0c\n\
    \x04\x04\x01\x02\x03\x12\x04\xed\x01\x083\n\r\n\x05\x04\x01\x02\x03\x04\
    \x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\x01\x02\x03\x05\x12\x04\xed\x01\
    \x11\x16\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\xed\x01\x17.\n\r\n\x05\
    \x04\x01\x02\x03\x03\x12\x04\xed\x0112\n\x0c\n\x04\x04\x01\x02\x04\x12\
    \x04\xee\x01\x08-\n\r\n\x05\x04\x01\x02\x04\x04\x12\x04\xee\x01\x08\x10\
    \n\r\n\x05\x04\x01\x02\x04\x05\x12\x04\xee\x01\x11\x17\n\r\n\x05\x04\x01\
    \x02\x04\x01\x12\x04\xee\x01\x18(\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\
    \xee\x01+,\n\x0c\n\x04\x04\x01\x02\x05\x12\x04\xef\x01\x08A\n\r\n\x05\
    \x04\x01\x02\x05\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\x01\x02\x05\
    \x06\x12\x04\xef\x01\x11*\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\xef\x01+\
    <\n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\xef\x01?@\n\x0c\n\x04\x04\x01\
    \x02\x06\x12\x04\xf0\x01\x08'\n\r\n\x05\x04\x01\x02\x06\x04\x12\x04\xf0\
    \x01\x08\x10\n\r\n\x05\x04\x01\x02\x06\x06\x12\x04\xf0\x01\x11\x19\n\r\n\
    \x05\x04\x01\x02\x06\x01\x12\x04\xf0\x01\x1a\"\n\r\n\x05\x04\x01\x02\x06\
    \x03\x12\x04\xf0\x01%&\n\x0c\n\x04\x04\x01\x02\x07\x12\x04\xf1\x01\x08Y\
    \n\r\n\x05\x04\x01\x02\x07\x04\x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04\x01\
    \x02\x07\x06\x12\x04\xf1\x01\x11:\n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\
    \xf1\x01;S\n\r\n\x05\x04\x01\x02\x07\x03\x12\x04\xf1\x01VX\n\x0c\n\x04\
    \x04\x01\x02\x08\x12\x04\xf2\x01\x083\n\r\n\x05\x04\x01\x02\x08\x04\x12\
    \x04\xf2\x01\x08\x10\n\r\n\x05\x04\x01\x02\x08\x05\x12\x04\xf2\x01\x11\
    \x16\n\r\n\x05\x04\x01\x02\x08\x01\x12\x04\xf2\x01\x17-\n\r\n\x05\x04\
    \x01\x02\x08\x03\x12\x04\xf2\x0102\n\x0c\n\x04\x04\x01\x02\t\x12\x04\xf3\
    \x01\x088\n\r\n\x05\x04\x01\x02\t\x04\x12\x04\xf3\x01\x08\x10\n\r\n\x05\
    \x04\x01\x02\t\x06\x12\x04\xf3\x01\x11'\n\r\n\x05\x04\x01\x02\t\x01\x12\
    \x04\xf3\x01(2\n\r\n\x05\x04\x01\x02\t\x03\x12\x04\xf3\x0157\n\x0c\n\x02\
    \x04\x02\x12\x06\xf6\x01\0\xd9\x02\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\
    \xf6\x01\x08!\n\x0e\n\x04\x04\x02\x03\0\x12\x06\xf7\x01\x08\xfa\x01\t\n\
    \r\n\x05\x04\x02\x03\0\x01\x12\x04\xf7\x01\x10\x1a\n\x0e\n\x06\x04\x02\
    \x03\0\x02\0\x12\x04\xf8\x01\x10'\n\x0f\n\x07\x04\x02\x03\0\x02\0\x04\
    \x12\x04\xf8\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\0\x02\0\x05\x12\x04\xf8\
    \x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\0\x02\0\x01\x12\x04\xf8\x01\x20\"\n\
    \x0f\n\x07\x04\x02\x03\0\x02\0\x03\x12\x04\xf8\x01%&\n\x0e\n\x06\x04\x02\
    \x03\0\x02\x01\x12\x04\xf9\x01\x10)\n\x0f\n\x07\x04\x02\x03\0\x02\x01\
    \x04\x12\x04\xf9\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x05\x12\
    \x04\xf9\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x04\xf9\
    \x01\x20$\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x04\xf9\x01'(\n\x0e\
    \n\x04\x04\x02\x03\x01\x12\x06\xfc\x01\x08\xd4\x02\t\n\r\n\x05\x04\x02\
    \x03\x01\x01\x12\x04\xfc\x01\x10\x14\n\x10\n\x06\x04\x02\x03\x01\x03\0\
    \x12\x06\xfd\x01\x10\xc8\x02\x11\n\x0f\n\x07\x04\x02\x03\x01\x03\0\x01\
    \x12\x04\xfd\x01\x18\x1e\n\x12\n\x08\x04\x02\x03\x01\x03\0\x03\0\x12\x06\
    \xfe\x01\x18\x98\x02\x19\n\x11\n\t\x04\x02\x03\x01\x03\0\x03\0\x01\x12\
    \x04\xfe\x01\x20-\n\x14\n\n\x04\x02\x03\x01\x03\0\x03\0\x03\0\x12\x06\
    \xff\x01\x20\x88\x02!\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\0\x03\0\x01\
    \x12\x04\xff\x01(7\n\x16\n\x0c\x04\x02\x03\x01\x03\0\x03\0\x03\0\x03\0\
    \x12\x06\x80\x02(\x83\x02)\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\0\
    \x03\0\x01\x12\x04\x80\x020<\n\x16\n\x0e\x04\x02\x03\x01\x03\0\x03\0\x03\
    \0\x03\0\x02\0\x12\x04\x81\x020L\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\
    \x03\0\x03\0\x02\0\x04\x12\x04\x81\x0208\n\x17\n\x0f\x04\x02\x03\x01\x03\
    \0\x03\0\x03\0\x03\0\x02\0\x05\x12\x04\x81\x029?\n\x17\n\x0f\x04\x02\x03\
    \x01\x03\0\x03\0\x03\0\x03\0\x02\0\x01\x12\x04\x81\x02@G\n\x17\n\x0f\x04\
    \x02\x03\x01\x03\0\x03\0\x03\0\x03\0\x02\0\x03\x12\x04\x81\x02JK\n\x16\n\
    \x0e\x04\x02\x03\x01\x03\0\x03\0\x03\0\x03\0\x02\x01\x12\x04\x82\x020K\n\
    \x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\0\x03\0\x02\x01\x04\x12\x04\
    \x82\x0208\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\0\x03\0\x02\x01\
    \x05\x12\x04\x82\x029?\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\0\x03\
    \0\x02\x01\x01\x12\x04\x82\x02@F\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\
    \x03\0\x03\0\x02\x01\x03\x12\x04\x82\x02IJ\n\x14\n\x0c\x04\x02\x03\x01\
    \x03\0\x03\0\x03\0\x02\0\x12\x04\x85\x02(N\n\x15\n\r\x04\x02\x03\x01\x03\
    \0\x03\0\x03\0\x02\0\x04\x12\x04\x85\x02(0\n\x15\n\r\x04\x02\x03\x01\x03\
    \0\x03\0\x03\0\x02\0\x05\x12\x04\x85\x0217\n\x15\n\r\x04\x02\x03\x01\x03\
    \0\x03\0\x03\0\x02\0\x01\x12\x04\x85\x028I\n\x15\n\r\x04\x02\x03\x01\x03\
    \0\x03\0\x03\0\x02\0\x03\x12\x04\x85\x02LM\n\x14\n\x0c\x04\x02\x03\x01\
    \x03\0\x03\0\x03\0\x02\x01\x12\x04\x86\x02(F\n\x15\n\r\x04\x02\x03\x01\
    \x03\0\x03\0\x03\0\x02\x01\x04\x12\x04\x86\x02(0\n\x15\n\r\x04\x02\x03\
    \x01\x03\0\x03\0\x03\0\x02\x01\x05\x12\x04\x86\x0216\n\x15\n\r\x04\x02\
    \x03\x01\x03\0\x03\0\x03\0\x02\x01\x01\x12\x04\x86\x027A\n\x15\n\r\x04\
    \x02\x03\x01\x03\0\x03\0\x03\0\x02\x01\x03\x12\x04\x86\x02DE\n\x15\n\x0c\
    \x04\x02\x03\x01\x03\0\x03\0\x03\0\x02\x02\x12\x05\x87\x02(\x96\x01\n\
    \x15\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\0\x02\x02\x04\x12\x04\x87\x02(0\
    \n\x16\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\0\x02\x02\x06\x12\x05\x87\x02\
    1\x81\x01\n\x17\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\0\x02\x02\x01\x12\
    \x06\x87\x02\x82\x01\x91\x01\n\x17\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\0\
    \x02\x02\x03\x12\x06\x87\x02\x94\x01\x95\x01\n\x14\n\n\x04\x02\x03\x01\
    \x03\0\x03\0\x03\x01\x12\x06\x8a\x02\x20\x93\x02!\n\x13\n\x0b\x04\x02\
    \x03\x01\x03\0\x03\0\x03\x01\x01\x12\x04\x8a\x02(8\n\x16\n\x0c\x04\x02\
    \x03\x01\x03\0\x03\0\x03\x01\x03\0\x12\x06\x8b\x02(\x8e\x02)\n\x15\n\r\
    \x04\x02\x03\x01\x03\0\x03\0\x03\x01\x03\0\x01\x12\x04\x8b\x020<\n\x16\n\
    \x0e\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x03\0\x02\0\x12\x04\x8c\x020L\n\
    \x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x03\0\x02\0\x04\x12\x04\
    \x8c\x0208\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x03\0\x02\0\
    \x05\x12\x04\x8c\x029?\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\x01\
    \x03\0\x02\0\x01\x12\x04\x8c\x02@G\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\
    \0\x03\x01\x03\0\x02\0\x03\x12\x04\x8c\x02JK\n\x16\n\x0e\x04\x02\x03\x01\
    \x03\0\x03\0\x03\x01\x03\0\x02\x01\x12\x04\x8d\x020L\n\x17\n\x0f\x04\x02\
    \x03\x01\x03\0\x03\0\x03\x01\x03\0\x02\x01\x04\x12\x04\x8d\x0208\n\x17\n\
    \x0f\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x03\0\x02\x01\x05\x12\x04\x8d\
    \x029?\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x03\0\x02\x01\x01\
    \x12\x04\x8d\x02@G\n\x17\n\x0f\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x03\0\
    \x02\x01\x03\x12\x04\x8d\x02JK\n\x14\n\x0c\x04\x02\x03\x01\x03\0\x03\0\
    \x03\x01\x02\0\x12\x04\x90\x02(N\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\0\
    \x03\x01\x02\0\x04\x12\x04\x90\x02(0\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\
    \0\x03\x01\x02\0\x05\x12\x04\x90\x0217\n\x15\n\r\x04\x02\x03\x01\x03\0\
    \x03\0\x03\x01\x02\0\x01\x12\x04\x90\x028I\n\x15\n\r\x04\x02\x03\x01\x03\
    \0\x03\0\x03\x01\x02\0\x03\x12\x04\x90\x02LM\n\x14\n\x0c\x04\x02\x03\x01\
    \x03\0\x03\0\x03\x01\x02\x01\x12\x04\x91\x02(F\n\x15\n\r\x04\x02\x03\x01\
    \x03\0\x03\0\x03\x01\x02\x01\x04\x12\x04\x91\x02(0\n\x15\n\r\x04\x02\x03\
    \x01\x03\0\x03\0\x03\x01\x02\x01\x05\x12\x04\x91\x0216\n\x15\n\r\x04\x02\
    \x03\x01\x03\0\x03\0\x03\x01\x02\x01\x01\x12\x04\x91\x027A\n\x15\n\r\x04\
    \x02\x03\x01\x03\0\x03\0\x03\x01\x02\x01\x03\x12\x04\x91\x02DE\n\x15\n\
    \x0c\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x02\x02\x12\x05\x92\x02(\x97\
    \x01\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x02\x02\x04\x12\x04\
    \x92\x02(0\n\x16\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x02\x02\x06\x12\
    \x05\x92\x021\x82\x01\n\x17\n\r\x04\x02\x03\x01\x03\0\x03\0\x03\x01\x02\
    \x02\x01\x12\x06\x92\x02\x83\x01\x92\x01\n\x17\n\r\x04\x02\x03\x01\x03\0\
    \x03\0\x03\x01\x02\x02\x03\x12\x06\x92\x02\x95\x01\x96\x01\n\x12\n\n\x04\
    \x02\x03\x01\x03\0\x03\0\x02\0\x12\x04\x95\x02\x20=\n\x13\n\x0b\x04\x02\
    \x03\x01\x03\0\x03\0\x02\0\x04\x12\x04\x95\x02\x20(\n\x13\n\x0b\x04\x02\
    \x03\x01\x03\0\x03\0\x02\0\x05\x12\x04\x95\x02).\n\x13\n\x0b\x04\x02\x03\
    \x01\x03\0\x03\0\x02\0\x01\x12\x04\x95\x02/8\n\x13\n\x0b\x04\x02\x03\x01\
    \x03\0\x03\0\x02\0\x03\x12\x04\x95\x02;<\n\x13\n\n\x04\x02\x03\x01\x03\0\
    \x03\0\x02\x01\x12\x05\x96\x02\x20\x83\x01\n\x13\n\x0b\x04\x02\x03\x01\
    \x03\0\x03\0\x02\x01\x04\x12\x04\x96\x02\x20(\n\x13\n\x0b\x04\x02\x03\
    \x01\x03\0\x03\0\x02\x01\x06\x12\x04\x96\x02)l\n\x13\n\x0b\x04\x02\x03\
    \x01\x03\0\x03\0\x02\x01\x01\x12\x04\x96\x02m~\n\x15\n\x0b\x04\x02\x03\
    \x01\x03\0\x03\0\x02\x01\x03\x12\x06\x96\x02\x81\x01\x82\x01\n\x13\n\n\
    \x04\x02\x03\x01\x03\0\x03\0\x02\x02\x12\x05\x97\x02\x20\x85\x01\n\x13\n\
    \x0b\x04\x02\x03\x01\x03\0\x03\0\x02\x02\x04\x12\x04\x97\x02\x20(\n\x13\
    \n\x0b\x04\x02\x03\x01\x03\0\x03\0\x02\x02\x06\x12\x04\x97\x02)m\n\x14\n\
    \x0b\x04\x02\x03\x01\x03\0\x03\0\x02\x02\x01\x12\x05\x97\x02n\x80\x01\n\
    \x15\n\x0b\x04\x02\x03\x01\x03\0\x03\0\x02\x02\x03\x12\x06\x97\x02\x83\
    \x01\x84\x01\n\x12\n\x08\x04\x02\x03\x01\x03\0\x03\x01\x12\x06\x9a\x02\
    \x18\xa4\x02\x19\n\x11\n\t\x04\x02\x03\x01\x03\0\x03\x01\x01\x12\x04\x9a\
    \x02\x20*\n\x14\n\n\x04\x02\x03\x01\x03\0\x03\x01\x03\0\x12\x06\x9b\x02\
    \x20\x9f\x02!\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x03\0\x01\x12\
    \x04\x9b\x02(4\n\x14\n\x0c\x04\x02\x03\x01\x03\0\x03\x01\x03\0\x02\0\x12\
    \x04\x9c\x02(D\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\x01\x03\0\x02\0\x04\
    \x12\x04\x9c\x02(0\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\x01\x03\0\x02\0\
    \x05\x12\x04\x9c\x0217\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\x01\x03\0\x02\
    \0\x01\x12\x04\x9c\x028?\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\x01\x03\0\
    \x02\0\x03\x12\x04\x9c\x02BC\n\x14\n\x0c\x04\x02\x03\x01\x03\0\x03\x01\
    \x03\0\x02\x01\x12\x04\x9d\x02(L\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\x01\
    \x03\0\x02\x01\x04\x12\x04\x9d\x02(0\n\x15\n\r\x04\x02\x03\x01\x03\0\x03\
    \x01\x03\0\x02\x01\x05\x12\x04\x9d\x0216\n\x15\n\r\x04\x02\x03\x01\x03\0\
    \x03\x01\x03\0\x02\x01\x01\x12\x04\x9d\x027G\n\x15\n\r\x04\x02\x03\x01\
    \x03\0\x03\x01\x03\0\x02\x01\x03\x12\x04\x9d\x02JK\n\x14\n\x0c\x04\x02\
    \x03\x01\x03\0\x03\x01\x03\0\x02\x02\x12\x04\x9e\x02(D\n\x15\n\r\x04\x02\
    \x03\x01\x03\0\x03\x01\x03\0\x02\x02\x04\x12\x04\x9e\x02(0\n\x15\n\r\x04\
    \x02\x03\x01\x03\0\x03\x01\x03\0\x02\x02\x05\x12\x04\x9e\x0215\n\x15\n\r\
    \x04\x02\x03\x01\x03\0\x03\x01\x03\0\x02\x02\x01\x12\x04\x9e\x026?\n\x15\
    \n\r\x04\x02\x03\x01\x03\0\x03\x01\x03\0\x02\x02\x03\x12\x04\x9e\x02BC\n\
    \x12\n\n\x04\x02\x03\x01\x03\0\x03\x01\x02\0\x12\x04\xa1\x02\x20C\n\x13\
    \n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\0\x04\x12\x04\xa1\x02\x20(\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\0\x05\x12\x04\xa1\x02).\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\0\x01\x12\x04\xa1\x02/>\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\0\x03\x12\x04\xa1\x02AB\n\
    \x12\n\n\x04\x02\x03\x01\x03\0\x03\x01\x02\x01\x12\x04\xa2\x02\x20G\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x01\x04\x12\x04\xa2\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x01\x05\x12\x04\xa2\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x01\x01\x12\x04\xa2\x020\
    B\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x01\x03\x12\x04\xa2\x02E\
    F\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x01\x02\x02\x12\x04\xa3\x02\x20{\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x02\x04\x12\x04\xa3\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x02\x06\x12\x04\xa3\x02)\
    f\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x02\x01\x12\x04\xa3\x02g\
    v\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x01\x02\x02\x03\x12\x04\xa3\x02y\
    z\n\x12\n\x08\x04\x02\x03\x01\x03\0\x03\x02\x12\x06\xa6\x02\x18\xaf\x02\
    \x19\n\x11\n\t\x04\x02\x03\x01\x03\0\x03\x02\x01\x12\x04\xa6\x02\x20,\n\
    \x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\0\x12\x04\xa7\x02\x20:\n\x13\
    \n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\0\x04\x12\x04\xa7\x02\x20(\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\0\x05\x12\x04\xa7\x02)/\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\0\x01\x12\x04\xa7\x0205\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\0\x03\x12\x04\xa7\x0289\n\
    \x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\x01\x12\x04\xa8\x02\x20;\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x01\x04\x12\x04\xa8\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x01\x05\x12\x04\xa8\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x01\x01\x12\x04\xa8\x020\
    6\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x01\x03\x12\x04\xa8\x029\
    :\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\x02\x12\x04\xa9\x02\x20A\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x02\x04\x12\x04\xa9\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x02\x05\x12\x04\xa9\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x02\x01\x12\x04\xa9\x020\
    <\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x02\x03\x12\x04\xa9\x02?\
    @\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\x03\x12\x04\xaa\x02\x20<\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x03\x04\x12\x04\xaa\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x03\x05\x12\x04\xaa\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x03\x01\x12\x04\xaa\x020\
    7\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x03\x03\x12\x04\xaa\x02:\
    ;\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\x04\x12\x04\xab\x02\x20>\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x04\x04\x12\x04\xab\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x04\x05\x12\x04\xab\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x04\x01\x12\x04\xab\x020\
    9\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x04\x03\x12\x04\xab\x02<\
    =\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\x05\x12\x04\xac\x02\x20>\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x05\x04\x12\x04\xac\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x05\x05\x12\x04\xac\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x05\x01\x12\x04\xac\x020\
    9\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x05\x03\x12\x04\xac\x02<\
    =\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\x06\x12\x04\xad\x02\x20:\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x06\x04\x12\x04\xad\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x06\x05\x12\x04\xad\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x06\x01\x12\x04\xad\x020\
    5\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x06\x03\x12\x04\xad\x028\
    9\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x02\x02\x07\x12\x04\xae\x02\x20:\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x07\x04\x12\x04\xae\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x07\x05\x12\x04\xae\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x07\x01\x12\x04\xae\x020\
    5\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x02\x02\x07\x03\x12\x04\xae\x028\
    9\n\x12\n\x08\x04\x02\x03\x01\x03\0\x03\x03\x12\x06\xb1\x02\x18\xb8\x02\
    \x19\n\x11\n\t\x04\x02\x03\x01\x03\0\x03\x03\x01\x12\x04\xb1\x02\x20*\n\
    \x12\n\n\x04\x02\x03\x01\x03\0\x03\x03\x02\0\x12\x04\xb2\x02\x20:\n\x13\
    \n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\0\x04\x12\x04\xb2\x02\x20(\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\0\x05\x12\x04\xb2\x02)/\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\0\x01\x12\x04\xb2\x0205\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\0\x03\x12\x04\xb2\x0289\n\
    \x12\n\n\x04\x02\x03\x01\x03\0\x03\x03\x02\x01\x12\x04\xb3\x02\x20;\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x01\x04\x12\x04\xb3\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x01\x05\x12\x04\xb3\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x01\x01\x12\x04\xb3\x020\
    6\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x01\x03\x12\x04\xb3\x029\
    :\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x03\x02\x02\x12\x04\xb4\x02\x20;\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x02\x04\x12\x04\xb4\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x02\x05\x12\x04\xb4\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x02\x01\x12\x04\xb4\x020\
    6\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x02\x03\x12\x04\xb4\x029\
    :\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x03\x02\x03\x12\x04\xb5\x02\x20F\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x03\x04\x12\x04\xb5\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x03\x05\x12\x04\xb5\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x03\x01\x12\x04\xb5\x020\
    A\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x03\x03\x12\x04\xb5\x02D\
    E\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x03\x02\x04\x12\x04\xb6\x02\x20<\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x04\x04\x12\x04\xb6\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x04\x05\x12\x04\xb6\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x04\x01\x12\x04\xb6\x020\
    7\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x04\x03\x12\x04\xb6\x02:\
    ;\n\x12\n\n\x04\x02\x03\x01\x03\0\x03\x03\x02\x05\x12\x04\xb7\x02\x20:\n\
    \x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x05\x04\x12\x04\xb7\x02\x20\
    (\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x05\x05\x12\x04\xb7\x02)\
    /\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x05\x01\x12\x04\xb7\x020\
    5\n\x13\n\x0b\x04\x02\x03\x01\x03\0\x03\x03\x02\x05\x03\x12\x04\xb7\x028\
    9\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\0\x12\x04\xba\x02\x188\n\x11\n\t\
    \x04\x02\x03\x01\x03\0\x02\0\x04\x12\x04\xba\x02\x18\x20\n\x11\n\t\x04\
    \x02\x03\x01\x03\0\x02\0\x05\x12\x04\xba\x02!'\n\x11\n\t\x04\x02\x03\x01\
    \x03\0\x02\0\x01\x12\x04\xba\x02(3\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\0\
    \x03\x12\x04\xba\x0267\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\x01\x12\x04\
    \xbb\x02\x18;\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x01\x04\x12\x04\xbb\
    \x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x01\x05\x12\x04\xbb\x02\
    !&\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x01\x01\x12\x04\xbb\x02'6\n\x11\n\
    \t\x04\x02\x03\x01\x03\0\x02\x01\x03\x12\x04\xbb\x029:\n\x10\n\x08\x04\
    \x02\x03\x01\x03\0\x02\x02\x12\x04\xbc\x02\x18i\n\x11\n\t\x04\x02\x03\
    \x01\x03\0\x02\x02\x04\x12\x04\xbc\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\
    \x03\0\x02\x02\x06\x12\x04\xbc\x02!T\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\
    \x02\x01\x12\x04\xbc\x02Ud\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x02\x03\
    \x12\x04\xbc\x02gh\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\x03\x12\x04\xbd\
    \x02\x18>\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x03\x04\x12\x04\xbd\x02\
    \x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x03\x05\x12\x04\xbd\x02!'\n\
    \x11\n\t\x04\x02\x03\x01\x03\0\x02\x03\x01\x12\x04\xbd\x02(9\n\x11\n\t\
    \x04\x02\x03\x01\x03\0\x02\x03\x03\x12\x04\xbd\x02<=\n\x10\n\x08\x04\x02\
    \x03\x01\x03\0\x02\x04\x12\x04\xbe\x02\x18c\n\x11\n\t\x04\x02\x03\x01\
    \x03\0\x02\x04\x04\x12\x04\xbe\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\
    \0\x02\x04\x06\x12\x04\xbe\x02!Q\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x04\
    \x01\x12\x04\xbe\x02R^\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x04\x03\x12\
    \x04\xbe\x02ab\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\x05\x12\x04\xbf\x02\
    \x187\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x05\x04\x12\x04\xbf\x02\x18\
    \x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x05\x05\x12\x04\xbf\x02!&\n\x11\
    \n\t\x04\x02\x03\x01\x03\0\x02\x05\x01\x12\x04\xbf\x02'2\n\x11\n\t\x04\
    \x02\x03\x01\x03\0\x02\x05\x03\x12\x04\xbf\x0256\n\x10\n\x08\x04\x02\x03\
    \x01\x03\0\x02\x06\x12\x04\xc0\x02\x188\n\x11\n\t\x04\x02\x03\x01\x03\0\
    \x02\x06\x04\x12\x04\xc0\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\
    \x06\x05\x12\x04\xc0\x02!&\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x06\x01\
    \x12\x04\xc0\x02'3\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x06\x03\x12\x04\
    \xc0\x0267\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\x07\x12\x04\xc1\x02\x18\
    9\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x07\x04\x12\x04\xc1\x02\x18\x20\n\
    \x11\n\t\x04\x02\x03\x01\x03\0\x02\x07\x05\x12\x04\xc1\x02!&\n\x11\n\t\
    \x04\x02\x03\x01\x03\0\x02\x07\x01\x12\x04\xc1\x02'4\n\x11\n\t\x04\x02\
    \x03\x01\x03\0\x02\x07\x03\x12\x04\xc1\x0278\n\x10\n\x08\x04\x02\x03\x01\
    \x03\0\x02\x08\x12\x04\xc2\x02\x18;\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\
    \x08\x04\x12\x04\xc2\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x08\
    \x05\x12\x04\xc2\x02!&\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x08\x01\x12\
    \x04\xc2\x02'5\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x08\x03\x12\x04\xc2\
    \x028:\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\t\x12\x04\xc3\x02\x189\n\
    \x11\n\t\x04\x02\x03\x01\x03\0\x02\t\x04\x12\x04\xc3\x02\x18\x20\n\x11\n\
    \t\x04\x02\x03\x01\x03\0\x02\t\x05\x12\x04\xc3\x02!&\n\x11\n\t\x04\x02\
    \x03\x01\x03\0\x02\t\x01\x12\x04\xc3\x02'3\n\x11\n\t\x04\x02\x03\x01\x03\
    \0\x02\t\x03\x12\x04\xc3\x0268\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\n\
    \x12\x04\xc4\x02\x18g\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\n\x04\x12\x04\
    \xc4\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\n\x06\x12\x04\xc4\
    \x02!S\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\n\x01\x12\x04\xc4\x02Ta\n\x11\
    \n\t\x04\x02\x03\x01\x03\0\x02\n\x03\x12\x04\xc4\x02df\n\x10\n\x08\x04\
    \x02\x03\x01\x03\0\x02\x0b\x12\x04\xc5\x02\x18c\n\x11\n\t\x04\x02\x03\
    \x01\x03\0\x02\x0b\x04\x12\x04\xc5\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\
    \x03\0\x02\x0b\x06\x12\x04\xc5\x02!Q\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\
    \x0b\x01\x12\x04\xc5\x02R]\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x0b\x03\
    \x12\x04\xc5\x02`b\n\x10\n\x08\x04\x02\x03\x01\x03\0\x02\x0c\x12\x04\xc6\
    \x02\x18?\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x0c\x04\x12\x04\xc6\x02\
    \x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\x0c\x06\x12\x04\xc6\x02!-\n\
    \x11\n\t\x04\x02\x03\x01\x03\0\x02\x0c\x01\x12\x04\xc6\x02.9\n\x11\n\t\
    \x04\x02\x03\x01\x03\0\x02\x0c\x03\x12\x04\xc6\x02<>\n\x10\n\x08\x04\x02\
    \x03\x01\x03\0\x02\r\x12\x04\xc7\x02\x187\n\x11\n\t\x04\x02\x03\x01\x03\
    \0\x02\r\x04\x12\x04\xc7\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\
    \r\x05\x12\x04\xc7\x02!'\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\r\x01\x12\
    \x04\xc7\x02(1\n\x11\n\t\x04\x02\x03\x01\x03\0\x02\r\x03\x12\x04\xc7\x02\
    46\n\x10\n\x06\x04\x02\x03\x01\x03\x01\x12\x06\xca\x02\x10\xcf\x02\x11\n\
    \x0f\n\x07\x04\x02\x03\x01\x03\x01\x01\x12\x04\xca\x02\x18\x20\n\x10\n\
    \x08\x04\x02\x03\x01\x03\x01\x02\0\x12\x04\xcb\x02\x186\n\x11\n\t\x04\
    \x02\x03\x01\x03\x01\x02\0\x04\x12\x04\xcb\x02\x18\x20\n\x11\n\t\x04\x02\
    \x03\x01\x03\x01\x02\0\x05\x12\x04\xcb\x02!'\n\x11\n\t\x04\x02\x03\x01\
    \x03\x01\x02\0\x01\x12\x04\xcb\x02(1\n\x11\n\t\x04\x02\x03\x01\x03\x01\
    \x02\0\x03\x12\x04\xcb\x0245\n\x10\n\x08\x04\x02\x03\x01\x03\x01\x02\x01\
    \x12\x04\xcc\x02\x18=\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\x01\x04\x12\
    \x04\xcc\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\x01\x05\x12\
    \x04\xcc\x02!'\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\x01\x01\x12\x04\xcc\
    \x02(8\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\x01\x03\x12\x04\xcc\x02;<\n\
    \x10\n\x08\x04\x02\x03\x01\x03\x01\x02\x02\x12\x04\xcd\x02\x18=\n\x11\n\
    \t\x04\x02\x03\x01\x03\x01\x02\x02\x04\x12\x04\xcd\x02\x18\x20\n\x11\n\t\
    \x04\x02\x03\x01\x03\x01\x02\x02\x05\x12\x04\xcd\x02!'\n\x11\n\t\x04\x02\
    \x03\x01\x03\x01\x02\x02\x01\x12\x04\xcd\x02(8\n\x11\n\t\x04\x02\x03\x01\
    \x03\x01\x02\x02\x03\x12\x04\xcd\x02;<\n\x10\n\x08\x04\x02\x03\x01\x03\
    \x01\x02\x03\x12\x04\xce\x02\x186\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\
    \x03\x04\x12\x04\xce\x02\x18\x20\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\
    \x03\x05\x12\x04\xce\x02!&\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\x03\x01\
    \x12\x04\xce\x02'1\n\x11\n\t\x04\x02\x03\x01\x03\x01\x02\x03\x03\x12\x04\
    \xce\x0245\n\x0e\n\x06\x04\x02\x03\x01\x02\0\x12\x04\xd1\x02\x10.\n\x0f\
    \n\x07\x04\x02\x03\x01\x02\0\x04\x12\x04\xd1\x02\x10\x18\n\x0f\n\x07\x04\
    \x02\x03\x01\x02\0\x05\x12\x04\xd1\x02\x19\x1f\n\x0f\n\x07\x04\x02\x03\
    \x01\x02\0\x01\x12\x04\xd1\x02\x20)\n\x0f\n\x07\x04\x02\x03\x01\x02\0\
    \x03\x12\x04\xd1\x02,-\n\x0e\n\x06\x04\x02\x03\x01\x02\x01\x12\x04\xd2\
    \x02\x10K\n\x0f\n\x07\x04\x02\x03\x01\x02\x01\x04\x12\x04\xd2\x02\x10\
    \x18\n\x0f\n\x07\x04\x02\x03\x01\x02\x01\x06\x12\x04\xd2\x02\x19>\n\x0f\
    \n\x07\x04\x02\x03\x01\x02\x01\x01\x12\x04\xd2\x02?F\n\x0f\n\x07\x04\x02\
    \x03\x01\x02\x01\x03\x12\x04\xd2\x02IJ\n\x0e\n\x06\x04\x02\x03\x01\x02\
    \x02\x12\x04\xd3\x02\x10O\n\x0f\n\x07\x04\x02\x03\x01\x02\x02\x04\x12\
    \x04\xd3\x02\x10\x18\n\x0f\n\x07\x04\x02\x03\x01\x02\x02\x06\x12\x04\xd3\
    \x02\x19@\n\x0f\n\x07\x04\x02\x03\x01\x02\x02\x01\x12\x04\xd3\x02AJ\n\
    \x0f\n\x07\x04\x02\x03\x01\x02\x02\x03\x12\x04\xd3\x02MN\n\x0c\n\x04\x04\
    \x02\x02\0\x12\x04\xd6\x02\x08:\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\xd6\
    \x02\x08\x10\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xd6\x02\x11/\n\r\n\x05\
    \x04\x02\x02\0\x01\x12\x04\xd6\x0205\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\
    \xd6\x0289\n\x0c\n\x04\x04\x02\x02\x01\x12\x04\xd7\x02\x081\n\r\n\x05\
    \x04\x02\x02\x01\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04\x02\x02\x01\
    \x05\x12\x04\xd7\x02\x11\x16\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xd7\
    \x02\x17,\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xd7\x02/0\n\x0c\n\x04\
    \x04\x02\x02\x02\x12\x04\xd8\x02\x08G\n\r\n\x05\x04\x02\x02\x02\x04\x12\
    \x04\xd8\x02\x08\x10\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xd8\x02\x115\
    \n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xd8\x026B\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\xd8\x02EF\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::base_gcmessages::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common_match_management::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common_lobby::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(36);
            messages.push(CDOTAMatchMetadataFile::generated_message_descriptor_data());
            messages.push(CDOTAMatchMetadata::generated_message_descriptor_data());
            messages.push(CDOTAMatchPrivateMetadata::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::EconItem::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::Team::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::GuildChallengeProgress::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::Tip::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::PlayerKill::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::ItemPurchase::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::InventorySnapshot::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::AutoStyleCriteria::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::StrangeGemProgress::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::VictoryPrediction::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::SubChallenge::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::CavernChallengeResult::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::ActionGrant::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::CandyGrant::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::PeriodicResourceData::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::EventData::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::FeaturedGamemodeProgress::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::Player::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::team::player::ContractProgress::generated_message_descriptor_data());
            messages.push(cdotamatch_metadata::guild_challenge_progress::IndividualProgress::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::StringName::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::Team::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::Player::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::Building::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::CombatSegment::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::BuffRecord::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::GoldReceived::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::XPReceived::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::combat_segment::DamageByAbility::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::combat_segment::HealingByAbility::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::combat_segment::damage_by_ability::ByHeroTarget::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::combat_segment::healing_by_ability::ByHeroTarget::generated_message_descriptor_data());
            messages.push(cdotamatch_private_metadata::team::player::buff_record::ByHeroTarget::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
