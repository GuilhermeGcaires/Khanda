// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_webapi.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgArcanaVotes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgArcanaVotes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.matches)
    pub matches: ::std::vec::Vec<cmsg_arcana_votes::Match>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.round_time_remaining)
    pub round_time_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.round_number)
    pub round_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.voting_state)
    pub voting_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.is_current_round_calibrating)
    pub is_current_round_calibrating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.closest_active_match_id)
    pub closest_active_match_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.voting_start_time)
    pub voting_start_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgArcanaVotes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgArcanaVotes {
    fn default() -> &'a CMsgArcanaVotes {
        <CMsgArcanaVotes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgArcanaVotes {
    pub fn new() -> CMsgArcanaVotes {
        ::std::default::Default::default()
    }

    // optional uint32 round_time_remaining = 2;

    pub fn round_time_remaining(&self) -> u32 {
        self.round_time_remaining.unwrap_or(0)
    }

    pub fn clear_round_time_remaining(&mut self) {
        self.round_time_remaining = ::std::option::Option::None;
    }

    pub fn has_round_time_remaining(&self) -> bool {
        self.round_time_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_time_remaining(&mut self, v: u32) {
        self.round_time_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 round_number = 3;

    pub fn round_number(&self) -> u32 {
        self.round_number.unwrap_or(0)
    }

    pub fn clear_round_number(&mut self) {
        self.round_number = ::std::option::Option::None;
    }

    pub fn has_round_number(&self) -> bool {
        self.round_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_number(&mut self, v: u32) {
        self.round_number = ::std::option::Option::Some(v);
    }

    // optional uint32 voting_state = 4;

    pub fn voting_state(&self) -> u32 {
        self.voting_state.unwrap_or(0)
    }

    pub fn clear_voting_state(&mut self) {
        self.voting_state = ::std::option::Option::None;
    }

    pub fn has_voting_state(&self) -> bool {
        self.voting_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voting_state(&mut self, v: u32) {
        self.voting_state = ::std::option::Option::Some(v);
    }

    // optional bool is_current_round_calibrating = 5;

    pub fn is_current_round_calibrating(&self) -> bool {
        self.is_current_round_calibrating.unwrap_or(false)
    }

    pub fn clear_is_current_round_calibrating(&mut self) {
        self.is_current_round_calibrating = ::std::option::Option::None;
    }

    pub fn has_is_current_round_calibrating(&self) -> bool {
        self.is_current_round_calibrating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_current_round_calibrating(&mut self, v: bool) {
        self.is_current_round_calibrating = ::std::option::Option::Some(v);
    }

    // optional uint32 closest_active_match_id = 6;

    pub fn closest_active_match_id(&self) -> u32 {
        self.closest_active_match_id.unwrap_or(0)
    }

    pub fn clear_closest_active_match_id(&mut self) {
        self.closest_active_match_id = ::std::option::Option::None;
    }

    pub fn has_closest_active_match_id(&self) -> bool {
        self.closest_active_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closest_active_match_id(&mut self, v: u32) {
        self.closest_active_match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 7;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 voting_start_time = 8;

    pub fn voting_start_time(&self) -> u32 {
        self.voting_start_time.unwrap_or(0)
    }

    pub fn clear_voting_start_time(&mut self) {
        self.voting_start_time = ::std::option::Option::None;
    }

    pub fn has_voting_start_time(&self) -> bool {
        self.voting_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voting_start_time(&mut self, v: u32) {
        self.voting_start_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &CMsgArcanaVotes| { &m.matches },
            |m: &mut CMsgArcanaVotes| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round_time_remaining",
            |m: &CMsgArcanaVotes| { &m.round_time_remaining },
            |m: &mut CMsgArcanaVotes| { &mut m.round_time_remaining },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round_number",
            |m: &CMsgArcanaVotes| { &m.round_number },
            |m: &mut CMsgArcanaVotes| { &mut m.round_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voting_state",
            |m: &CMsgArcanaVotes| { &m.voting_state },
            |m: &mut CMsgArcanaVotes| { &mut m.voting_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_current_round_calibrating",
            |m: &CMsgArcanaVotes| { &m.is_current_round_calibrating },
            |m: &mut CMsgArcanaVotes| { &mut m.is_current_round_calibrating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "closest_active_match_id",
            |m: &CMsgArcanaVotes| { &m.closest_active_match_id },
            |m: &mut CMsgArcanaVotes| { &mut m.closest_active_match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgArcanaVotes| { &m.event_id },
            |m: &mut CMsgArcanaVotes| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voting_start_time",
            |m: &CMsgArcanaVotes| { &m.voting_start_time },
            |m: &mut CMsgArcanaVotes| { &mut m.voting_start_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgArcanaVotes>(
            "CMsgArcanaVotes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgArcanaVotes {
    const NAME: &'static str = "CMsgArcanaVotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                16 => {
                    self.round_time_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.round_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.voting_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.is_current_round_calibrating = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.closest_active_match_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.voting_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.round_time_remaining {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.round_number {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.voting_state {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.is_current_round_calibrating {
            my_size += 1 + 1;
        }
        if let Some(v) = self.closest_active_match_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.voting_start_time {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.round_time_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.round_number {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.voting_state {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_current_round_calibrating {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.closest_active_match_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.voting_start_time {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgArcanaVotes {
        CMsgArcanaVotes::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.round_time_remaining = ::std::option::Option::None;
        self.round_number = ::std::option::Option::None;
        self.voting_state = ::std::option::Option::None;
        self.is_current_round_calibrating = ::std::option::Option::None;
        self.closest_active_match_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.voting_start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgArcanaVotes {
        static instance: CMsgArcanaVotes = CMsgArcanaVotes {
            matches: ::std::vec::Vec::new(),
            round_time_remaining: ::std::option::Option::None,
            round_number: ::std::option::Option::None,
            voting_state: ::std::option::Option::None,
            is_current_round_calibrating: ::std::option::Option::None,
            closest_active_match_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            voting_start_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgArcanaVotes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgArcanaVotes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgArcanaVotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgArcanaVotes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgArcanaVotes`
pub mod cmsg_arcana_votes {
    // @@protoc_insertion_point(message:dota.CMsgArcanaVotes.Match)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Match {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.match_id)
        pub match_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.hero_id_0)
        pub hero_id_0: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.hero_id_1)
        pub hero_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.hero_seeding_0)
        pub hero_seeding_0: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.hero_seeding_1)
        pub hero_seeding_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.vote_count_0)
        pub vote_count_0: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.vote_count_1)
        pub vote_count_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.voting_state)
        pub voting_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.round_number)
        pub round_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.is_votes_hidden)
        pub is_votes_hidden: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgArcanaVotes.Match.calibration_time_remaining)
        pub calibration_time_remaining: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgArcanaVotes.Match.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Match {
        fn default() -> &'a Match {
            <Match as ::protobuf::Message>::default_instance()
        }
    }

    impl Match {
        pub fn new() -> Match {
            ::std::default::Default::default()
        }

        // optional uint32 match_id = 1;

        pub fn match_id(&self) -> u32 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u32) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id_0 = 2;

        pub fn hero_id_0(&self) -> u32 {
            self.hero_id_0.unwrap_or(0)
        }

        pub fn clear_hero_id_0(&mut self) {
            self.hero_id_0 = ::std::option::Option::None;
        }

        pub fn has_hero_id_0(&self) -> bool {
            self.hero_id_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id_0(&mut self, v: u32) {
            self.hero_id_0 = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id_1 = 3;

        pub fn hero_id_1(&self) -> u32 {
            self.hero_id_1.unwrap_or(0)
        }

        pub fn clear_hero_id_1(&mut self) {
            self.hero_id_1 = ::std::option::Option::None;
        }

        pub fn has_hero_id_1(&self) -> bool {
            self.hero_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id_1(&mut self, v: u32) {
            self.hero_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_seeding_0 = 4;

        pub fn hero_seeding_0(&self) -> u32 {
            self.hero_seeding_0.unwrap_or(0)
        }

        pub fn clear_hero_seeding_0(&mut self) {
            self.hero_seeding_0 = ::std::option::Option::None;
        }

        pub fn has_hero_seeding_0(&self) -> bool {
            self.hero_seeding_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_seeding_0(&mut self, v: u32) {
            self.hero_seeding_0 = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_seeding_1 = 5;

        pub fn hero_seeding_1(&self) -> u32 {
            self.hero_seeding_1.unwrap_or(0)
        }

        pub fn clear_hero_seeding_1(&mut self) {
            self.hero_seeding_1 = ::std::option::Option::None;
        }

        pub fn has_hero_seeding_1(&self) -> bool {
            self.hero_seeding_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_seeding_1(&mut self, v: u32) {
            self.hero_seeding_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 vote_count_0 = 6;

        pub fn vote_count_0(&self) -> u32 {
            self.vote_count_0.unwrap_or(0)
        }

        pub fn clear_vote_count_0(&mut self) {
            self.vote_count_0 = ::std::option::Option::None;
        }

        pub fn has_vote_count_0(&self) -> bool {
            self.vote_count_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_count_0(&mut self, v: u32) {
            self.vote_count_0 = ::std::option::Option::Some(v);
        }

        // optional uint32 vote_count_1 = 7;

        pub fn vote_count_1(&self) -> u32 {
            self.vote_count_1.unwrap_or(0)
        }

        pub fn clear_vote_count_1(&mut self) {
            self.vote_count_1 = ::std::option::Option::None;
        }

        pub fn has_vote_count_1(&self) -> bool {
            self.vote_count_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_count_1(&mut self, v: u32) {
            self.vote_count_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 voting_state = 8;

        pub fn voting_state(&self) -> u32 {
            self.voting_state.unwrap_or(0)
        }

        pub fn clear_voting_state(&mut self) {
            self.voting_state = ::std::option::Option::None;
        }

        pub fn has_voting_state(&self) -> bool {
            self.voting_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voting_state(&mut self, v: u32) {
            self.voting_state = ::std::option::Option::Some(v);
        }

        // optional uint32 round_number = 9;

        pub fn round_number(&self) -> u32 {
            self.round_number.unwrap_or(0)
        }

        pub fn clear_round_number(&mut self) {
            self.round_number = ::std::option::Option::None;
        }

        pub fn has_round_number(&self) -> bool {
            self.round_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_round_number(&mut self, v: u32) {
            self.round_number = ::std::option::Option::Some(v);
        }

        // optional bool is_votes_hidden = 10;

        pub fn is_votes_hidden(&self) -> bool {
            self.is_votes_hidden.unwrap_or(false)
        }

        pub fn clear_is_votes_hidden(&mut self) {
            self.is_votes_hidden = ::std::option::Option::None;
        }

        pub fn has_is_votes_hidden(&self) -> bool {
            self.is_votes_hidden.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_votes_hidden(&mut self, v: bool) {
            self.is_votes_hidden = ::std::option::Option::Some(v);
        }

        // optional uint32 calibration_time_remaining = 11;

        pub fn calibration_time_remaining(&self) -> u32 {
            self.calibration_time_remaining.unwrap_or(0)
        }

        pub fn clear_calibration_time_remaining(&mut self) {
            self.calibration_time_remaining = ::std::option::Option::None;
        }

        pub fn has_calibration_time_remaining(&self) -> bool {
            self.calibration_time_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_calibration_time_remaining(&mut self, v: u32) {
            self.calibration_time_remaining = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &Match| { &m.match_id },
                |m: &mut Match| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id_0",
                |m: &Match| { &m.hero_id_0 },
                |m: &mut Match| { &mut m.hero_id_0 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id_1",
                |m: &Match| { &m.hero_id_1 },
                |m: &mut Match| { &mut m.hero_id_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_seeding_0",
                |m: &Match| { &m.hero_seeding_0 },
                |m: &mut Match| { &mut m.hero_seeding_0 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_seeding_1",
                |m: &Match| { &m.hero_seeding_1 },
                |m: &mut Match| { &mut m.hero_seeding_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vote_count_0",
                |m: &Match| { &m.vote_count_0 },
                |m: &mut Match| { &mut m.vote_count_0 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vote_count_1",
                |m: &Match| { &m.vote_count_1 },
                |m: &mut Match| { &mut m.vote_count_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voting_state",
                |m: &Match| { &m.voting_state },
                |m: &mut Match| { &mut m.voting_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "round_number",
                |m: &Match| { &m.round_number },
                |m: &mut Match| { &mut m.round_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_votes_hidden",
                |m: &Match| { &m.is_votes_hidden },
                |m: &mut Match| { &mut m.is_votes_hidden },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "calibration_time_remaining",
                |m: &Match| { &m.calibration_time_remaining },
                |m: &mut Match| { &mut m.calibration_time_remaining },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Match>(
                "CMsgArcanaVotes.Match",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Match {
        const NAME: &'static str = "Match";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id_0 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.hero_seeding_0 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.hero_seeding_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.vote_count_0 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.vote_count_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.voting_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.round_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.is_votes_hidden = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.calibration_time_remaining = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id_0 {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id_1 {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.hero_seeding_0 {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.hero_seeding_1 {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.vote_count_0 {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.vote_count_1 {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.voting_state {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.round_number {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.is_votes_hidden {
                my_size += 1 + 1;
            }
            if let Some(v) = self.calibration_time_remaining {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id_0 {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id_1 {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.hero_seeding_0 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.hero_seeding_1 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.vote_count_0 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.vote_count_1 {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.voting_state {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.round_number {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.is_votes_hidden {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.calibration_time_remaining {
                os.write_uint32(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Match {
            Match::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.hero_id_0 = ::std::option::Option::None;
            self.hero_id_1 = ::std::option::Option::None;
            self.hero_seeding_0 = ::std::option::Option::None;
            self.hero_seeding_1 = ::std::option::Option::None;
            self.vote_count_0 = ::std::option::Option::None;
            self.vote_count_1 = ::std::option::Option::None;
            self.voting_state = ::std::option::Option::None;
            self.round_number = ::std::option::Option::None;
            self.is_votes_hidden = ::std::option::Option::None;
            self.calibration_time_remaining = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Match {
            static instance: Match = Match {
                match_id: ::std::option::Option::None,
                hero_id_0: ::std::option::Option::None,
                hero_id_1: ::std::option::Option::None,
                hero_seeding_0: ::std::option::Option::None,
                hero_seeding_1: ::std::option::Option::None,
                vote_count_0: ::std::option::Option::None,
                vote_count_1: ::std::option::Option::None,
                voting_state: ::std::option::Option::None,
                round_number: ::std::option::Option::None,
                is_votes_hidden: ::std::option::Option::None,
                calibration_time_remaining: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Match {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgArcanaVotes.Match").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Match {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Match {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgArcanaVotes.VotingState)
    pub enum VotingState {
        // @@protoc_insertion_point(enum_value:dota.CMsgArcanaVotes.VotingState.FINISHED)
        FINISHED = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgArcanaVotes.VotingState.IN_PROGRESS)
        IN_PROGRESS = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgArcanaVotes.VotingState.IN_FUTURE)
        IN_FUTURE = 2,
    }

    impl ::protobuf::Enum for VotingState {
        const NAME: &'static str = "VotingState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<VotingState> {
            match value {
                0 => ::std::option::Option::Some(VotingState::FINISHED),
                1 => ::std::option::Option::Some(VotingState::IN_PROGRESS),
                2 => ::std::option::Option::Some(VotingState::IN_FUTURE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<VotingState> {
            match str {
                "FINISHED" => ::std::option::Option::Some(VotingState::FINISHED),
                "IN_PROGRESS" => ::std::option::Option::Some(VotingState::IN_PROGRESS),
                "IN_FUTURE" => ::std::option::Option::Some(VotingState::IN_FUTURE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [VotingState] = &[
            VotingState::FINISHED,
            VotingState::IN_PROGRESS,
            VotingState::IN_FUTURE,
        ];
    }

    impl ::protobuf::EnumFull for VotingState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgArcanaVotes.VotingState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for VotingState {
        fn default() -> Self {
            VotingState::FINISHED
        }
    }

    impl VotingState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VotingState>("CMsgArcanaVotes.VotingState")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTADPCFeed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCFeed {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.elements)
    pub elements: ::std::vec::Vec<cmsg_dotadpcfeed::Element>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCFeed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCFeed {
    fn default() -> &'a CMsgDOTADPCFeed {
        <CMsgDOTADPCFeed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCFeed {
    pub fn new() -> CMsgDOTADPCFeed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "elements",
            |m: &CMsgDOTADPCFeed| { &m.elements },
            |m: &mut CMsgDOTADPCFeed| { &mut m.elements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTADPCFeed>(
            "CMsgDOTADPCFeed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTADPCFeed {
    const NAME: &'static str = "CMsgDOTADPCFeed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.elements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.elements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCFeed {
        CMsgDOTADPCFeed::new()
    }

    fn clear(&mut self) {
        self.elements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCFeed {
        static instance: CMsgDOTADPCFeed = CMsgDOTADPCFeed {
            elements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTADPCFeed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTADPCFeed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTADPCFeed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADPCFeed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTADPCFeed`
pub mod cmsg_dotadpcfeed {
    // @@protoc_insertion_point(message:dota.CMsgDOTADPCFeed.Element)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Element {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<EFeedElementType>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.series_id)
        pub series_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.data_1)
        pub data_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.data_2)
        pub data_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.data_3)
        pub data_3: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCFeed.Element.data_4)
        pub data_4: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCFeed.Element.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Element {
        fn default() -> &'a Element {
            <Element as ::protobuf::Message>::default_instance()
        }
    }

    impl Element {
        pub fn new() -> Element {
            ::std::default::Default::default()
        }

        // optional .dota.CMsgDOTADPCFeed.EFeedElementType type = 1;

        pub fn type_(&self) -> EFeedElementType {
            match self.type_ {
                Some(e) => e.enum_value_or(EFeedElementType::FEED_SERIES_RESULT),
                None => EFeedElementType::FEED_SERIES_RESULT,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: EFeedElementType) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 series_id = 3;

        pub fn series_id(&self) -> u32 {
            self.series_id.unwrap_or(0)
        }

        pub fn clear_series_id(&mut self) {
            self.series_id = ::std::option::Option::None;
        }

        pub fn has_series_id(&self) -> bool {
            self.series_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_id(&mut self, v: u32) {
            self.series_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 4;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 5;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 6;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 7;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 node_id = 8;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }

        // optional uint64 server_steam_id = 13;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 data_1 = 9;

        pub fn data_1(&self) -> u32 {
            self.data_1.unwrap_or(0)
        }

        pub fn clear_data_1(&mut self) {
            self.data_1 = ::std::option::Option::None;
        }

        pub fn has_data_1(&self) -> bool {
            self.data_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_1(&mut self, v: u32) {
            self.data_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 data_2 = 10;

        pub fn data_2(&self) -> u32 {
            self.data_2.unwrap_or(0)
        }

        pub fn clear_data_2(&mut self) {
            self.data_2 = ::std::option::Option::None;
        }

        pub fn has_data_2(&self) -> bool {
            self.data_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_2(&mut self, v: u32) {
            self.data_2 = ::std::option::Option::Some(v);
        }

        // optional uint32 data_3 = 11;

        pub fn data_3(&self) -> u32 {
            self.data_3.unwrap_or(0)
        }

        pub fn clear_data_3(&mut self) {
            self.data_3 = ::std::option::Option::None;
        }

        pub fn has_data_3(&self) -> bool {
            self.data_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_3(&mut self, v: u32) {
            self.data_3 = ::std::option::Option::Some(v);
        }

        // optional uint32 data_4 = 12;

        pub fn data_4(&self) -> u32 {
            self.data_4.unwrap_or(0)
        }

        pub fn clear_data_4(&mut self) {
            self.data_4 = ::std::option::Option::None;
        }

        pub fn has_data_4(&self) -> bool {
            self.data_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_4(&mut self, v: u32) {
            self.data_4 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Element| { &m.type_ },
                |m: &mut Element| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &Element| { &m.timestamp },
                |m: &mut Element| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "series_id",
                |m: &Element| { &m.series_id },
                |m: &mut Element| { &mut m.series_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &Element| { &m.match_id },
                |m: &mut Element| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Element| { &m.team_id },
                |m: &mut Element| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Element| { &m.account_id },
                |m: &mut Element| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &Element| { &m.league_id },
                |m: &mut Element| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "node_id",
                |m: &Element| { &m.node_id },
                |m: &mut Element| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_steam_id",
                |m: &Element| { &m.server_steam_id },
                |m: &mut Element| { &mut m.server_steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_1",
                |m: &Element| { &m.data_1 },
                |m: &mut Element| { &mut m.data_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_2",
                |m: &Element| { &m.data_2 },
                |m: &mut Element| { &mut m.data_2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_3",
                |m: &Element| { &m.data_3 },
                |m: &mut Element| { &mut m.data_3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_4",
                |m: &Element| { &m.data_4 },
                |m: &mut Element| { &mut m.data_4 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Element>(
                "CMsgDOTADPCFeed.Element",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Element {
        const NAME: &'static str = "Element";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.data_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.data_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.data_3 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.data_4 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.series_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.node_id {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.server_steam_id {
                my_size += ::protobuf::rt::uint64_size(13, v);
            }
            if let Some(v) = self.data_1 {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.data_2 {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.data_3 {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.data_4 {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.series_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.node_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.server_steam_id {
                os.write_uint64(13, v)?;
            }
            if let Some(v) = self.data_1 {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.data_2 {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.data_3 {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.data_4 {
                os.write_uint32(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Element {
            Element::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.series_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.node_id = ::std::option::Option::None;
            self.server_steam_id = ::std::option::Option::None;
            self.data_1 = ::std::option::Option::None;
            self.data_2 = ::std::option::Option::None;
            self.data_3 = ::std::option::Option::None;
            self.data_4 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Element {
            static instance: Element = Element {
                type_: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                series_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                node_id: ::std::option::Option::None,
                server_steam_id: ::std::option::Option::None,
                data_1: ::std::option::Option::None,
                data_2: ::std::option::Option::None,
                data_3: ::std::option::Option::None,
                data_4: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Element {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTADPCFeed.Element").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Element {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Element {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgDOTADPCFeed.EFeedElementType)
    pub enum EFeedElementType {
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_SERIES_RESULT)
        FEED_SERIES_RESULT = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_MATCH_POPULAR)
        FEED_MATCH_POPULAR = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_UPCOMING_MATCH)
        FEED_TEAM_UPCOMING_MATCH = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_LEAGUE_RESULT)
        FEED_TEAM_LEAGUE_RESULT = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_ADD_PLAYER)
        FEED_TEAM_ADD_PLAYER = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_REMOVE_PLAYER)
        FEED_TEAM_REMOVE_PLAYER = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_DISBAND)
        FEED_TEAM_DISBAND = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_UPCOMING)
        FEED_LEAGUE_UPCOMING = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_CONCLUDED)
        FEED_LEAGUE_CONCLUDED = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_DPC_STANDINGS)
        FEED_DPC_STANDINGS = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_ALERT_PREDICTIONS)
        FEED_ALERT_PREDICTIONS = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_ALERT_FANTASY)
        FEED_ALERT_FANTASY = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_LIVE_MATCH)
        FEED_LEAGUE_LIVE_MATCH = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_INPROGRESS_SERIES)
        FEED_LEAGUE_INPROGRESS_SERIES = 14,
    }

    impl ::protobuf::Enum for EFeedElementType {
        const NAME: &'static str = "EFeedElementType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EFeedElementType> {
            match value {
                1 => ::std::option::Option::Some(EFeedElementType::FEED_SERIES_RESULT),
                2 => ::std::option::Option::Some(EFeedElementType::FEED_MATCH_POPULAR),
                3 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_UPCOMING_MATCH),
                4 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_LEAGUE_RESULT),
                5 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_ADD_PLAYER),
                6 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_REMOVE_PLAYER),
                7 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_DISBAND),
                8 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_UPCOMING),
                9 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_CONCLUDED),
                10 => ::std::option::Option::Some(EFeedElementType::FEED_DPC_STANDINGS),
                11 => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_PREDICTIONS),
                12 => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_FANTASY),
                13 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_LIVE_MATCH),
                14 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_INPROGRESS_SERIES),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EFeedElementType> {
            match str {
                "FEED_SERIES_RESULT" => ::std::option::Option::Some(EFeedElementType::FEED_SERIES_RESULT),
                "FEED_MATCH_POPULAR" => ::std::option::Option::Some(EFeedElementType::FEED_MATCH_POPULAR),
                "FEED_TEAM_UPCOMING_MATCH" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_UPCOMING_MATCH),
                "FEED_TEAM_LEAGUE_RESULT" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_LEAGUE_RESULT),
                "FEED_TEAM_ADD_PLAYER" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_ADD_PLAYER),
                "FEED_TEAM_REMOVE_PLAYER" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_REMOVE_PLAYER),
                "FEED_TEAM_DISBAND" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_DISBAND),
                "FEED_LEAGUE_UPCOMING" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_UPCOMING),
                "FEED_LEAGUE_CONCLUDED" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_CONCLUDED),
                "FEED_DPC_STANDINGS" => ::std::option::Option::Some(EFeedElementType::FEED_DPC_STANDINGS),
                "FEED_ALERT_PREDICTIONS" => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_PREDICTIONS),
                "FEED_ALERT_FANTASY" => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_FANTASY),
                "FEED_LEAGUE_LIVE_MATCH" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_LIVE_MATCH),
                "FEED_LEAGUE_INPROGRESS_SERIES" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_INPROGRESS_SERIES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EFeedElementType] = &[
            EFeedElementType::FEED_SERIES_RESULT,
            EFeedElementType::FEED_MATCH_POPULAR,
            EFeedElementType::FEED_TEAM_UPCOMING_MATCH,
            EFeedElementType::FEED_TEAM_LEAGUE_RESULT,
            EFeedElementType::FEED_TEAM_ADD_PLAYER,
            EFeedElementType::FEED_TEAM_REMOVE_PLAYER,
            EFeedElementType::FEED_TEAM_DISBAND,
            EFeedElementType::FEED_LEAGUE_UPCOMING,
            EFeedElementType::FEED_LEAGUE_CONCLUDED,
            EFeedElementType::FEED_DPC_STANDINGS,
            EFeedElementType::FEED_ALERT_PREDICTIONS,
            EFeedElementType::FEED_ALERT_FANTASY,
            EFeedElementType::FEED_LEAGUE_LIVE_MATCH,
            EFeedElementType::FEED_LEAGUE_INPROGRESS_SERIES,
        ];
    }

    impl ::protobuf::EnumFull for EFeedElementType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgDOTADPCFeed.EFeedElementType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EFeedElementType::FEED_SERIES_RESULT => 0,
                EFeedElementType::FEED_MATCH_POPULAR => 1,
                EFeedElementType::FEED_TEAM_UPCOMING_MATCH => 2,
                EFeedElementType::FEED_TEAM_LEAGUE_RESULT => 3,
                EFeedElementType::FEED_TEAM_ADD_PLAYER => 4,
                EFeedElementType::FEED_TEAM_REMOVE_PLAYER => 5,
                EFeedElementType::FEED_TEAM_DISBAND => 6,
                EFeedElementType::FEED_LEAGUE_UPCOMING => 7,
                EFeedElementType::FEED_LEAGUE_CONCLUDED => 8,
                EFeedElementType::FEED_DPC_STANDINGS => 9,
                EFeedElementType::FEED_ALERT_PREDICTIONS => 10,
                EFeedElementType::FEED_ALERT_FANTASY => 11,
                EFeedElementType::FEED_LEAGUE_LIVE_MATCH => 12,
                EFeedElementType::FEED_LEAGUE_INPROGRESS_SERIES => 13,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EFeedElementType {
        fn default() -> Self {
            EFeedElementType::FEED_SERIES_RESULT
        }
    }

    impl EFeedElementType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EFeedElementType>("CMsgDOTADPCFeed.EFeedElementType")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTADPCUserInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCUserInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCUserInfo.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCUserInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCUserInfo {
    fn default() -> &'a CMsgDOTADPCUserInfo {
        <CMsgDOTADPCUserInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCUserInfo {
    pub fn new() -> CMsgDOTADPCUserInfo {
        ::std::default::Default::default()
    }

    // optional bool is_plus_subscriber = 1;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_plus_subscriber",
            |m: &CMsgDOTADPCUserInfo| { &m.is_plus_subscriber },
            |m: &mut CMsgDOTADPCUserInfo| { &mut m.is_plus_subscriber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTADPCUserInfo>(
            "CMsgDOTADPCUserInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTADPCUserInfo {
    const NAME: &'static str = "CMsgDOTADPCUserInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_plus_subscriber {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCUserInfo {
        CMsgDOTADPCUserInfo::new()
    }

    fn clear(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCUserInfo {
        static instance: CMsgDOTADPCUserInfo = CMsgDOTADPCUserInfo {
            is_plus_subscriber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTADPCUserInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTADPCUserInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTADPCUserInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADPCUserInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDraftTrivia)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDraftTrivia {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.has_valid_match)
    pub has_valid_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.match_hero_info)
    pub match_hero_info: ::protobuf::MessageField<cmsg_draft_trivia::DraftTriviaMatchInfo>,
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.match_rank_tier)
    pub match_rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.end_time)
    pub end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.current_match_voted_radiant)
    pub current_match_voted_radiant: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.previous_result)
    pub previous_result: ::protobuf::MessageField<cmsg_draft_trivia::PreviousResult>,
    // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.current_streak)
    pub current_streak: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDraftTrivia.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDraftTrivia {
    fn default() -> &'a CMsgDraftTrivia {
        <CMsgDraftTrivia as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDraftTrivia {
    pub fn new() -> CMsgDraftTrivia {
        ::std::default::Default::default()
    }

    // optional bool has_valid_match = 1;

    pub fn has_valid_match(&self) -> bool {
        self.has_valid_match.unwrap_or(false)
    }

    pub fn clear_has_valid_match(&mut self) {
        self.has_valid_match = ::std::option::Option::None;
    }

    pub fn has_has_valid_match(&self) -> bool {
        self.has_valid_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_valid_match(&mut self, v: bool) {
        self.has_valid_match = ::std::option::Option::Some(v);
    }

    // optional uint32 match_rank_tier = 3;

    pub fn match_rank_tier(&self) -> u32 {
        self.match_rank_tier.unwrap_or(0)
    }

    pub fn clear_match_rank_tier(&mut self) {
        self.match_rank_tier = ::std::option::Option::None;
    }

    pub fn has_match_rank_tier(&self) -> bool {
        self.match_rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_rank_tier(&mut self, v: u32) {
        self.match_rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time = 4;

    pub fn end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 5;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional bool current_match_voted_radiant = 6;

    pub fn current_match_voted_radiant(&self) -> bool {
        self.current_match_voted_radiant.unwrap_or(false)
    }

    pub fn clear_current_match_voted_radiant(&mut self) {
        self.current_match_voted_radiant = ::std::option::Option::None;
    }

    pub fn has_current_match_voted_radiant(&self) -> bool {
        self.current_match_voted_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_match_voted_radiant(&mut self, v: bool) {
        self.current_match_voted_radiant = ::std::option::Option::Some(v);
    }

    // optional uint32 current_streak = 8;

    pub fn current_streak(&self) -> u32 {
        self.current_streak.unwrap_or(0)
    }

    pub fn clear_current_streak(&mut self) {
        self.current_streak = ::std::option::Option::None;
    }

    pub fn has_current_streak(&self) -> bool {
        self.current_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_streak(&mut self, v: u32) {
        self.current_streak = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_valid_match",
            |m: &CMsgDraftTrivia| { &m.has_valid_match },
            |m: &mut CMsgDraftTrivia| { &mut m.has_valid_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_draft_trivia::DraftTriviaMatchInfo>(
            "match_hero_info",
            |m: &CMsgDraftTrivia| { &m.match_hero_info },
            |m: &mut CMsgDraftTrivia| { &mut m.match_hero_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_rank_tier",
            |m: &CMsgDraftTrivia| { &m.match_rank_tier },
            |m: &mut CMsgDraftTrivia| { &mut m.match_rank_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_time",
            |m: &CMsgDraftTrivia| { &m.end_time },
            |m: &mut CMsgDraftTrivia| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgDraftTrivia| { &m.event_id },
            |m: &mut CMsgDraftTrivia| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_match_voted_radiant",
            |m: &CMsgDraftTrivia| { &m.current_match_voted_radiant },
            |m: &mut CMsgDraftTrivia| { &mut m.current_match_voted_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_draft_trivia::PreviousResult>(
            "previous_result",
            |m: &CMsgDraftTrivia| { &m.previous_result },
            |m: &mut CMsgDraftTrivia| { &mut m.previous_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_streak",
            |m: &CMsgDraftTrivia| { &m.current_streak },
            |m: &mut CMsgDraftTrivia| { &mut m.current_streak },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDraftTrivia>(
            "CMsgDraftTrivia",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDraftTrivia {
    const NAME: &'static str = "CMsgDraftTrivia";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_valid_match = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_hero_info)?;
                },
                24 => {
                    self.match_rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.current_match_voted_radiant = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.previous_result)?;
                },
                64 => {
                    self.current_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_valid_match {
            my_size += 1 + 1;
        }
        if let Some(v) = self.match_hero_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_rank_tier {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.end_time {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.current_match_voted_radiant {
            my_size += 1 + 1;
        }
        if let Some(v) = self.previous_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_streak {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.has_valid_match {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.match_hero_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.match_rank_tier {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.current_match_voted_radiant {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.previous_result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.current_streak {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDraftTrivia {
        CMsgDraftTrivia::new()
    }

    fn clear(&mut self) {
        self.has_valid_match = ::std::option::Option::None;
        self.match_hero_info.clear();
        self.match_rank_tier = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.current_match_voted_radiant = ::std::option::Option::None;
        self.previous_result.clear();
        self.current_streak = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDraftTrivia {
        static instance: CMsgDraftTrivia = CMsgDraftTrivia {
            has_valid_match: ::std::option::Option::None,
            match_hero_info: ::protobuf::MessageField::none(),
            match_rank_tier: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            current_match_voted_radiant: ::std::option::Option::None,
            previous_result: ::protobuf::MessageField::none(),
            current_streak: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDraftTrivia {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDraftTrivia").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDraftTrivia {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDraftTrivia {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDraftTrivia`
pub mod cmsg_draft_trivia {
    // @@protoc_insertion_point(message:dota.CMsgDraftTrivia.DraftTriviaHeroInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DraftTriviaHeroInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.DraftTriviaHeroInfo.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.DraftTriviaHeroInfo.role)
        pub role: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDraftTrivia.DraftTriviaHeroInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DraftTriviaHeroInfo {
        fn default() -> &'a DraftTriviaHeroInfo {
            <DraftTriviaHeroInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl DraftTriviaHeroInfo {
        pub fn new() -> DraftTriviaHeroInfo {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 role = 2;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &DraftTriviaHeroInfo| { &m.hero_id },
                |m: &mut DraftTriviaHeroInfo| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "role",
                |m: &DraftTriviaHeroInfo| { &m.role },
                |m: &mut DraftTriviaHeroInfo| { &mut m.role },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DraftTriviaHeroInfo>(
                "CMsgDraftTrivia.DraftTriviaHeroInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DraftTriviaHeroInfo {
        const NAME: &'static str = "DraftTriviaHeroInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.role {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DraftTriviaHeroInfo {
            DraftTriviaHeroInfo::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DraftTriviaHeroInfo {
            static instance: DraftTriviaHeroInfo = DraftTriviaHeroInfo {
                hero_id: ::std::option::Option::None,
                role: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DraftTriviaHeroInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDraftTrivia.DraftTriviaHeroInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DraftTriviaHeroInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DraftTriviaHeroInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDraftTrivia.DraftTriviaMatchInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DraftTriviaMatchInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.DraftTriviaMatchInfo.radiant_heroes)
        pub radiant_heroes: ::std::vec::Vec<DraftTriviaHeroInfo>,
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.DraftTriviaMatchInfo.dire_heroes)
        pub dire_heroes: ::std::vec::Vec<DraftTriviaHeroInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDraftTrivia.DraftTriviaMatchInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DraftTriviaMatchInfo {
        fn default() -> &'a DraftTriviaMatchInfo {
            <DraftTriviaMatchInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl DraftTriviaMatchInfo {
        pub fn new() -> DraftTriviaMatchInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "radiant_heroes",
                |m: &DraftTriviaMatchInfo| { &m.radiant_heroes },
                |m: &mut DraftTriviaMatchInfo| { &mut m.radiant_heroes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dire_heroes",
                |m: &DraftTriviaMatchInfo| { &m.dire_heroes },
                |m: &mut DraftTriviaMatchInfo| { &mut m.dire_heroes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DraftTriviaMatchInfo>(
                "CMsgDraftTrivia.DraftTriviaMatchInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DraftTriviaMatchInfo {
        const NAME: &'static str = "DraftTriviaMatchInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.radiant_heroes.push(is.read_message()?);
                    },
                    18 => {
                        self.dire_heroes.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.radiant_heroes {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.dire_heroes {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.radiant_heroes {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.dire_heroes {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DraftTriviaMatchInfo {
            DraftTriviaMatchInfo::new()
        }

        fn clear(&mut self) {
            self.radiant_heroes.clear();
            self.dire_heroes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DraftTriviaMatchInfo {
            static instance: DraftTriviaMatchInfo = DraftTriviaMatchInfo {
                radiant_heroes: ::std::vec::Vec::new(),
                dire_heroes: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DraftTriviaMatchInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDraftTrivia.DraftTriviaMatchInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DraftTriviaMatchInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DraftTriviaMatchInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDraftTrivia.PreviousResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PreviousResult {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.PreviousResult.voted_correctly)
        pub voted_correctly: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.PreviousResult.voted_radiant)
        pub voted_radiant: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.PreviousResult.match_hero_info)
        pub match_hero_info: ::protobuf::MessageField<DraftTriviaMatchInfo>,
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.PreviousResult.match_rank_tier)
        pub match_rank_tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.PreviousResult.end_time)
        pub end_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDraftTrivia.PreviousResult.match_id)
        pub match_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDraftTrivia.PreviousResult.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PreviousResult {
        fn default() -> &'a PreviousResult {
            <PreviousResult as ::protobuf::Message>::default_instance()
        }
    }

    impl PreviousResult {
        pub fn new() -> PreviousResult {
            ::std::default::Default::default()
        }

        // optional bool voted_correctly = 1;

        pub fn voted_correctly(&self) -> bool {
            self.voted_correctly.unwrap_or(false)
        }

        pub fn clear_voted_correctly(&mut self) {
            self.voted_correctly = ::std::option::Option::None;
        }

        pub fn has_voted_correctly(&self) -> bool {
            self.voted_correctly.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voted_correctly(&mut self, v: bool) {
            self.voted_correctly = ::std::option::Option::Some(v);
        }

        // optional bool voted_radiant = 2;

        pub fn voted_radiant(&self) -> bool {
            self.voted_radiant.unwrap_or(false)
        }

        pub fn clear_voted_radiant(&mut self) {
            self.voted_radiant = ::std::option::Option::None;
        }

        pub fn has_voted_radiant(&self) -> bool {
            self.voted_radiant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voted_radiant(&mut self, v: bool) {
            self.voted_radiant = ::std::option::Option::Some(v);
        }

        // optional uint32 match_rank_tier = 4;

        pub fn match_rank_tier(&self) -> u32 {
            self.match_rank_tier.unwrap_or(0)
        }

        pub fn clear_match_rank_tier(&mut self) {
            self.match_rank_tier = ::std::option::Option::None;
        }

        pub fn has_match_rank_tier(&self) -> bool {
            self.match_rank_tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_rank_tier(&mut self, v: u32) {
            self.match_rank_tier = ::std::option::Option::Some(v);
        }

        // optional uint32 end_time = 5;

        pub fn end_time(&self) -> u32 {
            self.end_time.unwrap_or(0)
        }

        pub fn clear_end_time(&mut self) {
            self.end_time = ::std::option::Option::None;
        }

        pub fn has_end_time(&self) -> bool {
            self.end_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_time(&mut self, v: u32) {
            self.end_time = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 6;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voted_correctly",
                |m: &PreviousResult| { &m.voted_correctly },
                |m: &mut PreviousResult| { &mut m.voted_correctly },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voted_radiant",
                |m: &PreviousResult| { &m.voted_radiant },
                |m: &mut PreviousResult| { &mut m.voted_radiant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DraftTriviaMatchInfo>(
                "match_hero_info",
                |m: &PreviousResult| { &m.match_hero_info },
                |m: &mut PreviousResult| { &mut m.match_hero_info },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_rank_tier",
                |m: &PreviousResult| { &m.match_rank_tier },
                |m: &mut PreviousResult| { &mut m.match_rank_tier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "end_time",
                |m: &PreviousResult| { &m.end_time },
                |m: &mut PreviousResult| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &PreviousResult| { &m.match_id },
                |m: &mut PreviousResult| { &mut m.match_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PreviousResult>(
                "CMsgDraftTrivia.PreviousResult",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PreviousResult {
        const NAME: &'static str = "PreviousResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.voted_correctly = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.voted_radiant = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_hero_info)?;
                    },
                    32 => {
                        self.match_rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.voted_correctly {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voted_radiant {
                my_size += 1 + 1;
            }
            if let Some(v) = self.match_hero_info.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.match_rank_tier {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.end_time {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.voted_correctly {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.voted_radiant {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.match_hero_info.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.match_rank_tier {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.end_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PreviousResult {
            PreviousResult::new()
        }

        fn clear(&mut self) {
            self.voted_correctly = ::std::option::Option::None;
            self.voted_radiant = ::std::option::Option::None;
            self.match_hero_info.clear();
            self.match_rank_tier = ::std::option::Option::None;
            self.end_time = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PreviousResult {
            static instance: PreviousResult = PreviousResult {
                voted_correctly: ::std::option::Option::None,
                voted_radiant: ::std::option::Option::None,
                match_hero_info: ::protobuf::MessageField::none(),
                match_rank_tier: ::std::option::Option::None,
                end_time: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PreviousResult {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDraftTrivia.PreviousResult").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PreviousResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PreviousResult {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgTeamFanContentAssetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentAssetStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAssetStatus.asset_type)
    pub asset_type: ::std::option::Option<::protobuf::EnumOrUnknown<ETeamFanContentAssetType>>,
    // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAssetStatus.asset_index)
    pub asset_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAssetStatus.asset_status)
    pub asset_status: ::std::option::Option<::protobuf::EnumOrUnknown<ETeamFanContentAssetStatus>>,
    // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAssetStatus.crc)
    pub crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTeamFanContentAssetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentAssetStatus {
    fn default() -> &'a CMsgTeamFanContentAssetStatus {
        <CMsgTeamFanContentAssetStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentAssetStatus {
    pub fn new() -> CMsgTeamFanContentAssetStatus {
        ::std::default::Default::default()
    }

    // optional .dota.ETeamFanContentAssetType asset_type = 1;

    pub fn asset_type(&self) -> ETeamFanContentAssetType {
        match self.asset_type {
            Some(e) => e.enum_value_or(ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG),
            None => ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG,
        }
    }

    pub fn clear_asset_type(&mut self) {
        self.asset_type = ::std::option::Option::None;
    }

    pub fn has_asset_type(&self) -> bool {
        self.asset_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_type(&mut self, v: ETeamFanContentAssetType) {
        self.asset_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 asset_index = 2;

    pub fn asset_index(&self) -> u32 {
        self.asset_index.unwrap_or(0)
    }

    pub fn clear_asset_index(&mut self) {
        self.asset_index = ::std::option::Option::None;
    }

    pub fn has_asset_index(&self) -> bool {
        self.asset_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_index(&mut self, v: u32) {
        self.asset_index = ::std::option::Option::Some(v);
    }

    // optional .dota.ETeamFanContentAssetStatus asset_status = 3;

    pub fn asset_status(&self) -> ETeamFanContentAssetStatus {
        match self.asset_status {
            Some(e) => e.enum_value_or(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None),
            None => ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None,
        }
    }

    pub fn clear_asset_status(&mut self) {
        self.asset_status = ::std::option::Option::None;
    }

    pub fn has_asset_status(&self) -> bool {
        self.asset_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_status(&mut self, v: ETeamFanContentAssetStatus) {
        self.asset_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 crc = 4;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "asset_type",
            |m: &CMsgTeamFanContentAssetStatus| { &m.asset_type },
            |m: &mut CMsgTeamFanContentAssetStatus| { &mut m.asset_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "asset_index",
            |m: &CMsgTeamFanContentAssetStatus| { &m.asset_index },
            |m: &mut CMsgTeamFanContentAssetStatus| { &mut m.asset_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "asset_status",
            |m: &CMsgTeamFanContentAssetStatus| { &m.asset_status },
            |m: &mut CMsgTeamFanContentAssetStatus| { &mut m.asset_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CMsgTeamFanContentAssetStatus| { &m.crc },
            |m: &mut CMsgTeamFanContentAssetStatus| { &mut m.crc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTeamFanContentAssetStatus>(
            "CMsgTeamFanContentAssetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTeamFanContentAssetStatus {
    const NAME: &'static str = "CMsgTeamFanContentAssetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.asset_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.asset_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.asset_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.asset_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.asset_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.asset_status {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.asset_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.asset_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.asset_status {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.crc {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentAssetStatus {
        CMsgTeamFanContentAssetStatus::new()
    }

    fn clear(&mut self) {
        self.asset_type = ::std::option::Option::None;
        self.asset_index = ::std::option::Option::None;
        self.asset_status = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentAssetStatus {
        static instance: CMsgTeamFanContentAssetStatus = CMsgTeamFanContentAssetStatus {
            asset_type: ::std::option::Option::None,
            asset_index: ::std::option::Option::None,
            asset_status: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTeamFanContentAssetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTeamFanContentAssetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTeamFanContentAssetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTeamFanContentAssetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgTeamFanContentAssetStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentAssetStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAssetStatusResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_team_fan_content_asset_status_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTeamFanContentAssetStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentAssetStatusResponse {
    fn default() -> &'a CMsgTeamFanContentAssetStatusResponse {
        <CMsgTeamFanContentAssetStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentAssetStatusResponse {
    pub fn new() -> CMsgTeamFanContentAssetStatusResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgTeamFanContentAssetStatusResponse.EResult result = 1;

    pub fn result(&self) -> cmsg_team_fan_content_asset_status_response::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_team_fan_content_asset_status_response::EResult::k_eSuccess),
            None => cmsg_team_fan_content_asset_status_response::EResult::k_eSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_team_fan_content_asset_status_response::EResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgTeamFanContentAssetStatusResponse| { &m.result },
            |m: &mut CMsgTeamFanContentAssetStatusResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTeamFanContentAssetStatusResponse>(
            "CMsgTeamFanContentAssetStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTeamFanContentAssetStatusResponse {
    const NAME: &'static str = "CMsgTeamFanContentAssetStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentAssetStatusResponse {
        CMsgTeamFanContentAssetStatusResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentAssetStatusResponse {
        static instance: CMsgTeamFanContentAssetStatusResponse = CMsgTeamFanContentAssetStatusResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTeamFanContentAssetStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTeamFanContentAssetStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTeamFanContentAssetStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTeamFanContentAssetStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgTeamFanContentAssetStatusResponse`
pub mod cmsg_team_fan_content_asset_status_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgTeamFanContentAssetStatusResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:dota.CMsgTeamFanContentAssetStatusResponse.EResult.k_eSuccess)
        k_eSuccess = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgTeamFanContentAssetStatusResponse.EResult.k_eInternalError)
        k_eInternalError = 1,
    }

    impl ::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_eSuccess),
                1 => ::std::option::Option::Some(EResult::k_eInternalError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_eSuccess" => ::std::option::Option::Some(EResult::k_eSuccess),
                "k_eInternalError" => ::std::option::Option::Some(EResult::k_eInternalError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_eSuccess,
            EResult::k_eInternalError,
        ];
    }

    impl ::protobuf::EnumFull for EResult {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgTeamFanContentAssetStatusResponse.EResult").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_eSuccess
        }
    }

    impl EResult {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResult>("CMsgTeamFanContentAssetStatusResponse.EResult")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgTeamFanContentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.team_status_list)
    pub team_status_list: ::std::vec::Vec<cmsg_team_fan_content_status::TeamStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTeamFanContentStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentStatus {
    fn default() -> &'a CMsgTeamFanContentStatus {
        <CMsgTeamFanContentStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentStatus {
    pub fn new() -> CMsgTeamFanContentStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_status_list",
            |m: &CMsgTeamFanContentStatus| { &m.team_status_list },
            |m: &mut CMsgTeamFanContentStatus| { &mut m.team_status_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTeamFanContentStatus>(
            "CMsgTeamFanContentStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTeamFanContentStatus {
    const NAME: &'static str = "CMsgTeamFanContentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.team_status_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.team_status_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.team_status_list {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentStatus {
        CMsgTeamFanContentStatus::new()
    }

    fn clear(&mut self) {
        self.team_status_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentStatus {
        static instance: CMsgTeamFanContentStatus = CMsgTeamFanContentStatus {
            team_status_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTeamFanContentStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTeamFanContentStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTeamFanContentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTeamFanContentStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgTeamFanContentStatus`
pub mod cmsg_team_fan_content_status {
    // @@protoc_insertion_point(message:dota.CMsgTeamFanContentStatus.TeamStatus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamStatus {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.logo_url)
        pub logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.status)
        pub status: ::std::option::Option<::protobuf::EnumOrUnknown<super::ETeamFanContentStatus>>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.ugc_logo)
        pub ugc_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.workshop_account_id)
        pub workshop_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.abbreviation)
        pub abbreviation: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.voiceline_count)
        pub voiceline_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.spray_count)
        pub spray_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.emoticon_count)
        pub emoticon_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.wallpaper_count)
        pub wallpaper_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.comment)
        pub comment: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.comment_timestamp)
        pub comment_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.asset_status)
        pub asset_status: ::std::vec::Vec<super::CMsgTeamFanContentAssetStatus>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.email_timestamp)
        pub email_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.email_tier)
        pub email_tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentStatus.TeamStatus.languages)
        pub languages: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgTeamFanContentStatus.TeamStatus.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStatus {
        fn default() -> &'a TeamStatus {
            <TeamStatus as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamStatus {
        pub fn new() -> TeamStatus {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string logo_url = 3;

        pub fn logo_url(&self) -> &str {
            match self.logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_logo_url(&mut self) {
            self.logo_url = ::std::option::Option::None;
        }

        pub fn has_logo_url(&self) -> bool {
            self.logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_logo_url(&mut self, v: ::std::string::String) {
            self.logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_logo_url(&mut self) -> &mut ::std::string::String {
            if self.logo_url.is_none() {
                self.logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_logo_url(&mut self) -> ::std::string::String {
            self.logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .dota.ETeamFanContentStatus status = 4;

        pub fn status(&self) -> super::ETeamFanContentStatus {
            match self.status {
                Some(e) => e.enum_value_or(super::ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID),
                None => super::ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID,
            }
        }

        pub fn clear_status(&mut self) {
            self.status = ::std::option::Option::None;
        }

        pub fn has_status(&self) -> bool {
            self.status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_status(&mut self, v: super::ETeamFanContentStatus) {
            self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 timestamp = 5;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint64 ugc_logo = 7;

        pub fn ugc_logo(&self) -> u64 {
            self.ugc_logo.unwrap_or(0)
        }

        pub fn clear_ugc_logo(&mut self) {
            self.ugc_logo = ::std::option::Option::None;
        }

        pub fn has_ugc_logo(&self) -> bool {
            self.ugc_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ugc_logo(&mut self, v: u64) {
            self.ugc_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 workshop_account_id = 8;

        pub fn workshop_account_id(&self) -> u32 {
            self.workshop_account_id.unwrap_or(0)
        }

        pub fn clear_workshop_account_id(&mut self) {
            self.workshop_account_id = ::std::option::Option::None;
        }

        pub fn has_workshop_account_id(&self) -> bool {
            self.workshop_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_account_id(&mut self, v: u32) {
            self.workshop_account_id = ::std::option::Option::Some(v);
        }

        // optional string abbreviation = 9;

        pub fn abbreviation(&self) -> &str {
            match self.abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_abbreviation(&mut self) {
            self.abbreviation = ::std::option::Option::None;
        }

        pub fn has_abbreviation(&self) -> bool {
            self.abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_abbreviation(&mut self, v: ::std::string::String) {
            self.abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.abbreviation.is_none() {
                self.abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_abbreviation(&mut self) -> ::std::string::String {
            self.abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 voiceline_count = 10;

        pub fn voiceline_count(&self) -> u32 {
            self.voiceline_count.unwrap_or(0)
        }

        pub fn clear_voiceline_count(&mut self) {
            self.voiceline_count = ::std::option::Option::None;
        }

        pub fn has_voiceline_count(&self) -> bool {
            self.voiceline_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voiceline_count(&mut self, v: u32) {
            self.voiceline_count = ::std::option::Option::Some(v);
        }

        // optional uint32 spray_count = 11;

        pub fn spray_count(&self) -> u32 {
            self.spray_count.unwrap_or(0)
        }

        pub fn clear_spray_count(&mut self) {
            self.spray_count = ::std::option::Option::None;
        }

        pub fn has_spray_count(&self) -> bool {
            self.spray_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spray_count(&mut self, v: u32) {
            self.spray_count = ::std::option::Option::Some(v);
        }

        // optional uint32 emoticon_count = 12;

        pub fn emoticon_count(&self) -> u32 {
            self.emoticon_count.unwrap_or(0)
        }

        pub fn clear_emoticon_count(&mut self) {
            self.emoticon_count = ::std::option::Option::None;
        }

        pub fn has_emoticon_count(&self) -> bool {
            self.emoticon_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_emoticon_count(&mut self, v: u32) {
            self.emoticon_count = ::std::option::Option::Some(v);
        }

        // optional uint32 wallpaper_count = 13;

        pub fn wallpaper_count(&self) -> u32 {
            self.wallpaper_count.unwrap_or(0)
        }

        pub fn clear_wallpaper_count(&mut self) {
            self.wallpaper_count = ::std::option::Option::None;
        }

        pub fn has_wallpaper_count(&self) -> bool {
            self.wallpaper_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wallpaper_count(&mut self, v: u32) {
            self.wallpaper_count = ::std::option::Option::Some(v);
        }

        // optional string comment = 14;

        pub fn comment(&self) -> &str {
            match self.comment.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_comment(&mut self) {
            self.comment = ::std::option::Option::None;
        }

        pub fn has_comment(&self) -> bool {
            self.comment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comment(&mut self, v: ::std::string::String) {
            self.comment = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_comment(&mut self) -> &mut ::std::string::String {
            if self.comment.is_none() {
                self.comment = ::std::option::Option::Some(::std::string::String::new());
            }
            self.comment.as_mut().unwrap()
        }

        // Take field
        pub fn take_comment(&mut self) -> ::std::string::String {
            self.comment.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 comment_timestamp = 15;

        pub fn comment_timestamp(&self) -> u32 {
            self.comment_timestamp.unwrap_or(0)
        }

        pub fn clear_comment_timestamp(&mut self) {
            self.comment_timestamp = ::std::option::Option::None;
        }

        pub fn has_comment_timestamp(&self) -> bool {
            self.comment_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comment_timestamp(&mut self, v: u32) {
            self.comment_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 email_timestamp = 17;

        pub fn email_timestamp(&self) -> u32 {
            self.email_timestamp.unwrap_or(0)
        }

        pub fn clear_email_timestamp(&mut self) {
            self.email_timestamp = ::std::option::Option::None;
        }

        pub fn has_email_timestamp(&self) -> bool {
            self.email_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_email_timestamp(&mut self, v: u32) {
            self.email_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 email_tier = 18;

        pub fn email_tier(&self) -> u32 {
            self.email_tier.unwrap_or(0)
        }

        pub fn clear_email_tier(&mut self) {
            self.email_tier = ::std::option::Option::None;
        }

        pub fn has_email_tier(&self) -> bool {
            self.email_tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_email_tier(&mut self, v: u32) {
            self.email_tier = ::std::option::Option::Some(v);
        }

        // optional string languages = 19;

        pub fn languages(&self) -> &str {
            match self.languages.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_languages(&mut self) {
            self.languages = ::std::option::Option::None;
        }

        pub fn has_languages(&self) -> bool {
            self.languages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_languages(&mut self, v: ::std::string::String) {
            self.languages = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_languages(&mut self) -> &mut ::std::string::String {
            if self.languages.is_none() {
                self.languages = ::std::option::Option::Some(::std::string::String::new());
            }
            self.languages.as_mut().unwrap()
        }

        // Take field
        pub fn take_languages(&mut self) -> ::std::string::String {
            self.languages.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(18);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &TeamStatus| { &m.name },
                |m: &mut TeamStatus| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &TeamStatus| { &m.team_id },
                |m: &mut TeamStatus| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "logo_url",
                |m: &TeamStatus| { &m.logo_url },
                |m: &mut TeamStatus| { &mut m.logo_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "status",
                |m: &TeamStatus| { &m.status },
                |m: &mut TeamStatus| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &TeamStatus| { &m.timestamp },
                |m: &mut TeamStatus| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ugc_logo",
                |m: &TeamStatus| { &m.ugc_logo },
                |m: &mut TeamStatus| { &mut m.ugc_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "workshop_account_id",
                |m: &TeamStatus| { &m.workshop_account_id },
                |m: &mut TeamStatus| { &mut m.workshop_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "abbreviation",
                |m: &TeamStatus| { &m.abbreviation },
                |m: &mut TeamStatus| { &mut m.abbreviation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voiceline_count",
                |m: &TeamStatus| { &m.voiceline_count },
                |m: &mut TeamStatus| { &mut m.voiceline_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "spray_count",
                |m: &TeamStatus| { &m.spray_count },
                |m: &mut TeamStatus| { &mut m.spray_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "emoticon_count",
                |m: &TeamStatus| { &m.emoticon_count },
                |m: &mut TeamStatus| { &mut m.emoticon_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wallpaper_count",
                |m: &TeamStatus| { &m.wallpaper_count },
                |m: &mut TeamStatus| { &mut m.wallpaper_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "comment",
                |m: &TeamStatus| { &m.comment },
                |m: &mut TeamStatus| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "comment_timestamp",
                |m: &TeamStatus| { &m.comment_timestamp },
                |m: &mut TeamStatus| { &mut m.comment_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "asset_status",
                |m: &TeamStatus| { &m.asset_status },
                |m: &mut TeamStatus| { &mut m.asset_status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "email_timestamp",
                |m: &TeamStatus| { &m.email_timestamp },
                |m: &mut TeamStatus| { &mut m.email_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "email_tier",
                |m: &TeamStatus| { &m.email_tier },
                |m: &mut TeamStatus| { &mut m.email_tier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "languages",
                |m: &TeamStatus| { &m.languages },
                |m: &mut TeamStatus| { &mut m.languages },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamStatus>(
                "CMsgTeamFanContentStatus.TeamStatus",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamStatus {
        const NAME: &'static str = "TeamStatus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    40 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.ugc_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.workshop_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    74 => {
                        self.abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.voiceline_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.spray_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.emoticon_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.wallpaper_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    114 => {
                        self.comment = ::std::option::Option::Some(is.read_string()?);
                    },
                    120 => {
                        self.comment_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    130 => {
                        self.asset_status.push(is.read_message()?);
                    },
                    136 => {
                        self.email_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.email_tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    154 => {
                        self.languages = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.status {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.ugc_logo {
                my_size += ::protobuf::rt::uint64_size(7, v);
            }
            if let Some(v) = self.workshop_account_id {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.abbreviation.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.voiceline_count {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.spray_count {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.emoticon_count {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.wallpaper_count {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.comment.as_ref() {
                my_size += ::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.comment_timestamp {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            for value in &self.asset_status {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.email_timestamp {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.email_tier {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.languages.as_ref() {
                my_size += ::protobuf::rt::string_size(19, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.logo_url.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.status {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.ugc_logo {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.workshop_account_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.abbreviation.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.voiceline_count {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.spray_count {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.emoticon_count {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.wallpaper_count {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.comment.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.comment_timestamp {
                os.write_uint32(15, v)?;
            }
            for v in &self.asset_status {
                ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
            };
            if let Some(v) = self.email_timestamp {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.email_tier {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.languages.as_ref() {
                os.write_string(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStatus {
            TeamStatus::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.logo_url = ::std::option::Option::None;
            self.status = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.ugc_logo = ::std::option::Option::None;
            self.workshop_account_id = ::std::option::Option::None;
            self.abbreviation = ::std::option::Option::None;
            self.voiceline_count = ::std::option::Option::None;
            self.spray_count = ::std::option::Option::None;
            self.emoticon_count = ::std::option::Option::None;
            self.wallpaper_count = ::std::option::Option::None;
            self.comment = ::std::option::Option::None;
            self.comment_timestamp = ::std::option::Option::None;
            self.asset_status.clear();
            self.email_timestamp = ::std::option::Option::None;
            self.email_tier = ::std::option::Option::None;
            self.languages = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStatus {
            static instance: TeamStatus = TeamStatus {
                name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                logo_url: ::std::option::Option::None,
                status: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                ugc_logo: ::std::option::Option::None,
                workshop_account_id: ::std::option::Option::None,
                abbreviation: ::std::option::Option::None,
                voiceline_count: ::std::option::Option::None,
                spray_count: ::std::option::Option::None,
                emoticon_count: ::std::option::Option::None,
                wallpaper_count: ::std::option::Option::None,
                comment: ::std::option::Option::None,
                comment_timestamp: ::std::option::Option::None,
                asset_status: ::std::vec::Vec::new(),
                email_timestamp: ::std::option::Option::None,
                email_tier: ::std::option::Option::None,
                languages: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamStatus {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgTeamFanContentStatus.TeamStatus").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamStatus {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgTeamFanContentAutographStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentAutographStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.team_autographs)
    pub team_autographs: ::std::vec::Vec<cmsg_team_fan_content_autograph_status::TeamStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgTeamFanContentAutographStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentAutographStatus {
    fn default() -> &'a CMsgTeamFanContentAutographStatus {
        <CMsgTeamFanContentAutographStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentAutographStatus {
    pub fn new() -> CMsgTeamFanContentAutographStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_autographs",
            |m: &CMsgTeamFanContentAutographStatus| { &m.team_autographs },
            |m: &mut CMsgTeamFanContentAutographStatus| { &mut m.team_autographs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTeamFanContentAutographStatus>(
            "CMsgTeamFanContentAutographStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTeamFanContentAutographStatus {
    const NAME: &'static str = "CMsgTeamFanContentAutographStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.team_autographs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.team_autographs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.team_autographs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentAutographStatus {
        CMsgTeamFanContentAutographStatus::new()
    }

    fn clear(&mut self) {
        self.team_autographs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentAutographStatus {
        static instance: CMsgTeamFanContentAutographStatus = CMsgTeamFanContentAutographStatus {
            team_autographs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTeamFanContentAutographStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTeamFanContentAutographStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTeamFanContentAutographStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTeamFanContentAutographStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgTeamFanContentAutographStatus`
pub mod cmsg_team_fan_content_autograph_status {
    // @@protoc_insertion_point(message:dota.CMsgTeamFanContentAutographStatus.AutographStatus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutographStatus {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.AutographStatus.pro_name)
        pub pro_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.AutographStatus.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.AutographStatus.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.AutographStatus.file)
        pub file: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgTeamFanContentAutographStatus.AutographStatus.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutographStatus {
        fn default() -> &'a AutographStatus {
            <AutographStatus as ::protobuf::Message>::default_instance()
        }
    }

    impl AutographStatus {
        pub fn new() -> AutographStatus {
            ::std::default::Default::default()
        }

        // optional string pro_name = 1;

        pub fn pro_name(&self) -> &str {
            match self.pro_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_pro_name(&mut self) {
            self.pro_name = ::std::option::Option::None;
        }

        pub fn has_pro_name(&self) -> bool {
            self.pro_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_name(&mut self, v: ::std::string::String) {
            self.pro_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_pro_name(&mut self) -> &mut ::std::string::String {
            if self.pro_name.is_none() {
                self.pro_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.pro_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_pro_name(&mut self) -> ::std::string::String {
            self.pro_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string file = 4;

        pub fn file(&self) -> &str {
            match self.file.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_file(&mut self) {
            self.file = ::std::option::Option::None;
        }

        pub fn has_file(&self) -> bool {
            self.file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file(&mut self, v: ::std::string::String) {
            self.file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_file(&mut self) -> &mut ::std::string::String {
            if self.file.is_none() {
                self.file = ::std::option::Option::Some(::std::string::String::new());
            }
            self.file.as_mut().unwrap()
        }

        // Take field
        pub fn take_file(&mut self) -> ::std::string::String {
            self.file.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pro_name",
                |m: &AutographStatus| { &m.pro_name },
                |m: &mut AutographStatus| { &mut m.pro_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &AutographStatus| { &m.account_id },
                |m: &mut AutographStatus| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &AutographStatus| { &m.timestamp },
                |m: &mut AutographStatus| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "file",
                |m: &AutographStatus| { &m.file },
                |m: &mut AutographStatus| { &mut m.file },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutographStatus>(
                "CMsgTeamFanContentAutographStatus.AutographStatus",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AutographStatus {
        const NAME: &'static str = "AutographStatus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.pro_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.file = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pro_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.file.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.pro_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.file.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutographStatus {
            AutographStatus::new()
        }

        fn clear(&mut self) {
            self.pro_name = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.file = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutographStatus {
            static instance: AutographStatus = AutographStatus {
                pro_name: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                file: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AutographStatus {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgTeamFanContentAutographStatus.AutographStatus").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AutographStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutographStatus {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgTeamFanContentAutographStatus.TeamStatus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamStatus {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.TeamStatus.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.TeamStatus.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.TeamStatus.autographs)
        pub autographs: ::std::vec::Vec<AutographStatus>,
        // @@protoc_insertion_point(field:dota.CMsgTeamFanContentAutographStatus.TeamStatus.workshop_account_id)
        pub workshop_account_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgTeamFanContentAutographStatus.TeamStatus.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStatus {
        fn default() -> &'a TeamStatus {
            <TeamStatus as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamStatus {
        pub fn new() -> TeamStatus {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 workshop_account_id = 4;

        pub fn workshop_account_id(&self) -> u32 {
            self.workshop_account_id.unwrap_or(0)
        }

        pub fn clear_workshop_account_id(&mut self) {
            self.workshop_account_id = ::std::option::Option::None;
        }

        pub fn has_workshop_account_id(&self) -> bool {
            self.workshop_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_account_id(&mut self, v: u32) {
            self.workshop_account_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &TeamStatus| { &m.name },
                |m: &mut TeamStatus| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &TeamStatus| { &m.team_id },
                |m: &mut TeamStatus| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "autographs",
                |m: &TeamStatus| { &m.autographs },
                |m: &mut TeamStatus| { &mut m.autographs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "workshop_account_id",
                |m: &TeamStatus| { &m.workshop_account_id },
                |m: &mut TeamStatus| { &mut m.workshop_account_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamStatus>(
                "CMsgTeamFanContentAutographStatus.TeamStatus",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamStatus {
        const NAME: &'static str = "TeamStatus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.autographs.push(is.read_message()?);
                    },
                    32 => {
                        self.workshop_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.autographs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.workshop_account_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            for v in &self.autographs {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.workshop_account_id {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStatus {
            TeamStatus::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.autographs.clear();
            self.workshop_account_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStatus {
            static instance: TeamStatus = TeamStatus {
                name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                autographs: ::std::vec::Vec::new(),
                workshop_account_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamStatus {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgTeamFanContentAutographStatus.TeamStatus").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamStatus {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDPCEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPCEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.event)
    pub event: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_dpcevent::ELeagueEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.event_type)
    pub event_type: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_dpcevent::ELeagueEventType>>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.leagues)
    pub leagues: ::std::vec::Vec<cmsg_dpcevent::League>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.registration_period)
    pub registration_period: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.is_event_upcoming)
    pub is_event_upcoming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.is_event_completed)
    pub is_event_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.multicast_league_id)
    pub multicast_league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.multicast_streams)
    pub multicast_streams: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.tour)
    pub tour: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_dpcevent::ETour>>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.timestamp_drop_lock)
    pub timestamp_drop_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.timestamp_add_lock)
    pub timestamp_add_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.timestamp_content_deadline)
    pub timestamp_content_deadline: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.is_fantasy_enabled)
    pub is_fantasy_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDPCEvent.timestamp_content_review_deadline)
    pub timestamp_content_review_deadline: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDPCEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPCEvent {
    fn default() -> &'a CMsgDPCEvent {
        <CMsgDPCEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPCEvent {
    pub fn new() -> CMsgDPCEvent {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgDPCEvent.ELeagueEvent event = 1;

    pub fn event(&self) -> cmsg_dpcevent::ELeagueEvent {
        match self.event {
            Some(e) => e.enum_value_or(cmsg_dpcevent::ELeagueEvent::EVENT_INVALID),
            None => cmsg_dpcevent::ELeagueEvent::EVENT_INVALID,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: cmsg_dpcevent::ELeagueEvent) {
        self.event = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.CMsgDPCEvent.ELeagueEventType event_type = 2;

    pub fn event_type(&self) -> cmsg_dpcevent::ELeagueEventType {
        match self.event_type {
            Some(e) => e.enum_value_or(cmsg_dpcevent::ELeagueEventType::UNKNOWN),
            None => cmsg_dpcevent::ELeagueEventType::UNKNOWN,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: cmsg_dpcevent::ELeagueEventType) {
        self.event_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 registration_period = 4;

    pub fn registration_period(&self) -> u32 {
        self.registration_period.unwrap_or(0)
    }

    pub fn clear_registration_period(&mut self) {
        self.registration_period = ::std::option::Option::None;
    }

    pub fn has_registration_period(&self) -> bool {
        self.registration_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_period(&mut self, v: u32) {
        self.registration_period = ::std::option::Option::Some(v);
    }

    // optional bool is_event_upcoming = 5;

    pub fn is_event_upcoming(&self) -> bool {
        self.is_event_upcoming.unwrap_or(false)
    }

    pub fn clear_is_event_upcoming(&mut self) {
        self.is_event_upcoming = ::std::option::Option::None;
    }

    pub fn has_is_event_upcoming(&self) -> bool {
        self.is_event_upcoming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_upcoming(&mut self, v: bool) {
        self.is_event_upcoming = ::std::option::Option::Some(v);
    }

    // optional bool is_event_completed = 6;

    pub fn is_event_completed(&self) -> bool {
        self.is_event_completed.unwrap_or(false)
    }

    pub fn clear_is_event_completed(&mut self) {
        self.is_event_completed = ::std::option::Option::None;
    }

    pub fn has_is_event_completed(&self) -> bool {
        self.is_event_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_completed(&mut self, v: bool) {
        self.is_event_completed = ::std::option::Option::Some(v);
    }

    // optional string event_name = 7;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 multicast_league_id = 8;

    pub fn multicast_league_id(&self) -> u32 {
        self.multicast_league_id.unwrap_or(0)
    }

    pub fn clear_multicast_league_id(&mut self) {
        self.multicast_league_id = ::std::option::Option::None;
    }

    pub fn has_multicast_league_id(&self) -> bool {
        self.multicast_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast_league_id(&mut self, v: u32) {
        self.multicast_league_id = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgDPCEvent.ETour tour = 10;

    pub fn tour(&self) -> cmsg_dpcevent::ETour {
        match self.tour {
            Some(e) => e.enum_value_or(cmsg_dpcevent::ETour::TOUR_NONE),
            None => cmsg_dpcevent::ETour::TOUR_NONE,
        }
    }

    pub fn clear_tour(&mut self) {
        self.tour = ::std::option::Option::None;
    }

    pub fn has_tour(&self) -> bool {
        self.tour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour(&mut self, v: cmsg_dpcevent::ETour) {
        self.tour = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp_drop_lock = 12;

    pub fn timestamp_drop_lock(&self) -> u32 {
        self.timestamp_drop_lock.unwrap_or(0)
    }

    pub fn clear_timestamp_drop_lock(&mut self) {
        self.timestamp_drop_lock = ::std::option::Option::None;
    }

    pub fn has_timestamp_drop_lock(&self) -> bool {
        self.timestamp_drop_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_drop_lock(&mut self, v: u32) {
        self.timestamp_drop_lock = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_add_lock = 13;

    pub fn timestamp_add_lock(&self) -> u32 {
        self.timestamp_add_lock.unwrap_or(0)
    }

    pub fn clear_timestamp_add_lock(&mut self) {
        self.timestamp_add_lock = ::std::option::Option::None;
    }

    pub fn has_timestamp_add_lock(&self) -> bool {
        self.timestamp_add_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_add_lock(&mut self, v: u32) {
        self.timestamp_add_lock = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_content_deadline = 14;

    pub fn timestamp_content_deadline(&self) -> u32 {
        self.timestamp_content_deadline.unwrap_or(0)
    }

    pub fn clear_timestamp_content_deadline(&mut self) {
        self.timestamp_content_deadline = ::std::option::Option::None;
    }

    pub fn has_timestamp_content_deadline(&self) -> bool {
        self.timestamp_content_deadline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_content_deadline(&mut self, v: u32) {
        self.timestamp_content_deadline = ::std::option::Option::Some(v);
    }

    // optional bool is_fantasy_enabled = 15;

    pub fn is_fantasy_enabled(&self) -> bool {
        self.is_fantasy_enabled.unwrap_or(false)
    }

    pub fn clear_is_fantasy_enabled(&mut self) {
        self.is_fantasy_enabled = ::std::option::Option::None;
    }

    pub fn has_is_fantasy_enabled(&self) -> bool {
        self.is_fantasy_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fantasy_enabled(&mut self, v: bool) {
        self.is_fantasy_enabled = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_content_review_deadline = 16;

    pub fn timestamp_content_review_deadline(&self) -> u32 {
        self.timestamp_content_review_deadline.unwrap_or(0)
    }

    pub fn clear_timestamp_content_review_deadline(&mut self) {
        self.timestamp_content_review_deadline = ::std::option::Option::None;
    }

    pub fn has_timestamp_content_review_deadline(&self) -> bool {
        self.timestamp_content_review_deadline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_content_review_deadline(&mut self, v: u32) {
        self.timestamp_content_review_deadline = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event",
            |m: &CMsgDPCEvent| { &m.event },
            |m: &mut CMsgDPCEvent| { &mut m.event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgDPCEvent| { &m.event_type },
            |m: &mut CMsgDPCEvent| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "leagues",
            |m: &CMsgDPCEvent| { &m.leagues },
            |m: &mut CMsgDPCEvent| { &mut m.leagues },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registration_period",
            |m: &CMsgDPCEvent| { &m.registration_period },
            |m: &mut CMsgDPCEvent| { &mut m.registration_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_event_upcoming",
            |m: &CMsgDPCEvent| { &m.is_event_upcoming },
            |m: &mut CMsgDPCEvent| { &mut m.is_event_upcoming },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_event_completed",
            |m: &CMsgDPCEvent| { &m.is_event_completed },
            |m: &mut CMsgDPCEvent| { &mut m.is_event_completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &CMsgDPCEvent| { &m.event_name },
            |m: &mut CMsgDPCEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multicast_league_id",
            |m: &CMsgDPCEvent| { &m.multicast_league_id },
            |m: &mut CMsgDPCEvent| { &mut m.multicast_league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multicast_streams",
            |m: &CMsgDPCEvent| { &m.multicast_streams },
            |m: &mut CMsgDPCEvent| { &mut m.multicast_streams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tour",
            |m: &CMsgDPCEvent| { &m.tour },
            |m: &mut CMsgDPCEvent| { &mut m.tour },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_drop_lock",
            |m: &CMsgDPCEvent| { &m.timestamp_drop_lock },
            |m: &mut CMsgDPCEvent| { &mut m.timestamp_drop_lock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_add_lock",
            |m: &CMsgDPCEvent| { &m.timestamp_add_lock },
            |m: &mut CMsgDPCEvent| { &mut m.timestamp_add_lock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_content_deadline",
            |m: &CMsgDPCEvent| { &m.timestamp_content_deadline },
            |m: &mut CMsgDPCEvent| { &mut m.timestamp_content_deadline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_fantasy_enabled",
            |m: &CMsgDPCEvent| { &m.is_fantasy_enabled },
            |m: &mut CMsgDPCEvent| { &mut m.is_fantasy_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_content_review_deadline",
            |m: &CMsgDPCEvent| { &m.timestamp_content_review_deadline },
            |m: &mut CMsgDPCEvent| { &mut m.timestamp_content_review_deadline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDPCEvent>(
            "CMsgDPCEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDPCEvent {
    const NAME: &'static str = "CMsgDPCEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.leagues.push(is.read_message()?);
                },
                32 => {
                    self.registration_period = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.is_event_upcoming = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_event_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.multicast_league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.multicast_streams)?;
                },
                72 => {
                    self.multicast_streams.push(is.read_uint32()?);
                },
                80 => {
                    self.tour = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.timestamp_drop_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.timestamp_add_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.timestamp_content_deadline = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.is_fantasy_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.timestamp_content_review_deadline = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.registration_period {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.is_event_upcoming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_event_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.multicast_league_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.multicast_streams {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.tour {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.timestamp_drop_lock {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.timestamp_add_lock {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.timestamp_content_deadline {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.is_fantasy_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp_content_review_deadline {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.leagues {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.registration_period {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_event_upcoming {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_event_completed {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.multicast_league_id {
            os.write_uint32(8, v)?;
        }
        for v in &self.multicast_streams {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.tour {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp_drop_lock {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.timestamp_add_lock {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.timestamp_content_deadline {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.is_fantasy_enabled {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.timestamp_content_review_deadline {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPCEvent {
        CMsgDPCEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.leagues.clear();
        self.registration_period = ::std::option::Option::None;
        self.is_event_upcoming = ::std::option::Option::None;
        self.is_event_completed = ::std::option::Option::None;
        self.event_name = ::std::option::Option::None;
        self.multicast_league_id = ::std::option::Option::None;
        self.multicast_streams.clear();
        self.tour = ::std::option::Option::None;
        self.timestamp_drop_lock = ::std::option::Option::None;
        self.timestamp_add_lock = ::std::option::Option::None;
        self.timestamp_content_deadline = ::std::option::Option::None;
        self.is_fantasy_enabled = ::std::option::Option::None;
        self.timestamp_content_review_deadline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPCEvent {
        static instance: CMsgDPCEvent = CMsgDPCEvent {
            event: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            leagues: ::std::vec::Vec::new(),
            registration_period: ::std::option::Option::None,
            is_event_upcoming: ::std::option::Option::None,
            is_event_completed: ::std::option::Option::None,
            event_name: ::std::option::Option::None,
            multicast_league_id: ::std::option::Option::None,
            multicast_streams: ::std::vec::Vec::new(),
            tour: ::std::option::Option::None,
            timestamp_drop_lock: ::std::option::Option::None,
            timestamp_add_lock: ::std::option::Option::None,
            timestamp_content_deadline: ::std::option::Option::None,
            is_fantasy_enabled: ::std::option::Option::None,
            timestamp_content_review_deadline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDPCEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDPCEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDPCEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPCEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDPCEvent`
pub mod cmsg_dpcevent {
    // @@protoc_insertion_point(message:dota.CMsgDPCEvent.PhaseInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PhaseInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDPCEvent.PhaseInfo.phase)
        pub phase: ::std::option::Option<::protobuf::EnumOrUnknown<ELeagueEventPhase>>,
        // @@protoc_insertion_point(field:dota.CMsgDPCEvent.PhaseInfo.node_group_id)
        pub node_group_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDPCEvent.PhaseInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PhaseInfo {
        fn default() -> &'a PhaseInfo {
            <PhaseInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PhaseInfo {
        pub fn new() -> PhaseInfo {
            ::std::default::Default::default()
        }

        // optional .dota.CMsgDPCEvent.ELeagueEventPhase phase = 1;

        pub fn phase(&self) -> ELeagueEventPhase {
            match self.phase {
                Some(e) => e.enum_value_or(ELeagueEventPhase::PHASE_INVALID),
                None => ELeagueEventPhase::PHASE_INVALID,
            }
        }

        pub fn clear_phase(&mut self) {
            self.phase = ::std::option::Option::None;
        }

        pub fn has_phase(&self) -> bool {
            self.phase.is_some()
        }

        // Param is passed by value, moved
        pub fn set_phase(&mut self, v: ELeagueEventPhase) {
            self.phase = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 node_group_id = 2;

        pub fn node_group_id(&self) -> u32 {
            self.node_group_id.unwrap_or(0)
        }

        pub fn clear_node_group_id(&mut self) {
            self.node_group_id = ::std::option::Option::None;
        }

        pub fn has_node_group_id(&self) -> bool {
            self.node_group_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_group_id(&mut self, v: u32) {
            self.node_group_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "phase",
                |m: &PhaseInfo| { &m.phase },
                |m: &mut PhaseInfo| { &mut m.phase },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "node_group_id",
                |m: &PhaseInfo| { &m.node_group_id },
                |m: &mut PhaseInfo| { &mut m.node_group_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhaseInfo>(
                "CMsgDPCEvent.PhaseInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PhaseInfo {
        const NAME: &'static str = "PhaseInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.phase {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.node_group_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.phase {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.node_group_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PhaseInfo {
            PhaseInfo::new()
        }

        fn clear(&mut self) {
            self.phase = ::std::option::Option::None;
            self.node_group_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PhaseInfo {
            static instance: PhaseInfo = PhaseInfo {
                phase: ::std::option::Option::None,
                node_group_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PhaseInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDPCEvent.PhaseInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PhaseInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PhaseInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDPCEvent.League)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct League {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDPCEvent.League.region)
        pub region: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:dota.CMsgDPCEvent.League.division)
        pub division: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueDivision>>,
        // @@protoc_insertion_point(field:dota.CMsgDPCEvent.League.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDPCEvent.League.phases)
        pub phases: ::std::vec::Vec<PhaseInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDPCEvent.League.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a League {
        fn default() -> &'a League {
            <League as ::protobuf::Message>::default_instance()
        }
    }

    impl League {
        pub fn new() -> League {
            ::std::default::Default::default()
        }

        // optional .dota.ELeagueRegion region = 1;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .dota.ELeagueDivision division = 2;

        pub fn division(&self) -> super::super::dota_shared_enums::ELeagueDivision {
            match self.division {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET),
                None => super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET,
            }
        }

        pub fn clear_division(&mut self) {
            self.division = ::std::option::Option::None;
        }

        pub fn has_division(&self) -> bool {
            self.division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_division(&mut self, v: super::super::dota_shared_enums::ELeagueDivision) {
            self.division = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 league_id = 3;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region",
                |m: &League| { &m.region },
                |m: &mut League| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "division",
                |m: &League| { &m.division },
                |m: &mut League| { &mut m.division },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &League| { &m.league_id },
                |m: &mut League| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "phases",
                |m: &League| { &m.phases },
                |m: &mut League| { &mut m.phases },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<League>(
                "CMsgDPCEvent.League",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for League {
        const NAME: &'static str = "League";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.division = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.phases.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.region {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.division {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.phases {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.region {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.division {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(3, v)?;
            }
            for v in &self.phases {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> League {
            League::new()
        }

        fn clear(&mut self) {
            self.region = ::std::option::Option::None;
            self.division = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.phases.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static League {
            static instance: League = League {
                region: ::std::option::Option::None,
                division: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                phases: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for League {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDPCEvent.League").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for League {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for League {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgDPCEvent.ELeagueEvent)
    pub enum ELeagueEvent {
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.EVENT_INVALID)
        EVENT_INVALID = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SPRING_2021_LEAGUE)
        SPRING_2021_LEAGUE = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SPRING_2021_MAJOR)
        SPRING_2021_MAJOR = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2021_QUALIFIERS)
        INTERNATIONAL_2021_QUALIFIERS = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2021)
        INTERNATIONAL_2021 = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.WINTER_2021_LEAGUE)
        WINTER_2021_LEAGUE = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.WINTER_2021_LEAGUE_FINALS)
        WINTER_2021_LEAGUE_FINALS = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SPRING_2022_LEAGUE)
        SPRING_2022_LEAGUE = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SPRING_2022_MAJOR)
        SPRING_2022_MAJOR = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SUMMER_2022_LEAGUE)
        SUMMER_2022_LEAGUE = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SUMMER_2022_MAJOR)
        SUMMER_2022_MAJOR = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2022)
        INTERNATIONAL_2022 = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.CHINA_REGIONAL_FINALS)
        CHINA_REGIONAL_FINALS = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2022_REGIONAL_QUALIFIERS)
        INTERNATIONAL_2022_REGIONAL_QUALIFIERS = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS)
        INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS = 14,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.WINTER_2023_LEAGUE)
        WINTER_2023_LEAGUE = 15,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.WINTER_2023_MAJOR)
        WINTER_2023_MAJOR = 16,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SPRING_2023_LEAGUE)
        SPRING_2023_LEAGUE = 17,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SPRING_2023_MAJOR)
        SPRING_2023_MAJOR = 18,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SUMMER_2023_LEAGUE)
        SUMMER_2023_LEAGUE = 19,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.SUMMER_2023_MAJOR)
        SUMMER_2023_MAJOR = 20,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2023)
        INTERNATIONAL_2023 = 21,
    }

    impl ::protobuf::Enum for ELeagueEvent {
        const NAME: &'static str = "ELeagueEvent";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ELeagueEvent> {
            match value {
                0 => ::std::option::Option::Some(ELeagueEvent::EVENT_INVALID),
                1 => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_LEAGUE),
                2 => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_MAJOR),
                3 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021_QUALIFIERS),
                4 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021),
                5 => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE),
                6 => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE_FINALS),
                7 => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_LEAGUE),
                8 => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_MAJOR),
                9 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_LEAGUE),
                10 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_MAJOR),
                11 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022),
                12 => ::std::option::Option::Some(ELeagueEvent::CHINA_REGIONAL_FINALS),
                13 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_REGIONAL_QUALIFIERS),
                14 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS),
                15 => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_LEAGUE),
                16 => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_MAJOR),
                17 => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_LEAGUE),
                18 => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_MAJOR),
                19 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_LEAGUE),
                20 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_MAJOR),
                21 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2023),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ELeagueEvent> {
            match str {
                "EVENT_INVALID" => ::std::option::Option::Some(ELeagueEvent::EVENT_INVALID),
                "SPRING_2021_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_LEAGUE),
                "SPRING_2021_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_MAJOR),
                "INTERNATIONAL_2021_QUALIFIERS" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021_QUALIFIERS),
                "INTERNATIONAL_2021" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021),
                "WINTER_2021_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE),
                "WINTER_2021_LEAGUE_FINALS" => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE_FINALS),
                "SPRING_2022_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_LEAGUE),
                "SPRING_2022_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_MAJOR),
                "SUMMER_2022_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_LEAGUE),
                "SUMMER_2022_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_MAJOR),
                "INTERNATIONAL_2022" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022),
                "CHINA_REGIONAL_FINALS" => ::std::option::Option::Some(ELeagueEvent::CHINA_REGIONAL_FINALS),
                "INTERNATIONAL_2022_REGIONAL_QUALIFIERS" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_REGIONAL_QUALIFIERS),
                "INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS),
                "WINTER_2023_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_LEAGUE),
                "WINTER_2023_MAJOR" => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_MAJOR),
                "SPRING_2023_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_LEAGUE),
                "SPRING_2023_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_MAJOR),
                "SUMMER_2023_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_LEAGUE),
                "SUMMER_2023_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_MAJOR),
                "INTERNATIONAL_2023" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2023),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ELeagueEvent] = &[
            ELeagueEvent::EVENT_INVALID,
            ELeagueEvent::SPRING_2021_LEAGUE,
            ELeagueEvent::SPRING_2021_MAJOR,
            ELeagueEvent::INTERNATIONAL_2021_QUALIFIERS,
            ELeagueEvent::INTERNATIONAL_2021,
            ELeagueEvent::WINTER_2021_LEAGUE,
            ELeagueEvent::WINTER_2021_LEAGUE_FINALS,
            ELeagueEvent::SPRING_2022_LEAGUE,
            ELeagueEvent::SPRING_2022_MAJOR,
            ELeagueEvent::SUMMER_2022_LEAGUE,
            ELeagueEvent::SUMMER_2022_MAJOR,
            ELeagueEvent::INTERNATIONAL_2022,
            ELeagueEvent::CHINA_REGIONAL_FINALS,
            ELeagueEvent::INTERNATIONAL_2022_REGIONAL_QUALIFIERS,
            ELeagueEvent::INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS,
            ELeagueEvent::WINTER_2023_LEAGUE,
            ELeagueEvent::WINTER_2023_MAJOR,
            ELeagueEvent::SPRING_2023_LEAGUE,
            ELeagueEvent::SPRING_2023_MAJOR,
            ELeagueEvent::SUMMER_2023_LEAGUE,
            ELeagueEvent::SUMMER_2023_MAJOR,
            ELeagueEvent::INTERNATIONAL_2023,
        ];
    }

    impl ::protobuf::EnumFull for ELeagueEvent {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgDPCEvent.ELeagueEvent").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ELeagueEvent {
        fn default() -> Self {
            ELeagueEvent::EVENT_INVALID
        }
    }

    impl ELeagueEvent {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueEvent>("CMsgDPCEvent.ELeagueEvent")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgDPCEvent.ELeagueEventPhase)
    pub enum ELeagueEventPhase {
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.PHASE_INVALID)
        PHASE_INVALID = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.WILD_CARD)
        WILD_CARD = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.GROUP_STAGE)
        GROUP_STAGE = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.GROUP_A)
        GROUP_A = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.GROUP_B)
        GROUP_B = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.OVERALL)
        OVERALL = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.PLAYOFF)
        PLAYOFF = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventPhase.RESULTS)
        RESULTS = 7,
    }

    impl ::protobuf::Enum for ELeagueEventPhase {
        const NAME: &'static str = "ELeagueEventPhase";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ELeagueEventPhase> {
            match value {
                0 => ::std::option::Option::Some(ELeagueEventPhase::PHASE_INVALID),
                1 => ::std::option::Option::Some(ELeagueEventPhase::WILD_CARD),
                2 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_STAGE),
                3 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_A),
                4 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_B),
                5 => ::std::option::Option::Some(ELeagueEventPhase::OVERALL),
                6 => ::std::option::Option::Some(ELeagueEventPhase::PLAYOFF),
                7 => ::std::option::Option::Some(ELeagueEventPhase::RESULTS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ELeagueEventPhase> {
            match str {
                "PHASE_INVALID" => ::std::option::Option::Some(ELeagueEventPhase::PHASE_INVALID),
                "WILD_CARD" => ::std::option::Option::Some(ELeagueEventPhase::WILD_CARD),
                "GROUP_STAGE" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_STAGE),
                "GROUP_A" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_A),
                "GROUP_B" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_B),
                "OVERALL" => ::std::option::Option::Some(ELeagueEventPhase::OVERALL),
                "PLAYOFF" => ::std::option::Option::Some(ELeagueEventPhase::PLAYOFF),
                "RESULTS" => ::std::option::Option::Some(ELeagueEventPhase::RESULTS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ELeagueEventPhase] = &[
            ELeagueEventPhase::PHASE_INVALID,
            ELeagueEventPhase::WILD_CARD,
            ELeagueEventPhase::GROUP_STAGE,
            ELeagueEventPhase::GROUP_A,
            ELeagueEventPhase::GROUP_B,
            ELeagueEventPhase::OVERALL,
            ELeagueEventPhase::PLAYOFF,
            ELeagueEventPhase::RESULTS,
        ];
    }

    impl ::protobuf::EnumFull for ELeagueEventPhase {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgDPCEvent.ELeagueEventPhase").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ELeagueEventPhase {
        fn default() -> Self {
            ELeagueEventPhase::PHASE_INVALID
        }
    }

    impl ELeagueEventPhase {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueEventPhase>("CMsgDPCEvent.ELeagueEventPhase")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgDPCEvent.ELeagueEventType)
    pub enum ELeagueEventType {
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventType.LEAGUE)
        LEAGUE = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventType.MAJOR)
        MAJOR = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventType.INTERNATIONAL_QUALIFIERS)
        INTERNATIONAL_QUALIFIERS = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventType.INTERNATIONAL)
        INTERNATIONAL = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ELeagueEventType.LEAGUE_FINALS)
        LEAGUE_FINALS = 5,
    }

    impl ::protobuf::Enum for ELeagueEventType {
        const NAME: &'static str = "ELeagueEventType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ELeagueEventType> {
            match value {
                0 => ::std::option::Option::Some(ELeagueEventType::UNKNOWN),
                1 => ::std::option::Option::Some(ELeagueEventType::LEAGUE),
                2 => ::std::option::Option::Some(ELeagueEventType::MAJOR),
                3 => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL_QUALIFIERS),
                4 => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL),
                5 => ::std::option::Option::Some(ELeagueEventType::LEAGUE_FINALS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ELeagueEventType> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(ELeagueEventType::UNKNOWN),
                "LEAGUE" => ::std::option::Option::Some(ELeagueEventType::LEAGUE),
                "MAJOR" => ::std::option::Option::Some(ELeagueEventType::MAJOR),
                "INTERNATIONAL_QUALIFIERS" => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL_QUALIFIERS),
                "INTERNATIONAL" => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL),
                "LEAGUE_FINALS" => ::std::option::Option::Some(ELeagueEventType::LEAGUE_FINALS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ELeagueEventType] = &[
            ELeagueEventType::UNKNOWN,
            ELeagueEventType::LEAGUE,
            ELeagueEventType::MAJOR,
            ELeagueEventType::INTERNATIONAL_QUALIFIERS,
            ELeagueEventType::INTERNATIONAL,
            ELeagueEventType::LEAGUE_FINALS,
        ];
    }

    impl ::protobuf::EnumFull for ELeagueEventType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgDPCEvent.ELeagueEventType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ELeagueEventType {
        fn default() -> Self {
            ELeagueEventType::UNKNOWN
        }
    }

    impl ELeagueEventType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueEventType>("CMsgDPCEvent.ELeagueEventType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgDPCEvent.ETour)
    pub enum ETour {
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ETour.TOUR_NONE)
        TOUR_NONE = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ETour.TOUR_1)
        TOUR_1 = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ETour.TOUR_2)
        TOUR_2 = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgDPCEvent.ETour.TOUR_3)
        TOUR_3 = 3,
    }

    impl ::protobuf::Enum for ETour {
        const NAME: &'static str = "ETour";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETour> {
            match value {
                0 => ::std::option::Option::Some(ETour::TOUR_NONE),
                1 => ::std::option::Option::Some(ETour::TOUR_1),
                2 => ::std::option::Option::Some(ETour::TOUR_2),
                3 => ::std::option::Option::Some(ETour::TOUR_3),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETour> {
            match str {
                "TOUR_NONE" => ::std::option::Option::Some(ETour::TOUR_NONE),
                "TOUR_1" => ::std::option::Option::Some(ETour::TOUR_1),
                "TOUR_2" => ::std::option::Option::Some(ETour::TOUR_2),
                "TOUR_3" => ::std::option::Option::Some(ETour::TOUR_3),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETour] = &[
            ETour::TOUR_NONE,
            ETour::TOUR_1,
            ETour::TOUR_2,
            ETour::TOUR_3,
        ];
    }

    impl ::protobuf::EnumFull for ETour {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgDPCEvent.ETour").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ETour {
        fn default() -> Self {
            ETour::TOUR_NONE
        }
    }

    impl ETour {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETour>("CMsgDPCEvent.ETour")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgDPCEventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPCEventList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDPCEventList.events)
    pub events: ::std::vec::Vec<CMsgDPCEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDPCEventList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPCEventList {
    fn default() -> &'a CMsgDPCEventList {
        <CMsgDPCEventList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPCEventList {
    pub fn new() -> CMsgDPCEventList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &CMsgDPCEventList| { &m.events },
            |m: &mut CMsgDPCEventList| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDPCEventList>(
            "CMsgDPCEventList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDPCEventList {
    const NAME: &'static str = "CMsgDPCEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPCEventList {
        CMsgDPCEventList::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPCEventList {
        static instance: CMsgDPCEventList = CMsgDPCEventList {
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDPCEventList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDPCEventList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDPCEventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPCEventList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardLineup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyCardLineup {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.periods)
    pub periods: ::std::vec::Vec<cmsg_dotafantasy_card_lineup::Period>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardLineup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyCardLineup {
    fn default() -> &'a CMsgDOTAFantasyCardLineup {
        <CMsgDOTAFantasyCardLineup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyCardLineup {
    pub fn new() -> CMsgDOTAFantasyCardLineup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "periods",
            |m: &CMsgDOTAFantasyCardLineup| { &m.periods },
            |m: &mut CMsgDOTAFantasyCardLineup| { &mut m.periods },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAFantasyCardLineup>(
            "CMsgDOTAFantasyCardLineup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyCardLineup {
    const NAME: &'static str = "CMsgDOTAFantasyCardLineup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.periods.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.periods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.periods {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyCardLineup {
        CMsgDOTAFantasyCardLineup::new()
    }

    fn clear(&mut self) {
        self.periods.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyCardLineup {
        static instance: CMsgDOTAFantasyCardLineup = CMsgDOTAFantasyCardLineup {
            periods: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAFantasyCardLineup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardLineup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAFantasyCardLineup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyCardLineup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTAFantasyCardLineup`
pub mod cmsg_dotafantasy_card_lineup {
    // @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardLineup.CardBonus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CardBonus {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.CardBonus.bonus_stat)
        pub bonus_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.CardBonus.bonus_value)
        pub bonus_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardLineup.CardBonus.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CardBonus {
        fn default() -> &'a CardBonus {
            <CardBonus as ::protobuf::Message>::default_instance()
        }
    }

    impl CardBonus {
        pub fn new() -> CardBonus {
            ::std::default::Default::default()
        }

        // optional uint32 bonus_stat = 1;

        pub fn bonus_stat(&self) -> u32 {
            self.bonus_stat.unwrap_or(0)
        }

        pub fn clear_bonus_stat(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
        }

        pub fn has_bonus_stat(&self) -> bool {
            self.bonus_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_stat(&mut self, v: u32) {
            self.bonus_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 bonus_value = 2;

        pub fn bonus_value(&self) -> u32 {
            self.bonus_value.unwrap_or(0)
        }

        pub fn clear_bonus_value(&mut self) {
            self.bonus_value = ::std::option::Option::None;
        }

        pub fn has_bonus_value(&self) -> bool {
            self.bonus_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_value(&mut self, v: u32) {
            self.bonus_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bonus_stat",
                |m: &CardBonus| { &m.bonus_stat },
                |m: &mut CardBonus| { &mut m.bonus_stat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bonus_value",
                |m: &CardBonus| { &m.bonus_value },
                |m: &mut CardBonus| { &mut m.bonus_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CardBonus>(
                "CMsgDOTAFantasyCardLineup.CardBonus",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CardBonus {
        const NAME: &'static str = "CardBonus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.bonus_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.bonus_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.bonus_stat {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.bonus_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.bonus_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.bonus_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CardBonus {
            CardBonus::new()
        }

        fn clear(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
            self.bonus_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CardBonus {
            static instance: CardBonus = CardBonus {
                bonus_stat: ::std::option::Option::None,
                bonus_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CardBonus {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardLineup.CardBonus").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CardBonus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CardBonus {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardLineup.Card)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Card {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.player_account_id)
        pub player_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.bonuses)
        pub bonuses: ::std::vec::Vec<CardBonus>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.score)
        pub score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.finalized)
        pub finalized: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Card.item_id)
        pub item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardLineup.Card.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Card {
        fn default() -> &'a Card {
            <Card as ::protobuf::Message>::default_instance()
        }
    }

    impl Card {
        pub fn new() -> Card {
            ::std::default::Default::default()
        }

        // optional uint32 player_account_id = 1;

        pub fn player_account_id(&self) -> u32 {
            self.player_account_id.unwrap_or(0)
        }

        pub fn clear_player_account_id(&mut self) {
            self.player_account_id = ::std::option::Option::None;
        }

        pub fn has_player_account_id(&self) -> bool {
            self.player_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_account_id(&mut self, v: u32) {
            self.player_account_id = ::std::option::Option::Some(v);
        }

        // optional string player_name = 2;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 3;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 4;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 role = 5;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional float score = 7;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional bool finalized = 8;

        pub fn finalized(&self) -> bool {
            self.finalized.unwrap_or(false)
        }

        pub fn clear_finalized(&mut self) {
            self.finalized = ::std::option::Option::None;
        }

        pub fn has_finalized(&self) -> bool {
            self.finalized.is_some()
        }

        // Param is passed by value, moved
        pub fn set_finalized(&mut self, v: bool) {
            self.finalized = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 9;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_account_id",
                |m: &Card| { &m.player_account_id },
                |m: &mut Card| { &mut m.player_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name",
                |m: &Card| { &m.player_name },
                |m: &mut Card| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Card| { &m.team_id },
                |m: &mut Card| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &Card| { &m.team_name },
                |m: &mut Card| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "role",
                |m: &Card| { &m.role },
                |m: &mut Card| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bonuses",
                |m: &Card| { &m.bonuses },
                |m: &mut Card| { &mut m.bonuses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &Card| { &m.score },
                |m: &mut Card| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "finalized",
                |m: &Card| { &m.finalized },
                |m: &mut Card| { &mut m.finalized },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &Card| { &m.item_id },
                |m: &mut Card| { &mut m.item_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Card>(
                "CMsgDOTAFantasyCardLineup.Card",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Card {
        const NAME: &'static str = "Card";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.bonuses.push(is.read_message()?);
                    },
                    61 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    64 => {
                        self.finalized = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.role {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            for value in &self.bonuses {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.finalized {
                my_size += 1 + 1;
            }
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(5, v)?;
            }
            for v in &self.bonuses {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.score {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.finalized {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Card {
            Card::new()
        }

        fn clear(&mut self) {
            self.player_account_id = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.bonuses.clear();
            self.score = ::std::option::Option::None;
            self.finalized = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Card {
            static instance: Card = Card {
                player_account_id: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                role: ::std::option::Option::None,
                bonuses: ::std::vec::Vec::new(),
                score: ::std::option::Option::None,
                finalized: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Card {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardLineup.Card").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Card {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Card {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardLineup.League)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct League {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.League.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.League.cards)
        pub cards: ::std::vec::Vec<Card>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.League.score)
        pub score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardLineup.League.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a League {
        fn default() -> &'a League {
            <League as ::protobuf::Message>::default_instance()
        }
    }

    impl League {
        pub fn new() -> League {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional float score = 3;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &League| { &m.league_id },
                |m: &mut League| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cards",
                |m: &League| { &m.cards },
                |m: &mut League| { &mut m.cards },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &League| { &m.score },
                |m: &mut League| { &mut m.score },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<League>(
                "CMsgDOTAFantasyCardLineup.League",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for League {
        const NAME: &'static str = "League";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.cards.push(is.read_message()?);
                    },
                    29 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.cards {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.cards {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.score {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> League {
            League::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.cards.clear();
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static League {
            static instance: League = League {
                league_id: ::std::option::Option::None,
                cards: ::std::vec::Vec::new(),
                score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for League {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardLineup.League").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for League {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for League {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardLineup.Period)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Period {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Period.fantasy_period)
        pub fantasy_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Period.timestamp_start)
        pub timestamp_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Period.timestamp_end)
        pub timestamp_end: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardLineup.Period.leagues)
        pub leagues: ::std::vec::Vec<League>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardLineup.Period.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Period {
        fn default() -> &'a Period {
            <Period as ::protobuf::Message>::default_instance()
        }
    }

    impl Period {
        pub fn new() -> Period {
            ::std::default::Default::default()
        }

        // optional uint32 fantasy_period = 1;

        pub fn fantasy_period(&self) -> u32 {
            self.fantasy_period.unwrap_or(0)
        }

        pub fn clear_fantasy_period(&mut self) {
            self.fantasy_period = ::std::option::Option::None;
        }

        pub fn has_fantasy_period(&self) -> bool {
            self.fantasy_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fantasy_period(&mut self, v: u32) {
            self.fantasy_period = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp_start = 2;

        pub fn timestamp_start(&self) -> u32 {
            self.timestamp_start.unwrap_or(0)
        }

        pub fn clear_timestamp_start(&mut self) {
            self.timestamp_start = ::std::option::Option::None;
        }

        pub fn has_timestamp_start(&self) -> bool {
            self.timestamp_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_start(&mut self, v: u32) {
            self.timestamp_start = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp_end = 3;

        pub fn timestamp_end(&self) -> u32 {
            self.timestamp_end.unwrap_or(0)
        }

        pub fn clear_timestamp_end(&mut self) {
            self.timestamp_end = ::std::option::Option::None;
        }

        pub fn has_timestamp_end(&self) -> bool {
            self.timestamp_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_end(&mut self, v: u32) {
            self.timestamp_end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fantasy_period",
                |m: &Period| { &m.fantasy_period },
                |m: &mut Period| { &mut m.fantasy_period },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp_start",
                |m: &Period| { &m.timestamp_start },
                |m: &mut Period| { &mut m.timestamp_start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp_end",
                |m: &Period| { &m.timestamp_end },
                |m: &mut Period| { &mut m.timestamp_end },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "leagues",
                |m: &Period| { &m.leagues },
                |m: &mut Period| { &mut m.leagues },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Period>(
                "CMsgDOTAFantasyCardLineup.Period",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Period {
        const NAME: &'static str = "Period";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fantasy_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.timestamp_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.leagues.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.fantasy_period {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp_start {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.timestamp_end {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.leagues {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.fantasy_period {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp_start {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.timestamp_end {
                os.write_uint32(3, v)?;
            }
            for v in &self.leagues {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Period {
            Period::new()
        }

        fn clear(&mut self) {
            self.fantasy_period = ::std::option::Option::None;
            self.timestamp_start = ::std::option::Option::None;
            self.timestamp_end = ::std::option::Option::None;
            self.leagues.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Period {
            static instance: Period = Period {
                fantasy_period: ::std::option::Option::None,
                timestamp_start: ::std::option::Option::None,
                timestamp_end: ::std::option::Option::None,
                leagues: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Period {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardLineup.Period").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Period {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Period {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyCardList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.cards)
    pub cards: ::std::vec::Vec<cmsg_dotafantasy_card_list::Card>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyCardList {
    fn default() -> &'a CMsgDOTAFantasyCardList {
        <CMsgDOTAFantasyCardList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyCardList {
    pub fn new() -> CMsgDOTAFantasyCardList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cards",
            |m: &CMsgDOTAFantasyCardList| { &m.cards },
            |m: &mut CMsgDOTAFantasyCardList| { &mut m.cards },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAFantasyCardList>(
            "CMsgDOTAFantasyCardList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyCardList {
    const NAME: &'static str = "CMsgDOTAFantasyCardList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cards.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cards {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyCardList {
        CMsgDOTAFantasyCardList::new()
    }

    fn clear(&mut self) {
        self.cards.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyCardList {
        static instance: CMsgDOTAFantasyCardList = CMsgDOTAFantasyCardList {
            cards: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAFantasyCardList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAFantasyCardList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyCardList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTAFantasyCardList`
pub mod cmsg_dotafantasy_card_list {
    // @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardList.CardBonus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CardBonus {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.CardBonus.bonus_stat)
        pub bonus_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.CardBonus.bonus_value)
        pub bonus_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardList.CardBonus.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CardBonus {
        fn default() -> &'a CardBonus {
            <CardBonus as ::protobuf::Message>::default_instance()
        }
    }

    impl CardBonus {
        pub fn new() -> CardBonus {
            ::std::default::Default::default()
        }

        // optional uint32 bonus_stat = 1;

        pub fn bonus_stat(&self) -> u32 {
            self.bonus_stat.unwrap_or(0)
        }

        pub fn clear_bonus_stat(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
        }

        pub fn has_bonus_stat(&self) -> bool {
            self.bonus_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_stat(&mut self, v: u32) {
            self.bonus_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 bonus_value = 2;

        pub fn bonus_value(&self) -> u32 {
            self.bonus_value.unwrap_or(0)
        }

        pub fn clear_bonus_value(&mut self) {
            self.bonus_value = ::std::option::Option::None;
        }

        pub fn has_bonus_value(&self) -> bool {
            self.bonus_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_value(&mut self, v: u32) {
            self.bonus_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bonus_stat",
                |m: &CardBonus| { &m.bonus_stat },
                |m: &mut CardBonus| { &mut m.bonus_stat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bonus_value",
                |m: &CardBonus| { &m.bonus_value },
                |m: &mut CardBonus| { &mut m.bonus_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CardBonus>(
                "CMsgDOTAFantasyCardList.CardBonus",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CardBonus {
        const NAME: &'static str = "CardBonus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.bonus_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.bonus_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.bonus_stat {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.bonus_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.bonus_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.bonus_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CardBonus {
            CardBonus::new()
        }

        fn clear(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
            self.bonus_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CardBonus {
            static instance: CardBonus = CardBonus {
                bonus_stat: ::std::option::Option::None,
                bonus_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CardBonus {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardList.CardBonus").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CardBonus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CardBonus {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAFantasyCardList.Card)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Card {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.Card.player_account_id)
        pub player_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.Card.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.Card.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.Card.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.Card.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.Card.bonuses)
        pub bonuses: ::std::vec::Vec<CardBonus>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyCardList.Card.item_id)
        pub item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyCardList.Card.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Card {
        fn default() -> &'a Card {
            <Card as ::protobuf::Message>::default_instance()
        }
    }

    impl Card {
        pub fn new() -> Card {
            ::std::default::Default::default()
        }

        // optional uint32 player_account_id = 1;

        pub fn player_account_id(&self) -> u32 {
            self.player_account_id.unwrap_or(0)
        }

        pub fn clear_player_account_id(&mut self) {
            self.player_account_id = ::std::option::Option::None;
        }

        pub fn has_player_account_id(&self) -> bool {
            self.player_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_account_id(&mut self, v: u32) {
            self.player_account_id = ::std::option::Option::Some(v);
        }

        // optional string player_name = 2;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 3;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 4;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 role = 5;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 8;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_account_id",
                |m: &Card| { &m.player_account_id },
                |m: &mut Card| { &mut m.player_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name",
                |m: &Card| { &m.player_name },
                |m: &mut Card| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Card| { &m.team_id },
                |m: &mut Card| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &Card| { &m.team_name },
                |m: &mut Card| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "role",
                |m: &Card| { &m.role },
                |m: &mut Card| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bonuses",
                |m: &Card| { &m.bonuses },
                |m: &mut Card| { &mut m.bonuses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &Card| { &m.item_id },
                |m: &mut Card| { &mut m.item_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Card>(
                "CMsgDOTAFantasyCardList.Card",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Card {
        const NAME: &'static str = "Card";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.bonuses.push(is.read_message()?);
                    },
                    64 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.role {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            for value in &self.bonuses {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(5, v)?;
            }
            for v in &self.bonuses {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.item_id {
                os.write_uint64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Card {
            Card::new()
        }

        fn clear(&mut self) {
            self.player_account_id = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.bonuses.clear();
            self.item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Card {
            static instance: Card = Card {
                player_account_id: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                role: ::std::option::Option::None,
                bonuses: ::std::vec::Vec::new(),
                item_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Card {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyCardList.Card").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Card {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Card {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgChatToxicityReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgChatToxicityReport {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgChatToxicityReport.num_matches_seen)
    pub num_matches_seen: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgChatToxicityReport.num_messages)
    pub num_messages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgChatToxicityReport.num_messages_human_thinks_toxic)
    pub num_messages_human_thinks_toxic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgChatToxicityReport.num_messages_ml_thinks_toxic)
    pub num_messages_ml_thinks_toxic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgChatToxicityReport.status)
    pub status: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgChatToxicityReport.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgChatToxicityReport.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgChatToxicityReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgChatToxicityReport {
    fn default() -> &'a CMsgChatToxicityReport {
        <CMsgChatToxicityReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgChatToxicityReport {
    pub fn new() -> CMsgChatToxicityReport {
        ::std::default::Default::default()
    }

    // optional uint32 num_matches_seen = 1;

    pub fn num_matches_seen(&self) -> u32 {
        self.num_matches_seen.unwrap_or(0)
    }

    pub fn clear_num_matches_seen(&mut self) {
        self.num_matches_seen = ::std::option::Option::None;
    }

    pub fn has_num_matches_seen(&self) -> bool {
        self.num_matches_seen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_matches_seen(&mut self, v: u32) {
        self.num_matches_seen = ::std::option::Option::Some(v);
    }

    // optional uint32 num_messages = 2;

    pub fn num_messages(&self) -> u32 {
        self.num_messages.unwrap_or(0)
    }

    pub fn clear_num_messages(&mut self) {
        self.num_messages = ::std::option::Option::None;
    }

    pub fn has_num_messages(&self) -> bool {
        self.num_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u32) {
        self.num_messages = ::std::option::Option::Some(v);
    }

    // optional uint32 num_messages_human_thinks_toxic = 3;

    pub fn num_messages_human_thinks_toxic(&self) -> u32 {
        self.num_messages_human_thinks_toxic.unwrap_or(0)
    }

    pub fn clear_num_messages_human_thinks_toxic(&mut self) {
        self.num_messages_human_thinks_toxic = ::std::option::Option::None;
    }

    pub fn has_num_messages_human_thinks_toxic(&self) -> bool {
        self.num_messages_human_thinks_toxic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages_human_thinks_toxic(&mut self, v: u32) {
        self.num_messages_human_thinks_toxic = ::std::option::Option::Some(v);
    }

    // optional uint32 num_messages_ml_thinks_toxic = 4;

    pub fn num_messages_ml_thinks_toxic(&self) -> u32 {
        self.num_messages_ml_thinks_toxic.unwrap_or(0)
    }

    pub fn clear_num_messages_ml_thinks_toxic(&mut self) {
        self.num_messages_ml_thinks_toxic = ::std::option::Option::None;
    }

    pub fn has_num_messages_ml_thinks_toxic(&self) -> bool {
        self.num_messages_ml_thinks_toxic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages_ml_thinks_toxic(&mut self, v: u32) {
        self.num_messages_ml_thinks_toxic = ::std::option::Option::Some(v);
    }

    // optional string status = 5;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 result = 6;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 7;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_matches_seen",
            |m: &CMsgChatToxicityReport| { &m.num_matches_seen },
            |m: &mut CMsgChatToxicityReport| { &mut m.num_matches_seen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_messages",
            |m: &CMsgChatToxicityReport| { &m.num_messages },
            |m: &mut CMsgChatToxicityReport| { &mut m.num_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_messages_human_thinks_toxic",
            |m: &CMsgChatToxicityReport| { &m.num_messages_human_thinks_toxic },
            |m: &mut CMsgChatToxicityReport| { &mut m.num_messages_human_thinks_toxic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_messages_ml_thinks_toxic",
            |m: &CMsgChatToxicityReport| { &m.num_messages_ml_thinks_toxic },
            |m: &mut CMsgChatToxicityReport| { &mut m.num_messages_ml_thinks_toxic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgChatToxicityReport| { &m.status },
            |m: &mut CMsgChatToxicityReport| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgChatToxicityReport| { &m.result },
            |m: &mut CMsgChatToxicityReport| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgChatToxicityReport| { &m.message },
            |m: &mut CMsgChatToxicityReport| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgChatToxicityReport>(
            "CMsgChatToxicityReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgChatToxicityReport {
    const NAME: &'static str = "CMsgChatToxicityReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_matches_seen = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_messages = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_messages_human_thinks_toxic = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.num_messages_ml_thinks_toxic = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_matches_seen {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_messages {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_messages_human_thinks_toxic {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.num_messages_ml_thinks_toxic {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_matches_seen {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_messages {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_messages_human_thinks_toxic {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.num_messages_ml_thinks_toxic {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgChatToxicityReport {
        CMsgChatToxicityReport::new()
    }

    fn clear(&mut self) {
        self.num_matches_seen = ::std::option::Option::None;
        self.num_messages = ::std::option::Option::None;
        self.num_messages_human_thinks_toxic = ::std::option::Option::None;
        self.num_messages_ml_thinks_toxic = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgChatToxicityReport {
        static instance: CMsgChatToxicityReport = CMsgChatToxicityReport {
            num_matches_seen: ::std::option::Option::None,
            num_messages: ::std::option::Option::None,
            num_messages_human_thinks_toxic: ::std::option::Option::None,
            num_messages_ml_thinks_toxic: ::std::option::Option::None,
            status: ::std::option::Option::None,
            result: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgChatToxicityReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgChatToxicityReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgChatToxicityReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgChatToxicityReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGetTeamAuditInformation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetTeamAuditInformation {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.team_name)
    pub team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.actions)
    pub actions: ::std::vec::Vec<cmsg_get_team_audit_information::Action>,
    // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.last_updated)
    pub last_updated: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGetTeamAuditInformation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetTeamAuditInformation {
    fn default() -> &'a CMsgGetTeamAuditInformation {
        <CMsgGetTeamAuditInformation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetTeamAuditInformation {
    pub fn new() -> CMsgGetTeamAuditInformation {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional string team_name = 2;

    pub fn team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_name(&mut self) {
        self.team_name = ::std::option::Option::None;
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 last_updated = 4;

    pub fn last_updated(&self) -> u32 {
        self.last_updated.unwrap_or(0)
    }

    pub fn clear_last_updated(&mut self) {
        self.last_updated = ::std::option::Option::None;
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: u32) {
        self.last_updated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CMsgGetTeamAuditInformation| { &m.team_id },
            |m: &mut CMsgGetTeamAuditInformation| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_name",
            |m: &CMsgGetTeamAuditInformation| { &m.team_name },
            |m: &mut CMsgGetTeamAuditInformation| { &mut m.team_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &CMsgGetTeamAuditInformation| { &m.actions },
            |m: &mut CMsgGetTeamAuditInformation| { &mut m.actions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_updated",
            |m: &CMsgGetTeamAuditInformation| { &m.last_updated },
            |m: &mut CMsgGetTeamAuditInformation| { &mut m.last_updated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetTeamAuditInformation>(
            "CMsgGetTeamAuditInformation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGetTeamAuditInformation {
    const NAME: &'static str = "CMsgGetTeamAuditInformation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.team_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.actions.push(is.read_message()?);
                },
                32 => {
                    self.last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.last_updated {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.last_updated {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetTeamAuditInformation {
        CMsgGetTeamAuditInformation::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.team_name = ::std::option::Option::None;
        self.actions.clear();
        self.last_updated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetTeamAuditInformation {
        static instance: CMsgGetTeamAuditInformation = CMsgGetTeamAuditInformation {
            team_id: ::std::option::Option::None,
            team_name: ::std::option::Option::None,
            actions: ::std::vec::Vec::new(),
            last_updated: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGetTeamAuditInformation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetTeamAuditInformation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetTeamAuditInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetTeamAuditInformation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGetTeamAuditInformation`
pub mod cmsg_get_team_audit_information {
    // @@protoc_insertion_point(message:dota.CMsgGetTeamAuditInformation.Action)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Action {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.Action.registration_period)
        pub registration_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.Action.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.Action.action)
        pub action: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.Action.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.Action.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGetTeamAuditInformation.Action.player_real_name)
        pub player_real_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGetTeamAuditInformation.Action.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Action {
        fn default() -> &'a Action {
            <Action as ::protobuf::Message>::default_instance()
        }
    }

    impl Action {
        pub fn new() -> Action {
            ::std::default::Default::default()
        }

        // optional uint32 registration_period = 1;

        pub fn registration_period(&self) -> u32 {
            self.registration_period.unwrap_or(0)
        }

        pub fn clear_registration_period(&mut self) {
            self.registration_period = ::std::option::Option::None;
        }

        pub fn has_registration_period(&self) -> bool {
            self.registration_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_registration_period(&mut self, v: u32) {
            self.registration_period = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 action = 3;

        pub fn action(&self) -> u32 {
            self.action.unwrap_or(0)
        }

        pub fn clear_action(&mut self) {
            self.action = ::std::option::Option::None;
        }

        pub fn has_action(&self) -> bool {
            self.action.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action(&mut self, v: u32) {
            self.action = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string player_name = 5;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string player_real_name = 6;

        pub fn player_real_name(&self) -> &str {
            match self.player_real_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_real_name(&mut self) {
            self.player_real_name = ::std::option::Option::None;
        }

        pub fn has_player_real_name(&self) -> bool {
            self.player_real_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_real_name(&mut self, v: ::std::string::String) {
            self.player_real_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_real_name(&mut self) -> &mut ::std::string::String {
            if self.player_real_name.is_none() {
                self.player_real_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_real_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_real_name(&mut self) -> ::std::string::String {
            self.player_real_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "registration_period",
                |m: &Action| { &m.registration_period },
                |m: &mut Action| { &mut m.registration_period },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Action| { &m.account_id },
                |m: &mut Action| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "action",
                |m: &Action| { &m.action },
                |m: &mut Action| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &Action| { &m.timestamp },
                |m: &mut Action| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name",
                |m: &Action| { &m.player_name },
                |m: &mut Action| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_real_name",
                |m: &Action| { &m.player_real_name },
                |m: &mut Action| { &mut m.player_real_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Action>(
                "CMsgGetTeamAuditInformation.Action",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Action {
        const NAME: &'static str = "Action";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.registration_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.action = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.player_real_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.registration_period {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.action {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.player_real_name.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.registration_period {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.action {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.player_real_name.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Action {
            Action::new()
        }

        fn clear(&mut self) {
            self.registration_period = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.action = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.player_real_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Action {
            static instance: Action = Action {
                registration_period: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                action: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                player_real_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Action {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGetTeamAuditInformation.Action").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Action {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Action {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTADPCMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCMatch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCMatch.match)
    pub match_: ::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCMatch.metadata)
    pub metadata: ::protobuf::MessageField<super::dota_match_metadata::CDOTAMatchMetadata>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCMatch {
    fn default() -> &'a CMsgDOTADPCMatch {
        <CMsgDOTADPCMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCMatch {
    pub fn new() -> CMsgDOTADPCMatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_gcmessages_common::CMsgDOTAMatch>(
            "match",
            |m: &CMsgDOTADPCMatch| { &m.match_ },
            |m: &mut CMsgDOTADPCMatch| { &mut m.match_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_match_metadata::CDOTAMatchMetadata>(
            "metadata",
            |m: &CMsgDOTADPCMatch| { &m.metadata },
            |m: &mut CMsgDOTADPCMatch| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTADPCMatch>(
            "CMsgDOTADPCMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTADPCMatch {
    const NAME: &'static str = "CMsgDOTADPCMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCMatch {
        CMsgDOTADPCMatch::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCMatch {
        static instance: CMsgDOTADPCMatch = CMsgDOTADPCMatch {
            match_: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTADPCMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTADPCMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTADPCMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADPCMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ETeamFanContentStatus)
pub enum ETeamFanContentStatus {
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentStatus.TEAM_FAN_CONTENT_STATUS_INVALID)
    TEAM_FAN_CONTENT_STATUS_INVALID = 0,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentStatus.TEAM_FAN_CONTENT_STATUS_PENDING)
    TEAM_FAN_CONTENT_STATUS_PENDING = 1,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentStatus.TEAM_FAN_CONTENT_STATUS_EVALUATED)
    TEAM_FAN_CONTENT_STATUS_EVALUATED = 2,
}

impl ::protobuf::Enum for ETeamFanContentStatus {
    const NAME: &'static str = "ETeamFanContentStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeamFanContentStatus> {
        match value {
            0 => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID),
            1 => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_PENDING),
            2 => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_EVALUATED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeamFanContentStatus> {
        match str {
            "TEAM_FAN_CONTENT_STATUS_INVALID" => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID),
            "TEAM_FAN_CONTENT_STATUS_PENDING" => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_PENDING),
            "TEAM_FAN_CONTENT_STATUS_EVALUATED" => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_EVALUATED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeamFanContentStatus] = &[
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID,
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_PENDING,
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_EVALUATED,
    ];
}

impl ::protobuf::EnumFull for ETeamFanContentStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETeamFanContentStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ETeamFanContentStatus {
    fn default() -> Self {
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID
    }
}

impl ETeamFanContentStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETeamFanContentStatus>("ETeamFanContentStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ETeamFanContentAssetType)
pub enum ETeamFanContentAssetType {
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_LogoPNG)
    k_eFanContentAssetType_LogoPNG = 1,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_LogoSVG)
    k_eFanContentAssetType_LogoSVG = 2,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_Logo3D)
    k_eFanContentAssetType_Logo3D = 3,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_Players)
    k_eFanContentAssetType_Players = 4,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_Sprays)
    k_eFanContentAssetType_Sprays = 5,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_Wallpapers)
    k_eFanContentAssetType_Wallpapers = 6,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_Emoticons)
    k_eFanContentAssetType_Emoticons = 7,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_VoiceLines)
    k_eFanContentAssetType_VoiceLines = 8,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetType.k_eFanContentAssetType_Localization)
    k_eFanContentAssetType_Localization = 9,
}

impl ::protobuf::Enum for ETeamFanContentAssetType {
    const NAME: &'static str = "ETeamFanContentAssetType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeamFanContentAssetType> {
        match value {
            1 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG),
            2 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoSVG),
            3 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Logo3D),
            4 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Players),
            5 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Sprays),
            6 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Wallpapers),
            7 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Emoticons),
            8 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_VoiceLines),
            9 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Localization),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeamFanContentAssetType> {
        match str {
            "k_eFanContentAssetType_LogoPNG" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG),
            "k_eFanContentAssetType_LogoSVG" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoSVG),
            "k_eFanContentAssetType_Logo3D" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Logo3D),
            "k_eFanContentAssetType_Players" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Players),
            "k_eFanContentAssetType_Sprays" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Sprays),
            "k_eFanContentAssetType_Wallpapers" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Wallpapers),
            "k_eFanContentAssetType_Emoticons" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Emoticons),
            "k_eFanContentAssetType_VoiceLines" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_VoiceLines),
            "k_eFanContentAssetType_Localization" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Localization),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeamFanContentAssetType] = &[
        ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG,
        ETeamFanContentAssetType::k_eFanContentAssetType_LogoSVG,
        ETeamFanContentAssetType::k_eFanContentAssetType_Logo3D,
        ETeamFanContentAssetType::k_eFanContentAssetType_Players,
        ETeamFanContentAssetType::k_eFanContentAssetType_Sprays,
        ETeamFanContentAssetType::k_eFanContentAssetType_Wallpapers,
        ETeamFanContentAssetType::k_eFanContentAssetType_Emoticons,
        ETeamFanContentAssetType::k_eFanContentAssetType_VoiceLines,
        ETeamFanContentAssetType::k_eFanContentAssetType_Localization,
    ];
}

impl ::protobuf::EnumFull for ETeamFanContentAssetType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETeamFanContentAssetType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG => 0,
            ETeamFanContentAssetType::k_eFanContentAssetType_LogoSVG => 1,
            ETeamFanContentAssetType::k_eFanContentAssetType_Logo3D => 2,
            ETeamFanContentAssetType::k_eFanContentAssetType_Players => 3,
            ETeamFanContentAssetType::k_eFanContentAssetType_Sprays => 4,
            ETeamFanContentAssetType::k_eFanContentAssetType_Wallpapers => 5,
            ETeamFanContentAssetType::k_eFanContentAssetType_Emoticons => 6,
            ETeamFanContentAssetType::k_eFanContentAssetType_VoiceLines => 7,
            ETeamFanContentAssetType::k_eFanContentAssetType_Localization => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETeamFanContentAssetType {
    fn default() -> Self {
        ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG
    }
}

impl ETeamFanContentAssetType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETeamFanContentAssetType>("ETeamFanContentAssetType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ETeamFanContentAssetStatus)
pub enum ETeamFanContentAssetStatus {
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetStatus.k_eFanContentAssetStatus_None)
    k_eFanContentAssetStatus_None = 0,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetStatus.k_eFanContentAssetStatus_Approved)
    k_eFanContentAssetStatus_Approved = 1,
    // @@protoc_insertion_point(enum_value:dota.ETeamFanContentAssetStatus.k_eFanContentAssetStatus_Rejected)
    k_eFanContentAssetStatus_Rejected = 2,
}

impl ::protobuf::Enum for ETeamFanContentAssetStatus {
    const NAME: &'static str = "ETeamFanContentAssetStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeamFanContentAssetStatus> {
        match value {
            0 => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None),
            1 => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Approved),
            2 => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Rejected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeamFanContentAssetStatus> {
        match str {
            "k_eFanContentAssetStatus_None" => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None),
            "k_eFanContentAssetStatus_Approved" => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Approved),
            "k_eFanContentAssetStatus_Rejected" => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Rejected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeamFanContentAssetStatus] = &[
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None,
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Approved,
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Rejected,
    ];
}

impl ::protobuf::EnumFull for ETeamFanContentAssetStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETeamFanContentAssetStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ETeamFanContentAssetStatus {
    fn default() -> Self {
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None
    }
}

impl ETeamFanContentAssetStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETeamFanContentAssetStatus>("ETeamFanContentAssetStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cdota_gcmessages_webapi.proto\x12\x04dota\x1a\x13steammessages.prot\
    o\x1a\x16gcsdk_gcmessages.proto\x1a\x17dota_shared_enums.proto\x1a\x1cdo\
    ta_gcmessages_common.proto\x1a\x19dota_match_metadata.proto\"\xd5\x06\n\
    \x0fCMsgArcanaVotes\x125\n\x07matches\x18\x01\x20\x03(\x0b2\x1b.dota.CMs\
    gArcanaVotes.MatchR\x07matches\x120\n\x14round_time_remaining\x18\x02\
    \x20\x01(\rR\x12roundTimeRemaining\x12!\n\x0cround_number\x18\x03\x20\
    \x01(\rR\x0broundNumber\x12!\n\x0cvoting_state\x18\x04\x20\x01(\rR\x0bvo\
    tingState\x12?\n\x1cis_current_round_calibrating\x18\x05\x20\x01(\x08R\
    \x19isCurrentRoundCalibrating\x125\n\x17closest_active_match_id\x18\x06\
    \x20\x01(\rR\x14closestActiveMatchId\x12\x19\n\x08event_id\x18\x07\x20\
    \x01(\rR\x07eventId\x12*\n\x11voting_start_time\x18\x08\x20\x01(\rR\x0fv\
    otingStartTime\x1a\x96\x03\n\x05Match\x12\x19\n\x08match_id\x18\x01\x20\
    \x01(\rR\x07matchId\x12\x1a\n\thero_id_0\x18\x02\x20\x01(\rR\x07heroId0\
    \x12\x1a\n\thero_id_1\x18\x03\x20\x01(\rR\x07heroId1\x12$\n\x0ehero_seed\
    ing_0\x18\x04\x20\x01(\rR\x0cheroSeeding0\x12$\n\x0ehero_seeding_1\x18\
    \x05\x20\x01(\rR\x0cheroSeeding1\x12\x20\n\x0cvote_count_0\x18\x06\x20\
    \x01(\rR\nvoteCount0\x12\x20\n\x0cvote_count_1\x18\x07\x20\x01(\rR\nvote\
    Count1\x12!\n\x0cvoting_state\x18\x08\x20\x01(\rR\x0bvotingState\x12!\n\
    \x0cround_number\x18\t\x20\x01(\rR\x0broundNumber\x12&\n\x0fis_votes_hid\
    den\x18\n\x20\x01(\x08R\risVotesHidden\x12<\n\x1acalibration_time_remain\
    ing\x18\x0b\x20\x01(\rR\x18calibrationTimeRemaining\";\n\x0bVotingState\
    \x12\x0c\n\x08FINISHED\x10\0\x12\x0f\n\x0bIN_PROGRESS\x10\x01\x12\r\n\tI\
    N_FUTURE\x10\x02\"\xea\x06\n\x0fCMsgDOTADPCFeed\x129\n\x08elements\x18\
    \x01\x20\x03(\x0b2\x1d.dota.CMsgDOTADPCFeed.ElementR\x08elements\x1a\x8d\
    \x03\n\x07Element\x12:\n\x04type\x18\x01\x20\x01(\x0e2&.dota.CMsgDOTADPC\
    Feed.EFeedElementTypeR\x04type\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\
    \ttimestamp\x12\x1b\n\tseries_id\x18\x03\x20\x01(\rR\x08seriesId\x12\x19\
    \n\x08match_id\x18\x04\x20\x01(\x04R\x07matchId\x12\x17\n\x07team_id\x18\
    \x05\x20\x01(\rR\x06teamId\x12\x1d\n\naccount_id\x18\x06\x20\x01(\rR\tac\
    countId\x12\x1b\n\tleague_id\x18\x07\x20\x01(\rR\x08leagueId\x12\x17\n\
    \x07node_id\x18\x08\x20\x01(\rR\x06nodeId\x12&\n\x0fserver_steam_id\x18\
    \r\x20\x01(\x04R\rserverSteamId\x12\x15\n\x06data_1\x18\t\x20\x01(\rR\
    \x05data1\x12\x15\n\x06data_2\x18\n\x20\x01(\rR\x05data2\x12\x15\n\x06da\
    ta_3\x18\x0b\x20\x01(\rR\x05data3\x12\x15\n\x06data_4\x18\x0c\x20\x01(\r\
    R\x05data4\"\x8b\x03\n\x10EFeedElementType\x12\x16\n\x12FEED_SERIES_RESU\
    LT\x10\x01\x12\x16\n\x12FEED_MATCH_POPULAR\x10\x02\x12\x1c\n\x18FEED_TEA\
    M_UPCOMING_MATCH\x10\x03\x12\x1b\n\x17FEED_TEAM_LEAGUE_RESULT\x10\x04\
    \x12\x18\n\x14FEED_TEAM_ADD_PLAYER\x10\x05\x12\x1b\n\x17FEED_TEAM_REMOVE\
    _PLAYER\x10\x06\x12\x15\n\x11FEED_TEAM_DISBAND\x10\x07\x12\x18\n\x14FEED\
    _LEAGUE_UPCOMING\x10\x08\x12\x19\n\x15FEED_LEAGUE_CONCLUDED\x10\t\x12\
    \x16\n\x12FEED_DPC_STANDINGS\x10\n\x12\x1a\n\x16FEED_ALERT_PREDICTIONS\
    \x10\x0b\x12\x16\n\x12FEED_ALERT_FANTASY\x10\x0c\x12\x1a\n\x16FEED_LEAGU\
    E_LIVE_MATCH\x10\r\x12!\n\x1dFEED_LEAGUE_INPROGRESS_SERIES\x10\x0e\"C\n\
    \x13CMsgDOTADPCUserInfo\x12,\n\x12is_plus_subscriber\x18\x01\x20\x01(\
    \x08R\x10isPlusSubscriber\"\xae\x07\n\x0fCMsgDraftTrivia\x12&\n\x0fhas_v\
    alid_match\x18\x01\x20\x01(\x08R\rhasValidMatch\x12R\n\x0fmatch_hero_inf\
    o\x18\x02\x20\x01(\x0b2*.dota.CMsgDraftTrivia.DraftTriviaMatchInfoR\rmat\
    chHeroInfo\x12&\n\x0fmatch_rank_tier\x18\x03\x20\x01(\rR\rmatchRankTier\
    \x12\x19\n\x08end_time\x18\x04\x20\x01(\rR\x07endTime\x12\x19\n\x08event\
    _id\x18\x05\x20\x01(\rR\x07eventId\x12=\n\x1bcurrent_match_voted_radiant\
    \x18\x06\x20\x01(\x08R\x18currentMatchVotedRadiant\x12M\n\x0fprevious_re\
    sult\x18\x07\x20\x01(\x0b2$.dota.CMsgDraftTrivia.PreviousResultR\x0eprev\
    iousResult\x12%\n\x0ecurrent_streak\x18\x08\x20\x01(\rR\rcurrentStreak\
    \x1aB\n\x13DraftTriviaHeroInfo\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\
    \x06heroId\x12\x12\n\x04role\x18\x02\x20\x01(\rR\x04role\x1a\xb4\x01\n\
    \x14DraftTriviaMatchInfo\x12P\n\x0eradiant_heroes\x18\x01\x20\x03(\x0b2)\
    .dota.CMsgDraftTrivia.DraftTriviaHeroInfoR\rradiantHeroes\x12J\n\x0bdire\
    _heroes\x18\x02\x20\x03(\x0b2).dota.CMsgDraftTrivia.DraftTriviaHeroInfoR\
    \ndireHeroes\x1a\x90\x02\n\x0ePreviousResult\x12'\n\x0fvoted_correctly\
    \x18\x01\x20\x01(\x08R\x0evotedCorrectly\x12#\n\rvoted_radiant\x18\x02\
    \x20\x01(\x08R\x0cvotedRadiant\x12R\n\x0fmatch_hero_info\x18\x03\x20\x01\
    (\x0b2*.dota.CMsgDraftTrivia.DraftTriviaMatchInfoR\rmatchHeroInfo\x12&\n\
    \x0fmatch_rank_tier\x18\x04\x20\x01(\rR\rmatchRankTier\x12\x19\n\x08end_\
    time\x18\x05\x20\x01(\rR\x07endTime\x12\x19\n\x08match_id\x18\x06\x20\
    \x01(\x04R\x07matchId\"\xd6\x01\n\x1dCMsgTeamFanContentAssetStatus\x12=\
    \n\nasset_type\x18\x01\x20\x01(\x0e2\x1e.dota.ETeamFanContentAssetTypeR\
    \tassetType\x12\x1f\n\x0basset_index\x18\x02\x20\x01(\rR\nassetIndex\x12\
    C\n\x0casset_status\x18\x03\x20\x01(\x0e2\x20.dota.ETeamFanContentAssetS\
    tatusR\x0bassetStatus\x12\x10\n\x03crc\x18\x04\x20\x01(\rR\x03crc\"\xa5\
    \x01\n%CMsgTeamFanContentAssetStatusResponse\x12K\n\x06result\x18\x01\
    \x20\x01(\x0e23.dota.CMsgTeamFanContentAssetStatusResponse.EResultR\x06r\
    esult\"/\n\x07EResult\x12\x0e\n\nk_eSuccess\x10\0\x12\x14\n\x10k_eIntern\
    alError\x10\x01\"\x97\x06\n\x18CMsgTeamFanContentStatus\x12S\n\x10team_s\
    tatus_list\x18\x01\x20\x03(\x0b2).dota.CMsgTeamFanContentStatus.TeamStat\
    usR\x0eteamStatusList\x1a\xa5\x05\n\nTeamStatus\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x17\n\x07team_id\x18\x02\x20\x01(\rR\x06tea\
    mId\x12\x19\n\x08logo_url\x18\x03\x20\x01(\tR\x07logoUrl\x123\n\x06statu\
    s\x18\x04\x20\x01(\x0e2\x1b.dota.ETeamFanContentStatusR\x06status\x12\
    \x1c\n\ttimestamp\x18\x05\x20\x01(\rR\ttimestamp\x12\x19\n\x08ugc_logo\
    \x18\x07\x20\x01(\x04R\x07ugcLogo\x12.\n\x13workshop_account_id\x18\x08\
    \x20\x01(\rR\x11workshopAccountId\x12\"\n\x0cabbreviation\x18\t\x20\x01(\
    \tR\x0cabbreviation\x12'\n\x0fvoiceline_count\x18\n\x20\x01(\rR\x0evoice\
    lineCount\x12\x1f\n\x0bspray_count\x18\x0b\x20\x01(\rR\nsprayCount\x12%\
    \n\x0eemoticon_count\x18\x0c\x20\x01(\rR\remoticonCount\x12'\n\x0fwallpa\
    per_count\x18\r\x20\x01(\rR\x0ewallpaperCount\x12\x18\n\x07comment\x18\
    \x0e\x20\x01(\tR\x07comment\x12+\n\x11comment_timestamp\x18\x0f\x20\x01(\
    \rR\x10commentTimestamp\x12F\n\x0casset_status\x18\x10\x20\x03(\x0b2#.do\
    ta.CMsgTeamFanContentAssetStatusR\x0bassetStatus\x12'\n\x0femail_timesta\
    mp\x18\x11\x20\x01(\rR\x0eemailTimestamp\x12\x1d\n\nemail_tier\x18\x12\
    \x20\x01(\rR\temailTier\x12\x1c\n\tlanguages\x18\x13\x20\x01(\tR\tlangua\
    ges\"\xc4\x03\n!CMsgTeamFanContentAutographStatus\x12[\n\x0fteam_autogra\
    phs\x18\x01\x20\x03(\x0b22.dota.CMsgTeamFanContentAutographStatus.TeamSt\
    atusR\x0eteamAutographs\x1a}\n\x0fAutographStatus\x12\x19\n\x08pro_name\
    \x18\x01\x20\x01(\tR\x07proName\x12\x1d\n\naccount_id\x18\x02\x20\x01(\r\
    R\taccountId\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestamp\x12\x12\
    \n\x04file\x18\x04\x20\x01(\tR\x04file\x1a\xc2\x01\n\nTeamStatus\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x17\n\x07team_id\x18\x02\x20\
    \x01(\rR\x06teamId\x12W\n\nautographs\x18\x03\x20\x03(\x0b27.dota.CMsgTe\
    amFanContentAutographStatus.AutographStatusR\nautographs\x12.\n\x13works\
    hop_account_id\x18\x04\x20\x01(\rR\x11workshopAccountId\"\xcb\x0f\n\x0cC\
    MsgDPCEvent\x125\n\x05event\x18\x01\x20\x01(\x0e2\x1f.dota.CMsgDPCEvent.\
    ELeagueEventR\x05event\x12B\n\nevent_type\x18\x02\x20\x01(\x0e2#.dota.CM\
    sgDPCEvent.ELeagueEventTypeR\teventType\x123\n\x07leagues\x18\x03\x20\
    \x03(\x0b2\x19.dota.CMsgDPCEvent.LeagueR\x07leagues\x12/\n\x13registrati\
    on_period\x18\x04\x20\x01(\rR\x12registrationPeriod\x12*\n\x11is_event_u\
    pcoming\x18\x05\x20\x01(\x08R\x0fisEventUpcoming\x12,\n\x12is_event_comp\
    leted\x18\x06\x20\x01(\x08R\x10isEventCompleted\x12\x1d\n\nevent_name\
    \x18\x07\x20\x01(\tR\teventName\x12.\n\x13multicast_league_id\x18\x08\
    \x20\x01(\rR\x11multicastLeagueId\x12+\n\x11multicast_streams\x18\t\x20\
    \x03(\rR\x10multicastStreams\x12,\n\x04tour\x18\n\x20\x01(\x0e2\x18.dota\
    .CMsgDPCEvent.ETourR\x04tour\x12.\n\x13timestamp_drop_lock\x18\x0c\x20\
    \x01(\rR\x11timestampDropLock\x12,\n\x12timestamp_add_lock\x18\r\x20\x01\
    (\rR\x10timestampAddLock\x12<\n\x1atimestamp_content_deadline\x18\x0e\
    \x20\x01(\rR\x18timestampContentDeadline\x12,\n\x12is_fantasy_enabled\
    \x18\x0f\x20\x01(\x08R\x10isFantasyEnabled\x12I\n!timestamp_content_revi\
    ew_deadline\x18\x10\x20\x01(\rR\x1etimestampContentReviewDeadline\x1ak\n\
    \tPhaseInfo\x12:\n\x05phase\x18\x01\x20\x01(\x0e2$.dota.CMsgDPCEvent.ELe\
    agueEventPhaseR\x05phase\x12\"\n\rnode_group_id\x18\x02\x20\x01(\rR\x0bn\
    odeGroupId\x1a\xbb\x01\n\x06League\x12+\n\x06region\x18\x01\x20\x01(\x0e\
    2\x13.dota.ELeagueRegionR\x06region\x121\n\x08division\x18\x02\x20\x01(\
    \x0e2\x15.dota.ELeagueDivisionR\x08division\x12\x1b\n\tleague_id\x18\x03\
    \x20\x01(\rR\x08leagueId\x124\n\x06phases\x18\x04\x20\x03(\x0b2\x1c.dota\
    .CMsgDPCEvent.PhaseInfoR\x06phases\"\xd3\x04\n\x0cELeagueEvent\x12\x11\n\
    \rEVENT_INVALID\x10\0\x12\x16\n\x12SPRING_2021_LEAGUE\x10\x01\x12\x15\n\
    \x11SPRING_2021_MAJOR\x10\x02\x12!\n\x1dINTERNATIONAL_2021_QUALIFIERS\
    \x10\x03\x12\x16\n\x12INTERNATIONAL_2021\x10\x04\x12\x16\n\x12WINTER_202\
    1_LEAGUE\x10\x05\x12\x1d\n\x19WINTER_2021_LEAGUE_FINALS\x10\x06\x12\x16\
    \n\x12SPRING_2022_LEAGUE\x10\x07\x12\x15\n\x11SPRING_2022_MAJOR\x10\x08\
    \x12\x16\n\x12SUMMER_2022_LEAGUE\x10\t\x12\x15\n\x11SUMMER_2022_MAJOR\
    \x10\n\x12\x16\n\x12INTERNATIONAL_2022\x10\x0b\x12\x19\n\x15CHINA_REGION\
    AL_FINALS\x10\x0c\x12*\n&INTERNATIONAL_2022_REGIONAL_QUALIFIERS\x10\r\
    \x12-\n)INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS\x10\x0e\x12\x16\n\x12W\
    INTER_2023_LEAGUE\x10\x0f\x12\x15\n\x11WINTER_2023_MAJOR\x10\x10\x12\x16\
    \n\x12SPRING_2023_LEAGUE\x10\x11\x12\x15\n\x11SPRING_2023_MAJOR\x10\x12\
    \x12\x16\n\x12SUMMER_2023_LEAGUE\x10\x13\x12\x15\n\x11SUMMER_2023_MAJOR\
    \x10\x14\x12\x16\n\x12INTERNATIONAL_2023\x10\x15\"\x87\x01\n\x11ELeagueE\
    ventPhase\x12\x11\n\rPHASE_INVALID\x10\0\x12\r\n\tWILD_CARD\x10\x01\x12\
    \x0f\n\x0bGROUP_STAGE\x10\x02\x12\x0b\n\x07GROUP_A\x10\x03\x12\x0b\n\x07\
    GROUP_B\x10\x04\x12\x0b\n\x07OVERALL\x10\x05\x12\x0b\n\x07PLAYOFF\x10\
    \x06\x12\x0b\n\x07RESULTS\x10\x07\"z\n\x10ELeagueEventType\x12\x0b\n\x07\
    UNKNOWN\x10\0\x12\n\n\x06LEAGUE\x10\x01\x12\t\n\x05MAJOR\x10\x02\x12\x1c\
    \n\x18INTERNATIONAL_QUALIFIERS\x10\x03\x12\x11\n\rINTERNATIONAL\x10\x04\
    \x12\x11\n\rLEAGUE_FINALS\x10\x05\":\n\x05ETour\x12\r\n\tTOUR_NONE\x10\0\
    \x12\n\n\x06TOUR_1\x10\x01\x12\n\n\x06TOUR_2\x10\x02\x12\n\n\x06TOUR_3\
    \x10\x03\">\n\x10CMsgDPCEventList\x12*\n\x06events\x18\x01\x20\x03(\x0b2\
    \x12.dota.CMsgDPCEventR\x06events\"\x97\x06\n\x19CMsgDOTAFantasyCardLine\
    up\x12@\n\x07periods\x18\x01\x20\x03(\x0b2&.dota.CMsgDOTAFantasyCardLine\
    up.PeriodR\x07periods\x1aK\n\tCardBonus\x12\x1d\n\nbonus_stat\x18\x01\
    \x20\x01(\rR\tbonusStat\x12\x1f\n\x0bbonus_value\x18\x02\x20\x01(\rR\nbo\
    nusValue\x1a\xaf\x02\n\x04Card\x12*\n\x11player_account_id\x18\x01\x20\
    \x01(\rR\x0fplayerAccountId\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\
    \nplayerName\x12\x17\n\x07team_id\x18\x03\x20\x01(\rR\x06teamId\x12\x1b\
    \n\tteam_name\x18\x04\x20\x01(\tR\x08teamName\x12\x12\n\x04role\x18\x05\
    \x20\x01(\rR\x04role\x12C\n\x07bonuses\x18\x06\x20\x03(\x0b2).dota.CMsgD\
    OTAFantasyCardLineup.CardBonusR\x07bonuses\x12\x14\n\x05score\x18\x07\
    \x20\x01(\x02R\x05score\x12\x1c\n\tfinalized\x18\x08\x20\x01(\x08R\tfina\
    lized\x12\x17\n\x07item_id\x18\t\x20\x01(\x04R\x06itemId\x1aw\n\x06Leagu\
    e\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x12:\n\x05cards\
    \x18\x02\x20\x03(\x0b2$.dota.CMsgDOTAFantasyCardLineup.CardR\x05cards\
    \x12\x14\n\x05score\x18\x03\x20\x01(\x02R\x05score\x1a\xbf\x01\n\x06Peri\
    od\x12%\n\x0efantasy_period\x18\x01\x20\x01(\rR\rfantasyPeriod\x12'\n\
    \x0ftimestamp_start\x18\x02\x20\x01(\rR\x0etimestampStart\x12#\n\rtimest\
    amp_end\x18\x03\x20\x01(\rR\x0ctimestampEnd\x12@\n\x07leagues\x18\x04\
    \x20\x03(\x0b2&.dota.CMsgDOTAFantasyCardLineup.LeagueR\x07leagues\"\x9c\
    \x03\n\x17CMsgDOTAFantasyCardList\x128\n\x05cards\x18\x01\x20\x03(\x0b2\
    \".dota.CMsgDOTAFantasyCardList.CardR\x05cards\x1aK\n\tCardBonus\x12\x1d\
    \n\nbonus_stat\x18\x01\x20\x01(\rR\tbonusStat\x12\x1f\n\x0bbonus_value\
    \x18\x02\x20\x01(\rR\nbonusValue\x1a\xf9\x01\n\x04Card\x12*\n\x11player_\
    account_id\x18\x01\x20\x01(\rR\x0fplayerAccountId\x12\x1f\n\x0bplayer_na\
    me\x18\x02\x20\x01(\tR\nplayerName\x12\x17\n\x07team_id\x18\x03\x20\x01(\
    \rR\x06teamId\x12\x1b\n\tteam_name\x18\x04\x20\x01(\tR\x08teamName\x12\
    \x12\n\x04role\x18\x05\x20\x01(\rR\x04role\x12A\n\x07bonuses\x18\x06\x20\
    \x03(\x0b2'.dota.CMsgDOTAFantasyCardList.CardBonusR\x07bonuses\x12\x17\n\
    \x07item_id\x18\x08\x20\x01(\x04R\x06itemId\"\xb5\x02\n\x16CMsgChatToxic\
    ityReport\x12(\n\x10num_matches_seen\x18\x01\x20\x01(\rR\x0enumMatchesSe\
    en\x12!\n\x0cnum_messages\x18\x02\x20\x01(\rR\x0bnumMessages\x12D\n\x1fn\
    um_messages_human_thinks_toxic\x18\x03\x20\x01(\rR\x1bnumMessagesHumanTh\
    inksToxic\x12>\n\x1cnum_messages_ml_thinks_toxic\x18\x04\x20\x01(\rR\x18\
    numMessagesMlThinksToxic\x12\x16\n\x06status\x18\x05\x20\x01(\tR\x06stat\
    us\x12\x16\n\x06result\x18\x06\x20\x01(\rR\x06result\x12\x18\n\x07messag\
    e\x18\x07\x20\x01(\tR\x07message\"\x96\x03\n\x1bCMsgGetTeamAuditInformat\
    ion\x12\x17\n\x07team_id\x18\x01\x20\x01(\rR\x06teamId\x12\x1b\n\tteam_n\
    ame\x18\x02\x20\x01(\tR\x08teamName\x12B\n\x07actions\x18\x03\x20\x03(\
    \x0b2(.dota.CMsgGetTeamAuditInformation.ActionR\x07actions\x12!\n\x0clas\
    t_updated\x18\x04\x20\x01(\rR\x0blastUpdated\x1a\xd9\x01\n\x06Action\x12\
    /\n\x13registration_period\x18\x01\x20\x01(\rR\x12registrationPeriod\x12\
    \x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x16\n\x06action\
    \x18\x03\x20\x01(\rR\x06action\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\rR\
    \ttimestamp\x12\x1f\n\x0bplayer_name\x18\x05\x20\x01(\tR\nplayerName\x12\
    (\n\x10player_real_name\x18\x06\x20\x01(\tR\x0eplayerRealName\"s\n\x10CM\
    sgDOTADPCMatch\x12)\n\x05match\x18\x01\x20\x01(\x0b2\x13.dota.CMsgDOTAMa\
    tchR\x05match\x124\n\x08metadata\x18\x02\x20\x01(\x0b2\x18.dota.CDOTAMat\
    chMetadataR\x08metadata*\x88\x01\n\x15ETeamFanContentStatus\x12#\n\x1fTE\
    AM_FAN_CONTENT_STATUS_INVALID\x10\0\x12#\n\x1fTEAM_FAN_CONTENT_STATUS_PE\
    NDING\x10\x01\x12%\n!TEAM_FAN_CONTENT_STATUS_EVALUATED\x10\x02*\xe9\x02\
    \n\x18ETeamFanContentAssetType\x12\"\n\x1ek_eFanContentAssetType_LogoPNG\
    \x10\x01\x12\"\n\x1ek_eFanContentAssetType_LogoSVG\x10\x02\x12!\n\x1dk_e\
    FanContentAssetType_Logo3D\x10\x03\x12\"\n\x1ek_eFanContentAssetType_Pla\
    yers\x10\x04\x12!\n\x1dk_eFanContentAssetType_Sprays\x10\x05\x12%\n!k_eF\
    anContentAssetType_Wallpapers\x10\x06\x12$\n\x20k_eFanContentAssetType_E\
    moticons\x10\x07\x12%\n!k_eFanContentAssetType_VoiceLines\x10\x08\x12'\n\
    #k_eFanContentAssetType_Localization\x10\t*\x8d\x01\n\x1aETeamFanContent\
    AssetStatus\x12!\n\x1dk_eFanContentAssetStatus_None\x10\0\x12%\n!k_eFanC\
    ontentAssetStatus_Approved\x10\x01\x12%\n!k_eFanContentAssetStatus_Rejec\
    ted\x10\x02B%Z#github.com/dotabuff/manta/dota;dotaJ\x93\x85\x01\n\x07\
    \x12\x05\0\0\xec\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\
    \x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\n\t\n\x02\x03\x01\
    \x12\x03\x06\x07\x1f\n\t\n\x02\x03\x02\x12\x03\x07\x07\x20\n\t\n\x02\x03\
    \x03\x12\x03\x08\x07%\n\t\n\x02\x03\x04\x12\x03\t\x07\"\n\n\n\x02\x05\0\
    \x12\x04\x0b\0\x0f\x01\n\n\n\x03\x05\0\x01\x12\x03\x0b\x05\x1a\n\x0b\n\
    \x04\x05\0\x02\0\x12\x03\x0c\x08,\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\
    \x0c\x08'\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x0c*+\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\r\x08,\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\r\x08'\n\
    \x0c\n\x05\x05\0\x02\x01\x02\x12\x03\r*+\n\x0b\n\x04\x05\0\x02\x02\x12\
    \x03\x0e\x08.\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0e\x08)\n\x0c\n\x05\
    \x05\0\x02\x02\x02\x12\x03\x0e,-\n\n\n\x02\x05\x01\x12\x04\x11\0\x1b\x01\
    \n\n\n\x03\x05\x01\x01\x12\x03\x11\x05\x1d\n\x0b\n\x04\x05\x01\x02\0\x12\
    \x03\x12\x08+\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x12\x08&\n\x0c\n\x05\
    \x05\x01\x02\0\x02\x12\x03\x12)*\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x13\
    \x08+\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x13\x08&\n\x0c\n\x05\x05\
    \x01\x02\x01\x02\x12\x03\x13)*\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x14\
    \x08*\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x14\x08%\n\x0c\n\x05\x05\
    \x01\x02\x02\x02\x12\x03\x14()\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x15\
    \x08+\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x15\x08&\n\x0c\n\x05\x05\
    \x01\x02\x03\x02\x12\x03\x15)*\n\x0b\n\x04\x05\x01\x02\x04\x12\x03\x16\
    \x08*\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x16\x08%\n\x0c\n\x05\x05\
    \x01\x02\x04\x02\x12\x03\x16()\n\x0b\n\x04\x05\x01\x02\x05\x12\x03\x17\
    \x08.\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\x17\x08)\n\x0c\n\x05\x05\
    \x01\x02\x05\x02\x12\x03\x17,-\n\x0b\n\x04\x05\x01\x02\x06\x12\x03\x18\
    \x08-\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03\x18\x08(\n\x0c\n\x05\x05\
    \x01\x02\x06\x02\x12\x03\x18+,\n\x0b\n\x04\x05\x01\x02\x07\x12\x03\x19\
    \x08.\n\x0c\n\x05\x05\x01\x02\x07\x01\x12\x03\x19\x08)\n\x0c\n\x05\x05\
    \x01\x02\x07\x02\x12\x03\x19,-\n\x0b\n\x04\x05\x01\x02\x08\x12\x03\x1a\
    \x080\n\x0c\n\x05\x05\x01\x02\x08\x01\x12\x03\x1a\x08+\n\x0c\n\x05\x05\
    \x01\x02\x08\x02\x12\x03\x1a./\n\n\n\x02\x05\x02\x12\x04\x1d\0!\x01\n\n\
    \n\x03\x05\x02\x01\x12\x03\x1d\x05\x1f\n\x0b\n\x04\x05\x02\x02\0\x12\x03\
    \x1e\x08*\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03\x1e\x08%\n\x0c\n\x05\x05\
    \x02\x02\0\x02\x12\x03\x1e()\n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x1f\x08\
    .\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03\x1f\x08)\n\x0c\n\x05\x05\x02\
    \x02\x01\x02\x12\x03\x1f,-\n\x0b\n\x04\x05\x02\x02\x02\x12\x03\x20\x08.\
    \n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03\x20\x08)\n\x0c\n\x05\x05\x02\
    \x02\x02\x02\x12\x03\x20,-\n\n\n\x02\x04\0\x12\x04#\0@\x01\n\n\n\x03\x04\
    \0\x01\x12\x03#\x08\x17\n\x0c\n\x04\x04\0\x03\0\x12\x04$\x080\t\n\x0c\n\
    \x05\x04\0\x03\0\x01\x12\x03$\x10\x15\n\r\n\x06\x04\0\x03\0\x02\0\x12\
    \x03%\x10-\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03%\x10\x18\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x05\x12\x03%\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\
    \0\x01\x12\x03%\x20(\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03%+,\n\r\n\
    \x06\x04\0\x03\0\x02\x01\x12\x03&\x10.\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x04\x12\x03&\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03&\x19\
    \x1f\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03&\x20)\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x03\x12\x03&,-\n\r\n\x06\x04\0\x03\0\x02\x02\x12\x03'\x10\
    .\n\x0e\n\x07\x04\0\x03\0\x02\x02\x04\x12\x03'\x10\x18\n\x0e\n\x07\x04\0\
    \x03\0\x02\x02\x05\x12\x03'\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x02\x01\
    \x12\x03'\x20)\n\x0e\n\x07\x04\0\x03\0\x02\x02\x03\x12\x03',-\n\r\n\x06\
    \x04\0\x03\0\x02\x03\x12\x03(\x103\n\x0e\n\x07\x04\0\x03\0\x02\x03\x04\
    \x12\x03(\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x03\x05\x12\x03(\x19\x1f\n\
    \x0e\n\x07\x04\0\x03\0\x02\x03\x01\x12\x03(\x20.\n\x0e\n\x07\x04\0\x03\0\
    \x02\x03\x03\x12\x03(12\n\r\n\x06\x04\0\x03\0\x02\x04\x12\x03)\x103\n\
    \x0e\n\x07\x04\0\x03\0\x02\x04\x04\x12\x03)\x10\x18\n\x0e\n\x07\x04\0\
    \x03\0\x02\x04\x05\x12\x03)\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x04\x01\
    \x12\x03)\x20.\n\x0e\n\x07\x04\0\x03\0\x02\x04\x03\x12\x03)12\n\r\n\x06\
    \x04\0\x03\0\x02\x05\x12\x03*\x101\n\x0e\n\x07\x04\0\x03\0\x02\x05\x04\
    \x12\x03*\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x05\x05\x12\x03*\x19\x1f\n\
    \x0e\n\x07\x04\0\x03\0\x02\x05\x01\x12\x03*\x20,\n\x0e\n\x07\x04\0\x03\0\
    \x02\x05\x03\x12\x03*/0\n\r\n\x06\x04\0\x03\0\x02\x06\x12\x03+\x101\n\
    \x0e\n\x07\x04\0\x03\0\x02\x06\x04\x12\x03+\x10\x18\n\x0e\n\x07\x04\0\
    \x03\0\x02\x06\x05\x12\x03+\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x06\x01\
    \x12\x03+\x20,\n\x0e\n\x07\x04\0\x03\0\x02\x06\x03\x12\x03+/0\n\r\n\x06\
    \x04\0\x03\0\x02\x07\x12\x03,\x101\n\x0e\n\x07\x04\0\x03\0\x02\x07\x04\
    \x12\x03,\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x07\x05\x12\x03,\x19\x1f\n\
    \x0e\n\x07\x04\0\x03\0\x02\x07\x01\x12\x03,\x20,\n\x0e\n\x07\x04\0\x03\0\
    \x02\x07\x03\x12\x03,/0\n\r\n\x06\x04\0\x03\0\x02\x08\x12\x03-\x101\n\
    \x0e\n\x07\x04\0\x03\0\x02\x08\x04\x12\x03-\x10\x18\n\x0e\n\x07\x04\0\
    \x03\0\x02\x08\x05\x12\x03-\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x08\x01\
    \x12\x03-\x20,\n\x0e\n\x07\x04\0\x03\0\x02\x08\x03\x12\x03-/0\n\r\n\x06\
    \x04\0\x03\0\x02\t\x12\x03.\x103\n\x0e\n\x07\x04\0\x03\0\x02\t\x04\x12\
    \x03.\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\t\x05\x12\x03.\x19\x1d\n\x0e\n\
    \x07\x04\0\x03\0\x02\t\x01\x12\x03.\x1e-\n\x0e\n\x07\x04\0\x03\0\x02\t\
    \x03\x12\x03.02\n\r\n\x06\x04\0\x03\0\x02\n\x12\x03/\x10@\n\x0e\n\x07\
    \x04\0\x03\0\x02\n\x04\x12\x03/\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\n\
    \x05\x12\x03/\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\n\x01\x12\x03/\x20:\n\
    \x0e\n\x07\x04\0\x03\0\x02\n\x03\x12\x03/=?\n\x0c\n\x04\x04\0\x04\0\x12\
    \x042\x086\t\n\x0c\n\x05\x04\0\x04\0\x01\x12\x032\r\x18\n\r\n\x06\x04\0\
    \x04\0\x02\0\x12\x033\x10\x1d\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x033\
    \x10\x18\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x033\x1b\x1c\n\r\n\x06\
    \x04\0\x04\0\x02\x01\x12\x034\x10\x20\n\x0e\n\x07\x04\0\x04\0\x02\x01\
    \x01\x12\x034\x10\x1b\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x034\x1e\
    \x1f\n\r\n\x06\x04\0\x04\0\x02\x02\x12\x035\x10\x1e\n\x0e\n\x07\x04\0\
    \x04\0\x02\x02\x01\x12\x035\x10\x19\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\
    \x12\x035\x1c\x1d\n\x0b\n\x04\x04\0\x02\0\x12\x038\x083\n\x0c\n\x05\x04\
    \0\x02\0\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\0\x02\0\x06\x12\x038\x11&\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x038'.\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03812\n\x0b\n\x04\x04\0\x02\x01\x12\x039\x081\n\x0c\n\x05\x04\0\x02\
    \x01\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x039\x11\x17\
    \n\x0c\n\x05\x04\0\x02\x01\x01\x12\x039\x18,\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x039/0\n\x0b\n\x04\x04\0\x02\x02\x12\x03:\x08)\n\x0c\n\x05\x04\
    \0\x02\x02\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03:\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03:\x18$\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03:'(\n\x0b\n\x04\x04\0\x02\x03\x12\x03;\x08)\n\x0c\n\
    \x05\x04\0\x02\x03\x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\
    \x12\x03;\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03;\x18$\n\x0c\n\
    \x05\x04\0\x02\x03\x03\x12\x03;'(\n\x0b\n\x04\x04\0\x02\x04\x12\x03<\x08\
    7\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03<\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x04\x05\x12\x03<\x11\x15\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03<\x162\n\
    \x0c\n\x05\x04\0\x02\x04\x03\x12\x03<56\n\x0b\n\x04\x04\0\x02\x05\x12\
    \x03=\x084\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03=\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x05\x05\x12\x03=\x11\x17\n\x0c\n\x05\x04\0\x02\x05\x01\x12\
    \x03=\x18/\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03=23\n\x0b\n\x04\x04\0\
    \x02\x06\x12\x03>\x08%\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03>\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x06\x05\x12\x03>\x11\x17\n\x0c\n\x05\x04\0\x02\x06\
    \x01\x12\x03>\x18\x20\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03>#$\n\x0b\n\
    \x04\x04\0\x02\x07\x12\x03?\x08.\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03?\
    \x08\x10\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03?\x11\x17\n\x0c\n\x05\x04\
    \0\x02\x07\x01\x12\x03?\x18)\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03?,-\n\
    \n\n\x02\x04\x01\x12\x04B\0e\x01\n\n\n\x03\x04\x01\x01\x12\x03B\x08\x17\
    \n\x0c\n\x04\x04\x01\x03\0\x12\x04C\x08Q\t\n\x0c\n\x05\x04\x01\x03\0\x01\
    \x12\x03C\x10\x17\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03D\x10C\n\x0e\n\
    \x07\x04\x01\x03\0\x02\0\x04\x12\x03D\x10\x18\n\x0e\n\x07\x04\x01\x03\0\
    \x02\0\x06\x12\x03D\x199\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\x12\x03D:>\
    \n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x03DAB\n\r\n\x06\x04\x01\x03\0\
    \x02\x01\x12\x03E\x10.\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x03E\
    \x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x03E\x19\x1f\n\x0e\n\
    \x07\x04\x01\x03\0\x02\x01\x01\x12\x03E\x20)\n\x0e\n\x07\x04\x01\x03\0\
    \x02\x01\x03\x12\x03E,-\n\r\n\x06\x04\x01\x03\0\x02\x02\x12\x03F\x10.\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x02\x04\x12\x03F\x10\x18\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x02\x05\x12\x03F\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x02\x01\x12\x03F\x20)\n\x0e\n\x07\x04\x01\x03\0\x02\x02\x03\x12\x03F,-\
    \n\r\n\x06\x04\x01\x03\0\x02\x03\x12\x03G\x10-\n\x0e\n\x07\x04\x01\x03\0\
    \x02\x03\x04\x12\x03G\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x05\x12\
    \x03G\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x01\x12\x03G\x20(\n\x0e\
    \n\x07\x04\x01\x03\0\x02\x03\x03\x12\x03G+,\n\r\n\x06\x04\x01\x03\0\x02\
    \x04\x12\x03H\x10,\n\x0e\n\x07\x04\x01\x03\0\x02\x04\x04\x12\x03H\x10\
    \x18\n\x0e\n\x07\x04\x01\x03\0\x02\x04\x05\x12\x03H\x19\x1f\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x04\x01\x12\x03H\x20'\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x04\x03\x12\x03H*+\n\r\n\x06\x04\x01\x03\0\x02\x05\x12\x03I\x10/\n\x0e\
    \n\x07\x04\x01\x03\0\x02\x05\x04\x12\x03I\x10\x18\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x05\x05\x12\x03I\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x05\
    \x01\x12\x03I\x20*\n\x0e\n\x07\x04\x01\x03\0\x02\x05\x03\x12\x03I-.\n\r\
    \n\x06\x04\x01\x03\0\x02\x06\x12\x03J\x10.\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x06\x04\x12\x03J\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x06\x05\x12\x03J\
    \x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x06\x01\x12\x03J\x20)\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x06\x03\x12\x03J,-\n\r\n\x06\x04\x01\x03\0\x02\x07\
    \x12\x03K\x10,\n\x0e\n\x07\x04\x01\x03\0\x02\x07\x04\x12\x03K\x10\x18\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x07\x05\x12\x03K\x19\x1f\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x07\x01\x12\x03K\x20'\n\x0e\n\x07\x04\x01\x03\0\x02\x07\
    \x03\x12\x03K*+\n\r\n\x06\x04\x01\x03\0\x02\x08\x12\x03L\x105\n\x0e\n\
    \x07\x04\x01\x03\0\x02\x08\x04\x12\x03L\x10\x18\n\x0e\n\x07\x04\x01\x03\
    \0\x02\x08\x05\x12\x03L\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x08\x01\
    \x12\x03L\x20/\n\x0e\n\x07\x04\x01\x03\0\x02\x08\x03\x12\x03L24\n\r\n\
    \x06\x04\x01\x03\0\x02\t\x12\x03M\x10+\n\x0e\n\x07\x04\x01\x03\0\x02\t\
    \x04\x12\x03M\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\t\x05\x12\x03M\x19\
    \x1f\n\x0e\n\x07\x04\x01\x03\0\x02\t\x01\x12\x03M\x20&\n\x0e\n\x07\x04\
    \x01\x03\0\x02\t\x03\x12\x03M)*\n\r\n\x06\x04\x01\x03\0\x02\n\x12\x03N\
    \x10,\n\x0e\n\x07\x04\x01\x03\0\x02\n\x04\x12\x03N\x10\x18\n\x0e\n\x07\
    \x04\x01\x03\0\x02\n\x05\x12\x03N\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\
    \n\x01\x12\x03N\x20&\n\x0e\n\x07\x04\x01\x03\0\x02\n\x03\x12\x03N)+\n\r\
    \n\x06\x04\x01\x03\0\x02\x0b\x12\x03O\x10,\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x0b\x04\x12\x03O\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x0b\x05\x12\x03O\
    \x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x0b\x01\x12\x03O\x20&\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x0b\x03\x12\x03O)+\n\r\n\x06\x04\x01\x03\0\x02\x0c\
    \x12\x03P\x10,\n\x0e\n\x07\x04\x01\x03\0\x02\x0c\x04\x12\x03P\x10\x18\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x0c\x05\x12\x03P\x19\x1f\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x0c\x01\x12\x03P\x20&\n\x0e\n\x07\x04\x01\x03\0\x02\x0c\
    \x03\x12\x03P)+\n\x0c\n\x04\x04\x01\x04\0\x12\x04S\x08b\t\n\x0c\n\x05\
    \x04\x01\x04\0\x01\x12\x03S\r\x1d\n\r\n\x06\x04\x01\x04\0\x02\0\x12\x03T\
    \x10'\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\x03T\x10\"\n\x0e\n\x07\x04\
    \x01\x04\0\x02\0\x02\x12\x03T%&\n\r\n\x06\x04\x01\x04\0\x02\x01\x12\x03U\
    \x10'\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x03U\x10\"\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x01\x02\x12\x03U%&\n\r\n\x06\x04\x01\x04\0\x02\x02\
    \x12\x03V\x10-\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x03V\x10(\n\x0e\
    \n\x07\x04\x01\x04\0\x02\x02\x02\x12\x03V+,\n\r\n\x06\x04\x01\x04\0\x02\
    \x03\x12\x03W\x10,\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x03W\x10'\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x03W*+\n\r\n\x06\x04\x01\x04\0\
    \x02\x04\x12\x03X\x10)\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x01\x12\x03X\
    \x10$\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x02\x12\x03X'(\n\r\n\x06\x04\x01\
    \x04\0\x02\x05\x12\x03Y\x10,\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x01\x12\
    \x03Y\x10'\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x02\x12\x03Y*+\n\r\n\x06\
    \x04\x01\x04\0\x02\x06\x12\x03Z\x10&\n\x0e\n\x07\x04\x01\x04\0\x02\x06\
    \x01\x12\x03Z\x10!\n\x0e\n\x07\x04\x01\x04\0\x02\x06\x02\x12\x03Z$%\n\r\
    \n\x06\x04\x01\x04\0\x02\x07\x12\x03[\x10)\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x07\x01\x12\x03[\x10$\n\x0e\n\x07\x04\x01\x04\0\x02\x07\x02\x12\x03['(\
    \n\r\n\x06\x04\x01\x04\0\x02\x08\x12\x03\\\x10*\n\x0e\n\x07\x04\x01\x04\
    \0\x02\x08\x01\x12\x03\\\x10%\n\x0e\n\x07\x04\x01\x04\0\x02\x08\x02\x12\
    \x03\\()\n\r\n\x06\x04\x01\x04\0\x02\t\x12\x03]\x10(\n\x0e\n\x07\x04\x01\
    \x04\0\x02\t\x01\x12\x03]\x10\"\n\x0e\n\x07\x04\x01\x04\0\x02\t\x02\x12\
    \x03]%'\n\r\n\x06\x04\x01\x04\0\x02\n\x12\x03^\x10,\n\x0e\n\x07\x04\x01\
    \x04\0\x02\n\x01\x12\x03^\x10&\n\x0e\n\x07\x04\x01\x04\0\x02\n\x02\x12\
    \x03^)+\n\r\n\x06\x04\x01\x04\0\x02\x0b\x12\x03_\x10(\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x0b\x01\x12\x03_\x10\"\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\
    \x02\x12\x03_%'\n\r\n\x06\x04\x01\x04\0\x02\x0c\x12\x03`\x10,\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x0c\x01\x12\x03`\x10&\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x0c\x02\x12\x03`)+\n\r\n\x06\x04\x01\x04\0\x02\r\x12\x03a\x103\n\
    \x0e\n\x07\x04\x01\x04\0\x02\r\x01\x12\x03a\x10-\n\x0e\n\x07\x04\x01\x04\
    \0\x02\r\x02\x12\x03a02\n\x0b\n\x04\x04\x01\x02\0\x12\x03d\x086\n\x0c\n\
    \x05\x04\x01\x02\0\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x06\
    \x12\x03d\x11(\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03d)1\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03d45\n\n\n\x02\x04\x02\x12\x04g\0i\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03g\x08\x1b\n\x0b\n\x04\x04\x02\x02\0\x12\x03h\x08-\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03h\x11\x15\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03h\x16(\n\x0c\
    \n\x05\x04\x02\x02\0\x03\x12\x03h+,\n\x0b\n\x02\x04\x03\x12\x05k\0\x87\
    \x01\x01\n\n\n\x03\x04\x03\x01\x12\x03k\x08\x17\n\x0c\n\x04\x04\x03\x03\
    \0\x12\x04l\x08o\t\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x03l\x10#\n\r\n\x06\
    \x04\x03\x03\0\x02\0\x12\x03m\x10,\n\x0e\n\x07\x04\x03\x03\0\x02\0\x04\
    \x12\x03m\x10\x18\n\x0e\n\x07\x04\x03\x03\0\x02\0\x05\x12\x03m\x19\x1f\n\
    \x0e\n\x07\x04\x03\x03\0\x02\0\x01\x12\x03m\x20'\n\x0e\n\x07\x04\x03\x03\
    \0\x02\0\x03\x12\x03m*+\n\r\n\x06\x04\x03\x03\0\x02\x01\x12\x03n\x10)\n\
    \x0e\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x03n\x10\x18\n\x0e\n\x07\x04\
    \x03\x03\0\x02\x01\x05\x12\x03n\x19\x1f\n\x0e\n\x07\x04\x03\x03\0\x02\
    \x01\x01\x12\x03n\x20$\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x03n'(\
    \n\x0c\n\x04\x04\x03\x03\x01\x12\x04q\x08t\t\n\x0c\n\x05\x04\x03\x03\x01\
    \x01\x12\x03q\x10$\n\r\n\x06\x04\x03\x03\x01\x02\0\x12\x03r\x10P\n\x0e\n\
    \x07\x04\x03\x03\x01\x02\0\x04\x12\x03r\x10\x18\n\x0e\n\x07\x04\x03\x03\
    \x01\x02\0\x06\x12\x03r\x19<\n\x0e\n\x07\x04\x03\x03\x01\x02\0\x01\x12\
    \x03r=K\n\x0e\n\x07\x04\x03\x03\x01\x02\0\x03\x12\x03rNO\n\r\n\x06\x04\
    \x03\x03\x01\x02\x01\x12\x03s\x10M\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\
    \x04\x12\x03s\x10\x18\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\x06\x12\x03s\
    \x19<\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\x01\x12\x03s=H\n\x0e\n\x07\x04\
    \x03\x03\x01\x02\x01\x03\x12\x03sKL\n\x0c\n\x04\x04\x03\x03\x02\x12\x04v\
    \x08}\t\n\x0c\n\x05\x04\x03\x03\x02\x01\x12\x03v\x10\x1e\n\r\n\x06\x04\
    \x03\x03\x02\x02\0\x12\x03w\x102\n\x0e\n\x07\x04\x03\x03\x02\x02\0\x04\
    \x12\x03w\x10\x18\n\x0e\n\x07\x04\x03\x03\x02\x02\0\x05\x12\x03w\x19\x1d\
    \n\x0e\n\x07\x04\x03\x03\x02\x02\0\x01\x12\x03w\x1e-\n\x0e\n\x07\x04\x03\
    \x03\x02\x02\0\x03\x12\x03w01\n\r\n\x06\x04\x03\x03\x02\x02\x01\x12\x03x\
    \x100\n\x0e\n\x07\x04\x03\x03\x02\x02\x01\x04\x12\x03x\x10\x18\n\x0e\n\
    \x07\x04\x03\x03\x02\x02\x01\x05\x12\x03x\x19\x1d\n\x0e\n\x07\x04\x03\
    \x03\x02\x02\x01\x01\x12\x03x\x1e+\n\x0e\n\x07\x04\x03\x03\x02\x02\x01\
    \x03\x12\x03x./\n\r\n\x06\x04\x03\x03\x02\x02\x02\x12\x03y\x10R\n\x0e\n\
    \x07\x04\x03\x03\x02\x02\x02\x04\x12\x03y\x10\x18\n\x0e\n\x07\x04\x03\
    \x03\x02\x02\x02\x06\x12\x03y\x19=\n\x0e\n\x07\x04\x03\x03\x02\x02\x02\
    \x01\x12\x03y>M\n\x0e\n\x07\x04\x03\x03\x02\x02\x02\x03\x12\x03yPQ\n\r\n\
    \x06\x04\x03\x03\x02\x02\x03\x12\x03z\x104\n\x0e\n\x07\x04\x03\x03\x02\
    \x02\x03\x04\x12\x03z\x10\x18\n\x0e\n\x07\x04\x03\x03\x02\x02\x03\x05\
    \x12\x03z\x19\x1f\n\x0e\n\x07\x04\x03\x03\x02\x02\x03\x01\x12\x03z\x20/\
    \n\x0e\n\x07\x04\x03\x03\x02\x02\x03\x03\x12\x03z23\n\r\n\x06\x04\x03\
    \x03\x02\x02\x04\x12\x03{\x10-\n\x0e\n\x07\x04\x03\x03\x02\x02\x04\x04\
    \x12\x03{\x10\x18\n\x0e\n\x07\x04\x03\x03\x02\x02\x04\x05\x12\x03{\x19\
    \x1f\n\x0e\n\x07\x04\x03\x03\x02\x02\x04\x01\x12\x03{\x20(\n\x0e\n\x07\
    \x04\x03\x03\x02\x02\x04\x03\x12\x03{+,\n\r\n\x06\x04\x03\x03\x02\x02\
    \x05\x12\x03|\x10-\n\x0e\n\x07\x04\x03\x03\x02\x02\x05\x04\x12\x03|\x10\
    \x18\n\x0e\n\x07\x04\x03\x03\x02\x02\x05\x05\x12\x03|\x19\x1f\n\x0e\n\
    \x07\x04\x03\x03\x02\x02\x05\x01\x12\x03|\x20(\n\x0e\n\x07\x04\x03\x03\
    \x02\x02\x05\x03\x12\x03|+,\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x7f\x08*\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \0\x05\x12\x03\x7f\x11\x15\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x7f\x16\
    %\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x7f()\n\x0c\n\x04\x04\x03\x02\
    \x01\x12\x04\x80\x01\x08J\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\x80\x01\
    \x08\x10\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x80\x01\x115\n\r\n\x05\
    \x04\x03\x02\x01\x01\x12\x04\x80\x016E\n\r\n\x05\x04\x03\x02\x01\x03\x12\
    \x04\x80\x01HI\n\x0c\n\x04\x04\x03\x02\x02\x12\x04\x81\x01\x08,\n\r\n\
    \x05\x04\x03\x02\x02\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\x03\x02\
    \x02\x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\
    \x81\x01\x18'\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\x81\x01*+\n\x0c\n\
    \x04\x04\x03\x02\x03\x12\x04\x82\x01\x08%\n\r\n\x05\x04\x03\x02\x03\x04\
    \x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\x82\x01\
    \x11\x17\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\x82\x01\x18\x20\n\r\n\x05\
    \x04\x03\x02\x03\x03\x12\x04\x82\x01#$\n\x0c\n\x04\x04\x03\x02\x04\x12\
    \x04\x83\x01\x08%\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04\x83\x01\x08\x10\
    \n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\x83\x01\x11\x17\n\r\n\x05\x04\x03\
    \x02\x04\x01\x12\x04\x83\x01\x18\x20\n\r\n\x05\x04\x03\x02\x04\x03\x12\
    \x04\x83\x01#$\n\x0c\n\x04\x04\x03\x02\x05\x12\x04\x84\x01\x086\n\r\n\
    \x05\x04\x03\x02\x05\x04\x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\x03\x02\
    \x05\x05\x12\x04\x84\x01\x11\x15\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\
    \x84\x01\x161\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\x84\x0145\n\x0c\n\
    \x04\x04\x03\x02\x06\x12\x04\x85\x01\x08D\n\r\n\x05\x04\x03\x02\x06\x04\
    \x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x03\x02\x06\x06\x12\x04\x85\x01\
    \x11/\n\r\n\x05\x04\x03\x02\x06\x01\x12\x04\x85\x010?\n\r\n\x05\x04\x03\
    \x02\x06\x03\x12\x04\x85\x01BC\n\x0c\n\x04\x04\x03\x02\x07\x12\x04\x86\
    \x01\x08+\n\r\n\x05\x04\x03\x02\x07\x04\x12\x04\x86\x01\x08\x10\n\r\n\
    \x05\x04\x03\x02\x07\x05\x12\x04\x86\x01\x11\x17\n\r\n\x05\x04\x03\x02\
    \x07\x01\x12\x04\x86\x01\x18&\n\r\n\x05\x04\x03\x02\x07\x03\x12\x04\x86\
    \x01)*\n\x0c\n\x02\x04\x04\x12\x06\x89\x01\0\x8e\x01\x01\n\x0b\n\x03\x04\
    \x04\x01\x12\x04\x89\x01\x08%\n\x0c\n\x04\x04\x04\x02\0\x12\x04\x8a\x01\
    \x089\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x8a\x01\x08\x10\n\r\n\x05\x04\
    \x04\x02\0\x06\x12\x04\x8a\x01\x11)\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\
    \x8a\x01*4\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x8a\x0178\n\x0c\n\x04\x04\
    \x04\x02\x01\x12\x04\x8b\x01\x08(\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\
    \x8b\x01\x08\x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\x8b\x01\x11\x17\n\
    \r\n\x05\x04\x04\x02\x01\x01\x12\x04\x8b\x01\x18#\n\r\n\x05\x04\x04\x02\
    \x01\x03\x12\x04\x8b\x01&'\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\x8c\x01\
    \x08=\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\
    \x04\x04\x02\x02\x06\x12\x04\x8c\x01\x11+\n\r\n\x05\x04\x04\x02\x02\x01\
    \x12\x04\x8c\x01,8\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x8c\x01;<\n\x0c\
    \n\x04\x04\x04\x02\x03\x12\x04\x8d\x01\x08\x20\n\r\n\x05\x04\x04\x02\x03\
    \x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\x8d\
    \x01\x11\x17\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\x8d\x01\x18\x1b\n\r\n\
    \x05\x04\x04\x02\x03\x03\x12\x04\x8d\x01\x1e\x1f\n\x0c\n\x02\x04\x05\x12\
    \x06\x90\x01\0\x97\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x90\x01\x08-\
    \n\x0e\n\x04\x04\x05\x04\0\x12\x06\x91\x01\x08\x94\x01\t\n\r\n\x05\x04\
    \x05\x04\0\x01\x12\x04\x91\x01\r\x14\n\x0e\n\x06\x04\x05\x04\0\x02\0\x12\
    \x04\x92\x01\x10\x1f\n\x0f\n\x07\x04\x05\x04\0\x02\0\x01\x12\x04\x92\x01\
    \x10\x1a\n\x0f\n\x07\x04\x05\x04\0\x02\0\x02\x12\x04\x92\x01\x1d\x1e\n\
    \x0e\n\x06\x04\x05\x04\0\x02\x01\x12\x04\x93\x01\x10%\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x01\x01\x12\x04\x93\x01\x10\x20\n\x0f\n\x07\x04\x05\x04\0\
    \x02\x01\x02\x12\x04\x93\x01#$\n\x0c\n\x04\x04\x05\x02\0\x12\x04\x96\x01\
    \x08J\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\
    \x05\x02\0\x06\x12\x04\x96\x01\x11>\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\
    \x96\x01?E\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x96\x01HI\n\x0c\n\x02\x04\
    \x06\x12\x06\x99\x01\0\xb0\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x99\
    \x01\x08\x20\n\x0e\n\x04\x04\x06\x03\0\x12\x06\x9a\x01\x08\xad\x01\t\n\r\
    \n\x05\x04\x06\x03\0\x01\x12\x04\x9a\x01\x10\x1a\n\x0e\n\x06\x04\x06\x03\
    \0\x02\0\x12\x04\x9b\x01\x10)\n\x0f\n\x07\x04\x06\x03\0\x02\0\x04\x12\
    \x04\x9b\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\0\x05\x12\x04\x9b\x01\
    \x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\0\x01\x12\x04\x9b\x01\x20$\n\x0f\
    \n\x07\x04\x06\x03\0\x02\0\x03\x12\x04\x9b\x01'(\n\x0e\n\x06\x04\x06\x03\
    \0\x02\x01\x12\x04\x9c\x01\x10,\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x04\
    \x12\x04\x9c\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x05\x12\x04\
    \x9c\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x01\x12\x04\x9c\x01\
    \x20'\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x03\x12\x04\x9c\x01*+\n\x0e\n\
    \x06\x04\x06\x03\0\x02\x02\x12\x04\x9d\x01\x10-\n\x0f\n\x07\x04\x06\x03\
    \0\x02\x02\x04\x12\x04\x9d\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x02\
    \x05\x12\x04\x9d\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x02\x01\x12\
    \x04\x9d\x01\x20(\n\x0f\n\x07\x04\x06\x03\0\x02\x02\x03\x12\x04\x9d\x01+\
    ,\n\x0e\n\x06\x04\x06\x03\0\x02\x03\x12\x04\x9e\x01\x10:\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x03\x04\x12\x04\x9e\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x03\x06\x12\x04\x9e\x01\x19.\n\x0f\n\x07\x04\x06\x03\0\x02\x03\x01\
    \x12\x04\x9e\x01/5\n\x0f\n\x07\x04\x06\x03\0\x02\x03\x03\x12\x04\x9e\x01\
    89\n\x0e\n\x06\x04\x06\x03\0\x02\x04\x12\x04\x9f\x01\x10.\n\x0f\n\x07\
    \x04\x06\x03\0\x02\x04\x04\x12\x04\x9f\x01\x10\x18\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x04\x05\x12\x04\x9f\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x04\x01\x12\x04\x9f\x01\x20)\n\x0f\n\x07\x04\x06\x03\0\x02\x04\x03\x12\
    \x04\x9f\x01,-\n\x0e\n\x06\x04\x06\x03\0\x02\x05\x12\x04\xa0\x01\x10-\n\
    \x0f\n\x07\x04\x06\x03\0\x02\x05\x04\x12\x04\xa0\x01\x10\x18\n\x0f\n\x07\
    \x04\x06\x03\0\x02\x05\x05\x12\x04\xa0\x01\x19\x1f\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x05\x01\x12\x04\xa0\x01\x20(\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x05\x03\x12\x04\xa0\x01+,\n\x0e\n\x06\x04\x06\x03\0\x02\x06\x12\x04\xa1\
    \x01\x108\n\x0f\n\x07\x04\x06\x03\0\x02\x06\x04\x12\x04\xa1\x01\x10\x18\
    \n\x0f\n\x07\x04\x06\x03\0\x02\x06\x05\x12\x04\xa1\x01\x19\x1f\n\x0f\n\
    \x07\x04\x06\x03\0\x02\x06\x01\x12\x04\xa1\x01\x203\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x06\x03\x12\x04\xa1\x0167\n\x0e\n\x06\x04\x06\x03\0\x02\x07\
    \x12\x04\xa2\x01\x101\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x04\x12\x04\xa2\
    \x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x05\x12\x04\xa2\x01\x19\
    \x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x01\x12\x04\xa2\x01\x20,\n\x0f\n\
    \x07\x04\x06\x03\0\x02\x07\x03\x12\x04\xa2\x01/0\n\x0e\n\x06\x04\x06\x03\
    \0\x02\x08\x12\x04\xa3\x01\x105\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x04\
    \x12\x04\xa3\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x05\x12\x04\
    \xa3\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x01\x12\x04\xa3\x01\
    \x20/\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x03\x12\x04\xa3\x0124\n\x0e\n\
    \x06\x04\x06\x03\0\x02\t\x12\x04\xa4\x01\x101\n\x0f\n\x07\x04\x06\x03\0\
    \x02\t\x04\x12\x04\xa4\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\t\x05\
    \x12\x04\xa4\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\t\x01\x12\x04\xa4\
    \x01\x20+\n\x0f\n\x07\x04\x06\x03\0\x02\t\x03\x12\x04\xa4\x01.0\n\x0e\n\
    \x06\x04\x06\x03\0\x02\n\x12\x04\xa5\x01\x104\n\x0f\n\x07\x04\x06\x03\0\
    \x02\n\x04\x12\x04\xa5\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\n\x05\
    \x12\x04\xa5\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\n\x01\x12\x04\xa5\
    \x01\x20.\n\x0f\n\x07\x04\x06\x03\0\x02\n\x03\x12\x04\xa5\x0113\n\x0e\n\
    \x06\x04\x06\x03\0\x02\x0b\x12\x04\xa6\x01\x105\n\x0f\n\x07\x04\x06\x03\
    \0\x02\x0b\x04\x12\x04\xa6\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x0b\
    \x05\x12\x04\xa6\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x0b\x01\x12\
    \x04\xa6\x01\x20/\n\x0f\n\x07\x04\x06\x03\0\x02\x0b\x03\x12\x04\xa6\x012\
    4\n\x0e\n\x06\x04\x06\x03\0\x02\x0c\x12\x04\xa7\x01\x10-\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x0c\x04\x12\x04\xa7\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x0c\x05\x12\x04\xa7\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x0c\
    \x01\x12\x04\xa7\x01\x20'\n\x0f\n\x07\x04\x06\x03\0\x02\x0c\x03\x12\x04\
    \xa7\x01*,\n\x0e\n\x06\x04\x06\x03\0\x02\r\x12\x04\xa8\x01\x107\n\x0f\n\
    \x07\x04\x06\x03\0\x02\r\x04\x12\x04\xa8\x01\x10\x18\n\x0f\n\x07\x04\x06\
    \x03\0\x02\r\x05\x12\x04\xa8\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\r\
    \x01\x12\x04\xa8\x01\x201\n\x0f\n\x07\x04\x06\x03\0\x02\r\x03\x12\x04\
    \xa8\x0146\n\x0e\n\x06\x04\x06\x03\0\x02\x0e\x12\x04\xa9\x01\x10I\n\x0f\
    \n\x07\x04\x06\x03\0\x02\x0e\x04\x12\x04\xa9\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x0e\x06\x12\x04\xa9\x01\x196\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x0e\x01\x12\x04\xa9\x017C\n\x0f\n\x07\x04\x06\x03\0\x02\x0e\x03\x12\
    \x04\xa9\x01FH\n\x0e\n\x06\x04\x06\x03\0\x02\x0f\x12\x04\xaa\x01\x105\n\
    \x0f\n\x07\x04\x06\x03\0\x02\x0f\x04\x12\x04\xaa\x01\x10\x18\n\x0f\n\x07\
    \x04\x06\x03\0\x02\x0f\x05\x12\x04\xaa\x01\x19\x1f\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x0f\x01\x12\x04\xaa\x01\x20/\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x0f\x03\x12\x04\xaa\x0124\n\x0e\n\x06\x04\x06\x03\0\x02\x10\x12\x04\xab\
    \x01\x100\n\x0f\n\x07\x04\x06\x03\0\x02\x10\x04\x12\x04\xab\x01\x10\x18\
    \n\x0f\n\x07\x04\x06\x03\0\x02\x10\x05\x12\x04\xab\x01\x19\x1f\n\x0f\n\
    \x07\x04\x06\x03\0\x02\x10\x01\x12\x04\xab\x01\x20*\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x10\x03\x12\x04\xab\x01-/\n\x0e\n\x06\x04\x06\x03\0\x02\x11\
    \x12\x04\xac\x01\x10/\n\x0f\n\x07\x04\x06\x03\0\x02\x11\x04\x12\x04\xac\
    \x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x11\x05\x12\x04\xac\x01\x19\
    \x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x11\x01\x12\x04\xac\x01\x20)\n\x0f\n\
    \x07\x04\x06\x03\0\x02\x11\x03\x12\x04\xac\x01,.\n\x0c\n\x04\x04\x06\x02\
    \0\x12\x04\xaf\x01\x08J\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xaf\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xaf\x01\x114\n\r\n\x05\x04\x06\
    \x02\0\x01\x12\x04\xaf\x015E\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xaf\x01\
    HI\n\x0c\n\x02\x04\x07\x12\x06\xb2\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xb2\x01\x08)\n\x0e\n\x04\x04\x07\x03\0\x12\x06\xb3\x01\x08\
    \xb8\x01\t\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\xb3\x01\x10\x1f\n\x0e\n\
    \x06\x04\x07\x03\0\x02\0\x12\x04\xb4\x01\x10-\n\x0f\n\x07\x04\x07\x03\0\
    \x02\0\x04\x12\x04\xb4\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\0\x05\
    \x12\x04\xb4\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\xb4\
    \x01\x20(\n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\x12\x04\xb4\x01+,\n\x0e\n\
    \x06\x04\x07\x03\0\x02\x01\x12\x04\xb5\x01\x10/\n\x0f\n\x07\x04\x07\x03\
    \0\x02\x01\x04\x12\x04\xb5\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x01\
    \x05\x12\x04\xb5\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x01\x12\
    \x04\xb5\x01\x20*\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x03\x12\x04\xb5\x01-\
    .\n\x0e\n\x06\x04\x07\x03\0\x02\x02\x12\x04\xb6\x01\x10.\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x02\x04\x12\x04\xb6\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x02\x05\x12\x04\xb6\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x02\
    \x01\x12\x04\xb6\x01\x20)\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x03\x12\x04\
    \xb6\x01,-\n\x0e\n\x06\x04\x07\x03\0\x02\x03\x12\x04\xb7\x01\x10)\n\x0f\
    \n\x07\x04\x07\x03\0\x02\x03\x04\x12\x04\xb7\x01\x10\x18\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x03\x05\x12\x04\xb7\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x03\x01\x12\x04\xb7\x01\x20$\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x03\
    \x12\x04\xb7\x01'(\n\x0e\n\x04\x04\x07\x03\x01\x12\x06\xba\x01\x08\xbf\
    \x01\t\n\r\n\x05\x04\x07\x03\x01\x01\x12\x04\xba\x01\x10\x1a\n\x0e\n\x06\
    \x04\x07\x03\x01\x02\0\x12\x04\xbb\x01\x10)\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\0\x04\x12\x04\xbb\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x05\
    \x12\x04\xbb\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x01\x12\x04\
    \xbb\x01\x20$\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x03\x12\x04\xbb\x01'(\n\
    \x0e\n\x06\x04\x07\x03\x01\x02\x01\x12\x04\xbc\x01\x10,\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x01\x04\x12\x04\xbc\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x01\x05\x12\x04\xbc\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\x01\x02\
    \x01\x01\x12\x04\xbc\x01\x20'\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x03\
    \x12\x04\xbc\x01*+\n\x0e\n\x06\x04\x07\x03\x01\x02\x02\x12\x04\xbd\x01\
    \x10Z\n\x0f\n\x07\x04\x07\x03\x01\x02\x02\x04\x12\x04\xbd\x01\x10\x18\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x02\x06\x12\x04\xbd\x01\x19J\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\x02\x01\x12\x04\xbd\x01KU\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x02\x03\x12\x04\xbd\x01XY\n\x0e\n\x06\x04\x07\x03\x01\x02\x03\
    \x12\x04\xbe\x01\x108\n\x0f\n\x07\x04\x07\x03\x01\x02\x03\x04\x12\x04\
    \xbe\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x03\x05\x12\x04\xbe\x01\
    \x19\x1f\n\x0f\n\x07\x04\x07\x03\x01\x02\x03\x01\x12\x04\xbe\x01\x203\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x03\x03\x12\x04\xbe\x0167\n\x0c\n\x04\x04\
    \x07\x02\0\x12\x04\xc1\x01\x08R\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xc1\
    \x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xc1\x01\x11=\n\r\n\x05\
    \x04\x07\x02\0\x01\x12\x04\xc1\x01>M\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\
    \xc1\x01PQ\n\x0c\n\x02\x04\x08\x12\x06\xc4\x01\0\x94\x02\x01\n\x0b\n\x03\
    \x04\x08\x01\x12\x04\xc4\x01\x08\x14\n\x0e\n\x04\x04\x08\x03\0\x12\x06\
    \xc5\x01\x08\xc8\x01\t\n\r\n\x05\x04\x08\x03\0\x01\x12\x04\xc5\x01\x10\
    \x19\n\x0e\n\x06\x04\x08\x03\0\x02\0\x12\x04\xc6\x01\x10B\n\x0f\n\x07\
    \x04\x08\x03\0\x02\0\x04\x12\x04\xc6\x01\x10\x18\n\x0f\n\x07\x04\x08\x03\
    \0\x02\0\x06\x12\x04\xc6\x01\x197\n\x0f\n\x07\x04\x08\x03\0\x02\0\x01\
    \x12\x04\xc6\x018=\n\x0f\n\x07\x04\x08\x03\0\x02\0\x03\x12\x04\xc6\x01@A\
    \n\x0e\n\x06\x04\x08\x03\0\x02\x01\x12\x04\xc7\x01\x102\n\x0f\n\x07\x04\
    \x08\x03\0\x02\x01\x04\x12\x04\xc7\x01\x10\x18\n\x0f\n\x07\x04\x08\x03\0\
    \x02\x01\x05\x12\x04\xc7\x01\x19\x1f\n\x0f\n\x07\x04\x08\x03\0\x02\x01\
    \x01\x12\x04\xc7\x01\x20-\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x04\
    \xc7\x0101\n\x0e\n\x04\x04\x08\x03\x01\x12\x06\xca\x01\x08\xcf\x01\t\n\r\
    \n\x05\x04\x08\x03\x01\x01\x12\x04\xca\x01\x10\x16\n\x0e\n\x06\x04\x08\
    \x03\x01\x02\0\x12\x04\xcb\x01\x102\n\x0f\n\x07\x04\x08\x03\x01\x02\0\
    \x04\x12\x04\xcb\x01\x10\x18\n\x0f\n\x07\x04\x08\x03\x01\x02\0\x06\x12\
    \x04\xcb\x01\x19&\n\x0f\n\x07\x04\x08\x03\x01\x02\0\x01\x12\x04\xcb\x01'\
    -\n\x0f\n\x07\x04\x08\x03\x01\x02\0\x03\x12\x04\xcb\x0101\n\x0e\n\x06\
    \x04\x08\x03\x01\x02\x01\x12\x04\xcc\x01\x106\n\x0f\n\x07\x04\x08\x03\
    \x01\x02\x01\x04\x12\x04\xcc\x01\x10\x18\n\x0f\n\x07\x04\x08\x03\x01\x02\
    \x01\x06\x12\x04\xcc\x01\x19(\n\x0f\n\x07\x04\x08\x03\x01\x02\x01\x01\
    \x12\x04\xcc\x01)1\n\x0f\n\x07\x04\x08\x03\x01\x02\x01\x03\x12\x04\xcc\
    \x0145\n\x0e\n\x06\x04\x08\x03\x01\x02\x02\x12\x04\xcd\x01\x10.\n\x0f\n\
    \x07\x04\x08\x03\x01\x02\x02\x04\x12\x04\xcd\x01\x10\x18\n\x0f\n\x07\x04\
    \x08\x03\x01\x02\x02\x05\x12\x04\xcd\x01\x19\x1f\n\x0f\n\x07\x04\x08\x03\
    \x01\x02\x02\x01\x12\x04\xcd\x01\x20)\n\x0f\n\x07\x04\x08\x03\x01\x02\
    \x02\x03\x12\x04\xcd\x01,-\n\x0e\n\x06\x04\x08\x03\x01\x02\x03\x12\x04\
    \xce\x01\x10;\n\x0f\n\x07\x04\x08\x03\x01\x02\x03\x04\x12\x04\xce\x01\
    \x10\x18\n\x0f\n\x07\x04\x08\x03\x01\x02\x03\x06\x12\x04\xce\x01\x19/\n\
    \x0f\n\x07\x04\x08\x03\x01\x02\x03\x01\x12\x04\xce\x0106\n\x0f\n\x07\x04\
    \x08\x03\x01\x02\x03\x03\x12\x04\xce\x019:\n\x0e\n\x04\x04\x08\x04\0\x12\
    \x06\xd1\x01\x08\xe8\x01\t\n\r\n\x05\x04\x08\x04\0\x01\x12\x04\xd1\x01\r\
    \x19\n\x0e\n\x06\x04\x08\x04\0\x02\0\x12\x04\xd2\x01\x10\"\n\x0f\n\x07\
    \x04\x08\x04\0\x02\0\x01\x12\x04\xd2\x01\x10\x1d\n\x0f\n\x07\x04\x08\x04\
    \0\x02\0\x02\x12\x04\xd2\x01\x20!\n\x0e\n\x06\x04\x08\x04\0\x02\x01\x12\
    \x04\xd3\x01\x10'\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x04\xd3\x01\
    \x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x02\x12\x04\xd3\x01%&\n\x0e\n\
    \x06\x04\x08\x04\0\x02\x02\x12\x04\xd4\x01\x10&\n\x0f\n\x07\x04\x08\x04\
    \0\x02\x02\x01\x12\x04\xd4\x01\x10!\n\x0f\n\x07\x04\x08\x04\0\x02\x02\
    \x02\x12\x04\xd4\x01$%\n\x0e\n\x06\x04\x08\x04\0\x02\x03\x12\x04\xd5\x01\
    \x102\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x01\x12\x04\xd5\x01\x10-\n\x0f\n\
    \x07\x04\x08\x04\0\x02\x03\x02\x12\x04\xd5\x0101\n\x0e\n\x06\x04\x08\x04\
    \0\x02\x04\x12\x04\xd6\x01\x10'\n\x0f\n\x07\x04\x08\x04\0\x02\x04\x01\
    \x12\x04\xd6\x01\x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\x04\x02\x12\x04\xd6\
    \x01%&\n\x0e\n\x06\x04\x08\x04\0\x02\x05\x12\x04\xd7\x01\x10'\n\x0f\n\
    \x07\x04\x08\x04\0\x02\x05\x01\x12\x04\xd7\x01\x10\"\n\x0f\n\x07\x04\x08\
    \x04\0\x02\x05\x02\x12\x04\xd7\x01%&\n\x0e\n\x06\x04\x08\x04\0\x02\x06\
    \x12\x04\xd8\x01\x10.\n\x0f\n\x07\x04\x08\x04\0\x02\x06\x01\x12\x04\xd8\
    \x01\x10)\n\x0f\n\x07\x04\x08\x04\0\x02\x06\x02\x12\x04\xd8\x01,-\n\x0e\
    \n\x06\x04\x08\x04\0\x02\x07\x12\x04\xd9\x01\x10'\n\x0f\n\x07\x04\x08\
    \x04\0\x02\x07\x01\x12\x04\xd9\x01\x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\
    \x07\x02\x12\x04\xd9\x01%&\n\x0e\n\x06\x04\x08\x04\0\x02\x08\x12\x04\xda\
    \x01\x10&\n\x0f\n\x07\x04\x08\x04\0\x02\x08\x01\x12\x04\xda\x01\x10!\n\
    \x0f\n\x07\x04\x08\x04\0\x02\x08\x02\x12\x04\xda\x01$%\n\x0e\n\x06\x04\
    \x08\x04\0\x02\t\x12\x04\xdb\x01\x10'\n\x0f\n\x07\x04\x08\x04\0\x02\t\
    \x01\x12\x04\xdb\x01\x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\t\x02\x12\x04\
    \xdb\x01%&\n\x0e\n\x06\x04\x08\x04\0\x02\n\x12\x04\xdc\x01\x10'\n\x0f\n\
    \x07\x04\x08\x04\0\x02\n\x01\x12\x04\xdc\x01\x10!\n\x0f\n\x07\x04\x08\
    \x04\0\x02\n\x02\x12\x04\xdc\x01$&\n\x0e\n\x06\x04\x08\x04\0\x02\x0b\x12\
    \x04\xdd\x01\x10(\n\x0f\n\x07\x04\x08\x04\0\x02\x0b\x01\x12\x04\xdd\x01\
    \x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\x0b\x02\x12\x04\xdd\x01%'\n\x0e\n\
    \x06\x04\x08\x04\0\x02\x0c\x12\x04\xde\x01\x10+\n\x0f\n\x07\x04\x08\x04\
    \0\x02\x0c\x01\x12\x04\xde\x01\x10%\n\x0f\n\x07\x04\x08\x04\0\x02\x0c\
    \x02\x12\x04\xde\x01(*\n\x0e\n\x06\x04\x08\x04\0\x02\r\x12\x04\xdf\x01\
    \x10<\n\x0f\n\x07\x04\x08\x04\0\x02\r\x01\x12\x04\xdf\x01\x106\n\x0f\n\
    \x07\x04\x08\x04\0\x02\r\x02\x12\x04\xdf\x019;\n\x0e\n\x06\x04\x08\x04\0\
    \x02\x0e\x12\x04\xe0\x01\x10?\n\x0f\n\x07\x04\x08\x04\0\x02\x0e\x01\x12\
    \x04\xe0\x01\x109\n\x0f\n\x07\x04\x08\x04\0\x02\x0e\x02\x12\x04\xe0\x01<\
    >\n\x0e\n\x06\x04\x08\x04\0\x02\x0f\x12\x04\xe1\x01\x10(\n\x0f\n\x07\x04\
    \x08\x04\0\x02\x0f\x01\x12\x04\xe1\x01\x10\"\n\x0f\n\x07\x04\x08\x04\0\
    \x02\x0f\x02\x12\x04\xe1\x01%'\n\x0e\n\x06\x04\x08\x04\0\x02\x10\x12\x04\
    \xe2\x01\x10'\n\x0f\n\x07\x04\x08\x04\0\x02\x10\x01\x12\x04\xe2\x01\x10!\
    \n\x0f\n\x07\x04\x08\x04\0\x02\x10\x02\x12\x04\xe2\x01$&\n\x0e\n\x06\x04\
    \x08\x04\0\x02\x11\x12\x04\xe3\x01\x10(\n\x0f\n\x07\x04\x08\x04\0\x02\
    \x11\x01\x12\x04\xe3\x01\x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\x11\x02\x12\
    \x04\xe3\x01%'\n\x0e\n\x06\x04\x08\x04\0\x02\x12\x12\x04\xe4\x01\x10'\n\
    \x0f\n\x07\x04\x08\x04\0\x02\x12\x01\x12\x04\xe4\x01\x10!\n\x0f\n\x07\
    \x04\x08\x04\0\x02\x12\x02\x12\x04\xe4\x01$&\n\x0e\n\x06\x04\x08\x04\0\
    \x02\x13\x12\x04\xe5\x01\x10(\n\x0f\n\x07\x04\x08\x04\0\x02\x13\x01\x12\
    \x04\xe5\x01\x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\x13\x02\x12\x04\xe5\x01\
    %'\n\x0e\n\x06\x04\x08\x04\0\x02\x14\x12\x04\xe6\x01\x10'\n\x0f\n\x07\
    \x04\x08\x04\0\x02\x14\x01\x12\x04\xe6\x01\x10!\n\x0f\n\x07\x04\x08\x04\
    \0\x02\x14\x02\x12\x04\xe6\x01$&\n\x0e\n\x06\x04\x08\x04\0\x02\x15\x12\
    \x04\xe7\x01\x10(\n\x0f\n\x07\x04\x08\x04\0\x02\x15\x01\x12\x04\xe7\x01\
    \x10\"\n\x0f\n\x07\x04\x08\x04\0\x02\x15\x02\x12\x04\xe7\x01%'\n\x0e\n\
    \x04\x04\x08\x04\x01\x12\x06\xea\x01\x08\xf3\x01\t\n\r\n\x05\x04\x08\x04\
    \x01\x01\x12\x04\xea\x01\r\x1e\n\x0e\n\x06\x04\x08\x04\x01\x02\0\x12\x04\
    \xeb\x01\x10\"\n\x0f\n\x07\x04\x08\x04\x01\x02\0\x01\x12\x04\xeb\x01\x10\
    \x1d\n\x0f\n\x07\x04\x08\x04\x01\x02\0\x02\x12\x04\xeb\x01\x20!\n\x0e\n\
    \x06\x04\x08\x04\x01\x02\x01\x12\x04\xec\x01\x10\x1e\n\x0f\n\x07\x04\x08\
    \x04\x01\x02\x01\x01\x12\x04\xec\x01\x10\x19\n\x0f\n\x07\x04\x08\x04\x01\
    \x02\x01\x02\x12\x04\xec\x01\x1c\x1d\n\x0e\n\x06\x04\x08\x04\x01\x02\x02\
    \x12\x04\xed\x01\x10\x20\n\x0f\n\x07\x04\x08\x04\x01\x02\x02\x01\x12\x04\
    \xed\x01\x10\x1b\n\x0f\n\x07\x04\x08\x04\x01\x02\x02\x02\x12\x04\xed\x01\
    \x1e\x1f\n\x0e\n\x06\x04\x08\x04\x01\x02\x03\x12\x04\xee\x01\x10\x1c\n\
    \x0f\n\x07\x04\x08\x04\x01\x02\x03\x01\x12\x04\xee\x01\x10\x17\n\x0f\n\
    \x07\x04\x08\x04\x01\x02\x03\x02\x12\x04\xee\x01\x1a\x1b\n\x0e\n\x06\x04\
    \x08\x04\x01\x02\x04\x12\x04\xef\x01\x10\x1c\n\x0f\n\x07\x04\x08\x04\x01\
    \x02\x04\x01\x12\x04\xef\x01\x10\x17\n\x0f\n\x07\x04\x08\x04\x01\x02\x04\
    \x02\x12\x04\xef\x01\x1a\x1b\n\x0e\n\x06\x04\x08\x04\x01\x02\x05\x12\x04\
    \xf0\x01\x10\x1c\n\x0f\n\x07\x04\x08\x04\x01\x02\x05\x01\x12\x04\xf0\x01\
    \x10\x17\n\x0f\n\x07\x04\x08\x04\x01\x02\x05\x02\x12\x04\xf0\x01\x1a\x1b\
    \n\x0e\n\x06\x04\x08\x04\x01\x02\x06\x12\x04\xf1\x01\x10\x1c\n\x0f\n\x07\
    \x04\x08\x04\x01\x02\x06\x01\x12\x04\xf1\x01\x10\x17\n\x0f\n\x07\x04\x08\
    \x04\x01\x02\x06\x02\x12\x04\xf1\x01\x1a\x1b\n\x0e\n\x06\x04\x08\x04\x01\
    \x02\x07\x12\x04\xf2\x01\x10\x1c\n\x0f\n\x07\x04\x08\x04\x01\x02\x07\x01\
    \x12\x04\xf2\x01\x10\x17\n\x0f\n\x07\x04\x08\x04\x01\x02\x07\x02\x12\x04\
    \xf2\x01\x1a\x1b\n\x0e\n\x04\x04\x08\x04\x02\x12\x06\xf5\x01\x08\xfc\x01\
    \t\n\r\n\x05\x04\x08\x04\x02\x01\x12\x04\xf5\x01\r\x1d\n\x0e\n\x06\x04\
    \x08\x04\x02\x02\0\x12\x04\xf6\x01\x10\x1c\n\x0f\n\x07\x04\x08\x04\x02\
    \x02\0\x01\x12\x04\xf6\x01\x10\x17\n\x0f\n\x07\x04\x08\x04\x02\x02\0\x02\
    \x12\x04\xf6\x01\x1a\x1b\n\x0e\n\x06\x04\x08\x04\x02\x02\x01\x12\x04\xf7\
    \x01\x10\x1b\n\x0f\n\x07\x04\x08\x04\x02\x02\x01\x01\x12\x04\xf7\x01\x10\
    \x16\n\x0f\n\x07\x04\x08\x04\x02\x02\x01\x02\x12\x04\xf7\x01\x19\x1a\n\
    \x0e\n\x06\x04\x08\x04\x02\x02\x02\x12\x04\xf8\x01\x10\x1a\n\x0f\n\x07\
    \x04\x08\x04\x02\x02\x02\x01\x12\x04\xf8\x01\x10\x15\n\x0f\n\x07\x04\x08\
    \x04\x02\x02\x02\x02\x12\x04\xf8\x01\x18\x19\n\x0e\n\x06\x04\x08\x04\x02\
    \x02\x03\x12\x04\xf9\x01\x10-\n\x0f\n\x07\x04\x08\x04\x02\x02\x03\x01\
    \x12\x04\xf9\x01\x10(\n\x0f\n\x07\x04\x08\x04\x02\x02\x03\x02\x12\x04\
    \xf9\x01+,\n\x0e\n\x06\x04\x08\x04\x02\x02\x04\x12\x04\xfa\x01\x10\"\n\
    \x0f\n\x07\x04\x08\x04\x02\x02\x04\x01\x12\x04\xfa\x01\x10\x1d\n\x0f\n\
    \x07\x04\x08\x04\x02\x02\x04\x02\x12\x04\xfa\x01\x20!\n\x0e\n\x06\x04\
    \x08\x04\x02\x02\x05\x12\x04\xfb\x01\x10\"\n\x0f\n\x07\x04\x08\x04\x02\
    \x02\x05\x01\x12\x04\xfb\x01\x10\x1d\n\x0f\n\x07\x04\x08\x04\x02\x02\x05\
    \x02\x12\x04\xfb\x01\x20!\n\x0e\n\x04\x04\x08\x04\x03\x12\x06\xfe\x01\
    \x08\x83\x02\t\n\r\n\x05\x04\x08\x04\x03\x01\x12\x04\xfe\x01\r\x12\n\x0e\
    \n\x06\x04\x08\x04\x03\x02\0\x12\x04\xff\x01\x10\x1e\n\x0f\n\x07\x04\x08\
    \x04\x03\x02\0\x01\x12\x04\xff\x01\x10\x19\n\x0f\n\x07\x04\x08\x04\x03\
    \x02\0\x02\x12\x04\xff\x01\x1c\x1d\n\x0e\n\x06\x04\x08\x04\x03\x02\x01\
    \x12\x04\x80\x02\x10\x1b\n\x0f\n\x07\x04\x08\x04\x03\x02\x01\x01\x12\x04\
    \x80\x02\x10\x16\n\x0f\n\x07\x04\x08\x04\x03\x02\x01\x02\x12\x04\x80\x02\
    \x19\x1a\n\x0e\n\x06\x04\x08\x04\x03\x02\x02\x12\x04\x81\x02\x10\x1b\n\
    \x0f\n\x07\x04\x08\x04\x03\x02\x02\x01\x12\x04\x81\x02\x10\x16\n\x0f\n\
    \x07\x04\x08\x04\x03\x02\x02\x02\x12\x04\x81\x02\x19\x1a\n\x0e\n\x06\x04\
    \x08\x04\x03\x02\x03\x12\x04\x82\x02\x10\x1b\n\x0f\n\x07\x04\x08\x04\x03\
    \x02\x03\x01\x12\x04\x82\x02\x10\x16\n\x0f\n\x07\x04\x08\x04\x03\x02\x03\
    \x02\x12\x04\x82\x02\x19\x1a\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x85\x02\
    \x085\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\
    \x08\x02\0\x06\x12\x04\x85\x02\x11*\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \x85\x02+0\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x85\x0234\n\x0c\n\x04\x04\
    \x08\x02\x01\x12\x04\x86\x02\x08>\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\
    \x86\x02\x08\x10\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\x86\x02\x11.\n\r\
    \n\x05\x04\x08\x02\x01\x01\x12\x04\x86\x02/9\n\r\n\x05\x04\x08\x02\x01\
    \x03\x12\x04\x86\x02<=\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\x87\x02\x081\
    \n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x87\x02\x08\x10\n\r\n\x05\x04\x08\
    \x02\x02\x06\x12\x04\x87\x02\x11$\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\
    \x87\x02%,\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x87\x02/0\n\x0c\n\x04\
    \x04\x08\x02\x03\x12\x04\x88\x02\x080\n\r\n\x05\x04\x08\x02\x03\x04\x12\
    \x04\x88\x02\x08\x10\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\x88\x02\x11\
    \x17\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\x88\x02\x18+\n\r\n\x05\x04\
    \x08\x02\x03\x03\x12\x04\x88\x02./\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\
    \x89\x02\x08,\n\r\n\x05\x04\x08\x02\x04\x04\x12\x04\x89\x02\x08\x10\n\r\
    \n\x05\x04\x08\x02\x04\x05\x12\x04\x89\x02\x11\x15\n\r\n\x05\x04\x08\x02\
    \x04\x01\x12\x04\x89\x02\x16'\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\x89\
    \x02*+\n\x0c\n\x04\x04\x08\x02\x05\x12\x04\x8a\x02\x08-\n\r\n\x05\x04\
    \x08\x02\x05\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\x08\x02\x05\x05\
    \x12\x04\x8a\x02\x11\x15\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\x8a\x02\
    \x16(\n\r\n\x05\x04\x08\x02\x05\x03\x12\x04\x8a\x02+,\n\x0c\n\x04\x04\
    \x08\x02\x06\x12\x04\x8b\x02\x08'\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\
    \x8b\x02\x08\x10\n\r\n\x05\x04\x08\x02\x06\x05\x12\x04\x8b\x02\x11\x17\n\
    \r\n\x05\x04\x08\x02\x06\x01\x12\x04\x8b\x02\x18\"\n\r\n\x05\x04\x08\x02\
    \x06\x03\x12\x04\x8b\x02%&\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\x8c\x02\
    \x080\n\r\n\x05\x04\x08\x02\x07\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\
    \x04\x08\x02\x07\x05\x12\x04\x8c\x02\x11\x17\n\r\n\x05\x04\x08\x02\x07\
    \x01\x12\x04\x8c\x02\x18+\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\x8c\x02.\
    /\n\x0c\n\x04\x04\x08\x02\x08\x12\x04\x8d\x02\x08.\n\r\n\x05\x04\x08\x02\
    \x08\x04\x12\x04\x8d\x02\x08\x10\n\r\n\x05\x04\x08\x02\x08\x05\x12\x04\
    \x8d\x02\x11\x17\n\r\n\x05\x04\x08\x02\x08\x01\x12\x04\x8d\x02\x18)\n\r\
    \n\x05\x04\x08\x02\x08\x03\x12\x04\x8d\x02,-\n\x0c\n\x04\x04\x08\x02\t\
    \x12\x04\x8e\x02\x08.\n\r\n\x05\x04\x08\x02\t\x04\x12\x04\x8e\x02\x08\
    \x10\n\r\n\x05\x04\x08\x02\t\x06\x12\x04\x8e\x02\x11#\n\r\n\x05\x04\x08\
    \x02\t\x01\x12\x04\x8e\x02$(\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\x8e\x02\
    +-\n\x0c\n\x04\x04\x08\x02\n\x12\x04\x8f\x02\x081\n\r\n\x05\x04\x08\x02\
    \n\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\x04\x08\x02\n\x05\x12\x04\x8f\
    \x02\x11\x17\n\r\n\x05\x04\x08\x02\n\x01\x12\x04\x8f\x02\x18+\n\r\n\x05\
    \x04\x08\x02\n\x03\x12\x04\x8f\x02.0\n\x0c\n\x04\x04\x08\x02\x0b\x12\x04\
    \x90\x02\x080\n\r\n\x05\x04\x08\x02\x0b\x04\x12\x04\x90\x02\x08\x10\n\r\
    \n\x05\x04\x08\x02\x0b\x05\x12\x04\x90\x02\x11\x17\n\r\n\x05\x04\x08\x02\
    \x0b\x01\x12\x04\x90\x02\x18*\n\r\n\x05\x04\x08\x02\x0b\x03\x12\x04\x90\
    \x02-/\n\x0c\n\x04\x04\x08\x02\x0c\x12\x04\x91\x02\x088\n\r\n\x05\x04\
    \x08\x02\x0c\x04\x12\x04\x91\x02\x08\x10\n\r\n\x05\x04\x08\x02\x0c\x05\
    \x12\x04\x91\x02\x11\x17\n\r\n\x05\x04\x08\x02\x0c\x01\x12\x04\x91\x02\
    \x182\n\r\n\x05\x04\x08\x02\x0c\x03\x12\x04\x91\x0257\n\x0c\n\x04\x04\
    \x08\x02\r\x12\x04\x92\x02\x08.\n\r\n\x05\x04\x08\x02\r\x04\x12\x04\x92\
    \x02\x08\x10\n\r\n\x05\x04\x08\x02\r\x05\x12\x04\x92\x02\x11\x15\n\r\n\
    \x05\x04\x08\x02\r\x01\x12\x04\x92\x02\x16(\n\r\n\x05\x04\x08\x02\r\x03\
    \x12\x04\x92\x02+-\n\x0c\n\x04\x04\x08\x02\x0e\x12\x04\x93\x02\x08?\n\r\
    \n\x05\x04\x08\x02\x0e\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x08\x02\
    \x0e\x05\x12\x04\x93\x02\x11\x17\n\r\n\x05\x04\x08\x02\x0e\x01\x12\x04\
    \x93\x02\x189\n\r\n\x05\x04\x08\x02\x0e\x03\x12\x04\x93\x02<>\n\x0c\n\
    \x02\x04\t\x12\x06\x96\x02\0\x98\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\
    \x96\x02\x08\x18\n\x0c\n\x04\x04\t\x02\0\x12\x04\x97\x02\x08)\n\r\n\x05\
    \x04\t\x02\0\x04\x12\x04\x97\x02\x08\x10\n\r\n\x05\x04\t\x02\0\x06\x12\
    \x04\x97\x02\x11\x1d\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x97\x02\x1e$\n\r\
    \n\x05\x04\t\x02\0\x03\x12\x04\x97\x02'(\n\x0c\n\x02\x04\n\x12\x06\x9a\
    \x02\0\xba\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x9a\x02\x08!\n\x0e\n\
    \x04\x04\n\x03\0\x12\x06\x9b\x02\x08\x9e\x02\t\n\r\n\x05\x04\n\x03\0\x01\
    \x12\x04\x9b\x02\x10\x19\n\x0e\n\x06\x04\n\x03\0\x02\0\x12\x04\x9c\x02\
    \x10/\n\x0f\n\x07\x04\n\x03\0\x02\0\x04\x12\x04\x9c\x02\x10\x18\n\x0f\n\
    \x07\x04\n\x03\0\x02\0\x05\x12\x04\x9c\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\
    \0\x02\0\x01\x12\x04\x9c\x02\x20*\n\x0f\n\x07\x04\n\x03\0\x02\0\x03\x12\
    \x04\x9c\x02-.\n\x0e\n\x06\x04\n\x03\0\x02\x01\x12\x04\x9d\x02\x100\n\
    \x0f\n\x07\x04\n\x03\0\x02\x01\x04\x12\x04\x9d\x02\x10\x18\n\x0f\n\x07\
    \x04\n\x03\0\x02\x01\x05\x12\x04\x9d\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\0\
    \x02\x01\x01\x12\x04\x9d\x02\x20+\n\x0f\n\x07\x04\n\x03\0\x02\x01\x03\
    \x12\x04\x9d\x02./\n\x0e\n\x04\x04\n\x03\x01\x12\x06\xa0\x02\x08\xaa\x02\
    \t\n\r\n\x05\x04\n\x03\x01\x01\x12\x04\xa0\x02\x10\x14\n\x0e\n\x06\x04\n\
    \x03\x01\x02\0\x12\x04\xa1\x02\x106\n\x0f\n\x07\x04\n\x03\x01\x02\0\x04\
    \x12\x04\xa1\x02\x10\x18\n\x0f\n\x07\x04\n\x03\x01\x02\0\x05\x12\x04\xa1\
    \x02\x19\x1f\n\x0f\n\x07\x04\n\x03\x01\x02\0\x01\x12\x04\xa1\x02\x201\n\
    \x0f\n\x07\x04\n\x03\x01\x02\0\x03\x12\x04\xa1\x0245\n\x0e\n\x06\x04\n\
    \x03\x01\x02\x01\x12\x04\xa2\x02\x100\n\x0f\n\x07\x04\n\x03\x01\x02\x01\
    \x04\x12\x04\xa2\x02\x10\x18\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x05\x12\
    \x04\xa2\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x01\x12\x04\xa2\
    \x02\x20+\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x03\x12\x04\xa2\x02./\n\x0e\
    \n\x06\x04\n\x03\x01\x02\x02\x12\x04\xa3\x02\x10,\n\x0f\n\x07\x04\n\x03\
    \x01\x02\x02\x04\x12\x04\xa3\x02\x10\x18\n\x0f\n\x07\x04\n\x03\x01\x02\
    \x02\x05\x12\x04\xa3\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\x01\x02\x02\x01\
    \x12\x04\xa3\x02\x20'\n\x0f\n\x07\x04\n\x03\x01\x02\x02\x03\x12\x04\xa3\
    \x02*+\n\x0e\n\x06\x04\n\x03\x01\x02\x03\x12\x04\xa4\x02\x10.\n\x0f\n\
    \x07\x04\n\x03\x01\x02\x03\x04\x12\x04\xa4\x02\x10\x18\n\x0f\n\x07\x04\n\
    \x03\x01\x02\x03\x05\x12\x04\xa4\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\x01\
    \x02\x03\x01\x12\x04\xa4\x02\x20)\n\x0f\n\x07\x04\n\x03\x01\x02\x03\x03\
    \x12\x04\xa4\x02,-\n\x0e\n\x06\x04\n\x03\x01\x02\x04\x12\x04\xa5\x02\x10\
    )\n\x0f\n\x07\x04\n\x03\x01\x02\x04\x04\x12\x04\xa5\x02\x10\x18\n\x0f\n\
    \x07\x04\n\x03\x01\x02\x04\x05\x12\x04\xa5\x02\x19\x1f\n\x0f\n\x07\x04\n\
    \x03\x01\x02\x04\x01\x12\x04\xa5\x02\x20$\n\x0f\n\x07\x04\n\x03\x01\x02\
    \x04\x03\x12\x04\xa5\x02'(\n\x0e\n\x06\x04\n\x03\x01\x02\x05\x12\x04\xa6\
    \x02\x10I\n\x0f\n\x07\x04\n\x03\x01\x02\x05\x04\x12\x04\xa6\x02\x10\x18\
    \n\x0f\n\x07\x04\n\x03\x01\x02\x05\x06\x12\x04\xa6\x02\x19<\n\x0f\n\x07\
    \x04\n\x03\x01\x02\x05\x01\x12\x04\xa6\x02=D\n\x0f\n\x07\x04\n\x03\x01\
    \x02\x05\x03\x12\x04\xa6\x02GH\n\x0e\n\x06\x04\n\x03\x01\x02\x06\x12\x04\
    \xa7\x02\x10)\n\x0f\n\x07\x04\n\x03\x01\x02\x06\x04\x12\x04\xa7\x02\x10\
    \x18\n\x0f\n\x07\x04\n\x03\x01\x02\x06\x05\x12\x04\xa7\x02\x19\x1e\n\x0f\
    \n\x07\x04\n\x03\x01\x02\x06\x01\x12\x04\xa7\x02\x1f$\n\x0f\n\x07\x04\n\
    \x03\x01\x02\x06\x03\x12\x04\xa7\x02'(\n\x0e\n\x06\x04\n\x03\x01\x02\x07\
    \x12\x04\xa8\x02\x10,\n\x0f\n\x07\x04\n\x03\x01\x02\x07\x04\x12\x04\xa8\
    \x02\x10\x18\n\x0f\n\x07\x04\n\x03\x01\x02\x07\x05\x12\x04\xa8\x02\x19\
    \x1d\n\x0f\n\x07\x04\n\x03\x01\x02\x07\x01\x12\x04\xa8\x02\x1e'\n\x0f\n\
    \x07\x04\n\x03\x01\x02\x07\x03\x12\x04\xa8\x02*+\n\x0e\n\x06\x04\n\x03\
    \x01\x02\x08\x12\x04\xa9\x02\x10,\n\x0f\n\x07\x04\n\x03\x01\x02\x08\x04\
    \x12\x04\xa9\x02\x10\x18\n\x0f\n\x07\x04\n\x03\x01\x02\x08\x05\x12\x04\
    \xa9\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\x01\x02\x08\x01\x12\x04\xa9\x02\
    \x20'\n\x0f\n\x07\x04\n\x03\x01\x02\x08\x03\x12\x04\xa9\x02*+\n\x0e\n\
    \x04\x04\n\x03\x02\x12\x06\xac\x02\x08\xb0\x02\t\n\r\n\x05\x04\n\x03\x02\
    \x01\x12\x04\xac\x02\x10\x16\n\x0e\n\x06\x04\n\x03\x02\x02\0\x12\x04\xad\
    \x02\x10.\n\x0f\n\x07\x04\n\x03\x02\x02\0\x04\x12\x04\xad\x02\x10\x18\n\
    \x0f\n\x07\x04\n\x03\x02\x02\0\x05\x12\x04\xad\x02\x19\x1f\n\x0f\n\x07\
    \x04\n\x03\x02\x02\0\x01\x12\x04\xad\x02\x20)\n\x0f\n\x07\x04\n\x03\x02\
    \x02\0\x03\x12\x04\xad\x02,-\n\x0e\n\x06\x04\n\x03\x02\x02\x01\x12\x04\
    \xae\x02\x10B\n\x0f\n\x07\x04\n\x03\x02\x02\x01\x04\x12\x04\xae\x02\x10\
    \x18\n\x0f\n\x07\x04\n\x03\x02\x02\x01\x06\x12\x04\xae\x02\x197\n\x0f\n\
    \x07\x04\n\x03\x02\x02\x01\x01\x12\x04\xae\x028=\n\x0f\n\x07\x04\n\x03\
    \x02\x02\x01\x03\x12\x04\xae\x02@A\n\x0e\n\x06\x04\n\x03\x02\x02\x02\x12\
    \x04\xaf\x02\x10)\n\x0f\n\x07\x04\n\x03\x02\x02\x02\x04\x12\x04\xaf\x02\
    \x10\x18\n\x0f\n\x07\x04\n\x03\x02\x02\x02\x05\x12\x04\xaf\x02\x19\x1e\n\
    \x0f\n\x07\x04\n\x03\x02\x02\x02\x01\x12\x04\xaf\x02\x1f$\n\x0f\n\x07\
    \x04\n\x03\x02\x02\x02\x03\x12\x04\xaf\x02'(\n\x0e\n\x04\x04\n\x03\x03\
    \x12\x06\xb2\x02\x08\xb7\x02\t\n\r\n\x05\x04\n\x03\x03\x01\x12\x04\xb2\
    \x02\x10\x16\n\x0e\n\x06\x04\n\x03\x03\x02\0\x12\x04\xb3\x02\x103\n\x0f\
    \n\x07\x04\n\x03\x03\x02\0\x04\x12\x04\xb3\x02\x10\x18\n\x0f\n\x07\x04\n\
    \x03\x03\x02\0\x05\x12\x04\xb3\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\x03\x02\
    \0\x01\x12\x04\xb3\x02\x20.\n\x0f\n\x07\x04\n\x03\x03\x02\0\x03\x12\x04\
    \xb3\x0212\n\x0e\n\x06\x04\n\x03\x03\x02\x01\x12\x04\xb4\x02\x104\n\x0f\
    \n\x07\x04\n\x03\x03\x02\x01\x04\x12\x04\xb4\x02\x10\x18\n\x0f\n\x07\x04\
    \n\x03\x03\x02\x01\x05\x12\x04\xb4\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\x03\
    \x02\x01\x01\x12\x04\xb4\x02\x20/\n\x0f\n\x07\x04\n\x03\x03\x02\x01\x03\
    \x12\x04\xb4\x0223\n\x0e\n\x06\x04\n\x03\x03\x02\x02\x12\x04\xb5\x02\x10\
    2\n\x0f\n\x07\x04\n\x03\x03\x02\x02\x04\x12\x04\xb5\x02\x10\x18\n\x0f\n\
    \x07\x04\n\x03\x03\x02\x02\x05\x12\x04\xb5\x02\x19\x1f\n\x0f\n\x07\x04\n\
    \x03\x03\x02\x02\x01\x12\x04\xb5\x02\x20-\n\x0f\n\x07\x04\n\x03\x03\x02\
    \x02\x03\x12\x04\xb5\x0201\n\x0e\n\x06\x04\n\x03\x03\x02\x03\x12\x04\xb6\
    \x02\x10F\n\x0f\n\x07\x04\n\x03\x03\x02\x03\x04\x12\x04\xb6\x02\x10\x18\
    \n\x0f\n\x07\x04\n\x03\x03\x02\x03\x06\x12\x04\xb6\x02\x199\n\x0f\n\x07\
    \x04\n\x03\x03\x02\x03\x01\x12\x04\xb6\x02:A\n\x0f\n\x07\x04\n\x03\x03\
    \x02\x03\x03\x12\x04\xb6\x02DE\n\x0c\n\x04\x04\n\x02\0\x12\x04\xb9\x02\
    \x08>\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\n\
    \x02\0\x06\x12\x04\xb9\x02\x111\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xb9\
    \x0229\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb9\x02<=\n\x0c\n\x02\x04\x0b\
    \x12\x06\xbc\x02\0\xcd\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xbc\x02\
    \x08\x1f\n\x0e\n\x04\x04\x0b\x03\0\x12\x06\xbd\x02\x08\xc0\x02\t\n\r\n\
    \x05\x04\x0b\x03\0\x01\x12\x04\xbd\x02\x10\x19\n\x0e\n\x06\x04\x0b\x03\0\
    \x02\0\x12\x04\xbe\x02\x10/\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x04\x12\x04\
    \xbe\x02\x10\x18\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x05\x12\x04\xbe\x02\x19\
    \x1f\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x01\x12\x04\xbe\x02\x20*\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\0\x03\x12\x04\xbe\x02-.\n\x0e\n\x06\x04\x0b\x03\0\
    \x02\x01\x12\x04\xbf\x02\x100\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x04\x12\
    \x04\xbf\x02\x10\x18\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x05\x12\x04\xbf\
    \x02\x19\x1f\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x01\x12\x04\xbf\x02\x20+\
    \n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x03\x12\x04\xbf\x02./\n\x0e\n\x04\x04\
    \x0b\x03\x01\x12\x06\xc2\x02\x08\xca\x02\t\n\r\n\x05\x04\x0b\x03\x01\x01\
    \x12\x04\xc2\x02\x10\x14\n\x0e\n\x06\x04\x0b\x03\x01\x02\0\x12\x04\xc3\
    \x02\x106\n\x0f\n\x07\x04\x0b\x03\x01\x02\0\x04\x12\x04\xc3\x02\x10\x18\
    \n\x0f\n\x07\x04\x0b\x03\x01\x02\0\x05\x12\x04\xc3\x02\x19\x1f\n\x0f\n\
    \x07\x04\x0b\x03\x01\x02\0\x01\x12\x04\xc3\x02\x201\n\x0f\n\x07\x04\x0b\
    \x03\x01\x02\0\x03\x12\x04\xc3\x0245\n\x0e\n\x06\x04\x0b\x03\x01\x02\x01\
    \x12\x04\xc4\x02\x100\n\x0f\n\x07\x04\x0b\x03\x01\x02\x01\x04\x12\x04\
    \xc4\x02\x10\x18\n\x0f\n\x07\x04\x0b\x03\x01\x02\x01\x05\x12\x04\xc4\x02\
    \x19\x1f\n\x0f\n\x07\x04\x0b\x03\x01\x02\x01\x01\x12\x04\xc4\x02\x20+\n\
    \x0f\n\x07\x04\x0b\x03\x01\x02\x01\x03\x12\x04\xc4\x02./\n\x0e\n\x06\x04\
    \x0b\x03\x01\x02\x02\x12\x04\xc5\x02\x10,\n\x0f\n\x07\x04\x0b\x03\x01\
    \x02\x02\x04\x12\x04\xc5\x02\x10\x18\n\x0f\n\x07\x04\x0b\x03\x01\x02\x02\
    \x05\x12\x04\xc5\x02\x19\x1f\n\x0f\n\x07\x04\x0b\x03\x01\x02\x02\x01\x12\
    \x04\xc5\x02\x20'\n\x0f\n\x07\x04\x0b\x03\x01\x02\x02\x03\x12\x04\xc5\
    \x02*+\n\x0e\n\x06\x04\x0b\x03\x01\x02\x03\x12\x04\xc6\x02\x10.\n\x0f\n\
    \x07\x04\x0b\x03\x01\x02\x03\x04\x12\x04\xc6\x02\x10\x18\n\x0f\n\x07\x04\
    \x0b\x03\x01\x02\x03\x05\x12\x04\xc6\x02\x19\x1f\n\x0f\n\x07\x04\x0b\x03\
    \x01\x02\x03\x01\x12\x04\xc6\x02\x20)\n\x0f\n\x07\x04\x0b\x03\x01\x02\
    \x03\x03\x12\x04\xc6\x02,-\n\x0e\n\x06\x04\x0b\x03\x01\x02\x04\x12\x04\
    \xc7\x02\x10)\n\x0f\n\x07\x04\x0b\x03\x01\x02\x04\x04\x12\x04\xc7\x02\
    \x10\x18\n\x0f\n\x07\x04\x0b\x03\x01\x02\x04\x05\x12\x04\xc7\x02\x19\x1f\
    \n\x0f\n\x07\x04\x0b\x03\x01\x02\x04\x01\x12\x04\xc7\x02\x20$\n\x0f\n\
    \x07\x04\x0b\x03\x01\x02\x04\x03\x12\x04\xc7\x02'(\n\x0e\n\x06\x04\x0b\
    \x03\x01\x02\x05\x12\x04\xc8\x02\x10G\n\x0f\n\x07\x04\x0b\x03\x01\x02\
    \x05\x04\x12\x04\xc8\x02\x10\x18\n\x0f\n\x07\x04\x0b\x03\x01\x02\x05\x06\
    \x12\x04\xc8\x02\x19:\n\x0f\n\x07\x04\x0b\x03\x01\x02\x05\x01\x12\x04\
    \xc8\x02;B\n\x0f\n\x07\x04\x0b\x03\x01\x02\x05\x03\x12\x04\xc8\x02EF\n\
    \x0e\n\x06\x04\x0b\x03\x01\x02\x06\x12\x04\xc9\x02\x10,\n\x0f\n\x07\x04\
    \x0b\x03\x01\x02\x06\x04\x12\x04\xc9\x02\x10\x18\n\x0f\n\x07\x04\x0b\x03\
    \x01\x02\x06\x05\x12\x04\xc9\x02\x19\x1f\n\x0f\n\x07\x04\x0b\x03\x01\x02\
    \x06\x01\x12\x04\xc9\x02\x20'\n\x0f\n\x07\x04\x0b\x03\x01\x02\x06\x03\
    \x12\x04\xc9\x02*+\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xcc\x02\x088\n\r\n\
    \x05\x04\x0b\x02\0\x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x04\x0b\x02\0\
    \x06\x12\x04\xcc\x02\x11-\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xcc\x02.3\
    \n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xcc\x0267\n\x0c\n\x02\x04\x0c\x12\
    \x06\xcf\x02\0\xd7\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xcf\x02\x08\
    \x1e\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xd0\x02\x08-\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04\xd0\x02\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\
    \xd0\x02\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xd0\x02\x18(\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\xd0\x02+,\n\x0c\n\x04\x04\x0c\x02\x01\x12\
    \x04\xd1\x02\x08)\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xd1\x02\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xd1\x02\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\xd1\x02\x18$\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \xd1\x02'(\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xd2\x02\x08<\n\r\n\x05\
    \x04\x0c\x02\x02\x04\x12\x04\xd2\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x02\
    \x05\x12\x04\xd2\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xd2\
    \x02\x187\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xd2\x02:;\n\x0c\n\x04\
    \x04\x0c\x02\x03\x12\x04\xd3\x02\x089\n\r\n\x05\x04\x0c\x02\x03\x04\x12\
    \x04\xd3\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xd3\x02\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xd3\x02\x184\n\r\n\x05\x04\
    \x0c\x02\x03\x03\x12\x04\xd3\x0278\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\
    \xd4\x02\x08#\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\xd4\x02\x08\x10\n\r\
    \n\x05\x04\x0c\x02\x04\x05\x12\x04\xd4\x02\x11\x17\n\r\n\x05\x04\x0c\x02\
    \x04\x01\x12\x04\xd4\x02\x18\x1e\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\
    \xd4\x02!\"\n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\xd5\x02\x08#\n\r\n\x05\
    \x04\x0c\x02\x05\x04\x12\x04\xd5\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x05\
    \x05\x12\x04\xd5\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xd5\
    \x02\x18\x1e\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xd5\x02!\"\n\x0c\n\
    \x04\x04\x0c\x02\x06\x12\x04\xd6\x02\x08$\n\r\n\x05\x04\x0c\x02\x06\x04\
    \x12\x04\xd6\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xd6\x02\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xd6\x02\x18\x1f\n\r\n\x05\
    \x04\x0c\x02\x06\x03\x12\x04\xd6\x02\"#\n\x0c\n\x02\x04\r\x12\x06\xd9\
    \x02\0\xe7\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xd9\x02\x08#\n\x0e\n\
    \x04\x04\r\x03\0\x12\x06\xda\x02\x08\xe1\x02\t\n\r\n\x05\x04\r\x03\0\x01\
    \x12\x04\xda\x02\x10\x16\n\x0e\n\x06\x04\r\x03\0\x02\0\x12\x04\xdb\x02\
    \x108\n\x0f\n\x07\x04\r\x03\0\x02\0\x04\x12\x04\xdb\x02\x10\x18\n\x0f\n\
    \x07\x04\r\x03\0\x02\0\x05\x12\x04\xdb\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\
    \0\x02\0\x01\x12\x04\xdb\x02\x203\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\
    \x04\xdb\x0267\n\x0e\n\x06\x04\r\x03\0\x02\x01\x12\x04\xdc\x02\x10/\n\
    \x0f\n\x07\x04\r\x03\0\x02\x01\x04\x12\x04\xdc\x02\x10\x18\n\x0f\n\x07\
    \x04\r\x03\0\x02\x01\x05\x12\x04\xdc\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\
    \x02\x01\x01\x12\x04\xdc\x02\x20*\n\x0f\n\x07\x04\r\x03\0\x02\x01\x03\
    \x12\x04\xdc\x02-.\n\x0e\n\x06\x04\r\x03\0\x02\x02\x12\x04\xdd\x02\x10+\
    \n\x0f\n\x07\x04\r\x03\0\x02\x02\x04\x12\x04\xdd\x02\x10\x18\n\x0f\n\x07\
    \x04\r\x03\0\x02\x02\x05\x12\x04\xdd\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\
    \x02\x02\x01\x12\x04\xdd\x02\x20&\n\x0f\n\x07\x04\r\x03\0\x02\x02\x03\
    \x12\x04\xdd\x02)*\n\x0e\n\x06\x04\r\x03\0\x02\x03\x12\x04\xde\x02\x10.\
    \n\x0f\n\x07\x04\r\x03\0\x02\x03\x04\x12\x04\xde\x02\x10\x18\n\x0f\n\x07\
    \x04\r\x03\0\x02\x03\x05\x12\x04\xde\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\
    \x02\x03\x01\x12\x04\xde\x02\x20)\n\x0f\n\x07\x04\r\x03\0\x02\x03\x03\
    \x12\x04\xde\x02,-\n\x0e\n\x06\x04\r\x03\0\x02\x04\x12\x04\xdf\x02\x100\
    \n\x0f\n\x07\x04\r\x03\0\x02\x04\x04\x12\x04\xdf\x02\x10\x18\n\x0f\n\x07\
    \x04\r\x03\0\x02\x04\x05\x12\x04\xdf\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\
    \x02\x04\x01\x12\x04\xdf\x02\x20+\n\x0f\n\x07\x04\r\x03\0\x02\x04\x03\
    \x12\x04\xdf\x02./\n\x0e\n\x06\x04\r\x03\0\x02\x05\x12\x04\xe0\x02\x105\
    \n\x0f\n\x07\x04\r\x03\0\x02\x05\x04\x12\x04\xe0\x02\x10\x18\n\x0f\n\x07\
    \x04\r\x03\0\x02\x05\x05\x12\x04\xe0\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\
    \x02\x05\x01\x12\x04\xe0\x02\x200\n\x0f\n\x07\x04\r\x03\0\x02\x05\x03\
    \x12\x04\xe0\x0234\n\x0c\n\x04\x04\r\x02\0\x12\x04\xe3\x02\x08$\n\r\n\
    \x05\x04\r\x02\0\x04\x12\x04\xe3\x02\x08\x10\n\r\n\x05\x04\r\x02\0\x05\
    \x12\x04\xe3\x02\x11\x17\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xe3\x02\x18\
    \x1f\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xe3\x02\"#\n\x0c\n\x04\x04\r\x02\
    \x01\x12\x04\xe4\x02\x08&\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xe4\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xe4\x02\x11\x17\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\xe4\x02\x18!\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\xe4\x02$%\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xe5\x02\x08@\n\r\n\x05\
    \x04\r\x02\x02\x04\x12\x04\xe5\x02\x08\x10\n\r\n\x05\x04\r\x02\x02\x06\
    \x12\x04\xe5\x02\x113\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xe5\x024;\n\r\
    \n\x05\x04\r\x02\x02\x03\x12\x04\xe5\x02>?\n\x0c\n\x04\x04\r\x02\x03\x12\
    \x04\xe6\x02\x08)\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xe6\x02\x08\x10\n\
    \r\n\x05\x04\r\x02\x03\x05\x12\x04\xe6\x02\x11\x17\n\r\n\x05\x04\r\x02\
    \x03\x01\x12\x04\xe6\x02\x18$\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xe6\
    \x02'(\n\x0c\n\x02\x04\x0e\x12\x06\xe9\x02\0\xec\x02\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xe9\x02\x08\x18\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xea\
    \x02\x08)\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\0\x06\x12\x04\xea\x02\x11\x1e\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xea\x02\x1f$\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xea\x02'(\n\
    \x0c\n\x04\x04\x0e\x02\x01\x12\x04\xeb\x02\x081\n\r\n\x05\x04\x0e\x02\
    \x01\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\
    \xeb\x02\x11#\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xeb\x02$,\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\xeb\x02/0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common::file_descriptor().clone());
            deps.push(super::dota_match_metadata::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(32);
            messages.push(CMsgArcanaVotes::generated_message_descriptor_data());
            messages.push(CMsgDOTADPCFeed::generated_message_descriptor_data());
            messages.push(CMsgDOTADPCUserInfo::generated_message_descriptor_data());
            messages.push(CMsgDraftTrivia::generated_message_descriptor_data());
            messages.push(CMsgTeamFanContentAssetStatus::generated_message_descriptor_data());
            messages.push(CMsgTeamFanContentAssetStatusResponse::generated_message_descriptor_data());
            messages.push(CMsgTeamFanContentStatus::generated_message_descriptor_data());
            messages.push(CMsgTeamFanContentAutographStatus::generated_message_descriptor_data());
            messages.push(CMsgDPCEvent::generated_message_descriptor_data());
            messages.push(CMsgDPCEventList::generated_message_descriptor_data());
            messages.push(CMsgDOTAFantasyCardLineup::generated_message_descriptor_data());
            messages.push(CMsgDOTAFantasyCardList::generated_message_descriptor_data());
            messages.push(CMsgChatToxicityReport::generated_message_descriptor_data());
            messages.push(CMsgGetTeamAuditInformation::generated_message_descriptor_data());
            messages.push(CMsgDOTADPCMatch::generated_message_descriptor_data());
            messages.push(cmsg_arcana_votes::Match::generated_message_descriptor_data());
            messages.push(cmsg_dotadpcfeed::Element::generated_message_descriptor_data());
            messages.push(cmsg_draft_trivia::DraftTriviaHeroInfo::generated_message_descriptor_data());
            messages.push(cmsg_draft_trivia::DraftTriviaMatchInfo::generated_message_descriptor_data());
            messages.push(cmsg_draft_trivia::PreviousResult::generated_message_descriptor_data());
            messages.push(cmsg_team_fan_content_status::TeamStatus::generated_message_descriptor_data());
            messages.push(cmsg_team_fan_content_autograph_status::AutographStatus::generated_message_descriptor_data());
            messages.push(cmsg_team_fan_content_autograph_status::TeamStatus::generated_message_descriptor_data());
            messages.push(cmsg_dpcevent::PhaseInfo::generated_message_descriptor_data());
            messages.push(cmsg_dpcevent::League::generated_message_descriptor_data());
            messages.push(cmsg_dotafantasy_card_lineup::CardBonus::generated_message_descriptor_data());
            messages.push(cmsg_dotafantasy_card_lineup::Card::generated_message_descriptor_data());
            messages.push(cmsg_dotafantasy_card_lineup::League::generated_message_descriptor_data());
            messages.push(cmsg_dotafantasy_card_lineup::Period::generated_message_descriptor_data());
            messages.push(cmsg_dotafantasy_card_list::CardBonus::generated_message_descriptor_data());
            messages.push(cmsg_dotafantasy_card_list::Card::generated_message_descriptor_data());
            messages.push(cmsg_get_team_audit_information::Action::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(ETeamFanContentStatus::generated_enum_descriptor_data());
            enums.push(ETeamFanContentAssetType::generated_enum_descriptor_data());
            enums.push(ETeamFanContentAssetStatus::generated_enum_descriptor_data());
            enums.push(cmsg_arcana_votes::VotingState::generated_enum_descriptor_data());
            enums.push(cmsg_dotadpcfeed::EFeedElementType::generated_enum_descriptor_data());
            enums.push(cmsg_team_fan_content_asset_status_response::EResult::generated_enum_descriptor_data());
            enums.push(cmsg_dpcevent::ELeagueEvent::generated_enum_descriptor_data());
            enums.push(cmsg_dpcevent::ELeagueEventPhase::generated_enum_descriptor_data());
            enums.push(cmsg_dpcevent::ELeagueEventType::generated_enum_descriptor_data());
            enums.push(cmsg_dpcevent::ETour::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
