// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_guild.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgGuildInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_name)
    pub guild_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_tag)
    pub guild_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.created_timestamp)
    pub created_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_language)
    pub guild_language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_logo)
    pub guild_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_region)
    pub guild_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_chat_group_id)
    pub guild_chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_description)
    pub guild_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.default_chat_channel_id)
    pub default_chat_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_primary_color)
    pub guild_primary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_secondary_color)
    pub guild_secondary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_pattern)
    pub guild_pattern: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_refresh_time_offset)
    pub guild_refresh_time_offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_required_rank_tier)
    pub guild_required_rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_motd_timestamp)
    pub guild_motd_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInfo.guild_motd)
    pub guild_motd: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildInfo {
    fn default() -> &'a CMsgGuildInfo {
        <CMsgGuildInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildInfo {
    pub fn new() -> CMsgGuildInfo {
        ::std::default::Default::default()
    }

    // optional string guild_name = 1;

    pub fn guild_name(&self) -> &str {
        match self.guild_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_name(&mut self) {
        self.guild_name = ::std::option::Option::None;
    }

    pub fn has_guild_name(&self) -> bool {
        self.guild_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_name(&mut self, v: ::std::string::String) {
        self.guild_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_name(&mut self) -> &mut ::std::string::String {
        if self.guild_name.is_none() {
            self.guild_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_name(&mut self) -> ::std::string::String {
        self.guild_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string guild_tag = 2;

    pub fn guild_tag(&self) -> &str {
        match self.guild_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_tag(&mut self) {
        self.guild_tag = ::std::option::Option::None;
    }

    pub fn has_guild_tag(&self) -> bool {
        self.guild_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_tag(&mut self, v: ::std::string::String) {
        self.guild_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_tag(&mut self) -> &mut ::std::string::String {
        if self.guild_tag.is_none() {
            self.guild_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_tag(&mut self) -> ::std::string::String {
        self.guild_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 created_timestamp = 3;

    pub fn created_timestamp(&self) -> u32 {
        self.created_timestamp.unwrap_or(0)
    }

    pub fn clear_created_timestamp(&mut self) {
        self.created_timestamp = ::std::option::Option::None;
    }

    pub fn has_created_timestamp(&self) -> bool {
        self.created_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_timestamp(&mut self, v: u32) {
        self.created_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_language = 4;

    pub fn guild_language(&self) -> u32 {
        self.guild_language.unwrap_or(0)
    }

    pub fn clear_guild_language(&mut self) {
        self.guild_language = ::std::option::Option::None;
    }

    pub fn has_guild_language(&self) -> bool {
        self.guild_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_language(&mut self, v: u32) {
        self.guild_language = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_flags = 5;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_logo = 7;

    pub fn guild_logo(&self) -> u64 {
        self.guild_logo.unwrap_or(0)
    }

    pub fn clear_guild_logo(&mut self) {
        self.guild_logo = ::std::option::Option::None;
    }

    pub fn has_guild_logo(&self) -> bool {
        self.guild_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_logo(&mut self, v: u64) {
        self.guild_logo = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_region = 8;

    pub fn guild_region(&self) -> u32 {
        self.guild_region.unwrap_or(0)
    }

    pub fn clear_guild_region(&mut self) {
        self.guild_region = ::std::option::Option::None;
    }

    pub fn has_guild_region(&self) -> bool {
        self.guild_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_region(&mut self, v: u32) {
        self.guild_region = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_chat_group_id = 9;

    pub fn guild_chat_group_id(&self) -> u64 {
        self.guild_chat_group_id.unwrap_or(0)
    }

    pub fn clear_guild_chat_group_id(&mut self) {
        self.guild_chat_group_id = ::std::option::Option::None;
    }

    pub fn has_guild_chat_group_id(&self) -> bool {
        self.guild_chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_chat_group_id(&mut self, v: u64) {
        self.guild_chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string guild_description = 10;

    pub fn guild_description(&self) -> &str {
        match self.guild_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_description(&mut self) {
        self.guild_description = ::std::option::Option::None;
    }

    pub fn has_guild_description(&self) -> bool {
        self.guild_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_description(&mut self, v: ::std::string::String) {
        self.guild_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_description(&mut self) -> &mut ::std::string::String {
        if self.guild_description.is_none() {
            self.guild_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_description(&mut self) -> ::std::string::String {
        self.guild_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 default_chat_channel_id = 11;

    pub fn default_chat_channel_id(&self) -> u64 {
        self.default_chat_channel_id.unwrap_or(0)
    }

    pub fn clear_default_chat_channel_id(&mut self) {
        self.default_chat_channel_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_channel_id(&self) -> bool {
        self.default_chat_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_channel_id(&mut self, v: u64) {
        self.default_chat_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_primary_color = 12;

    pub fn guild_primary_color(&self) -> u32 {
        self.guild_primary_color.unwrap_or(0)
    }

    pub fn clear_guild_primary_color(&mut self) {
        self.guild_primary_color = ::std::option::Option::None;
    }

    pub fn has_guild_primary_color(&self) -> bool {
        self.guild_primary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_primary_color(&mut self, v: u32) {
        self.guild_primary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_secondary_color = 13;

    pub fn guild_secondary_color(&self) -> u32 {
        self.guild_secondary_color.unwrap_or(0)
    }

    pub fn clear_guild_secondary_color(&mut self) {
        self.guild_secondary_color = ::std::option::Option::None;
    }

    pub fn has_guild_secondary_color(&self) -> bool {
        self.guild_secondary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_secondary_color(&mut self, v: u32) {
        self.guild_secondary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_pattern = 14;

    pub fn guild_pattern(&self) -> u32 {
        self.guild_pattern.unwrap_or(0)
    }

    pub fn clear_guild_pattern(&mut self) {
        self.guild_pattern = ::std::option::Option::None;
    }

    pub fn has_guild_pattern(&self) -> bool {
        self.guild_pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_pattern(&mut self, v: u32) {
        self.guild_pattern = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_refresh_time_offset = 15;

    pub fn guild_refresh_time_offset(&self) -> u32 {
        self.guild_refresh_time_offset.unwrap_or(0)
    }

    pub fn clear_guild_refresh_time_offset(&mut self) {
        self.guild_refresh_time_offset = ::std::option::Option::None;
    }

    pub fn has_guild_refresh_time_offset(&self) -> bool {
        self.guild_refresh_time_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_refresh_time_offset(&mut self, v: u32) {
        self.guild_refresh_time_offset = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_required_rank_tier = 16;

    pub fn guild_required_rank_tier(&self) -> u32 {
        self.guild_required_rank_tier.unwrap_or(0)
    }

    pub fn clear_guild_required_rank_tier(&mut self) {
        self.guild_required_rank_tier = ::std::option::Option::None;
    }

    pub fn has_guild_required_rank_tier(&self) -> bool {
        self.guild_required_rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_required_rank_tier(&mut self, v: u32) {
        self.guild_required_rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_motd_timestamp = 17;

    pub fn guild_motd_timestamp(&self) -> u32 {
        self.guild_motd_timestamp.unwrap_or(0)
    }

    pub fn clear_guild_motd_timestamp(&mut self) {
        self.guild_motd_timestamp = ::std::option::Option::None;
    }

    pub fn has_guild_motd_timestamp(&self) -> bool {
        self.guild_motd_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_motd_timestamp(&mut self, v: u32) {
        self.guild_motd_timestamp = ::std::option::Option::Some(v);
    }

    // optional string guild_motd = 18;

    pub fn guild_motd(&self) -> &str {
        match self.guild_motd.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_motd(&mut self) {
        self.guild_motd = ::std::option::Option::None;
    }

    pub fn has_guild_motd(&self) -> bool {
        self.guild_motd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_motd(&mut self, v: ::std::string::String) {
        self.guild_motd = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_motd(&mut self) -> &mut ::std::string::String {
        if self.guild_motd.is_none() {
            self.guild_motd = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_motd.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_motd(&mut self) -> ::std::string::String {
        self.guild_motd.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_name",
            |m: &CMsgGuildInfo| { &m.guild_name },
            |m: &mut CMsgGuildInfo| { &mut m.guild_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_tag",
            |m: &CMsgGuildInfo| { &m.guild_tag },
            |m: &mut CMsgGuildInfo| { &mut m.guild_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "created_timestamp",
            |m: &CMsgGuildInfo| { &m.created_timestamp },
            |m: &mut CMsgGuildInfo| { &mut m.created_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_language",
            |m: &CMsgGuildInfo| { &m.guild_language },
            |m: &mut CMsgGuildInfo| { &mut m.guild_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_flags",
            |m: &CMsgGuildInfo| { &m.guild_flags },
            |m: &mut CMsgGuildInfo| { &mut m.guild_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_logo",
            |m: &CMsgGuildInfo| { &m.guild_logo },
            |m: &mut CMsgGuildInfo| { &mut m.guild_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_region",
            |m: &CMsgGuildInfo| { &m.guild_region },
            |m: &mut CMsgGuildInfo| { &mut m.guild_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_chat_group_id",
            |m: &CMsgGuildInfo| { &m.guild_chat_group_id },
            |m: &mut CMsgGuildInfo| { &mut m.guild_chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_description",
            |m: &CMsgGuildInfo| { &m.guild_description },
            |m: &mut CMsgGuildInfo| { &mut m.guild_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_chat_channel_id",
            |m: &CMsgGuildInfo| { &m.default_chat_channel_id },
            |m: &mut CMsgGuildInfo| { &mut m.default_chat_channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_primary_color",
            |m: &CMsgGuildInfo| { &m.guild_primary_color },
            |m: &mut CMsgGuildInfo| { &mut m.guild_primary_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_secondary_color",
            |m: &CMsgGuildInfo| { &m.guild_secondary_color },
            |m: &mut CMsgGuildInfo| { &mut m.guild_secondary_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_pattern",
            |m: &CMsgGuildInfo| { &m.guild_pattern },
            |m: &mut CMsgGuildInfo| { &mut m.guild_pattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_refresh_time_offset",
            |m: &CMsgGuildInfo| { &m.guild_refresh_time_offset },
            |m: &mut CMsgGuildInfo| { &mut m.guild_refresh_time_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_required_rank_tier",
            |m: &CMsgGuildInfo| { &m.guild_required_rank_tier },
            |m: &mut CMsgGuildInfo| { &mut m.guild_required_rank_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_motd_timestamp",
            |m: &CMsgGuildInfo| { &m.guild_motd_timestamp },
            |m: &mut CMsgGuildInfo| { &mut m.guild_motd_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_motd",
            |m: &CMsgGuildInfo| { &m.guild_motd },
            |m: &mut CMsgGuildInfo| { &mut m.guild_motd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildInfo>(
            "CMsgGuildInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildInfo {
    const NAME: &'static str = "CMsgGuildInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guild_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.guild_tag = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.created_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.guild_language = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.guild_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.guild_chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    self.guild_description = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.default_chat_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.guild_primary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.guild_secondary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.guild_pattern = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.guild_refresh_time_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.guild_required_rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.guild_motd_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.guild_motd = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.guild_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.created_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_language {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.guild_logo {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.guild_region {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.guild_chat_group_id {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.guild_description.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.default_chat_channel_id {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.guild_primary_color {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.guild_secondary_color {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.guild_pattern {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.guild_refresh_time_offset {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.guild_required_rank_tier {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.guild_motd_timestamp {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.guild_motd.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.guild_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.created_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_language {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.guild_logo {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.guild_region {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.guild_chat_group_id {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.guild_description.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.default_chat_channel_id {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.guild_primary_color {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.guild_secondary_color {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.guild_pattern {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.guild_refresh_time_offset {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.guild_required_rank_tier {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.guild_motd_timestamp {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.guild_motd.as_ref() {
            os.write_string(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildInfo {
        CMsgGuildInfo::new()
    }

    fn clear(&mut self) {
        self.guild_name = ::std::option::Option::None;
        self.guild_tag = ::std::option::Option::None;
        self.created_timestamp = ::std::option::Option::None;
        self.guild_language = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.guild_logo = ::std::option::Option::None;
        self.guild_region = ::std::option::Option::None;
        self.guild_chat_group_id = ::std::option::Option::None;
        self.guild_description = ::std::option::Option::None;
        self.default_chat_channel_id = ::std::option::Option::None;
        self.guild_primary_color = ::std::option::Option::None;
        self.guild_secondary_color = ::std::option::Option::None;
        self.guild_pattern = ::std::option::Option::None;
        self.guild_refresh_time_offset = ::std::option::Option::None;
        self.guild_required_rank_tier = ::std::option::Option::None;
        self.guild_motd_timestamp = ::std::option::Option::None;
        self.guild_motd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildInfo {
        static instance: CMsgGuildInfo = CMsgGuildInfo {
            guild_name: ::std::option::Option::None,
            guild_tag: ::std::option::Option::None,
            created_timestamp: ::std::option::Option::None,
            guild_language: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            guild_logo: ::std::option::Option::None,
            guild_region: ::std::option::Option::None,
            guild_chat_group_id: ::std::option::Option::None,
            guild_description: ::std::option::Option::None,
            default_chat_channel_id: ::std::option::Option::None,
            guild_primary_color: ::std::option::Option::None,
            guild_secondary_color: ::std::option::Option::None,
            guild_pattern: ::std::option::Option::None,
            guild_refresh_time_offset: ::std::option::Option::None,
            guild_required_rank_tier: ::std::option::Option::None,
            guild_motd_timestamp: ::std::option::Option::None,
            guild_motd: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildSummary {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildSummary.guild_info)
    pub guild_info: ::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:dota.CMsgGuildSummary.member_count)
    pub member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildSummary.event_points)
    pub event_points: ::std::vec::Vec<cmsg_guild_summary::EventPoints>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildSummary {
    fn default() -> &'a CMsgGuildSummary {
        <CMsgGuildSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildSummary {
    pub fn new() -> CMsgGuildSummary {
        ::std::default::Default::default()
    }

    // optional uint32 member_count = 2;

    pub fn member_count(&self) -> u32 {
        self.member_count.unwrap_or(0)
    }

    pub fn clear_member_count(&mut self) {
        self.member_count = ::std::option::Option::None;
    }

    pub fn has_member_count(&self) -> bool {
        self.member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_count(&mut self, v: u32) {
        self.member_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildInfo>(
            "guild_info",
            |m: &CMsgGuildSummary| { &m.guild_info },
            |m: &mut CMsgGuildSummary| { &mut m.guild_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_count",
            |m: &CMsgGuildSummary| { &m.member_count },
            |m: &mut CMsgGuildSummary| { &mut m.member_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_points",
            |m: &CMsgGuildSummary| { &m.event_points },
            |m: &mut CMsgGuildSummary| { &mut m.event_points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildSummary>(
            "CMsgGuildSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildSummary {
    const NAME: &'static str = "CMsgGuildSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                16 => {
                    self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.event_points.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.member_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.event_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.member_count {
            os.write_uint32(2, v)?;
        }
        for v in &self.event_points {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildSummary {
        CMsgGuildSummary::new()
    }

    fn clear(&mut self) {
        self.guild_info.clear();
        self.member_count = ::std::option::Option::None;
        self.event_points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildSummary {
        static instance: CMsgGuildSummary = CMsgGuildSummary {
            guild_info: ::protobuf::MessageField::none(),
            member_count: ::std::option::Option::None,
            event_points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGuildSummary`
pub mod cmsg_guild_summary {
    // @@protoc_insertion_point(message:dota.CMsgGuildSummary.EventPoints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventPoints {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGuildSummary.EventPoints.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGuildSummary.EventPoints.guild_points)
        pub guild_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGuildSummary.EventPoints.guild_rank)
        pub guild_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGuildSummary.EventPoints.guild_weekly_rank)
        pub guild_weekly_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGuildSummary.EventPoints.guild_weekly_percentile)
        pub guild_weekly_percentile: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGuildSummary.EventPoints.guild_current_percentile)
        pub guild_current_percentile: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGuildSummary.EventPoints.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventPoints {
        fn default() -> &'a EventPoints {
            <EventPoints as ::protobuf::Message>::default_instance()
        }
    }

    impl EventPoints {
        pub fn new() -> EventPoints {
            ::std::default::Default::default()
        }

        // optional uint32 event_id = 1;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_points = 2;

        pub fn guild_points(&self) -> u32 {
            self.guild_points.unwrap_or(0)
        }

        pub fn clear_guild_points(&mut self) {
            self.guild_points = ::std::option::Option::None;
        }

        pub fn has_guild_points(&self) -> bool {
            self.guild_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_points(&mut self, v: u32) {
            self.guild_points = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_rank = 3;

        pub fn guild_rank(&self) -> u32 {
            self.guild_rank.unwrap_or(0)
        }

        pub fn clear_guild_rank(&mut self) {
            self.guild_rank = ::std::option::Option::None;
        }

        pub fn has_guild_rank(&self) -> bool {
            self.guild_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_rank(&mut self, v: u32) {
            self.guild_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_weekly_rank = 4;

        pub fn guild_weekly_rank(&self) -> u32 {
            self.guild_weekly_rank.unwrap_or(0)
        }

        pub fn clear_guild_weekly_rank(&mut self) {
            self.guild_weekly_rank = ::std::option::Option::None;
        }

        pub fn has_guild_weekly_rank(&self) -> bool {
            self.guild_weekly_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_weekly_rank(&mut self, v: u32) {
            self.guild_weekly_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_weekly_percentile = 5;

        pub fn guild_weekly_percentile(&self) -> u32 {
            self.guild_weekly_percentile.unwrap_or(0)
        }

        pub fn clear_guild_weekly_percentile(&mut self) {
            self.guild_weekly_percentile = ::std::option::Option::None;
        }

        pub fn has_guild_weekly_percentile(&self) -> bool {
            self.guild_weekly_percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_weekly_percentile(&mut self, v: u32) {
            self.guild_weekly_percentile = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_current_percentile = 6;

        pub fn guild_current_percentile(&self) -> u32 {
            self.guild_current_percentile.unwrap_or(0)
        }

        pub fn clear_guild_current_percentile(&mut self) {
            self.guild_current_percentile = ::std::option::Option::None;
        }

        pub fn has_guild_current_percentile(&self) -> bool {
            self.guild_current_percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_current_percentile(&mut self, v: u32) {
            self.guild_current_percentile = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &EventPoints| { &m.event_id },
                |m: &mut EventPoints| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_points",
                |m: &EventPoints| { &m.guild_points },
                |m: &mut EventPoints| { &mut m.guild_points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_rank",
                |m: &EventPoints| { &m.guild_rank },
                |m: &mut EventPoints| { &mut m.guild_rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_weekly_rank",
                |m: &EventPoints| { &m.guild_weekly_rank },
                |m: &mut EventPoints| { &mut m.guild_weekly_rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_weekly_percentile",
                |m: &EventPoints| { &m.guild_weekly_percentile },
                |m: &mut EventPoints| { &mut m.guild_weekly_percentile },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_current_percentile",
                |m: &EventPoints| { &m.guild_current_percentile },
                |m: &mut EventPoints| { &mut m.guild_current_percentile },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventPoints>(
                "CMsgGuildSummary.EventPoints",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EventPoints {
        const NAME: &'static str = "EventPoints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.guild_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.guild_weekly_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.guild_current_percentile = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guild_points {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.guild_rank {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.guild_weekly_rank {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.guild_weekly_percentile {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.guild_current_percentile {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guild_points {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.guild_rank {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.guild_weekly_rank {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.guild_weekly_percentile {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.guild_current_percentile {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventPoints {
            EventPoints::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.guild_points = ::std::option::Option::None;
            self.guild_rank = ::std::option::Option::None;
            self.guild_weekly_rank = ::std::option::Option::None;
            self.guild_weekly_percentile = ::std::option::Option::None;
            self.guild_current_percentile = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventPoints {
            static instance: EventPoints = EventPoints {
                event_id: ::std::option::Option::None,
                guild_points: ::std::option::Option::None,
                guild_rank: ::std::option::Option::None,
                guild_weekly_rank: ::std::option::Option::None,
                guild_weekly_percentile: ::std::option::Option::None,
                guild_current_percentile: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EventPoints {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGuildSummary.EventPoints").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EventPoints {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EventPoints {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildRole {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildRole.role_id)
    pub role_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildRole.role_name)
    pub role_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGuildRole.role_flags)
    pub role_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildRole.role_order)
    pub role_order: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildRole {
    fn default() -> &'a CMsgGuildRole {
        <CMsgGuildRole as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildRole {
    pub fn new() -> CMsgGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 role_id = 1;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string role_name = 2;

    pub fn role_name(&self) -> &str {
        match self.role_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_role_name(&mut self) {
        self.role_name = ::std::option::Option::None;
    }

    pub fn has_role_name(&self) -> bool {
        self.role_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_name(&mut self, v: ::std::string::String) {
        self.role_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_name(&mut self) -> &mut ::std::string::String {
        if self.role_name.is_none() {
            self.role_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.role_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_name(&mut self) -> ::std::string::String {
        self.role_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 role_flags = 3;

    pub fn role_flags(&self) -> u32 {
        self.role_flags.unwrap_or(0)
    }

    pub fn clear_role_flags(&mut self) {
        self.role_flags = ::std::option::Option::None;
    }

    pub fn has_role_flags(&self) -> bool {
        self.role_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_flags(&mut self, v: u32) {
        self.role_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 role_order = 4;

    pub fn role_order(&self) -> u32 {
        self.role_order.unwrap_or(0)
    }

    pub fn clear_role_order(&mut self) {
        self.role_order = ::std::option::Option::None;
    }

    pub fn has_role_order(&self) -> bool {
        self.role_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_order(&mut self, v: u32) {
        self.role_order = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CMsgGuildRole| { &m.role_id },
            |m: &mut CMsgGuildRole| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_name",
            |m: &CMsgGuildRole| { &m.role_name },
            |m: &mut CMsgGuildRole| { &mut m.role_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_flags",
            |m: &CMsgGuildRole| { &m.role_flags },
            |m: &mut CMsgGuildRole| { &mut m.role_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_order",
            |m: &CMsgGuildRole| { &m.role_order },
            |m: &mut CMsgGuildRole| { &mut m.role_order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildRole>(
            "CMsgGuildRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildRole {
    const NAME: &'static str = "CMsgGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.role_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.role_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.role_order = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.role_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.role_order {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.role_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.role_order {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildRole {
        CMsgGuildRole::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.role_name = ::std::option::Option::None;
        self.role_flags = ::std::option::Option::None;
        self.role_order = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildRole {
        static instance: CMsgGuildRole = CMsgGuildRole {
            role_id: ::std::option::Option::None,
            role_name: ::std::option::Option::None,
            role_flags: ::std::option::Option::None,
            role_order: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildMember {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildMember.member_account_id)
    pub member_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildMember.member_role_id)
    pub member_role_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildMember.member_joined_timestamp)
    pub member_joined_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildMember.member_last_active_timestamp)
    pub member_last_active_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildMember {
    fn default() -> &'a CMsgGuildMember {
        <CMsgGuildMember as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildMember {
    pub fn new() -> CMsgGuildMember {
        ::std::default::Default::default()
    }

    // optional uint32 member_account_id = 1;

    pub fn member_account_id(&self) -> u32 {
        self.member_account_id.unwrap_or(0)
    }

    pub fn clear_member_account_id(&mut self) {
        self.member_account_id = ::std::option::Option::None;
    }

    pub fn has_member_account_id(&self) -> bool {
        self.member_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_account_id(&mut self, v: u32) {
        self.member_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 member_role_id = 2;

    pub fn member_role_id(&self) -> u32 {
        self.member_role_id.unwrap_or(0)
    }

    pub fn clear_member_role_id(&mut self) {
        self.member_role_id = ::std::option::Option::None;
    }

    pub fn has_member_role_id(&self) -> bool {
        self.member_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_role_id(&mut self, v: u32) {
        self.member_role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 member_joined_timestamp = 3;

    pub fn member_joined_timestamp(&self) -> u32 {
        self.member_joined_timestamp.unwrap_or(0)
    }

    pub fn clear_member_joined_timestamp(&mut self) {
        self.member_joined_timestamp = ::std::option::Option::None;
    }

    pub fn has_member_joined_timestamp(&self) -> bool {
        self.member_joined_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_joined_timestamp(&mut self, v: u32) {
        self.member_joined_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 member_last_active_timestamp = 4;

    pub fn member_last_active_timestamp(&self) -> u32 {
        self.member_last_active_timestamp.unwrap_or(0)
    }

    pub fn clear_member_last_active_timestamp(&mut self) {
        self.member_last_active_timestamp = ::std::option::Option::None;
    }

    pub fn has_member_last_active_timestamp(&self) -> bool {
        self.member_last_active_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_last_active_timestamp(&mut self, v: u32) {
        self.member_last_active_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_account_id",
            |m: &CMsgGuildMember| { &m.member_account_id },
            |m: &mut CMsgGuildMember| { &mut m.member_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_role_id",
            |m: &CMsgGuildMember| { &m.member_role_id },
            |m: &mut CMsgGuildMember| { &mut m.member_role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_joined_timestamp",
            |m: &CMsgGuildMember| { &m.member_joined_timestamp },
            |m: &mut CMsgGuildMember| { &mut m.member_joined_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_last_active_timestamp",
            |m: &CMsgGuildMember| { &m.member_last_active_timestamp },
            |m: &mut CMsgGuildMember| { &mut m.member_last_active_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildMember>(
            "CMsgGuildMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildMember {
    const NAME: &'static str = "CMsgGuildMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.member_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.member_role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.member_joined_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.member_last_active_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.member_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.member_role_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.member_joined_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.member_last_active_timestamp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.member_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.member_role_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.member_joined_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.member_last_active_timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildMember {
        CMsgGuildMember::new()
    }

    fn clear(&mut self) {
        self.member_account_id = ::std::option::Option::None;
        self.member_role_id = ::std::option::Option::None;
        self.member_joined_timestamp = ::std::option::Option::None;
        self.member_last_active_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildMember {
        static instance: CMsgGuildMember = CMsgGuildMember {
            member_account_id: ::std::option::Option::None,
            member_role_id: ::std::option::Option::None,
            member_joined_timestamp: ::std::option::Option::None,
            member_last_active_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildInvite {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildInvite.requester_account_id)
    pub requester_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInvite.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildInvite.timestamp_sent)
    pub timestamp_sent: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildInvite {
    fn default() -> &'a CMsgGuildInvite {
        <CMsgGuildInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildInvite {
    pub fn new() -> CMsgGuildInvite {
        ::std::default::Default::default()
    }

    // optional uint32 requester_account_id = 1;

    pub fn requester_account_id(&self) -> u32 {
        self.requester_account_id.unwrap_or(0)
    }

    pub fn clear_requester_account_id(&mut self) {
        self.requester_account_id = ::std::option::Option::None;
    }

    pub fn has_requester_account_id(&self) -> bool {
        self.requester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_account_id(&mut self, v: u32) {
        self.requester_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_sent = 3;

    pub fn timestamp_sent(&self) -> u32 {
        self.timestamp_sent.unwrap_or(0)
    }

    pub fn clear_timestamp_sent(&mut self) {
        self.timestamp_sent = ::std::option::Option::None;
    }

    pub fn has_timestamp_sent(&self) -> bool {
        self.timestamp_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_sent(&mut self, v: u32) {
        self.timestamp_sent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requester_account_id",
            |m: &CMsgGuildInvite| { &m.requester_account_id },
            |m: &mut CMsgGuildInvite| { &mut m.requester_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_account_id",
            |m: &CMsgGuildInvite| { &m.target_account_id },
            |m: &mut CMsgGuildInvite| { &mut m.target_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_sent",
            |m: &CMsgGuildInvite| { &m.timestamp_sent },
            |m: &mut CMsgGuildInvite| { &mut m.timestamp_sent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildInvite>(
            "CMsgGuildInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildInvite {
    const NAME: &'static str = "CMsgGuildInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.requester_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timestamp_sent = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requester_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timestamp_sent {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.requester_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp_sent {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildInvite {
        CMsgGuildInvite::new()
    }

    fn clear(&mut self) {
        self.requester_account_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.timestamp_sent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildInvite {
        static instance: CMsgGuildInvite = CMsgGuildInvite {
            requester_account_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            timestamp_sent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildData.guild_info)
    pub guild_info: ::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:dota.CMsgGuildData.guild_roles)
    pub guild_roles: ::std::vec::Vec<CMsgGuildRole>,
    // @@protoc_insertion_point(field:dota.CMsgGuildData.guild_members)
    pub guild_members: ::std::vec::Vec<CMsgGuildMember>,
    // @@protoc_insertion_point(field:dota.CMsgGuildData.guild_invites)
    pub guild_invites: ::std::vec::Vec<CMsgGuildInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildData {
    fn default() -> &'a CMsgGuildData {
        <CMsgGuildData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildData {
    pub fn new() -> CMsgGuildData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGuildData| { &m.guild_id },
            |m: &mut CMsgGuildData| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildInfo>(
            "guild_info",
            |m: &CMsgGuildData| { &m.guild_info },
            |m: &mut CMsgGuildData| { &mut m.guild_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_roles",
            |m: &CMsgGuildData| { &m.guild_roles },
            |m: &mut CMsgGuildData| { &mut m.guild_roles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_members",
            |m: &CMsgGuildData| { &m.guild_members },
            |m: &mut CMsgGuildData| { &mut m.guild_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_invites",
            |m: &CMsgGuildData| { &m.guild_invites },
            |m: &mut CMsgGuildData| { &mut m.guild_invites },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildData>(
            "CMsgGuildData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildData {
    const NAME: &'static str = "CMsgGuildData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                26 => {
                    self.guild_roles.push(is.read_message()?);
                },
                34 => {
                    self.guild_members.push(is.read_message()?);
                },
                42 => {
                    self.guild_invites.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.guild_roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.guild_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.guild_invites {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.guild_roles {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.guild_members {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.guild_invites {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildData {
        CMsgGuildData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_info.clear();
        self.guild_roles.clear();
        self.guild_members.clear();
        self.guild_invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildData {
        static instance: CMsgGuildData = CMsgGuildData {
            guild_id: ::std::option::Option::None,
            guild_info: ::protobuf::MessageField::none(),
            guild_roles: ::std::vec::Vec::new(),
            guild_members: ::std::vec::Vec::new(),
            guild_invites: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAccountGuildInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildInvite {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildInvite.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildInvite.requester_account_id)
    pub requester_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildInvite.timestamp_sent)
    pub timestamp_sent: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAccountGuildInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildInvite {
    fn default() -> &'a CMsgAccountGuildInvite {
        <CMsgAccountGuildInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildInvite {
    pub fn new() -> CMsgAccountGuildInvite {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requester_account_id = 2;

    pub fn requester_account_id(&self) -> u32 {
        self.requester_account_id.unwrap_or(0)
    }

    pub fn clear_requester_account_id(&mut self) {
        self.requester_account_id = ::std::option::Option::None;
    }

    pub fn has_requester_account_id(&self) -> bool {
        self.requester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_account_id(&mut self, v: u32) {
        self.requester_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_sent = 3;

    pub fn timestamp_sent(&self) -> u32 {
        self.timestamp_sent.unwrap_or(0)
    }

    pub fn clear_timestamp_sent(&mut self) {
        self.timestamp_sent = ::std::option::Option::None;
    }

    pub fn has_timestamp_sent(&self) -> bool {
        self.timestamp_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_sent(&mut self, v: u32) {
        self.timestamp_sent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgAccountGuildInvite| { &m.guild_id },
            |m: &mut CMsgAccountGuildInvite| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requester_account_id",
            |m: &CMsgAccountGuildInvite| { &m.requester_account_id },
            |m: &mut CMsgAccountGuildInvite| { &mut m.requester_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_sent",
            |m: &CMsgAccountGuildInvite| { &m.timestamp_sent },
            |m: &mut CMsgAccountGuildInvite| { &mut m.timestamp_sent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAccountGuildInvite>(
            "CMsgAccountGuildInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAccountGuildInvite {
    const NAME: &'static str = "CMsgAccountGuildInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.requester_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timestamp_sent = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.requester_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timestamp_sent {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.requester_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp_sent {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildInvite {
        CMsgAccountGuildInvite::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.requester_account_id = ::std::option::Option::None;
        self.timestamp_sent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildInvite {
        static instance: CMsgAccountGuildInvite = CMsgAccountGuildInvite {
            guild_id: ::std::option::Option::None,
            requester_account_id: ::std::option::Option::None,
            timestamp_sent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAccountGuildInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAccountGuildInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAccountGuildInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAccountGuildInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAccountGuildMemberships)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildMemberships {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildMemberships.guild_ids)
    pub guild_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildMemberships.guild_invites)
    pub guild_invites: ::std::vec::Vec<CMsgAccountGuildInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAccountGuildMemberships.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildMemberships {
    fn default() -> &'a CMsgAccountGuildMemberships {
        <CMsgAccountGuildMemberships as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildMemberships {
    pub fn new() -> CMsgAccountGuildMemberships {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_ids",
            |m: &CMsgAccountGuildMemberships| { &m.guild_ids },
            |m: &mut CMsgAccountGuildMemberships| { &mut m.guild_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_invites",
            |m: &CMsgAccountGuildMemberships| { &m.guild_invites },
            |m: &mut CMsgAccountGuildMemberships| { &mut m.guild_invites },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAccountGuildMemberships>(
            "CMsgAccountGuildMemberships",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAccountGuildMemberships {
    const NAME: &'static str = "CMsgAccountGuildMemberships";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.guild_ids)?;
                },
                8 => {
                    self.guild_ids.push(is.read_uint32()?);
                },
                18 => {
                    self.guild_invites.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.guild_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.guild_invites {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.guild_ids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.guild_invites {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildMemberships {
        CMsgAccountGuildMemberships::new()
    }

    fn clear(&mut self) {
        self.guild_ids.clear();
        self.guild_invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildMemberships {
        static instance: CMsgAccountGuildMemberships = CMsgAccountGuildMemberships {
            guild_ids: ::std::vec::Vec::new(),
            guild_invites: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAccountGuildMemberships {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAccountGuildMemberships").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAccountGuildMemberships {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAccountGuildMemberships {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildPersonaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildPersonaInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildPersonaInfo.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildPersonaInfo.guild_tag)
    pub guild_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGuildPersonaInfo.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildPersonaInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildPersonaInfo {
    fn default() -> &'a CMsgGuildPersonaInfo {
        <CMsgGuildPersonaInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildPersonaInfo {
    pub fn new() -> CMsgGuildPersonaInfo {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional string guild_tag = 2;

    pub fn guild_tag(&self) -> &str {
        match self.guild_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_tag(&mut self) {
        self.guild_tag = ::std::option::Option::None;
    }

    pub fn has_guild_tag(&self) -> bool {
        self.guild_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_tag(&mut self, v: ::std::string::String) {
        self.guild_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_tag(&mut self) -> &mut ::std::string::String {
        if self.guild_tag.is_none() {
            self.guild_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_tag(&mut self) -> ::std::string::String {
        self.guild_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 guild_flags = 3;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGuildPersonaInfo| { &m.guild_id },
            |m: &mut CMsgGuildPersonaInfo| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_tag",
            |m: &CMsgGuildPersonaInfo| { &m.guild_tag },
            |m: &mut CMsgGuildPersonaInfo| { &mut m.guild_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_flags",
            |m: &CMsgGuildPersonaInfo| { &m.guild_flags },
            |m: &mut CMsgGuildPersonaInfo| { &mut m.guild_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildPersonaInfo>(
            "CMsgGuildPersonaInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildPersonaInfo {
    const NAME: &'static str = "CMsgGuildPersonaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.guild_tag = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildPersonaInfo {
        CMsgGuildPersonaInfo::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_tag = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildPersonaInfo {
        static instance: CMsgGuildPersonaInfo = CMsgGuildPersonaInfo {
            guild_id: ::std::option::Option::None,
            guild_tag: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildPersonaInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildPersonaInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildPersonaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildPersonaInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAccountGuildsPersonaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildsPersonaInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildsPersonaInfo.guild_persona_infos)
    pub guild_persona_infos: ::std::vec::Vec<CMsgGuildPersonaInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAccountGuildsPersonaInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildsPersonaInfo {
    fn default() -> &'a CMsgAccountGuildsPersonaInfo {
        <CMsgAccountGuildsPersonaInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildsPersonaInfo {
    pub fn new() -> CMsgAccountGuildsPersonaInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_persona_infos",
            |m: &CMsgAccountGuildsPersonaInfo| { &m.guild_persona_infos },
            |m: &mut CMsgAccountGuildsPersonaInfo| { &mut m.guild_persona_infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAccountGuildsPersonaInfo>(
            "CMsgAccountGuildsPersonaInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAccountGuildsPersonaInfo {
    const NAME: &'static str = "CMsgAccountGuildsPersonaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guild_persona_infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.guild_persona_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.guild_persona_infos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildsPersonaInfo {
        CMsgAccountGuildsPersonaInfo::new()
    }

    fn clear(&mut self) {
        self.guild_persona_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildsPersonaInfo {
        static instance: CMsgAccountGuildsPersonaInfo = CMsgAccountGuildsPersonaInfo {
            guild_persona_infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAccountGuildsPersonaInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAccountGuildsPersonaInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAccountGuildsPersonaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAccountGuildsPersonaInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildFeedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildFeedEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildFeedEvent.feed_event_id)
    pub feed_event_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGuildFeedEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildFeedEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildFeedEvent.param_uint_1)
    pub param_uint_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildFeedEvent.param_uint_2)
    pub param_uint_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildFeedEvent.param_uint_3)
    pub param_uint_3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildFeedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildFeedEvent {
    fn default() -> &'a CMsgGuildFeedEvent {
        <CMsgGuildFeedEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildFeedEvent {
    pub fn new() -> CMsgGuildFeedEvent {
        ::std::default::Default::default()
    }

    // optional uint64 feed_event_id = 1;

    pub fn feed_event_id(&self) -> u64 {
        self.feed_event_id.unwrap_or(0)
    }

    pub fn clear_feed_event_id(&mut self) {
        self.feed_event_id = ::std::option::Option::None;
    }

    pub fn has_feed_event_id(&self) -> bool {
        self.feed_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed_event_id(&mut self, v: u64) {
        self.feed_event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 3;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 param_uint_1 = 4;

    pub fn param_uint_1(&self) -> u32 {
        self.param_uint_1.unwrap_or(0)
    }

    pub fn clear_param_uint_1(&mut self) {
        self.param_uint_1 = ::std::option::Option::None;
    }

    pub fn has_param_uint_1(&self) -> bool {
        self.param_uint_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_uint_1(&mut self, v: u32) {
        self.param_uint_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 param_uint_2 = 5;

    pub fn param_uint_2(&self) -> u32 {
        self.param_uint_2.unwrap_or(0)
    }

    pub fn clear_param_uint_2(&mut self) {
        self.param_uint_2 = ::std::option::Option::None;
    }

    pub fn has_param_uint_2(&self) -> bool {
        self.param_uint_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_uint_2(&mut self, v: u32) {
        self.param_uint_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 param_uint_3 = 6;

    pub fn param_uint_3(&self) -> u32 {
        self.param_uint_3.unwrap_or(0)
    }

    pub fn clear_param_uint_3(&mut self) {
        self.param_uint_3 = ::std::option::Option::None;
    }

    pub fn has_param_uint_3(&self) -> bool {
        self.param_uint_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_uint_3(&mut self, v: u32) {
        self.param_uint_3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "feed_event_id",
            |m: &CMsgGuildFeedEvent| { &m.feed_event_id },
            |m: &mut CMsgGuildFeedEvent| { &mut m.feed_event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgGuildFeedEvent| { &m.timestamp },
            |m: &mut CMsgGuildFeedEvent| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgGuildFeedEvent| { &m.event_type },
            |m: &mut CMsgGuildFeedEvent| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_uint_1",
            |m: &CMsgGuildFeedEvent| { &m.param_uint_1 },
            |m: &mut CMsgGuildFeedEvent| { &mut m.param_uint_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_uint_2",
            |m: &CMsgGuildFeedEvent| { &m.param_uint_2 },
            |m: &mut CMsgGuildFeedEvent| { &mut m.param_uint_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_uint_3",
            |m: &CMsgGuildFeedEvent| { &m.param_uint_3 },
            |m: &mut CMsgGuildFeedEvent| { &mut m.param_uint_3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildFeedEvent>(
            "CMsgGuildFeedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildFeedEvent {
    const NAME: &'static str = "CMsgGuildFeedEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.feed_event_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.param_uint_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.param_uint_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.param_uint_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.feed_event_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.param_uint_1 {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.param_uint_2 {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.param_uint_3 {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.feed_event_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.param_uint_1 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.param_uint_2 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.param_uint_3 {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildFeedEvent {
        CMsgGuildFeedEvent::new()
    }

    fn clear(&mut self) {
        self.feed_event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.param_uint_1 = ::std::option::Option::None;
        self.param_uint_2 = ::std::option::Option::None;
        self.param_uint_3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildFeedEvent {
        static instance: CMsgGuildFeedEvent = CMsgGuildFeedEvent {
            feed_event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            param_uint_1: ::std::option::Option::None,
            param_uint_2: ::std::option::Option::None,
            param_uint_3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildFeedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildFeedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildFeedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildFeedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCreateGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateGuild {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateGuild.guild_info)
    pub guild_info: ::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateGuild.guild_chat_type)
    pub guild_chat_type: ::std::option::Option<::protobuf::EnumOrUnknown<EGuildChatType>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateGuild.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateGuild {
    fn default() -> &'a CMsgClientToGCCreateGuild {
        <CMsgClientToGCCreateGuild as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateGuild {
    pub fn new() -> CMsgClientToGCCreateGuild {
        ::std::default::Default::default()
    }

    // optional .dota.EGuildChatType guild_chat_type = 2;

    pub fn guild_chat_type(&self) -> EGuildChatType {
        match self.guild_chat_type {
            Some(e) => e.enum_value_or(EGuildChatType::k_EGuildChatType_Unspecified),
            None => EGuildChatType::k_EGuildChatType_Unspecified,
        }
    }

    pub fn clear_guild_chat_type(&mut self) {
        self.guild_chat_type = ::std::option::Option::None;
    }

    pub fn has_guild_chat_type(&self) -> bool {
        self.guild_chat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_chat_type(&mut self, v: EGuildChatType) {
        self.guild_chat_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildInfo>(
            "guild_info",
            |m: &CMsgClientToGCCreateGuild| { &m.guild_info },
            |m: &mut CMsgClientToGCCreateGuild| { &mut m.guild_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_chat_type",
            |m: &CMsgClientToGCCreateGuild| { &m.guild_chat_type },
            |m: &mut CMsgClientToGCCreateGuild| { &mut m.guild_chat_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCreateGuild>(
            "CMsgClientToGCCreateGuild",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateGuild {
    const NAME: &'static str = "CMsgClientToGCCreateGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                16 => {
                    self.guild_chat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.guild_chat_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.guild_chat_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateGuild {
        CMsgClientToGCCreateGuild::new()
    }

    fn clear(&mut self) {
        self.guild_info.clear();
        self.guild_chat_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateGuild {
        static instance: CMsgClientToGCCreateGuild = CMsgClientToGCCreateGuild {
            guild_info: ::protobuf::MessageField::none(),
            guild_chat_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCreateGuild {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateGuild").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCreateGuild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateGuild {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCreateGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateGuildResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccreate_guild_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateGuildResponse.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateGuildResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateGuildResponse {
    fn default() -> &'a CMsgClientToGCCreateGuildResponse {
        <CMsgClientToGCCreateGuildResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateGuildResponse {
    pub fn new() -> CMsgClientToGCCreateGuildResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCreateGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gccreate_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccreate_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccreate_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccreate_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCCreateGuildResponse| { &m.result },
            |m: &mut CMsgClientToGCCreateGuildResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCCreateGuildResponse| { &m.guild_id },
            |m: &mut CMsgClientToGCCreateGuildResponse| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCreateGuildResponse>(
            "CMsgClientToGCCreateGuildResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateGuildResponse {
    const NAME: &'static str = "CMsgClientToGCCreateGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateGuildResponse {
        CMsgClientToGCCreateGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateGuildResponse {
        static instance: CMsgClientToGCCreateGuildResponse = CMsgClientToGCCreateGuildResponse {
            result: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCreateGuildResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateGuildResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCreateGuildResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateGuildResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCreateGuildResponse`
pub mod cmsg_client_to_gccreate_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCreateGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidName)
        k_eInvalidName = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eNameAlreadyUsed)
        k_eNameAlreadyUsed = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidTag)
        k_eInvalidTag = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eTagAlreadyUsed)
        k_eTagAlreadyUsed = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidDescription)
        k_eInvalidDescription = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidRegion)
        k_eInvalidRegion = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidLogo)
        k_eInvalidLogo = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eDoesNotOwnEvent)
        k_eDoesNotOwnEvent = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eGuildLimit)
        k_eGuildLimit = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidMotD)
        k_eInvalidMotD = 14,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateGuildResponse.EResponse.k_eBlocked)
        k_eBlocked = 15,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidName),
                6 => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                8 => ::std::option::Option::Some(EResponse::k_eTagAlreadyUsed),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidDescription),
                10 => ::std::option::Option::Some(EResponse::k_eInvalidRegion),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidLogo),
                12 => ::std::option::Option::Some(EResponse::k_eDoesNotOwnEvent),
                13 => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                14 => ::std::option::Option::Some(EResponse::k_eInvalidMotD),
                15 => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidName" => ::std::option::Option::Some(EResponse::k_eInvalidName),
                "k_eNameAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                "k_eInvalidTag" => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                "k_eTagAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eTagAlreadyUsed),
                "k_eInvalidDescription" => ::std::option::Option::Some(EResponse::k_eInvalidDescription),
                "k_eInvalidRegion" => ::std::option::Option::Some(EResponse::k_eInvalidRegion),
                "k_eInvalidLogo" => ::std::option::Option::Some(EResponse::k_eInvalidLogo),
                "k_eDoesNotOwnEvent" => ::std::option::Option::Some(EResponse::k_eDoesNotOwnEvent),
                "k_eGuildLimit" => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                "k_eInvalidMotD" => ::std::option::Option::Some(EResponse::k_eInvalidMotD),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidName,
            EResponse::k_eNameAlreadyUsed,
            EResponse::k_eInvalidTag,
            EResponse::k_eTagAlreadyUsed,
            EResponse::k_eInvalidDescription,
            EResponse::k_eInvalidRegion,
            EResponse::k_eInvalidLogo,
            EResponse::k_eDoesNotOwnEvent,
            EResponse::k_eGuildLimit,
            EResponse::k_eInvalidMotD,
            EResponse::k_eBlocked,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCreateGuildResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCreateGuildResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetGuildInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildInfo.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildInfo.guild_info)
    pub guild_info: ::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildInfo.guild_chat_type)
    pub guild_chat_type: ::std::option::Option<::protobuf::EnumOrUnknown<EGuildChatType>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetGuildInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildInfo {
    fn default() -> &'a CMsgClientToGCSetGuildInfo {
        <CMsgClientToGCSetGuildInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildInfo {
    pub fn new() -> CMsgClientToGCSetGuildInfo {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EGuildChatType guild_chat_type = 3;

    pub fn guild_chat_type(&self) -> EGuildChatType {
        match self.guild_chat_type {
            Some(e) => e.enum_value_or(EGuildChatType::k_EGuildChatType_Unspecified),
            None => EGuildChatType::k_EGuildChatType_Unspecified,
        }
    }

    pub fn clear_guild_chat_type(&mut self) {
        self.guild_chat_type = ::std::option::Option::None;
    }

    pub fn has_guild_chat_type(&self) -> bool {
        self.guild_chat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_chat_type(&mut self, v: EGuildChatType) {
        self.guild_chat_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCSetGuildInfo| { &m.guild_id },
            |m: &mut CMsgClientToGCSetGuildInfo| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildInfo>(
            "guild_info",
            |m: &CMsgClientToGCSetGuildInfo| { &m.guild_info },
            |m: &mut CMsgClientToGCSetGuildInfo| { &mut m.guild_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_chat_type",
            |m: &CMsgClientToGCSetGuildInfo| { &m.guild_chat_type },
            |m: &mut CMsgClientToGCSetGuildInfo| { &mut m.guild_chat_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetGuildInfo>(
            "CMsgClientToGCSetGuildInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetGuildInfo {
    const NAME: &'static str = "CMsgClientToGCSetGuildInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                24 => {
                    self.guild_chat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.guild_chat_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.guild_chat_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildInfo {
        CMsgClientToGCSetGuildInfo::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_info.clear();
        self.guild_chat_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildInfo {
        static instance: CMsgClientToGCSetGuildInfo = CMsgClientToGCSetGuildInfo {
            guild_id: ::std::option::Option::None,
            guild_info: ::protobuf::MessageField::none(),
            guild_chat_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetGuildInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetGuildInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetGuildInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetGuildInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetGuildInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildInfoResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcset_guild_info_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetGuildInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildInfoResponse {
    fn default() -> &'a CMsgClientToGCSetGuildInfoResponse {
        <CMsgClientToGCSetGuildInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildInfoResponse {
    pub fn new() -> CMsgClientToGCSetGuildInfoResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCSetGuildInfoResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_guild_info_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_guild_info_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_guild_info_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_guild_info_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCSetGuildInfoResponse| { &m.result },
            |m: &mut CMsgClientToGCSetGuildInfoResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetGuildInfoResponse>(
            "CMsgClientToGCSetGuildInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetGuildInfoResponse {
    const NAME: &'static str = "CMsgClientToGCSetGuildInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildInfoResponse {
        CMsgClientToGCSetGuildInfoResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildInfoResponse {
        static instance: CMsgClientToGCSetGuildInfoResponse = CMsgClientToGCSetGuildInfoResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetGuildInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetGuildInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetGuildInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetGuildInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCSetGuildInfoResponse`
pub mod cmsg_client_to_gcset_guild_info_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCSetGuildInfoResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eMotDTooLong)
        k_eMotDTooLong = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNameChangeNoPermissions)
        k_eNameChangeNoPermissions = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTagChangeNoPermissions)
        k_eTagChangeNoPermissions = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNameInvalid)
        k_eNameInvalid = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTagInvalid)
        k_eTagInvalid = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eDescriptionInvalid)
        k_eDescriptionInvalid = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildInfoResponse.EResponse.k_eBlocked)
        k_eBlocked = 14,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                8 => ::std::option::Option::Some(EResponse::k_eMotDTooLong),
                9 => ::std::option::Option::Some(EResponse::k_eNameChangeNoPermissions),
                10 => ::std::option::Option::Some(EResponse::k_eTagChangeNoPermissions),
                11 => ::std::option::Option::Some(EResponse::k_eNameInvalid),
                12 => ::std::option::Option::Some(EResponse::k_eTagInvalid),
                13 => ::std::option::Option::Some(EResponse::k_eDescriptionInvalid),
                14 => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eMotDTooLong" => ::std::option::Option::Some(EResponse::k_eMotDTooLong),
                "k_eNameChangeNoPermissions" => ::std::option::Option::Some(EResponse::k_eNameChangeNoPermissions),
                "k_eTagChangeNoPermissions" => ::std::option::Option::Some(EResponse::k_eTagChangeNoPermissions),
                "k_eNameInvalid" => ::std::option::Option::Some(EResponse::k_eNameInvalid),
                "k_eTagInvalid" => ::std::option::Option::Some(EResponse::k_eTagInvalid),
                "k_eDescriptionInvalid" => ::std::option::Option::Some(EResponse::k_eDescriptionInvalid),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eNoPermission,
            EResponse::k_eMotDTooLong,
            EResponse::k_eNameChangeNoPermissions,
            EResponse::k_eTagChangeNoPermissions,
            EResponse::k_eNameInvalid,
            EResponse::k_eTagInvalid,
            EResponse::k_eDescriptionInvalid,
            EResponse::k_eBlocked,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCSetGuildInfoResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCSetGuildInfoResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestGuildData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestGuildData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildData {
    fn default() -> &'a CMsgClientToGCRequestGuildData {
        <CMsgClientToGCRequestGuildData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildData {
    pub fn new() -> CMsgClientToGCRequestGuildData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCRequestGuildData| { &m.guild_id },
            |m: &mut CMsgClientToGCRequestGuildData| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestGuildData>(
            "CMsgClientToGCRequestGuildData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestGuildData {
    const NAME: &'static str = "CMsgClientToGCRequestGuildData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildData {
        CMsgClientToGCRequestGuildData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildData {
        static instance: CMsgClientToGCRequestGuildData = CMsgClientToGCRequestGuildData {
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestGuildData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestGuildData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestGuildData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestGuildData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestGuildDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildDataResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildDataResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_data_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildDataResponse.guild_data)
    pub guild_data: ::protobuf::MessageField<CMsgGuildData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestGuildDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildDataResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildDataResponse {
        <CMsgClientToGCRequestGuildDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildDataResponse {
    pub fn new() -> CMsgClientToGCRequestGuildDataResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestGuildDataResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_data_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_data_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestGuildDataResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestGuildDataResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildData>(
            "guild_data",
            |m: &CMsgClientToGCRequestGuildDataResponse| { &m.guild_data },
            |m: &mut CMsgClientToGCRequestGuildDataResponse| { &mut m.guild_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestGuildDataResponse>(
            "CMsgClientToGCRequestGuildDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestGuildDataResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildDataResponse {
        CMsgClientToGCRequestGuildDataResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildDataResponse {
        static instance: CMsgClientToGCRequestGuildDataResponse = CMsgClientToGCRequestGuildDataResponse {
            result: ::std::option::Option::None,
            guild_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestGuildDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestGuildDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestGuildDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestGuildDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildDataResponse`
pub mod cmsg_client_to_gcrequest_guild_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestGuildDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildDataResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildDataResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestGuildDataResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestGuildDataResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientGuildDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientGuildDataUpdated.guild_data)
    pub guild_data: ::protobuf::MessageField<CMsgGuildData>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientGuildDataUpdated.update_flags)
    pub update_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientGuildDataUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildDataUpdated {
    fn default() -> &'a CMsgGCToClientGuildDataUpdated {
        <CMsgGCToClientGuildDataUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildDataUpdated {
    pub fn new() -> CMsgGCToClientGuildDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 update_flags = 2;

    pub fn update_flags(&self) -> u32 {
        self.update_flags.unwrap_or(0)
    }

    pub fn clear_update_flags(&mut self) {
        self.update_flags = ::std::option::Option::None;
    }

    pub fn has_update_flags(&self) -> bool {
        self.update_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_flags(&mut self, v: u32) {
        self.update_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildData>(
            "guild_data",
            |m: &CMsgGCToClientGuildDataUpdated| { &m.guild_data },
            |m: &mut CMsgGCToClientGuildDataUpdated| { &mut m.guild_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_flags",
            |m: &CMsgGCToClientGuildDataUpdated| { &m.update_flags },
            |m: &mut CMsgGCToClientGuildDataUpdated| { &mut m.update_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientGuildDataUpdated>(
            "CMsgGCToClientGuildDataUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientGuildDataUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_data)?;
                },
                16 => {
                    self.update_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.update_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildDataUpdated {
        CMsgGCToClientGuildDataUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_data.clear();
        self.update_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildDataUpdated {
        static instance: CMsgGCToClientGuildDataUpdated = CMsgGCToClientGuildDataUpdated {
            guild_data: ::protobuf::MessageField::none(),
            update_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientGuildDataUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientGuildDataUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientGuildDataUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientGuildDataUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientGuildMembersDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildMembersDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientGuildMembersDataUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientGuildMembersDataUpdated.members_data)
    pub members_data: ::std::vec::Vec<CMsgGuildMember>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientGuildMembersDataUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildMembersDataUpdated {
    fn default() -> &'a CMsgGCToClientGuildMembersDataUpdated {
        <CMsgGCToClientGuildMembersDataUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildMembersDataUpdated {
    pub fn new() -> CMsgGCToClientGuildMembersDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGCToClientGuildMembersDataUpdated| { &m.guild_id },
            |m: &mut CMsgGCToClientGuildMembersDataUpdated| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members_data",
            |m: &CMsgGCToClientGuildMembersDataUpdated| { &m.members_data },
            |m: &mut CMsgGCToClientGuildMembersDataUpdated| { &mut m.members_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientGuildMembersDataUpdated>(
            "CMsgGCToClientGuildMembersDataUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientGuildMembersDataUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildMembersDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.members_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.members_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.members_data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildMembersDataUpdated {
        CMsgGCToClientGuildMembersDataUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.members_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildMembersDataUpdated {
        static instance: CMsgGCToClientGuildMembersDataUpdated = CMsgGCToClientGuildMembersDataUpdated {
            guild_id: ::std::option::Option::None,
            members_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientGuildMembersDataUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientGuildMembersDataUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientGuildMembersDataUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientGuildMembersDataUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestGuildMembership)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildMembership {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestGuildMembership.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildMembership {
    fn default() -> &'a CMsgClientToGCRequestGuildMembership {
        <CMsgClientToGCRequestGuildMembership as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildMembership {
    pub fn new() -> CMsgClientToGCRequestGuildMembership {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestGuildMembership>(
            "CMsgClientToGCRequestGuildMembership",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestGuildMembership {
    const NAME: &'static str = "CMsgClientToGCRequestGuildMembership";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildMembership {
        CMsgClientToGCRequestGuildMembership::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildMembership {
        static instance: CMsgClientToGCRequestGuildMembership = CMsgClientToGCRequestGuildMembership {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestGuildMembership {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestGuildMembership").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestGuildMembership {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestGuildMembership {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestGuildMembershipResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildMembershipResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildMembershipResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_membership_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildMembershipResponse.guild_memberships)
    pub guild_memberships: ::protobuf::MessageField<CMsgAccountGuildMemberships>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestGuildMembershipResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildMembershipResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildMembershipResponse {
        <CMsgClientToGCRequestGuildMembershipResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildMembershipResponse {
    pub fn new() -> CMsgClientToGCRequestGuildMembershipResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestGuildMembershipResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_membership_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_membership_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_membership_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_membership_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestGuildMembershipResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestGuildMembershipResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAccountGuildMemberships>(
            "guild_memberships",
            |m: &CMsgClientToGCRequestGuildMembershipResponse| { &m.guild_memberships },
            |m: &mut CMsgClientToGCRequestGuildMembershipResponse| { &mut m.guild_memberships },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestGuildMembershipResponse>(
            "CMsgClientToGCRequestGuildMembershipResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestGuildMembershipResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildMembershipResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_memberships)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_memberships.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_memberships.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildMembershipResponse {
        CMsgClientToGCRequestGuildMembershipResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_memberships.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildMembershipResponse {
        static instance: CMsgClientToGCRequestGuildMembershipResponse = CMsgClientToGCRequestGuildMembershipResponse {
            result: ::std::option::Option::None,
            guild_memberships: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestGuildMembershipResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestGuildMembershipResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestGuildMembershipResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestGuildMembershipResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildMembershipResponse`
pub mod cmsg_client_to_gcrequest_guild_membership_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestGuildMembershipResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestGuildMembershipResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestGuildMembershipResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientGuildMembershipUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildMembershipUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientGuildMembershipUpdated.guild_memberships)
    pub guild_memberships: ::protobuf::MessageField<CMsgAccountGuildMemberships>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientGuildMembershipUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildMembershipUpdated {
    fn default() -> &'a CMsgGCToClientGuildMembershipUpdated {
        <CMsgGCToClientGuildMembershipUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildMembershipUpdated {
    pub fn new() -> CMsgGCToClientGuildMembershipUpdated {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAccountGuildMemberships>(
            "guild_memberships",
            |m: &CMsgGCToClientGuildMembershipUpdated| { &m.guild_memberships },
            |m: &mut CMsgGCToClientGuildMembershipUpdated| { &mut m.guild_memberships },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientGuildMembershipUpdated>(
            "CMsgGCToClientGuildMembershipUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientGuildMembershipUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildMembershipUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_memberships)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_memberships.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_memberships.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildMembershipUpdated {
        CMsgGCToClientGuildMembershipUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_memberships.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildMembershipUpdated {
        static instance: CMsgGCToClientGuildMembershipUpdated = CMsgGCToClientGuildMembershipUpdated {
            guild_memberships: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientGuildMembershipUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientGuildMembershipUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientGuildMembershipUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientGuildMembershipUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCJoinGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinGuild {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCJoinGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCJoinGuild.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinGuild {
    fn default() -> &'a CMsgClientToGCJoinGuild {
        <CMsgClientToGCJoinGuild as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinGuild {
    pub fn new() -> CMsgClientToGCJoinGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCJoinGuild| { &m.guild_id },
            |m: &mut CMsgClientToGCJoinGuild| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCJoinGuild>(
            "CMsgClientToGCJoinGuild",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCJoinGuild {
    const NAME: &'static str = "CMsgClientToGCJoinGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinGuild {
        CMsgClientToGCJoinGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinGuild {
        static instance: CMsgClientToGCJoinGuild = CMsgClientToGCJoinGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCJoinGuild {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCJoinGuild").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCJoinGuild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCJoinGuild {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCJoinGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCJoinGuildResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcjoin_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCJoinGuildResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinGuildResponse {
    fn default() -> &'a CMsgClientToGCJoinGuildResponse {
        <CMsgClientToGCJoinGuildResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinGuildResponse {
    pub fn new() -> CMsgClientToGCJoinGuildResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCJoinGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcjoin_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcjoin_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcjoin_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcjoin_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCJoinGuildResponse| { &m.result },
            |m: &mut CMsgClientToGCJoinGuildResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCJoinGuildResponse>(
            "CMsgClientToGCJoinGuildResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCJoinGuildResponse {
    const NAME: &'static str = "CMsgClientToGCJoinGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinGuildResponse {
        CMsgClientToGCJoinGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinGuildResponse {
        static instance: CMsgClientToGCJoinGuildResponse = CMsgClientToGCJoinGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCJoinGuildResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCJoinGuildResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCJoinGuildResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCJoinGuildResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCJoinGuildResponse`
pub mod cmsg_client_to_gcjoin_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCJoinGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildFull)
        k_eGuildFull = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eAlreadyMember)
        k_eAlreadyMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildLimit)
        k_eGuildLimit = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildRequiresInvite)
        k_eGuildRequiresInvite = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildRankTooLow)
        k_eGuildRankTooLow = 10,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eGuildFull),
                7 => ::std::option::Option::Some(EResponse::k_eAlreadyMember),
                8 => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                9 => ::std::option::Option::Some(EResponse::k_eGuildRequiresInvite),
                10 => ::std::option::Option::Some(EResponse::k_eGuildRankTooLow),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eGuildFull" => ::std::option::Option::Some(EResponse::k_eGuildFull),
                "k_eAlreadyMember" => ::std::option::Option::Some(EResponse::k_eAlreadyMember),
                "k_eGuildLimit" => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                "k_eGuildRequiresInvite" => ::std::option::Option::Some(EResponse::k_eGuildRequiresInvite),
                "k_eGuildRankTooLow" => ::std::option::Option::Some(EResponse::k_eGuildRankTooLow),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eGuildFull,
            EResponse::k_eAlreadyMember,
            EResponse::k_eGuildLimit,
            EResponse::k_eGuildRequiresInvite,
            EResponse::k_eGuildRankTooLow,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCJoinGuildResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCJoinGuildResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCLeaveGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLeaveGuild {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCLeaveGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCLeaveGuild.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLeaveGuild {
    fn default() -> &'a CMsgClientToGCLeaveGuild {
        <CMsgClientToGCLeaveGuild as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLeaveGuild {
    pub fn new() -> CMsgClientToGCLeaveGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCLeaveGuild| { &m.guild_id },
            |m: &mut CMsgClientToGCLeaveGuild| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCLeaveGuild>(
            "CMsgClientToGCLeaveGuild",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCLeaveGuild {
    const NAME: &'static str = "CMsgClientToGCLeaveGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLeaveGuild {
        CMsgClientToGCLeaveGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLeaveGuild {
        static instance: CMsgClientToGCLeaveGuild = CMsgClientToGCLeaveGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCLeaveGuild {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCLeaveGuild").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCLeaveGuild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLeaveGuild {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCLeaveGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLeaveGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCLeaveGuildResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcleave_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCLeaveGuildResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLeaveGuildResponse {
    fn default() -> &'a CMsgClientToGCLeaveGuildResponse {
        <CMsgClientToGCLeaveGuildResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLeaveGuildResponse {
    pub fn new() -> CMsgClientToGCLeaveGuildResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCLeaveGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcleave_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcleave_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcleave_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcleave_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCLeaveGuildResponse| { &m.result },
            |m: &mut CMsgClientToGCLeaveGuildResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCLeaveGuildResponse>(
            "CMsgClientToGCLeaveGuildResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCLeaveGuildResponse {
    const NAME: &'static str = "CMsgClientToGCLeaveGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLeaveGuildResponse {
        CMsgClientToGCLeaveGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLeaveGuildResponse {
        static instance: CMsgClientToGCLeaveGuildResponse = CMsgClientToGCLeaveGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCLeaveGuildResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCLeaveGuildResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCLeaveGuildResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLeaveGuildResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCLeaveGuildResponse`
pub mod cmsg_client_to_gcleave_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCLeaveGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeaveGuildResponse.EResponse.k_eLastAdmin)
        k_eLastAdmin = 7,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eLastAdmin),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eLastAdmin" => ::std::option::Option::Some(EResponse::k_eLastAdmin),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eLastAdmin,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCLeaveGuildResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCLeaveGuildResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCKickGuildMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCKickGuildMember {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCKickGuildMember.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCKickGuildMember.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCKickGuildMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCKickGuildMember {
    fn default() -> &'a CMsgClientToGCKickGuildMember {
        <CMsgClientToGCKickGuildMember as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCKickGuildMember {
    pub fn new() -> CMsgClientToGCKickGuildMember {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCKickGuildMember| { &m.guild_id },
            |m: &mut CMsgClientToGCKickGuildMember| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_account_id",
            |m: &CMsgClientToGCKickGuildMember| { &m.target_account_id },
            |m: &mut CMsgClientToGCKickGuildMember| { &mut m.target_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCKickGuildMember>(
            "CMsgClientToGCKickGuildMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCKickGuildMember {
    const NAME: &'static str = "CMsgClientToGCKickGuildMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCKickGuildMember {
        CMsgClientToGCKickGuildMember::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCKickGuildMember {
        static instance: CMsgClientToGCKickGuildMember = CMsgClientToGCKickGuildMember {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCKickGuildMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCKickGuildMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCKickGuildMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCKickGuildMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCKickGuildMemberResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCKickGuildMemberResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCKickGuildMemberResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gckick_guild_member_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCKickGuildMemberResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCKickGuildMemberResponse {
    fn default() -> &'a CMsgClientToGCKickGuildMemberResponse {
        <CMsgClientToGCKickGuildMemberResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCKickGuildMemberResponse {
    pub fn new() -> CMsgClientToGCKickGuildMemberResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCKickGuildMemberResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gckick_guild_member_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gckick_guild_member_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gckick_guild_member_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gckick_guild_member_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCKickGuildMemberResponse| { &m.result },
            |m: &mut CMsgClientToGCKickGuildMemberResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCKickGuildMemberResponse>(
            "CMsgClientToGCKickGuildMemberResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCKickGuildMemberResponse {
    const NAME: &'static str = "CMsgClientToGCKickGuildMemberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCKickGuildMemberResponse {
        CMsgClientToGCKickGuildMemberResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCKickGuildMemberResponse {
        static instance: CMsgClientToGCKickGuildMemberResponse = CMsgClientToGCKickGuildMemberResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCKickGuildMemberResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCKickGuildMemberResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCKickGuildMemberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCKickGuildMemberResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCKickGuildMemberResponse`
pub mod cmsg_client_to_gckick_guild_member_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCKickGuildMemberResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eRequesterNotMember)
        k_eRequesterNotMember = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eTargetNotMember)
        k_eTargetNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCKickGuildMemberResponse.EResponse.k_eCantKickSelf)
        k_eCantKickSelf = 9,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                9 => ::std::option::Option::Some(EResponse::k_eCantKickSelf),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eRequesterNotMember" => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                "k_eTargetNotMember" => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eCantKickSelf" => ::std::option::Option::Some(EResponse::k_eCantKickSelf),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eRequesterNotMember,
            EResponse::k_eTargetNotMember,
            EResponse::k_eNoPermission,
            EResponse::k_eCantKickSelf,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCKickGuildMemberResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCKickGuildMemberResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetGuildMemberRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildMemberRole {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildMemberRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildMemberRole.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildMemberRole.target_role_id)
    pub target_role_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetGuildMemberRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildMemberRole {
    fn default() -> &'a CMsgClientToGCSetGuildMemberRole {
        <CMsgClientToGCSetGuildMemberRole as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildMemberRole {
    pub fn new() -> CMsgClientToGCSetGuildMemberRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_role_id = 3;

    pub fn target_role_id(&self) -> u32 {
        self.target_role_id.unwrap_or(0)
    }

    pub fn clear_target_role_id(&mut self) {
        self.target_role_id = ::std::option::Option::None;
    }

    pub fn has_target_role_id(&self) -> bool {
        self.target_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_role_id(&mut self, v: u32) {
        self.target_role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCSetGuildMemberRole| { &m.guild_id },
            |m: &mut CMsgClientToGCSetGuildMemberRole| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_account_id",
            |m: &CMsgClientToGCSetGuildMemberRole| { &m.target_account_id },
            |m: &mut CMsgClientToGCSetGuildMemberRole| { &mut m.target_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_role_id",
            |m: &CMsgClientToGCSetGuildMemberRole| { &m.target_role_id },
            |m: &mut CMsgClientToGCSetGuildMemberRole| { &mut m.target_role_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetGuildMemberRole>(
            "CMsgClientToGCSetGuildMemberRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetGuildMemberRole {
    const NAME: &'static str = "CMsgClientToGCSetGuildMemberRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.target_role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.target_role_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.target_role_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildMemberRole {
        CMsgClientToGCSetGuildMemberRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.target_role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildMemberRole {
        static instance: CMsgClientToGCSetGuildMemberRole = CMsgClientToGCSetGuildMemberRole {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            target_role_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetGuildMemberRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetGuildMemberRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetGuildMemberRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetGuildMemberRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetGuildMemberRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildMemberRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildMemberRoleResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcset_guild_member_role_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetGuildMemberRoleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildMemberRoleResponse {
    fn default() -> &'a CMsgClientToGCSetGuildMemberRoleResponse {
        <CMsgClientToGCSetGuildMemberRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildMemberRoleResponse {
    pub fn new() -> CMsgClientToGCSetGuildMemberRoleResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_guild_member_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_guild_member_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_guild_member_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_guild_member_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCSetGuildMemberRoleResponse| { &m.result },
            |m: &mut CMsgClientToGCSetGuildMemberRoleResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetGuildMemberRoleResponse>(
            "CMsgClientToGCSetGuildMemberRoleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetGuildMemberRoleResponse {
    const NAME: &'static str = "CMsgClientToGCSetGuildMemberRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildMemberRoleResponse {
        CMsgClientToGCSetGuildMemberRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildMemberRoleResponse {
        static instance: CMsgClientToGCSetGuildMemberRoleResponse = CMsgClientToGCSetGuildMemberRoleResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetGuildMemberRoleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetGuildMemberRoleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetGuildMemberRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetGuildMemberRoleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCSetGuildMemberRoleResponse`
pub mod cmsg_client_to_gcset_guild_member_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eRequesterNotMember)
        k_eRequesterNotMember = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eTargetNotMember)
        k_eTargetNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 10,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                10 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eRequesterNotMember" => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                "k_eTargetNotMember" => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eRequesterNotMember,
            EResponse::k_eTargetNotMember,
            EResponse::k_eNoPermission,
            EResponse::k_eInvalidRole,
            EResponse::k_eAdminViolation,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCSetGuildMemberRoleResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCSetGuildMemberRoleResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCInviteToGuild.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCInviteToGuild.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCInviteToGuild {
    fn default() -> &'a CMsgClientToGCInviteToGuild {
        <CMsgClientToGCInviteToGuild as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCInviteToGuild {
    pub fn new() -> CMsgClientToGCInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCInviteToGuild| { &m.guild_id },
            |m: &mut CMsgClientToGCInviteToGuild| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_account_id",
            |m: &CMsgClientToGCInviteToGuild| { &m.target_account_id },
            |m: &mut CMsgClientToGCInviteToGuild| { &mut m.target_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCInviteToGuild>(
            "CMsgClientToGCInviteToGuild",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCInviteToGuild {
        CMsgClientToGCInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCInviteToGuild {
        static instance: CMsgClientToGCInviteToGuild = CMsgClientToGCInviteToGuild {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCInviteToGuild {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCInviteToGuild").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCInviteToGuild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCInviteToGuild {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCInviteToGuildResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcinvite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCInviteToGuildResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCInviteToGuildResponse {
        <CMsgClientToGCInviteToGuildResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcinvite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcinvite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcinvite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcinvite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCInviteToGuildResponse| { &m.result },
            |m: &mut CMsgClientToGCInviteToGuildResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCInviteToGuildResponse>(
            "CMsgClientToGCInviteToGuildResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCInviteToGuildResponse {
        CMsgClientToGCInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCInviteToGuildResponse {
        static instance: CMsgClientToGCInviteToGuildResponse = CMsgClientToGCInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCInviteToGuildResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCInviteToGuildResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCInviteToGuildResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCInviteToGuildResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCInviteToGuildResponse`
pub mod cmsg_client_to_gcinvite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eGuildFull)
        k_eGuildFull = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eRequesterNotMember)
        k_eRequesterNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eAlreadyAMember)
        k_eAlreadyAMember = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eAlreadyInvited)
        k_eAlreadyInvited = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eNoInvitePermissions)
        k_eNoInvitePermissions = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eTooManyInvites)
        k_eTooManyInvites = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCInviteToGuildResponse.EResponse.k_eInvalidUser)
        k_eInvalidUser = 12,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eGuildFull),
                7 => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eAlreadyAMember),
                9 => ::std::option::Option::Some(EResponse::k_eAlreadyInvited),
                10 => ::std::option::Option::Some(EResponse::k_eNoInvitePermissions),
                11 => ::std::option::Option::Some(EResponse::k_eTooManyInvites),
                12 => ::std::option::Option::Some(EResponse::k_eInvalidUser),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eGuildFull" => ::std::option::Option::Some(EResponse::k_eGuildFull),
                "k_eRequesterNotMember" => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                "k_eAlreadyAMember" => ::std::option::Option::Some(EResponse::k_eAlreadyAMember),
                "k_eAlreadyInvited" => ::std::option::Option::Some(EResponse::k_eAlreadyInvited),
                "k_eNoInvitePermissions" => ::std::option::Option::Some(EResponse::k_eNoInvitePermissions),
                "k_eTooManyInvites" => ::std::option::Option::Some(EResponse::k_eTooManyInvites),
                "k_eInvalidUser" => ::std::option::Option::Some(EResponse::k_eInvalidUser),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eGuildFull,
            EResponse::k_eRequesterNotMember,
            EResponse::k_eAlreadyAMember,
            EResponse::k_eAlreadyInvited,
            EResponse::k_eNoInvitePermissions,
            EResponse::k_eTooManyInvites,
            EResponse::k_eInvalidUser,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCInviteToGuildResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCInviteToGuildResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCDeclineInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDeclineInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCDeclineInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCDeclineInviteToGuild.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDeclineInviteToGuild {
    fn default() -> &'a CMsgClientToGCDeclineInviteToGuild {
        <CMsgClientToGCDeclineInviteToGuild as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDeclineInviteToGuild {
    pub fn new() -> CMsgClientToGCDeclineInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCDeclineInviteToGuild| { &m.guild_id },
            |m: &mut CMsgClientToGCDeclineInviteToGuild| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCDeclineInviteToGuild>(
            "CMsgClientToGCDeclineInviteToGuild",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCDeclineInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCDeclineInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDeclineInviteToGuild {
        CMsgClientToGCDeclineInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDeclineInviteToGuild {
        static instance: CMsgClientToGCDeclineInviteToGuild = CMsgClientToGCDeclineInviteToGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCDeclineInviteToGuild {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCDeclineInviteToGuild").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCDeclineInviteToGuild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCDeclineInviteToGuild {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCDeclineInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDeclineInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCDeclineInviteToGuildResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcdecline_invite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCDeclineInviteToGuildResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDeclineInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCDeclineInviteToGuildResponse {
        <CMsgClientToGCDeclineInviteToGuildResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDeclineInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCDeclineInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcdecline_invite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcdecline_invite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcdecline_invite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcdecline_invite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCDeclineInviteToGuildResponse| { &m.result },
            |m: &mut CMsgClientToGCDeclineInviteToGuildResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCDeclineInviteToGuildResponse>(
            "CMsgClientToGCDeclineInviteToGuildResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCDeclineInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCDeclineInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDeclineInviteToGuildResponse {
        CMsgClientToGCDeclineInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDeclineInviteToGuildResponse {
        static instance: CMsgClientToGCDeclineInviteToGuildResponse = CMsgClientToGCDeclineInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCDeclineInviteToGuildResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCDeclineInviteToGuildResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCDeclineInviteToGuildResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCDeclineInviteToGuildResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCDeclineInviteToGuildResponse`
pub mod cmsg_client_to_gcdecline_invite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eNoInviteFound)
        k_eNoInviteFound = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoInviteFound" => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoInviteFound,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCDeclineInviteToGuildResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCDeclineInviteToGuildResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAcceptInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcceptInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcceptInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAcceptInviteToGuild.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcceptInviteToGuild {
    fn default() -> &'a CMsgClientToGCAcceptInviteToGuild {
        <CMsgClientToGCAcceptInviteToGuild as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcceptInviteToGuild {
    pub fn new() -> CMsgClientToGCAcceptInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCAcceptInviteToGuild| { &m.guild_id },
            |m: &mut CMsgClientToGCAcceptInviteToGuild| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAcceptInviteToGuild>(
            "CMsgClientToGCAcceptInviteToGuild",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAcceptInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCAcceptInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcceptInviteToGuild {
        CMsgClientToGCAcceptInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcceptInviteToGuild {
        static instance: CMsgClientToGCAcceptInviteToGuild = CMsgClientToGCAcceptInviteToGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAcceptInviteToGuild {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAcceptInviteToGuild").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAcceptInviteToGuild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAcceptInviteToGuild {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAcceptInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcceptInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcceptInviteToGuildResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcaccept_invite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAcceptInviteToGuildResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcceptInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCAcceptInviteToGuildResponse {
        <CMsgClientToGCAcceptInviteToGuildResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcceptInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCAcceptInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcaccept_invite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcaccept_invite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcaccept_invite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcaccept_invite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCAcceptInviteToGuildResponse| { &m.result },
            |m: &mut CMsgClientToGCAcceptInviteToGuildResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAcceptInviteToGuildResponse>(
            "CMsgClientToGCAcceptInviteToGuildResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAcceptInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCAcceptInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcceptInviteToGuildResponse {
        CMsgClientToGCAcceptInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcceptInviteToGuildResponse {
        static instance: CMsgClientToGCAcceptInviteToGuildResponse = CMsgClientToGCAcceptInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAcceptInviteToGuildResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAcceptInviteToGuildResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAcceptInviteToGuildResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAcceptInviteToGuildResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCAcceptInviteToGuildResponse`
pub mod cmsg_client_to_gcaccept_invite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eNoInviteFound)
        k_eNoInviteFound = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eGuildFull)
        k_eGuildFull = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eGuildLimit)
        k_eGuildLimit = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eInvalidInviter)
        k_eInvalidInviter = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eAlreadyInGuild)
        k_eAlreadyInGuild = 10,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                7 => ::std::option::Option::Some(EResponse::k_eGuildFull),
                8 => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidInviter),
                10 => ::std::option::Option::Some(EResponse::k_eAlreadyInGuild),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoInviteFound" => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                "k_eGuildFull" => ::std::option::Option::Some(EResponse::k_eGuildFull),
                "k_eGuildLimit" => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                "k_eInvalidInviter" => ::std::option::Option::Some(EResponse::k_eInvalidInviter),
                "k_eAlreadyInGuild" => ::std::option::Option::Some(EResponse::k_eAlreadyInGuild),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoInviteFound,
            EResponse::k_eGuildFull,
            EResponse::k_eGuildLimit,
            EResponse::k_eInvalidInviter,
            EResponse::k_eAlreadyInGuild,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCAcceptInviteToGuildResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCAcceptInviteToGuildResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCancelInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCancelInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCancelInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCancelInviteToGuild.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCancelInviteToGuild.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCancelInviteToGuild {
    fn default() -> &'a CMsgClientToGCCancelInviteToGuild {
        <CMsgClientToGCCancelInviteToGuild as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCancelInviteToGuild {
    pub fn new() -> CMsgClientToGCCancelInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCCancelInviteToGuild| { &m.guild_id },
            |m: &mut CMsgClientToGCCancelInviteToGuild| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_account_id",
            |m: &CMsgClientToGCCancelInviteToGuild| { &m.target_account_id },
            |m: &mut CMsgClientToGCCancelInviteToGuild| { &mut m.target_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCancelInviteToGuild>(
            "CMsgClientToGCCancelInviteToGuild",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCancelInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCCancelInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCancelInviteToGuild {
        CMsgClientToGCCancelInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCancelInviteToGuild {
        static instance: CMsgClientToGCCancelInviteToGuild = CMsgClientToGCCancelInviteToGuild {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCancelInviteToGuild {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCancelInviteToGuild").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCancelInviteToGuild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCancelInviteToGuild {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCancelInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCancelInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCancelInviteToGuildResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccancel_invite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCancelInviteToGuildResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCancelInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCCancelInviteToGuildResponse {
        <CMsgClientToGCCancelInviteToGuildResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCancelInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCCancelInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gccancel_invite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccancel_invite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccancel_invite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccancel_invite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCCancelInviteToGuildResponse| { &m.result },
            |m: &mut CMsgClientToGCCancelInviteToGuildResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCancelInviteToGuildResponse>(
            "CMsgClientToGCCancelInviteToGuildResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCancelInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCCancelInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCancelInviteToGuildResponse {
        CMsgClientToGCCancelInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCancelInviteToGuildResponse {
        static instance: CMsgClientToGCCancelInviteToGuildResponse = CMsgClientToGCCancelInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCancelInviteToGuildResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCancelInviteToGuildResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCancelInviteToGuildResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCancelInviteToGuildResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCancelInviteToGuildResponse`
pub mod cmsg_client_to_gccancel_invite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eNoInviteFound)
        k_eNoInviteFound = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 7,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                7 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoInviteFound" => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoInviteFound,
            EResponse::k_eNoPermissions,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCancelInviteToGuildResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCancelInviteToGuildResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAddGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddGuildRole {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAddGuildRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAddGuildRole.role_name)
    pub role_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAddGuildRole.role_flags)
    pub role_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAddGuildRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddGuildRole {
    fn default() -> &'a CMsgClientToGCAddGuildRole {
        <CMsgClientToGCAddGuildRole as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddGuildRole {
    pub fn new() -> CMsgClientToGCAddGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional string role_name = 2;

    pub fn role_name(&self) -> &str {
        match self.role_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_role_name(&mut self) {
        self.role_name = ::std::option::Option::None;
    }

    pub fn has_role_name(&self) -> bool {
        self.role_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_name(&mut self, v: ::std::string::String) {
        self.role_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_name(&mut self) -> &mut ::std::string::String {
        if self.role_name.is_none() {
            self.role_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.role_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_name(&mut self) -> ::std::string::String {
        self.role_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 role_flags = 3;

    pub fn role_flags(&self) -> u32 {
        self.role_flags.unwrap_or(0)
    }

    pub fn clear_role_flags(&mut self) {
        self.role_flags = ::std::option::Option::None;
    }

    pub fn has_role_flags(&self) -> bool {
        self.role_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_flags(&mut self, v: u32) {
        self.role_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCAddGuildRole| { &m.guild_id },
            |m: &mut CMsgClientToGCAddGuildRole| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_name",
            |m: &CMsgClientToGCAddGuildRole| { &m.role_name },
            |m: &mut CMsgClientToGCAddGuildRole| { &mut m.role_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_flags",
            |m: &CMsgClientToGCAddGuildRole| { &m.role_flags },
            |m: &mut CMsgClientToGCAddGuildRole| { &mut m.role_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAddGuildRole>(
            "CMsgClientToGCAddGuildRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAddGuildRole {
    const NAME: &'static str = "CMsgClientToGCAddGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.role_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.role_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.role_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.role_flags {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddGuildRole {
        CMsgClientToGCAddGuildRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.role_name = ::std::option::Option::None;
        self.role_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddGuildRole {
        static instance: CMsgClientToGCAddGuildRole = CMsgClientToGCAddGuildRole {
            guild_id: ::std::option::Option::None,
            role_name: ::std::option::Option::None,
            role_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAddGuildRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAddGuildRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAddGuildRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAddGuildRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAddGuildRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddGuildRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAddGuildRoleResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcadd_guild_role_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAddGuildRoleResponse.role_id)
    pub role_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAddGuildRoleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddGuildRoleResponse {
    fn default() -> &'a CMsgClientToGCAddGuildRoleResponse {
        <CMsgClientToGCAddGuildRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddGuildRoleResponse {
    pub fn new() -> CMsgClientToGCAddGuildRoleResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCAddGuildRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcadd_guild_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcadd_guild_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcadd_guild_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcadd_guild_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 role_id = 2;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCAddGuildRoleResponse| { &m.result },
            |m: &mut CMsgClientToGCAddGuildRoleResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CMsgClientToGCAddGuildRoleResponse| { &m.role_id },
            |m: &mut CMsgClientToGCAddGuildRoleResponse| { &mut m.role_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAddGuildRoleResponse>(
            "CMsgClientToGCAddGuildRoleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAddGuildRoleResponse {
    const NAME: &'static str = "CMsgClientToGCAddGuildRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.role_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddGuildRoleResponse {
        CMsgClientToGCAddGuildRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddGuildRoleResponse {
        static instance: CMsgClientToGCAddGuildRoleResponse = CMsgClientToGCAddGuildRoleResponse {
            result: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAddGuildRoleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAddGuildRoleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAddGuildRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAddGuildRoleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCAddGuildRoleResponse`
pub mod cmsg_client_to_gcadd_guild_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCAddGuildRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eNameAlreadyUsed)
        k_eNameAlreadyUsed = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInvalidFlags)
        k_eInvalidFlags = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInvalidName)
        k_eInvalidName = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eTooManyRoles)
        k_eTooManyRoles = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddGuildRoleResponse.EResponse.k_eBlocked)
        k_eBlocked = 12,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                7 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidName),
                10 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                11 => ::std::option::Option::Some(EResponse::k_eTooManyRoles),
                12 => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNameAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eInvalidFlags" => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                "k_eInvalidName" => ::std::option::Option::Some(EResponse::k_eInvalidName),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                "k_eTooManyRoles" => ::std::option::Option::Some(EResponse::k_eTooManyRoles),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNameAlreadyUsed,
            EResponse::k_eNoPermissions,
            EResponse::k_eInvalidFlags,
            EResponse::k_eInvalidName,
            EResponse::k_eAdminViolation,
            EResponse::k_eTooManyRoles,
            EResponse::k_eBlocked,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCAddGuildRoleResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCAddGuildRoleResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCModifyGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCModifyGuildRole {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCModifyGuildRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCModifyGuildRole.role_id)
    pub role_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCModifyGuildRole.role_name)
    pub role_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCModifyGuildRole.role_flags)
    pub role_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCModifyGuildRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCModifyGuildRole {
    fn default() -> &'a CMsgClientToGCModifyGuildRole {
        <CMsgClientToGCModifyGuildRole as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCModifyGuildRole {
    pub fn new() -> CMsgClientToGCModifyGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 role_id = 2;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string role_name = 3;

    pub fn role_name(&self) -> &str {
        match self.role_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_role_name(&mut self) {
        self.role_name = ::std::option::Option::None;
    }

    pub fn has_role_name(&self) -> bool {
        self.role_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_name(&mut self, v: ::std::string::String) {
        self.role_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_name(&mut self) -> &mut ::std::string::String {
        if self.role_name.is_none() {
            self.role_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.role_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_name(&mut self) -> ::std::string::String {
        self.role_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 role_flags = 4;

    pub fn role_flags(&self) -> u32 {
        self.role_flags.unwrap_or(0)
    }

    pub fn clear_role_flags(&mut self) {
        self.role_flags = ::std::option::Option::None;
    }

    pub fn has_role_flags(&self) -> bool {
        self.role_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_flags(&mut self, v: u32) {
        self.role_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCModifyGuildRole| { &m.guild_id },
            |m: &mut CMsgClientToGCModifyGuildRole| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CMsgClientToGCModifyGuildRole| { &m.role_id },
            |m: &mut CMsgClientToGCModifyGuildRole| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_name",
            |m: &CMsgClientToGCModifyGuildRole| { &m.role_name },
            |m: &mut CMsgClientToGCModifyGuildRole| { &mut m.role_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_flags",
            |m: &CMsgClientToGCModifyGuildRole| { &m.role_flags },
            |m: &mut CMsgClientToGCModifyGuildRole| { &mut m.role_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCModifyGuildRole>(
            "CMsgClientToGCModifyGuildRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCModifyGuildRole {
    const NAME: &'static str = "CMsgClientToGCModifyGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.role_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.role_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.role_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.role_flags {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.role_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.role_flags {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCModifyGuildRole {
        CMsgClientToGCModifyGuildRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.role_name = ::std::option::Option::None;
        self.role_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCModifyGuildRole {
        static instance: CMsgClientToGCModifyGuildRole = CMsgClientToGCModifyGuildRole {
            guild_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            role_name: ::std::option::Option::None,
            role_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCModifyGuildRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCModifyGuildRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCModifyGuildRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCModifyGuildRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCModifyGuildRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCModifyGuildRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCModifyGuildRoleResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcmodify_guild_role_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCModifyGuildRoleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCModifyGuildRoleResponse {
    fn default() -> &'a CMsgClientToGCModifyGuildRoleResponse {
        <CMsgClientToGCModifyGuildRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCModifyGuildRoleResponse {
    pub fn new() -> CMsgClientToGCModifyGuildRoleResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCModifyGuildRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcmodify_guild_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcmodify_guild_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcmodify_guild_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcmodify_guild_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCModifyGuildRoleResponse| { &m.result },
            |m: &mut CMsgClientToGCModifyGuildRoleResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCModifyGuildRoleResponse>(
            "CMsgClientToGCModifyGuildRoleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCModifyGuildRoleResponse {
    const NAME: &'static str = "CMsgClientToGCModifyGuildRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCModifyGuildRoleResponse {
        CMsgClientToGCModifyGuildRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCModifyGuildRoleResponse {
        static instance: CMsgClientToGCModifyGuildRoleResponse = CMsgClientToGCModifyGuildRoleResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCModifyGuildRoleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCModifyGuildRoleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCModifyGuildRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCModifyGuildRoleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCModifyGuildRoleResponse`
pub mod cmsg_client_to_gcmodify_guild_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eNameAlreadyUsed)
        k_eNameAlreadyUsed = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidFlags)
        k_eInvalidFlags = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidName)
        k_eInvalidName = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eBlocked)
        k_eBlocked = 12,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                7 => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidName),
                10 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                11 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                12 => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eNameAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                "k_eInvalidFlags" => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                "k_eInvalidName" => ::std::option::Option::Some(EResponse::k_eInvalidName),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eInvalidRole,
            EResponse::k_eNameAlreadyUsed,
            EResponse::k_eInvalidFlags,
            EResponse::k_eInvalidName,
            EResponse::k_eNoPermissions,
            EResponse::k_eAdminViolation,
            EResponse::k_eBlocked,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCModifyGuildRoleResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCModifyGuildRoleResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRemoveGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveGuildRole {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRemoveGuildRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRemoveGuildRole.role_id)
    pub role_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRemoveGuildRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveGuildRole {
    fn default() -> &'a CMsgClientToGCRemoveGuildRole {
        <CMsgClientToGCRemoveGuildRole as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveGuildRole {
    pub fn new() -> CMsgClientToGCRemoveGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 role_id = 2;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCRemoveGuildRole| { &m.guild_id },
            |m: &mut CMsgClientToGCRemoveGuildRole| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CMsgClientToGCRemoveGuildRole| { &m.role_id },
            |m: &mut CMsgClientToGCRemoveGuildRole| { &mut m.role_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRemoveGuildRole>(
            "CMsgClientToGCRemoveGuildRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRemoveGuildRole {
    const NAME: &'static str = "CMsgClientToGCRemoveGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveGuildRole {
        CMsgClientToGCRemoveGuildRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveGuildRole {
        static instance: CMsgClientToGCRemoveGuildRole = CMsgClientToGCRemoveGuildRole {
            guild_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRemoveGuildRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRemoveGuildRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRemoveGuildRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRemoveGuildRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRemoveGuildRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveGuildRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRemoveGuildRoleResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcremove_guild_role_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRemoveGuildRoleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveGuildRoleResponse {
    fn default() -> &'a CMsgClientToGCRemoveGuildRoleResponse {
        <CMsgClientToGCRemoveGuildRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveGuildRoleResponse {
    pub fn new() -> CMsgClientToGCRemoveGuildRoleResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcremove_guild_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcremove_guild_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcremove_guild_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcremove_guild_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRemoveGuildRoleResponse| { &m.result },
            |m: &mut CMsgClientToGCRemoveGuildRoleResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRemoveGuildRoleResponse>(
            "CMsgClientToGCRemoveGuildRoleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRemoveGuildRoleResponse {
    const NAME: &'static str = "CMsgClientToGCRemoveGuildRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveGuildRoleResponse {
        CMsgClientToGCRemoveGuildRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveGuildRoleResponse {
        static instance: CMsgClientToGCRemoveGuildRoleResponse = CMsgClientToGCRemoveGuildRoleResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRemoveGuildRoleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRemoveGuildRoleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRemoveGuildRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRemoveGuildRoleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRemoveGuildRoleResponse`
pub mod cmsg_client_to_gcremove_guild_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eRoleNotEmpty)
        k_eRoleNotEmpty = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eCantRemoveDefaultRole)
        k_eCantRemoveDefaultRole = 10,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                7 => ::std::option::Option::Some(EResponse::k_eRoleNotEmpty),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                9 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                10 => ::std::option::Option::Some(EResponse::k_eCantRemoveDefaultRole),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eRoleNotEmpty" => ::std::option::Option::Some(EResponse::k_eRoleNotEmpty),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                "k_eCantRemoveDefaultRole" => ::std::option::Option::Some(EResponse::k_eCantRemoveDefaultRole),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eInvalidRole,
            EResponse::k_eRoleNotEmpty,
            EResponse::k_eNoPermissions,
            EResponse::k_eAdminViolation,
            EResponse::k_eCantRemoveDefaultRole,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRemoveGuildRoleResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRemoveGuildRoleResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetGuildRoleOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildRoleOrder {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildRoleOrder.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildRoleOrder.requested_role_ids)
    pub requested_role_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildRoleOrder.previous_role_ids)
    pub previous_role_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetGuildRoleOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildRoleOrder {
    fn default() -> &'a CMsgClientToGCSetGuildRoleOrder {
        <CMsgClientToGCSetGuildRoleOrder as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildRoleOrder {
    pub fn new() -> CMsgClientToGCSetGuildRoleOrder {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCSetGuildRoleOrder| { &m.guild_id },
            |m: &mut CMsgClientToGCSetGuildRoleOrder| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requested_role_ids",
            |m: &CMsgClientToGCSetGuildRoleOrder| { &m.requested_role_ids },
            |m: &mut CMsgClientToGCSetGuildRoleOrder| { &mut m.requested_role_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previous_role_ids",
            |m: &CMsgClientToGCSetGuildRoleOrder| { &m.previous_role_ids },
            |m: &mut CMsgClientToGCSetGuildRoleOrder| { &mut m.previous_role_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetGuildRoleOrder>(
            "CMsgClientToGCSetGuildRoleOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetGuildRoleOrder {
    const NAME: &'static str = "CMsgClientToGCSetGuildRoleOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.requested_role_ids)?;
                },
                16 => {
                    self.requested_role_ids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.previous_role_ids)?;
                },
                24 => {
                    self.previous_role_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.requested_role_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.previous_role_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.requested_role_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.previous_role_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildRoleOrder {
        CMsgClientToGCSetGuildRoleOrder::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.requested_role_ids.clear();
        self.previous_role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildRoleOrder {
        static instance: CMsgClientToGCSetGuildRoleOrder = CMsgClientToGCSetGuildRoleOrder {
            guild_id: ::std::option::Option::None,
            requested_role_ids: ::std::vec::Vec::new(),
            previous_role_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetGuildRoleOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetGuildRoleOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetGuildRoleOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetGuildRoleOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetGuildRoleOrderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildRoleOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildRoleOrderResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcset_guild_role_order_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetGuildRoleOrderResponse.confirmed_role_ids)
    pub confirmed_role_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetGuildRoleOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildRoleOrderResponse {
    fn default() -> &'a CMsgClientToGCSetGuildRoleOrderResponse {
        <CMsgClientToGCSetGuildRoleOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildRoleOrderResponse {
    pub fn new() -> CMsgClientToGCSetGuildRoleOrderResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_guild_role_order_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_guild_role_order_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_guild_role_order_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_guild_role_order_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCSetGuildRoleOrderResponse| { &m.result },
            |m: &mut CMsgClientToGCSetGuildRoleOrderResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "confirmed_role_ids",
            |m: &CMsgClientToGCSetGuildRoleOrderResponse| { &m.confirmed_role_ids },
            |m: &mut CMsgClientToGCSetGuildRoleOrderResponse| { &mut m.confirmed_role_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetGuildRoleOrderResponse>(
            "CMsgClientToGCSetGuildRoleOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetGuildRoleOrderResponse {
    const NAME: &'static str = "CMsgClientToGCSetGuildRoleOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.confirmed_role_ids)?;
                },
                16 => {
                    self.confirmed_role_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.confirmed_role_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.confirmed_role_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildRoleOrderResponse {
        CMsgClientToGCSetGuildRoleOrderResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.confirmed_role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildRoleOrderResponse {
        static instance: CMsgClientToGCSetGuildRoleOrderResponse = CMsgClientToGCSetGuildRoleOrderResponse {
            result: ::std::option::Option::None,
            confirmed_role_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetGuildRoleOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetGuildRoleOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetGuildRoleOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetGuildRoleOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCSetGuildRoleOrderResponse`
pub mod cmsg_client_to_gcset_guild_role_order_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInvalidOrder)
        k_eInvalidOrder = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 9,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidOrder),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                9 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eInvalidOrder" => ::std::option::Option::Some(EResponse::k_eInvalidOrder),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eInvalidRole,
            EResponse::k_eInvalidOrder,
            EResponse::k_eNoPermissions,
            EResponse::k_eAdminViolation,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCSetGuildRoleOrderResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCSetGuildRoleOrderResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGuildFeedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGuildFeedRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGuildFeedRequest.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGuildFeedRequest.last_seen_id)
    pub last_seen_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGuildFeedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGuildFeedRequest {
    fn default() -> &'a CMsgClientToGCGuildFeedRequest {
        <CMsgClientToGCGuildFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGuildFeedRequest {
    pub fn new() -> CMsgClientToGCGuildFeedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint64 last_seen_id = 2;

    pub fn last_seen_id(&self) -> u64 {
        self.last_seen_id.unwrap_or(0)
    }

    pub fn clear_last_seen_id(&mut self) {
        self.last_seen_id = ::std::option::Option::None;
    }

    pub fn has_last_seen_id(&self) -> bool {
        self.last_seen_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_seen_id(&mut self, v: u64) {
        self.last_seen_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCGuildFeedRequest| { &m.guild_id },
            |m: &mut CMsgClientToGCGuildFeedRequest| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_seen_id",
            |m: &CMsgClientToGCGuildFeedRequest| { &m.last_seen_id },
            |m: &mut CMsgClientToGCGuildFeedRequest| { &mut m.last_seen_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGuildFeedRequest>(
            "CMsgClientToGCGuildFeedRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGuildFeedRequest {
    const NAME: &'static str = "CMsgClientToGCGuildFeedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_seen_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_seen_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_seen_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGuildFeedRequest {
        CMsgClientToGCGuildFeedRequest::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.last_seen_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGuildFeedRequest {
        static instance: CMsgClientToGCGuildFeedRequest = CMsgClientToGCGuildFeedRequest {
            guild_id: ::std::option::Option::None,
            last_seen_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGuildFeedRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGuildFeedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGuildFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGuildFeedRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestGuildFeedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildFeedResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildFeedResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_feed_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildFeedResponse.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildFeedResponse.feed_events)
    pub feed_events: ::std::vec::Vec<CMsgGuildFeedEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestGuildFeedResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildFeedResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildFeedResponse {
        <CMsgClientToGCRequestGuildFeedResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildFeedResponse {
    pub fn new() -> CMsgClientToGCRequestGuildFeedResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestGuildFeedResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_feed_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_feed_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_feed_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_feed_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestGuildFeedResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestGuildFeedResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCRequestGuildFeedResponse| { &m.guild_id },
            |m: &mut CMsgClientToGCRequestGuildFeedResponse| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "feed_events",
            |m: &CMsgClientToGCRequestGuildFeedResponse| { &m.feed_events },
            |m: &mut CMsgClientToGCRequestGuildFeedResponse| { &mut m.feed_events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestGuildFeedResponse>(
            "CMsgClientToGCRequestGuildFeedResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestGuildFeedResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildFeedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.feed_events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.feed_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.feed_events {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildFeedResponse {
        CMsgClientToGCRequestGuildFeedResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.feed_events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildFeedResponse {
        static instance: CMsgClientToGCRequestGuildFeedResponse = CMsgClientToGCRequestGuildFeedResponse {
            result: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            feed_events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestGuildFeedResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestGuildFeedResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestGuildFeedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestGuildFeedResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildFeedResponse`
pub mod cmsg_client_to_gcrequest_guild_feed_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoPermissions,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestGuildFeedResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestGuildFeedResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientGuildFeedUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildFeedUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientGuildFeedUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientGuildFeedUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildFeedUpdated {
    fn default() -> &'a CMsgGCToClientGuildFeedUpdated {
        <CMsgGCToClientGuildFeedUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildFeedUpdated {
    pub fn new() -> CMsgGCToClientGuildFeedUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGCToClientGuildFeedUpdated| { &m.guild_id },
            |m: &mut CMsgGCToClientGuildFeedUpdated| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientGuildFeedUpdated>(
            "CMsgGCToClientGuildFeedUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientGuildFeedUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildFeedUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildFeedUpdated {
        CMsgGCToClientGuildFeedUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildFeedUpdated {
        static instance: CMsgGCToClientGuildFeedUpdated = CMsgGCToClientGuildFeedUpdated {
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientGuildFeedUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientGuildFeedUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientGuildFeedUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientGuildFeedUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAddPlayerToGuildChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddPlayerToGuildChat {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAddPlayerToGuildChat.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAddPlayerToGuildChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddPlayerToGuildChat {
    fn default() -> &'a CMsgClientToGCAddPlayerToGuildChat {
        <CMsgClientToGCAddPlayerToGuildChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddPlayerToGuildChat {
    pub fn new() -> CMsgClientToGCAddPlayerToGuildChat {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCAddPlayerToGuildChat| { &m.guild_id },
            |m: &mut CMsgClientToGCAddPlayerToGuildChat| { &mut m.guild_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAddPlayerToGuildChat>(
            "CMsgClientToGCAddPlayerToGuildChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAddPlayerToGuildChat {
    const NAME: &'static str = "CMsgClientToGCAddPlayerToGuildChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddPlayerToGuildChat {
        CMsgClientToGCAddPlayerToGuildChat::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddPlayerToGuildChat {
        static instance: CMsgClientToGCAddPlayerToGuildChat = CMsgClientToGCAddPlayerToGuildChat {
            guild_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAddPlayerToGuildChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAddPlayerToGuildChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAddPlayerToGuildChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAddPlayerToGuildChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAddPlayerToGuildChatResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddPlayerToGuildChatResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAddPlayerToGuildChatResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAddPlayerToGuildChatResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddPlayerToGuildChatResponse {
    fn default() -> &'a CMsgClientToGCAddPlayerToGuildChatResponse {
        <CMsgClientToGCAddPlayerToGuildChatResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddPlayerToGuildChatResponse {
    pub fn new() -> CMsgClientToGCAddPlayerToGuildChatResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCAddPlayerToGuildChatResponse| { &m.result },
            |m: &mut CMsgClientToGCAddPlayerToGuildChatResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAddPlayerToGuildChatResponse>(
            "CMsgClientToGCAddPlayerToGuildChatResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAddPlayerToGuildChatResponse {
    const NAME: &'static str = "CMsgClientToGCAddPlayerToGuildChatResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddPlayerToGuildChatResponse {
        CMsgClientToGCAddPlayerToGuildChatResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddPlayerToGuildChatResponse {
        static instance: CMsgClientToGCAddPlayerToGuildChatResponse = CMsgClientToGCAddPlayerToGuildChatResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAddPlayerToGuildChatResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAddPlayerToGuildChatResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAddPlayerToGuildChatResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAddPlayerToGuildChatResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCAddPlayerToGuildChatResponse`
pub mod cmsg_client_to_gcadd_player_to_guild_chat_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eSteamChatNotEnabled)
        k_eSteamChatNotEnabled = 7,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eSteamChatNotEnabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eSteamChatNotEnabled" => ::std::option::Option::Some(EResponse::k_eSteamChatNotEnabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eSteamChatNotEnabled,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCAddPlayerToGuildChatResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCAddPlayerToGuildChatResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgFindGuildByTagResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFindGuildByTagResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgFindGuildByTagResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_find_guild_by_tag_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgFindGuildByTagResponse.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgFindGuildByTagResponse.guild_summary)
    pub guild_summary: ::protobuf::MessageField<CMsgGuildSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgFindGuildByTagResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFindGuildByTagResponse {
    fn default() -> &'a CMsgFindGuildByTagResponse {
        <CMsgFindGuildByTagResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFindGuildByTagResponse {
    pub fn new() -> CMsgFindGuildByTagResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgFindGuildByTagResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_find_guild_by_tag_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_find_guild_by_tag_response::EResponse::k_eInternalError),
            None => cmsg_find_guild_by_tag_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_find_guild_by_tag_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgFindGuildByTagResponse| { &m.result },
            |m: &mut CMsgFindGuildByTagResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgFindGuildByTagResponse| { &m.guild_id },
            |m: &mut CMsgFindGuildByTagResponse| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildSummary>(
            "guild_summary",
            |m: &CMsgFindGuildByTagResponse| { &m.guild_summary },
            |m: &mut CMsgFindGuildByTagResponse| { &mut m.guild_summary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFindGuildByTagResponse>(
            "CMsgFindGuildByTagResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFindGuildByTagResponse {
    const NAME: &'static str = "CMsgFindGuildByTagResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.guild_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guild_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFindGuildByTagResponse {
        CMsgFindGuildByTagResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.guild_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFindGuildByTagResponse {
        static instance: CMsgFindGuildByTagResponse = CMsgFindGuildByTagResponse {
            result: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            guild_summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFindGuildByTagResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFindGuildByTagResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFindGuildByTagResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFindGuildByTagResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgFindGuildByTagResponse`
pub mod cmsg_find_guild_by_tag_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgFindGuildByTagResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgFindGuildByTagResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgFindGuildByTagResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgFindGuildByTagResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgFindGuildByTagResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgFindGuildByTagResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgFindGuildByTagResponse.EResponse.k_eInvalidTag)
        k_eInvalidTag = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgFindGuildByTagResponse.EResponse.k_eGuildNotFound)
        k_eGuildNotFound = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                6 => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidTag" => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                "k_eGuildNotFound" => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidTag,
            EResponse::k_eGuildNotFound,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgFindGuildByTagResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgFindGuildByTagResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgSearchForOpenGuildsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSearchForOpenGuildsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSearchForOpenGuildsResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_search_for_open_guilds_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgSearchForOpenGuildsResponse.search_results)
    pub search_results: ::std::vec::Vec<cmsg_search_for_open_guilds_response::SearchResult>,
    // @@protoc_insertion_point(field:dota.CMsgSearchForOpenGuildsResponse.use_whitelist)
    pub use_whitelist: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSearchForOpenGuildsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSearchForOpenGuildsResponse {
    fn default() -> &'a CMsgSearchForOpenGuildsResponse {
        <CMsgSearchForOpenGuildsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSearchForOpenGuildsResponse {
    pub fn new() -> CMsgSearchForOpenGuildsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgSearchForOpenGuildsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_search_for_open_guilds_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_search_for_open_guilds_response::EResponse::k_eInternalError),
            None => cmsg_search_for_open_guilds_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_search_for_open_guilds_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool use_whitelist = 3;

    pub fn use_whitelist(&self) -> bool {
        self.use_whitelist.unwrap_or(false)
    }

    pub fn clear_use_whitelist(&mut self) {
        self.use_whitelist = ::std::option::Option::None;
    }

    pub fn has_use_whitelist(&self) -> bool {
        self.use_whitelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_whitelist(&mut self, v: bool) {
        self.use_whitelist = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgSearchForOpenGuildsResponse| { &m.result },
            |m: &mut CMsgSearchForOpenGuildsResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "search_results",
            |m: &CMsgSearchForOpenGuildsResponse| { &m.search_results },
            |m: &mut CMsgSearchForOpenGuildsResponse| { &mut m.search_results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_whitelist",
            |m: &CMsgSearchForOpenGuildsResponse| { &m.use_whitelist },
            |m: &mut CMsgSearchForOpenGuildsResponse| { &mut m.use_whitelist },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSearchForOpenGuildsResponse>(
            "CMsgSearchForOpenGuildsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSearchForOpenGuildsResponse {
    const NAME: &'static str = "CMsgSearchForOpenGuildsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.search_results.push(is.read_message()?);
                },
                24 => {
                    self.use_whitelist = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.search_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.use_whitelist {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.search_results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.use_whitelist {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSearchForOpenGuildsResponse {
        CMsgSearchForOpenGuildsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.search_results.clear();
        self.use_whitelist = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSearchForOpenGuildsResponse {
        static instance: CMsgSearchForOpenGuildsResponse = CMsgSearchForOpenGuildsResponse {
            result: ::std::option::Option::None,
            search_results: ::std::vec::Vec::new(),
            use_whitelist: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSearchForOpenGuildsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSearchForOpenGuildsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSearchForOpenGuildsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSearchForOpenGuildsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSearchForOpenGuildsResponse`
pub mod cmsg_search_for_open_guilds_response {
    // @@protoc_insertion_point(message:dota.CMsgSearchForOpenGuildsResponse.SearchResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SearchResult {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSearchForOpenGuildsResponse.SearchResult.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSearchForOpenGuildsResponse.SearchResult.guild_summary)
        pub guild_summary: ::protobuf::MessageField<super::CMsgGuildSummary>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSearchForOpenGuildsResponse.SearchResult.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SearchResult {
        fn default() -> &'a SearchResult {
            <SearchResult as ::protobuf::Message>::default_instance()
        }
    }

    impl SearchResult {
        pub fn new() -> SearchResult {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guild_id",
                |m: &SearchResult| { &m.guild_id },
                |m: &mut SearchResult| { &mut m.guild_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgGuildSummary>(
                "guild_summary",
                |m: &SearchResult| { &m.guild_summary },
                |m: &mut SearchResult| { &mut m.guild_summary },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchResult>(
                "CMsgSearchForOpenGuildsResponse.SearchResult",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SearchResult {
        const NAME: &'static str = "SearchResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_summary)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guild_summary.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guild_summary.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SearchResult {
            SearchResult::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.guild_summary.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SearchResult {
            static instance: SearchResult = SearchResult {
                guild_id: ::std::option::Option::None,
                guild_summary: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SearchResult {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSearchForOpenGuildsResponse.SearchResult").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SearchResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SearchResult {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgSearchForOpenGuildsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgSearchForOpenGuildsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgSearchForOpenGuildsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgSearchForOpenGuildsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgSearchForOpenGuildsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgSearchForOpenGuildsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSearchForOpenGuildsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgSearchForOpenGuildsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCReportGuildContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCReportGuildContent {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCReportGuildContent.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCReportGuildContent.guild_content_flags)
    pub guild_content_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCReportGuildContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCReportGuildContent {
    fn default() -> &'a CMsgClientToGCReportGuildContent {
        <CMsgClientToGCReportGuildContent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCReportGuildContent {
    pub fn new() -> CMsgClientToGCReportGuildContent {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_content_flags = 2;

    pub fn guild_content_flags(&self) -> u32 {
        self.guild_content_flags.unwrap_or(0)
    }

    pub fn clear_guild_content_flags(&mut self) {
        self.guild_content_flags = ::std::option::Option::None;
    }

    pub fn has_guild_content_flags(&self) -> bool {
        self.guild_content_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_content_flags(&mut self, v: u32) {
        self.guild_content_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCReportGuildContent| { &m.guild_id },
            |m: &mut CMsgClientToGCReportGuildContent| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_content_flags",
            |m: &CMsgClientToGCReportGuildContent| { &m.guild_content_flags },
            |m: &mut CMsgClientToGCReportGuildContent| { &mut m.guild_content_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCReportGuildContent>(
            "CMsgClientToGCReportGuildContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCReportGuildContent {
    const NAME: &'static str = "CMsgClientToGCReportGuildContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.guild_content_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_content_flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_content_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCReportGuildContent {
        CMsgClientToGCReportGuildContent::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_content_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCReportGuildContent {
        static instance: CMsgClientToGCReportGuildContent = CMsgClientToGCReportGuildContent {
            guild_id: ::std::option::Option::None,
            guild_content_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCReportGuildContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCReportGuildContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCReportGuildContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCReportGuildContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCReportGuildContent`
pub mod cmsg_client_to_gcreport_guild_content {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCReportGuildContent.EContentFlags)
    pub enum EContentFlags {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContent.EContentFlags.k_eNone)
        k_eNone = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContent.EContentFlags.k_eInappropriateName)
        k_eInappropriateName = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContent.EContentFlags.k_eInappropriateTag)
        k_eInappropriateTag = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContent.EContentFlags.k_eInappropriateLogo)
        k_eInappropriateLogo = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContent.EContentFlags.k_eValidFlags)
        k_eValidFlags = 7,
    }

    impl ::protobuf::Enum for EContentFlags {
        const NAME: &'static str = "EContentFlags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EContentFlags> {
            match value {
                0 => ::std::option::Option::Some(EContentFlags::k_eNone),
                1 => ::std::option::Option::Some(EContentFlags::k_eInappropriateName),
                2 => ::std::option::Option::Some(EContentFlags::k_eInappropriateTag),
                4 => ::std::option::Option::Some(EContentFlags::k_eInappropriateLogo),
                7 => ::std::option::Option::Some(EContentFlags::k_eValidFlags),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EContentFlags> {
            match str {
                "k_eNone" => ::std::option::Option::Some(EContentFlags::k_eNone),
                "k_eInappropriateName" => ::std::option::Option::Some(EContentFlags::k_eInappropriateName),
                "k_eInappropriateTag" => ::std::option::Option::Some(EContentFlags::k_eInappropriateTag),
                "k_eInappropriateLogo" => ::std::option::Option::Some(EContentFlags::k_eInappropriateLogo),
                "k_eValidFlags" => ::std::option::Option::Some(EContentFlags::k_eValidFlags),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EContentFlags] = &[
            EContentFlags::k_eNone,
            EContentFlags::k_eInappropriateName,
            EContentFlags::k_eInappropriateTag,
            EContentFlags::k_eInappropriateLogo,
            EContentFlags::k_eValidFlags,
        ];
    }

    impl ::protobuf::EnumFull for EContentFlags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCReportGuildContent.EContentFlags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EContentFlags::k_eNone => 0,
                EContentFlags::k_eInappropriateName => 1,
                EContentFlags::k_eInappropriateTag => 2,
                EContentFlags::k_eInappropriateLogo => 3,
                EContentFlags::k_eValidFlags => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EContentFlags {
        fn default() -> Self {
            EContentFlags::k_eNone
        }
    }

    impl EContentFlags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EContentFlags>("CMsgClientToGCReportGuildContent.EContentFlags")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCReportGuildContentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCReportGuildContentResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCReportGuildContentResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcreport_guild_content_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCReportGuildContentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCReportGuildContentResponse {
    fn default() -> &'a CMsgClientToGCReportGuildContentResponse {
        <CMsgClientToGCReportGuildContentResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCReportGuildContentResponse {
    pub fn new() -> CMsgClientToGCReportGuildContentResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCReportGuildContentResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcreport_guild_content_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcreport_guild_content_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcreport_guild_content_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcreport_guild_content_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCReportGuildContentResponse| { &m.result },
            |m: &mut CMsgClientToGCReportGuildContentResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCReportGuildContentResponse>(
            "CMsgClientToGCReportGuildContentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCReportGuildContentResponse {
    const NAME: &'static str = "CMsgClientToGCReportGuildContentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCReportGuildContentResponse {
        CMsgClientToGCReportGuildContentResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCReportGuildContentResponse {
        static instance: CMsgClientToGCReportGuildContentResponse = CMsgClientToGCReportGuildContentResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCReportGuildContentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCReportGuildContentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCReportGuildContentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCReportGuildContentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCReportGuildContentResponse`
pub mod cmsg_client_to_gcreport_guild_content_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCReportGuildContentResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContentResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContentResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContentResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContentResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContentResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContentResponse.EResponse.k_eGuildNotFound)
        k_eGuildNotFound = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCReportGuildContentResponse.EResponse.k_eFlagsInvalid)
        k_eFlagsInvalid = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                6 => ::std::option::Option::Some(EResponse::k_eFlagsInvalid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eGuildNotFound" => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                "k_eFlagsInvalid" => ::std::option::Option::Some(EResponse::k_eFlagsInvalid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eGuildNotFound,
            EResponse::k_eFlagsInvalid,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCReportGuildContentResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCReportGuildContentResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestAccountGuildPersonaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildPersonaInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestAccountGuildPersonaInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfo {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfo {
        <CMsgClientToGCRequestAccountGuildPersonaInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfo {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgClientToGCRequestAccountGuildPersonaInfo| { &m.account_id },
            |m: &mut CMsgClientToGCRequestAccountGuildPersonaInfo| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestAccountGuildPersonaInfo>(
            "CMsgClientToGCRequestAccountGuildPersonaInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfo {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfo {
        CMsgClientToGCRequestAccountGuildPersonaInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfo {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfo = CMsgClientToGCRequestAccountGuildPersonaInfo {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestAccountGuildPersonaInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestAccountGuildPersonaInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestAccountGuildPersonaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestAccountGuildPersonaInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.persona_info)
    pub persona_info: ::protobuf::MessageField<CMsgAccountGuildsPersonaInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        <CMsgClientToGCRequestAccountGuildPersonaInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestAccountGuildPersonaInfoResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestAccountGuildPersonaInfoResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAccountGuildsPersonaInfo>(
            "persona_info",
            |m: &CMsgClientToGCRequestAccountGuildPersonaInfoResponse| { &m.persona_info },
            |m: &mut CMsgClientToGCRequestAccountGuildPersonaInfoResponse| { &mut m.persona_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestAccountGuildPersonaInfoResponse>(
            "CMsgClientToGCRequestAccountGuildPersonaInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.persona_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.persona_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.persona_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        CMsgClientToGCRequestAccountGuildPersonaInfoResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.persona_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfoResponse = CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
            result: ::std::option::Option::None,
            persona_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestAccountGuildPersonaInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestAccountGuildPersonaInfoResponse`
pub mod cmsg_client_to_gcrequest_account_guild_persona_info_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eInvalidAccount)
        k_eInvalidAccount = 5,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidAccount),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidAccount" => ::std::option::Option::Some(EResponse::k_eInvalidAccount),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidAccount,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatch.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        <CMsgClientToGCRequestAccountGuildPersonaInfoBatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgClientToGCRequestAccountGuildPersonaInfoBatch| { &m.account_ids },
            |m: &mut CMsgClientToGCRequestAccountGuildPersonaInfoBatch| { &mut m.account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestAccountGuildPersonaInfoBatch>(
            "CMsgClientToGCRequestAccountGuildPersonaInfoBatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfoBatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        CMsgClientToGCRequestAccountGuildPersonaInfoBatch::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfoBatch = CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestAccountGuildPersonaInfoBatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.persona_infos)
    pub persona_infos: ::std::vec::Vec<CMsgAccountGuildsPersonaInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        <CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "persona_infos",
            |m: &CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse| { &m.persona_infos },
            |m: &mut CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse| { &mut m.persona_infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse>(
            "CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.persona_infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.persona_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.persona_infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.persona_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse = CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
            result: ::std::option::Option::None,
            persona_infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse`
pub mod cmsg_client_to_gcrequest_account_guild_persona_info_batch_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eInvalidRequest)
        k_eInvalidRequest = 5,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidRequest" => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidRequest,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EGuildAuditAction)
pub enum EGuildAuditAction {
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_Invalid)
    k_EGuildAuditAction_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildCreated)
    k_EGuildAuditAction_GuildCreated = 1,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildLanguageChanged)
    k_EGuildAuditAction_GuildLanguageChanged = 2,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildFlagsChanged)
    k_EGuildAuditAction_GuildFlagsChanged = 3,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildMemberJoined)
    k_EGuildAuditAction_GuildMemberJoined = 5,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildMemberLeft)
    k_EGuildAuditAction_GuildMemberLeft = 6,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildMemberKicked)
    k_EGuildAuditAction_GuildMemberKicked = 7,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildMemberRoleChanged)
    k_EGuildAuditAction_GuildMemberRoleChanged = 8,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildLogoChanged)
    k_EGuildAuditAction_GuildLogoChanged = 9,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildRegionChanged)
    k_EGuildAuditAction_GuildRegionChanged = 10,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildDescriptionChanged)
    k_EGuildAuditAction_GuildDescriptionChanged = 11,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildPrimaryColorChanged)
    k_EGuildAuditAction_GuildPrimaryColorChanged = 12,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildSecondaryColorChanged)
    k_EGuildAuditAction_GuildSecondaryColorChanged = 13,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildPatternChanged)
    k_EGuildAuditAction_GuildPatternChanged = 14,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminClearedLogo)
    k_EGuildAuditAction_AdminClearedLogo = 15,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildRequiredRankChanged)
    k_EGuildAuditAction_GuildRequiredRankChanged = 16,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildMotDChanged)
    k_EGuildAuditAction_GuildMotDChanged = 18,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminResetName)
    k_EGuildAuditAction_AdminResetName = 19,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminResetTag)
    k_EGuildAuditAction_AdminResetTag = 20,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminLock)
    k_EGuildAuditAction_AdminLock = 21,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildNameChanged)
    k_EGuildAuditAction_GuildNameChanged = 22,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_GuildTagChanged)
    k_EGuildAuditAction_GuildTagChanged = 23,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminPermitted)
    k_EGuildAuditAction_AdminPermitted = 24,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminBlocked)
    k_EGuildAuditAction_AdminBlocked = 25,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminBannedUser)
    k_EGuildAuditAction_AdminBannedUser = 26,
    // @@protoc_insertion_point(enum_value:dota.EGuildAuditAction.k_EGuildAuditAction_AdminExonerated)
    k_EGuildAuditAction_AdminExonerated = 27,
}

impl ::protobuf::Enum for EGuildAuditAction {
    const NAME: &'static str = "EGuildAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGuildAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_Invalid),
            1 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildCreated),
            2 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLanguageChanged),
            3 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildFlagsChanged),
            5 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberJoined),
            6 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberLeft),
            7 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberKicked),
            8 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberRoleChanged),
            9 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLogoChanged),
            10 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRegionChanged),
            11 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildDescriptionChanged),
            12 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPrimaryColorChanged),
            13 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildSecondaryColorChanged),
            14 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPatternChanged),
            15 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminClearedLogo),
            16 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRequiredRankChanged),
            18 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMotDChanged),
            19 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetName),
            20 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetTag),
            21 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminLock),
            22 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildNameChanged),
            23 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildTagChanged),
            24 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminPermitted),
            25 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBlocked),
            26 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBannedUser),
            27 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminExonerated),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGuildAuditAction> {
        match str {
            "k_EGuildAuditAction_Invalid" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_Invalid),
            "k_EGuildAuditAction_GuildCreated" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildCreated),
            "k_EGuildAuditAction_GuildLanguageChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLanguageChanged),
            "k_EGuildAuditAction_GuildFlagsChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildFlagsChanged),
            "k_EGuildAuditAction_GuildMemberJoined" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberJoined),
            "k_EGuildAuditAction_GuildMemberLeft" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberLeft),
            "k_EGuildAuditAction_GuildMemberKicked" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberKicked),
            "k_EGuildAuditAction_GuildMemberRoleChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberRoleChanged),
            "k_EGuildAuditAction_GuildLogoChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLogoChanged),
            "k_EGuildAuditAction_GuildRegionChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRegionChanged),
            "k_EGuildAuditAction_GuildDescriptionChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildDescriptionChanged),
            "k_EGuildAuditAction_GuildPrimaryColorChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPrimaryColorChanged),
            "k_EGuildAuditAction_GuildSecondaryColorChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildSecondaryColorChanged),
            "k_EGuildAuditAction_GuildPatternChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPatternChanged),
            "k_EGuildAuditAction_AdminClearedLogo" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminClearedLogo),
            "k_EGuildAuditAction_GuildRequiredRankChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRequiredRankChanged),
            "k_EGuildAuditAction_GuildMotDChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMotDChanged),
            "k_EGuildAuditAction_AdminResetName" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetName),
            "k_EGuildAuditAction_AdminResetTag" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetTag),
            "k_EGuildAuditAction_AdminLock" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminLock),
            "k_EGuildAuditAction_GuildNameChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildNameChanged),
            "k_EGuildAuditAction_GuildTagChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildTagChanged),
            "k_EGuildAuditAction_AdminPermitted" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminPermitted),
            "k_EGuildAuditAction_AdminBlocked" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBlocked),
            "k_EGuildAuditAction_AdminBannedUser" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBannedUser),
            "k_EGuildAuditAction_AdminExonerated" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminExonerated),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGuildAuditAction] = &[
        EGuildAuditAction::k_EGuildAuditAction_Invalid,
        EGuildAuditAction::k_EGuildAuditAction_GuildCreated,
        EGuildAuditAction::k_EGuildAuditAction_GuildLanguageChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildFlagsChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberJoined,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberLeft,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberKicked,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberRoleChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildLogoChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildRegionChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildDescriptionChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildPrimaryColorChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildSecondaryColorChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildPatternChanged,
        EGuildAuditAction::k_EGuildAuditAction_AdminClearedLogo,
        EGuildAuditAction::k_EGuildAuditAction_GuildRequiredRankChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildMotDChanged,
        EGuildAuditAction::k_EGuildAuditAction_AdminResetName,
        EGuildAuditAction::k_EGuildAuditAction_AdminResetTag,
        EGuildAuditAction::k_EGuildAuditAction_AdminLock,
        EGuildAuditAction::k_EGuildAuditAction_GuildNameChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildTagChanged,
        EGuildAuditAction::k_EGuildAuditAction_AdminPermitted,
        EGuildAuditAction::k_EGuildAuditAction_AdminBlocked,
        EGuildAuditAction::k_EGuildAuditAction_AdminBannedUser,
        EGuildAuditAction::k_EGuildAuditAction_AdminExonerated,
    ];
}

impl ::protobuf::EnumFull for EGuildAuditAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGuildAuditAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGuildAuditAction::k_EGuildAuditAction_Invalid => 0,
            EGuildAuditAction::k_EGuildAuditAction_GuildCreated => 1,
            EGuildAuditAction::k_EGuildAuditAction_GuildLanguageChanged => 2,
            EGuildAuditAction::k_EGuildAuditAction_GuildFlagsChanged => 3,
            EGuildAuditAction::k_EGuildAuditAction_GuildMemberJoined => 4,
            EGuildAuditAction::k_EGuildAuditAction_GuildMemberLeft => 5,
            EGuildAuditAction::k_EGuildAuditAction_GuildMemberKicked => 6,
            EGuildAuditAction::k_EGuildAuditAction_GuildMemberRoleChanged => 7,
            EGuildAuditAction::k_EGuildAuditAction_GuildLogoChanged => 8,
            EGuildAuditAction::k_EGuildAuditAction_GuildRegionChanged => 9,
            EGuildAuditAction::k_EGuildAuditAction_GuildDescriptionChanged => 10,
            EGuildAuditAction::k_EGuildAuditAction_GuildPrimaryColorChanged => 11,
            EGuildAuditAction::k_EGuildAuditAction_GuildSecondaryColorChanged => 12,
            EGuildAuditAction::k_EGuildAuditAction_GuildPatternChanged => 13,
            EGuildAuditAction::k_EGuildAuditAction_AdminClearedLogo => 14,
            EGuildAuditAction::k_EGuildAuditAction_GuildRequiredRankChanged => 15,
            EGuildAuditAction::k_EGuildAuditAction_GuildMotDChanged => 16,
            EGuildAuditAction::k_EGuildAuditAction_AdminResetName => 17,
            EGuildAuditAction::k_EGuildAuditAction_AdminResetTag => 18,
            EGuildAuditAction::k_EGuildAuditAction_AdminLock => 19,
            EGuildAuditAction::k_EGuildAuditAction_GuildNameChanged => 20,
            EGuildAuditAction::k_EGuildAuditAction_GuildTagChanged => 21,
            EGuildAuditAction::k_EGuildAuditAction_AdminPermitted => 22,
            EGuildAuditAction::k_EGuildAuditAction_AdminBlocked => 23,
            EGuildAuditAction::k_EGuildAuditAction_AdminBannedUser => 24,
            EGuildAuditAction::k_EGuildAuditAction_AdminExonerated => 25,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGuildAuditAction {
    fn default() -> Self {
        EGuildAuditAction::k_EGuildAuditAction_Invalid
    }
}

impl EGuildAuditAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGuildAuditAction>("EGuildAuditAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EGuildChatType)
pub enum EGuildChatType {
    // @@protoc_insertion_point(enum_value:dota.EGuildChatType.k_EGuildChatType_Unspecified)
    k_EGuildChatType_Unspecified = 0,
    // @@protoc_insertion_point(enum_value:dota.EGuildChatType.k_EGuildChatType_SteamChatGroup)
    k_EGuildChatType_SteamChatGroup = 1,
    // @@protoc_insertion_point(enum_value:dota.EGuildChatType.k_EGuildChatType_GC)
    k_EGuildChatType_GC = 2,
}

impl ::protobuf::Enum for EGuildChatType {
    const NAME: &'static str = "EGuildChatType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGuildChatType> {
        match value {
            0 => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_Unspecified),
            1 => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_SteamChatGroup),
            2 => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_GC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGuildChatType> {
        match str {
            "k_EGuildChatType_Unspecified" => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_Unspecified),
            "k_EGuildChatType_SteamChatGroup" => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_SteamChatGroup),
            "k_EGuildChatType_GC" => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_GC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGuildChatType] = &[
        EGuildChatType::k_EGuildChatType_Unspecified,
        EGuildChatType::k_EGuildChatType_SteamChatGroup,
        EGuildChatType::k_EGuildChatType_GC,
    ];
}

impl ::protobuf::EnumFull for EGuildChatType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGuildChatType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGuildChatType {
    fn default() -> Self {
        EGuildChatType::k_EGuildChatType_Unspecified
    }
}

impl EGuildChatType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGuildChatType>("EGuildChatType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"dota_gcmessages_client_guild.proto\x12\x04dota\x1a\x17dota_shared_en\
    ums.proto\"\xe3\x05\n\rCMsgGuildInfo\x12\x1d\n\nguild_name\x18\x01\x20\
    \x01(\tR\tguildName\x12\x1b\n\tguild_tag\x18\x02\x20\x01(\tR\x08guildTag\
    \x12+\n\x11created_timestamp\x18\x03\x20\x01(\rR\x10createdTimestamp\x12\
    %\n\x0eguild_language\x18\x04\x20\x01(\rR\rguildLanguage\x12\x1f\n\x0bgu\
    ild_flags\x18\x05\x20\x01(\rR\nguildFlags\x12\x1d\n\nguild_logo\x18\x07\
    \x20\x01(\x04R\tguildLogo\x12!\n\x0cguild_region\x18\x08\x20\x01(\rR\x0b\
    guildRegion\x12-\n\x13guild_chat_group_id\x18\t\x20\x01(\x04R\x10guildCh\
    atGroupId\x12+\n\x11guild_description\x18\n\x20\x01(\tR\x10guildDescript\
    ion\x125\n\x17default_chat_channel_id\x18\x0b\x20\x01(\x04R\x14defaultCh\
    atChannelId\x12.\n\x13guild_primary_color\x18\x0c\x20\x01(\rR\x11guildPr\
    imaryColor\x122\n\x15guild_secondary_color\x18\r\x20\x01(\rR\x13guildSec\
    ondaryColor\x12#\n\rguild_pattern\x18\x0e\x20\x01(\rR\x0cguildPattern\
    \x129\n\x19guild_refresh_time_offset\x18\x0f\x20\x01(\rR\x16guildRefresh\
    TimeOffset\x127\n\x18guild_required_rank_tier\x18\x10\x20\x01(\rR\x15gui\
    ldRequiredRankTier\x120\n\x14guild_motd_timestamp\x18\x11\x20\x01(\rR\
    \x12guildMotdTimestamp\x12\x1d\n\nguild_motd\x18\x12\x20\x01(\tR\tguildM\
    otd\"\xbb\x03\n\x10CMsgGuildSummary\x122\n\nguild_info\x18\x01\x20\x01(\
    \x0b2\x13.dota.CMsgGuildInfoR\tguildInfo\x12!\n\x0cmember_count\x18\x02\
    \x20\x01(\rR\x0bmemberCount\x12E\n\x0cevent_points\x18\x03\x20\x03(\x0b2\
    \".dota.CMsgGuildSummary.EventPointsR\x0beventPoints\x1a\x88\x02\n\x0bEv\
    entPoints\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12!\n\
    \x0cguild_points\x18\x02\x20\x01(\rR\x0bguildPoints\x12\x1d\n\nguild_ran\
    k\x18\x03\x20\x01(\rR\tguildRank\x12*\n\x11guild_weekly_rank\x18\x04\x20\
    \x01(\rR\x0fguildWeeklyRank\x126\n\x17guild_weekly_percentile\x18\x05\
    \x20\x01(\rR\x15guildWeeklyPercentile\x128\n\x18guild_current_percentile\
    \x18\x06\x20\x01(\rR\x16guildCurrentPercentile\"\x83\x01\n\rCMsgGuildRol\
    e\x12\x17\n\x07role_id\x18\x01\x20\x01(\rR\x06roleId\x12\x1b\n\trole_nam\
    e\x18\x02\x20\x01(\tR\x08roleName\x12\x1d\n\nrole_flags\x18\x03\x20\x01(\
    \rR\troleFlags\x12\x1d\n\nrole_order\x18\x04\x20\x01(\rR\troleOrder\"\
    \xdc\x01\n\x0fCMsgGuildMember\x12*\n\x11member_account_id\x18\x01\x20\
    \x01(\rR\x0fmemberAccountId\x12$\n\x0emember_role_id\x18\x02\x20\x01(\rR\
    \x0cmemberRoleId\x126\n\x17member_joined_timestamp\x18\x03\x20\x01(\rR\
    \x15memberJoinedTimestamp\x12?\n\x1cmember_last_active_timestamp\x18\x04\
    \x20\x01(\rR\x19memberLastActiveTimestamp\"\x96\x01\n\x0fCMsgGuildInvite\
    \x120\n\x14requester_account_id\x18\x01\x20\x01(\rR\x12requesterAccountI\
    d\x12*\n\x11target_account_id\x18\x02\x20\x01(\rR\x0ftargetAccountId\x12\
    %\n\x0etimestamp_sent\x18\x03\x20\x01(\rR\rtimestampSent\"\x8c\x02\n\rCM\
    sgGuildData\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x122\n\
    \nguild_info\x18\x02\x20\x01(\x0b2\x13.dota.CMsgGuildInfoR\tguildInfo\
    \x124\n\x0bguild_roles\x18\x03\x20\x03(\x0b2\x13.dota.CMsgGuildRoleR\ngu\
    ildRoles\x12:\n\rguild_members\x18\x04\x20\x03(\x0b2\x15.dota.CMsgGuildM\
    emberR\x0cguildMembers\x12:\n\rguild_invites\x18\x05\x20\x03(\x0b2\x15.d\
    ota.CMsgGuildInviteR\x0cguildInvites\"\x8c\x01\n\x16CMsgAccountGuildInvi\
    te\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x120\n\x14reques\
    ter_account_id\x18\x02\x20\x01(\rR\x12requesterAccountId\x12%\n\x0etimes\
    tamp_sent\x18\x03\x20\x01(\rR\rtimestampSent\"}\n\x1bCMsgAccountGuildMem\
    berships\x12\x1b\n\tguild_ids\x18\x01\x20\x03(\rR\x08guildIds\x12A\n\rgu\
    ild_invites\x18\x02\x20\x03(\x0b2\x1c.dota.CMsgAccountGuildInviteR\x0cgu\
    ildInvites\"o\n\x14CMsgGuildPersonaInfo\x12\x19\n\x08guild_id\x18\x01\
    \x20\x01(\rR\x07guildId\x12\x1b\n\tguild_tag\x18\x02\x20\x01(\tR\x08guil\
    dTag\x12\x1f\n\x0bguild_flags\x18\x03\x20\x01(\rR\nguildFlags\"j\n\x1cCM\
    sgAccountGuildsPersonaInfo\x12J\n\x13guild_persona_infos\x18\x01\x20\x03\
    (\x0b2\x1a.dota.CMsgGuildPersonaInfoR\x11guildPersonaInfos\"\xdb\x01\n\
    \x12CMsgGuildFeedEvent\x12\"\n\rfeed_event_id\x18\x01\x20\x01(\x04R\x0bf\
    eedEventId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x1d\n\
    \nevent_type\x18\x03\x20\x01(\rR\teventType\x12\x20\n\x0cparam_uint_1\
    \x18\x04\x20\x01(\rR\nparamUint1\x12\x20\n\x0cparam_uint_2\x18\x05\x20\
    \x01(\rR\nparamUint2\x12\x20\n\x0cparam_uint_3\x18\x06\x20\x01(\rR\npara\
    mUint3\"\x8d\x01\n\x19CMsgClientToGCCreateGuild\x122\n\nguild_info\x18\
    \x01\x20\x01(\x0b2\x13.dota.CMsgGuildInfoR\tguildInfo\x12<\n\x0fguild_ch\
    at_type\x18\x02\x20\x01(\x0e2\x14.dota.EGuildChatTypeR\rguildChatType\"\
    \xd8\x03\n!CMsgClientToGCCreateGuildResponse\x12I\n\x06result\x18\x01\
    \x20\x01(\x0e21.dota.CMsgClientToGCCreateGuildResponse.EResponseR\x06res\
    ult\x12\x19\n\x08guild_id\x18\x02\x20\x01(\rR\x07guildId\"\xcc\x02\n\tER\
    esponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\
    \x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\
    \x0e\n\nk_eTimeout\x10\x04\x12\x12\n\x0ek_eInvalidName\x10\x05\x12\x16\n\
    \x12k_eNameAlreadyUsed\x10\x06\x12\x11\n\rk_eInvalidTag\x10\x07\x12\x15\
    \n\x11k_eTagAlreadyUsed\x10\x08\x12\x19\n\x15k_eInvalidDescription\x10\t\
    \x12\x14\n\x10k_eInvalidRegion\x10\n\x12\x12\n\x0ek_eInvalidLogo\x10\x0b\
    \x12\x16\n\x12k_eDoesNotOwnEvent\x10\x0c\x12\x11\n\rk_eGuildLimit\x10\r\
    \x12\x12\n\x0ek_eInvalidMotD\x10\x0e\x12\x0e\n\nk_eBlocked\x10\x0f\"\xa9\
    \x01\n\x1aCMsgClientToGCSetGuildInfo\x12\x19\n\x08guild_id\x18\x01\x20\
    \x01(\rR\x07guildId\x122\n\nguild_info\x18\x02\x20\x01(\x0b2\x13.dota.CM\
    sgGuildInfoR\tguildInfo\x12<\n\x0fguild_chat_type\x18\x03\x20\x01(\x0e2\
    \x14.dota.EGuildChatTypeR\rguildChatType\"\xb6\x03\n\"CMsgClientToGCSetG\
    uildInfoResponse\x12J\n\x06result\x18\x01\x20\x01(\x0e22.dota.CMsgClient\
    ToGCSetGuildInfoResponse.EResponseR\x06result\"\xc3\x02\n\tEResponse\x12\
    \x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\
    \nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTime\
    out\x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\x05\x12\x10\n\x0ck_eNotMemb\
    er\x10\x06\x12\x13\n\x0fk_eNoPermission\x10\x07\x12\x12\n\x0ek_eMotDTooL\
    ong\x10\x08\x12\x1e\n\x1ak_eNameChangeNoPermissions\x10\t\x12\x1d\n\x19k\
    _eTagChangeNoPermissions\x10\n\x12\x12\n\x0ek_eNameInvalid\x10\x0b\x12\
    \x11\n\rk_eTagInvalid\x10\x0c\x12\x19\n\x15k_eDescriptionInvalid\x10\r\
    \x12\x0e\n\nk_eBlocked\x10\x0e\";\n\x1eCMsgClientToGCRequestGuildData\
    \x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\"\xb8\x02\n&CMsgCl\
    ientToGCRequestGuildDataResponse\x12N\n\x06result\x18\x01\x20\x01(\x0e26\
    .dota.CMsgClientToGCRequestGuildDataResponse.EResponseR\x06result\x122\n\
    \nguild_data\x18\x02\x20\x01(\x0b2\x13.dota.CMsgGuildDataR\tguildData\"\
    \x89\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_e\
    Success\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\
    \x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\
    \x05\x12\x10\n\x0ck_eNotMember\x10\x06\"w\n\x1eCMsgGCToClientGuildDataUp\
    dated\x122\n\nguild_data\x18\x01\x20\x01(\x0b2\x13.dota.CMsgGuildDataR\t\
    guildData\x12!\n\x0cupdate_flags\x18\x02\x20\x01(\rR\x0bupdateFlags\"|\n\
    %CMsgGCToClientGuildMembersDataUpdated\x12\x19\n\x08guild_id\x18\x01\x20\
    \x01(\rR\x07guildId\x128\n\x0cmembers_data\x18\x02\x20\x03(\x0b2\x15.dot\
    a.CMsgGuildMemberR\x0bmembersData\"&\n$CMsgClientToGCRequestGuildMembers\
    hip\"\xb8\x02\n,CMsgClientToGCRequestGuildMembershipResponse\x12T\n\x06r\
    esult\x18\x01\x20\x01(\x0e2<.dota.CMsgClientToGCRequestGuildMembershipRe\
    sponse.EResponseR\x06result\x12N\n\x11guild_memberships\x18\x02\x20\x01(\
    \x0b2!.dota.CMsgAccountGuildMembershipsR\x10guildMemberships\"b\n\tEResp\
    onse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\
    \x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\
    \n\nk_eTimeout\x10\x04\"v\n$CMsgGCToClientGuildMembershipUpdated\x12N\n\
    \x11guild_memberships\x18\x01\x20\x01(\x0b2!.dota.CMsgAccountGuildMember\
    shipsR\x10guildMemberships\"4\n\x17CMsgClientToGCJoinGuild\x12\x19\n\x08\
    guild_id\x18\x01\x20\x01(\rR\x07guildId\"\xd3\x02\n\x1fCMsgClientToGCJoi\
    nGuildResponse\x12G\n\x06result\x18\x01\x20\x01(\x0e2/.dota.CMsgClientTo\
    GCJoinGuildResponse.EResponseR\x06result\"\xe6\x01\n\tEResponse\x12\x14\
    \n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_\
    eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\
    \x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\x05\x12\x10\n\x0ck_eGuildFull\
    \x10\x06\x12\x14\n\x10k_eAlreadyMember\x10\x07\x12\x11\n\rk_eGuildLimit\
    \x10\x08\x12\x1a\n\x16k_eGuildRequiresInvite\x10\t\x12\x16\n\x12k_eGuild\
    RankTooLow\x10\n\"5\n\x18CMsgClientToGCLeaveGuild\x12\x19\n\x08guild_id\
    \x18\x01\x20\x01(\rR\x07guildId\"\x8a\x02\n\x20CMsgClientToGCLeaveGuildR\
    esponse\x12H\n\x06result\x18\x01\x20\x01(\x0e20.dota.CMsgClientToGCLeave\
    GuildResponse.EResponseR\x06result\"\x9b\x01\n\tEResponse\x12\x14\n\x10k\
    _eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBus\
    y\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\
    \x12\x13\n\x0fk_eInvalidGuild\x10\x05\x12\x10\n\x0ck_eNotMember\x10\x06\
    \x12\x10\n\x0ck_eLastAdmin\x10\x07\"f\n\x1dCMsgClientToGCKickGuildMember\
    \x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12*\n\x11target_a\
    ccount_id\x18\x02\x20\x01(\rR\x0ftargetAccountId\"\xcd\x02\n%CMsgClientT\
    oGCKickGuildMemberResponse\x12M\n\x06result\x18\x01\x20\x01(\x0e25.dota.\
    CMsgClientToGCKickGuildMemberResponse.EResponseR\x06result\"\xd4\x01\n\t\
    EResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\
    \x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\
    \x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\x05\x12\x19\
    \n\x15k_eRequesterNotMember\x10\x06\x12\x16\n\x12k_eTargetNotMember\x10\
    \x07\x12\x13\n\x0fk_eNoPermission\x10\x08\x12\x13\n\x0fk_eCantKickSelf\
    \x10\t\"\x8f\x01\n\x20CMsgClientToGCSetGuildMemberRole\x12\x19\n\x08guil\
    d_id\x18\x01\x20\x01(\rR\x07guildId\x12*\n\x11target_account_id\x18\x02\
    \x20\x01(\rR\x0ftargetAccountId\x12$\n\x0etarget_role_id\x18\x03\x20\x01\
    (\rR\x0ctargetRoleId\"\xe9\x02\n(CMsgClientToGCSetGuildMemberRoleRespons\
    e\x12P\n\x06result\x18\x01\x20\x01(\x0e28.dota.CMsgClientToGCSetGuildMem\
    berRoleResponse.EResponseR\x06result\"\xea\x01\n\tEResponse\x12\x14\n\
    \x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eT\
    ooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\
    \x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\x05\x12\x19\n\x15k_eRequesterN\
    otMember\x10\x06\x12\x16\n\x12k_eTargetNotMember\x10\x07\x12\x13\n\x0fk_\
    eNoPermission\x10\x08\x12\x12\n\x0ek_eInvalidRole\x10\t\x12\x15\n\x11k_e\
    AdminViolation\x10\n\"d\n\x1bCMsgClientToGCInviteToGuild\x12\x19\n\x08gu\
    ild_id\x18\x01\x20\x01(\rR\x07guildId\x12*\n\x11target_account_id\x18\
    \x02\x20\x01(\rR\x0ftargetAccountId\"\x8e\x03\n#CMsgClientToGCInviteToGu\
    ildResponse\x12K\n\x06result\x18\x01\x20\x01(\x0e23.dota.CMsgClientToGCI\
    nviteToGuildResponse.EResponseR\x06result\"\x99\x02\n\tEResponse\x12\x14\
    \n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_\
    eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\
    \x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\x05\x12\x10\n\x0ck_eGuildFull\
    \x10\x06\x12\x19\n\x15k_eRequesterNotMember\x10\x07\x12\x15\n\x11k_eAlre\
    adyAMember\x10\x08\x12\x15\n\x11k_eAlreadyInvited\x10\t\x12\x1a\n\x16k_e\
    NoInvitePermissions\x10\n\x12\x15\n\x11k_eTooManyInvites\x10\x0b\x12\x12\
    \n\x0ek_eInvalidUser\x10\x0c\"?\n\"CMsgClientToGCDeclineInviteToGuild\
    \x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\"\x90\x02\n*CMsgCl\
    ientToGCDeclineInviteToGuildResponse\x12R\n\x06result\x18\x01\x20\x01(\
    \x0e2:.dota.CMsgClientToGCDeclineInviteToGuildResponse.EResponseR\x06res\
    ult\"\x8d\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\
    \nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisab\
    led\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidGuild\
    \x10\x05\x12\x14\n\x10k_eNoInviteFound\x10\x06\">\n!CMsgClientToGCAccept\
    InviteToGuild\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\"\xe1\
    \x02\n)CMsgClientToGCAcceptInviteToGuildResponse\x12Q\n\x06result\x18\
    \x01\x20\x01(\x0e29.dota.CMsgClientToGCAcceptInviteToGuildResponse.EResp\
    onseR\x06result\"\xe0\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\
    \0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\
    \x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eIn\
    validGuild\x10\x05\x12\x14\n\x10k_eNoInviteFound\x10\x06\x12\x10\n\x0ck_\
    eGuildFull\x10\x07\x12\x11\n\rk_eGuildLimit\x10\x08\x12\x15\n\x11k_eInva\
    lidInviter\x10\t\x12\x15\n\x11k_eAlreadyInGuild\x10\n\"j\n!CMsgClientToG\
    CCancelInviteToGuild\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildI\
    d\x12*\n\x11target_account_id\x18\x02\x20\x01(\rR\x0ftargetAccountId\"\
    \xa4\x02\n)CMsgClientToGCCancelInviteToGuildResponse\x12Q\n\x06result\
    \x18\x01\x20\x01(\x0e29.dota.CMsgClientToGCCancelInviteToGuildResponse.E\
    ResponseR\x06result\"\xa3\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\
    \x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\
    \x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\
    \x0fk_eInvalidGuild\x10\x05\x12\x14\n\x10k_eNoInviteFound\x10\x06\x12\
    \x14\n\x10k_eNoPermissions\x10\x07\"s\n\x1aCMsgClientToGCAddGuildRole\
    \x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12\x1b\n\trole_na\
    me\x18\x02\x20\x01(\tR\x08roleName\x12\x1d\n\nrole_flags\x18\x03\x20\x01\
    (\rR\troleFlags\"\x96\x03\n\"CMsgClientToGCAddGuildRoleResponse\x12J\n\
    \x06result\x18\x01\x20\x01(\x0e22.dota.CMsgClientToGCAddGuildRoleRespons\
    e.EResponseR\x06result\x12\x17\n\x07role_id\x18\x02\x20\x01(\rR\x06roleI\
    d\"\x8a\x02\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\n\
    k_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisable\
    d\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\
    \x05\x12\x16\n\x12k_eNameAlreadyUsed\x10\x06\x12\x14\n\x10k_eNoPermissio\
    ns\x10\x07\x12\x13\n\x0fk_eInvalidFlags\x10\x08\x12\x12\n\x0ek_eInvalidN\
    ame\x10\t\x12\x15\n\x11k_eAdminViolation\x10\n\x12\x13\n\x0fk_eTooManyRo\
    les\x10\x0b\x12\x0e\n\nk_eBlocked\x10\x0c\"\x8f\x01\n\x1dCMsgClientToGCM\
    odifyGuildRole\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12\
    \x17\n\x07role_id\x18\x02\x20\x01(\rR\x06roleId\x12\x1b\n\trole_name\x18\
    \x03\x20\x01(\tR\x08roleName\x12\x1d\n\nrole_flags\x18\x04\x20\x01(\rR\t\
    roleFlags\"\x82\x03\n%CMsgClientToGCModifyGuildRoleResponse\x12M\n\x06re\
    sult\x18\x01\x20\x01(\x0e25.dota.CMsgClientToGCModifyGuildRoleResponse.E\
    ResponseR\x06result\"\x89\x02\n\tEResponse\x12\x14\n\x10k_eInternalError\
    \x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\
    \x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\
    \x0fk_eInvalidGuild\x10\x05\x12\x12\n\x0ek_eInvalidRole\x10\x06\x12\x16\
    \n\x12k_eNameAlreadyUsed\x10\x07\x12\x13\n\x0fk_eInvalidFlags\x10\x08\
    \x12\x12\n\x0ek_eInvalidName\x10\t\x12\x14\n\x10k_eNoPermissions\x10\n\
    \x12\x15\n\x11k_eAdminViolation\x10\x0b\x12\x0e\n\nk_eBlocked\x10\x0c\"S\
    \n\x1dCMsgClientToGCRemoveGuildRole\x12\x19\n\x08guild_id\x18\x01\x20\
    \x01(\rR\x07guildId\x12\x17\n\x07role_id\x18\x02\x20\x01(\rR\x06roleId\"\
    \xe4\x02\n%CMsgClientToGCRemoveGuildRoleResponse\x12M\n\x06result\x18\
    \x01\x20\x01(\x0e25.dota.CMsgClientToGCRemoveGuildRoleResponse.EResponse\
    R\x06result\"\xeb\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\
    \x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\
    \x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eIn\
    validGuild\x10\x05\x12\x12\n\x0ek_eInvalidRole\x10\x06\x12\x13\n\x0fk_eR\
    oleNotEmpty\x10\x07\x12\x14\n\x10k_eNoPermissions\x10\x08\x12\x15\n\x11k\
    _eAdminViolation\x10\t\x12\x1c\n\x18k_eCantRemoveDefaultRole\x10\n\"\x96\
    \x01\n\x1fCMsgClientToGCSetGuildRoleOrder\x12\x19\n\x08guild_id\x18\x01\
    \x20\x01(\rR\x07guildId\x12,\n\x12requested_role_ids\x18\x02\x20\x03(\rR\
    \x10requestedRoleIds\x12*\n\x11previous_role_ids\x18\x03\x20\x03(\rR\x0f\
    previousRoleIds\"\xf8\x02\n'CMsgClientToGCSetGuildRoleOrderResponse\x12O\
    \n\x06result\x18\x01\x20\x01(\x0e27.dota.CMsgClientToGCSetGuildRoleOrder\
    Response.EResponseR\x06result\x12,\n\x12confirmed_role_ids\x18\x02\x20\
    \x03(\rR\x10confirmedRoleIds\"\xcd\x01\n\tEResponse\x12\x14\n\x10k_eInte\
    rnalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\
    \x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\
    \x13\n\x0fk_eInvalidGuild\x10\x05\x12\x12\n\x0ek_eInvalidRole\x10\x06\
    \x12\x13\n\x0fk_eInvalidOrder\x10\x07\x12\x14\n\x10k_eNoPermissions\x10\
    \x08\x12\x15\n\x11k_eAdminViolation\x10\t\"]\n\x1eCMsgClientToGCGuildFee\
    dRequest\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12\x20\n\
    \x0clast_seen_id\x18\x02\x20\x01(\x04R\nlastSeenId\"\xde\x02\n&CMsgClien\
    tToGCRequestGuildFeedResponse\x12N\n\x06result\x18\x01\x20\x01(\x0e26.do\
    ta.CMsgClientToGCRequestGuildFeedResponse.EResponseR\x06result\x12\x19\n\
    \x08guild_id\x18\x02\x20\x01(\rR\x07guildId\x129\n\x0bfeed_events\x18\
    \x03\x20\x03(\x0b2\x18.dota.CMsgGuildFeedEventR\nfeedEvents\"\x8d\x01\n\
    \tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\
    \x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\
    \x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidGuild\x10\x05\x12\
    \x14\n\x10k_eNoPermissions\x10\x06\";\n\x1eCMsgGCToClientGuildFeedUpdate\
    d\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\"?\n\"CMsgClientT\
    oGCAddPlayerToGuildChat\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07gui\
    ldId\"\xa8\x02\n*CMsgClientToGCAddPlayerToGuildChatResponse\x12R\n\x06re\
    sult\x18\x01\x20\x01(\x0e2:.dota.CMsgClientToGCAddPlayerToGuildChatRespo\
    nse.EResponseR\x06result\"\xa5\x01\n\tEResponse\x12\x14\n\x10k_eInternal\
    Error\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\
    \x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\
    \n\x0fk_eInvalidGuild\x10\x05\x12\x10\n\x0ck_eNotMember\x10\x06\x12\x1a\
    \n\x16k_eSteamChatNotEnabled\x10\x07\"\xc6\x02\n\x1aCMsgFindGuildByTagRe\
    sponse\x12B\n\x06result\x18\x01\x20\x01(\x0e2*.dota.CMsgFindGuildByTagRe\
    sponse.EResponseR\x06result\x12\x19\n\x08guild_id\x18\x02\x20\x01(\rR\
    \x07guildId\x12;\n\rguild_summary\x18\x03\x20\x01(\x0b2\x16.dota.CMsgGui\
    ldSummaryR\x0cguildSummary\"\x8b\x01\n\tEResponse\x12\x14\n\x10k_eIntern\
    alError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\
    \x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\
    \x11\n\rk_eInvalidTag\x10\x05\x12\x14\n\x10k_eGuildNotFound\x10\x06\"\
    \xb6\x03\n\x1fCMsgSearchForOpenGuildsResponse\x12G\n\x06result\x18\x01\
    \x20\x01(\x0e2/.dota.CMsgSearchForOpenGuildsResponse.EResponseR\x06resul\
    t\x12Y\n\x0esearch_results\x18\x02\x20\x03(\x0b22.dota.CMsgSearchForOpen\
    GuildsResponse.SearchResultR\rsearchResults\x12#\n\ruse_whitelist\x18\
    \x03\x20\x01(\x08R\x0cuseWhitelist\x1af\n\x0cSearchResult\x12\x19\n\x08g\
    uild_id\x18\x01\x20\x01(\rR\x07guildId\x12;\n\rguild_summary\x18\x02\x20\
    \x01(\x0b2\x16.dota.CMsgGuildSummaryR\x0cguildSummary\"b\n\tEResponse\
    \x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\
    \x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk\
    _eTimeout\x10\x04\"\xeb\x01\n\x20CMsgClientToGCReportGuildContent\x12\
    \x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12.\n\x13guild_conten\
    t_flags\x18\x02\x20\x01(\rR\x11guildContentFlags\"|\n\rEContentFlags\x12\
    \x0b\n\x07k_eNone\x10\0\x12\x18\n\x14k_eInappropriateName\x10\x01\x12\
    \x17\n\x13k_eInappropriateTag\x10\x02\x12\x18\n\x14k_eInappropriateLogo\
    \x10\x04\x12\x11\n\rk_eValidFlags\x10\x07\"\x8c\x02\n(CMsgClientToGCRepo\
    rtGuildContentResponse\x12P\n\x06result\x18\x01\x20\x01(\x0e28.dota.CMsg\
    ClientToGCReportGuildContentResponse.EResponseR\x06result\"\x8d\x01\n\tE\
    Response\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\
    \x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\
    \x0e\n\nk_eTimeout\x10\x04\x12\x14\n\x10k_eGuildNotFound\x10\x05\x12\x13\
    \n\x0fk_eFlagsInvalid\x10\x06\"M\n,CMsgClientToGCRequestAccountGuildPers\
    onaInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"\xd6\x02\n\
    4CMsgClientToGCRequestAccountGuildPersonaInfoResponse\x12\\\n\x06result\
    \x18\x01\x20\x01(\x0e2D.dota.CMsgClientToGCRequestAccountGuildPersonaInf\
    oResponse.EResponseR\x06result\x12E\n\x0cpersona_info\x18\x02\x20\x01(\
    \x0b2\".dota.CMsgAccountGuildsPersonaInfoR\x0bpersonaInfo\"y\n\tERespons\
    e\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\
    \x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk\
    _eTimeout\x10\x04\x12\x15\n\x11k_eInvalidAccount\x10\x05\"T\n1CMsgClient\
    ToGCRequestAccountGuildPersonaInfoBatch\x12\x1f\n\x0baccount_ids\x18\x01\
    \x20\x03(\rR\naccountIds\"\xe2\x02\n9CMsgClientToGCRequestAccountGuildPe\
    rsonaInfoBatchResponse\x12a\n\x06result\x18\x01\x20\x01(\x0e2I.dota.CMsg\
    ClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponseR\x06resu\
    lt\x12G\n\rpersona_infos\x18\x02\x20\x03(\x0b2\".dota.CMsgAccountGuildsP\
    ersonaInfoR\x0cpersonaInfos\"y\n\tEResponse\x12\x14\n\x10k_eInternalErro\
    r\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\
    \x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x15\n\
    \x11k_eInvalidRequest\x10\x05*\xe7\x08\n\x11EGuildAuditAction\x12\x1f\n\
    \x1bk_EGuildAuditAction_Invalid\x10\0\x12$\n\x20k_EGuildAuditAction_Guil\
    dCreated\x10\x01\x12,\n(k_EGuildAuditAction_GuildLanguageChanged\x10\x02\
    \x12)\n%k_EGuildAuditAction_GuildFlagsChanged\x10\x03\x12)\n%k_EGuildAud\
    itAction_GuildMemberJoined\x10\x05\x12'\n#k_EGuildAuditAction_GuildMembe\
    rLeft\x10\x06\x12)\n%k_EGuildAuditAction_GuildMemberKicked\x10\x07\x12.\
    \n*k_EGuildAuditAction_GuildMemberRoleChanged\x10\x08\x12(\n$k_EGuildAud\
    itAction_GuildLogoChanged\x10\t\x12*\n&k_EGuildAuditAction_GuildRegionCh\
    anged\x10\n\x12/\n+k_EGuildAuditAction_GuildDescriptionChanged\x10\x0b\
    \x120\n,k_EGuildAuditAction_GuildPrimaryColorChanged\x10\x0c\x122\n.k_EG\
    uildAuditAction_GuildSecondaryColorChanged\x10\r\x12+\n'k_EGuildAuditAct\
    ion_GuildPatternChanged\x10\x0e\x12(\n$k_EGuildAuditAction_AdminClearedL\
    ogo\x10\x0f\x120\n,k_EGuildAuditAction_GuildRequiredRankChanged\x10\x10\
    \x12(\n$k_EGuildAuditAction_GuildMotDChanged\x10\x12\x12&\n\"k_EGuildAud\
    itAction_AdminResetName\x10\x13\x12%\n!k_EGuildAuditAction_AdminResetTag\
    \x10\x14\x12!\n\x1dk_EGuildAuditAction_AdminLock\x10\x15\x12(\n$k_EGuild\
    AuditAction_GuildNameChanged\x10\x16\x12'\n#k_EGuildAuditAction_GuildTag\
    Changed\x10\x17\x12&\n\"k_EGuildAuditAction_AdminPermitted\x10\x18\x12$\
    \n\x20k_EGuildAuditAction_AdminBlocked\x10\x19\x12'\n#k_EGuildAuditActio\
    n_AdminBannedUser\x10\x1a\x12'\n#k_EGuildAuditAction_AdminExonerated\x10\
    \x1b*p\n\x0eEGuildChatType\x12\x20\n\x1ck_EGuildChatType_Unspecified\x10\
    \0\x12#\n\x1fk_EGuildChatType_SteamChatGroup\x10\x01\x12\x17\n\x13k_EGui\
    ldChatType_GC\x10\x02B%Z#github.com/dotabuff/manta/dota;dotaJ\xc0\xc1\
    \x01\n\x07\x12\x05\0\0\x8e\x05\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\
    \n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\
    \x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x20\n\n\n\x02\
    \x05\0\x12\x04\x07\0\"\x01\n\n\n\x03\x05\0\x01\x12\x03\x07\x05\x16\n\x0b\
    \n\x04\x05\0\x02\0\x12\x03\x08\x08(\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\
    \x08\x08#\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x08&'\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\t\x08-\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\t\x08(\n\
    \x0c\n\x05\x05\0\x02\x01\x02\x12\x03\t+,\n\x0b\n\x04\x05\0\x02\x02\x12\
    \x03\n\x085\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\n\x080\n\x0c\n\x05\x05\
    \0\x02\x02\x02\x12\x03\n34\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x0b\x082\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x0b\x08-\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03\x0b01\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x0c\x082\n\x0c\n\
    \x05\x05\0\x02\x04\x01\x12\x03\x0c\x08-\n\x0c\n\x05\x05\0\x02\x04\x02\
    \x12\x03\x0c01\n\x0b\n\x04\x05\0\x02\x05\x12\x03\r\x080\n\x0c\n\x05\x05\
    \0\x02\x05\x01\x12\x03\r\x08+\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\r./\
    \n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0e\x082\n\x0c\n\x05\x05\0\x02\x06\
    \x01\x12\x03\x0e\x08-\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0e01\n\x0b\
    \n\x04\x05\0\x02\x07\x12\x03\x0f\x087\n\x0c\n\x05\x05\0\x02\x07\x01\x12\
    \x03\x0f\x082\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x0f56\n\x0b\n\x04\
    \x05\0\x02\x08\x12\x03\x10\x081\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\
    \x10\x08,\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x10/0\n\x0b\n\x04\x05\0\
    \x02\t\x12\x03\x11\x084\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x11\x08.\n\
    \x0c\n\x05\x05\0\x02\t\x02\x12\x03\x1113\n\x0b\n\x04\x05\0\x02\n\x12\x03\
    \x12\x089\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x12\x083\n\x0c\n\x05\x05\0\
    \x02\n\x02\x12\x03\x1268\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x13\x08:\n\
    \x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x13\x084\n\x0c\n\x05\x05\0\x02\x0b\
    \x02\x12\x03\x1379\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x14\x08<\n\x0c\n\
    \x05\x05\0\x02\x0c\x01\x12\x03\x14\x086\n\x0c\n\x05\x05\0\x02\x0c\x02\
    \x12\x03\x149;\n\x0b\n\x04\x05\0\x02\r\x12\x03\x15\x085\n\x0c\n\x05\x05\
    \0\x02\r\x01\x12\x03\x15\x08/\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x1524\
    \n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x16\x082\n\x0c\n\x05\x05\0\x02\x0e\
    \x01\x12\x03\x16\x08,\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x16/1\n\x0b\
    \n\x04\x05\0\x02\x0f\x12\x03\x17\x08:\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\
    \x03\x17\x084\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x1779\n\x0b\n\x04\
    \x05\0\x02\x10\x12\x03\x18\x082\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\
    \x18\x08,\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x18/1\n\x0b\n\x04\x05\0\
    \x02\x11\x12\x03\x19\x080\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x19\x08*\
    \n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x19-/\n\x0b\n\x04\x05\0\x02\x12\
    \x12\x03\x1a\x08/\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\x1a\x08)\n\x0c\n\
    \x05\x05\0\x02\x12\x02\x12\x03\x1a,.\n\x0b\n\x04\x05\0\x02\x13\x12\x03\
    \x1b\x08+\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x1b\x08%\n\x0c\n\x05\x05\
    \0\x02\x13\x02\x12\x03\x1b(*\n\x0b\n\x04\x05\0\x02\x14\x12\x03\x1c\x082\
    \n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1c\x08,\n\x0c\n\x05\x05\0\x02\
    \x14\x02\x12\x03\x1c/1\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1d\x081\n\x0c\
    \n\x05\x05\0\x02\x15\x01\x12\x03\x1d\x08+\n\x0c\n\x05\x05\0\x02\x15\x02\
    \x12\x03\x1d.0\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x1e\x080\n\x0c\n\x05\
    \x05\0\x02\x16\x01\x12\x03\x1e\x08*\n\x0c\n\x05\x05\0\x02\x16\x02\x12\
    \x03\x1e-/\n\x0b\n\x04\x05\0\x02\x17\x12\x03\x1f\x08.\n\x0c\n\x05\x05\0\
    \x02\x17\x01\x12\x03\x1f\x08(\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03\x1f+\
    -\n\x0b\n\x04\x05\0\x02\x18\x12\x03\x20\x081\n\x0c\n\x05\x05\0\x02\x18\
    \x01\x12\x03\x20\x08+\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03\x20.0\n\x0b\
    \n\x04\x05\0\x02\x19\x12\x03!\x081\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03\
    !\x08+\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03!.0\n\n\n\x02\x05\x01\x12\
    \x04$\0(\x01\n\n\n\x03\x05\x01\x01\x12\x03$\x05\x13\n\x0b\n\x04\x05\x01\
    \x02\0\x12\x03%\x08)\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03%\x08$\n\x0c\n\
    \x05\x05\x01\x02\0\x02\x12\x03%'(\n\x0b\n\x04\x05\x01\x02\x01\x12\x03&\
    \x08,\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03&\x08'\n\x0c\n\x05\x05\x01\
    \x02\x01\x02\x12\x03&*+\n\x0b\n\x04\x05\x01\x02\x02\x12\x03'\x08\x20\n\
    \x0c\n\x05\x05\x01\x02\x02\x01\x12\x03'\x08\x1b\n\x0c\n\x05\x05\x01\x02\
    \x02\x02\x12\x03'\x1e\x1f\n\n\n\x02\x04\0\x12\x04*\0<\x01\n\n\n\x03\x04\
    \0\x01\x12\x03*\x08\x15\n\x0b\n\x04\x04\0\x02\0\x12\x03+\x08'\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03+\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03+\x18\"\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03+%&\n\x0b\n\x04\x04\0\x02\x01\x12\x03,\x08&\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03,\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03,\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03,\x18!\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03,$%\n\x0b\n\x04\x04\0\x02\x02\x12\x03-\x08\
    .\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03-\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x02\x05\x12\x03-\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03-\x18)\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03-,-\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03.\x08+\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03.\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x03\x05\x12\x03.\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03.\x18&\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03.)*\n\x0b\n\x04\x04\0\
    \x02\x04\x12\x03/\x08(\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03/\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x04\x05\x12\x03/\x11\x17\n\x0c\n\x05\x04\0\x02\x04\
    \x01\x12\x03/\x18#\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03/&'\n\x0b\n\x04\
    \x04\0\x02\x05\x12\x030\x08'\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x030\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x030\x11\x17\n\x0c\n\x05\x04\0\
    \x02\x05\x01\x12\x030\x18\"\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x030%&\n\
    \x0b\n\x04\x04\0\x02\x06\x12\x031\x08)\n\x0c\n\x05\x04\0\x02\x06\x04\x12\
    \x031\x08\x10\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x031\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x06\x01\x12\x031\x18$\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x031'\
    (\n\x0b\n\x04\x04\0\x02\x07\x12\x032\x080\n\x0c\n\x05\x04\0\x02\x07\x04\
    \x12\x032\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x032\x11\x17\n\x0c\n\
    \x05\x04\0\x02\x07\x01\x12\x032\x18+\n\x0c\n\x05\x04\0\x02\x07\x03\x12\
    \x032./\n\x0b\n\x04\x04\0\x02\x08\x12\x033\x08/\n\x0c\n\x05\x04\0\x02\
    \x08\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x033\x11\x17\
    \n\x0c\n\x05\x04\0\x02\x08\x01\x12\x033\x18)\n\x0c\n\x05\x04\0\x02\x08\
    \x03\x12\x033,.\n\x0b\n\x04\x04\0\x02\t\x12\x034\x085\n\x0c\n\x05\x04\0\
    \x02\t\x04\x12\x034\x08\x10\n\x0c\n\x05\x04\0\x02\t\x05\x12\x034\x11\x17\
    \n\x0c\n\x05\x04\0\x02\t\x01\x12\x034\x18/\n\x0c\n\x05\x04\0\x02\t\x03\
    \x12\x03424\n\x0b\n\x04\x04\0\x02\n\x12\x035\x081\n\x0c\n\x05\x04\0\x02\
    \n\x04\x12\x035\x08\x10\n\x0c\n\x05\x04\0\x02\n\x05\x12\x035\x11\x17\n\
    \x0c\n\x05\x04\0\x02\n\x01\x12\x035\x18+\n\x0c\n\x05\x04\0\x02\n\x03\x12\
    \x035.0\n\x0b\n\x04\x04\0\x02\x0b\x12\x036\x083\n\x0c\n\x05\x04\0\x02\
    \x0b\x04\x12\x036\x08\x10\n\x0c\n\x05\x04\0\x02\x0b\x05\x12\x036\x11\x17\
    \n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x036\x18-\n\x0c\n\x05\x04\0\x02\x0b\
    \x03\x12\x03602\n\x0b\n\x04\x04\0\x02\x0c\x12\x037\x08+\n\x0c\n\x05\x04\
    \0\x02\x0c\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x037\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x037\x18%\n\x0c\n\x05\x04\0\
    \x02\x0c\x03\x12\x037(*\n\x0b\n\x04\x04\0\x02\r\x12\x038\x087\n\x0c\n\
    \x05\x04\0\x02\r\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\0\x02\r\x05\x12\
    \x038\x11\x17\n\x0c\n\x05\x04\0\x02\r\x01\x12\x038\x181\n\x0c\n\x05\x04\
    \0\x02\r\x03\x12\x03846\n\x0b\n\x04\x04\0\x02\x0e\x12\x039\x086\n\x0c\n\
    \x05\x04\0\x02\x0e\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\0\x02\x0e\x05\
    \x12\x039\x11\x17\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x039\x180\n\x0c\n\
    \x05\x04\0\x02\x0e\x03\x12\x03935\n\x0b\n\x04\x04\0\x02\x0f\x12\x03:\x08\
    2\n\x0c\n\x05\x04\0\x02\x0f\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x0f\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\0\x02\x0f\x01\x12\x03:\x18,\n\
    \x0c\n\x05\x04\0\x02\x0f\x03\x12\x03:/1\n\x0b\n\x04\x04\0\x02\x10\x12\
    \x03;\x08(\n\x0c\n\x05\x04\0\x02\x10\x04\x12\x03;\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x10\x05\x12\x03;\x11\x17\n\x0c\n\x05\x04\0\x02\x10\x01\x12\
    \x03;\x18\"\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x03;%'\n\n\n\x02\x04\x01\
    \x12\x04>\0K\x01\n\n\n\x03\x04\x01\x01\x12\x03>\x08\x18\n\x0c\n\x04\x04\
    \x01\x03\0\x12\x04?\x08F\t\n\x0c\n\x05\x04\x01\x03\0\x01\x12\x03?\x10\
    \x1b\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03@\x10-\n\x0e\n\x07\x04\x01\x03\
    \0\x02\0\x04\x12\x03@\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\0\x05\x12\
    \x03@\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\x12\x03@\x20(\n\x0e\n\
    \x07\x04\x01\x03\0\x02\0\x03\x12\x03@+,\n\r\n\x06\x04\x01\x03\0\x02\x01\
    \x12\x03A\x101\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x03A\x10\x18\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x03A\x19\x1f\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x01\x01\x12\x03A\x20,\n\x0e\n\x07\x04\x01\x03\0\x02\x01\
    \x03\x12\x03A/0\n\r\n\x06\x04\x01\x03\0\x02\x02\x12\x03B\x10/\n\x0e\n\
    \x07\x04\x01\x03\0\x02\x02\x04\x12\x03B\x10\x18\n\x0e\n\x07\x04\x01\x03\
    \0\x02\x02\x05\x12\x03B\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x02\x01\
    \x12\x03B\x20*\n\x0e\n\x07\x04\x01\x03\0\x02\x02\x03\x12\x03B-.\n\r\n\
    \x06\x04\x01\x03\0\x02\x03\x12\x03C\x106\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x03\x04\x12\x03C\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x05\x12\x03C\
    \x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x01\x12\x03C\x201\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x03\x03\x12\x03C45\n\r\n\x06\x04\x01\x03\0\x02\x04\
    \x12\x03D\x10<\n\x0e\n\x07\x04\x01\x03\0\x02\x04\x04\x12\x03D\x10\x18\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x04\x05\x12\x03D\x19\x1f\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x04\x01\x12\x03D\x207\n\x0e\n\x07\x04\x01\x03\0\x02\x04\
    \x03\x12\x03D:;\n\r\n\x06\x04\x01\x03\0\x02\x05\x12\x03E\x10=\n\x0e\n\
    \x07\x04\x01\x03\0\x02\x05\x04\x12\x03E\x10\x18\n\x0e\n\x07\x04\x01\x03\
    \0\x02\x05\x05\x12\x03E\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x05\x01\
    \x12\x03E\x208\n\x0e\n\x07\x04\x01\x03\0\x02\x05\x03\x12\x03E;<\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03H\x08.\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03H\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03H\x11\x1e\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03H\x1f)\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03H,-\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x03I\x08)\n\x0c\n\x05\x04\x01\x02\x01\x04\
    \x12\x03I\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03I\x11\x17\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x03I\x18$\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03I'(\n\x0b\n\x04\x04\x01\x02\x02\x12\x03J\x08?\n\x0c\n\x05\x04\
    \x01\x02\x02\x04\x12\x03J\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\
    \x03J\x11-\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03J.:\n\x0c\n\x05\x04\
    \x01\x02\x02\x03\x12\x03J=>\n\n\n\x02\x04\x02\x12\x04M\0R\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03M\x08\x15\n\x0b\n\x04\x04\x02\x02\0\x12\x03N\x08$\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03N\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03N\x18\x1f\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03N\"#\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03O\x08&\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03O\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03O\x18!\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03O$%\n\x0b\n\x04\
    \x04\x02\x02\x02\x12\x03P\x08'\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03P\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03P\x11\x17\n\x0c\n\x05\
    \x04\x02\x02\x02\x01\x12\x03P\x18\"\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\
    \x03P%&\n\x0b\n\x04\x04\x02\x02\x03\x12\x03Q\x08'\n\x0c\n\x05\x04\x02\
    \x02\x03\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03Q\
    \x11\x17\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03Q\x18\"\n\x0c\n\x05\x04\
    \x02\x02\x03\x03\x12\x03Q%&\n\n\n\x02\x04\x03\x12\x04T\0Y\x01\n\n\n\x03\
    \x04\x03\x01\x12\x03T\x08\x17\n\x0b\n\x04\x04\x03\x02\0\x12\x03U\x08.\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x03U\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03U\x18)\n\x0c\
    \n\x05\x04\x03\x02\0\x03\x12\x03U,-\n\x0b\n\x04\x04\x03\x02\x01\x12\x03V\
    \x08+\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x01\x05\x12\x03V\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\
    \x03V\x18&\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03V)*\n\x0b\n\x04\x04\
    \x03\x02\x02\x12\x03W\x084\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03W\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03W\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x02\x01\x12\x03W\x18/\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03W2\
    3\n\x0b\n\x04\x04\x03\x02\x03\x12\x03X\x089\n\x0c\n\x05\x04\x03\x02\x03\
    \x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03X\x11\x17\n\
    \x0c\n\x05\x04\x03\x02\x03\x01\x12\x03X\x184\n\x0c\n\x05\x04\x03\x02\x03\
    \x03\x12\x03X78\n\n\n\x02\x04\x04\x12\x04[\0_\x01\n\n\n\x03\x04\x04\x01\
    \x12\x03[\x08\x17\n\x0b\n\x04\x04\x04\x02\0\x12\x03\\\x081\n\x0c\n\x05\
    \x04\x04\x02\0\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x03\\\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\\\x18,\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03\\/0\n\x0b\n\x04\x04\x04\x02\x01\x12\x03]\x08.\
    \n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03]\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x01\x05\x12\x03]\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03]\
    \x18)\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03],-\n\x0b\n\x04\x04\x04\x02\
    \x02\x12\x03^\x08+\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03^\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x02\x05\x12\x03^\x11\x17\n\x0c\n\x05\x04\x04\x02\
    \x02\x01\x12\x03^\x18&\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03^)*\n\n\n\
    \x02\x04\x05\x12\x04a\0g\x01\n\n\n\x03\x04\x05\x01\x12\x03a\x08\x15\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x03b\x08%\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03b\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03b\x11\x17\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03b\x18\x20\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03b#$\n\x0b\n\x04\x04\x05\x02\x01\x12\x03c\x08.\n\x0c\n\x05\x04\x05\
    \x02\x01\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03c\
    \x11\x1e\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03c\x1f)\n\x0c\n\x05\x04\
    \x05\x02\x01\x03\x12\x03c,-\n\x0b\n\x04\x04\x05\x02\x02\x12\x03d\x08/\n\
    \x0c\n\x05\x04\x05\x02\x02\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x05\x02\
    \x02\x06\x12\x03d\x11\x1e\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03d\x1f*\
    \n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03d-.\n\x0b\n\x04\x04\x05\x02\x03\
    \x12\x03e\x083\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03e\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\x03\x06\x12\x03e\x11\x20\n\x0c\n\x05\x04\x05\x02\x03\
    \x01\x12\x03e!.\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03e12\n\x0b\n\x04\
    \x04\x05\x02\x04\x12\x03f\x083\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x03f\
    \x08\x10\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\x03f\x11\x20\n\x0c\n\x05\
    \x04\x05\x02\x04\x01\x12\x03f!.\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03f\
    12\n\n\n\x02\x04\x06\x12\x04i\0m\x01\n\n\n\x03\x04\x06\x01\x12\x03i\x08\
    \x1e\n\x0b\n\x04\x04\x06\x02\0\x12\x03j\x08%\n\x0c\n\x05\x04\x06\x02\0\
    \x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03j\x11\x17\n\
    \x0c\n\x05\x04\x06\x02\0\x01\x12\x03j\x18\x20\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03j#$\n\x0b\n\x04\x04\x06\x02\x01\x12\x03k\x081\n\x0c\n\x05\
    \x04\x06\x02\x01\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\
    \x12\x03k\x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03k\x18,\n\x0c\n\
    \x05\x04\x06\x02\x01\x03\x12\x03k/0\n\x0b\n\x04\x04\x06\x02\x02\x12\x03l\
    \x08+\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\
    \x06\x02\x02\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\
    \x03l\x18&\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03l)*\n\n\n\x02\x04\x07\
    \x12\x04o\0r\x01\n\n\n\x03\x04\x07\x01\x12\x03o\x08#\n\x0b\n\x04\x04\x07\
    \x02\0\x12\x03p\x08&\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03p\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\0\x05\x12\x03p\x11\x17\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03p\x18!\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03p$%\n\x0b\n\x04\
    \x04\x07\x02\x01\x12\x03q\x08:\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03q\
    \x08\x10\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03q\x11'\n\x0c\n\x05\x04\
    \x07\x02\x01\x01\x12\x03q(5\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03q89\n\
    \n\n\x02\x04\x08\x12\x04t\0x\x01\n\n\n\x03\x04\x08\x01\x12\x03t\x08\x1c\
    \n\x0b\n\x04\x04\x08\x02\0\x12\x03u\x08%\n\x0c\n\x05\x04\x08\x02\0\x04\
    \x12\x03u\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03u\x11\x17\n\x0c\n\
    \x05\x04\x08\x02\0\x01\x12\x03u\x18\x20\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x03u#$\n\x0b\n\x04\x04\x08\x02\x01\x12\x03v\x08&\n\x0c\n\x05\x04\
    \x08\x02\x01\x04\x12\x03v\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\
    \x03v\x11\x17\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03v\x18!\n\x0c\n\x05\
    \x04\x08\x02\x01\x03\x12\x03v$%\n\x0b\n\x04\x04\x08\x02\x02\x12\x03w\x08\
    (\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\x08\
    \x02\x02\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03w\
    \x18#\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03w&'\n\n\n\x02\x04\t\x12\x04\
    z\0|\x01\n\n\n\x03\x04\t\x01\x12\x03z\x08$\n\x0b\n\x04\x04\t\x02\0\x12\
    \x03{\x08>\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\
    \t\x02\0\x06\x12\x03{\x11%\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03{&9\n\x0c\
    \n\x05\x04\t\x02\0\x03\x12\x03{<=\n\x0b\n\x02\x04\n\x12\x05~\0\x85\x01\
    \x01\n\n\n\x03\x04\n\x01\x12\x03~\x08\x1a\n\x0b\n\x04\x04\n\x02\0\x12\
    \x03\x7f\x08*\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03\x7f\x08\x10\n\x0c\n\
    \x05\x04\n\x02\0\x05\x12\x03\x7f\x11\x17\n\x0c\n\x05\x04\n\x02\0\x01\x12\
    \x03\x7f\x18%\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03\x7f()\n\x0c\n\x04\x04\
    \n\x02\x01\x12\x04\x80\x01\x08&\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x80\
    \x01\x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x80\x01\x11\x17\n\r\n\
    \x05\x04\n\x02\x01\x01\x12\x04\x80\x01\x18!\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\x80\x01$%\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x81\x01\x08'\n\r\n\
    \x05\x04\n\x02\x02\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\n\x02\x02\
    \x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x81\x01\
    \x18\"\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x81\x01%&\n\x0c\n\x04\x04\n\
    \x02\x03\x12\x04\x82\x01\x08)\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\x82\
    \x01\x08\x10\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\x82\x01\x11\x17\n\r\n\
    \x05\x04\n\x02\x03\x01\x12\x04\x82\x01\x18$\n\r\n\x05\x04\n\x02\x03\x03\
    \x12\x04\x82\x01'(\n\x0c\n\x04\x04\n\x02\x04\x12\x04\x83\x01\x08)\n\r\n\
    \x05\x04\n\x02\x04\x04\x12\x04\x83\x01\x08\x10\n\r\n\x05\x04\n\x02\x04\
    \x05\x12\x04\x83\x01\x11\x17\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x83\x01\
    \x18$\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\x83\x01'(\n\x0c\n\x04\x04\n\
    \x02\x05\x12\x04\x84\x01\x08)\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\x84\
    \x01\x08\x10\n\r\n\x05\x04\n\x02\x05\x05\x12\x04\x84\x01\x11\x17\n\r\n\
    \x05\x04\n\x02\x05\x01\x12\x04\x84\x01\x18$\n\r\n\x05\x04\n\x02\x05\x03\
    \x12\x04\x84\x01'(\n\x0c\n\x02\x04\x0b\x12\x06\x87\x01\0\x8a\x01\x01\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\x87\x01\x08!\n\x0c\n\x04\x04\x0b\x02\0\
    \x12\x04\x88\x01\x08.\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x88\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\x88\x01\x11\x1e\n\r\n\x05\x04\
    \x0b\x02\0\x01\x12\x04\x88\x01\x1f)\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \x88\x01,-\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x89\x01\x084\n\r\n\x05\
    \x04\x0b\x02\x01\x04\x12\x04\x89\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\
    \x06\x12\x04\x89\x01\x11\x1f\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x89\
    \x01\x20/\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x89\x0123\n\x0c\n\x02\
    \x04\x0c\x12\x06\x8c\x01\0\xa2\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\
    \x8c\x01\x08)\n\x0e\n\x04\x04\x0c\x04\0\x12\x06\x8d\x01\x08\x9e\x01\t\n\
    \r\n\x05\x04\x0c\x04\0\x01\x12\x04\x8d\x01\r\x16\n\x0e\n\x06\x04\x0c\x04\
    \0\x02\0\x12\x04\x8e\x01\x10%\n\x0f\n\x07\x04\x0c\x04\0\x02\0\x01\x12\
    \x04\x8e\x01\x10\x20\n\x0f\n\x07\x04\x0c\x04\0\x02\0\x02\x12\x04\x8e\x01\
    #$\n\x0e\n\x06\x04\x0c\x04\0\x02\x01\x12\x04\x8f\x01\x10\x1f\n\x0f\n\x07\
    \x04\x0c\x04\0\x02\x01\x01\x12\x04\x8f\x01\x10\x1a\n\x0f\n\x07\x04\x0c\
    \x04\0\x02\x01\x02\x12\x04\x8f\x01\x1d\x1e\n\x0e\n\x06\x04\x0c\x04\0\x02\
    \x02\x12\x04\x90\x01\x10\x1f\n\x0f\n\x07\x04\x0c\x04\0\x02\x02\x01\x12\
    \x04\x90\x01\x10\x1a\n\x0f\n\x07\x04\x0c\x04\0\x02\x02\x02\x12\x04\x90\
    \x01\x1d\x1e\n\x0e\n\x06\x04\x0c\x04\0\x02\x03\x12\x04\x91\x01\x10\x20\n\
    \x0f\n\x07\x04\x0c\x04\0\x02\x03\x01\x12\x04\x91\x01\x10\x1b\n\x0f\n\x07\
    \x04\x0c\x04\0\x02\x03\x02\x12\x04\x91\x01\x1e\x1f\n\x0e\n\x06\x04\x0c\
    \x04\0\x02\x04\x12\x04\x92\x01\x10\x1f\n\x0f\n\x07\x04\x0c\x04\0\x02\x04\
    \x01\x12\x04\x92\x01\x10\x1a\n\x0f\n\x07\x04\x0c\x04\0\x02\x04\x02\x12\
    \x04\x92\x01\x1d\x1e\n\x0e\n\x06\x04\x0c\x04\0\x02\x05\x12\x04\x93\x01\
    \x10#\n\x0f\n\x07\x04\x0c\x04\0\x02\x05\x01\x12\x04\x93\x01\x10\x1e\n\
    \x0f\n\x07\x04\x0c\x04\0\x02\x05\x02\x12\x04\x93\x01!\"\n\x0e\n\x06\x04\
    \x0c\x04\0\x02\x06\x12\x04\x94\x01\x10'\n\x0f\n\x07\x04\x0c\x04\0\x02\
    \x06\x01\x12\x04\x94\x01\x10\"\n\x0f\n\x07\x04\x0c\x04\0\x02\x06\x02\x12\
    \x04\x94\x01%&\n\x0e\n\x06\x04\x0c\x04\0\x02\x07\x12\x04\x95\x01\x10\"\n\
    \x0f\n\x07\x04\x0c\x04\0\x02\x07\x01\x12\x04\x95\x01\x10\x1d\n\x0f\n\x07\
    \x04\x0c\x04\0\x02\x07\x02\x12\x04\x95\x01\x20!\n\x0e\n\x06\x04\x0c\x04\
    \0\x02\x08\x12\x04\x96\x01\x10&\n\x0f\n\x07\x04\x0c\x04\0\x02\x08\x01\
    \x12\x04\x96\x01\x10!\n\x0f\n\x07\x04\x0c\x04\0\x02\x08\x02\x12\x04\x96\
    \x01$%\n\x0e\n\x06\x04\x0c\x04\0\x02\t\x12\x04\x97\x01\x10*\n\x0f\n\x07\
    \x04\x0c\x04\0\x02\t\x01\x12\x04\x97\x01\x10%\n\x0f\n\x07\x04\x0c\x04\0\
    \x02\t\x02\x12\x04\x97\x01()\n\x0e\n\x06\x04\x0c\x04\0\x02\n\x12\x04\x98\
    \x01\x10&\n\x0f\n\x07\x04\x0c\x04\0\x02\n\x01\x12\x04\x98\x01\x10\x20\n\
    \x0f\n\x07\x04\x0c\x04\0\x02\n\x02\x12\x04\x98\x01#%\n\x0e\n\x06\x04\x0c\
    \x04\0\x02\x0b\x12\x04\x99\x01\x10$\n\x0f\n\x07\x04\x0c\x04\0\x02\x0b\
    \x01\x12\x04\x99\x01\x10\x1e\n\x0f\n\x07\x04\x0c\x04\0\x02\x0b\x02\x12\
    \x04\x99\x01!#\n\x0e\n\x06\x04\x0c\x04\0\x02\x0c\x12\x04\x9a\x01\x10(\n\
    \x0f\n\x07\x04\x0c\x04\0\x02\x0c\x01\x12\x04\x9a\x01\x10\"\n\x0f\n\x07\
    \x04\x0c\x04\0\x02\x0c\x02\x12\x04\x9a\x01%'\n\x0e\n\x06\x04\x0c\x04\0\
    \x02\r\x12\x04\x9b\x01\x10#\n\x0f\n\x07\x04\x0c\x04\0\x02\r\x01\x12\x04\
    \x9b\x01\x10\x1d\n\x0f\n\x07\x04\x0c\x04\0\x02\r\x02\x12\x04\x9b\x01\x20\
    \"\n\x0e\n\x06\x04\x0c\x04\0\x02\x0e\x12\x04\x9c\x01\x10$\n\x0f\n\x07\
    \x04\x0c\x04\0\x02\x0e\x01\x12\x04\x9c\x01\x10\x1e\n\x0f\n\x07\x04\x0c\
    \x04\0\x02\x0e\x02\x12\x04\x9c\x01!#\n\x0e\n\x06\x04\x0c\x04\0\x02\x0f\
    \x12\x04\x9d\x01\x10\x20\n\x0f\n\x07\x04\x0c\x04\0\x02\x0f\x01\x12\x04\
    \x9d\x01\x10\x1a\n\x0f\n\x07\x04\x0c\x04\0\x02\x0f\x02\x12\x04\x9d\x01\
    \x1d\x1f\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xa0\x01\x08H\n\r\n\x05\x04\
    \x0c\x02\0\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\x12\
    \x04\xa0\x01\x11<\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa0\x01=C\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\xa0\x01FG\n\x0c\n\x04\x04\x0c\x02\x01\x12\
    \x04\xa1\x01\x08%\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xa1\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xa1\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\xa1\x01\x18\x20\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\xa1\x01#$\n\x0c\n\x02\x04\r\x12\x06\xa4\x01\0\xa8\x01\x01\n\x0b\n\
    \x03\x04\r\x01\x12\x04\xa4\x01\x08\"\n\x0c\n\x04\x04\r\x02\0\x12\x04\xa5\
    \x01\x08%\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\0\x05\x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\xa5\x01\x18\x20\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa5\x01#$\n\x0c\n\
    \x04\x04\r\x02\x01\x12\x04\xa6\x01\x08.\n\r\n\x05\x04\r\x02\x01\x04\x12\
    \x04\xa6\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xa6\x01\x11\x1e\
    \n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa6\x01\x1f)\n\r\n\x05\x04\r\x02\
    \x01\x03\x12\x04\xa6\x01,-\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xa7\x01\x08\
    4\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\r\
    \x02\x02\x06\x12\x04\xa7\x01\x11\x1f\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\
    \xa7\x01\x20/\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xa7\x0123\n\x0c\n\x02\
    \x04\x0e\x12\x06\xaa\x01\0\xbe\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\
    \xaa\x01\x08*\n\x0e\n\x04\x04\x0e\x04\0\x12\x06\xab\x01\x08\xbb\x01\t\n\
    \r\n\x05\x04\x0e\x04\0\x01\x12\x04\xab\x01\r\x16\n\x0e\n\x06\x04\x0e\x04\
    \0\x02\0\x12\x04\xac\x01\x10%\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\
    \x04\xac\x01\x10\x20\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xac\x01\
    #$\n\x0e\n\x06\x04\x0e\x04\0\x02\x01\x12\x04\xad\x01\x10\x1f\n\x0f\n\x07\
    \x04\x0e\x04\0\x02\x01\x01\x12\x04\xad\x01\x10\x1a\n\x0f\n\x07\x04\x0e\
    \x04\0\x02\x01\x02\x12\x04\xad\x01\x1d\x1e\n\x0e\n\x06\x04\x0e\x04\0\x02\
    \x02\x12\x04\xae\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x01\x12\
    \x04\xae\x01\x10\x1a\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x02\x12\x04\xae\
    \x01\x1d\x1e\n\x0e\n\x06\x04\x0e\x04\0\x02\x03\x12\x04\xaf\x01\x10\x20\n\
    \x0f\n\x07\x04\x0e\x04\0\x02\x03\x01\x12\x04\xaf\x01\x10\x1b\n\x0f\n\x07\
    \x04\x0e\x04\0\x02\x03\x02\x12\x04\xaf\x01\x1e\x1f\n\x0e\n\x06\x04\x0e\
    \x04\0\x02\x04\x12\x04\xb0\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\
    \x01\x12\x04\xb0\x01\x10\x1a\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\x02\x12\
    \x04\xb0\x01\x1d\x1e\n\x0e\n\x06\x04\x0e\x04\0\x02\x05\x12\x04\xb1\x01\
    \x10$\n\x0f\n\x07\x04\x0e\x04\0\x02\x05\x01\x12\x04\xb1\x01\x10\x1f\n\
    \x0f\n\x07\x04\x0e\x04\0\x02\x05\x02\x12\x04\xb1\x01\"#\n\x0e\n\x06\x04\
    \x0e\x04\0\x02\x06\x12\x04\xb2\x01\x10!\n\x0f\n\x07\x04\x0e\x04\0\x02\
    \x06\x01\x12\x04\xb2\x01\x10\x1c\n\x0f\n\x07\x04\x0e\x04\0\x02\x06\x02\
    \x12\x04\xb2\x01\x1f\x20\n\x0e\n\x06\x04\x0e\x04\0\x02\x07\x12\x04\xb3\
    \x01\x10$\n\x0f\n\x07\x04\x0e\x04\0\x02\x07\x01\x12\x04\xb3\x01\x10\x1f\
    \n\x0f\n\x07\x04\x0e\x04\0\x02\x07\x02\x12\x04\xb3\x01\"#\n\x0e\n\x06\
    \x04\x0e\x04\0\x02\x08\x12\x04\xb4\x01\x10#\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x08\x01\x12\x04\xb4\x01\x10\x1e\n\x0f\n\x07\x04\x0e\x04\0\x02\x08\
    \x02\x12\x04\xb4\x01!\"\n\x0e\n\x06\x04\x0e\x04\0\x02\t\x12\x04\xb5\x01\
    \x10/\n\x0f\n\x07\x04\x0e\x04\0\x02\t\x01\x12\x04\xb5\x01\x10*\n\x0f\n\
    \x07\x04\x0e\x04\0\x02\t\x02\x12\x04\xb5\x01-.\n\x0e\n\x06\x04\x0e\x04\0\
    \x02\n\x12\x04\xb6\x01\x10/\n\x0f\n\x07\x04\x0e\x04\0\x02\n\x01\x12\x04\
    \xb6\x01\x10)\n\x0f\n\x07\x04\x0e\x04\0\x02\n\x02\x12\x04\xb6\x01,.\n\
    \x0e\n\x06\x04\x0e\x04\0\x02\x0b\x12\x04\xb7\x01\x10$\n\x0f\n\x07\x04\
    \x0e\x04\0\x02\x0b\x01\x12\x04\xb7\x01\x10\x1e\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x0b\x02\x12\x04\xb7\x01!#\n\x0e\n\x06\x04\x0e\x04\0\x02\x0c\x12\x04\
    \xb8\x01\x10#\n\x0f\n\x07\x04\x0e\x04\0\x02\x0c\x01\x12\x04\xb8\x01\x10\
    \x1d\n\x0f\n\x07\x04\x0e\x04\0\x02\x0c\x02\x12\x04\xb8\x01\x20\"\n\x0e\n\
    \x06\x04\x0e\x04\0\x02\r\x12\x04\xb9\x01\x10+\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\r\x01\x12\x04\xb9\x01\x10%\n\x0f\n\x07\x04\x0e\x04\0\x02\r\x02\x12\
    \x04\xb9\x01(*\n\x0e\n\x06\x04\x0e\x04\0\x02\x0e\x12\x04\xba\x01\x10\x20\
    \n\x0f\n\x07\x04\x0e\x04\0\x02\x0e\x01\x12\x04\xba\x01\x10\x1a\n\x0f\n\
    \x07\x04\x0e\x04\0\x02\x0e\x02\x12\x04\xba\x01\x1d\x1f\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\xbd\x01\x08I\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xbd\
    \x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xbd\x01\x11=\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xbd\x01>D\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\
    \xbd\x01GH\n\x0c\n\x02\x04\x0f\x12\x06\xc0\x01\0\xc2\x01\x01\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\xc0\x01\x08&\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xc1\
    \x01\x08%\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\
    \x04\x0f\x02\0\x05\x12\x04\xc1\x01\x11\x17\n\r\n\x05\x04\x0f\x02\0\x01\
    \x12\x04\xc1\x01\x18\x20\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xc1\x01#$\n\
    \x0c\n\x02\x04\x10\x12\x06\xc4\x01\0\xd1\x01\x01\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\xc4\x01\x08.\n\x0e\n\x04\x04\x10\x04\0\x12\x06\xc5\x01\x08\xcd\
    \x01\t\n\r\n\x05\x04\x10\x04\0\x01\x12\x04\xc5\x01\r\x16\n\x0e\n\x06\x04\
    \x10\x04\0\x02\0\x12\x04\xc6\x01\x10%\n\x0f\n\x07\x04\x10\x04\0\x02\0\
    \x01\x12\x04\xc6\x01\x10\x20\n\x0f\n\x07\x04\x10\x04\0\x02\0\x02\x12\x04\
    \xc6\x01#$\n\x0e\n\x06\x04\x10\x04\0\x02\x01\x12\x04\xc7\x01\x10\x1f\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x01\x01\x12\x04\xc7\x01\x10\x1a\n\x0f\n\x07\
    \x04\x10\x04\0\x02\x01\x02\x12\x04\xc7\x01\x1d\x1e\n\x0e\n\x06\x04\x10\
    \x04\0\x02\x02\x12\x04\xc8\x01\x10\x1f\n\x0f\n\x07\x04\x10\x04\0\x02\x02\
    \x01\x12\x04\xc8\x01\x10\x1a\n\x0f\n\x07\x04\x10\x04\0\x02\x02\x02\x12\
    \x04\xc8\x01\x1d\x1e\n\x0e\n\x06\x04\x10\x04\0\x02\x03\x12\x04\xc9\x01\
    \x10\x20\n\x0f\n\x07\x04\x10\x04\0\x02\x03\x01\x12\x04\xc9\x01\x10\x1b\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x03\x02\x12\x04\xc9\x01\x1e\x1f\n\x0e\n\x06\
    \x04\x10\x04\0\x02\x04\x12\x04\xca\x01\x10\x1f\n\x0f\n\x07\x04\x10\x04\0\
    \x02\x04\x01\x12\x04\xca\x01\x10\x1a\n\x0f\n\x07\x04\x10\x04\0\x02\x04\
    \x02\x12\x04\xca\x01\x1d\x1e\n\x0e\n\x06\x04\x10\x04\0\x02\x05\x12\x04\
    \xcb\x01\x10$\n\x0f\n\x07\x04\x10\x04\0\x02\x05\x01\x12\x04\xcb\x01\x10\
    \x1f\n\x0f\n\x07\x04\x10\x04\0\x02\x05\x02\x12\x04\xcb\x01\"#\n\x0e\n\
    \x06\x04\x10\x04\0\x02\x06\x12\x04\xcc\x01\x10!\n\x0f\n\x07\x04\x10\x04\
    \0\x02\x06\x01\x12\x04\xcc\x01\x10\x1c\n\x0f\n\x07\x04\x10\x04\0\x02\x06\
    \x02\x12\x04\xcc\x01\x1f\x20\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xcf\x01\
    \x08M\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xcf\x01\x08\x10\n\r\n\x05\x04\
    \x10\x02\0\x06\x12\x04\xcf\x01\x11A\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xcf\x01BH\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xcf\x01KL\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\xd0\x01\x08.\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\
    \xd0\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xd0\x01\x11\x1e\n\
    \r\n\x05\x04\x10\x02\x01\x01\x12\x04\xd0\x01\x1f)\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\xd0\x01,-\n\x0c\n\x02\x04\x11\x12\x06\xd3\x01\0\xd6\x01\
    \x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xd3\x01\x08&\n\x0c\n\x04\x04\x11\
    \x02\0\x12\x04\xd4\x01\x08.\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xd4\x01\
    \x08\x10\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xd4\x01\x11\x1e\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\xd4\x01\x1f)\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\xd4\x01,-\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xd5\x01\x08)\n\r\n\
    \x05\x04\x11\x02\x01\x04\x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x11\x02\
    \x01\x05\x12\x04\xd5\x01\x11\x17\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \xd5\x01\x18$\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xd5\x01'(\n\x0c\n\
    \x02\x04\x12\x12\x06\xd8\x01\0\xdb\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xd8\x01\x08-\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xd9\x01\x08%\n\r\n\
    \x05\x04\x12\x02\0\x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\
    \x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xd9\x01\
    \x18\x20\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xd9\x01#$\n\x0c\n\x04\x04\
    \x12\x02\x01\x12\x04\xda\x01\x082\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\
    \xda\x01\x08\x10\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xda\x01\x11\x20\n\
    \r\n\x05\x04\x12\x02\x01\x01\x12\x04\xda\x01!-\n\r\n\x05\x04\x12\x02\x01\
    \x03\x12\x04\xda\x0101\n\x0c\n\x02\x04\x13\x12\x06\xdd\x01\0\xde\x01\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xdd\x01\x08,\n\x0c\n\x02\x04\x14\x12\
    \x06\xe0\x01\0\xeb\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xe0\x01\x084\
    \n\x0e\n\x04\x04\x14\x04\0\x12\x06\xe1\x01\x08\xe7\x01\t\n\r\n\x05\x04\
    \x14\x04\0\x01\x12\x04\xe1\x01\r\x16\n\x0e\n\x06\x04\x14\x04\0\x02\0\x12\
    \x04\xe2\x01\x10%\n\x0f\n\x07\x04\x14\x04\0\x02\0\x01\x12\x04\xe2\x01\
    \x10\x20\n\x0f\n\x07\x04\x14\x04\0\x02\0\x02\x12\x04\xe2\x01#$\n\x0e\n\
    \x06\x04\x14\x04\0\x02\x01\x12\x04\xe3\x01\x10\x1f\n\x0f\n\x07\x04\x14\
    \x04\0\x02\x01\x01\x12\x04\xe3\x01\x10\x1a\n\x0f\n\x07\x04\x14\x04\0\x02\
    \x01\x02\x12\x04\xe3\x01\x1d\x1e\n\x0e\n\x06\x04\x14\x04\0\x02\x02\x12\
    \x04\xe4\x01\x10\x1f\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x01\x12\x04\xe4\
    \x01\x10\x1a\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x02\x12\x04\xe4\x01\x1d\
    \x1e\n\x0e\n\x06\x04\x14\x04\0\x02\x03\x12\x04\xe5\x01\x10\x20\n\x0f\n\
    \x07\x04\x14\x04\0\x02\x03\x01\x12\x04\xe5\x01\x10\x1b\n\x0f\n\x07\x04\
    \x14\x04\0\x02\x03\x02\x12\x04\xe5\x01\x1e\x1f\n\x0e\n\x06\x04\x14\x04\0\
    \x02\x04\x12\x04\xe6\x01\x10\x1f\n\x0f\n\x07\x04\x14\x04\0\x02\x04\x01\
    \x12\x04\xe6\x01\x10\x1a\n\x0f\n\x07\x04\x14\x04\0\x02\x04\x02\x12\x04\
    \xe6\x01\x1d\x1e\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xe9\x01\x08S\n\r\n\
    \x05\x04\x14\x02\0\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x14\x02\0\
    \x06\x12\x04\xe9\x01\x11G\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xe9\x01HN\
    \n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xe9\x01QR\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\xea\x01\x08C\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xea\x01\
    \x08\x10\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xea\x01\x11,\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\xea\x01->\n\r\n\x05\x04\x14\x02\x01\x03\x12\
    \x04\xea\x01AB\n\x0c\n\x02\x04\x15\x12\x06\xed\x01\0\xef\x01\x01\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xed\x01\x08,\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xee\x01\x08C\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xee\x01\x08\x10\n\r\n\
    \x05\x04\x15\x02\0\x06\x12\x04\xee\x01\x11,\n\r\n\x05\x04\x15\x02\0\x01\
    \x12\x04\xee\x01->\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xee\x01AB\n\x0c\n\
    \x02\x04\x16\x12\x06\xf1\x01\0\xf3\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\xf1\x01\x08\x1f\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xf2\x01\x08%\n\r\
    \n\x05\x04\x16\x02\0\x04\x12\x04\xf2\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\
    \x05\x12\x04\xf2\x01\x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xf2\x01\
    \x18\x20\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xf2\x01#$\n\x0c\n\x02\x04\
    \x17\x12\x06\xf5\x01\0\x85\x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xf5\
    \x01\x08'\n\x0e\n\x04\x04\x17\x04\0\x12\x06\xf6\x01\x08\x82\x02\t\n\r\n\
    \x05\x04\x17\x04\0\x01\x12\x04\xf6\x01\r\x16\n\x0e\n\x06\x04\x17\x04\0\
    \x02\0\x12\x04\xf7\x01\x10%\n\x0f\n\x07\x04\x17\x04\0\x02\0\x01\x12\x04\
    \xf7\x01\x10\x20\n\x0f\n\x07\x04\x17\x04\0\x02\0\x02\x12\x04\xf7\x01#$\n\
    \x0e\n\x06\x04\x17\x04\0\x02\x01\x12\x04\xf8\x01\x10\x1f\n\x0f\n\x07\x04\
    \x17\x04\0\x02\x01\x01\x12\x04\xf8\x01\x10\x1a\n\x0f\n\x07\x04\x17\x04\0\
    \x02\x01\x02\x12\x04\xf8\x01\x1d\x1e\n\x0e\n\x06\x04\x17\x04\0\x02\x02\
    \x12\x04\xf9\x01\x10\x1f\n\x0f\n\x07\x04\x17\x04\0\x02\x02\x01\x12\x04\
    \xf9\x01\x10\x1a\n\x0f\n\x07\x04\x17\x04\0\x02\x02\x02\x12\x04\xf9\x01\
    \x1d\x1e\n\x0e\n\x06\x04\x17\x04\0\x02\x03\x12\x04\xfa\x01\x10\x20\n\x0f\
    \n\x07\x04\x17\x04\0\x02\x03\x01\x12\x04\xfa\x01\x10\x1b\n\x0f\n\x07\x04\
    \x17\x04\0\x02\x03\x02\x12\x04\xfa\x01\x1e\x1f\n\x0e\n\x06\x04\x17\x04\0\
    \x02\x04\x12\x04\xfb\x01\x10\x1f\n\x0f\n\x07\x04\x17\x04\0\x02\x04\x01\
    \x12\x04\xfb\x01\x10\x1a\n\x0f\n\x07\x04\x17\x04\0\x02\x04\x02\x12\x04\
    \xfb\x01\x1d\x1e\n\x0e\n\x06\x04\x17\x04\0\x02\x05\x12\x04\xfc\x01\x10$\
    \n\x0f\n\x07\x04\x17\x04\0\x02\x05\x01\x12\x04\xfc\x01\x10\x1f\n\x0f\n\
    \x07\x04\x17\x04\0\x02\x05\x02\x12\x04\xfc\x01\"#\n\x0e\n\x06\x04\x17\
    \x04\0\x02\x06\x12\x04\xfd\x01\x10!\n\x0f\n\x07\x04\x17\x04\0\x02\x06\
    \x01\x12\x04\xfd\x01\x10\x1c\n\x0f\n\x07\x04\x17\x04\0\x02\x06\x02\x12\
    \x04\xfd\x01\x1f\x20\n\x0e\n\x06\x04\x17\x04\0\x02\x07\x12\x04\xfe\x01\
    \x10%\n\x0f\n\x07\x04\x17\x04\0\x02\x07\x01\x12\x04\xfe\x01\x10\x20\n\
    \x0f\n\x07\x04\x17\x04\0\x02\x07\x02\x12\x04\xfe\x01#$\n\x0e\n\x06\x04\
    \x17\x04\0\x02\x08\x12\x04\xff\x01\x10\"\n\x0f\n\x07\x04\x17\x04\0\x02\
    \x08\x01\x12\x04\xff\x01\x10\x1d\n\x0f\n\x07\x04\x17\x04\0\x02\x08\x02\
    \x12\x04\xff\x01\x20!\n\x0e\n\x06\x04\x17\x04\0\x02\t\x12\x04\x80\x02\
    \x10+\n\x0f\n\x07\x04\x17\x04\0\x02\t\x01\x12\x04\x80\x02\x10&\n\x0f\n\
    \x07\x04\x17\x04\0\x02\t\x02\x12\x04\x80\x02)*\n\x0e\n\x06\x04\x17\x04\0\
    \x02\n\x12\x04\x81\x02\x10(\n\x0f\n\x07\x04\x17\x04\0\x02\n\x01\x12\x04\
    \x81\x02\x10\"\n\x0f\n\x07\x04\x17\x04\0\x02\n\x02\x12\x04\x81\x02%'\n\
    \x0c\n\x04\x04\x17\x02\0\x12\x04\x84\x02\x08F\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\x84\x02\x08\x10\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\x84\x02\
    \x11:\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x84\x02;A\n\r\n\x05\x04\x17\
    \x02\0\x03\x12\x04\x84\x02DE\n\x0c\n\x02\x04\x18\x12\x06\x87\x02\0\x89\
    \x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x87\x02\x08\x20\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\x88\x02\x08%\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\x88\
    \x02\x08\x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\x88\x02\x11\x17\n\r\n\
    \x05\x04\x18\x02\0\x01\x12\x04\x88\x02\x18\x20\n\r\n\x05\x04\x18\x02\0\
    \x03\x12\x04\x88\x02#$\n\x0c\n\x02\x04\x19\x12\x06\x8b\x02\0\x98\x02\x01\
    \n\x0b\n\x03\x04\x19\x01\x12\x04\x8b\x02\x08(\n\x0e\n\x04\x04\x19\x04\0\
    \x12\x06\x8c\x02\x08\x95\x02\t\n\r\n\x05\x04\x19\x04\0\x01\x12\x04\x8c\
    \x02\r\x16\n\x0e\n\x06\x04\x19\x04\0\x02\0\x12\x04\x8d\x02\x10%\n\x0f\n\
    \x07\x04\x19\x04\0\x02\0\x01\x12\x04\x8d\x02\x10\x20\n\x0f\n\x07\x04\x19\
    \x04\0\x02\0\x02\x12\x04\x8d\x02#$\n\x0e\n\x06\x04\x19\x04\0\x02\x01\x12\
    \x04\x8e\x02\x10\x1f\n\x0f\n\x07\x04\x19\x04\0\x02\x01\x01\x12\x04\x8e\
    \x02\x10\x1a\n\x0f\n\x07\x04\x19\x04\0\x02\x01\x02\x12\x04\x8e\x02\x1d\
    \x1e\n\x0e\n\x06\x04\x19\x04\0\x02\x02\x12\x04\x8f\x02\x10\x1f\n\x0f\n\
    \x07\x04\x19\x04\0\x02\x02\x01\x12\x04\x8f\x02\x10\x1a\n\x0f\n\x07\x04\
    \x19\x04\0\x02\x02\x02\x12\x04\x8f\x02\x1d\x1e\n\x0e\n\x06\x04\x19\x04\0\
    \x02\x03\x12\x04\x90\x02\x10\x20\n\x0f\n\x07\x04\x19\x04\0\x02\x03\x01\
    \x12\x04\x90\x02\x10\x1b\n\x0f\n\x07\x04\x19\x04\0\x02\x03\x02\x12\x04\
    \x90\x02\x1e\x1f\n\x0e\n\x06\x04\x19\x04\0\x02\x04\x12\x04\x91\x02\x10\
    \x1f\n\x0f\n\x07\x04\x19\x04\0\x02\x04\x01\x12\x04\x91\x02\x10\x1a\n\x0f\
    \n\x07\x04\x19\x04\0\x02\x04\x02\x12\x04\x91\x02\x1d\x1e\n\x0e\n\x06\x04\
    \x19\x04\0\x02\x05\x12\x04\x92\x02\x10$\n\x0f\n\x07\x04\x19\x04\0\x02\
    \x05\x01\x12\x04\x92\x02\x10\x1f\n\x0f\n\x07\x04\x19\x04\0\x02\x05\x02\
    \x12\x04\x92\x02\"#\n\x0e\n\x06\x04\x19\x04\0\x02\x06\x12\x04\x93\x02\
    \x10!\n\x0f\n\x07\x04\x19\x04\0\x02\x06\x01\x12\x04\x93\x02\x10\x1c\n\
    \x0f\n\x07\x04\x19\x04\0\x02\x06\x02\x12\x04\x93\x02\x1f\x20\n\x0e\n\x06\
    \x04\x19\x04\0\x02\x07\x12\x04\x94\x02\x10!\n\x0f\n\x07\x04\x19\x04\0\
    \x02\x07\x01\x12\x04\x94\x02\x10\x1c\n\x0f\n\x07\x04\x19\x04\0\x02\x07\
    \x02\x12\x04\x94\x02\x1f\x20\n\x0c\n\x04\x04\x19\x02\0\x12\x04\x97\x02\
    \x08G\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\x97\x02\x08\x10\n\r\n\x05\x04\
    \x19\x02\0\x06\x12\x04\x97\x02\x11;\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\
    \x97\x02<B\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x97\x02EF\n\x0c\n\x02\x04\
    \x1a\x12\x06\x9a\x02\0\x9d\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x9a\
    \x02\x08%\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x9b\x02\x08%\n\r\n\x05\x04\
    \x1a\x02\0\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\
    \x04\x9b\x02\x11\x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x9b\x02\x18\x20\
    \n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x9b\x02#$\n\x0c\n\x04\x04\x1a\x02\
    \x01\x12\x04\x9c\x02\x08.\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\x9c\x02\
    \x08\x10\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\x9c\x02\x11\x17\n\r\n\x05\
    \x04\x1a\x02\x01\x01\x12\x04\x9c\x02\x18)\n\r\n\x05\x04\x1a\x02\x01\x03\
    \x12\x04\x9c\x02,-\n\x0c\n\x02\x04\x1b\x12\x06\x9f\x02\0\xae\x02\x01\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\x9f\x02\x08-\n\x0e\n\x04\x04\x1b\x04\0\
    \x12\x06\xa0\x02\x08\xab\x02\t\n\r\n\x05\x04\x1b\x04\0\x01\x12\x04\xa0\
    \x02\r\x16\n\x0e\n\x06\x04\x1b\x04\0\x02\0\x12\x04\xa1\x02\x10%\n\x0f\n\
    \x07\x04\x1b\x04\0\x02\0\x01\x12\x04\xa1\x02\x10\x20\n\x0f\n\x07\x04\x1b\
    \x04\0\x02\0\x02\x12\x04\xa1\x02#$\n\x0e\n\x06\x04\x1b\x04\0\x02\x01\x12\
    \x04\xa2\x02\x10\x1f\n\x0f\n\x07\x04\x1b\x04\0\x02\x01\x01\x12\x04\xa2\
    \x02\x10\x1a\n\x0f\n\x07\x04\x1b\x04\0\x02\x01\x02\x12\x04\xa2\x02\x1d\
    \x1e\n\x0e\n\x06\x04\x1b\x04\0\x02\x02\x12\x04\xa3\x02\x10\x1f\n\x0f\n\
    \x07\x04\x1b\x04\0\x02\x02\x01\x12\x04\xa3\x02\x10\x1a\n\x0f\n\x07\x04\
    \x1b\x04\0\x02\x02\x02\x12\x04\xa3\x02\x1d\x1e\n\x0e\n\x06\x04\x1b\x04\0\
    \x02\x03\x12\x04\xa4\x02\x10\x20\n\x0f\n\x07\x04\x1b\x04\0\x02\x03\x01\
    \x12\x04\xa4\x02\x10\x1b\n\x0f\n\x07\x04\x1b\x04\0\x02\x03\x02\x12\x04\
    \xa4\x02\x1e\x1f\n\x0e\n\x06\x04\x1b\x04\0\x02\x04\x12\x04\xa5\x02\x10\
    \x1f\n\x0f\n\x07\x04\x1b\x04\0\x02\x04\x01\x12\x04\xa5\x02\x10\x1a\n\x0f\
    \n\x07\x04\x1b\x04\0\x02\x04\x02\x12\x04\xa5\x02\x1d\x1e\n\x0e\n\x06\x04\
    \x1b\x04\0\x02\x05\x12\x04\xa6\x02\x10$\n\x0f\n\x07\x04\x1b\x04\0\x02\
    \x05\x01\x12\x04\xa6\x02\x10\x1f\n\x0f\n\x07\x04\x1b\x04\0\x02\x05\x02\
    \x12\x04\xa6\x02\"#\n\x0e\n\x06\x04\x1b\x04\0\x02\x06\x12\x04\xa7\x02\
    \x10*\n\x0f\n\x07\x04\x1b\x04\0\x02\x06\x01\x12\x04\xa7\x02\x10%\n\x0f\n\
    \x07\x04\x1b\x04\0\x02\x06\x02\x12\x04\xa7\x02()\n\x0e\n\x06\x04\x1b\x04\
    \0\x02\x07\x12\x04\xa8\x02\x10'\n\x0f\n\x07\x04\x1b\x04\0\x02\x07\x01\
    \x12\x04\xa8\x02\x10\"\n\x0f\n\x07\x04\x1b\x04\0\x02\x07\x02\x12\x04\xa8\
    \x02%&\n\x0e\n\x06\x04\x1b\x04\0\x02\x08\x12\x04\xa9\x02\x10$\n\x0f\n\
    \x07\x04\x1b\x04\0\x02\x08\x01\x12\x04\xa9\x02\x10\x1f\n\x0f\n\x07\x04\
    \x1b\x04\0\x02\x08\x02\x12\x04\xa9\x02\"#\n\x0e\n\x06\x04\x1b\x04\0\x02\
    \t\x12\x04\xaa\x02\x10$\n\x0f\n\x07\x04\x1b\x04\0\x02\t\x01\x12\x04\xaa\
    \x02\x10\x1f\n\x0f\n\x07\x04\x1b\x04\0\x02\t\x02\x12\x04\xaa\x02\"#\n\
    \x0c\n\x04\x04\x1b\x02\0\x12\x04\xad\x02\x08L\n\r\n\x05\x04\x1b\x02\0\
    \x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xad\x02\
    \x11@\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xad\x02AG\n\r\n\x05\x04\x1b\
    \x02\0\x03\x12\x04\xad\x02JK\n\x0c\n\x02\x04\x1c\x12\x06\xb0\x02\0\xb4\
    \x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xb0\x02\x08(\n\x0c\n\x04\x04\
    \x1c\x02\0\x12\x04\xb1\x02\x08%\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xb1\
    \x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xb1\x02\x11\x17\n\r\n\
    \x05\x04\x1c\x02\0\x01\x12\x04\xb1\x02\x18\x20\n\r\n\x05\x04\x1c\x02\0\
    \x03\x12\x04\xb1\x02#$\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xb2\x02\x08.\
    \n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04\x1c\
    \x02\x01\x05\x12\x04\xb2\x02\x11\x17\n\r\n\x05\x04\x1c\x02\x01\x01\x12\
    \x04\xb2\x02\x18)\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xb2\x02,-\n\x0c\
    \n\x04\x04\x1c\x02\x02\x12\x04\xb3\x02\x08+\n\r\n\x05\x04\x1c\x02\x02\
    \x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xb3\
    \x02\x11\x17\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xb3\x02\x18&\n\r\n\
    \x05\x04\x1c\x02\x02\x03\x12\x04\xb3\x02)*\n\x0c\n\x02\x04\x1d\x12\x06\
    \xb6\x02\0\xc6\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xb6\x02\x080\n\
    \x0e\n\x04\x04\x1d\x04\0\x12\x06\xb7\x02\x08\xc3\x02\t\n\r\n\x05\x04\x1d\
    \x04\0\x01\x12\x04\xb7\x02\r\x16\n\x0e\n\x06\x04\x1d\x04\0\x02\0\x12\x04\
    \xb8\x02\x10%\n\x0f\n\x07\x04\x1d\x04\0\x02\0\x01\x12\x04\xb8\x02\x10\
    \x20\n\x0f\n\x07\x04\x1d\x04\0\x02\0\x02\x12\x04\xb8\x02#$\n\x0e\n\x06\
    \x04\x1d\x04\0\x02\x01\x12\x04\xb9\x02\x10\x1f\n\x0f\n\x07\x04\x1d\x04\0\
    \x02\x01\x01\x12\x04\xb9\x02\x10\x1a\n\x0f\n\x07\x04\x1d\x04\0\x02\x01\
    \x02\x12\x04\xb9\x02\x1d\x1e\n\x0e\n\x06\x04\x1d\x04\0\x02\x02\x12\x04\
    \xba\x02\x10\x1f\n\x0f\n\x07\x04\x1d\x04\0\x02\x02\x01\x12\x04\xba\x02\
    \x10\x1a\n\x0f\n\x07\x04\x1d\x04\0\x02\x02\x02\x12\x04\xba\x02\x1d\x1e\n\
    \x0e\n\x06\x04\x1d\x04\0\x02\x03\x12\x04\xbb\x02\x10\x20\n\x0f\n\x07\x04\
    \x1d\x04\0\x02\x03\x01\x12\x04\xbb\x02\x10\x1b\n\x0f\n\x07\x04\x1d\x04\0\
    \x02\x03\x02\x12\x04\xbb\x02\x1e\x1f\n\x0e\n\x06\x04\x1d\x04\0\x02\x04\
    \x12\x04\xbc\x02\x10\x1f\n\x0f\n\x07\x04\x1d\x04\0\x02\x04\x01\x12\x04\
    \xbc\x02\x10\x1a\n\x0f\n\x07\x04\x1d\x04\0\x02\x04\x02\x12\x04\xbc\x02\
    \x1d\x1e\n\x0e\n\x06\x04\x1d\x04\0\x02\x05\x12\x04\xbd\x02\x10$\n\x0f\n\
    \x07\x04\x1d\x04\0\x02\x05\x01\x12\x04\xbd\x02\x10\x1f\n\x0f\n\x07\x04\
    \x1d\x04\0\x02\x05\x02\x12\x04\xbd\x02\"#\n\x0e\n\x06\x04\x1d\x04\0\x02\
    \x06\x12\x04\xbe\x02\x10*\n\x0f\n\x07\x04\x1d\x04\0\x02\x06\x01\x12\x04\
    \xbe\x02\x10%\n\x0f\n\x07\x04\x1d\x04\0\x02\x06\x02\x12\x04\xbe\x02()\n\
    \x0e\n\x06\x04\x1d\x04\0\x02\x07\x12\x04\xbf\x02\x10'\n\x0f\n\x07\x04\
    \x1d\x04\0\x02\x07\x01\x12\x04\xbf\x02\x10\"\n\x0f\n\x07\x04\x1d\x04\0\
    \x02\x07\x02\x12\x04\xbf\x02%&\n\x0e\n\x06\x04\x1d\x04\0\x02\x08\x12\x04\
    \xc0\x02\x10$\n\x0f\n\x07\x04\x1d\x04\0\x02\x08\x01\x12\x04\xc0\x02\x10\
    \x1f\n\x0f\n\x07\x04\x1d\x04\0\x02\x08\x02\x12\x04\xc0\x02\"#\n\x0e\n\
    \x06\x04\x1d\x04\0\x02\t\x12\x04\xc1\x02\x10#\n\x0f\n\x07\x04\x1d\x04\0\
    \x02\t\x01\x12\x04\xc1\x02\x10\x1e\n\x0f\n\x07\x04\x1d\x04\0\x02\t\x02\
    \x12\x04\xc1\x02!\"\n\x0e\n\x06\x04\x1d\x04\0\x02\n\x12\x04\xc2\x02\x10'\
    \n\x0f\n\x07\x04\x1d\x04\0\x02\n\x01\x12\x04\xc2\x02\x10!\n\x0f\n\x07\
    \x04\x1d\x04\0\x02\n\x02\x12\x04\xc2\x02$&\n\x0c\n\x04\x04\x1d\x02\0\x12\
    \x04\xc5\x02\x08O\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xc5\x02\x08\x10\n\
    \r\n\x05\x04\x1d\x02\0\x06\x12\x04\xc5\x02\x11C\n\r\n\x05\x04\x1d\x02\0\
    \x01\x12\x04\xc5\x02DJ\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xc5\x02MN\n\
    \x0c\n\x02\x04\x1e\x12\x06\xc8\x02\0\xcb\x02\x01\n\x0b\n\x03\x04\x1e\x01\
    \x12\x04\xc8\x02\x08#\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xc9\x02\x08%\n\r\
    \n\x05\x04\x1e\x02\0\x04\x12\x04\xc9\x02\x08\x10\n\r\n\x05\x04\x1e\x02\0\
    \x05\x12\x04\xc9\x02\x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xc9\x02\
    \x18\x20\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xc9\x02#$\n\x0c\n\x04\x04\
    \x1e\x02\x01\x12\x04\xca\x02\x08.\n\r\n\x05\x04\x1e\x02\x01\x04\x12\x04\
    \xca\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xca\x02\x11\x17\n\
    \r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xca\x02\x18)\n\r\n\x05\x04\x1e\x02\
    \x01\x03\x12\x04\xca\x02,-\n\x0c\n\x02\x04\x1f\x12\x06\xcd\x02\0\xdf\x02\
    \x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xcd\x02\x08+\n\x0e\n\x04\x04\x1f\
    \x04\0\x12\x06\xce\x02\x08\xdc\x02\t\n\r\n\x05\x04\x1f\x04\0\x01\x12\x04\
    \xce\x02\r\x16\n\x0e\n\x06\x04\x1f\x04\0\x02\0\x12\x04\xcf\x02\x10%\n\
    \x0f\n\x07\x04\x1f\x04\0\x02\0\x01\x12\x04\xcf\x02\x10\x20\n\x0f\n\x07\
    \x04\x1f\x04\0\x02\0\x02\x12\x04\xcf\x02#$\n\x0e\n\x06\x04\x1f\x04\0\x02\
    \x01\x12\x04\xd0\x02\x10\x1f\n\x0f\n\x07\x04\x1f\x04\0\x02\x01\x01\x12\
    \x04\xd0\x02\x10\x1a\n\x0f\n\x07\x04\x1f\x04\0\x02\x01\x02\x12\x04\xd0\
    \x02\x1d\x1e\n\x0e\n\x06\x04\x1f\x04\0\x02\x02\x12\x04\xd1\x02\x10\x1f\n\
    \x0f\n\x07\x04\x1f\x04\0\x02\x02\x01\x12\x04\xd1\x02\x10\x1a\n\x0f\n\x07\
    \x04\x1f\x04\0\x02\x02\x02\x12\x04\xd1\x02\x1d\x1e\n\x0e\n\x06\x04\x1f\
    \x04\0\x02\x03\x12\x04\xd2\x02\x10\x20\n\x0f\n\x07\x04\x1f\x04\0\x02\x03\
    \x01\x12\x04\xd2\x02\x10\x1b\n\x0f\n\x07\x04\x1f\x04\0\x02\x03\x02\x12\
    \x04\xd2\x02\x1e\x1f\n\x0e\n\x06\x04\x1f\x04\0\x02\x04\x12\x04\xd3\x02\
    \x10\x1f\n\x0f\n\x07\x04\x1f\x04\0\x02\x04\x01\x12\x04\xd3\x02\x10\x1a\n\
    \x0f\n\x07\x04\x1f\x04\0\x02\x04\x02\x12\x04\xd3\x02\x1d\x1e\n\x0e\n\x06\
    \x04\x1f\x04\0\x02\x05\x12\x04\xd4\x02\x10$\n\x0f\n\x07\x04\x1f\x04\0\
    \x02\x05\x01\x12\x04\xd4\x02\x10\x1f\n\x0f\n\x07\x04\x1f\x04\0\x02\x05\
    \x02\x12\x04\xd4\x02\"#\n\x0e\n\x06\x04\x1f\x04\0\x02\x06\x12\x04\xd5\
    \x02\x10!\n\x0f\n\x07\x04\x1f\x04\0\x02\x06\x01\x12\x04\xd5\x02\x10\x1c\
    \n\x0f\n\x07\x04\x1f\x04\0\x02\x06\x02\x12\x04\xd5\x02\x1f\x20\n\x0e\n\
    \x06\x04\x1f\x04\0\x02\x07\x12\x04\xd6\x02\x10*\n\x0f\n\x07\x04\x1f\x04\
    \0\x02\x07\x01\x12\x04\xd6\x02\x10%\n\x0f\n\x07\x04\x1f\x04\0\x02\x07\
    \x02\x12\x04\xd6\x02()\n\x0e\n\x06\x04\x1f\x04\0\x02\x08\x12\x04\xd7\x02\
    \x10&\n\x0f\n\x07\x04\x1f\x04\0\x02\x08\x01\x12\x04\xd7\x02\x10!\n\x0f\n\
    \x07\x04\x1f\x04\0\x02\x08\x02\x12\x04\xd7\x02$%\n\x0e\n\x06\x04\x1f\x04\
    \0\x02\t\x12\x04\xd8\x02\x10&\n\x0f\n\x07\x04\x1f\x04\0\x02\t\x01\x12\
    \x04\xd8\x02\x10!\n\x0f\n\x07\x04\x1f\x04\0\x02\t\x02\x12\x04\xd8\x02$%\
    \n\x0e\n\x06\x04\x1f\x04\0\x02\n\x12\x04\xd9\x02\x10,\n\x0f\n\x07\x04\
    \x1f\x04\0\x02\n\x01\x12\x04\xd9\x02\x10&\n\x0f\n\x07\x04\x1f\x04\0\x02\
    \n\x02\x12\x04\xd9\x02)+\n\x0e\n\x06\x04\x1f\x04\0\x02\x0b\x12\x04\xda\
    \x02\x10'\n\x0f\n\x07\x04\x1f\x04\0\x02\x0b\x01\x12\x04\xda\x02\x10!\n\
    \x0f\n\x07\x04\x1f\x04\0\x02\x0b\x02\x12\x04\xda\x02$&\n\x0e\n\x06\x04\
    \x1f\x04\0\x02\x0c\x12\x04\xdb\x02\x10$\n\x0f\n\x07\x04\x1f\x04\0\x02\
    \x0c\x01\x12\x04\xdb\x02\x10\x1e\n\x0f\n\x07\x04\x1f\x04\0\x02\x0c\x02\
    \x12\x04\xdb\x02!#\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xde\x02\x08J\n\r\n\
    \x05\x04\x1f\x02\0\x04\x12\x04\xde\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\
    \x06\x12\x04\xde\x02\x11>\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xde\x02?E\
    \n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xde\x02HI\n\x0c\n\x02\x04\x20\x12\
    \x06\xe1\x02\0\xe3\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xe1\x02\x08*\
    \n\x0c\n\x04\x04\x20\x02\0\x12\x04\xe2\x02\x08%\n\r\n\x05\x04\x20\x02\0\
    \x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xe2\x02\
    \x11\x17\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xe2\x02\x18\x20\n\r\n\x05\
    \x04\x20\x02\0\x03\x12\x04\xe2\x02#$\n\x0c\n\x02\x04!\x12\x06\xe5\x02\0\
    \xf1\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\xe5\x02\x082\n\x0e\n\x04\x04!\
    \x04\0\x12\x06\xe6\x02\x08\xee\x02\t\n\r\n\x05\x04!\x04\0\x01\x12\x04\
    \xe6\x02\r\x16\n\x0e\n\x06\x04!\x04\0\x02\0\x12\x04\xe7\x02\x10%\n\x0f\n\
    \x07\x04!\x04\0\x02\0\x01\x12\x04\xe7\x02\x10\x20\n\x0f\n\x07\x04!\x04\0\
    \x02\0\x02\x12\x04\xe7\x02#$\n\x0e\n\x06\x04!\x04\0\x02\x01\x12\x04\xe8\
    \x02\x10\x1f\n\x0f\n\x07\x04!\x04\0\x02\x01\x01\x12\x04\xe8\x02\x10\x1a\
    \n\x0f\n\x07\x04!\x04\0\x02\x01\x02\x12\x04\xe8\x02\x1d\x1e\n\x0e\n\x06\
    \x04!\x04\0\x02\x02\x12\x04\xe9\x02\x10\x1f\n\x0f\n\x07\x04!\x04\0\x02\
    \x02\x01\x12\x04\xe9\x02\x10\x1a\n\x0f\n\x07\x04!\x04\0\x02\x02\x02\x12\
    \x04\xe9\x02\x1d\x1e\n\x0e\n\x06\x04!\x04\0\x02\x03\x12\x04\xea\x02\x10\
    \x20\n\x0f\n\x07\x04!\x04\0\x02\x03\x01\x12\x04\xea\x02\x10\x1b\n\x0f\n\
    \x07\x04!\x04\0\x02\x03\x02\x12\x04\xea\x02\x1e\x1f\n\x0e\n\x06\x04!\x04\
    \0\x02\x04\x12\x04\xeb\x02\x10\x1f\n\x0f\n\x07\x04!\x04\0\x02\x04\x01\
    \x12\x04\xeb\x02\x10\x1a\n\x0f\n\x07\x04!\x04\0\x02\x04\x02\x12\x04\xeb\
    \x02\x1d\x1e\n\x0e\n\x06\x04!\x04\0\x02\x05\x12\x04\xec\x02\x10$\n\x0f\n\
    \x07\x04!\x04\0\x02\x05\x01\x12\x04\xec\x02\x10\x1f\n\x0f\n\x07\x04!\x04\
    \0\x02\x05\x02\x12\x04\xec\x02\"#\n\x0e\n\x06\x04!\x04\0\x02\x06\x12\x04\
    \xed\x02\x10%\n\x0f\n\x07\x04!\x04\0\x02\x06\x01\x12\x04\xed\x02\x10\x20\
    \n\x0f\n\x07\x04!\x04\0\x02\x06\x02\x12\x04\xed\x02#$\n\x0c\n\x04\x04!\
    \x02\0\x12\x04\xf0\x02\x08Q\n\r\n\x05\x04!\x02\0\x04\x12\x04\xf0\x02\x08\
    \x10\n\r\n\x05\x04!\x02\0\x06\x12\x04\xf0\x02\x11E\n\r\n\x05\x04!\x02\0\
    \x01\x12\x04\xf0\x02FL\n\r\n\x05\x04!\x02\0\x03\x12\x04\xf0\x02OP\n\x0c\
    \n\x02\x04\"\x12\x06\xf3\x02\0\xf5\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xf3\x02\x08)\n\x0c\n\x04\x04\"\x02\0\x12\x04\xf4\x02\x08%\n\r\n\x05\x04\
    \"\x02\0\x04\x12\x04\xf4\x02\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \xf4\x02\x11\x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xf4\x02\x18\x20\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xf4\x02#$\n\x0c\n\x02\x04#\x12\x06\xf7\x02\
    \0\x87\x03\x01\n\x0b\n\x03\x04#\x01\x12\x04\xf7\x02\x081\n\x0e\n\x04\x04\
    #\x04\0\x12\x06\xf8\x02\x08\x84\x03\t\n\r\n\x05\x04#\x04\0\x01\x12\x04\
    \xf8\x02\r\x16\n\x0e\n\x06\x04#\x04\0\x02\0\x12\x04\xf9\x02\x10%\n\x0f\n\
    \x07\x04#\x04\0\x02\0\x01\x12\x04\xf9\x02\x10\x20\n\x0f\n\x07\x04#\x04\0\
    \x02\0\x02\x12\x04\xf9\x02#$\n\x0e\n\x06\x04#\x04\0\x02\x01\x12\x04\xfa\
    \x02\x10\x1f\n\x0f\n\x07\x04#\x04\0\x02\x01\x01\x12\x04\xfa\x02\x10\x1a\
    \n\x0f\n\x07\x04#\x04\0\x02\x01\x02\x12\x04\xfa\x02\x1d\x1e\n\x0e\n\x06\
    \x04#\x04\0\x02\x02\x12\x04\xfb\x02\x10\x1f\n\x0f\n\x07\x04#\x04\0\x02\
    \x02\x01\x12\x04\xfb\x02\x10\x1a\n\x0f\n\x07\x04#\x04\0\x02\x02\x02\x12\
    \x04\xfb\x02\x1d\x1e\n\x0e\n\x06\x04#\x04\0\x02\x03\x12\x04\xfc\x02\x10\
    \x20\n\x0f\n\x07\x04#\x04\0\x02\x03\x01\x12\x04\xfc\x02\x10\x1b\n\x0f\n\
    \x07\x04#\x04\0\x02\x03\x02\x12\x04\xfc\x02\x1e\x1f\n\x0e\n\x06\x04#\x04\
    \0\x02\x04\x12\x04\xfd\x02\x10\x1f\n\x0f\n\x07\x04#\x04\0\x02\x04\x01\
    \x12\x04\xfd\x02\x10\x1a\n\x0f\n\x07\x04#\x04\0\x02\x04\x02\x12\x04\xfd\
    \x02\x1d\x1e\n\x0e\n\x06\x04#\x04\0\x02\x05\x12\x04\xfe\x02\x10$\n\x0f\n\
    \x07\x04#\x04\0\x02\x05\x01\x12\x04\xfe\x02\x10\x1f\n\x0f\n\x07\x04#\x04\
    \0\x02\x05\x02\x12\x04\xfe\x02\"#\n\x0e\n\x06\x04#\x04\0\x02\x06\x12\x04\
    \xff\x02\x10%\n\x0f\n\x07\x04#\x04\0\x02\x06\x01\x12\x04\xff\x02\x10\x20\
    \n\x0f\n\x07\x04#\x04\0\x02\x06\x02\x12\x04\xff\x02#$\n\x0e\n\x06\x04#\
    \x04\0\x02\x07\x12\x04\x80\x03\x10!\n\x0f\n\x07\x04#\x04\0\x02\x07\x01\
    \x12\x04\x80\x03\x10\x1c\n\x0f\n\x07\x04#\x04\0\x02\x07\x02\x12\x04\x80\
    \x03\x1f\x20\n\x0e\n\x06\x04#\x04\0\x02\x08\x12\x04\x81\x03\x10\"\n\x0f\
    \n\x07\x04#\x04\0\x02\x08\x01\x12\x04\x81\x03\x10\x1d\n\x0f\n\x07\x04#\
    \x04\0\x02\x08\x02\x12\x04\x81\x03\x20!\n\x0e\n\x06\x04#\x04\0\x02\t\x12\
    \x04\x82\x03\x10&\n\x0f\n\x07\x04#\x04\0\x02\t\x01\x12\x04\x82\x03\x10!\
    \n\x0f\n\x07\x04#\x04\0\x02\t\x02\x12\x04\x82\x03$%\n\x0e\n\x06\x04#\x04\
    \0\x02\n\x12\x04\x83\x03\x10'\n\x0f\n\x07\x04#\x04\0\x02\n\x01\x12\x04\
    \x83\x03\x10!\n\x0f\n\x07\x04#\x04\0\x02\n\x02\x12\x04\x83\x03$&\n\x0c\n\
    \x04\x04#\x02\0\x12\x04\x86\x03\x08P\n\r\n\x05\x04#\x02\0\x04\x12\x04\
    \x86\x03\x08\x10\n\r\n\x05\x04#\x02\0\x06\x12\x04\x86\x03\x11D\n\r\n\x05\
    \x04#\x02\0\x01\x12\x04\x86\x03EK\n\r\n\x05\x04#\x02\0\x03\x12\x04\x86\
    \x03NO\n\x0c\n\x02\x04$\x12\x06\x89\x03\0\x8c\x03\x01\n\x0b\n\x03\x04$\
    \x01\x12\x04\x89\x03\x08)\n\x0c\n\x04\x04$\x02\0\x12\x04\x8a\x03\x08%\n\
    \r\n\x05\x04$\x02\0\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04$\x02\0\x05\
    \x12\x04\x8a\x03\x11\x17\n\r\n\x05\x04$\x02\0\x01\x12\x04\x8a\x03\x18\
    \x20\n\r\n\x05\x04$\x02\0\x03\x12\x04\x8a\x03#$\n\x0c\n\x04\x04$\x02\x01\
    \x12\x04\x8b\x03\x08.\n\r\n\x05\x04$\x02\x01\x04\x12\x04\x8b\x03\x08\x10\
    \n\r\n\x05\x04$\x02\x01\x05\x12\x04\x8b\x03\x11\x17\n\r\n\x05\x04$\x02\
    \x01\x01\x12\x04\x8b\x03\x18)\n\r\n\x05\x04$\x02\x01\x03\x12\x04\x8b\x03\
    ,-\n\x0c\n\x02\x04%\x12\x06\x8e\x03\0\x9b\x03\x01\n\x0b\n\x03\x04%\x01\
    \x12\x04\x8e\x03\x081\n\x0e\n\x04\x04%\x04\0\x12\x06\x8f\x03\x08\x98\x03\
    \t\n\r\n\x05\x04%\x04\0\x01\x12\x04\x8f\x03\r\x16\n\x0e\n\x06\x04%\x04\0\
    \x02\0\x12\x04\x90\x03\x10%\n\x0f\n\x07\x04%\x04\0\x02\0\x01\x12\x04\x90\
    \x03\x10\x20\n\x0f\n\x07\x04%\x04\0\x02\0\x02\x12\x04\x90\x03#$\n\x0e\n\
    \x06\x04%\x04\0\x02\x01\x12\x04\x91\x03\x10\x1f\n\x0f\n\x07\x04%\x04\0\
    \x02\x01\x01\x12\x04\x91\x03\x10\x1a\n\x0f\n\x07\x04%\x04\0\x02\x01\x02\
    \x12\x04\x91\x03\x1d\x1e\n\x0e\n\x06\x04%\x04\0\x02\x02\x12\x04\x92\x03\
    \x10\x1f\n\x0f\n\x07\x04%\x04\0\x02\x02\x01\x12\x04\x92\x03\x10\x1a\n\
    \x0f\n\x07\x04%\x04\0\x02\x02\x02\x12\x04\x92\x03\x1d\x1e\n\x0e\n\x06\
    \x04%\x04\0\x02\x03\x12\x04\x93\x03\x10\x20\n\x0f\n\x07\x04%\x04\0\x02\
    \x03\x01\x12\x04\x93\x03\x10\x1b\n\x0f\n\x07\x04%\x04\0\x02\x03\x02\x12\
    \x04\x93\x03\x1e\x1f\n\x0e\n\x06\x04%\x04\0\x02\x04\x12\x04\x94\x03\x10\
    \x1f\n\x0f\n\x07\x04%\x04\0\x02\x04\x01\x12\x04\x94\x03\x10\x1a\n\x0f\n\
    \x07\x04%\x04\0\x02\x04\x02\x12\x04\x94\x03\x1d\x1e\n\x0e\n\x06\x04%\x04\
    \0\x02\x05\x12\x04\x95\x03\x10$\n\x0f\n\x07\x04%\x04\0\x02\x05\x01\x12\
    \x04\x95\x03\x10\x1f\n\x0f\n\x07\x04%\x04\0\x02\x05\x02\x12\x04\x95\x03\
    \"#\n\x0e\n\x06\x04%\x04\0\x02\x06\x12\x04\x96\x03\x10%\n\x0f\n\x07\x04%\
    \x04\0\x02\x06\x01\x12\x04\x96\x03\x10\x20\n\x0f\n\x07\x04%\x04\0\x02\
    \x06\x02\x12\x04\x96\x03#$\n\x0e\n\x06\x04%\x04\0\x02\x07\x12\x04\x97\
    \x03\x10%\n\x0f\n\x07\x04%\x04\0\x02\x07\x01\x12\x04\x97\x03\x10\x20\n\
    \x0f\n\x07\x04%\x04\0\x02\x07\x02\x12\x04\x97\x03#$\n\x0c\n\x04\x04%\x02\
    \0\x12\x04\x9a\x03\x08P\n\r\n\x05\x04%\x02\0\x04\x12\x04\x9a\x03\x08\x10\
    \n\r\n\x05\x04%\x02\0\x06\x12\x04\x9a\x03\x11D\n\r\n\x05\x04%\x02\0\x01\
    \x12\x04\x9a\x03EK\n\r\n\x05\x04%\x02\0\x03\x12\x04\x9a\x03NO\n\x0c\n\
    \x02\x04&\x12\x06\x9d\x03\0\xa1\x03\x01\n\x0b\n\x03\x04&\x01\x12\x04\x9d\
    \x03\x08\"\n\x0c\n\x04\x04&\x02\0\x12\x04\x9e\x03\x08%\n\r\n\x05\x04&\
    \x02\0\x04\x12\x04\x9e\x03\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\x9e\
    \x03\x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\x04\x9e\x03\x18\x20\n\r\n\x05\
    \x04&\x02\0\x03\x12\x04\x9e\x03#$\n\x0c\n\x04\x04&\x02\x01\x12\x04\x9f\
    \x03\x08&\n\r\n\x05\x04&\x02\x01\x04\x12\x04\x9f\x03\x08\x10\n\r\n\x05\
    \x04&\x02\x01\x05\x12\x04\x9f\x03\x11\x17\n\r\n\x05\x04&\x02\x01\x01\x12\
    \x04\x9f\x03\x18!\n\r\n\x05\x04&\x02\x01\x03\x12\x04\x9f\x03$%\n\x0c\n\
    \x04\x04&\x02\x02\x12\x04\xa0\x03\x08'\n\r\n\x05\x04&\x02\x02\x04\x12\
    \x04\xa0\x03\x08\x10\n\r\n\x05\x04&\x02\x02\x05\x12\x04\xa0\x03\x11\x17\
    \n\r\n\x05\x04&\x02\x02\x01\x12\x04\xa0\x03\x18\"\n\r\n\x05\x04&\x02\x02\
    \x03\x12\x04\xa0\x03%&\n\x0c\n\x02\x04'\x12\x06\xa3\x03\0\xb6\x03\x01\n\
    \x0b\n\x03\x04'\x01\x12\x04\xa3\x03\x08*\n\x0e\n\x04\x04'\x04\0\x12\x06\
    \xa4\x03\x08\xb2\x03\t\n\r\n\x05\x04'\x04\0\x01\x12\x04\xa4\x03\r\x16\n\
    \x0e\n\x06\x04'\x04\0\x02\0\x12\x04\xa5\x03\x10%\n\x0f\n\x07\x04'\x04\0\
    \x02\0\x01\x12\x04\xa5\x03\x10\x20\n\x0f\n\x07\x04'\x04\0\x02\0\x02\x12\
    \x04\xa5\x03#$\n\x0e\n\x06\x04'\x04\0\x02\x01\x12\x04\xa6\x03\x10\x1f\n\
    \x0f\n\x07\x04'\x04\0\x02\x01\x01\x12\x04\xa6\x03\x10\x1a\n\x0f\n\x07\
    \x04'\x04\0\x02\x01\x02\x12\x04\xa6\x03\x1d\x1e\n\x0e\n\x06\x04'\x04\0\
    \x02\x02\x12\x04\xa7\x03\x10\x1f\n\x0f\n\x07\x04'\x04\0\x02\x02\x01\x12\
    \x04\xa7\x03\x10\x1a\n\x0f\n\x07\x04'\x04\0\x02\x02\x02\x12\x04\xa7\x03\
    \x1d\x1e\n\x0e\n\x06\x04'\x04\0\x02\x03\x12\x04\xa8\x03\x10\x20\n\x0f\n\
    \x07\x04'\x04\0\x02\x03\x01\x12\x04\xa8\x03\x10\x1b\n\x0f\n\x07\x04'\x04\
    \0\x02\x03\x02\x12\x04\xa8\x03\x1e\x1f\n\x0e\n\x06\x04'\x04\0\x02\x04\
    \x12\x04\xa9\x03\x10\x1f\n\x0f\n\x07\x04'\x04\0\x02\x04\x01\x12\x04\xa9\
    \x03\x10\x1a\n\x0f\n\x07\x04'\x04\0\x02\x04\x02\x12\x04\xa9\x03\x1d\x1e\
    \n\x0e\n\x06\x04'\x04\0\x02\x05\x12\x04\xaa\x03\x10$\n\x0f\n\x07\x04'\
    \x04\0\x02\x05\x01\x12\x04\xaa\x03\x10\x1f\n\x0f\n\x07\x04'\x04\0\x02\
    \x05\x02\x12\x04\xaa\x03\"#\n\x0e\n\x06\x04'\x04\0\x02\x06\x12\x04\xab\
    \x03\x10'\n\x0f\n\x07\x04'\x04\0\x02\x06\x01\x12\x04\xab\x03\x10\"\n\x0f\
    \n\x07\x04'\x04\0\x02\x06\x02\x12\x04\xab\x03%&\n\x0e\n\x06\x04'\x04\0\
    \x02\x07\x12\x04\xac\x03\x10%\n\x0f\n\x07\x04'\x04\0\x02\x07\x01\x12\x04\
    \xac\x03\x10\x20\n\x0f\n\x07\x04'\x04\0\x02\x07\x02\x12\x04\xac\x03#$\n\
    \x0e\n\x06\x04'\x04\0\x02\x08\x12\x04\xad\x03\x10$\n\x0f\n\x07\x04'\x04\
    \0\x02\x08\x01\x12\x04\xad\x03\x10\x1f\n\x0f\n\x07\x04'\x04\0\x02\x08\
    \x02\x12\x04\xad\x03\"#\n\x0e\n\x06\x04'\x04\0\x02\t\x12\x04\xae\x03\x10\
    #\n\x0f\n\x07\x04'\x04\0\x02\t\x01\x12\x04\xae\x03\x10\x1e\n\x0f\n\x07\
    \x04'\x04\0\x02\t\x02\x12\x04\xae\x03!\"\n\x0e\n\x06\x04'\x04\0\x02\n\
    \x12\x04\xaf\x03\x10'\n\x0f\n\x07\x04'\x04\0\x02\n\x01\x12\x04\xaf\x03\
    \x10!\n\x0f\n\x07\x04'\x04\0\x02\n\x02\x12\x04\xaf\x03$&\n\x0e\n\x06\x04\
    '\x04\0\x02\x0b\x12\x04\xb0\x03\x10%\n\x0f\n\x07\x04'\x04\0\x02\x0b\x01\
    \x12\x04\xb0\x03\x10\x1f\n\x0f\n\x07\x04'\x04\0\x02\x0b\x02\x12\x04\xb0\
    \x03\"$\n\x0e\n\x06\x04'\x04\0\x02\x0c\x12\x04\xb1\x03\x10\x20\n\x0f\n\
    \x07\x04'\x04\0\x02\x0c\x01\x12\x04\xb1\x03\x10\x1a\n\x0f\n\x07\x04'\x04\
    \0\x02\x0c\x02\x12\x04\xb1\x03\x1d\x1f\n\x0c\n\x04\x04'\x02\0\x12\x04\
    \xb4\x03\x08I\n\r\n\x05\x04'\x02\0\x04\x12\x04\xb4\x03\x08\x10\n\r\n\x05\
    \x04'\x02\0\x06\x12\x04\xb4\x03\x11=\n\r\n\x05\x04'\x02\0\x01\x12\x04\
    \xb4\x03>D\n\r\n\x05\x04'\x02\0\x03\x12\x04\xb4\x03GH\n\x0c\n\x04\x04'\
    \x02\x01\x12\x04\xb5\x03\x08$\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xb5\x03\
    \x08\x10\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xb5\x03\x11\x17\n\r\n\x05\
    \x04'\x02\x01\x01\x12\x04\xb5\x03\x18\x1f\n\r\n\x05\x04'\x02\x01\x03\x12\
    \x04\xb5\x03\"#\n\x0c\n\x02\x04(\x12\x06\xb8\x03\0\xbd\x03\x01\n\x0b\n\
    \x03\x04(\x01\x12\x04\xb8\x03\x08%\n\x0c\n\x04\x04(\x02\0\x12\x04\xb9\
    \x03\x08%\n\r\n\x05\x04(\x02\0\x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04\
    (\x02\0\x05\x12\x04\xb9\x03\x11\x17\n\r\n\x05\x04(\x02\0\x01\x12\x04\xb9\
    \x03\x18\x20\n\r\n\x05\x04(\x02\0\x03\x12\x04\xb9\x03#$\n\x0c\n\x04\x04(\
    \x02\x01\x12\x04\xba\x03\x08$\n\r\n\x05\x04(\x02\x01\x04\x12\x04\xba\x03\
    \x08\x10\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xba\x03\x11\x17\n\r\n\x05\
    \x04(\x02\x01\x01\x12\x04\xba\x03\x18\x1f\n\r\n\x05\x04(\x02\x01\x03\x12\
    \x04\xba\x03\"#\n\x0c\n\x04\x04(\x02\x02\x12\x04\xbb\x03\x08&\n\r\n\x05\
    \x04(\x02\x02\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04(\x02\x02\x05\x12\
    \x04\xbb\x03\x11\x17\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xbb\x03\x18!\n\r\
    \n\x05\x04(\x02\x02\x03\x12\x04\xbb\x03$%\n\x0c\n\x04\x04(\x02\x03\x12\
    \x04\xbc\x03\x08'\n\r\n\x05\x04(\x02\x03\x04\x12\x04\xbc\x03\x08\x10\n\r\
    \n\x05\x04(\x02\x03\x05\x12\x04\xbc\x03\x11\x17\n\r\n\x05\x04(\x02\x03\
    \x01\x12\x04\xbc\x03\x18\"\n\r\n\x05\x04(\x02\x03\x03\x12\x04\xbc\x03%&\
    \n\x0c\n\x02\x04)\x12\x06\xbf\x03\0\xd1\x03\x01\n\x0b\n\x03\x04)\x01\x12\
    \x04\xbf\x03\x08-\n\x0e\n\x04\x04)\x04\0\x12\x06\xc0\x03\x08\xce\x03\t\n\
    \r\n\x05\x04)\x04\0\x01\x12\x04\xc0\x03\r\x16\n\x0e\n\x06\x04)\x04\0\x02\
    \0\x12\x04\xc1\x03\x10%\n\x0f\n\x07\x04)\x04\0\x02\0\x01\x12\x04\xc1\x03\
    \x10\x20\n\x0f\n\x07\x04)\x04\0\x02\0\x02\x12\x04\xc1\x03#$\n\x0e\n\x06\
    \x04)\x04\0\x02\x01\x12\x04\xc2\x03\x10\x1f\n\x0f\n\x07\x04)\x04\0\x02\
    \x01\x01\x12\x04\xc2\x03\x10\x1a\n\x0f\n\x07\x04)\x04\0\x02\x01\x02\x12\
    \x04\xc2\x03\x1d\x1e\n\x0e\n\x06\x04)\x04\0\x02\x02\x12\x04\xc3\x03\x10\
    \x1f\n\x0f\n\x07\x04)\x04\0\x02\x02\x01\x12\x04\xc3\x03\x10\x1a\n\x0f\n\
    \x07\x04)\x04\0\x02\x02\x02\x12\x04\xc3\x03\x1d\x1e\n\x0e\n\x06\x04)\x04\
    \0\x02\x03\x12\x04\xc4\x03\x10\x20\n\x0f\n\x07\x04)\x04\0\x02\x03\x01\
    \x12\x04\xc4\x03\x10\x1b\n\x0f\n\x07\x04)\x04\0\x02\x03\x02\x12\x04\xc4\
    \x03\x1e\x1f\n\x0e\n\x06\x04)\x04\0\x02\x04\x12\x04\xc5\x03\x10\x1f\n\
    \x0f\n\x07\x04)\x04\0\x02\x04\x01\x12\x04\xc5\x03\x10\x1a\n\x0f\n\x07\
    \x04)\x04\0\x02\x04\x02\x12\x04\xc5\x03\x1d\x1e\n\x0e\n\x06\x04)\x04\0\
    \x02\x05\x12\x04\xc6\x03\x10$\n\x0f\n\x07\x04)\x04\0\x02\x05\x01\x12\x04\
    \xc6\x03\x10\x1f\n\x0f\n\x07\x04)\x04\0\x02\x05\x02\x12\x04\xc6\x03\"#\n\
    \x0e\n\x06\x04)\x04\0\x02\x06\x12\x04\xc7\x03\x10#\n\x0f\n\x07\x04)\x04\
    \0\x02\x06\x01\x12\x04\xc7\x03\x10\x1e\n\x0f\n\x07\x04)\x04\0\x02\x06\
    \x02\x12\x04\xc7\x03!\"\n\x0e\n\x06\x04)\x04\0\x02\x07\x12\x04\xc8\x03\
    \x10'\n\x0f\n\x07\x04)\x04\0\x02\x07\x01\x12\x04\xc8\x03\x10\"\n\x0f\n\
    \x07\x04)\x04\0\x02\x07\x02\x12\x04\xc8\x03%&\n\x0e\n\x06\x04)\x04\0\x02\
    \x08\x12\x04\xc9\x03\x10$\n\x0f\n\x07\x04)\x04\0\x02\x08\x01\x12\x04\xc9\
    \x03\x10\x1f\n\x0f\n\x07\x04)\x04\0\x02\x08\x02\x12\x04\xc9\x03\"#\n\x0e\
    \n\x06\x04)\x04\0\x02\t\x12\x04\xca\x03\x10#\n\x0f\n\x07\x04)\x04\0\x02\
    \t\x01\x12\x04\xca\x03\x10\x1e\n\x0f\n\x07\x04)\x04\0\x02\t\x02\x12\x04\
    \xca\x03!\"\n\x0e\n\x06\x04)\x04\0\x02\n\x12\x04\xcb\x03\x10&\n\x0f\n\
    \x07\x04)\x04\0\x02\n\x01\x12\x04\xcb\x03\x10\x20\n\x0f\n\x07\x04)\x04\0\
    \x02\n\x02\x12\x04\xcb\x03#%\n\x0e\n\x06\x04)\x04\0\x02\x0b\x12\x04\xcc\
    \x03\x10'\n\x0f\n\x07\x04)\x04\0\x02\x0b\x01\x12\x04\xcc\x03\x10!\n\x0f\
    \n\x07\x04)\x04\0\x02\x0b\x02\x12\x04\xcc\x03$&\n\x0e\n\x06\x04)\x04\0\
    \x02\x0c\x12\x04\xcd\x03\x10\x20\n\x0f\n\x07\x04)\x04\0\x02\x0c\x01\x12\
    \x04\xcd\x03\x10\x1a\n\x0f\n\x07\x04)\x04\0\x02\x0c\x02\x12\x04\xcd\x03\
    \x1d\x1f\n\x0c\n\x04\x04)\x02\0\x12\x04\xd0\x03\x08L\n\r\n\x05\x04)\x02\
    \0\x04\x12\x04\xd0\x03\x08\x10\n\r\n\x05\x04)\x02\0\x06\x12\x04\xd0\x03\
    \x11@\n\r\n\x05\x04)\x02\0\x01\x12\x04\xd0\x03AG\n\r\n\x05\x04)\x02\0\
    \x03\x12\x04\xd0\x03JK\n\x0c\n\x02\x04*\x12\x06\xd3\x03\0\xd6\x03\x01\n\
    \x0b\n\x03\x04*\x01\x12\x04\xd3\x03\x08%\n\x0c\n\x04\x04*\x02\0\x12\x04\
    \xd4\x03\x08%\n\r\n\x05\x04*\x02\0\x04\x12\x04\xd4\x03\x08\x10\n\r\n\x05\
    \x04*\x02\0\x05\x12\x04\xd4\x03\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\
    \xd4\x03\x18\x20\n\r\n\x05\x04*\x02\0\x03\x12\x04\xd4\x03#$\n\x0c\n\x04\
    \x04*\x02\x01\x12\x04\xd5\x03\x08$\n\r\n\x05\x04*\x02\x01\x04\x12\x04\
    \xd5\x03\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xd5\x03\x11\x17\n\r\
    \n\x05\x04*\x02\x01\x01\x12\x04\xd5\x03\x18\x1f\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xd5\x03\"#\n\x0c\n\x02\x04+\x12\x06\xd8\x03\0\xe8\x03\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xd8\x03\x08-\n\x0e\n\x04\x04+\x04\0\x12\x06\
    \xd9\x03\x08\xe5\x03\t\n\r\n\x05\x04+\x04\0\x01\x12\x04\xd9\x03\r\x16\n\
    \x0e\n\x06\x04+\x04\0\x02\0\x12\x04\xda\x03\x10%\n\x0f\n\x07\x04+\x04\0\
    \x02\0\x01\x12\x04\xda\x03\x10\x20\n\x0f\n\x07\x04+\x04\0\x02\0\x02\x12\
    \x04\xda\x03#$\n\x0e\n\x06\x04+\x04\0\x02\x01\x12\x04\xdb\x03\x10\x1f\n\
    \x0f\n\x07\x04+\x04\0\x02\x01\x01\x12\x04\xdb\x03\x10\x1a\n\x0f\n\x07\
    \x04+\x04\0\x02\x01\x02\x12\x04\xdb\x03\x1d\x1e\n\x0e\n\x06\x04+\x04\0\
    \x02\x02\x12\x04\xdc\x03\x10\x1f\n\x0f\n\x07\x04+\x04\0\x02\x02\x01\x12\
    \x04\xdc\x03\x10\x1a\n\x0f\n\x07\x04+\x04\0\x02\x02\x02\x12\x04\xdc\x03\
    \x1d\x1e\n\x0e\n\x06\x04+\x04\0\x02\x03\x12\x04\xdd\x03\x10\x20\n\x0f\n\
    \x07\x04+\x04\0\x02\x03\x01\x12\x04\xdd\x03\x10\x1b\n\x0f\n\x07\x04+\x04\
    \0\x02\x03\x02\x12\x04\xdd\x03\x1e\x1f\n\x0e\n\x06\x04+\x04\0\x02\x04\
    \x12\x04\xde\x03\x10\x1f\n\x0f\n\x07\x04+\x04\0\x02\x04\x01\x12\x04\xde\
    \x03\x10\x1a\n\x0f\n\x07\x04+\x04\0\x02\x04\x02\x12\x04\xde\x03\x1d\x1e\
    \n\x0e\n\x06\x04+\x04\0\x02\x05\x12\x04\xdf\x03\x10$\n\x0f\n\x07\x04+\
    \x04\0\x02\x05\x01\x12\x04\xdf\x03\x10\x1f\n\x0f\n\x07\x04+\x04\0\x02\
    \x05\x02\x12\x04\xdf\x03\"#\n\x0e\n\x06\x04+\x04\0\x02\x06\x12\x04\xe0\
    \x03\x10#\n\x0f\n\x07\x04+\x04\0\x02\x06\x01\x12\x04\xe0\x03\x10\x1e\n\
    \x0f\n\x07\x04+\x04\0\x02\x06\x02\x12\x04\xe0\x03!\"\n\x0e\n\x06\x04+\
    \x04\0\x02\x07\x12\x04\xe1\x03\x10$\n\x0f\n\x07\x04+\x04\0\x02\x07\x01\
    \x12\x04\xe1\x03\x10\x1f\n\x0f\n\x07\x04+\x04\0\x02\x07\x02\x12\x04\xe1\
    \x03\"#\n\x0e\n\x06\x04+\x04\0\x02\x08\x12\x04\xe2\x03\x10%\n\x0f\n\x07\
    \x04+\x04\0\x02\x08\x01\x12\x04\xe2\x03\x10\x20\n\x0f\n\x07\x04+\x04\0\
    \x02\x08\x02\x12\x04\xe2\x03#$\n\x0e\n\x06\x04+\x04\0\x02\t\x12\x04\xe3\
    \x03\x10&\n\x0f\n\x07\x04+\x04\0\x02\t\x01\x12\x04\xe3\x03\x10!\n\x0f\n\
    \x07\x04+\x04\0\x02\t\x02\x12\x04\xe3\x03$%\n\x0e\n\x06\x04+\x04\0\x02\n\
    \x12\x04\xe4\x03\x10.\n\x0f\n\x07\x04+\x04\0\x02\n\x01\x12\x04\xe4\x03\
    \x10(\n\x0f\n\x07\x04+\x04\0\x02\n\x02\x12\x04\xe4\x03+-\n\x0c\n\x04\x04\
    +\x02\0\x12\x04\xe7\x03\x08L\n\r\n\x05\x04+\x02\0\x04\x12\x04\xe7\x03\
    \x08\x10\n\r\n\x05\x04+\x02\0\x06\x12\x04\xe7\x03\x11@\n\r\n\x05\x04+\
    \x02\0\x01\x12\x04\xe7\x03AG\n\r\n\x05\x04+\x02\0\x03\x12\x04\xe7\x03JK\
    \n\x0c\n\x02\x04,\x12\x06\xea\x03\0\xee\x03\x01\n\x0b\n\x03\x04,\x01\x12\
    \x04\xea\x03\x08'\n\x0c\n\x04\x04,\x02\0\x12\x04\xeb\x03\x08%\n\r\n\x05\
    \x04,\x02\0\x04\x12\x04\xeb\x03\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\
    \xeb\x03\x11\x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\xeb\x03\x18\x20\n\r\n\
    \x05\x04,\x02\0\x03\x12\x04\xeb\x03#$\n\x0c\n\x04\x04,\x02\x01\x12\x04\
    \xec\x03\x08/\n\r\n\x05\x04,\x02\x01\x04\x12\x04\xec\x03\x08\x10\n\r\n\
    \x05\x04,\x02\x01\x05\x12\x04\xec\x03\x11\x17\n\r\n\x05\x04,\x02\x01\x01\
    \x12\x04\xec\x03\x18*\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xec\x03-.\n\x0c\
    \n\x04\x04,\x02\x02\x12\x04\xed\x03\x08.\n\r\n\x05\x04,\x02\x02\x04\x12\
    \x04\xed\x03\x08\x10\n\r\n\x05\x04,\x02\x02\x05\x12\x04\xed\x03\x11\x17\
    \n\r\n\x05\x04,\x02\x02\x01\x12\x04\xed\x03\x18)\n\r\n\x05\x04,\x02\x02\
    \x03\x12\x04\xed\x03,-\n\x0c\n\x02\x04-\x12\x06\xf0\x03\0\x80\x04\x01\n\
    \x0b\n\x03\x04-\x01\x12\x04\xf0\x03\x08/\n\x0e\n\x04\x04-\x04\0\x12\x06\
    \xf1\x03\x08\xfc\x03\t\n\r\n\x05\x04-\x04\0\x01\x12\x04\xf1\x03\r\x16\n\
    \x0e\n\x06\x04-\x04\0\x02\0\x12\x04\xf2\x03\x10%\n\x0f\n\x07\x04-\x04\0\
    \x02\0\x01\x12\x04\xf2\x03\x10\x20\n\x0f\n\x07\x04-\x04\0\x02\0\x02\x12\
    \x04\xf2\x03#$\n\x0e\n\x06\x04-\x04\0\x02\x01\x12\x04\xf3\x03\x10\x1f\n\
    \x0f\n\x07\x04-\x04\0\x02\x01\x01\x12\x04\xf3\x03\x10\x1a\n\x0f\n\x07\
    \x04-\x04\0\x02\x01\x02\x12\x04\xf3\x03\x1d\x1e\n\x0e\n\x06\x04-\x04\0\
    \x02\x02\x12\x04\xf4\x03\x10\x1f\n\x0f\n\x07\x04-\x04\0\x02\x02\x01\x12\
    \x04\xf4\x03\x10\x1a\n\x0f\n\x07\x04-\x04\0\x02\x02\x02\x12\x04\xf4\x03\
    \x1d\x1e\n\x0e\n\x06\x04-\x04\0\x02\x03\x12\x04\xf5\x03\x10\x20\n\x0f\n\
    \x07\x04-\x04\0\x02\x03\x01\x12\x04\xf5\x03\x10\x1b\n\x0f\n\x07\x04-\x04\
    \0\x02\x03\x02\x12\x04\xf5\x03\x1e\x1f\n\x0e\n\x06\x04-\x04\0\x02\x04\
    \x12\x04\xf6\x03\x10\x1f\n\x0f\n\x07\x04-\x04\0\x02\x04\x01\x12\x04\xf6\
    \x03\x10\x1a\n\x0f\n\x07\x04-\x04\0\x02\x04\x02\x12\x04\xf6\x03\x1d\x1e\
    \n\x0e\n\x06\x04-\x04\0\x02\x05\x12\x04\xf7\x03\x10$\n\x0f\n\x07\x04-\
    \x04\0\x02\x05\x01\x12\x04\xf7\x03\x10\x1f\n\x0f\n\x07\x04-\x04\0\x02\
    \x05\x02\x12\x04\xf7\x03\"#\n\x0e\n\x06\x04-\x04\0\x02\x06\x12\x04\xf8\
    \x03\x10#\n\x0f\n\x07\x04-\x04\0\x02\x06\x01\x12\x04\xf8\x03\x10\x1e\n\
    \x0f\n\x07\x04-\x04\0\x02\x06\x02\x12\x04\xf8\x03!\"\n\x0e\n\x06\x04-\
    \x04\0\x02\x07\x12\x04\xf9\x03\x10$\n\x0f\n\x07\x04-\x04\0\x02\x07\x01\
    \x12\x04\xf9\x03\x10\x1f\n\x0f\n\x07\x04-\x04\0\x02\x07\x02\x12\x04\xf9\
    \x03\"#\n\x0e\n\x06\x04-\x04\0\x02\x08\x12\x04\xfa\x03\x10%\n\x0f\n\x07\
    \x04-\x04\0\x02\x08\x01\x12\x04\xfa\x03\x10\x20\n\x0f\n\x07\x04-\x04\0\
    \x02\x08\x02\x12\x04\xfa\x03#$\n\x0e\n\x06\x04-\x04\0\x02\t\x12\x04\xfb\
    \x03\x10&\n\x0f\n\x07\x04-\x04\0\x02\t\x01\x12\x04\xfb\x03\x10!\n\x0f\n\
    \x07\x04-\x04\0\x02\t\x02\x12\x04\xfb\x03$%\n\x0c\n\x04\x04-\x02\0\x12\
    \x04\xfe\x03\x08N\n\r\n\x05\x04-\x02\0\x04\x12\x04\xfe\x03\x08\x10\n\r\n\
    \x05\x04-\x02\0\x06\x12\x04\xfe\x03\x11B\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\xfe\x03CI\n\r\n\x05\x04-\x02\0\x03\x12\x04\xfe\x03LM\n\x0c\n\x04\
    \x04-\x02\x01\x12\x04\xff\x03\x08/\n\r\n\x05\x04-\x02\x01\x04\x12\x04\
    \xff\x03\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xff\x03\x11\x17\n\r\
    \n\x05\x04-\x02\x01\x01\x12\x04\xff\x03\x18*\n\r\n\x05\x04-\x02\x01\x03\
    \x12\x04\xff\x03-.\n\x0c\n\x02\x04.\x12\x06\x82\x04\0\x85\x04\x01\n\x0b\
    \n\x03\x04.\x01\x12\x04\x82\x04\x08&\n\x0c\n\x04\x04.\x02\0\x12\x04\x83\
    \x04\x08%\n\r\n\x05\x04.\x02\0\x04\x12\x04\x83\x04\x08\x10\n\r\n\x05\x04\
    .\x02\0\x05\x12\x04\x83\x04\x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\x83\
    \x04\x18\x20\n\r\n\x05\x04.\x02\0\x03\x12\x04\x83\x04#$\n\x0c\n\x04\x04.\
    \x02\x01\x12\x04\x84\x04\x08)\n\r\n\x05\x04.\x02\x01\x04\x12\x04\x84\x04\
    \x08\x10\n\r\n\x05\x04.\x02\x01\x05\x12\x04\x84\x04\x11\x17\n\r\n\x05\
    \x04.\x02\x01\x01\x12\x04\x84\x04\x18$\n\r\n\x05\x04.\x02\x01\x03\x12\
    \x04\x84\x04'(\n\x0c\n\x02\x04/\x12\x06\x87\x04\0\x95\x04\x01\n\x0b\n\
    \x03\x04/\x01\x12\x04\x87\x04\x08.\n\x0e\n\x04\x04/\x04\0\x12\x06\x88\
    \x04\x08\x90\x04\t\n\r\n\x05\x04/\x04\0\x01\x12\x04\x88\x04\r\x16\n\x0e\
    \n\x06\x04/\x04\0\x02\0\x12\x04\x89\x04\x10%\n\x0f\n\x07\x04/\x04\0\x02\
    \0\x01\x12\x04\x89\x04\x10\x20\n\x0f\n\x07\x04/\x04\0\x02\0\x02\x12\x04\
    \x89\x04#$\n\x0e\n\x06\x04/\x04\0\x02\x01\x12\x04\x8a\x04\x10\x1f\n\x0f\
    \n\x07\x04/\x04\0\x02\x01\x01\x12\x04\x8a\x04\x10\x1a\n\x0f\n\x07\x04/\
    \x04\0\x02\x01\x02\x12\x04\x8a\x04\x1d\x1e\n\x0e\n\x06\x04/\x04\0\x02\
    \x02\x12\x04\x8b\x04\x10\x1f\n\x0f\n\x07\x04/\x04\0\x02\x02\x01\x12\x04\
    \x8b\x04\x10\x1a\n\x0f\n\x07\x04/\x04\0\x02\x02\x02\x12\x04\x8b\x04\x1d\
    \x1e\n\x0e\n\x06\x04/\x04\0\x02\x03\x12\x04\x8c\x04\x10\x20\n\x0f\n\x07\
    \x04/\x04\0\x02\x03\x01\x12\x04\x8c\x04\x10\x1b\n\x0f\n\x07\x04/\x04\0\
    \x02\x03\x02\x12\x04\x8c\x04\x1e\x1f\n\x0e\n\x06\x04/\x04\0\x02\x04\x12\
    \x04\x8d\x04\x10\x1f\n\x0f\n\x07\x04/\x04\0\x02\x04\x01\x12\x04\x8d\x04\
    \x10\x1a\n\x0f\n\x07\x04/\x04\0\x02\x04\x02\x12\x04\x8d\x04\x1d\x1e\n\
    \x0e\n\x06\x04/\x04\0\x02\x05\x12\x04\x8e\x04\x10$\n\x0f\n\x07\x04/\x04\
    \0\x02\x05\x01\x12\x04\x8e\x04\x10\x1f\n\x0f\n\x07\x04/\x04\0\x02\x05\
    \x02\x12\x04\x8e\x04\"#\n\x0e\n\x06\x04/\x04\0\x02\x06\x12\x04\x8f\x04\
    \x10%\n\x0f\n\x07\x04/\x04\0\x02\x06\x01\x12\x04\x8f\x04\x10\x20\n\x0f\n\
    \x07\x04/\x04\0\x02\x06\x02\x12\x04\x8f\x04#$\n\x0c\n\x04\x04/\x02\0\x12\
    \x04\x92\x04\x08M\n\r\n\x05\x04/\x02\0\x04\x12\x04\x92\x04\x08\x10\n\r\n\
    \x05\x04/\x02\0\x06\x12\x04\x92\x04\x11A\n\r\n\x05\x04/\x02\0\x01\x12\
    \x04\x92\x04BH\n\r\n\x05\x04/\x02\0\x03\x12\x04\x92\x04KL\n\x0c\n\x04\
    \x04/\x02\x01\x12\x04\x93\x04\x08%\n\r\n\x05\x04/\x02\x01\x04\x12\x04\
    \x93\x04\x08\x10\n\r\n\x05\x04/\x02\x01\x05\x12\x04\x93\x04\x11\x17\n\r\
    \n\x05\x04/\x02\x01\x01\x12\x04\x93\x04\x18\x20\n\r\n\x05\x04/\x02\x01\
    \x03\x12\x04\x93\x04#$\n\x0c\n\x04\x04/\x02\x02\x12\x04\x94\x04\x084\n\r\
    \n\x05\x04/\x02\x02\x04\x12\x04\x94\x04\x08\x10\n\r\n\x05\x04/\x02\x02\
    \x06\x12\x04\x94\x04\x11#\n\r\n\x05\x04/\x02\x02\x01\x12\x04\x94\x04$/\n\
    \r\n\x05\x04/\x02\x02\x03\x12\x04\x94\x0423\n\x0c\n\x02\x040\x12\x06\x97\
    \x04\0\x99\x04\x01\n\x0b\n\x03\x040\x01\x12\x04\x97\x04\x08&\n\x0c\n\x04\
    \x040\x02\0\x12\x04\x98\x04\x08%\n\r\n\x05\x040\x02\0\x04\x12\x04\x98\
    \x04\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\x98\x04\x11\x17\n\r\n\x05\
    \x040\x02\0\x01\x12\x04\x98\x04\x18\x20\n\r\n\x05\x040\x02\0\x03\x12\x04\
    \x98\x04#$\n\x0c\n\x02\x041\x12\x06\x9b\x04\0\x9d\x04\x01\n\x0b\n\x03\
    \x041\x01\x12\x04\x9b\x04\x08*\n\x0c\n\x04\x041\x02\0\x12\x04\x9c\x04\
    \x08%\n\r\n\x05\x041\x02\0\x04\x12\x04\x9c\x04\x08\x10\n\r\n\x05\x041\
    \x02\0\x05\x12\x04\x9c\x04\x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\x9c\
    \x04\x18\x20\n\r\n\x05\x041\x02\0\x03\x12\x04\x9c\x04#$\n\x0c\n\x02\x042\
    \x12\x06\x9f\x04\0\xac\x04\x01\n\x0b\n\x03\x042\x01\x12\x04\x9f\x04\x082\
    \n\x0e\n\x04\x042\x04\0\x12\x06\xa0\x04\x08\xa9\x04\t\n\r\n\x05\x042\x04\
    \0\x01\x12\x04\xa0\x04\r\x16\n\x0e\n\x06\x042\x04\0\x02\0\x12\x04\xa1\
    \x04\x10%\n\x0f\n\x07\x042\x04\0\x02\0\x01\x12\x04\xa1\x04\x10\x20\n\x0f\
    \n\x07\x042\x04\0\x02\0\x02\x12\x04\xa1\x04#$\n\x0e\n\x06\x042\x04\0\x02\
    \x01\x12\x04\xa2\x04\x10\x1f\n\x0f\n\x07\x042\x04\0\x02\x01\x01\x12\x04\
    \xa2\x04\x10\x1a\n\x0f\n\x07\x042\x04\0\x02\x01\x02\x12\x04\xa2\x04\x1d\
    \x1e\n\x0e\n\x06\x042\x04\0\x02\x02\x12\x04\xa3\x04\x10\x1f\n\x0f\n\x07\
    \x042\x04\0\x02\x02\x01\x12\x04\xa3\x04\x10\x1a\n\x0f\n\x07\x042\x04\0\
    \x02\x02\x02\x12\x04\xa3\x04\x1d\x1e\n\x0e\n\x06\x042\x04\0\x02\x03\x12\
    \x04\xa4\x04\x10\x20\n\x0f\n\x07\x042\x04\0\x02\x03\x01\x12\x04\xa4\x04\
    \x10\x1b\n\x0f\n\x07\x042\x04\0\x02\x03\x02\x12\x04\xa4\x04\x1e\x1f\n\
    \x0e\n\x06\x042\x04\0\x02\x04\x12\x04\xa5\x04\x10\x1f\n\x0f\n\x07\x042\
    \x04\0\x02\x04\x01\x12\x04\xa5\x04\x10\x1a\n\x0f\n\x07\x042\x04\0\x02\
    \x04\x02\x12\x04\xa5\x04\x1d\x1e\n\x0e\n\x06\x042\x04\0\x02\x05\x12\x04\
    \xa6\x04\x10$\n\x0f\n\x07\x042\x04\0\x02\x05\x01\x12\x04\xa6\x04\x10\x1f\
    \n\x0f\n\x07\x042\x04\0\x02\x05\x02\x12\x04\xa6\x04\"#\n\x0e\n\x06\x042\
    \x04\0\x02\x06\x12\x04\xa7\x04\x10!\n\x0f\n\x07\x042\x04\0\x02\x06\x01\
    \x12\x04\xa7\x04\x10\x1c\n\x0f\n\x07\x042\x04\0\x02\x06\x02\x12\x04\xa7\
    \x04\x1f\x20\n\x0e\n\x06\x042\x04\0\x02\x07\x12\x04\xa8\x04\x10+\n\x0f\n\
    \x07\x042\x04\0\x02\x07\x01\x12\x04\xa8\x04\x10&\n\x0f\n\x07\x042\x04\0\
    \x02\x07\x02\x12\x04\xa8\x04)*\n\x0c\n\x04\x042\x02\0\x12\x04\xab\x04\
    \x08Q\n\r\n\x05\x042\x02\0\x04\x12\x04\xab\x04\x08\x10\n\r\n\x05\x042\
    \x02\0\x06\x12\x04\xab\x04\x11E\n\r\n\x05\x042\x02\0\x01\x12\x04\xab\x04\
    FL\n\r\n\x05\x042\x02\0\x03\x12\x04\xab\x04OP\n\x0c\n\x02\x043\x12\x06\
    \xae\x04\0\xbc\x04\x01\n\x0b\n\x03\x043\x01\x12\x04\xae\x04\x08\"\n\x0e\
    \n\x04\x043\x04\0\x12\x06\xaf\x04\x08\xb7\x04\t\n\r\n\x05\x043\x04\0\x01\
    \x12\x04\xaf\x04\r\x16\n\x0e\n\x06\x043\x04\0\x02\0\x12\x04\xb0\x04\x10%\
    \n\x0f\n\x07\x043\x04\0\x02\0\x01\x12\x04\xb0\x04\x10\x20\n\x0f\n\x07\
    \x043\x04\0\x02\0\x02\x12\x04\xb0\x04#$\n\x0e\n\x06\x043\x04\0\x02\x01\
    \x12\x04\xb1\x04\x10\x1f\n\x0f\n\x07\x043\x04\0\x02\x01\x01\x12\x04\xb1\
    \x04\x10\x1a\n\x0f\n\x07\x043\x04\0\x02\x01\x02\x12\x04\xb1\x04\x1d\x1e\
    \n\x0e\n\x06\x043\x04\0\x02\x02\x12\x04\xb2\x04\x10\x1f\n\x0f\n\x07\x043\
    \x04\0\x02\x02\x01\x12\x04\xb2\x04\x10\x1a\n\x0f\n\x07\x043\x04\0\x02\
    \x02\x02\x12\x04\xb2\x04\x1d\x1e\n\x0e\n\x06\x043\x04\0\x02\x03\x12\x04\
    \xb3\x04\x10\x20\n\x0f\n\x07\x043\x04\0\x02\x03\x01\x12\x04\xb3\x04\x10\
    \x1b\n\x0f\n\x07\x043\x04\0\x02\x03\x02\x12\x04\xb3\x04\x1e\x1f\n\x0e\n\
    \x06\x043\x04\0\x02\x04\x12\x04\xb4\x04\x10\x1f\n\x0f\n\x07\x043\x04\0\
    \x02\x04\x01\x12\x04\xb4\x04\x10\x1a\n\x0f\n\x07\x043\x04\0\x02\x04\x02\
    \x12\x04\xb4\x04\x1d\x1e\n\x0e\n\x06\x043\x04\0\x02\x05\x12\x04\xb5\x04\
    \x10\"\n\x0f\n\x07\x043\x04\0\x02\x05\x01\x12\x04\xb5\x04\x10\x1d\n\x0f\
    \n\x07\x043\x04\0\x02\x05\x02\x12\x04\xb5\x04\x20!\n\x0e\n\x06\x043\x04\
    \0\x02\x06\x12\x04\xb6\x04\x10%\n\x0f\n\x07\x043\x04\0\x02\x06\x01\x12\
    \x04\xb6\x04\x10\x20\n\x0f\n\x07\x043\x04\0\x02\x06\x02\x12\x04\xb6\x04#\
    $\n\x0c\n\x04\x043\x02\0\x12\x04\xb9\x04\x08A\n\r\n\x05\x043\x02\0\x04\
    \x12\x04\xb9\x04\x08\x10\n\r\n\x05\x043\x02\0\x06\x12\x04\xb9\x04\x115\n\
    \r\n\x05\x043\x02\0\x01\x12\x04\xb9\x046<\n\r\n\x05\x043\x02\0\x03\x12\
    \x04\xb9\x04?@\n\x0c\n\x04\x043\x02\x01\x12\x04\xba\x04\x08%\n\r\n\x05\
    \x043\x02\x01\x04\x12\x04\xba\x04\x08\x10\n\r\n\x05\x043\x02\x01\x05\x12\
    \x04\xba\x04\x11\x17\n\r\n\x05\x043\x02\x01\x01\x12\x04\xba\x04\x18\x20\
    \n\r\n\x05\x043\x02\x01\x03\x12\x04\xba\x04#$\n\x0c\n\x04\x043\x02\x02\
    \x12\x04\xbb\x04\x084\n\r\n\x05\x043\x02\x02\x04\x12\x04\xbb\x04\x08\x10\
    \n\r\n\x05\x043\x02\x02\x06\x12\x04\xbb\x04\x11!\n\r\n\x05\x043\x02\x02\
    \x01\x12\x04\xbb\x04\"/\n\r\n\x05\x043\x02\x02\x03\x12\x04\xbb\x0423\n\
    \x0c\n\x02\x044\x12\x06\xbe\x04\0\xcf\x04\x01\n\x0b\n\x03\x044\x01\x12\
    \x04\xbe\x04\x08'\n\x0e\n\x04\x044\x03\0\x12\x06\xbf\x04\x08\xc2\x04\t\n\
    \r\n\x05\x044\x03\0\x01\x12\x04\xbf\x04\x10\x1c\n\x0e\n\x06\x044\x03\0\
    \x02\0\x12\x04\xc0\x04\x10-\n\x0f\n\x07\x044\x03\0\x02\0\x04\x12\x04\xc0\
    \x04\x10\x18\n\x0f\n\x07\x044\x03\0\x02\0\x05\x12\x04\xc0\x04\x19\x1f\n\
    \x0f\n\x07\x044\x03\0\x02\0\x01\x12\x04\xc0\x04\x20(\n\x0f\n\x07\x044\
    \x03\0\x02\0\x03\x12\x04\xc0\x04+,\n\x0e\n\x06\x044\x03\0\x02\x01\x12\
    \x04\xc1\x04\x10<\n\x0f\n\x07\x044\x03\0\x02\x01\x04\x12\x04\xc1\x04\x10\
    \x18\n\x0f\n\x07\x044\x03\0\x02\x01\x06\x12\x04\xc1\x04\x19)\n\x0f\n\x07\
    \x044\x03\0\x02\x01\x01\x12\x04\xc1\x04*7\n\x0f\n\x07\x044\x03\0\x02\x01\
    \x03\x12\x04\xc1\x04:;\n\x0e\n\x04\x044\x04\0\x12\x06\xc4\x04\x08\xca\
    \x04\t\n\r\n\x05\x044\x04\0\x01\x12\x04\xc4\x04\r\x16\n\x0e\n\x06\x044\
    \x04\0\x02\0\x12\x04\xc5\x04\x10%\n\x0f\n\x07\x044\x04\0\x02\0\x01\x12\
    \x04\xc5\x04\x10\x20\n\x0f\n\x07\x044\x04\0\x02\0\x02\x12\x04\xc5\x04#$\
    \n\x0e\n\x06\x044\x04\0\x02\x01\x12\x04\xc6\x04\x10\x1f\n\x0f\n\x07\x044\
    \x04\0\x02\x01\x01\x12\x04\xc6\x04\x10\x1a\n\x0f\n\x07\x044\x04\0\x02\
    \x01\x02\x12\x04\xc6\x04\x1d\x1e\n\x0e\n\x06\x044\x04\0\x02\x02\x12\x04\
    \xc7\x04\x10\x1f\n\x0f\n\x07\x044\x04\0\x02\x02\x01\x12\x04\xc7\x04\x10\
    \x1a\n\x0f\n\x07\x044\x04\0\x02\x02\x02\x12\x04\xc7\x04\x1d\x1e\n\x0e\n\
    \x06\x044\x04\0\x02\x03\x12\x04\xc8\x04\x10\x20\n\x0f\n\x07\x044\x04\0\
    \x02\x03\x01\x12\x04\xc8\x04\x10\x1b\n\x0f\n\x07\x044\x04\0\x02\x03\x02\
    \x12\x04\xc8\x04\x1e\x1f\n\x0e\n\x06\x044\x04\0\x02\x04\x12\x04\xc9\x04\
    \x10\x1f\n\x0f\n\x07\x044\x04\0\x02\x04\x01\x12\x04\xc9\x04\x10\x1a\n\
    \x0f\n\x07\x044\x04\0\x02\x04\x02\x12\x04\xc9\x04\x1d\x1e\n\x0c\n\x04\
    \x044\x02\0\x12\x04\xcc\x04\x08F\n\r\n\x05\x044\x02\0\x04\x12\x04\xcc\
    \x04\x08\x10\n\r\n\x05\x044\x02\0\x06\x12\x04\xcc\x04\x11:\n\r\n\x05\x04\
    4\x02\0\x01\x12\x04\xcc\x04;A\n\r\n\x05\x044\x02\0\x03\x12\x04\xcc\x04DE\
    \n\x0c\n\x04\x044\x02\x01\x12\x04\xcd\x04\x08Q\n\r\n\x05\x044\x02\x01\
    \x04\x12\x04\xcd\x04\x08\x10\n\r\n\x05\x044\x02\x01\x06\x12\x04\xcd\x04\
    \x11=\n\r\n\x05\x044\x02\x01\x01\x12\x04\xcd\x04>L\n\r\n\x05\x044\x02\
    \x01\x03\x12\x04\xcd\x04OP\n\x0c\n\x04\x044\x02\x02\x12\x04\xce\x04\x08(\
    \n\r\n\x05\x044\x02\x02\x04\x12\x04\xce\x04\x08\x10\n\r\n\x05\x044\x02\
    \x02\x05\x12\x04\xce\x04\x11\x15\n\r\n\x05\x044\x02\x02\x01\x12\x04\xce\
    \x04\x16#\n\r\n\x05\x044\x02\x02\x03\x12\x04\xce\x04&'\n\x0c\n\x02\x045\
    \x12\x06\xd1\x04\0\xdc\x04\x01\n\x0b\n\x03\x045\x01\x12\x04\xd1\x04\x08(\
    \n\x0e\n\x04\x045\x04\0\x12\x06\xd2\x04\x08\xd8\x04\t\n\r\n\x05\x045\x04\
    \0\x01\x12\x04\xd2\x04\r\x1a\n\x0e\n\x06\x045\x04\0\x02\0\x12\x04\xd3\
    \x04\x10\x1c\n\x0f\n\x07\x045\x04\0\x02\0\x01\x12\x04\xd3\x04\x10\x17\n\
    \x0f\n\x07\x045\x04\0\x02\0\x02\x12\x04\xd3\x04\x1a\x1b\n\x0e\n\x06\x045\
    \x04\0\x02\x01\x12\x04\xd4\x04\x10)\n\x0f\n\x07\x045\x04\0\x02\x01\x01\
    \x12\x04\xd4\x04\x10$\n\x0f\n\x07\x045\x04\0\x02\x01\x02\x12\x04\xd4\x04\
    '(\n\x0e\n\x06\x045\x04\0\x02\x02\x12\x04\xd5\x04\x10(\n\x0f\n\x07\x045\
    \x04\0\x02\x02\x01\x12\x04\xd5\x04\x10#\n\x0f\n\x07\x045\x04\0\x02\x02\
    \x02\x12\x04\xd5\x04&'\n\x0e\n\x06\x045\x04\0\x02\x03\x12\x04\xd6\x04\
    \x10)\n\x0f\n\x07\x045\x04\0\x02\x03\x01\x12\x04\xd6\x04\x10$\n\x0f\n\
    \x07\x045\x04\0\x02\x03\x02\x12\x04\xd6\x04'(\n\x0e\n\x06\x045\x04\0\x02\
    \x04\x12\x04\xd7\x04\x10\"\n\x0f\n\x07\x045\x04\0\x02\x04\x01\x12\x04\
    \xd7\x04\x10\x1d\n\x0f\n\x07\x045\x04\0\x02\x04\x02\x12\x04\xd7\x04\x20!\
    \n\x0c\n\x04\x045\x02\0\x12\x04\xda\x04\x08%\n\r\n\x05\x045\x02\0\x04\
    \x12\x04\xda\x04\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\xda\x04\x11\
    \x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xda\x04\x18\x20\n\r\n\x05\x045\x02\
    \0\x03\x12\x04\xda\x04#$\n\x0c\n\x04\x045\x02\x01\x12\x04\xdb\x04\x080\n\
    \r\n\x05\x045\x02\x01\x04\x12\x04\xdb\x04\x08\x10\n\r\n\x05\x045\x02\x01\
    \x05\x12\x04\xdb\x04\x11\x17\n\r\n\x05\x045\x02\x01\x01\x12\x04\xdb\x04\
    \x18+\n\r\n\x05\x045\x02\x01\x03\x12\x04\xdb\x04./\n\x0c\n\x02\x046\x12\
    \x06\xde\x04\0\xea\x04\x01\n\x0b\n\x03\x046\x01\x12\x04\xde\x04\x080\n\
    \x0e\n\x04\x046\x04\0\x12\x06\xdf\x04\x08\xe7\x04\t\n\r\n\x05\x046\x04\0\
    \x01\x12\x04\xdf\x04\r\x16\n\x0e\n\x06\x046\x04\0\x02\0\x12\x04\xe0\x04\
    \x10%\n\x0f\n\x07\x046\x04\0\x02\0\x01\x12\x04\xe0\x04\x10\x20\n\x0f\n\
    \x07\x046\x04\0\x02\0\x02\x12\x04\xe0\x04#$\n\x0e\n\x06\x046\x04\0\x02\
    \x01\x12\x04\xe1\x04\x10\x1f\n\x0f\n\x07\x046\x04\0\x02\x01\x01\x12\x04\
    \xe1\x04\x10\x1a\n\x0f\n\x07\x046\x04\0\x02\x01\x02\x12\x04\xe1\x04\x1d\
    \x1e\n\x0e\n\x06\x046\x04\0\x02\x02\x12\x04\xe2\x04\x10\x1f\n\x0f\n\x07\
    \x046\x04\0\x02\x02\x01\x12\x04\xe2\x04\x10\x1a\n\x0f\n\x07\x046\x04\0\
    \x02\x02\x02\x12\x04\xe2\x04\x1d\x1e\n\x0e\n\x06\x046\x04\0\x02\x03\x12\
    \x04\xe3\x04\x10\x20\n\x0f\n\x07\x046\x04\0\x02\x03\x01\x12\x04\xe3\x04\
    \x10\x1b\n\x0f\n\x07\x046\x04\0\x02\x03\x02\x12\x04\xe3\x04\x1e\x1f\n\
    \x0e\n\x06\x046\x04\0\x02\x04\x12\x04\xe4\x04\x10\x1f\n\x0f\n\x07\x046\
    \x04\0\x02\x04\x01\x12\x04\xe4\x04\x10\x1a\n\x0f\n\x07\x046\x04\0\x02\
    \x04\x02\x12\x04\xe4\x04\x1d\x1e\n\x0e\n\x06\x046\x04\0\x02\x05\x12\x04\
    \xe5\x04\x10%\n\x0f\n\x07\x046\x04\0\x02\x05\x01\x12\x04\xe5\x04\x10\x20\
    \n\x0f\n\x07\x046\x04\0\x02\x05\x02\x12\x04\xe5\x04#$\n\x0e\n\x06\x046\
    \x04\0\x02\x06\x12\x04\xe6\x04\x10$\n\x0f\n\x07\x046\x04\0\x02\x06\x01\
    \x12\x04\xe6\x04\x10\x1f\n\x0f\n\x07\x046\x04\0\x02\x06\x02\x12\x04\xe6\
    \x04\"#\n\x0c\n\x04\x046\x02\0\x12\x04\xe9\x04\x08O\n\r\n\x05\x046\x02\0\
    \x04\x12\x04\xe9\x04\x08\x10\n\r\n\x05\x046\x02\0\x06\x12\x04\xe9\x04\
    \x11C\n\r\n\x05\x046\x02\0\x01\x12\x04\xe9\x04DJ\n\r\n\x05\x046\x02\0\
    \x03\x12\x04\xe9\x04MN\n\x0c\n\x02\x047\x12\x06\xec\x04\0\xee\x04\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xec\x04\x084\n\x0c\n\x04\x047\x02\0\x12\x04\
    \xed\x04\x08'\n\r\n\x05\x047\x02\0\x04\x12\x04\xed\x04\x08\x10\n\r\n\x05\
    \x047\x02\0\x05\x12\x04\xed\x04\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \xed\x04\x18\"\n\r\n\x05\x047\x02\0\x03\x12\x04\xed\x04%&\n\x0c\n\x02\
    \x048\x12\x06\xf0\x04\0\xfc\x04\x01\n\x0b\n\x03\x048\x01\x12\x04\xf0\x04\
    \x08<\n\x0e\n\x04\x048\x04\0\x12\x06\xf1\x04\x08\xf8\x04\t\n\r\n\x05\x04\
    8\x04\0\x01\x12\x04\xf1\x04\r\x16\n\x0e\n\x06\x048\x04\0\x02\0\x12\x04\
    \xf2\x04\x10%\n\x0f\n\x07\x048\x04\0\x02\0\x01\x12\x04\xf2\x04\x10\x20\n\
    \x0f\n\x07\x048\x04\0\x02\0\x02\x12\x04\xf2\x04#$\n\x0e\n\x06\x048\x04\0\
    \x02\x01\x12\x04\xf3\x04\x10\x1f\n\x0f\n\x07\x048\x04\0\x02\x01\x01\x12\
    \x04\xf3\x04\x10\x1a\n\x0f\n\x07\x048\x04\0\x02\x01\x02\x12\x04\xf3\x04\
    \x1d\x1e\n\x0e\n\x06\x048\x04\0\x02\x02\x12\x04\xf4\x04\x10\x1f\n\x0f\n\
    \x07\x048\x04\0\x02\x02\x01\x12\x04\xf4\x04\x10\x1a\n\x0f\n\x07\x048\x04\
    \0\x02\x02\x02\x12\x04\xf4\x04\x1d\x1e\n\x0e\n\x06\x048\x04\0\x02\x03\
    \x12\x04\xf5\x04\x10\x20\n\x0f\n\x07\x048\x04\0\x02\x03\x01\x12\x04\xf5\
    \x04\x10\x1b\n\x0f\n\x07\x048\x04\0\x02\x03\x02\x12\x04\xf5\x04\x1e\x1f\
    \n\x0e\n\x06\x048\x04\0\x02\x04\x12\x04\xf6\x04\x10\x1f\n\x0f\n\x07\x048\
    \x04\0\x02\x04\x01\x12\x04\xf6\x04\x10\x1a\n\x0f\n\x07\x048\x04\0\x02\
    \x04\x02\x12\x04\xf6\x04\x1d\x1e\n\x0e\n\x06\x048\x04\0\x02\x05\x12\x04\
    \xf7\x04\x10&\n\x0f\n\x07\x048\x04\0\x02\x05\x01\x12\x04\xf7\x04\x10!\n\
    \x0f\n\x07\x048\x04\0\x02\x05\x02\x12\x04\xf7\x04$%\n\x0c\n\x04\x048\x02\
    \0\x12\x04\xfa\x04\x08[\n\r\n\x05\x048\x02\0\x04\x12\x04\xfa\x04\x08\x10\
    \n\r\n\x05\x048\x02\0\x06\x12\x04\xfa\x04\x11O\n\r\n\x05\x048\x02\0\x01\
    \x12\x04\xfa\x04PV\n\r\n\x05\x048\x02\0\x03\x12\x04\xfa\x04YZ\n\x0c\n\
    \x04\x048\x02\x01\x12\x04\xfb\x04\x08?\n\r\n\x05\x048\x02\x01\x04\x12\
    \x04\xfb\x04\x08\x10\n\r\n\x05\x048\x02\x01\x06\x12\x04\xfb\x04\x11-\n\r\
    \n\x05\x048\x02\x01\x01\x12\x04\xfb\x04.:\n\r\n\x05\x048\x02\x01\x03\x12\
    \x04\xfb\x04=>\n\x0c\n\x02\x049\x12\x06\xfe\x04\0\x80\x05\x01\n\x0b\n\
    \x03\x049\x01\x12\x04\xfe\x04\x089\n\x0c\n\x04\x049\x02\0\x12\x04\xff\
    \x04\x08(\n\r\n\x05\x049\x02\0\x04\x12\x04\xff\x04\x08\x10\n\r\n\x05\x04\
    9\x02\0\x05\x12\x04\xff\x04\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xff\
    \x04\x18#\n\r\n\x05\x049\x02\0\x03\x12\x04\xff\x04&'\n\x0c\n\x02\x04:\
    \x12\x06\x82\x05\0\x8e\x05\x01\n\x0b\n\x03\x04:\x01\x12\x04\x82\x05\x08A\
    \n\x0e\n\x04\x04:\x04\0\x12\x06\x83\x05\x08\x8a\x05\t\n\r\n\x05\x04:\x04\
    \0\x01\x12\x04\x83\x05\r\x16\n\x0e\n\x06\x04:\x04\0\x02\0\x12\x04\x84\
    \x05\x10%\n\x0f\n\x07\x04:\x04\0\x02\0\x01\x12\x04\x84\x05\x10\x20\n\x0f\
    \n\x07\x04:\x04\0\x02\0\x02\x12\x04\x84\x05#$\n\x0e\n\x06\x04:\x04\0\x02\
    \x01\x12\x04\x85\x05\x10\x1f\n\x0f\n\x07\x04:\x04\0\x02\x01\x01\x12\x04\
    \x85\x05\x10\x1a\n\x0f\n\x07\x04:\x04\0\x02\x01\x02\x12\x04\x85\x05\x1d\
    \x1e\n\x0e\n\x06\x04:\x04\0\x02\x02\x12\x04\x86\x05\x10\x1f\n\x0f\n\x07\
    \x04:\x04\0\x02\x02\x01\x12\x04\x86\x05\x10\x1a\n\x0f\n\x07\x04:\x04\0\
    \x02\x02\x02\x12\x04\x86\x05\x1d\x1e\n\x0e\n\x06\x04:\x04\0\x02\x03\x12\
    \x04\x87\x05\x10\x20\n\x0f\n\x07\x04:\x04\0\x02\x03\x01\x12\x04\x87\x05\
    \x10\x1b\n\x0f\n\x07\x04:\x04\0\x02\x03\x02\x12\x04\x87\x05\x1e\x1f\n\
    \x0e\n\x06\x04:\x04\0\x02\x04\x12\x04\x88\x05\x10\x1f\n\x0f\n\x07\x04:\
    \x04\0\x02\x04\x01\x12\x04\x88\x05\x10\x1a\n\x0f\n\x07\x04:\x04\0\x02\
    \x04\x02\x12\x04\x88\x05\x1d\x1e\n\x0e\n\x06\x04:\x04\0\x02\x05\x12\x04\
    \x89\x05\x10&\n\x0f\n\x07\x04:\x04\0\x02\x05\x01\x12\x04\x89\x05\x10!\n\
    \x0f\n\x07\x04:\x04\0\x02\x05\x02\x12\x04\x89\x05$%\n\x0c\n\x04\x04:\x02\
    \0\x12\x04\x8c\x05\x08`\n\r\n\x05\x04:\x02\0\x04\x12\x04\x8c\x05\x08\x10\
    \n\r\n\x05\x04:\x02\0\x06\x12\x04\x8c\x05\x11T\n\r\n\x05\x04:\x02\0\x01\
    \x12\x04\x8c\x05U[\n\r\n\x05\x04:\x02\0\x03\x12\x04\x8c\x05^_\n\x0c\n\
    \x04\x04:\x02\x01\x12\x04\x8d\x05\x08@\n\r\n\x05\x04:\x02\x01\x04\x12\
    \x04\x8d\x05\x08\x10\n\r\n\x05\x04:\x02\x01\x06\x12\x04\x8d\x05\x11-\n\r\
    \n\x05\x04:\x02\x01\x01\x12\x04\x8d\x05.;\n\r\n\x05\x04:\x02\x01\x03\x12\
    \x04\x8d\x05>?\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(61);
            messages.push(CMsgGuildInfo::generated_message_descriptor_data());
            messages.push(CMsgGuildSummary::generated_message_descriptor_data());
            messages.push(CMsgGuildRole::generated_message_descriptor_data());
            messages.push(CMsgGuildMember::generated_message_descriptor_data());
            messages.push(CMsgGuildInvite::generated_message_descriptor_data());
            messages.push(CMsgGuildData::generated_message_descriptor_data());
            messages.push(CMsgAccountGuildInvite::generated_message_descriptor_data());
            messages.push(CMsgAccountGuildMemberships::generated_message_descriptor_data());
            messages.push(CMsgGuildPersonaInfo::generated_message_descriptor_data());
            messages.push(CMsgAccountGuildsPersonaInfo::generated_message_descriptor_data());
            messages.push(CMsgGuildFeedEvent::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCreateGuild::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCreateGuildResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetGuildInfo::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetGuildInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestGuildData::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestGuildDataResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientGuildDataUpdated::generated_message_descriptor_data());
            messages.push(CMsgGCToClientGuildMembersDataUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestGuildMembership::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestGuildMembershipResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientGuildMembershipUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCJoinGuild::generated_message_descriptor_data());
            messages.push(CMsgClientToGCJoinGuildResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCLeaveGuild::generated_message_descriptor_data());
            messages.push(CMsgClientToGCLeaveGuildResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCKickGuildMember::generated_message_descriptor_data());
            messages.push(CMsgClientToGCKickGuildMemberResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetGuildMemberRole::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetGuildMemberRoleResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCInviteToGuild::generated_message_descriptor_data());
            messages.push(CMsgClientToGCInviteToGuildResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCDeclineInviteToGuild::generated_message_descriptor_data());
            messages.push(CMsgClientToGCDeclineInviteToGuildResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAcceptInviteToGuild::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAcceptInviteToGuildResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCancelInviteToGuild::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCancelInviteToGuildResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAddGuildRole::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAddGuildRoleResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCModifyGuildRole::generated_message_descriptor_data());
            messages.push(CMsgClientToGCModifyGuildRoleResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRemoveGuildRole::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRemoveGuildRoleResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetGuildRoleOrder::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetGuildRoleOrderResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGuildFeedRequest::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestGuildFeedResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientGuildFeedUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAddPlayerToGuildChat::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAddPlayerToGuildChatResponse::generated_message_descriptor_data());
            messages.push(CMsgFindGuildByTagResponse::generated_message_descriptor_data());
            messages.push(CMsgSearchForOpenGuildsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCReportGuildContent::generated_message_descriptor_data());
            messages.push(CMsgClientToGCReportGuildContentResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestAccountGuildPersonaInfo::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestAccountGuildPersonaInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestAccountGuildPersonaInfoBatch::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse::generated_message_descriptor_data());
            messages.push(cmsg_guild_summary::EventPoints::generated_message_descriptor_data());
            messages.push(cmsg_search_for_open_guilds_response::SearchResult::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(26);
            enums.push(EGuildAuditAction::generated_enum_descriptor_data());
            enums.push(EGuildChatType::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccreate_guild_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcset_guild_info_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_guild_data_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_guild_membership_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcjoin_guild_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcleave_guild_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gckick_guild_member_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcset_guild_member_role_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcinvite_to_guild_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcdecline_invite_to_guild_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcaccept_invite_to_guild_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccancel_invite_to_guild_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcadd_guild_role_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcmodify_guild_role_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcremove_guild_role_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcset_guild_role_order_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_guild_feed_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_find_guild_by_tag_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_search_for_open_guilds_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcreport_guild_content::EContentFlags::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcreport_guild_content_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
