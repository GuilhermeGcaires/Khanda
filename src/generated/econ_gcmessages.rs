// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `econ_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgApplyAutograph)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyAutograph {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgApplyAutograph.autograph_item_id)
    pub autograph_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgApplyAutograph.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgApplyAutograph.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyAutograph {
    fn default() -> &'a CMsgApplyAutograph {
        <CMsgApplyAutograph as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyAutograph {
    pub fn new() -> CMsgApplyAutograph {
        ::std::default::Default::default()
    }

    // optional uint64 autograph_item_id = 1;

    pub fn autograph_item_id(&self) -> u64 {
        self.autograph_item_id.unwrap_or(0)
    }

    pub fn clear_autograph_item_id(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
    }

    pub fn has_autograph_item_id(&self) -> bool {
        self.autograph_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_item_id(&mut self, v: u64) {
        self.autograph_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autograph_item_id",
            |m: &CMsgApplyAutograph| { &m.autograph_item_id },
            |m: &mut CMsgApplyAutograph| { &mut m.autograph_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgApplyAutograph| { &m.item_item_id },
            |m: &mut CMsgApplyAutograph| { &mut m.item_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyAutograph>(
            "CMsgApplyAutograph",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyAutograph {
    const NAME: &'static str = "CMsgApplyAutograph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.autograph_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.autograph_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.autograph_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyAutograph {
        CMsgApplyAutograph::new()
    }

    fn clear(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyAutograph {
        static instance: CMsgApplyAutograph = CMsgApplyAutograph {
            autograph_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyAutograph {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyAutograph").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyAutograph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyAutograph {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAdjustItemEquippedState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAdjustItemEquippedState {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAdjustItemEquippedState.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgAdjustItemEquippedState.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAdjustItemEquippedState.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAdjustItemEquippedState.style_index)
    pub style_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAdjustItemEquippedState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedState {
    fn default() -> &'a CMsgAdjustItemEquippedState {
        <CMsgAdjustItemEquippedState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_class = 2;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 3;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 4;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgAdjustItemEquippedState| { &m.item_id },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_class",
            |m: &CMsgAdjustItemEquippedState| { &m.new_class },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_slot",
            |m: &CMsgAdjustItemEquippedState| { &m.new_slot },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_index",
            |m: &CMsgAdjustItemEquippedState| { &m.style_index },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.style_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAdjustItemEquippedState>(
            "CMsgAdjustItemEquippedState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedState {
    const NAME: &'static str = "CMsgAdjustItemEquippedState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static instance: CMsgAdjustItemEquippedState = CMsgAdjustItemEquippedState {
            item_id: ::std::option::Option::None,
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAdjustItemEquippedState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAdjustItemEquippedState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAdjustItemEquippedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgEconPlayerStrangeCountAdjustment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEconPlayerStrangeCountAdjustment {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgEconPlayerStrangeCountAdjustment.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgEconPlayerStrangeCountAdjustment.strange_count_adjustments)
    pub strange_count_adjustments: ::std::vec::Vec<cmsg_econ_player_strange_count_adjustment::CStrangeCountAdjustment>,
    // @@protoc_insertion_point(field:dota.CMsgEconPlayerStrangeCountAdjustment.turbo_mode)
    pub turbo_mode: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgEconPlayerStrangeCountAdjustment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEconPlayerStrangeCountAdjustment {
    fn default() -> &'a CMsgEconPlayerStrangeCountAdjustment {
        <CMsgEconPlayerStrangeCountAdjustment as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEconPlayerStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool turbo_mode = 3;

    pub fn turbo_mode(&self) -> bool {
        self.turbo_mode.unwrap_or(false)
    }

    pub fn clear_turbo_mode(&mut self) {
        self.turbo_mode = ::std::option::Option::None;
    }

    pub fn has_turbo_mode(&self) -> bool {
        self.turbo_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turbo_mode(&mut self, v: bool) {
        self.turbo_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgEconPlayerStrangeCountAdjustment| { &m.account_id },
            |m: &mut CMsgEconPlayerStrangeCountAdjustment| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strange_count_adjustments",
            |m: &CMsgEconPlayerStrangeCountAdjustment| { &m.strange_count_adjustments },
            |m: &mut CMsgEconPlayerStrangeCountAdjustment| { &mut m.strange_count_adjustments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "turbo_mode",
            |m: &CMsgEconPlayerStrangeCountAdjustment| { &m.turbo_mode },
            |m: &mut CMsgEconPlayerStrangeCountAdjustment| { &mut m.turbo_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgEconPlayerStrangeCountAdjustment>(
            "CMsgEconPlayerStrangeCountAdjustment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment {
    const NAME: &'static str = "CMsgEconPlayerStrangeCountAdjustment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.strange_count_adjustments.push(is.read_message()?);
                },
                24 => {
                    self.turbo_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.strange_count_adjustments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.turbo_mode {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.strange_count_adjustments {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.turbo_mode {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.strange_count_adjustments.clear();
        self.turbo_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment {
        static instance: CMsgEconPlayerStrangeCountAdjustment = CMsgEconPlayerStrangeCountAdjustment {
            account_id: ::std::option::Option::None,
            strange_count_adjustments: ::std::vec::Vec::new(),
            turbo_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgEconPlayerStrangeCountAdjustment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgEconPlayerStrangeCountAdjustment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgEconPlayerStrangeCountAdjustment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEconPlayerStrangeCountAdjustment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgEconPlayerStrangeCountAdjustment`
pub mod cmsg_econ_player_strange_count_adjustment {
    // @@protoc_insertion_point(message:dota.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CStrangeCountAdjustment {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.event_type)
        pub event_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.adjustment)
        pub adjustment: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CStrangeCountAdjustment {
        fn default() -> &'a CStrangeCountAdjustment {
            <CStrangeCountAdjustment as ::protobuf::Message>::default_instance()
        }
    }

    impl CStrangeCountAdjustment {
        pub fn new() -> CStrangeCountAdjustment {
            ::std::default::Default::default()
        }

        // optional uint32 event_type = 1;

        pub fn event_type(&self) -> u32 {
            self.event_type.unwrap_or(0)
        }

        pub fn clear_event_type(&mut self) {
            self.event_type = ::std::option::Option::None;
        }

        pub fn has_event_type(&self) -> bool {
            self.event_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_type(&mut self, v: u32) {
            self.event_type = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 2;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 adjustment = 3;

        pub fn adjustment(&self) -> u32 {
            self.adjustment.unwrap_or(0)
        }

        pub fn clear_adjustment(&mut self) {
            self.adjustment = ::std::option::Option::None;
        }

        pub fn has_adjustment(&self) -> bool {
            self.adjustment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_adjustment(&mut self, v: u32) {
            self.adjustment = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_type",
                |m: &CStrangeCountAdjustment| { &m.event_type },
                |m: &mut CStrangeCountAdjustment| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &CStrangeCountAdjustment| { &m.item_id },
                |m: &mut CStrangeCountAdjustment| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "adjustment",
                |m: &CStrangeCountAdjustment| { &m.adjustment },
                |m: &mut CStrangeCountAdjustment| { &mut m.adjustment },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CStrangeCountAdjustment>(
                "CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CStrangeCountAdjustment {
        const NAME: &'static str = "CStrangeCountAdjustment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.adjustment = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.adjustment {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.event_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.adjustment {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CStrangeCountAdjustment {
            CStrangeCountAdjustment::new()
        }

        fn clear(&mut self) {
            self.event_type = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.adjustment = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CStrangeCountAdjustment {
            static instance: CStrangeCountAdjustment = CStrangeCountAdjustment {
                event_type: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                adjustment: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CStrangeCountAdjustment {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CStrangeCountAdjustment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CStrangeCountAdjustment {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgCraftingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftingResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCraftingResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCraftingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftingResponse {
    fn default() -> &'a CMsgCraftingResponse {
        <CMsgCraftingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftingResponse {
    pub fn new() -> CMsgCraftingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgCraftingResponse| { &m.item_ids },
            |m: &mut CMsgCraftingResponse| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCraftingResponse>(
            "CMsgCraftingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCraftingResponse {
    const NAME: &'static str = "CMsgCraftingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftingResponse {
        CMsgCraftingResponse::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftingResponse {
        static instance: CMsgCraftingResponse = CMsgCraftingResponse {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCraftingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCraftingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCraftingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCRequestStoreSalesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesData.currency)
    pub currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCRequestStoreSalesData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesData {
    fn default() -> &'a CMsgGCRequestStoreSalesData {
        <CMsgGCRequestStoreSalesData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesData {
    pub fn new() -> CMsgGCRequestStoreSalesData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 2;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCRequestStoreSalesData| { &m.version },
            |m: &mut CMsgGCRequestStoreSalesData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgGCRequestStoreSalesData| { &m.currency },
            |m: &mut CMsgGCRequestStoreSalesData| { &mut m.currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestStoreSalesData>(
            "CMsgGCRequestStoreSalesData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesData {
    const NAME: &'static str = "CMsgGCRequestStoreSalesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesData {
        CMsgGCRequestStoreSalesData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesData {
        static instance: CMsgGCRequestStoreSalesData = CMsgGCRequestStoreSalesData {
            version: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestStoreSalesData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestStoreSalesData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCRequestStoreSalesDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesDataResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesDataResponse.sale_price)
    pub sale_price: ::std::vec::Vec<cmsg_gcrequest_store_sales_data_response::Price>,
    // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesDataResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesDataResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCRequestStoreSalesDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataResponse {
        <CMsgGCRequestStoreSalesDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 2;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sale_price",
            |m: &CMsgGCRequestStoreSalesDataResponse| { &m.sale_price },
            |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.sale_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCRequestStoreSalesDataResponse| { &m.version },
            |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_time",
            |m: &CMsgGCRequestStoreSalesDataResponse| { &m.expiration_time },
            |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.expiration_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestStoreSalesDataResponse>(
            "CMsgGCRequestStoreSalesDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sale_price.push(is.read_message()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sale_price {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sale_price {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataResponse {
        CMsgGCRequestStoreSalesDataResponse::new()
    }

    fn clear(&mut self) {
        self.sale_price.clear();
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse {
        static instance: CMsgGCRequestStoreSalesDataResponse = CMsgGCRequestStoreSalesDataResponse {
            sale_price: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestStoreSalesDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestStoreSalesDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCRequestStoreSalesDataResponse`
pub mod cmsg_gcrequest_store_sales_data_response {
    // @@protoc_insertion_point(message:dota.CMsgGCRequestStoreSalesDataResponse.Price)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Price {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesDataResponse.Price.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesDataResponse.Price.price)
        pub price: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCRequestStoreSalesDataResponse.Price.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Price {
        fn default() -> &'a Price {
            <Price as ::protobuf::Message>::default_instance()
        }
    }

    impl Price {
        pub fn new() -> Price {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 price = 2;

        pub fn price(&self) -> u32 {
            self.price.unwrap_or(0)
        }

        pub fn clear_price(&mut self) {
            self.price = ::std::option::Option::None;
        }

        pub fn has_price(&self) -> bool {
            self.price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price(&mut self, v: u32) {
            self.price = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_def",
                |m: &Price| { &m.item_def },
                |m: &mut Price| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "price",
                |m: &Price| { &m.price },
                |m: &mut Price| { &mut m.price },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Price>(
                "CMsgGCRequestStoreSalesDataResponse.Price",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Price {
        const NAME: &'static str = "Price";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.price = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.price {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.price {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Price {
            Price::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.price = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Price {
            static instance: Price = Price {
                item_def: ::std::option::Option::None,
                price: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Price {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesDataResponse.Price").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Price {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Price {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCRequestStoreSalesDataUpToDateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesDataUpToDateResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesDataUpToDateResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCRequestStoreSalesDataUpToDateResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCRequestStoreSalesDataUpToDateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
        <CMsgGCRequestStoreSalesDataUpToDateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataUpToDateResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 2;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCRequestStoreSalesDataUpToDateResponse| { &m.version },
            |m: &mut CMsgGCRequestStoreSalesDataUpToDateResponse| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_time",
            |m: &CMsgGCRequestStoreSalesDataUpToDateResponse| { &m.expiration_time },
            |m: &mut CMsgGCRequestStoreSalesDataUpToDateResponse| { &mut m.expiration_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestStoreSalesDataUpToDateResponse>(
            "CMsgGCRequestStoreSalesDataUpToDateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataUpToDateResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataUpToDateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        CMsgGCRequestStoreSalesDataUpToDateResponse::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataUpToDateResponse {
        static instance: CMsgGCRequestStoreSalesDataUpToDateResponse = CMsgGCRequestStoreSalesDataUpToDateResponse {
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesDataUpToDateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataUpToDateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCPingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingRequest {
    fn default() -> &'a CMsgGCToGCPingRequest {
        <CMsgGCToGCPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingRequest {
    pub fn new() -> CMsgGCToGCPingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCPingRequest>(
            "CMsgGCToGCPingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCPingRequest {
    const NAME: &'static str = "CMsgGCToGCPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingRequest {
        CMsgGCToGCPingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingRequest {
        static instance: CMsgGCToGCPingRequest = CMsgGCToGCPingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCPingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCPingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCPingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPingResponse {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCPingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingResponse {
    fn default() -> &'a CMsgGCToGCPingResponse {
        <CMsgGCToGCPingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingResponse {
    pub fn new() -> CMsgGCToGCPingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCPingResponse>(
            "CMsgGCToGCPingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCPingResponse {
    const NAME: &'static str = "CMsgGCToGCPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingResponse {
        CMsgGCToGCPingResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingResponse {
        static instance: CMsgGCToGCPingResponse = CMsgGCToGCPingResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCPingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCPingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGetUserSessionServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserSessionServer {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetUserSessionServer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGetUserSessionServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServer {
    fn default() -> &'a CMsgGCToGCGetUserSessionServer {
        <CMsgGCToGCGetUserSessionServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServer {
    pub fn new() -> CMsgGCToGCGetUserSessionServer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCGetUserSessionServer| { &m.account_id },
            |m: &mut CMsgGCToGCGetUserSessionServer| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserSessionServer>(
            "CMsgGCToGCGetUserSessionServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServer {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServer {
        CMsgGCToGCGetUserSessionServer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServer {
        static instance: CMsgGCToGCGetUserSessionServer = CMsgGCToGCGetUserSessionServer {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserSessionServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserSessionServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserSessionServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGetUserSessionServerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserSessionServerResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetUserSessionServerResponse.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetUserSessionServerResponse.is_online)
    pub is_online: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGetUserSessionServerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServerResponse {
    fn default() -> &'a CMsgGCToGCGetUserSessionServerResponse {
        <CMsgGCToGCGetUserSessionServerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServerResponse {
    pub fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 server_steam_id = 1;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool is_online = 2;

    pub fn is_online(&self) -> bool {
        self.is_online.unwrap_or(false)
    }

    pub fn clear_is_online(&mut self) {
        self.is_online = ::std::option::Option::None;
    }

    pub fn has_is_online(&self) -> bool {
        self.is_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_online(&mut self, v: bool) {
        self.is_online = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_steam_id",
            |m: &CMsgGCToGCGetUserSessionServerResponse| { &m.server_steam_id },
            |m: &mut CMsgGCToGCGetUserSessionServerResponse| { &mut m.server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_online",
            |m: &CMsgGCToGCGetUserSessionServerResponse| { &m.is_online },
            |m: &mut CMsgGCToGCGetUserSessionServerResponse| { &mut m.is_online },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserSessionServerResponse>(
            "CMsgGCToGCGetUserSessionServerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServerResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.is_online = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.is_online {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.is_online {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        CMsgGCToGCGetUserSessionServerResponse::new()
    }

    fn clear(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
        self.is_online = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServerResponse {
        static instance: CMsgGCToGCGetUserSessionServerResponse = CMsgGCToGCGetUserSessionServerResponse {
            server_steam_id: ::std::option::Option::None,
            is_online: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserSessionServerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserSessionServerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserSessionServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGetUserServerMembers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserServerMembers {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetUserServerMembers.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetUserServerMembers.max_spectators)
    pub max_spectators: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGetUserServerMembers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembers {
    fn default() -> &'a CMsgGCToGCGetUserServerMembers {
        <CMsgGCToGCGetUserServerMembers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembers {
    pub fn new() -> CMsgGCToGCGetUserServerMembers {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spectators = 2;

    pub fn max_spectators(&self) -> u32 {
        self.max_spectators.unwrap_or(0)
    }

    pub fn clear_max_spectators(&mut self) {
        self.max_spectators = ::std::option::Option::None;
    }

    pub fn has_max_spectators(&self) -> bool {
        self.max_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spectators(&mut self, v: u32) {
        self.max_spectators = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCGetUserServerMembers| { &m.account_id },
            |m: &mut CMsgGCToGCGetUserServerMembers| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_spectators",
            |m: &CMsgGCToGCGetUserServerMembers| { &m.max_spectators },
            |m: &mut CMsgGCToGCGetUserServerMembers| { &mut m.max_spectators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserServerMembers>(
            "CMsgGCToGCGetUserServerMembers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembers {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_spectators {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_spectators {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembers {
        CMsgGCToGCGetUserServerMembers::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.max_spectators = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembers {
        static instance: CMsgGCToGCGetUserServerMembers = CMsgGCToGCGetUserServerMembers {
            account_id: ::std::option::Option::None,
            max_spectators: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserServerMembers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserServerMembers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserServerMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGetUserServerMembersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserServerMembersResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetUserServerMembersResponse.member_account_id)
    pub member_account_id: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGetUserServerMembersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembersResponse {
    fn default() -> &'a CMsgGCToGCGetUserServerMembersResponse {
        <CMsgGCToGCGetUserServerMembersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembersResponse {
    pub fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "member_account_id",
            |m: &CMsgGCToGCGetUserServerMembersResponse| { &m.member_account_id },
            |m: &mut CMsgGCToGCGetUserServerMembersResponse| { &mut m.member_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserServerMembersResponse>(
            "CMsgGCToGCGetUserServerMembersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembersResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.member_account_id)?;
                },
                8 => {
                    self.member_account_id.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.member_account_id {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.member_account_id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        CMsgGCToGCGetUserServerMembersResponse::new()
    }

    fn clear(&mut self) {
        self.member_account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembersResponse {
        static instance: CMsgGCToGCGetUserServerMembersResponse = CMsgGCToGCGetUserServerMembersResponse {
            member_account_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserServerMembersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserServerMembersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserServerMembersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLookupMultipleAccountNames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLookupMultipleAccountNames {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLookupMultipleAccountNames.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLookupMultipleAccountNames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNames {
    fn default() -> &'a CMsgLookupMultipleAccountNames {
        <CMsgLookupMultipleAccountNames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNames {
    pub fn new() -> CMsgLookupMultipleAccountNames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accountids",
            |m: &CMsgLookupMultipleAccountNames| { &m.accountids },
            |m: &mut CMsgLookupMultipleAccountNames| { &mut m.accountids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLookupMultipleAccountNames>(
            "CMsgLookupMultipleAccountNames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNames {
    const NAME: &'static str = "CMsgLookupMultipleAccountNames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                8 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accountids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accountids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNames {
        CMsgLookupMultipleAccountNames::new()
    }

    fn clear(&mut self) {
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNames {
        static instance: CMsgLookupMultipleAccountNames = CMsgLookupMultipleAccountNames {
            accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLookupMultipleAccountNames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLookupMultipleAccountNames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLookupMultipleAccountNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLookupMultipleAccountNamesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLookupMultipleAccountNamesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLookupMultipleAccountNamesResponse.accounts)
    pub accounts: ::std::vec::Vec<cmsg_lookup_multiple_account_names_response::Account>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLookupMultipleAccountNamesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNamesResponse {
    fn default() -> &'a CMsgLookupMultipleAccountNamesResponse {
        <CMsgLookupMultipleAccountNamesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNamesResponse {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts",
            |m: &CMsgLookupMultipleAccountNamesResponse| { &m.accounts },
            |m: &mut CMsgLookupMultipleAccountNamesResponse| { &mut m.accounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLookupMultipleAccountNamesResponse>(
            "CMsgLookupMultipleAccountNamesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNamesResponse {
    const NAME: &'static str = "CMsgLookupMultipleAccountNamesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accounts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNamesResponse {
        CMsgLookupMultipleAccountNamesResponse::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse {
        static instance: CMsgLookupMultipleAccountNamesResponse = CMsgLookupMultipleAccountNamesResponse {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLookupMultipleAccountNamesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLookupMultipleAccountNamesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLookupMultipleAccountNamesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNamesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgLookupMultipleAccountNamesResponse`
pub mod cmsg_lookup_multiple_account_names_response {
    // @@protoc_insertion_point(message:dota.CMsgLookupMultipleAccountNamesResponse.Account)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Account {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLookupMultipleAccountNamesResponse.Account.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLookupMultipleAccountNamesResponse.Account.persona)
        pub persona: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLookupMultipleAccountNamesResponse.Account.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Account {
        fn default() -> &'a Account {
            <Account as ::protobuf::Message>::default_instance()
        }
    }

    impl Account {
        pub fn new() -> Account {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional string persona = 2;

        pub fn persona(&self) -> &str {
            match self.persona.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona(&mut self) {
            self.persona = ::std::option::Option::None;
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: ::std::string::String) {
            self.persona = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut ::std::string::String {
            if self.persona.is_none() {
                self.persona = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona(&mut self) -> ::std::string::String {
            self.persona.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Account| { &m.accountid },
                |m: &mut Account| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona",
                |m: &Account| { &m.persona },
                |m: &mut Account| { &mut m.persona },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Account>(
                "CMsgLookupMultipleAccountNamesResponse.Account",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Account {
        const NAME: &'static str = "Account";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.persona = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.persona.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Account {
            Account::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.persona = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Account {
            static instance: Account = Account {
                accountid: ::std::option::Option::None,
                persona: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Account {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLookupMultipleAccountNamesResponse.Account").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Account {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Account {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgRequestCrateItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateItems.crate_item_def)
    pub crate_item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRequestCrateItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateItems {
    fn default() -> &'a CMsgRequestCrateItems {
        <CMsgRequestCrateItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateItems {
    pub fn new() -> CMsgRequestCrateItems {
        ::std::default::Default::default()
    }

    // optional uint32 crate_item_def = 1;

    pub fn crate_item_def(&self) -> u32 {
        self.crate_item_def.unwrap_or(0)
    }

    pub fn clear_crate_item_def(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
    }

    pub fn has_crate_item_def(&self) -> bool {
        self.crate_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_def(&mut self, v: u32) {
        self.crate_item_def = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crate_item_def",
            |m: &CMsgRequestCrateItems| { &m.crate_item_def },
            |m: &mut CMsgRequestCrateItems| { &mut m.crate_item_def },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestCrateItems>(
            "CMsgRequestCrateItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestCrateItems {
    const NAME: &'static str = "CMsgRequestCrateItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_def {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.crate_item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateItems {
        CMsgRequestCrateItems::new()
    }

    fn clear(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateItems {
        static instance: CMsgRequestCrateItems = CMsgRequestCrateItems {
            crate_item_def: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestCrateItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestCrateItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestCrateItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestCrateItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgRequestCrateItemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateItemsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateItemsResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateItemsResponse.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateItemsResponse.peek_item_defs)
    pub peek_item_defs: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRequestCrateItemsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateItemsResponse {
    fn default() -> &'a CMsgRequestCrateItemsResponse {
        <CMsgRequestCrateItemsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateItemsResponse {
    pub fn new() -> CMsgRequestCrateItemsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgRequestCrateItemsResponse| { &m.response },
            |m: &mut CMsgRequestCrateItemsResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_defs",
            |m: &CMsgRequestCrateItemsResponse| { &m.item_defs },
            |m: &mut CMsgRequestCrateItemsResponse| { &mut m.item_defs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "peek_item_defs",
            |m: &CMsgRequestCrateItemsResponse| { &m.peek_item_defs },
            |m: &mut CMsgRequestCrateItemsResponse| { &mut m.peek_item_defs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestCrateItemsResponse>(
            "CMsgRequestCrateItemsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestCrateItemsResponse {
    const NAME: &'static str = "CMsgRequestCrateItemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                16 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.peek_item_defs)?;
                },
                24 => {
                    self.peek_item_defs.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_defs {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.peek_item_defs {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_defs {
            os.write_uint32(2, *v)?;
        };
        for v in &self.peek_item_defs {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateItemsResponse {
        CMsgRequestCrateItemsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_defs.clear();
        self.peek_item_defs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateItemsResponse {
        static instance: CMsgRequestCrateItemsResponse = CMsgRequestCrateItemsResponse {
            response: ::std::option::Option::None,
            item_defs: ::std::vec::Vec::new(),
            peek_item_defs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestCrateItemsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestCrateItemsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestCrateItemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestCrateItemsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRequestCrateItemsResponse`
pub mod cmsg_request_crate_items_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgRequestCrateItemsResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:dota.CMsgRequestCrateItemsResponse.EResult.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgRequestCrateItemsResponse.EResult.k_Failed)
        k_Failed = 1,
    }

    impl ::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_Succeeded),
                1 => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResult::k_Succeeded),
                "k_Failed" => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_Succeeded,
            EResult::k_Failed,
        ];
    }

    impl ::protobuf::EnumFull for EResult {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgRequestCrateItemsResponse.EResult").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_Succeeded
        }
    }

    impl EResult {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResult>("CMsgRequestCrateItemsResponse.EResult")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgRequestCrateEscalationLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateEscalationLevel {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateEscalationLevel.crate_item_def)
    pub crate_item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRequestCrateEscalationLevel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateEscalationLevel {
    fn default() -> &'a CMsgRequestCrateEscalationLevel {
        <CMsgRequestCrateEscalationLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateEscalationLevel {
    pub fn new() -> CMsgRequestCrateEscalationLevel {
        ::std::default::Default::default()
    }

    // optional uint32 crate_item_def = 1;

    pub fn crate_item_def(&self) -> u32 {
        self.crate_item_def.unwrap_or(0)
    }

    pub fn clear_crate_item_def(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
    }

    pub fn has_crate_item_def(&self) -> bool {
        self.crate_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_def(&mut self, v: u32) {
        self.crate_item_def = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crate_item_def",
            |m: &CMsgRequestCrateEscalationLevel| { &m.crate_item_def },
            |m: &mut CMsgRequestCrateEscalationLevel| { &mut m.crate_item_def },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestCrateEscalationLevel>(
            "CMsgRequestCrateEscalationLevel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestCrateEscalationLevel {
    const NAME: &'static str = "CMsgRequestCrateEscalationLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_def {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.crate_item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateEscalationLevel {
        CMsgRequestCrateEscalationLevel::new()
    }

    fn clear(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateEscalationLevel {
        static instance: CMsgRequestCrateEscalationLevel = CMsgRequestCrateEscalationLevel {
            crate_item_def: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestCrateEscalationLevel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestCrateEscalationLevel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestCrateEscalationLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestCrateEscalationLevel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgRequestCrateEscalationLevelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateEscalationLevelResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateEscalationLevelResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateEscalationLevelResponse.escalation_level0)
    pub escalation_level0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateEscalationLevelResponse.escalation_level1)
    pub escalation_level1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateEscalationLevelResponse.escalation_level2)
    pub escalation_level2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRequestCrateEscalationLevelResponse.escalation_level3)
    pub escalation_level3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRequestCrateEscalationLevelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateEscalationLevelResponse {
    fn default() -> &'a CMsgRequestCrateEscalationLevelResponse {
        <CMsgRequestCrateEscalationLevelResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateEscalationLevelResponse {
    pub fn new() -> CMsgRequestCrateEscalationLevelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level0 = 2;

    pub fn escalation_level0(&self) -> u32 {
        self.escalation_level0.unwrap_or(0)
    }

    pub fn clear_escalation_level0(&mut self) {
        self.escalation_level0 = ::std::option::Option::None;
    }

    pub fn has_escalation_level0(&self) -> bool {
        self.escalation_level0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level0(&mut self, v: u32) {
        self.escalation_level0 = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level1 = 3;

    pub fn escalation_level1(&self) -> u32 {
        self.escalation_level1.unwrap_or(0)
    }

    pub fn clear_escalation_level1(&mut self) {
        self.escalation_level1 = ::std::option::Option::None;
    }

    pub fn has_escalation_level1(&self) -> bool {
        self.escalation_level1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level1(&mut self, v: u32) {
        self.escalation_level1 = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level2 = 4;

    pub fn escalation_level2(&self) -> u32 {
        self.escalation_level2.unwrap_or(0)
    }

    pub fn clear_escalation_level2(&mut self) {
        self.escalation_level2 = ::std::option::Option::None;
    }

    pub fn has_escalation_level2(&self) -> bool {
        self.escalation_level2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level2(&mut self, v: u32) {
        self.escalation_level2 = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level3 = 5;

    pub fn escalation_level3(&self) -> u32 {
        self.escalation_level3.unwrap_or(0)
    }

    pub fn clear_escalation_level3(&mut self) {
        self.escalation_level3 = ::std::option::Option::None;
    }

    pub fn has_escalation_level3(&self) -> bool {
        self.escalation_level3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level3(&mut self, v: u32) {
        self.escalation_level3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgRequestCrateEscalationLevelResponse| { &m.response },
            |m: &mut CMsgRequestCrateEscalationLevelResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "escalation_level0",
            |m: &CMsgRequestCrateEscalationLevelResponse| { &m.escalation_level0 },
            |m: &mut CMsgRequestCrateEscalationLevelResponse| { &mut m.escalation_level0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "escalation_level1",
            |m: &CMsgRequestCrateEscalationLevelResponse| { &m.escalation_level1 },
            |m: &mut CMsgRequestCrateEscalationLevelResponse| { &mut m.escalation_level1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "escalation_level2",
            |m: &CMsgRequestCrateEscalationLevelResponse| { &m.escalation_level2 },
            |m: &mut CMsgRequestCrateEscalationLevelResponse| { &mut m.escalation_level2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "escalation_level3",
            |m: &CMsgRequestCrateEscalationLevelResponse| { &m.escalation_level3 },
            |m: &mut CMsgRequestCrateEscalationLevelResponse| { &mut m.escalation_level3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestCrateEscalationLevelResponse>(
            "CMsgRequestCrateEscalationLevelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestCrateEscalationLevelResponse {
    const NAME: &'static str = "CMsgRequestCrateEscalationLevelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.escalation_level0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.escalation_level1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.escalation_level2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.escalation_level3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.escalation_level0 {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.escalation_level1 {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.escalation_level2 {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.escalation_level3 {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.escalation_level0 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.escalation_level1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.escalation_level2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.escalation_level3 {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateEscalationLevelResponse {
        CMsgRequestCrateEscalationLevelResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.escalation_level0 = ::std::option::Option::None;
        self.escalation_level1 = ::std::option::Option::None;
        self.escalation_level2 = ::std::option::Option::None;
        self.escalation_level3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateEscalationLevelResponse {
        static instance: CMsgRequestCrateEscalationLevelResponse = CMsgRequestCrateEscalationLevelResponse {
            response: ::std::option::Option::None,
            escalation_level0: ::std::option::Option::None,
            escalation_level1: ::std::option::Option::None,
            escalation_level2: ::std::option::Option::None,
            escalation_level3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestCrateEscalationLevelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestCrateEscalationLevelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestCrateEscalationLevelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestCrateEscalationLevelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRequestCrateEscalationLevelResponse`
pub mod cmsg_request_crate_escalation_level_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgRequestCrateEscalationLevelResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:dota.CMsgRequestCrateEscalationLevelResponse.EResult.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgRequestCrateEscalationLevelResponse.EResult.k_Failed)
        k_Failed = 1,
    }

    impl ::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_Succeeded),
                1 => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResult::k_Succeeded),
                "k_Failed" => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_Succeeded,
            EResult::k_Failed,
        ];
    }

    impl ::protobuf::EnumFull for EResult {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgRequestCrateEscalationLevelResponse.EResult").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_Succeeded
        }
    }

    impl EResult {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResult>("CMsgRequestCrateEscalationLevelResponse.EResult")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCCanUseDropRateBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCCanUseDropRateBonus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCCanUseDropRateBonus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCCanUseDropRateBonus.drop_rate_bonus)
    pub drop_rate_bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCCanUseDropRateBonus.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCCanUseDropRateBonus.exclusive_item_def)
    pub exclusive_item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCCanUseDropRateBonus.allow_equal_rate)
    pub allow_equal_rate: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCCanUseDropRateBonus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCCanUseDropRateBonus {
    fn default() -> &'a CMsgGCToGCCanUseDropRateBonus {
        <CMsgGCToGCCanUseDropRateBonus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCCanUseDropRateBonus {
    pub fn new() -> CMsgGCToGCCanUseDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional float drop_rate_bonus = 2;

    pub fn drop_rate_bonus(&self) -> f32 {
        self.drop_rate_bonus.unwrap_or(0.)
    }

    pub fn clear_drop_rate_bonus(&mut self) {
        self.drop_rate_bonus = ::std::option::Option::None;
    }

    pub fn has_drop_rate_bonus(&self) -> bool {
        self.drop_rate_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_rate_bonus(&mut self, v: f32) {
        self.drop_rate_bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 3;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    // optional uint32 exclusive_item_def = 4;

    pub fn exclusive_item_def(&self) -> u32 {
        self.exclusive_item_def.unwrap_or(0)
    }

    pub fn clear_exclusive_item_def(&mut self) {
        self.exclusive_item_def = ::std::option::Option::None;
    }

    pub fn has_exclusive_item_def(&self) -> bool {
        self.exclusive_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusive_item_def(&mut self, v: u32) {
        self.exclusive_item_def = ::std::option::Option::Some(v);
    }

    // optional bool allow_equal_rate = 5;

    pub fn allow_equal_rate(&self) -> bool {
        self.allow_equal_rate.unwrap_or(false)
    }

    pub fn clear_allow_equal_rate(&mut self) {
        self.allow_equal_rate = ::std::option::Option::None;
    }

    pub fn has_allow_equal_rate(&self) -> bool {
        self.allow_equal_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_equal_rate(&mut self, v: bool) {
        self.allow_equal_rate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCCanUseDropRateBonus| { &m.account_id },
            |m: &mut CMsgGCToGCCanUseDropRateBonus| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "drop_rate_bonus",
            |m: &CMsgGCToGCCanUseDropRateBonus| { &m.drop_rate_bonus },
            |m: &mut CMsgGCToGCCanUseDropRateBonus| { &mut m.drop_rate_bonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "booster_type",
            |m: &CMsgGCToGCCanUseDropRateBonus| { &m.booster_type },
            |m: &mut CMsgGCToGCCanUseDropRateBonus| { &mut m.booster_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclusive_item_def",
            |m: &CMsgGCToGCCanUseDropRateBonus| { &m.exclusive_item_def },
            |m: &mut CMsgGCToGCCanUseDropRateBonus| { &mut m.exclusive_item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_equal_rate",
            |m: &CMsgGCToGCCanUseDropRateBonus| { &m.allow_equal_rate },
            |m: &mut CMsgGCToGCCanUseDropRateBonus| { &mut m.allow_equal_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCCanUseDropRateBonus>(
            "CMsgGCToGCCanUseDropRateBonus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCCanUseDropRateBonus {
    const NAME: &'static str = "CMsgGCToGCCanUseDropRateBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.drop_rate_bonus = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.exclusive_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.allow_equal_rate = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.drop_rate_bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.booster_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.exclusive_item_def {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.allow_equal_rate {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.drop_rate_bonus {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.exclusive_item_def {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.allow_equal_rate {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCCanUseDropRateBonus {
        CMsgGCToGCCanUseDropRateBonus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.drop_rate_bonus = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.exclusive_item_def = ::std::option::Option::None;
        self.allow_equal_rate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCCanUseDropRateBonus {
        static instance: CMsgGCToGCCanUseDropRateBonus = CMsgGCToGCCanUseDropRateBonus {
            account_id: ::std::option::Option::None,
            drop_rate_bonus: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            exclusive_item_def: ::std::option::Option::None,
            allow_equal_rate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCCanUseDropRateBonus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCCanUseDropRateBonus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCCanUseDropRateBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCCanUseDropRateBonus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSQLAddDropRateBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSQLAddDropRateBonus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSQLAddDropRateBonus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLAddDropRateBonus.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSQLAddDropRateBonus.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLAddDropRateBonus.drop_rate_bonus)
    pub drop_rate_bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLAddDropRateBonus.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLAddDropRateBonus.seconds_duration)
    pub seconds_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLAddDropRateBonus.end_time_stamp)
    pub end_time_stamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSQLAddDropRateBonus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSQLAddDropRateBonus {
    fn default() -> &'a CMsgSQLAddDropRateBonus {
        <CMsgSQLAddDropRateBonus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSQLAddDropRateBonus {
    pub fn new() -> CMsgSQLAddDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 3;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional float drop_rate_bonus = 4;

    pub fn drop_rate_bonus(&self) -> f32 {
        self.drop_rate_bonus.unwrap_or(0.)
    }

    pub fn clear_drop_rate_bonus(&mut self) {
        self.drop_rate_bonus = ::std::option::Option::None;
    }

    pub fn has_drop_rate_bonus(&self) -> bool {
        self.drop_rate_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_rate_bonus(&mut self, v: f32) {
        self.drop_rate_bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 5;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_duration = 6;

    pub fn seconds_duration(&self) -> u32 {
        self.seconds_duration.unwrap_or(0)
    }

    pub fn clear_seconds_duration(&mut self) {
        self.seconds_duration = ::std::option::Option::None;
    }

    pub fn has_seconds_duration(&self) -> bool {
        self.seconds_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_duration(&mut self, v: u32) {
        self.seconds_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time_stamp = 7;

    pub fn end_time_stamp(&self) -> u32 {
        self.end_time_stamp.unwrap_or(0)
    }

    pub fn clear_end_time_stamp(&mut self) {
        self.end_time_stamp = ::std::option::Option::None;
    }

    pub fn has_end_time_stamp(&self) -> bool {
        self.end_time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time_stamp(&mut self, v: u32) {
        self.end_time_stamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgSQLAddDropRateBonus| { &m.account_id },
            |m: &mut CMsgSQLAddDropRateBonus| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgSQLAddDropRateBonus| { &m.item_id },
            |m: &mut CMsgSQLAddDropRateBonus| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CMsgSQLAddDropRateBonus| { &m.item_def },
            |m: &mut CMsgSQLAddDropRateBonus| { &mut m.item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "drop_rate_bonus",
            |m: &CMsgSQLAddDropRateBonus| { &m.drop_rate_bonus },
            |m: &mut CMsgSQLAddDropRateBonus| { &mut m.drop_rate_bonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "booster_type",
            |m: &CMsgSQLAddDropRateBonus| { &m.booster_type },
            |m: &mut CMsgSQLAddDropRateBonus| { &mut m.booster_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_duration",
            |m: &CMsgSQLAddDropRateBonus| { &m.seconds_duration },
            |m: &mut CMsgSQLAddDropRateBonus| { &mut m.seconds_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_time_stamp",
            |m: &CMsgSQLAddDropRateBonus| { &m.end_time_stamp },
            |m: &mut CMsgSQLAddDropRateBonus| { &mut m.end_time_stamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSQLAddDropRateBonus>(
            "CMsgSQLAddDropRateBonus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSQLAddDropRateBonus {
    const NAME: &'static str = "CMsgSQLAddDropRateBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.drop_rate_bonus = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seconds_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.end_time_stamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.drop_rate_bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.booster_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seconds_duration {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.end_time_stamp {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.drop_rate_bonus {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seconds_duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.end_time_stamp {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSQLAddDropRateBonus {
        CMsgSQLAddDropRateBonus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.drop_rate_bonus = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.seconds_duration = ::std::option::Option::None;
        self.end_time_stamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSQLAddDropRateBonus {
        static instance: CMsgSQLAddDropRateBonus = CMsgSQLAddDropRateBonus {
            account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            drop_rate_bonus: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            seconds_duration: ::std::option::Option::None,
            end_time_stamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSQLAddDropRateBonus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSQLAddDropRateBonus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSQLAddDropRateBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSQLAddDropRateBonus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSQLUpgradeBattleBooster)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSQLUpgradeBattleBooster {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSQLUpgradeBattleBooster.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLUpgradeBattleBooster.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLUpgradeBattleBooster.bonus_to_add)
    pub bonus_to_add: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLUpgradeBattleBooster.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSQLUpgradeBattleBooster.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSQLUpgradeBattleBooster {
    fn default() -> &'a CMsgSQLUpgradeBattleBooster {
        <CMsgSQLUpgradeBattleBooster as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSQLUpgradeBattleBooster {
    pub fn new() -> CMsgSQLUpgradeBattleBooster {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 2;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional float bonus_to_add = 3;

    pub fn bonus_to_add(&self) -> f32 {
        self.bonus_to_add.unwrap_or(0.)
    }

    pub fn clear_bonus_to_add(&mut self) {
        self.bonus_to_add = ::std::option::Option::None;
    }

    pub fn has_bonus_to_add(&self) -> bool {
        self.bonus_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_to_add(&mut self, v: f32) {
        self.bonus_to_add = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 4;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgSQLUpgradeBattleBooster| { &m.account_id },
            |m: &mut CMsgSQLUpgradeBattleBooster| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CMsgSQLUpgradeBattleBooster| { &m.item_def },
            |m: &mut CMsgSQLUpgradeBattleBooster| { &mut m.item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_to_add",
            |m: &CMsgSQLUpgradeBattleBooster| { &m.bonus_to_add },
            |m: &mut CMsgSQLUpgradeBattleBooster| { &mut m.bonus_to_add },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "booster_type",
            |m: &CMsgSQLUpgradeBattleBooster| { &m.booster_type },
            |m: &mut CMsgSQLUpgradeBattleBooster| { &mut m.booster_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSQLUpgradeBattleBooster>(
            "CMsgSQLUpgradeBattleBooster",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSQLUpgradeBattleBooster {
    const NAME: &'static str = "CMsgSQLUpgradeBattleBooster";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.bonus_to_add = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bonus_to_add {
            my_size += 1 + 4;
        }
        if let Some(v) = self.booster_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_to_add {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSQLUpgradeBattleBooster {
        CMsgSQLUpgradeBattleBooster::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.bonus_to_add = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSQLUpgradeBattleBooster {
        static instance: CMsgSQLUpgradeBattleBooster = CMsgSQLUpgradeBattleBooster {
            account_id: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            bonus_to_add: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSQLUpgradeBattleBooster {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSQLUpgradeBattleBooster").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSQLUpgradeBattleBooster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSQLUpgradeBattleBooster {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCRefreshSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCRefreshSOCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCRefreshSOCache.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCRefreshSOCache.reload)
    pub reload: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCRefreshSOCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCRefreshSOCache {
    fn default() -> &'a CMsgGCToGCRefreshSOCache {
        <CMsgGCToGCRefreshSOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCRefreshSOCache {
    pub fn new() -> CMsgGCToGCRefreshSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool reload = 2;

    pub fn reload(&self) -> bool {
        self.reload.unwrap_or(false)
    }

    pub fn clear_reload(&mut self) {
        self.reload = ::std::option::Option::None;
    }

    pub fn has_reload(&self) -> bool {
        self.reload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reload(&mut self, v: bool) {
        self.reload = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCRefreshSOCache| { &m.account_id },
            |m: &mut CMsgGCToGCRefreshSOCache| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reload",
            |m: &CMsgGCToGCRefreshSOCache| { &m.reload },
            |m: &mut CMsgGCToGCRefreshSOCache| { &mut m.reload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCRefreshSOCache>(
            "CMsgGCToGCRefreshSOCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCRefreshSOCache {
    const NAME: &'static str = "CMsgGCToGCRefreshSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reload = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reload {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reload {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCRefreshSOCache {
        CMsgGCToGCRefreshSOCache::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCRefreshSOCache {
        static instance: CMsgGCToGCRefreshSOCache = CMsgGCToGCRefreshSOCache {
            account_id: ::std::option::Option::None,
            reload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCRefreshSOCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCRefreshSOCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCRefreshSOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCRefreshSOCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCAddSubscriptionTime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCAddSubscriptionTime {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCAddSubscriptionTime.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCAddSubscriptionTime.matching_subscription_def_indexes)
    pub matching_subscription_def_indexes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCAddSubscriptionTime.additional_seconds)
    pub additional_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCAddSubscriptionTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCAddSubscriptionTime {
    fn default() -> &'a CMsgGCToGCAddSubscriptionTime {
        <CMsgGCToGCAddSubscriptionTime as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCAddSubscriptionTime {
    pub fn new() -> CMsgGCToGCAddSubscriptionTime {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 additional_seconds = 3;

    pub fn additional_seconds(&self) -> u32 {
        self.additional_seconds.unwrap_or(0)
    }

    pub fn clear_additional_seconds(&mut self) {
        self.additional_seconds = ::std::option::Option::None;
    }

    pub fn has_additional_seconds(&self) -> bool {
        self.additional_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_seconds(&mut self, v: u32) {
        self.additional_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCAddSubscriptionTime| { &m.account_id },
            |m: &mut CMsgGCToGCAddSubscriptionTime| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matching_subscription_def_indexes",
            |m: &CMsgGCToGCAddSubscriptionTime| { &m.matching_subscription_def_indexes },
            |m: &mut CMsgGCToGCAddSubscriptionTime| { &mut m.matching_subscription_def_indexes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_seconds",
            |m: &CMsgGCToGCAddSubscriptionTime| { &m.additional_seconds },
            |m: &mut CMsgGCToGCAddSubscriptionTime| { &mut m.additional_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCAddSubscriptionTime>(
            "CMsgGCToGCAddSubscriptionTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCAddSubscriptionTime {
    const NAME: &'static str = "CMsgGCToGCAddSubscriptionTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.matching_subscription_def_indexes)?;
                },
                16 => {
                    self.matching_subscription_def_indexes.push(is.read_uint32()?);
                },
                24 => {
                    self.additional_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.matching_subscription_def_indexes {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.additional_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.matching_subscription_def_indexes {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.additional_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCAddSubscriptionTime {
        CMsgGCToGCAddSubscriptionTime::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.matching_subscription_def_indexes.clear();
        self.additional_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCAddSubscriptionTime {
        static instance: CMsgGCToGCAddSubscriptionTime = CMsgGCToGCAddSubscriptionTime {
            account_id: ::std::option::Option::None,
            matching_subscription_def_indexes: ::std::vec::Vec::new(),
            additional_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCAddSubscriptionTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCAddSubscriptionTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCAddSubscriptionTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCAddSubscriptionTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGrantAccountRolledItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGrantAccountRolledItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.items)
    pub items: ::std::vec::Vec<cmsg_gcto_gcgrant_account_rolled_items::Item>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.audit_action)
    pub audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.audit_data)
    pub audit_data: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGrantAccountRolledItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGrantAccountRolledItems {
    fn default() -> &'a CMsgGCToGCGrantAccountRolledItems {
        <CMsgGCToGCGrantAccountRolledItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGrantAccountRolledItems {
    pub fn new() -> CMsgGCToGCGrantAccountRolledItems {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 audit_action = 3;

    pub fn audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    // optional uint64 audit_data = 4;

    pub fn audit_data(&self) -> u64 {
        self.audit_data.unwrap_or(0)
    }

    pub fn clear_audit_data(&mut self) {
        self.audit_data = ::std::option::Option::None;
    }

    pub fn has_audit_data(&self) -> bool {
        self.audit_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_data(&mut self, v: u64) {
        self.audit_data = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCGrantAccountRolledItems| { &m.account_id },
            |m: &mut CMsgGCToGCGrantAccountRolledItems| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgGCToGCGrantAccountRolledItems| { &m.items },
            |m: &mut CMsgGCToGCGrantAccountRolledItems| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audit_action",
            |m: &CMsgGCToGCGrantAccountRolledItems| { &m.audit_action },
            |m: &mut CMsgGCToGCGrantAccountRolledItems| { &mut m.audit_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audit_data",
            |m: &CMsgGCToGCGrantAccountRolledItems| { &m.audit_data },
            |m: &mut CMsgGCToGCGrantAccountRolledItems| { &mut m.audit_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGrantAccountRolledItems>(
            "CMsgGCToGCGrantAccountRolledItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantAccountRolledItems {
    const NAME: &'static str = "CMsgGCToGCGrantAccountRolledItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                24 => {
                    self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.audit_action {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.audit_data {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.audit_action {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.audit_data {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGrantAccountRolledItems {
        CMsgGCToGCGrantAccountRolledItems::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.items.clear();
        self.audit_action = ::std::option::Option::None;
        self.audit_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGrantAccountRolledItems {
        static instance: CMsgGCToGCGrantAccountRolledItems = CMsgGCToGCGrantAccountRolledItems {
            account_id: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            audit_action: ::std::option::Option::None,
            audit_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGrantAccountRolledItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGrantAccountRolledItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGrantAccountRolledItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantAccountRolledItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToGCGrantAccountRolledItems`
pub mod cmsg_gcto_gcgrant_account_rolled_items {
    // @@protoc_insertion_point(message:dota.CMsgGCToGCGrantAccountRolledItems.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.loot_lists)
        pub loot_lists: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.ignore_limit)
        pub ignore_limit: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.origin)
        pub origin: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.dynamic_attributes)
        pub dynamic_attributes: ::std::vec::Vec<item::DynamicAttribute>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.additional_audit_entries)
        pub additional_audit_entries: ::std::vec::Vec<item::AdditionalAuditEntry>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.inventory_token)
        pub inventory_token: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGrantAccountRolledItems.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional bool ignore_limit = 3;

        pub fn ignore_limit(&self) -> bool {
            self.ignore_limit.unwrap_or(false)
        }

        pub fn clear_ignore_limit(&mut self) {
            self.ignore_limit = ::std::option::Option::None;
        }

        pub fn has_ignore_limit(&self) -> bool {
            self.ignore_limit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ignore_limit(&mut self, v: bool) {
            self.ignore_limit = ::std::option::Option::Some(v);
        }

        // optional uint32 origin = 4;

        pub fn origin(&self) -> u32 {
            self.origin.unwrap_or(0)
        }

        pub fn clear_origin(&mut self) {
            self.origin = ::std::option::Option::None;
        }

        pub fn has_origin(&self) -> bool {
            self.origin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin(&mut self, v: u32) {
            self.origin = ::std::option::Option::Some(v);
        }

        // optional uint32 inventory_token = 7;

        pub fn inventory_token(&self) -> u32 {
            self.inventory_token.unwrap_or(0)
        }

        pub fn clear_inventory_token(&mut self) {
            self.inventory_token = ::std::option::Option::None;
        }

        pub fn has_inventory_token(&self) -> bool {
            self.inventory_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inventory_token(&mut self, v: u32) {
            self.inventory_token = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_def",
                |m: &Item| { &m.item_def },
                |m: &mut Item| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "loot_lists",
                |m: &Item| { &m.loot_lists },
                |m: &mut Item| { &mut m.loot_lists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ignore_limit",
                |m: &Item| { &m.ignore_limit },
                |m: &mut Item| { &mut m.ignore_limit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin",
                |m: &Item| { &m.origin },
                |m: &mut Item| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dynamic_attributes",
                |m: &Item| { &m.dynamic_attributes },
                |m: &mut Item| { &mut m.dynamic_attributes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "additional_audit_entries",
                |m: &Item| { &m.additional_audit_entries },
                |m: &mut Item| { &mut m.additional_audit_entries },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "inventory_token",
                |m: &Item| { &m.inventory_token },
                |m: &mut Item| { &mut m.inventory_token },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                "CMsgGCToGCGrantAccountRolledItems.Item",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.loot_lists.push(is.read_string()?);
                    },
                    24 => {
                        self.ignore_limit = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.origin = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.dynamic_attributes.push(is.read_message()?);
                    },
                    50 => {
                        self.additional_audit_entries.push(is.read_message()?);
                    },
                    56 => {
                        self.inventory_token = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.loot_lists {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            if let Some(v) = self.ignore_limit {
                my_size += 1 + 1;
            }
            if let Some(v) = self.origin {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.dynamic_attributes {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.additional_audit_entries {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.inventory_token {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            for v in &self.loot_lists {
                os.write_string(2, &v)?;
            };
            if let Some(v) = self.ignore_limit {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.origin {
                os.write_uint32(4, v)?;
            }
            for v in &self.dynamic_attributes {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            for v in &self.additional_audit_entries {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.inventory_token {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.loot_lists.clear();
            self.ignore_limit = ::std::option::Option::None;
            self.origin = ::std::option::Option::None;
            self.dynamic_attributes.clear();
            self.additional_audit_entries.clear();
            self.inventory_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_def: ::std::option::Option::None,
                loot_lists: ::std::vec::Vec::new(),
                ignore_limit: ::std::option::Option::None,
                origin: ::std::option::Option::None,
                dynamic_attributes: ::std::vec::Vec::new(),
                additional_audit_entries: ::std::vec::Vec::new(),
                inventory_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Item {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToGCGrantAccountRolledItems.Item").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Item {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Item`
    pub mod item {
        // @@protoc_insertion_point(message:dota.CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DynamicAttribute {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.name)
            pub name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.value_uint32)
            pub value_uint32: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.value_float)
            pub value_float: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.value_string)
            pub value_string: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DynamicAttribute {
            fn default() -> &'a DynamicAttribute {
                <DynamicAttribute as ::protobuf::Message>::default_instance()
            }
        }

        impl DynamicAttribute {
            pub fn new() -> DynamicAttribute {
                ::std::default::Default::default()
            }

            // optional string name = 1;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 value_uint32 = 2;

            pub fn value_uint32(&self) -> u32 {
                self.value_uint32.unwrap_or(0)
            }

            pub fn clear_value_uint32(&mut self) {
                self.value_uint32 = ::std::option::Option::None;
            }

            pub fn has_value_uint32(&self) -> bool {
                self.value_uint32.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_uint32(&mut self, v: u32) {
                self.value_uint32 = ::std::option::Option::Some(v);
            }

            // optional float value_float = 3;

            pub fn value_float(&self) -> f32 {
                self.value_float.unwrap_or(0.)
            }

            pub fn clear_value_float(&mut self) {
                self.value_float = ::std::option::Option::None;
            }

            pub fn has_value_float(&self) -> bool {
                self.value_float.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_float(&mut self, v: f32) {
                self.value_float = ::std::option::Option::Some(v);
            }

            // optional string value_string = 4;

            pub fn value_string(&self) -> &str {
                match self.value_string.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_value_string(&mut self) {
                self.value_string = ::std::option::Option::None;
            }

            pub fn has_value_string(&self) -> bool {
                self.value_string.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_string(&mut self, v: ::std::string::String) {
                self.value_string = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_value_string(&mut self) -> &mut ::std::string::String {
                if self.value_string.is_none() {
                    self.value_string = ::std::option::Option::Some(::std::string::String::new());
                }
                self.value_string.as_mut().unwrap()
            }

            // Take field
            pub fn take_value_string(&mut self) -> ::std::string::String {
                self.value_string.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name",
                    |m: &DynamicAttribute| { &m.name },
                    |m: &mut DynamicAttribute| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value_uint32",
                    |m: &DynamicAttribute| { &m.value_uint32 },
                    |m: &mut DynamicAttribute| { &mut m.value_uint32 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value_float",
                    |m: &DynamicAttribute| { &m.value_float },
                    |m: &mut DynamicAttribute| { &mut m.value_float },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value_string",
                    |m: &DynamicAttribute| { &m.value_string },
                    |m: &mut DynamicAttribute| { &mut m.value_string },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DynamicAttribute>(
                    "CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DynamicAttribute {
            const NAME: &'static str = "DynamicAttribute";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.value_uint32 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        29 => {
                            self.value_float = ::std::option::Option::Some(is.read_float()?);
                        },
                        34 => {
                            self.value_string = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.value_uint32 {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.value_float {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.value_string.as_ref() {
                    my_size += ::protobuf::rt::string_size(4, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.value_uint32 {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.value_float {
                    os.write_float(3, v)?;
                }
                if let Some(v) = self.value_string.as_ref() {
                    os.write_string(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DynamicAttribute {
                DynamicAttribute::new()
            }

            fn clear(&mut self) {
                self.name = ::std::option::Option::None;
                self.value_uint32 = ::std::option::Option::None;
                self.value_float = ::std::option::Option::None;
                self.value_string = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DynamicAttribute {
                static instance: DynamicAttribute = DynamicAttribute {
                    name: ::std::option::Option::None,
                    value_uint32: ::std::option::Option::None,
                    value_float: ::std::option::Option::None,
                    value_string: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DynamicAttribute {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DynamicAttribute {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DynamicAttribute {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AdditionalAuditEntry {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.owner_account_id)
            pub owner_account_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.audit_action)
            pub audit_action: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.audit_data)
            pub audit_data: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AdditionalAuditEntry {
            fn default() -> &'a AdditionalAuditEntry {
                <AdditionalAuditEntry as ::protobuf::Message>::default_instance()
            }
        }

        impl AdditionalAuditEntry {
            pub fn new() -> AdditionalAuditEntry {
                ::std::default::Default::default()
            }

            // optional uint32 owner_account_id = 1;

            pub fn owner_account_id(&self) -> u32 {
                self.owner_account_id.unwrap_or(0)
            }

            pub fn clear_owner_account_id(&mut self) {
                self.owner_account_id = ::std::option::Option::None;
            }

            pub fn has_owner_account_id(&self) -> bool {
                self.owner_account_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_owner_account_id(&mut self, v: u32) {
                self.owner_account_id = ::std::option::Option::Some(v);
            }

            // optional uint32 audit_action = 2;

            pub fn audit_action(&self) -> u32 {
                self.audit_action.unwrap_or(0)
            }

            pub fn clear_audit_action(&mut self) {
                self.audit_action = ::std::option::Option::None;
            }

            pub fn has_audit_action(&self) -> bool {
                self.audit_action.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit_action(&mut self, v: u32) {
                self.audit_action = ::std::option::Option::Some(v);
            }

            // optional uint64 audit_data = 3;

            pub fn audit_data(&self) -> u64 {
                self.audit_data.unwrap_or(0)
            }

            pub fn clear_audit_data(&mut self) {
                self.audit_data = ::std::option::Option::None;
            }

            pub fn has_audit_data(&self) -> bool {
                self.audit_data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit_data(&mut self, v: u64) {
                self.audit_data = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "owner_account_id",
                    |m: &AdditionalAuditEntry| { &m.owner_account_id },
                    |m: &mut AdditionalAuditEntry| { &mut m.owner_account_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "audit_action",
                    |m: &AdditionalAuditEntry| { &m.audit_action },
                    |m: &mut AdditionalAuditEntry| { &mut m.audit_action },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "audit_data",
                    |m: &AdditionalAuditEntry| { &m.audit_data },
                    |m: &mut AdditionalAuditEntry| { &mut m.audit_data },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalAuditEntry>(
                    "CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AdditionalAuditEntry {
            const NAME: &'static str = "AdditionalAuditEntry";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.owner_account_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.audit_action {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.audit_data {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.owner_account_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.audit_action {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.audit_data {
                    os.write_uint64(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AdditionalAuditEntry {
                AdditionalAuditEntry::new()
            }

            fn clear(&mut self) {
                self.owner_account_id = ::std::option::Option::None;
                self.audit_action = ::std::option::Option::None;
                self.audit_data = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AdditionalAuditEntry {
                static instance: AdditionalAuditEntry = AdditionalAuditEntry {
                    owner_account_id: ::std::option::Option::None,
                    audit_action: ::std::option::Option::None,
                    audit_data: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AdditionalAuditEntry {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AdditionalAuditEntry {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AdditionalAuditEntry {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCBetaDeleteItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBetaDeleteItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBetaDeleteItems.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBetaDeleteItems.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBetaDeleteItems.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCBetaDeleteItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBetaDeleteItems {
    fn default() -> &'a CMsgGCToGCBetaDeleteItems {
        <CMsgGCToGCBetaDeleteItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBetaDeleteItems {
    pub fn new() -> CMsgGCToGCBetaDeleteItems {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCBetaDeleteItems| { &m.account_id },
            |m: &mut CMsgGCToGCBetaDeleteItems| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgGCToGCBetaDeleteItems| { &m.item_ids },
            |m: &mut CMsgGCToGCBetaDeleteItems| { &mut m.item_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_defs",
            |m: &CMsgGCToGCBetaDeleteItems| { &m.item_defs },
            |m: &mut CMsgGCToGCBetaDeleteItems| { &mut m.item_defs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCBetaDeleteItems>(
            "CMsgGCToGCBetaDeleteItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCBetaDeleteItems {
    const NAME: &'static str = "CMsgGCToGCBetaDeleteItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                24 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        for value in &self.item_defs {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        for v in &self.item_defs {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBetaDeleteItems {
        CMsgGCToGCBetaDeleteItems::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_ids.clear();
        self.item_defs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBetaDeleteItems {
        static instance: CMsgGCToGCBetaDeleteItems = CMsgGCToGCBetaDeleteItems {
            account_id: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            item_defs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCBetaDeleteItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCBetaDeleteItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCBetaDeleteItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBetaDeleteItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGrantSelfMadeItemToAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGrantSelfMadeItemToAccount {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantSelfMadeItemToAccount.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGrantSelfMadeItemToAccount.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGrantSelfMadeItemToAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGrantSelfMadeItemToAccount {
    fn default() -> &'a CMsgGCToGCGrantSelfMadeItemToAccount {
        <CMsgGCToGCGrantSelfMadeItemToAccount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGrantSelfMadeItemToAccount {
    pub fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCToGCGrantSelfMadeItemToAccount| { &m.item_def_index },
            |m: &mut CMsgGCToGCGrantSelfMadeItemToAccount| { &mut m.item_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCToGCGrantSelfMadeItemToAccount| { &m.accountid },
            |m: &mut CMsgGCToGCGrantSelfMadeItemToAccount| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGrantSelfMadeItemToAccount>(
            "CMsgGCToGCGrantSelfMadeItemToAccount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantSelfMadeItemToAccount {
    const NAME: &'static str = "CMsgGCToGCGrantSelfMadeItemToAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        CMsgGCToGCGrantSelfMadeItemToAccount::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGrantSelfMadeItemToAccount {
        static instance: CMsgGCToGCGrantSelfMadeItemToAccount = CMsgGCToGCGrantSelfMadeItemToAccount {
            item_def_index: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGrantSelfMadeItemToAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantSelfMadeItemToAccount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgUseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUseItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgUseItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgUseItem.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgUseItem.gift__potential_targets)
    pub gift__potential_targets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgUseItem.duel__class_lock)
    pub duel__class_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgUseItem.initiator_steam_id)
    pub initiator_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgUseItem.itempack__ack_immediately)
    pub itempack__ack_immediately: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgUseItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUseItem {
    fn default() -> &'a CMsgUseItem {
        <CMsgUseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 2;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel__class_lock = 4;

    pub fn duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }

    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    // optional uint64 initiator_steam_id = 5;

    pub fn initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool itempack__ack_immediately = 6;

    pub fn itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.unwrap_or(false)
    }

    pub fn clear_itempack__ack_immediately(&mut self) {
        self.itempack__ack_immediately = ::std::option::Option::None;
    }

    pub fn has_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itempack__ack_immediately(&mut self, v: bool) {
        self.itempack__ack_immediately = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgUseItem| { &m.item_id },
            |m: &mut CMsgUseItem| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgUseItem| { &m.target_steam_id },
            |m: &mut CMsgUseItem| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gift__potential_targets",
            |m: &CMsgUseItem| { &m.gift__potential_targets },
            |m: &mut CMsgUseItem| { &mut m.gift__potential_targets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duel__class_lock",
            |m: &CMsgUseItem| { &m.duel__class_lock },
            |m: &mut CMsgUseItem| { &mut m.duel__class_lock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator_steam_id",
            |m: &CMsgUseItem| { &m.initiator_steam_id },
            |m: &mut CMsgUseItem| { &mut m.initiator_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itempack__ack_immediately",
            |m: &CMsgUseItem| { &m.itempack__ack_immediately },
            |m: &mut CMsgUseItem| { &mut m.itempack__ack_immediately },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUseItem>(
            "CMsgUseItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUseItem {
    const NAME: &'static str = "CMsgUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.gift__potential_targets)?;
                },
                24 => {
                    self.gift__potential_targets.push(is.read_uint32()?);
                },
                32 => {
                    self.duel__class_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.initiator_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.itempack__ack_immediately = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        for value in &self.gift__potential_targets {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.itempack__ack_immediately {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.itempack__ack_immediately {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.gift__potential_targets.clear();
        self.duel__class_lock = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.itempack__ack_immediately = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUseItem {
        static instance: CMsgUseItem = CMsgUseItem {
            item_id: ::std::option::Option::None,
            target_steam_id: ::std::option::Option::None,
            gift__potential_targets: ::std::vec::Vec::new(),
            duel__class_lock: ::std::option::Option::None,
            initiator_steam_id: ::std::option::Option::None,
            itempack__ack_immediately: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUseItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUseItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerUseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerUseItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerUseItem.initiator_account_id)
    pub initiator_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerUseItem.use_item_msg)
    pub use_item_msg: ::protobuf::MessageField<CMsgUseItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerUseItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerUseItem {
    fn default() -> &'a CMsgServerUseItem {
        <CMsgServerUseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerUseItem {
    pub fn new() -> CMsgServerUseItem {
        ::std::default::Default::default()
    }

    // optional uint32 initiator_account_id = 1;

    pub fn initiator_account_id(&self) -> u32 {
        self.initiator_account_id.unwrap_or(0)
    }

    pub fn clear_initiator_account_id(&mut self) {
        self.initiator_account_id = ::std::option::Option::None;
    }

    pub fn has_initiator_account_id(&self) -> bool {
        self.initiator_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_account_id(&mut self, v: u32) {
        self.initiator_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator_account_id",
            |m: &CMsgServerUseItem| { &m.initiator_account_id },
            |m: &mut CMsgServerUseItem| { &mut m.initiator_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgUseItem>(
            "use_item_msg",
            |m: &CMsgServerUseItem| { &m.use_item_msg },
            |m: &mut CMsgServerUseItem| { &mut m.use_item_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerUseItem>(
            "CMsgServerUseItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerUseItem {
    const NAME: &'static str = "CMsgServerUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.initiator_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.use_item_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.use_item_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.initiator_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.use_item_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerUseItem {
        CMsgServerUseItem::new()
    }

    fn clear(&mut self) {
        self.initiator_account_id = ::std::option::Option::None;
        self.use_item_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerUseItem {
        static instance: CMsgServerUseItem = CMsgServerUseItem {
            initiator_account_id: ::std::option::Option::None,
            use_item_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerUseItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerUseItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerUseItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgUseMultipleItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUseMultipleItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgUseMultipleItems.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgUseMultipleItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUseMultipleItems {
    fn default() -> &'a CMsgUseMultipleItems {
        <CMsgUseMultipleItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUseMultipleItems {
    pub fn new() -> CMsgUseMultipleItems {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgUseMultipleItems| { &m.item_ids },
            |m: &mut CMsgUseMultipleItems| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUseMultipleItems>(
            "CMsgUseMultipleItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUseMultipleItems {
    const NAME: &'static str = "CMsgUseMultipleItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUseMultipleItems {
        CMsgUseMultipleItems::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUseMultipleItems {
        static instance: CMsgUseMultipleItems = CMsgUseMultipleItems {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUseMultipleItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUseMultipleItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUseMultipleItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseMultipleItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CGCStoreRechargeRedirect_LineItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCStoreRechargeRedirect_LineItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCStoreRechargeRedirect_LineItem.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCStoreRechargeRedirect_LineItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCStoreRechargeRedirect_LineItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCStoreRechargeRedirect_LineItem {
    fn default() -> &'a CGCStoreRechargeRedirect_LineItem {
        <CGCStoreRechargeRedirect_LineItem as ::protobuf::Message>::default_instance()
    }
}

impl CGCStoreRechargeRedirect_LineItem {
    pub fn new() -> CGCStoreRechargeRedirect_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CGCStoreRechargeRedirect_LineItem| { &m.item_def_id },
            |m: &mut CGCStoreRechargeRedirect_LineItem| { &mut m.item_def_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CGCStoreRechargeRedirect_LineItem| { &m.quantity },
            |m: &mut CGCStoreRechargeRedirect_LineItem| { &mut m.quantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCStoreRechargeRedirect_LineItem>(
            "CGCStoreRechargeRedirect_LineItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCStoreRechargeRedirect_LineItem {
    const NAME: &'static str = "CGCStoreRechargeRedirect_LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCStoreRechargeRedirect_LineItem {
        CGCStoreRechargeRedirect_LineItem::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCStoreRechargeRedirect_LineItem {
        static instance: CGCStoreRechargeRedirect_LineItem = CGCStoreRechargeRedirect_LineItem {
            item_def_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCStoreRechargeRedirect_LineItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCStoreRechargeRedirect_LineItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCStoreRechargeRedirect_LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCStoreRechargeRedirect_LineItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCEconSQLWorkItemEmbeddedRollbackData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCEconSQLWorkItemEmbeddedRollbackData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCEconSQLWorkItemEmbeddedRollbackData.deleted_item_id)
    pub deleted_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCEconSQLWorkItemEmbeddedRollbackData.old_audit_action)
    pub old_audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCEconSQLWorkItemEmbeddedRollbackData.new_audit_action)
    pub new_audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCEconSQLWorkItemEmbeddedRollbackData.expected_audit_action)
    pub expected_audit_action: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCEconSQLWorkItemEmbeddedRollbackData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn default() -> &'a CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        <CMsgGCEconSQLWorkItemEmbeddedRollbackData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    pub fn new() -> CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 deleted_item_id = 2;

    pub fn deleted_item_id(&self) -> u64 {
        self.deleted_item_id.unwrap_or(0)
    }

    pub fn clear_deleted_item_id(&mut self) {
        self.deleted_item_id = ::std::option::Option::None;
    }

    pub fn has_deleted_item_id(&self) -> bool {
        self.deleted_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted_item_id(&mut self, v: u64) {
        self.deleted_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 old_audit_action = 3;

    pub fn old_audit_action(&self) -> u32 {
        self.old_audit_action.unwrap_or(0)
    }

    pub fn clear_old_audit_action(&mut self) {
        self.old_audit_action = ::std::option::Option::None;
    }

    pub fn has_old_audit_action(&self) -> bool {
        self.old_audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_audit_action(&mut self, v: u32) {
        self.old_audit_action = ::std::option::Option::Some(v);
    }

    // optional uint32 new_audit_action = 4;

    pub fn new_audit_action(&self) -> u32 {
        self.new_audit_action.unwrap_or(0)
    }

    pub fn clear_new_audit_action(&mut self) {
        self.new_audit_action = ::std::option::Option::None;
    }

    pub fn has_new_audit_action(&self) -> bool {
        self.new_audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_audit_action(&mut self, v: u32) {
        self.new_audit_action = ::std::option::Option::Some(v);
    }

    // optional uint32 expected_audit_action = 5;

    pub fn expected_audit_action(&self) -> u32 {
        self.expected_audit_action.unwrap_or(0)
    }

    pub fn clear_expected_audit_action(&mut self) {
        self.expected_audit_action = ::std::option::Option::None;
    }

    pub fn has_expected_audit_action(&self) -> bool {
        self.expected_audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_audit_action(&mut self, v: u32) {
        self.expected_audit_action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &m.account_id },
            |m: &mut CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted_item_id",
            |m: &CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &m.deleted_item_id },
            |m: &mut CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &mut m.deleted_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "old_audit_action",
            |m: &CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &m.old_audit_action },
            |m: &mut CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &mut m.old_audit_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_audit_action",
            |m: &CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &m.new_audit_action },
            |m: &mut CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &mut m.new_audit_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expected_audit_action",
            |m: &CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &m.expected_audit_action },
            |m: &mut CMsgGCEconSQLWorkItemEmbeddedRollbackData| { &mut m.expected_audit_action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCEconSQLWorkItemEmbeddedRollbackData>(
            "CMsgGCEconSQLWorkItemEmbeddedRollbackData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    const NAME: &'static str = "CMsgGCEconSQLWorkItemEmbeddedRollbackData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deleted_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.old_audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.new_audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.expected_audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deleted_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.old_audit_action {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.new_audit_action {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.expected_audit_action {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deleted_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.old_audit_action {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.new_audit_action {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.expected_audit_action {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        CMsgGCEconSQLWorkItemEmbeddedRollbackData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.deleted_item_id = ::std::option::Option::None;
        self.old_audit_action = ::std::option::Option::None;
        self.new_audit_action = ::std::option::Option::None;
        self.expected_audit_action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        static instance: CMsgGCEconSQLWorkItemEmbeddedRollbackData = CMsgGCEconSQLWorkItemEmbeddedRollbackData {
            account_id: ::std::option::Option::None,
            deleted_item_id: ::std::option::Option::None,
            old_audit_action: ::std::option::Option::None,
            new_audit_action: ::std::option::Option::None,
            expected_audit_action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCEconSQLWorkItemEmbeddedRollbackData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCraftStatue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftStatue {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCraftStatue.heroid)
    pub heroid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCraftStatue.sequencename)
    pub sequencename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgCraftStatue.cycle)
    pub cycle: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgCraftStatue.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgCraftStatue.pedestal_itemdef)
    pub pedestal_itemdef: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCraftStatue.toolid)
    pub toolid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCraftStatue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftStatue {
    fn default() -> &'a CMsgCraftStatue {
        <CMsgCraftStatue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftStatue {
    pub fn new() -> CMsgCraftStatue {
        ::std::default::Default::default()
    }

    // optional uint32 heroid = 1;

    pub fn heroid(&self) -> u32 {
        self.heroid.unwrap_or(0)
    }

    pub fn clear_heroid(&mut self) {
        self.heroid = ::std::option::Option::None;
    }

    pub fn has_heroid(&self) -> bool {
        self.heroid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heroid(&mut self, v: u32) {
        self.heroid = ::std::option::Option::Some(v);
    }

    // optional string sequencename = 2;

    pub fn sequencename(&self) -> &str {
        match self.sequencename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sequencename(&mut self) {
        self.sequencename = ::std::option::Option::None;
    }

    pub fn has_sequencename(&self) -> bool {
        self.sequencename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequencename(&mut self, v: ::std::string::String) {
        self.sequencename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequencename(&mut self) -> &mut ::std::string::String {
        if self.sequencename.is_none() {
            self.sequencename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sequencename.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequencename(&mut self) -> ::std::string::String {
        self.sequencename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float cycle = 3;

    pub fn cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 pedestal_itemdef = 5;

    pub fn pedestal_itemdef(&self) -> u32 {
        self.pedestal_itemdef.unwrap_or(0)
    }

    pub fn clear_pedestal_itemdef(&mut self) {
        self.pedestal_itemdef = ::std::option::Option::None;
    }

    pub fn has_pedestal_itemdef(&self) -> bool {
        self.pedestal_itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pedestal_itemdef(&mut self, v: u32) {
        self.pedestal_itemdef = ::std::option::Option::Some(v);
    }

    // optional uint64 toolid = 6;

    pub fn toolid(&self) -> u64 {
        self.toolid.unwrap_or(0)
    }

    pub fn clear_toolid(&mut self) {
        self.toolid = ::std::option::Option::None;
    }

    pub fn has_toolid(&self) -> bool {
        self.toolid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toolid(&mut self, v: u64) {
        self.toolid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "heroid",
            |m: &CMsgCraftStatue| { &m.heroid },
            |m: &mut CMsgCraftStatue| { &mut m.heroid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequencename",
            |m: &CMsgCraftStatue| { &m.sequencename },
            |m: &mut CMsgCraftStatue| { &mut m.sequencename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cycle",
            |m: &CMsgCraftStatue| { &m.cycle },
            |m: &mut CMsgCraftStatue| { &mut m.cycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgCraftStatue| { &m.description },
            |m: &mut CMsgCraftStatue| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pedestal_itemdef",
            |m: &CMsgCraftStatue| { &m.pedestal_itemdef },
            |m: &mut CMsgCraftStatue| { &mut m.pedestal_itemdef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toolid",
            |m: &CMsgCraftStatue| { &m.toolid },
            |m: &mut CMsgCraftStatue| { &mut m.toolid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCraftStatue>(
            "CMsgCraftStatue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCraftStatue {
    const NAME: &'static str = "CMsgCraftStatue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.heroid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.sequencename = ::std::option::Option::Some(is.read_string()?);
                },
                29 => {
                    self.cycle = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.pedestal_itemdef = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.toolid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.heroid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sequencename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 1 + 4;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.pedestal_itemdef {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.toolid {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.heroid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sequencename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.pedestal_itemdef {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.toolid {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftStatue {
        CMsgCraftStatue::new()
    }

    fn clear(&mut self) {
        self.heroid = ::std::option::Option::None;
        self.sequencename = ::std::option::Option::None;
        self.cycle = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.pedestal_itemdef = ::std::option::Option::None;
        self.toolid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftStatue {
        static instance: CMsgCraftStatue = CMsgCraftStatue {
            heroid: ::std::option::Option::None,
            sequencename: ::std::option::Option::None,
            cycle: ::std::option::Option::None,
            description: ::std::option::Option::None,
            pedestal_itemdef: ::std::option::Option::None,
            toolid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCraftStatue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCraftStatue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCraftStatue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftStatue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgRedeemCode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRedeemCode {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRedeemCode.code)
    pub code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRedeemCode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRedeemCode {
    fn default() -> &'a CMsgRedeemCode {
        <CMsgRedeemCode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRedeemCode {
    pub fn new() -> CMsgRedeemCode {
        ::std::default::Default::default()
    }

    // optional string code = 1;

    pub fn code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &CMsgRedeemCode| { &m.code },
            |m: &mut CMsgRedeemCode| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRedeemCode>(
            "CMsgRedeemCode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRedeemCode {
    const NAME: &'static str = "CMsgRedeemCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRedeemCode {
        CMsgRedeemCode::new()
    }

    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRedeemCode {
        static instance: CMsgRedeemCode = CMsgRedeemCode {
            code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRedeemCode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRedeemCode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRedeemCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRedeemCode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgRedeemCodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRedeemCodeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRedeemCodeResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRedeemCodeResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRedeemCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRedeemCodeResponse {
    fn default() -> &'a CMsgRedeemCodeResponse {
        <CMsgRedeemCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRedeemCodeResponse {
    pub fn new() -> CMsgRedeemCodeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgRedeemCodeResponse| { &m.response },
            |m: &mut CMsgRedeemCodeResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgRedeemCodeResponse| { &m.item_id },
            |m: &mut CMsgRedeemCodeResponse| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRedeemCodeResponse>(
            "CMsgRedeemCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRedeemCodeResponse {
    const NAME: &'static str = "CMsgRedeemCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRedeemCodeResponse {
        CMsgRedeemCodeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRedeemCodeResponse {
        static instance: CMsgRedeemCodeResponse = CMsgRedeemCodeResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRedeemCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRedeemCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRedeemCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRedeemCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRedeemCodeResponse`
pub mod cmsg_redeem_code_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgRedeemCodeResponse.EResultCode)
    pub enum EResultCode {
        // @@protoc_insertion_point(enum_value:dota.CMsgRedeemCodeResponse.EResultCode.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgRedeemCodeResponse.EResultCode.k_Failed_CodeNotFound)
        k_Failed_CodeNotFound = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgRedeemCodeResponse.EResultCode.k_Failed_CodeAlreadyUsed)
        k_Failed_CodeAlreadyUsed = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgRedeemCodeResponse.EResultCode.k_Failed_OtherError)
        k_Failed_OtherError = 3,
    }

    impl ::protobuf::Enum for EResultCode {
        const NAME: &'static str = "EResultCode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResultCode> {
            match value {
                0 => ::std::option::Option::Some(EResultCode::k_Succeeded),
                1 => ::std::option::Option::Some(EResultCode::k_Failed_CodeNotFound),
                2 => ::std::option::Option::Some(EResultCode::k_Failed_CodeAlreadyUsed),
                3 => ::std::option::Option::Some(EResultCode::k_Failed_OtherError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResultCode> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResultCode::k_Succeeded),
                "k_Failed_CodeNotFound" => ::std::option::Option::Some(EResultCode::k_Failed_CodeNotFound),
                "k_Failed_CodeAlreadyUsed" => ::std::option::Option::Some(EResultCode::k_Failed_CodeAlreadyUsed),
                "k_Failed_OtherError" => ::std::option::Option::Some(EResultCode::k_Failed_OtherError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResultCode] = &[
            EResultCode::k_Succeeded,
            EResultCode::k_Failed_CodeNotFound,
            EResultCode::k_Failed_CodeAlreadyUsed,
            EResultCode::k_Failed_OtherError,
        ];
    }

    impl ::protobuf::EnumFull for EResultCode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgRedeemCodeResponse.EResultCode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResultCode {
        fn default() -> Self {
            EResultCode::k_Succeeded
        }
    }

    impl EResultCode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResultCode>("CMsgRedeemCodeResponse.EResultCode")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgDevNewItemRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevNewItemRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDevNewItemRequest.item_def_name)
    pub item_def_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDevNewItemRequest.loot_list_name)
    pub loot_list_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDevNewItemRequest.attr_def_name)
    pub attr_def_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDevNewItemRequest.attr_value)
    pub attr_value: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDevNewItemRequest.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDevNewItemRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequest {
    fn default() -> &'a CMsgDevNewItemRequest {
        <CMsgDevNewItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    // optional string item_def_name = 3;

    pub fn item_def_name(&self) -> &str {
        match self.item_def_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_def_name(&mut self) {
        self.item_def_name = ::std::option::Option::None;
    }

    pub fn has_item_def_name(&self) -> bool {
        self.item_def_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_name(&mut self, v: ::std::string::String) {
        self.item_def_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_def_name(&mut self) -> &mut ::std::string::String {
        if self.item_def_name.is_none() {
            self.item_def_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_def_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_def_name(&mut self) -> ::std::string::String {
        self.item_def_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string loot_list_name = 4;

    pub fn loot_list_name(&self) -> &str {
        match self.loot_list_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loot_list_name(&mut self) {
        self.loot_list_name = ::std::option::Option::None;
    }

    pub fn has_loot_list_name(&self) -> bool {
        self.loot_list_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list_name(&mut self, v: ::std::string::String) {
        self.loot_list_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list_name(&mut self) -> &mut ::std::string::String {
        if self.loot_list_name.is_none() {
            self.loot_list_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loot_list_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list_name(&mut self) -> ::std::string::String {
        self.loot_list_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 item_quality = 7;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_name",
            |m: &CMsgDevNewItemRequest| { &m.item_def_name },
            |m: &mut CMsgDevNewItemRequest| { &mut m.item_def_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loot_list_name",
            |m: &CMsgDevNewItemRequest| { &m.loot_list_name },
            |m: &mut CMsgDevNewItemRequest| { &mut m.loot_list_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attr_def_name",
            |m: &CMsgDevNewItemRequest| { &m.attr_def_name },
            |m: &mut CMsgDevNewItemRequest| { &mut m.attr_def_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attr_value",
            |m: &CMsgDevNewItemRequest| { &m.attr_value },
            |m: &mut CMsgDevNewItemRequest| { &mut m.attr_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CMsgDevNewItemRequest| { &m.item_quality },
            |m: &mut CMsgDevNewItemRequest| { &mut m.item_quality },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDevNewItemRequest>(
            "CMsgDevNewItemRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequest {
    const NAME: &'static str = "CMsgDevNewItemRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.item_def_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.loot_list_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.attr_def_name.push(is.read_string()?);
                },
                50 => {
                    self.attr_value.push(is.read_string()?);
                },
                56 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.attr_def_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.attr_value {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.attr_def_name {
            os.write_string(5, &v)?;
        };
        for v in &self.attr_value {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.item_quality {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn clear(&mut self) {
        self.item_def_name = ::std::option::Option::None;
        self.loot_list_name = ::std::option::Option::None;
        self.attr_def_name.clear();
        self.attr_value.clear();
        self.item_quality = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevNewItemRequest {
        static instance: CMsgDevNewItemRequest = CMsgDevNewItemRequest {
            item_def_name: ::std::option::Option::None,
            loot_list_name: ::std::option::Option::None,
            attr_def_name: ::std::vec::Vec::new(),
            attr_value: ::std::vec::Vec::new(),
            item_quality: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDevNewItemRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDevNewItemRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDevNewItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDevNewItemRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevNewItemRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDevNewItemRequestResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDevNewItemRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequestResponse {
    fn default() -> &'a CMsgDevNewItemRequestResponse {
        <CMsgDevNewItemRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequestResponse {
    pub fn new() -> CMsgDevNewItemRequestResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgDevNewItemRequestResponse| { &m.success },
            |m: &mut CMsgDevNewItemRequestResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDevNewItemRequestResponse>(
            "CMsgDevNewItemRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequestResponse {
    const NAME: &'static str = "CMsgDevNewItemRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevNewItemRequestResponse {
        CMsgDevNewItemRequestResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevNewItemRequestResponse {
        static instance: CMsgDevNewItemRequestResponse = CMsgDevNewItemRequestResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDevNewItemRequestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDevNewItemRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDevNewItemRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDevUnlockAllItemStyles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevUnlockAllItemStyles {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDevUnlockAllItemStyles.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDevUnlockAllItemStyles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevUnlockAllItemStyles {
    fn default() -> &'a CMsgDevUnlockAllItemStyles {
        <CMsgDevUnlockAllItemStyles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevUnlockAllItemStyles {
    pub fn new() -> CMsgDevUnlockAllItemStyles {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgDevUnlockAllItemStyles| { &m.item_id },
            |m: &mut CMsgDevUnlockAllItemStyles| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDevUnlockAllItemStyles>(
            "CMsgDevUnlockAllItemStyles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDevUnlockAllItemStyles {
    const NAME: &'static str = "CMsgDevUnlockAllItemStyles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevUnlockAllItemStyles {
        CMsgDevUnlockAllItemStyles::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevUnlockAllItemStyles {
        static instance: CMsgDevUnlockAllItemStyles = CMsgDevUnlockAllItemStyles {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDevUnlockAllItemStyles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDevUnlockAllItemStyles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDevUnlockAllItemStyles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevUnlockAllItemStyles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDevUnlockAllItemStylesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevUnlockAllItemStylesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDevUnlockAllItemStylesResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDevUnlockAllItemStylesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevUnlockAllItemStylesResponse {
    fn default() -> &'a CMsgDevUnlockAllItemStylesResponse {
        <CMsgDevUnlockAllItemStylesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevUnlockAllItemStylesResponse {
    pub fn new() -> CMsgDevUnlockAllItemStylesResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgDevUnlockAllItemStylesResponse| { &m.success },
            |m: &mut CMsgDevUnlockAllItemStylesResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDevUnlockAllItemStylesResponse>(
            "CMsgDevUnlockAllItemStylesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDevUnlockAllItemStylesResponse {
    const NAME: &'static str = "CMsgDevUnlockAllItemStylesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevUnlockAllItemStylesResponse {
        CMsgDevUnlockAllItemStylesResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevUnlockAllItemStylesResponse {
        static instance: CMsgDevUnlockAllItemStylesResponse = CMsgDevUnlockAllItemStylesResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDevUnlockAllItemStylesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDevUnlockAllItemStylesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDevUnlockAllItemStylesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevUnlockAllItemStylesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCGetAccountSubscriptionItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetAccountSubscriptionItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCGetAccountSubscriptionItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCGetAccountSubscriptionItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetAccountSubscriptionItem {
    fn default() -> &'a CMsgGCGetAccountSubscriptionItem {
        <CMsgGCGetAccountSubscriptionItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetAccountSubscriptionItem {
    pub fn new() -> CMsgGCGetAccountSubscriptionItem {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCGetAccountSubscriptionItem| { &m.account_id },
            |m: &mut CMsgGCGetAccountSubscriptionItem| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCGetAccountSubscriptionItem>(
            "CMsgGCGetAccountSubscriptionItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCGetAccountSubscriptionItem {
    const NAME: &'static str = "CMsgGCGetAccountSubscriptionItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetAccountSubscriptionItem {
        CMsgGCGetAccountSubscriptionItem::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetAccountSubscriptionItem {
        static instance: CMsgGCGetAccountSubscriptionItem = CMsgGCGetAccountSubscriptionItem {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCGetAccountSubscriptionItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCGetAccountSubscriptionItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCGetAccountSubscriptionItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetAccountSubscriptionItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCGetAccountSubscriptionItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetAccountSubscriptionItemResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCGetAccountSubscriptionItemResponse.def_index)
    pub def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCGetAccountSubscriptionItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetAccountSubscriptionItemResponse {
    fn default() -> &'a CMsgGCGetAccountSubscriptionItemResponse {
        <CMsgGCGetAccountSubscriptionItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetAccountSubscriptionItemResponse {
    pub fn new() -> CMsgGCGetAccountSubscriptionItemResponse {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CMsgGCGetAccountSubscriptionItemResponse| { &m.def_index },
            |m: &mut CMsgGCGetAccountSubscriptionItemResponse| { &mut m.def_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCGetAccountSubscriptionItemResponse>(
            "CMsgGCGetAccountSubscriptionItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCGetAccountSubscriptionItemResponse {
    const NAME: &'static str = "CMsgGCGetAccountSubscriptionItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetAccountSubscriptionItemResponse {
        CMsgGCGetAccountSubscriptionItemResponse::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetAccountSubscriptionItemResponse {
        static instance: CMsgGCGetAccountSubscriptionItemResponse = CMsgGCGetAccountSubscriptionItemResponse {
            def_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCGetAccountSubscriptionItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCGetAccountSubscriptionItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCGetAccountSubscriptionItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetAccountSubscriptionItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCAddGiftItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCAddGiftItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCAddGiftItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCAddGiftItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCAddGiftItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCAddGiftItem {
    fn default() -> &'a CMsgGCAddGiftItem {
        <CMsgGCAddGiftItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCAddGiftItem {
    pub fn new() -> CMsgGCAddGiftItem {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCAddGiftItem| { &m.account_id },
            |m: &mut CMsgGCAddGiftItem| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgGCAddGiftItem| { &m.item_id },
            |m: &mut CMsgGCAddGiftItem| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCAddGiftItem>(
            "CMsgGCAddGiftItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCAddGiftItem {
    const NAME: &'static str = "CMsgGCAddGiftItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCAddGiftItem {
        CMsgGCAddGiftItem::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCAddGiftItem {
        static instance: CMsgGCAddGiftItem = CMsgGCAddGiftItem {
            account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCAddGiftItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCAddGiftItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCAddGiftItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCAddGiftItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCWrapAndDeliverGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCWrapAndDeliverGift {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGift.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGift.give_to_account_id)
    pub give_to_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGift.gift_message)
    pub gift_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCWrapAndDeliverGift.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCWrapAndDeliverGift {
    fn default() -> &'a CMsgClientToGCWrapAndDeliverGift {
        <CMsgClientToGCWrapAndDeliverGift as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCWrapAndDeliverGift {
    pub fn new() -> CMsgClientToGCWrapAndDeliverGift {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 give_to_account_id = 2;

    pub fn give_to_account_id(&self) -> u32 {
        self.give_to_account_id.unwrap_or(0)
    }

    pub fn clear_give_to_account_id(&mut self) {
        self.give_to_account_id = ::std::option::Option::None;
    }

    pub fn has_give_to_account_id(&self) -> bool {
        self.give_to_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_give_to_account_id(&mut self, v: u32) {
        self.give_to_account_id = ::std::option::Option::Some(v);
    }

    // optional string gift_message = 3;

    pub fn gift_message(&self) -> &str {
        match self.gift_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gift_message(&mut self) {
        self.gift_message = ::std::option::Option::None;
    }

    pub fn has_gift_message(&self) -> bool {
        self.gift_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gift_message(&mut self, v: ::std::string::String) {
        self.gift_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gift_message(&mut self) -> &mut ::std::string::String {
        if self.gift_message.is_none() {
            self.gift_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gift_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_gift_message(&mut self) -> ::std::string::String {
        self.gift_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCWrapAndDeliverGift| { &m.item_id },
            |m: &mut CMsgClientToGCWrapAndDeliverGift| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "give_to_account_id",
            |m: &CMsgClientToGCWrapAndDeliverGift| { &m.give_to_account_id },
            |m: &mut CMsgClientToGCWrapAndDeliverGift| { &mut m.give_to_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gift_message",
            |m: &CMsgClientToGCWrapAndDeliverGift| { &m.gift_message },
            |m: &mut CMsgClientToGCWrapAndDeliverGift| { &mut m.gift_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCWrapAndDeliverGift>(
            "CMsgClientToGCWrapAndDeliverGift",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCWrapAndDeliverGift {
    const NAME: &'static str = "CMsgClientToGCWrapAndDeliverGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.give_to_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.gift_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.give_to_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gift_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.give_to_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gift_message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCWrapAndDeliverGift {
        CMsgClientToGCWrapAndDeliverGift::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.give_to_account_id = ::std::option::Option::None;
        self.gift_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCWrapAndDeliverGift {
        static instance: CMsgClientToGCWrapAndDeliverGift = CMsgClientToGCWrapAndDeliverGift {
            item_id: ::std::option::Option::None,
            give_to_account_id: ::std::option::Option::None,
            gift_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCWrapAndDeliverGift {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCWrapAndDeliverGift").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCWrapAndDeliverGift {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCWrapAndDeliverGift {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCWrapAndDeliverGiftResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCWrapAndDeliverGiftResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<super::econ_shared_enums::EGCMsgResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.gifting_charge_uses)
    pub gifting_charge_uses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.gifting_charge_max)
    pub gifting_charge_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.gifting_uses)
    pub gifting_uses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.gifting_max)
    pub gifting_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.gifting_window_hours)
    pub gifting_window_hours: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.trade_restriction)
    pub trade_restriction: ::std::option::Option<::protobuf::EnumOrUnknown<EGCMsgInitiateTradeResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCWrapAndDeliverGiftResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCWrapAndDeliverGiftResponse {
    fn default() -> &'a CMsgClientToGCWrapAndDeliverGiftResponse {
        <CMsgClientToGCWrapAndDeliverGiftResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCWrapAndDeliverGiftResponse {
    pub fn new() -> CMsgClientToGCWrapAndDeliverGiftResponse {
        ::std::default::Default::default()
    }

    // optional .dota.EGCMsgResponse response = 1;

    pub fn response(&self) -> super::econ_shared_enums::EGCMsgResponse {
        match self.response {
            Some(e) => e.enum_value_or(super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK),
            None => super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: super::econ_shared_enums::EGCMsgResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 gifting_charge_uses = 2;

    pub fn gifting_charge_uses(&self) -> u32 {
        self.gifting_charge_uses.unwrap_or(0)
    }

    pub fn clear_gifting_charge_uses(&mut self) {
        self.gifting_charge_uses = ::std::option::Option::None;
    }

    pub fn has_gifting_charge_uses(&self) -> bool {
        self.gifting_charge_uses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_charge_uses(&mut self, v: u32) {
        self.gifting_charge_uses = ::std::option::Option::Some(v);
    }

    // optional int32 gifting_charge_max = 3;

    pub fn gifting_charge_max(&self) -> i32 {
        self.gifting_charge_max.unwrap_or(0)
    }

    pub fn clear_gifting_charge_max(&mut self) {
        self.gifting_charge_max = ::std::option::Option::None;
    }

    pub fn has_gifting_charge_max(&self) -> bool {
        self.gifting_charge_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_charge_max(&mut self, v: i32) {
        self.gifting_charge_max = ::std::option::Option::Some(v);
    }

    // optional uint32 gifting_uses = 4;

    pub fn gifting_uses(&self) -> u32 {
        self.gifting_uses.unwrap_or(0)
    }

    pub fn clear_gifting_uses(&mut self) {
        self.gifting_uses = ::std::option::Option::None;
    }

    pub fn has_gifting_uses(&self) -> bool {
        self.gifting_uses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_uses(&mut self, v: u32) {
        self.gifting_uses = ::std::option::Option::Some(v);
    }

    // optional int32 gifting_max = 5;

    pub fn gifting_max(&self) -> i32 {
        self.gifting_max.unwrap_or(0)
    }

    pub fn clear_gifting_max(&mut self) {
        self.gifting_max = ::std::option::Option::None;
    }

    pub fn has_gifting_max(&self) -> bool {
        self.gifting_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_max(&mut self, v: i32) {
        self.gifting_max = ::std::option::Option::Some(v);
    }

    // optional uint32 gifting_window_hours = 6;

    pub fn gifting_window_hours(&self) -> u32 {
        self.gifting_window_hours.unwrap_or(0)
    }

    pub fn clear_gifting_window_hours(&mut self) {
        self.gifting_window_hours = ::std::option::Option::None;
    }

    pub fn has_gifting_window_hours(&self) -> bool {
        self.gifting_window_hours.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_window_hours(&mut self, v: u32) {
        self.gifting_window_hours = ::std::option::Option::Some(v);
    }

    // optional .dota.EGCMsgInitiateTradeResponse trade_restriction = 7;

    pub fn trade_restriction(&self) -> EGCMsgInitiateTradeResponse {
        match self.trade_restriction {
            Some(e) => e.enum_value_or(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            None => EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
        }
    }

    pub fn clear_trade_restriction(&mut self) {
        self.trade_restriction = ::std::option::Option::None;
    }

    pub fn has_trade_restriction(&self) -> bool {
        self.trade_restriction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_restriction(&mut self, v: EGCMsgInitiateTradeResponse) {
        self.trade_restriction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCWrapAndDeliverGiftResponse| { &m.response },
            |m: &mut CMsgClientToGCWrapAndDeliverGiftResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifting_charge_uses",
            |m: &CMsgClientToGCWrapAndDeliverGiftResponse| { &m.gifting_charge_uses },
            |m: &mut CMsgClientToGCWrapAndDeliverGiftResponse| { &mut m.gifting_charge_uses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifting_charge_max",
            |m: &CMsgClientToGCWrapAndDeliverGiftResponse| { &m.gifting_charge_max },
            |m: &mut CMsgClientToGCWrapAndDeliverGiftResponse| { &mut m.gifting_charge_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifting_uses",
            |m: &CMsgClientToGCWrapAndDeliverGiftResponse| { &m.gifting_uses },
            |m: &mut CMsgClientToGCWrapAndDeliverGiftResponse| { &mut m.gifting_uses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifting_max",
            |m: &CMsgClientToGCWrapAndDeliverGiftResponse| { &m.gifting_max },
            |m: &mut CMsgClientToGCWrapAndDeliverGiftResponse| { &mut m.gifting_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifting_window_hours",
            |m: &CMsgClientToGCWrapAndDeliverGiftResponse| { &m.gifting_window_hours },
            |m: &mut CMsgClientToGCWrapAndDeliverGiftResponse| { &mut m.gifting_window_hours },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_restriction",
            |m: &CMsgClientToGCWrapAndDeliverGiftResponse| { &m.trade_restriction },
            |m: &mut CMsgClientToGCWrapAndDeliverGiftResponse| { &mut m.trade_restriction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCWrapAndDeliverGiftResponse>(
            "CMsgClientToGCWrapAndDeliverGiftResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCWrapAndDeliverGiftResponse {
    const NAME: &'static str = "CMsgClientToGCWrapAndDeliverGiftResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.gifting_charge_uses = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.gifting_charge_max = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.gifting_uses = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.gifting_max = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.gifting_window_hours = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.trade_restriction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.gifting_charge_uses {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gifting_charge_max {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.gifting_uses {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.gifting_max {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.gifting_window_hours {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.trade_restriction {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gifting_charge_uses {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gifting_charge_max {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.gifting_uses {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.gifting_max {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.gifting_window_hours {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.trade_restriction {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCWrapAndDeliverGiftResponse {
        CMsgClientToGCWrapAndDeliverGiftResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.gifting_charge_uses = ::std::option::Option::None;
        self.gifting_charge_max = ::std::option::Option::None;
        self.gifting_uses = ::std::option::Option::None;
        self.gifting_max = ::std::option::Option::None;
        self.gifting_window_hours = ::std::option::Option::None;
        self.trade_restriction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCWrapAndDeliverGiftResponse {
        static instance: CMsgClientToGCWrapAndDeliverGiftResponse = CMsgClientToGCWrapAndDeliverGiftResponse {
            response: ::std::option::Option::None,
            gifting_charge_uses: ::std::option::Option::None,
            gifting_charge_max: ::std::option::Option::None,
            gifting_uses: ::std::option::Option::None,
            gifting_max: ::std::option::Option::None,
            gifting_window_hours: ::std::option::Option::None,
            trade_restriction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCWrapAndDeliverGiftResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCWrapAndDeliverGiftResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCUnwrapGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnwrapGift {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnwrapGift.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnwrapGift.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnwrapGift {
    fn default() -> &'a CMsgClientToGCUnwrapGift {
        <CMsgClientToGCUnwrapGift as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnwrapGift {
    pub fn new() -> CMsgClientToGCUnwrapGift {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCUnwrapGift| { &m.item_id },
            |m: &mut CMsgClientToGCUnwrapGift| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCUnwrapGift>(
            "CMsgClientToGCUnwrapGift",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCUnwrapGift {
    const NAME: &'static str = "CMsgClientToGCUnwrapGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnwrapGift {
        CMsgClientToGCUnwrapGift::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnwrapGift {
        static instance: CMsgClientToGCUnwrapGift = CMsgClientToGCUnwrapGift {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCUnwrapGift {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCUnwrapGift").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCUnwrapGift {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnwrapGift {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetGiftPermissions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetGiftPermissions {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetGiftPermissions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetGiftPermissions {
    fn default() -> &'a CMsgClientToGCGetGiftPermissions {
        <CMsgClientToGCGetGiftPermissions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetGiftPermissions {
    pub fn new() -> CMsgClientToGCGetGiftPermissions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetGiftPermissions>(
            "CMsgClientToGCGetGiftPermissions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetGiftPermissions {
    const NAME: &'static str = "CMsgClientToGCGetGiftPermissions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetGiftPermissions {
        CMsgClientToGCGetGiftPermissions::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetGiftPermissions {
        static instance: CMsgClientToGCGetGiftPermissions = CMsgClientToGCGetGiftPermissions {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetGiftPermissions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetGiftPermissions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetGiftPermissions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetGiftPermissions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetGiftPermissionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetGiftPermissionsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.is_unlimited)
    pub is_unlimited: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.has_two_factor)
    pub has_two_factor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.sender_permission)
    pub sender_permission: ::std::option::Option<::protobuf::EnumOrUnknown<EGCMsgInitiateTradeResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.friendship_age_requirement)
    pub friendship_age_requirement: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.friendship_age_requirement_two_factor)
    pub friendship_age_requirement_two_factor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.friend_permissions)
    pub friend_permissions: ::std::vec::Vec<cmsg_client_to_gcget_gift_permissions_response::FriendPermission>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetGiftPermissionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetGiftPermissionsResponse {
    fn default() -> &'a CMsgClientToGCGetGiftPermissionsResponse {
        <CMsgClientToGCGetGiftPermissionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetGiftPermissionsResponse {
    pub fn new() -> CMsgClientToGCGetGiftPermissionsResponse {
        ::std::default::Default::default()
    }

    // optional bool is_unlimited = 1;

    pub fn is_unlimited(&self) -> bool {
        self.is_unlimited.unwrap_or(false)
    }

    pub fn clear_is_unlimited(&mut self) {
        self.is_unlimited = ::std::option::Option::None;
    }

    pub fn has_is_unlimited(&self) -> bool {
        self.is_unlimited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unlimited(&mut self, v: bool) {
        self.is_unlimited = ::std::option::Option::Some(v);
    }

    // optional bool has_two_factor = 3;

    pub fn has_two_factor(&self) -> bool {
        self.has_two_factor.unwrap_or(false)
    }

    pub fn clear_has_two_factor(&mut self) {
        self.has_two_factor = ::std::option::Option::None;
    }

    pub fn has_has_two_factor(&self) -> bool {
        self.has_two_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_two_factor(&mut self, v: bool) {
        self.has_two_factor = ::std::option::Option::Some(v);
    }

    // optional .dota.EGCMsgInitiateTradeResponse sender_permission = 6;

    pub fn sender_permission(&self) -> EGCMsgInitiateTradeResponse {
        match self.sender_permission {
            Some(e) => e.enum_value_or(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            None => EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
        }
    }

    pub fn clear_sender_permission(&mut self) {
        self.sender_permission = ::std::option::Option::None;
    }

    pub fn has_sender_permission(&self) -> bool {
        self.sender_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_permission(&mut self, v: EGCMsgInitiateTradeResponse) {
        self.sender_permission = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 friendship_age_requirement = 7;

    pub fn friendship_age_requirement(&self) -> u32 {
        self.friendship_age_requirement.unwrap_or(0)
    }

    pub fn clear_friendship_age_requirement(&mut self) {
        self.friendship_age_requirement = ::std::option::Option::None;
    }

    pub fn has_friendship_age_requirement(&self) -> bool {
        self.friendship_age_requirement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendship_age_requirement(&mut self, v: u32) {
        self.friendship_age_requirement = ::std::option::Option::Some(v);
    }

    // optional uint32 friendship_age_requirement_two_factor = 8;

    pub fn friendship_age_requirement_two_factor(&self) -> u32 {
        self.friendship_age_requirement_two_factor.unwrap_or(0)
    }

    pub fn clear_friendship_age_requirement_two_factor(&mut self) {
        self.friendship_age_requirement_two_factor = ::std::option::Option::None;
    }

    pub fn has_friendship_age_requirement_two_factor(&self) -> bool {
        self.friendship_age_requirement_two_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendship_age_requirement_two_factor(&mut self, v: u32) {
        self.friendship_age_requirement_two_factor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_unlimited",
            |m: &CMsgClientToGCGetGiftPermissionsResponse| { &m.is_unlimited },
            |m: &mut CMsgClientToGCGetGiftPermissionsResponse| { &mut m.is_unlimited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_two_factor",
            |m: &CMsgClientToGCGetGiftPermissionsResponse| { &m.has_two_factor },
            |m: &mut CMsgClientToGCGetGiftPermissionsResponse| { &mut m.has_two_factor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_permission",
            |m: &CMsgClientToGCGetGiftPermissionsResponse| { &m.sender_permission },
            |m: &mut CMsgClientToGCGetGiftPermissionsResponse| { &mut m.sender_permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friendship_age_requirement",
            |m: &CMsgClientToGCGetGiftPermissionsResponse| { &m.friendship_age_requirement },
            |m: &mut CMsgClientToGCGetGiftPermissionsResponse| { &mut m.friendship_age_requirement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friendship_age_requirement_two_factor",
            |m: &CMsgClientToGCGetGiftPermissionsResponse| { &m.friendship_age_requirement_two_factor },
            |m: &mut CMsgClientToGCGetGiftPermissionsResponse| { &mut m.friendship_age_requirement_two_factor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friend_permissions",
            |m: &CMsgClientToGCGetGiftPermissionsResponse| { &m.friend_permissions },
            |m: &mut CMsgClientToGCGetGiftPermissionsResponse| { &mut m.friend_permissions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetGiftPermissionsResponse>(
            "CMsgClientToGCGetGiftPermissionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetGiftPermissionsResponse {
    const NAME: &'static str = "CMsgClientToGCGetGiftPermissionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_unlimited = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.has_two_factor = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.sender_permission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.friendship_age_requirement = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.friendship_age_requirement_two_factor = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.friend_permissions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_unlimited {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_two_factor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sender_permission {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.friendship_age_requirement {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.friendship_age_requirement_two_factor {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.friend_permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_unlimited {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.has_two_factor {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.sender_permission {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.friendship_age_requirement {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.friendship_age_requirement_two_factor {
            os.write_uint32(8, v)?;
        }
        for v in &self.friend_permissions {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetGiftPermissionsResponse {
        CMsgClientToGCGetGiftPermissionsResponse::new()
    }

    fn clear(&mut self) {
        self.is_unlimited = ::std::option::Option::None;
        self.has_two_factor = ::std::option::Option::None;
        self.sender_permission = ::std::option::Option::None;
        self.friendship_age_requirement = ::std::option::Option::None;
        self.friendship_age_requirement_two_factor = ::std::option::Option::None;
        self.friend_permissions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetGiftPermissionsResponse {
        static instance: CMsgClientToGCGetGiftPermissionsResponse = CMsgClientToGCGetGiftPermissionsResponse {
            is_unlimited: ::std::option::Option::None,
            has_two_factor: ::std::option::Option::None,
            sender_permission: ::std::option::Option::None,
            friendship_age_requirement: ::std::option::Option::None,
            friendship_age_requirement_two_factor: ::std::option::Option::None,
            friend_permissions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetGiftPermissionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetGiftPermissionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetGiftPermissionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetGiftPermissionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetGiftPermissionsResponse`
pub mod cmsg_client_to_gcget_gift_permissions_response {
    // @@protoc_insertion_point(message:dota.CMsgClientToGCGetGiftPermissionsResponse.FriendPermission)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendPermission {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.FriendPermission.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCGetGiftPermissionsResponse.FriendPermission.permission)
        pub permission: ::std::option::Option<::protobuf::EnumOrUnknown<super::EGCMsgInitiateTradeResponse>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetGiftPermissionsResponse.FriendPermission.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendPermission {
        fn default() -> &'a FriendPermission {
            <FriendPermission as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendPermission {
        pub fn new() -> FriendPermission {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional .dota.EGCMsgInitiateTradeResponse permission = 2;

        pub fn permission(&self) -> super::EGCMsgInitiateTradeResponse {
            match self.permission {
                Some(e) => e.enum_value_or(super::EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
                None => super::EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
            }
        }

        pub fn clear_permission(&mut self) {
            self.permission = ::std::option::Option::None;
        }

        pub fn has_permission(&self) -> bool {
            self.permission.is_some()
        }

        // Param is passed by value, moved
        pub fn set_permission(&mut self, v: super::EGCMsgInitiateTradeResponse) {
            self.permission = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &FriendPermission| { &m.account_id },
                |m: &mut FriendPermission| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "permission",
                |m: &FriendPermission| { &m.permission },
                |m: &mut FriendPermission| { &mut m.permission },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendPermission>(
                "CMsgClientToGCGetGiftPermissionsResponse.FriendPermission",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FriendPermission {
        const NAME: &'static str = "FriendPermission";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.permission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.permission {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.permission {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendPermission {
            FriendPermission::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.permission = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendPermission {
            static instance: FriendPermission = FriendPermission {
                account_id: ::std::option::Option::None,
                permission: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FriendPermission {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCGetGiftPermissionsResponse.FriendPermission").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FriendPermission {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendPermission {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCUnpackBundle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnpackBundle {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnpackBundle.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnpackBundle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnpackBundle {
    fn default() -> &'a CMsgClientToGCUnpackBundle {
        <CMsgClientToGCUnpackBundle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnpackBundle {
    pub fn new() -> CMsgClientToGCUnpackBundle {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCUnpackBundle| { &m.item_id },
            |m: &mut CMsgClientToGCUnpackBundle| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCUnpackBundle>(
            "CMsgClientToGCUnpackBundle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCUnpackBundle {
    const NAME: &'static str = "CMsgClientToGCUnpackBundle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnpackBundle {
        CMsgClientToGCUnpackBundle::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnpackBundle {
        static instance: CMsgClientToGCUnpackBundle = CMsgClientToGCUnpackBundle {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCUnpackBundle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCUnpackBundle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCUnpackBundle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnpackBundle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCUnpackBundleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnpackBundleResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnpackBundleResponse.unpacked_item_ids)
    pub unpacked_item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnpackBundleResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcunpack_bundle_response::EUnpackBundle>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnpackBundleResponse.unpacked_item_def_indexes)
    pub unpacked_item_def_indexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnpackBundleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnpackBundleResponse {
    fn default() -> &'a CMsgClientToGCUnpackBundleResponse {
        <CMsgClientToGCUnpackBundleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnpackBundleResponse {
    pub fn new() -> CMsgClientToGCUnpackBundleResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle response = 2;

    pub fn response(&self) -> cmsg_client_to_gcunpack_bundle_response::EUnpackBundle {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcunpack_bundle_response::EUnpackBundle::k_UnpackBundle_Succeeded),
            None => cmsg_client_to_gcunpack_bundle_response::EUnpackBundle::k_UnpackBundle_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcunpack_bundle_response::EUnpackBundle) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unpacked_item_ids",
            |m: &CMsgClientToGCUnpackBundleResponse| { &m.unpacked_item_ids },
            |m: &mut CMsgClientToGCUnpackBundleResponse| { &mut m.unpacked_item_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCUnpackBundleResponse| { &m.response },
            |m: &mut CMsgClientToGCUnpackBundleResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unpacked_item_def_indexes",
            |m: &CMsgClientToGCUnpackBundleResponse| { &m.unpacked_item_def_indexes },
            |m: &mut CMsgClientToGCUnpackBundleResponse| { &mut m.unpacked_item_def_indexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCUnpackBundleResponse>(
            "CMsgClientToGCUnpackBundleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCUnpackBundleResponse {
    const NAME: &'static str = "CMsgClientToGCUnpackBundleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.unpacked_item_ids)?;
                },
                8 => {
                    self.unpacked_item_ids.push(is.read_uint64()?);
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.unpacked_item_def_indexes)?;
                },
                24 => {
                    self.unpacked_item_def_indexes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.unpacked_item_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.unpacked_item_def_indexes {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.unpacked_item_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.response {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.unpacked_item_def_indexes {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnpackBundleResponse {
        CMsgClientToGCUnpackBundleResponse::new()
    }

    fn clear(&mut self) {
        self.unpacked_item_ids.clear();
        self.response = ::std::option::Option::None;
        self.unpacked_item_def_indexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnpackBundleResponse {
        static instance: CMsgClientToGCUnpackBundleResponse = CMsgClientToGCUnpackBundleResponse {
            unpacked_item_ids: ::std::vec::Vec::new(),
            response: ::std::option::Option::None,
            unpacked_item_def_indexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCUnpackBundleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCUnpackBundleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCUnpackBundleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnpackBundleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCUnpackBundleResponse`
pub mod cmsg_client_to_gcunpack_bundle_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle)
    pub enum EUnpackBundle {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Succeeded)
        k_UnpackBundle_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_ItemIsNotBundle)
        k_UnpackBundle_Failed_ItemIsNotBundle = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_UnableToCreateContainedItem)
        k_UnpackBundle_Failed_UnableToCreateContainedItem = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_SOCacheError)
        k_UnpackBundle_Failed_SOCacheError = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_ItemIsInvalid)
        k_UnpackBundle_Failed_ItemIsInvalid = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_BadItemQuantity)
        k_UnpackBundle_Failed_BadItemQuantity = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_UnableToDeleteItem)
        k_UnpackBundle_Failed_UnableToDeleteItem = 6,
    }

    impl ::protobuf::Enum for EUnpackBundle {
        const NAME: &'static str = "EUnpackBundle";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EUnpackBundle> {
            match value {
                0 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Succeeded),
                1 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle),
                2 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem),
                3 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_SOCacheError),
                4 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid),
                5 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity),
                6 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EUnpackBundle> {
            match str {
                "k_UnpackBundle_Succeeded" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Succeeded),
                "k_UnpackBundle_Failed_ItemIsNotBundle" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle),
                "k_UnpackBundle_Failed_UnableToCreateContainedItem" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem),
                "k_UnpackBundle_Failed_SOCacheError" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_SOCacheError),
                "k_UnpackBundle_Failed_ItemIsInvalid" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid),
                "k_UnpackBundle_Failed_BadItemQuantity" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity),
                "k_UnpackBundle_Failed_UnableToDeleteItem" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EUnpackBundle] = &[
            EUnpackBundle::k_UnpackBundle_Succeeded,
            EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle,
            EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem,
            EUnpackBundle::k_UnpackBundle_Failed_SOCacheError,
            EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid,
            EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity,
            EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem,
        ];
    }

    impl ::protobuf::EnumFull for EUnpackBundle {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCUnpackBundleResponse.EUnpackBundle").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EUnpackBundle {
        fn default() -> Self {
            EUnpackBundle::k_UnpackBundle_Succeeded
        }
    }

    impl EUnpackBundle {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EUnpackBundle>("CMsgClientToGCUnpackBundleResponse.EUnpackBundle")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientStoreTransactionCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientStoreTransactionCompleted {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientStoreTransactionCompleted.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientStoreTransactionCompleted.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientStoreTransactionCompleted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientStoreTransactionCompleted {
    fn default() -> &'a CMsgGCToClientStoreTransactionCompleted {
        <CMsgGCToClientStoreTransactionCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientStoreTransactionCompleted {
    pub fn new() -> CMsgGCToClientStoreTransactionCompleted {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCToClientStoreTransactionCompleted| { &m.txn_id },
            |m: &mut CMsgGCToClientStoreTransactionCompleted| { &mut m.txn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgGCToClientStoreTransactionCompleted| { &m.item_ids },
            |m: &mut CMsgGCToClientStoreTransactionCompleted| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientStoreTransactionCompleted>(
            "CMsgGCToClientStoreTransactionCompleted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientStoreTransactionCompleted {
    const NAME: &'static str = "CMsgGCToClientStoreTransactionCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientStoreTransactionCompleted {
        CMsgGCToClientStoreTransactionCompleted::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientStoreTransactionCompleted {
        static instance: CMsgGCToClientStoreTransactionCompleted = CMsgGCToClientStoreTransactionCompleted {
            txn_id: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientStoreTransactionCompleted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientStoreTransactionCompleted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientStoreTransactionCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientStoreTransactionCompleted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCEquipItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCEquipItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCEquipItems.equips)
    pub equips: ::std::vec::Vec<CMsgAdjustItemEquippedState>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCEquipItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCEquipItems {
    fn default() -> &'a CMsgClientToGCEquipItems {
        <CMsgClientToGCEquipItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCEquipItems {
    pub fn new() -> CMsgClientToGCEquipItems {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "equips",
            |m: &CMsgClientToGCEquipItems| { &m.equips },
            |m: &mut CMsgClientToGCEquipItems| { &mut m.equips },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCEquipItems>(
            "CMsgClientToGCEquipItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCEquipItems {
    const NAME: &'static str = "CMsgClientToGCEquipItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.equips.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.equips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.equips {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCEquipItems {
        CMsgClientToGCEquipItems::new()
    }

    fn clear(&mut self) {
        self.equips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCEquipItems {
        static instance: CMsgClientToGCEquipItems = CMsgClientToGCEquipItems {
            equips: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCEquipItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCEquipItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCEquipItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCEquipItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCEquipItemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCEquipItemsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCEquipItemsResponse.so_cache_version_id)
    pub so_cache_version_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCEquipItemsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCEquipItemsResponse {
    fn default() -> &'a CMsgClientToGCEquipItemsResponse {
        <CMsgClientToGCEquipItemsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCEquipItemsResponse {
    pub fn new() -> CMsgClientToGCEquipItemsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 so_cache_version_id = 1;

    pub fn so_cache_version_id(&self) -> u64 {
        self.so_cache_version_id.unwrap_or(0)
    }

    pub fn clear_so_cache_version_id(&mut self) {
        self.so_cache_version_id = ::std::option::Option::None;
    }

    pub fn has_so_cache_version_id(&self) -> bool {
        self.so_cache_version_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_so_cache_version_id(&mut self, v: u64) {
        self.so_cache_version_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "so_cache_version_id",
            |m: &CMsgClientToGCEquipItemsResponse| { &m.so_cache_version_id },
            |m: &mut CMsgClientToGCEquipItemsResponse| { &mut m.so_cache_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCEquipItemsResponse>(
            "CMsgClientToGCEquipItemsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCEquipItemsResponse {
    const NAME: &'static str = "CMsgClientToGCEquipItemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.so_cache_version_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.so_cache_version_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.so_cache_version_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCEquipItemsResponse {
        CMsgClientToGCEquipItemsResponse::new()
    }

    fn clear(&mut self) {
        self.so_cache_version_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCEquipItemsResponse {
        static instance: CMsgClientToGCEquipItemsResponse = CMsgClientToGCEquipItemsResponse {
            so_cache_version_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCEquipItemsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCEquipItemsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCEquipItemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCEquipItemsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetItemStyle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetItemStyle {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetItemStyle.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetItemStyle.style_index)
    pub style_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetItemStyle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetItemStyle {
    fn default() -> &'a CMsgClientToGCSetItemStyle {
        <CMsgClientToGCSetItemStyle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetItemStyle {
    pub fn new() -> CMsgClientToGCSetItemStyle {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 2;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCSetItemStyle| { &m.item_id },
            |m: &mut CMsgClientToGCSetItemStyle| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_index",
            |m: &CMsgClientToGCSetItemStyle| { &m.style_index },
            |m: &mut CMsgClientToGCSetItemStyle| { &mut m.style_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetItemStyle>(
            "CMsgClientToGCSetItemStyle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetItemStyle {
    const NAME: &'static str = "CMsgClientToGCSetItemStyle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetItemStyle {
        CMsgClientToGCSetItemStyle::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetItemStyle {
        static instance: CMsgClientToGCSetItemStyle = CMsgClientToGCSetItemStyle {
            item_id: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetItemStyle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetItemStyle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetItemStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetItemStyle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetItemStyleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetItemStyleResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetItemStyleResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcset_item_style_response::ESetStyle>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetItemStyleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetItemStyleResponse {
    fn default() -> &'a CMsgClientToGCSetItemStyleResponse {
        <CMsgClientToGCSetItemStyleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetItemStyleResponse {
    pub fn new() -> CMsgClientToGCSetItemStyleResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCSetItemStyleResponse.ESetStyle response = 1;

    pub fn response(&self) -> cmsg_client_to_gcset_item_style_response::ESetStyle {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_item_style_response::ESetStyle::k_SetStyle_Succeeded),
            None => cmsg_client_to_gcset_item_style_response::ESetStyle::k_SetStyle_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcset_item_style_response::ESetStyle) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCSetItemStyleResponse| { &m.response },
            |m: &mut CMsgClientToGCSetItemStyleResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetItemStyleResponse>(
            "CMsgClientToGCSetItemStyleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetItemStyleResponse {
    const NAME: &'static str = "CMsgClientToGCSetItemStyleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetItemStyleResponse {
        CMsgClientToGCSetItemStyleResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetItemStyleResponse {
        static instance: CMsgClientToGCSetItemStyleResponse = CMsgClientToGCSetItemStyleResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetItemStyleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetItemStyleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetItemStyleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetItemStyleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCSetItemStyleResponse`
pub mod cmsg_client_to_gcset_item_style_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCSetItemStyleResponse.ESetStyle)
    pub enum ESetStyle {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetItemStyleResponse.ESetStyle.k_SetStyle_Succeeded)
        k_SetStyle_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetItemStyleResponse.ESetStyle.k_SetStyle_Failed)
        k_SetStyle_Failed = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSetItemStyleResponse.ESetStyle.k_SetStyle_Failed_StyleIsLocked)
        k_SetStyle_Failed_StyleIsLocked = 2,
    }

    impl ::protobuf::Enum for ESetStyle {
        const NAME: &'static str = "ESetStyle";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ESetStyle> {
            match value {
                0 => ::std::option::Option::Some(ESetStyle::k_SetStyle_Succeeded),
                1 => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed),
                2 => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed_StyleIsLocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ESetStyle> {
            match str {
                "k_SetStyle_Succeeded" => ::std::option::Option::Some(ESetStyle::k_SetStyle_Succeeded),
                "k_SetStyle_Failed" => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed),
                "k_SetStyle_Failed_StyleIsLocked" => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed_StyleIsLocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ESetStyle] = &[
            ESetStyle::k_SetStyle_Succeeded,
            ESetStyle::k_SetStyle_Failed,
            ESetStyle::k_SetStyle_Failed_StyleIsLocked,
        ];
    }

    impl ::protobuf::EnumFull for ESetStyle {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCSetItemStyleResponse.ESetStyle").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ESetStyle {
        fn default() -> Self {
            ESetStyle::k_SetStyle_Succeeded
        }
    }

    impl ESetStyle {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESetStyle>("CMsgClientToGCSetItemStyleResponse.ESetStyle")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCUnlockItemStyle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockItemStyle {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockItemStyle.item_to_unlock)
    pub item_to_unlock: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockItemStyle.style_index)
    pub style_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockItemStyle.consumable_item_ids)
    pub consumable_item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnlockItemStyle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockItemStyle {
    fn default() -> &'a CMsgClientToGCUnlockItemStyle {
        <CMsgClientToGCUnlockItemStyle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockItemStyle {
    pub fn new() -> CMsgClientToGCUnlockItemStyle {
        ::std::default::Default::default()
    }

    // optional uint64 item_to_unlock = 1;

    pub fn item_to_unlock(&self) -> u64 {
        self.item_to_unlock.unwrap_or(0)
    }

    pub fn clear_item_to_unlock(&mut self) {
        self.item_to_unlock = ::std::option::Option::None;
    }

    pub fn has_item_to_unlock(&self) -> bool {
        self.item_to_unlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_to_unlock(&mut self, v: u64) {
        self.item_to_unlock = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 2;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_to_unlock",
            |m: &CMsgClientToGCUnlockItemStyle| { &m.item_to_unlock },
            |m: &mut CMsgClientToGCUnlockItemStyle| { &mut m.item_to_unlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_index",
            |m: &CMsgClientToGCUnlockItemStyle| { &m.style_index },
            |m: &mut CMsgClientToGCUnlockItemStyle| { &mut m.style_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "consumable_item_ids",
            |m: &CMsgClientToGCUnlockItemStyle| { &m.consumable_item_ids },
            |m: &mut CMsgClientToGCUnlockItemStyle| { &mut m.consumable_item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCUnlockItemStyle>(
            "CMsgClientToGCUnlockItemStyle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockItemStyle {
    const NAME: &'static str = "CMsgClientToGCUnlockItemStyle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_to_unlock = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.consumable_item_ids)?;
                },
                24 => {
                    self.consumable_item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_to_unlock {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.consumable_item_ids {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_to_unlock {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(2, v)?;
        }
        for v in &self.consumable_item_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockItemStyle {
        CMsgClientToGCUnlockItemStyle::new()
    }

    fn clear(&mut self) {
        self.item_to_unlock = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.consumable_item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockItemStyle {
        static instance: CMsgClientToGCUnlockItemStyle = CMsgClientToGCUnlockItemStyle {
            item_to_unlock: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            consumable_item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCUnlockItemStyle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCUnlockItemStyle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCUnlockItemStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockItemStyle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCUnlockItemStyleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockItemStyleResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockItemStyleResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcunlock_item_style_response::EUnlockStyle>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockItemStyleResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockItemStyleResponse.style_index)
    pub style_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockItemStyleResponse.style_prereq)
    pub style_prereq: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnlockItemStyleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockItemStyleResponse {
    fn default() -> &'a CMsgClientToGCUnlockItemStyleResponse {
        <CMsgClientToGCUnlockItemStyleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockItemStyleResponse {
    pub fn new() -> CMsgClientToGCUnlockItemStyleResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle response = 1;

    pub fn response(&self) -> cmsg_client_to_gcunlock_item_style_response::EUnlockStyle {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcunlock_item_style_response::EUnlockStyle::k_UnlockStyle_Succeeded),
            None => cmsg_client_to_gcunlock_item_style_response::EUnlockStyle::k_UnlockStyle_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcunlock_item_style_response::EUnlockStyle) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 3;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    // optional uint32 style_prereq = 4;

    pub fn style_prereq(&self) -> u32 {
        self.style_prereq.unwrap_or(0)
    }

    pub fn clear_style_prereq(&mut self) {
        self.style_prereq = ::std::option::Option::None;
    }

    pub fn has_style_prereq(&self) -> bool {
        self.style_prereq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_prereq(&mut self, v: u32) {
        self.style_prereq = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCUnlockItemStyleResponse| { &m.response },
            |m: &mut CMsgClientToGCUnlockItemStyleResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCUnlockItemStyleResponse| { &m.item_id },
            |m: &mut CMsgClientToGCUnlockItemStyleResponse| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_index",
            |m: &CMsgClientToGCUnlockItemStyleResponse| { &m.style_index },
            |m: &mut CMsgClientToGCUnlockItemStyleResponse| { &mut m.style_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_prereq",
            |m: &CMsgClientToGCUnlockItemStyleResponse| { &m.style_prereq },
            |m: &mut CMsgClientToGCUnlockItemStyleResponse| { &mut m.style_prereq },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCUnlockItemStyleResponse>(
            "CMsgClientToGCUnlockItemStyleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockItemStyleResponse {
    const NAME: &'static str = "CMsgClientToGCUnlockItemStyleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.style_prereq = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.style_prereq {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.style_prereq {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockItemStyleResponse {
        CMsgClientToGCUnlockItemStyleResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.style_prereq = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockItemStyleResponse {
        static instance: CMsgClientToGCUnlockItemStyleResponse = CMsgClientToGCUnlockItemStyleResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            style_prereq: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCUnlockItemStyleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCUnlockItemStyleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCUnlockItemStyleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockItemStyleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCUnlockItemStyleResponse`
pub mod cmsg_client_to_gcunlock_item_style_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle)
    pub enum EUnlockStyle {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Succeeded)
        k_UnlockStyle_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_PreReq)
        k_UnlockStyle_Failed_PreReq = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantAfford)
        k_UnlockStyle_Failed_CantAfford = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantCommit)
        k_UnlockStyle_Failed_CantCommit = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantLockCache)
        k_UnlockStyle_Failed_CantLockCache = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantAffordAttrib)
        k_UnlockStyle_Failed_CantAffordAttrib = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantAffordGem)
        k_UnlockStyle_Failed_CantAffordGem = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_NoCompendiumLevel)
        k_UnlockStyle_Failed_NoCompendiumLevel = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_AlreadyUnlocked)
        k_UnlockStyle_Failed_AlreadyUnlocked = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_OtherError)
        k_UnlockStyle_Failed_OtherError = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_ItemIsInvalid)
        k_UnlockStyle_Failed_ItemIsInvalid = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_ToolIsInvalid)
        k_UnlockStyle_Failed_ToolIsInvalid = 11,
    }

    impl ::protobuf::Enum for EUnlockStyle {
        const NAME: &'static str = "EUnlockStyle";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EUnlockStyle> {
            match value {
                0 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
                1 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
                2 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
                3 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
                4 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
                5 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
                6 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
                7 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel),
                8 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked),
                9 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_OtherError),
                10 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid),
                11 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EUnlockStyle> {
            match str {
                "k_UnlockStyle_Succeeded" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
                "k_UnlockStyle_Failed_PreReq" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
                "k_UnlockStyle_Failed_CantAfford" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
                "k_UnlockStyle_Failed_CantCommit" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
                "k_UnlockStyle_Failed_CantLockCache" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
                "k_UnlockStyle_Failed_CantAffordAttrib" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
                "k_UnlockStyle_Failed_CantAffordGem" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
                "k_UnlockStyle_Failed_NoCompendiumLevel" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel),
                "k_UnlockStyle_Failed_AlreadyUnlocked" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked),
                "k_UnlockStyle_Failed_OtherError" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_OtherError),
                "k_UnlockStyle_Failed_ItemIsInvalid" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid),
                "k_UnlockStyle_Failed_ToolIsInvalid" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EUnlockStyle] = &[
            EUnlockStyle::k_UnlockStyle_Succeeded,
            EUnlockStyle::k_UnlockStyle_Failed_PreReq,
            EUnlockStyle::k_UnlockStyle_Failed_CantAfford,
            EUnlockStyle::k_UnlockStyle_Failed_CantCommit,
            EUnlockStyle::k_UnlockStyle_Failed_CantLockCache,
            EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib,
            EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem,
            EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel,
            EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked,
            EUnlockStyle::k_UnlockStyle_Failed_OtherError,
            EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid,
            EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid,
        ];
    }

    impl ::protobuf::EnumFull for EUnlockStyle {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EUnlockStyle {
        fn default() -> Self {
            EUnlockStyle::k_UnlockStyle_Succeeded
        }
    }

    impl EUnlockStyle {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EUnlockStyle>("CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSetItemInventoryCategory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetItemInventoryCategory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetItemInventoryCategory.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetItemInventoryCategory.set_to_value)
    pub set_to_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetItemInventoryCategory.remove_categories)
    pub remove_categories: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSetItemInventoryCategory.add_categories)
    pub add_categories: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSetItemInventoryCategory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetItemInventoryCategory {
    fn default() -> &'a CMsgClientToGCSetItemInventoryCategory {
        <CMsgClientToGCSetItemInventoryCategory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetItemInventoryCategory {
    pub fn new() -> CMsgClientToGCSetItemInventoryCategory {
        ::std::default::Default::default()
    }

    // optional uint32 set_to_value = 2;

    pub fn set_to_value(&self) -> u32 {
        self.set_to_value.unwrap_or(0)
    }

    pub fn clear_set_to_value(&mut self) {
        self.set_to_value = ::std::option::Option::None;
    }

    pub fn has_set_to_value(&self) -> bool {
        self.set_to_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_to_value(&mut self, v: u32) {
        self.set_to_value = ::std::option::Option::Some(v);
    }

    // optional uint32 remove_categories = 3;

    pub fn remove_categories(&self) -> u32 {
        self.remove_categories.unwrap_or(0)
    }

    pub fn clear_remove_categories(&mut self) {
        self.remove_categories = ::std::option::Option::None;
    }

    pub fn has_remove_categories(&self) -> bool {
        self.remove_categories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_categories(&mut self, v: u32) {
        self.remove_categories = ::std::option::Option::Some(v);
    }

    // optional uint32 add_categories = 4;

    pub fn add_categories(&self) -> u32 {
        self.add_categories.unwrap_or(0)
    }

    pub fn clear_add_categories(&mut self) {
        self.add_categories = ::std::option::Option::None;
    }

    pub fn has_add_categories(&self) -> bool {
        self.add_categories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_categories(&mut self, v: u32) {
        self.add_categories = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgClientToGCSetItemInventoryCategory| { &m.item_ids },
            |m: &mut CMsgClientToGCSetItemInventoryCategory| { &mut m.item_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "set_to_value",
            |m: &CMsgClientToGCSetItemInventoryCategory| { &m.set_to_value },
            |m: &mut CMsgClientToGCSetItemInventoryCategory| { &mut m.set_to_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remove_categories",
            |m: &CMsgClientToGCSetItemInventoryCategory| { &m.remove_categories },
            |m: &mut CMsgClientToGCSetItemInventoryCategory| { &mut m.remove_categories },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_categories",
            |m: &CMsgClientToGCSetItemInventoryCategory| { &m.add_categories },
            |m: &mut CMsgClientToGCSetItemInventoryCategory| { &mut m.add_categories },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSetItemInventoryCategory>(
            "CMsgClientToGCSetItemInventoryCategory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSetItemInventoryCategory {
    const NAME: &'static str = "CMsgClientToGCSetItemInventoryCategory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                16 => {
                    self.set_to_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.remove_categories = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.add_categories = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.set_to_value {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.remove_categories {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.add_categories {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.set_to_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.remove_categories {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.add_categories {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetItemInventoryCategory {
        CMsgClientToGCSetItemInventoryCategory::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.set_to_value = ::std::option::Option::None;
        self.remove_categories = ::std::option::Option::None;
        self.add_categories = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetItemInventoryCategory {
        static instance: CMsgClientToGCSetItemInventoryCategory = CMsgClientToGCSetItemInventoryCategory {
            item_ids: ::std::vec::Vec::new(),
            set_to_value: ::std::option::Option::None,
            remove_categories: ::std::option::Option::None,
            add_categories: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSetItemInventoryCategory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSetItemInventoryCategory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSetItemInventoryCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetItemInventoryCategory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCUnlockCrate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockCrate {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockCrate.crate_item_id)
    pub crate_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockCrate.key_item_id)
    pub key_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnlockCrate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockCrate {
    fn default() -> &'a CMsgClientToGCUnlockCrate {
        <CMsgClientToGCUnlockCrate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockCrate {
    pub fn new() -> CMsgClientToGCUnlockCrate {
        ::std::default::Default::default()
    }

    // optional uint64 crate_item_id = 1;

    pub fn crate_item_id(&self) -> u64 {
        self.crate_item_id.unwrap_or(0)
    }

    pub fn clear_crate_item_id(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
    }

    pub fn has_crate_item_id(&self) -> bool {
        self.crate_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_id(&mut self, v: u64) {
        self.crate_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 key_item_id = 2;

    pub fn key_item_id(&self) -> u64 {
        self.key_item_id.unwrap_or(0)
    }

    pub fn clear_key_item_id(&mut self) {
        self.key_item_id = ::std::option::Option::None;
    }

    pub fn has_key_item_id(&self) -> bool {
        self.key_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_item_id(&mut self, v: u64) {
        self.key_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crate_item_id",
            |m: &CMsgClientToGCUnlockCrate| { &m.crate_item_id },
            |m: &mut CMsgClientToGCUnlockCrate| { &mut m.crate_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_item_id",
            |m: &CMsgClientToGCUnlockCrate| { &m.key_item_id },
            |m: &mut CMsgClientToGCUnlockCrate| { &mut m.key_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCUnlockCrate>(
            "CMsgClientToGCUnlockCrate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockCrate {
    const NAME: &'static str = "CMsgClientToGCUnlockCrate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.key_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.key_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.crate_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.key_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockCrate {
        CMsgClientToGCUnlockCrate::new()
    }

    fn clear(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
        self.key_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockCrate {
        static instance: CMsgClientToGCUnlockCrate = CMsgClientToGCUnlockCrate {
            crate_item_id: ::std::option::Option::None,
            key_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCUnlockCrate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCUnlockCrate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCUnlockCrate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockCrate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCUnlockCrateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockCrateResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockCrateResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<super::econ_shared_enums::EGCMsgResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockCrateResponse.granted_items)
    pub granted_items: ::std::vec::Vec<cmsg_client_to_gcunlock_crate_response::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnlockCrateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockCrateResponse {
    fn default() -> &'a CMsgClientToGCUnlockCrateResponse {
        <CMsgClientToGCUnlockCrateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockCrateResponse {
    pub fn new() -> CMsgClientToGCUnlockCrateResponse {
        ::std::default::Default::default()
    }

    // optional .dota.EGCMsgResponse result = 1;

    pub fn result(&self) -> super::econ_shared_enums::EGCMsgResponse {
        match self.result {
            Some(e) => e.enum_value_or(super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK),
            None => super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::econ_shared_enums::EGCMsgResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCUnlockCrateResponse| { &m.result },
            |m: &mut CMsgClientToGCUnlockCrateResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "granted_items",
            |m: &CMsgClientToGCUnlockCrateResponse| { &m.granted_items },
            |m: &mut CMsgClientToGCUnlockCrateResponse| { &mut m.granted_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCUnlockCrateResponse>(
            "CMsgClientToGCUnlockCrateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockCrateResponse {
    const NAME: &'static str = "CMsgClientToGCUnlockCrateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.granted_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.granted_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.granted_items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockCrateResponse {
        CMsgClientToGCUnlockCrateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.granted_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockCrateResponse {
        static instance: CMsgClientToGCUnlockCrateResponse = CMsgClientToGCUnlockCrateResponse {
            result: ::std::option::Option::None,
            granted_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCUnlockCrateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCUnlockCrateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCUnlockCrateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockCrateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCUnlockCrateResponse`
pub mod cmsg_client_to_gcunlock_crate_response {
    // @@protoc_insertion_point(message:dota.CMsgClientToGCUnlockCrateResponse.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockCrateResponse.Item.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCUnlockCrateResponse.Item.def_index)
        pub def_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCUnlockCrateResponse.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 def_index = 2;

        pub fn def_index(&self) -> u32 {
            self.def_index.unwrap_or(0)
        }

        pub fn clear_def_index(&mut self) {
            self.def_index = ::std::option::Option::None;
        }

        pub fn has_def_index(&self) -> bool {
            self.def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_def_index(&mut self, v: u32) {
            self.def_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &Item| { &m.item_id },
                |m: &mut Item| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "def_index",
                |m: &Item| { &m.def_index },
                |m: &mut Item| { &mut m.def_index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                "CMsgClientToGCUnlockCrateResponse.Item",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.def_index {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.def_index {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.def_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_id: ::std::option::Option::None,
                def_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Item {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCUnlockCrateResponse.Item").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Item {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRemoveItemAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRemoveItemAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRemoveItemAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveItemAttribute {
    fn default() -> &'a CMsgClientToGCRemoveItemAttribute {
        <CMsgClientToGCRemoveItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveItemAttribute {
    pub fn new() -> CMsgClientToGCRemoveItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCRemoveItemAttribute| { &m.item_id },
            |m: &mut CMsgClientToGCRemoveItemAttribute| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRemoveItemAttribute>(
            "CMsgClientToGCRemoveItemAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRemoveItemAttribute {
    const NAME: &'static str = "CMsgClientToGCRemoveItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveItemAttribute {
        CMsgClientToGCRemoveItemAttribute::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveItemAttribute {
        static instance: CMsgClientToGCRemoveItemAttribute = CMsgClientToGCRemoveItemAttribute {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRemoveItemAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRemoveItemAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRemoveItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRemoveItemAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRemoveItemAttributeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveItemAttributeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRemoveItemAttributeResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRemoveItemAttributeResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRemoveItemAttributeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveItemAttributeResponse {
    fn default() -> &'a CMsgClientToGCRemoveItemAttributeResponse {
        <CMsgClientToGCRemoveItemAttributeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveItemAttributeResponse {
    pub fn new() -> CMsgClientToGCRemoveItemAttributeResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute response = 1;

    pub fn response(&self) -> cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded),
            None => cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCRemoveItemAttributeResponse| { &m.response },
            |m: &mut CMsgClientToGCRemoveItemAttributeResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCRemoveItemAttributeResponse| { &m.item_id },
            |m: &mut CMsgClientToGCRemoveItemAttributeResponse| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRemoveItemAttributeResponse>(
            "CMsgClientToGCRemoveItemAttributeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRemoveItemAttributeResponse {
    const NAME: &'static str = "CMsgClientToGCRemoveItemAttributeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveItemAttributeResponse {
        CMsgClientToGCRemoveItemAttributeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveItemAttributeResponse {
        static instance: CMsgClientToGCRemoveItemAttributeResponse = CMsgClientToGCRemoveItemAttributeResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRemoveItemAttributeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRemoveItemAttributeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRemoveItemAttributeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRemoveItemAttributeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRemoveItemAttributeResponse`
pub mod cmsg_client_to_gcremove_item_attribute_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute)
    pub enum ERemoveItemAttribute {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Succeeded)
        k_RemoveItemAttribute_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed)
        k_RemoveItemAttribute_Failed = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed_ItemIsInvalid)
        k_RemoveItemAttribute_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved)
        k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed_AttributeDoesntExist)
        k_RemoveItemAttribute_Failed_AttributeDoesntExist = 4,
    }

    impl ::protobuf::Enum for ERemoveItemAttribute {
        const NAME: &'static str = "ERemoveItemAttribute";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERemoveItemAttribute> {
            match value {
                0 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded),
                1 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed),
                2 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved),
                4 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERemoveItemAttribute> {
            match str {
                "k_RemoveItemAttribute_Succeeded" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded),
                "k_RemoveItemAttribute_Failed" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed),
                "k_RemoveItemAttribute_Failed_ItemIsInvalid" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid),
                "k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved),
                "k_RemoveItemAttribute_Failed_AttributeDoesntExist" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERemoveItemAttribute] = &[
            ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist,
        ];
    }

    impl ::protobuf::EnumFull for ERemoveItemAttribute {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ERemoveItemAttribute {
        fn default() -> Self {
            ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded
        }
    }

    impl ERemoveItemAttribute {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERemoveItemAttribute>("CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCNameItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCNameItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCNameItem.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCNameItem.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCNameItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCNameItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCNameItem {
    fn default() -> &'a CMsgClientToGCNameItem {
        <CMsgClientToGCNameItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCNameItem {
    pub fn new() -> CMsgClientToGCNameItem {
        ::std::default::Default::default()
    }

    // optional uint64 subject_item_id = 1;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 tool_item_id = 2;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject_item_id",
            |m: &CMsgClientToGCNameItem| { &m.subject_item_id },
            |m: &mut CMsgClientToGCNameItem| { &mut m.subject_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgClientToGCNameItem| { &m.tool_item_id },
            |m: &mut CMsgClientToGCNameItem| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgClientToGCNameItem| { &m.name },
            |m: &mut CMsgClientToGCNameItem| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCNameItem>(
            "CMsgClientToGCNameItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCNameItem {
    const NAME: &'static str = "CMsgClientToGCNameItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subject_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.tool_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCNameItem {
        CMsgClientToGCNameItem::new()
    }

    fn clear(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
        self.tool_item_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCNameItem {
        static instance: CMsgClientToGCNameItem = CMsgClientToGCNameItem {
            subject_item_id: ::std::option::Option::None,
            tool_item_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCNameItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCNameItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCNameItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCNameItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCNameItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCNameItemResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCNameItemResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcname_item_response::ENameItem>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCNameItemResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCNameItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCNameItemResponse {
    fn default() -> &'a CMsgClientToGCNameItemResponse {
        <CMsgClientToGCNameItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCNameItemResponse {
    pub fn new() -> CMsgClientToGCNameItemResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCNameItemResponse.ENameItem response = 1;

    pub fn response(&self) -> cmsg_client_to_gcname_item_response::ENameItem {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcname_item_response::ENameItem::k_NameItem_Succeeded),
            None => cmsg_client_to_gcname_item_response::ENameItem::k_NameItem_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcname_item_response::ENameItem) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCNameItemResponse| { &m.response },
            |m: &mut CMsgClientToGCNameItemResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgClientToGCNameItemResponse| { &m.item_id },
            |m: &mut CMsgClientToGCNameItemResponse| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCNameItemResponse>(
            "CMsgClientToGCNameItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCNameItemResponse {
    const NAME: &'static str = "CMsgClientToGCNameItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCNameItemResponse {
        CMsgClientToGCNameItemResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCNameItemResponse {
        static instance: CMsgClientToGCNameItemResponse = CMsgClientToGCNameItemResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCNameItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCNameItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCNameItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCNameItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCNameItemResponse`
pub mod cmsg_client_to_gcname_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCNameItemResponse.ENameItem)
    pub enum ENameItem {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Succeeded)
        k_NameItem_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed)
        k_NameItem_Failed = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed_ToolIsInvalid)
        k_NameItem_Failed_ToolIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed_ItemIsInvalid)
        k_NameItem_Failed_ItemIsInvalid = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed_NameIsInvalid)
        k_NameItem_Failed_NameIsInvalid = 4,
    }

    impl ::protobuf::Enum for ENameItem {
        const NAME: &'static str = "ENameItem";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ENameItem> {
            match value {
                0 => ::std::option::Option::Some(ENameItem::k_NameItem_Succeeded),
                1 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed),
                2 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ToolIsInvalid),
                3 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ItemIsInvalid),
                4 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_NameIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ENameItem> {
            match str {
                "k_NameItem_Succeeded" => ::std::option::Option::Some(ENameItem::k_NameItem_Succeeded),
                "k_NameItem_Failed" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed),
                "k_NameItem_Failed_ToolIsInvalid" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ToolIsInvalid),
                "k_NameItem_Failed_ItemIsInvalid" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ItemIsInvalid),
                "k_NameItem_Failed_NameIsInvalid" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_NameIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ENameItem] = &[
            ENameItem::k_NameItem_Succeeded,
            ENameItem::k_NameItem_Failed,
            ENameItem::k_NameItem_Failed_ToolIsInvalid,
            ENameItem::k_NameItem_Failed_ItemIsInvalid,
            ENameItem::k_NameItem_Failed_NameIsInvalid,
        ];
    }

    impl ::protobuf::EnumFull for ENameItem {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCNameItemResponse.ENameItem").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ENameItem {
        fn default() -> Self {
            ENameItem::k_NameItem_Succeeded
        }
    }

    impl ENameItem {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ENameItem>("CMsgClientToGCNameItemResponse.ENameItem")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCSetItemPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSetItemPosition {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCSetItemPosition.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCSetItemPosition.new_position)
    pub new_position: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCSetItemPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSetItemPosition {
    fn default() -> &'a CMsgGCSetItemPosition {
        <CMsgGCSetItemPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSetItemPosition {
    pub fn new() -> CMsgGCSetItemPosition {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_position = 2;

    pub fn new_position(&self) -> u32 {
        self.new_position.unwrap_or(0)
    }

    pub fn clear_new_position(&mut self) {
        self.new_position = ::std::option::Option::None;
    }

    pub fn has_new_position(&self) -> bool {
        self.new_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_position(&mut self, v: u32) {
        self.new_position = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgGCSetItemPosition| { &m.item_id },
            |m: &mut CMsgGCSetItemPosition| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_position",
            |m: &CMsgGCSetItemPosition| { &m.new_position },
            |m: &mut CMsgGCSetItemPosition| { &mut m.new_position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCSetItemPosition>(
            "CMsgGCSetItemPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCSetItemPosition {
    const NAME: &'static str = "CMsgGCSetItemPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.new_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.new_position {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_position {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSetItemPosition {
        CMsgGCSetItemPosition::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_position = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSetItemPosition {
        static instance: CMsgGCSetItemPosition = CMsgGCSetItemPosition {
            item_id: ::std::option::Option::None,
            new_position: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCSetItemPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCSetItemPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCSetItemPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSetItemPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CAttribute_ItemDynamicRecipeComponent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_ItemDynamicRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.item_flags)
    pub item_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.attributes_string)
    pub attributes_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.item_count)
    pub item_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.items_fulfilled)
    pub items_fulfilled: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.item_rarity)
    pub item_rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.lootlist)
    pub lootlist: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.fulfilled_item_id)
    pub fulfilled_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CAttribute_ItemDynamicRecipeComponent.associated_item_def)
    pub associated_item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CAttribute_ItemDynamicRecipeComponent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_ItemDynamicRecipeComponent {
    fn default() -> &'a CAttribute_ItemDynamicRecipeComponent {
        <CAttribute_ItemDynamicRecipeComponent as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_ItemDynamicRecipeComponent {
    pub fn new() -> CAttribute_ItemDynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 item_flags = 3;

    pub fn item_flags(&self) -> u32 {
        self.item_flags.unwrap_or(0)
    }

    pub fn clear_item_flags(&mut self) {
        self.item_flags = ::std::option::Option::None;
    }

    pub fn has_item_flags(&self) -> bool {
        self.item_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_flags(&mut self, v: u32) {
        self.item_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 4;

    pub fn attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attributes_string(&mut self) {
        self.attributes_string = ::std::option::Option::None;
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 item_count = 5;

    pub fn item_count(&self) -> u32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: u32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional uint32 items_fulfilled = 6;

    pub fn items_fulfilled(&self) -> u32 {
        self.items_fulfilled.unwrap_or(0)
    }

    pub fn clear_items_fulfilled(&mut self) {
        self.items_fulfilled = ::std::option::Option::None;
    }

    pub fn has_items_fulfilled(&self) -> bool {
        self.items_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_fulfilled(&mut self, v: u32) {
        self.items_fulfilled = ::std::option::Option::Some(v);
    }

    // optional uint32 item_rarity = 7;

    pub fn item_rarity(&self) -> u32 {
        self.item_rarity.unwrap_or(0)
    }

    pub fn clear_item_rarity(&mut self) {
        self.item_rarity = ::std::option::Option::None;
    }

    pub fn has_item_rarity(&self) -> bool {
        self.item_rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_rarity(&mut self, v: u32) {
        self.item_rarity = ::std::option::Option::Some(v);
    }

    // optional string lootlist = 8;

    pub fn lootlist(&self) -> &str {
        match self.lootlist.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lootlist(&mut self) {
        self.lootlist = ::std::option::Option::None;
    }

    pub fn has_lootlist(&self) -> bool {
        self.lootlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lootlist(&mut self, v: ::std::string::String) {
        self.lootlist = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lootlist(&mut self) -> &mut ::std::string::String {
        if self.lootlist.is_none() {
            self.lootlist = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lootlist.as_mut().unwrap()
    }

    // Take field
    pub fn take_lootlist(&mut self) -> ::std::string::String {
        self.lootlist.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fulfilled_item_id = 9;

    pub fn fulfilled_item_id(&self) -> u64 {
        self.fulfilled_item_id.unwrap_or(0)
    }

    pub fn clear_fulfilled_item_id(&mut self) {
        self.fulfilled_item_id = ::std::option::Option::None;
    }

    pub fn has_fulfilled_item_id(&self) -> bool {
        self.fulfilled_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fulfilled_item_id(&mut self, v: u64) {
        self.fulfilled_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 associated_item_def = 10;

    pub fn associated_item_def(&self) -> u32 {
        self.associated_item_def.unwrap_or(0)
    }

    pub fn clear_associated_item_def(&mut self) {
        self.associated_item_def = ::std::option::Option::None;
    }

    pub fn has_associated_item_def(&self) -> bool {
        self.associated_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_item_def(&mut self, v: u32) {
        self.associated_item_def = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.item_def },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.item_quality },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.item_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_flags",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.item_flags },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.item_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attributes_string",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.attributes_string },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.attributes_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_count",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.item_count },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.item_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "items_fulfilled",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.items_fulfilled },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.items_fulfilled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_rarity",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.item_rarity },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.item_rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lootlist",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.lootlist },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.lootlist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fulfilled_item_id",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.fulfilled_item_id },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.fulfilled_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "associated_item_def",
            |m: &CAttribute_ItemDynamicRecipeComponent| { &m.associated_item_def },
            |m: &mut CAttribute_ItemDynamicRecipeComponent| { &mut m.associated_item_def },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_ItemDynamicRecipeComponent>(
            "CAttribute_ItemDynamicRecipeComponent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_ItemDynamicRecipeComponent {
    const NAME: &'static str = "CAttribute_ItemDynamicRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.attributes_string = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.items_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.item_rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.lootlist = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.fulfilled_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.associated_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.attributes_string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.item_count {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.items_fulfilled {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.item_rarity {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.lootlist.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fulfilled_item_id {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.associated_item_def {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.attributes_string.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.items_fulfilled {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.item_rarity {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.lootlist.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fulfilled_item_id {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.associated_item_def {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_ItemDynamicRecipeComponent {
        CAttribute_ItemDynamicRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_flags = ::std::option::Option::None;
        self.attributes_string = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.items_fulfilled = ::std::option::Option::None;
        self.item_rarity = ::std::option::Option::None;
        self.lootlist = ::std::option::Option::None;
        self.fulfilled_item_id = ::std::option::Option::None;
        self.associated_item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_ItemDynamicRecipeComponent {
        static instance: CAttribute_ItemDynamicRecipeComponent = CAttribute_ItemDynamicRecipeComponent {
            item_def: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            item_flags: ::std::option::Option::None,
            attributes_string: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            items_fulfilled: ::std::option::Option::None,
            item_rarity: ::std::option::Option::None,
            lootlist: ::std::option::Option::None,
            fulfilled_item_id: ::std::option::Option::None,
            associated_item_def: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_ItemDynamicRecipeComponent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_ItemDynamicRecipeComponent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_ItemDynamicRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_ItemDynamicRecipeComponent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket.attr_def_index)
    pub attr_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket.required_type)
    pub required_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket.required_hero)
    pub required_hero: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket.gem_def_index)
    pub gem_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket.not_tradable)
    pub not_tradable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket.required_item_slot)
    pub required_item_slot: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket {
    fn default() -> &'a CProtoItemSocket {
        <CProtoItemSocket as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket {
    pub fn new() -> CProtoItemSocket {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attr_def_index = 2;

    pub fn attr_def_index(&self) -> u32 {
        self.attr_def_index.unwrap_or(0)
    }

    pub fn clear_attr_def_index(&mut self) {
        self.attr_def_index = ::std::option::Option::None;
    }

    pub fn has_attr_def_index(&self) -> bool {
        self.attr_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr_def_index(&mut self, v: u32) {
        self.attr_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 required_type = 3;

    pub fn required_type(&self) -> u32 {
        self.required_type.unwrap_or(0)
    }

    pub fn clear_required_type(&mut self) {
        self.required_type = ::std::option::Option::None;
    }

    pub fn has_required_type(&self) -> bool {
        self.required_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_type(&mut self, v: u32) {
        self.required_type = ::std::option::Option::Some(v);
    }

    // optional string required_hero = 4;

    pub fn required_hero(&self) -> &str {
        match self.required_hero.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_required_hero(&mut self) {
        self.required_hero = ::std::option::Option::None;
    }

    pub fn has_required_hero(&self) -> bool {
        self.required_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_hero(&mut self, v: ::std::string::String) {
        self.required_hero = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_hero(&mut self) -> &mut ::std::string::String {
        if self.required_hero.is_none() {
            self.required_hero = ::std::option::Option::Some(::std::string::String::new());
        }
        self.required_hero.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_hero(&mut self) -> ::std::string::String {
        self.required_hero.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gem_def_index = 5;

    pub fn gem_def_index(&self) -> u32 {
        self.gem_def_index.unwrap_or(0)
    }

    pub fn clear_gem_def_index(&mut self) {
        self.gem_def_index = ::std::option::Option::None;
    }

    pub fn has_gem_def_index(&self) -> bool {
        self.gem_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gem_def_index(&mut self, v: u32) {
        self.gem_def_index = ::std::option::Option::Some(v);
    }

    // optional bool not_tradable = 6;

    pub fn not_tradable(&self) -> bool {
        self.not_tradable.unwrap_or(false)
    }

    pub fn clear_not_tradable(&mut self) {
        self.not_tradable = ::std::option::Option::None;
    }

    pub fn has_not_tradable(&self) -> bool {
        self.not_tradable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_tradable(&mut self, v: bool) {
        self.not_tradable = ::std::option::Option::Some(v);
    }

    // optional string required_item_slot = 7;

    pub fn required_item_slot(&self) -> &str {
        match self.required_item_slot.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_required_item_slot(&mut self) {
        self.required_item_slot = ::std::option::Option::None;
    }

    pub fn has_required_item_slot(&self) -> bool {
        self.required_item_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_item_slot(&mut self, v: ::std::string::String) {
        self.required_item_slot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_item_slot(&mut self) -> &mut ::std::string::String {
        if self.required_item_slot.is_none() {
            self.required_item_slot = ::std::option::Option::Some(::std::string::String::new());
        }
        self.required_item_slot.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_item_slot(&mut self) -> ::std::string::String {
        self.required_item_slot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CProtoItemSocket| { &m.item_id },
            |m: &mut CProtoItemSocket| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attr_def_index",
            |m: &CProtoItemSocket| { &m.attr_def_index },
            |m: &mut CProtoItemSocket| { &mut m.attr_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_type",
            |m: &CProtoItemSocket| { &m.required_type },
            |m: &mut CProtoItemSocket| { &mut m.required_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_hero",
            |m: &CProtoItemSocket| { &m.required_hero },
            |m: &mut CProtoItemSocket| { &mut m.required_hero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gem_def_index",
            |m: &CProtoItemSocket| { &m.gem_def_index },
            |m: &mut CProtoItemSocket| { &mut m.gem_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_tradable",
            |m: &CProtoItemSocket| { &m.not_tradable },
            |m: &mut CProtoItemSocket| { &mut m.not_tradable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_item_slot",
            |m: &CProtoItemSocket| { &m.required_item_slot },
            |m: &mut CProtoItemSocket| { &mut m.required_item_slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket>(
            "CProtoItemSocket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket {
    const NAME: &'static str = "CProtoItemSocket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.attr_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.required_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.required_hero = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.gem_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.not_tradable = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.required_item_slot = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.attr_def_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.required_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.required_hero.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gem_def_index {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.not_tradable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.required_item_slot.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attr_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.required_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.required_hero.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.gem_def_index {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.not_tradable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.required_item_slot.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket {
        CProtoItemSocket::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.attr_def_index = ::std::option::Option::None;
        self.required_type = ::std::option::Option::None;
        self.required_hero = ::std::option::Option::None;
        self.gem_def_index = ::std::option::Option::None;
        self.not_tradable = ::std::option::Option::None;
        self.required_item_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket {
        static instance: CProtoItemSocket = CProtoItemSocket {
            item_id: ::std::option::Option::None,
            attr_def_index: ::std::option::Option::None,
            required_type: ::std::option::Option::None,
            required_hero: ::std::option::Option::None,
            gem_def_index: ::std::option::Option::None,
            not_tradable: ::std::option::Option::None,
            required_item_slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_Empty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Empty {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Empty.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_Empty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Empty {
    fn default() -> &'a CProtoItemSocket_Empty {
        <CProtoItemSocket_Empty as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Empty {
    pub fn new() -> CProtoItemSocket_Empty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_Empty| { &m.socket },
            |m: &mut CProtoItemSocket_Empty| { &mut m.socket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_Empty>(
            "CProtoItemSocket_Empty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_Empty {
    const NAME: &'static str = "CProtoItemSocket_Empty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Empty {
        CProtoItemSocket_Empty::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Empty {
        static instance: CProtoItemSocket_Empty = CProtoItemSocket_Empty {
            socket: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_Empty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_Empty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Empty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_Effect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Effect {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Effect.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Effect.effect)
    pub effect: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_Effect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Effect {
    fn default() -> &'a CProtoItemSocket_Effect {
        <CProtoItemSocket_Effect as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Effect {
    pub fn new() -> CProtoItemSocket_Effect {
        ::std::default::Default::default()
    }

    // optional uint32 effect = 2;

    pub fn effect(&self) -> u32 {
        self.effect.unwrap_or(0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: u32) {
        self.effect = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_Effect| { &m.socket },
            |m: &mut CProtoItemSocket_Effect| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &CProtoItemSocket_Effect| { &m.effect },
            |m: &mut CProtoItemSocket_Effect| { &mut m.effect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_Effect>(
            "CProtoItemSocket_Effect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_Effect {
    const NAME: &'static str = "CProtoItemSocket_Effect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.effect {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Effect {
        CProtoItemSocket_Effect::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.effect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Effect {
        static instance: CProtoItemSocket_Effect = CProtoItemSocket_Effect {
            socket: ::protobuf::MessageField::none(),
            effect: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_Effect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_Effect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Effect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_Color)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Color {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Color.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Color.red)
    pub red: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Color.green)
    pub green: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Color.blue)
    pub blue: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_Color.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Color {
    fn default() -> &'a CProtoItemSocket_Color {
        <CProtoItemSocket_Color as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Color {
    pub fn new() -> CProtoItemSocket_Color {
        ::std::default::Default::default()
    }

    // optional uint32 red = 2;

    pub fn red(&self) -> u32 {
        self.red.unwrap_or(0)
    }

    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: u32) {
        self.red = ::std::option::Option::Some(v);
    }

    // optional uint32 green = 3;

    pub fn green(&self) -> u32 {
        self.green.unwrap_or(0)
    }

    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: u32) {
        self.green = ::std::option::Option::Some(v);
    }

    // optional uint32 blue = 4;

    pub fn blue(&self) -> u32 {
        self.blue.unwrap_or(0)
    }

    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: u32) {
        self.blue = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_Color| { &m.socket },
            |m: &mut CProtoItemSocket_Color| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "red",
            |m: &CProtoItemSocket_Color| { &m.red },
            |m: &mut CProtoItemSocket_Color| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "green",
            |m: &CProtoItemSocket_Color| { &m.green },
            |m: &mut CProtoItemSocket_Color| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blue",
            |m: &CProtoItemSocket_Color| { &m.blue },
            |m: &mut CProtoItemSocket_Color| { &mut m.blue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_Color>(
            "CProtoItemSocket_Color",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_Color {
    const NAME: &'static str = "CProtoItemSocket_Color";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.red = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.green = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.blue = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.red {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.green {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.blue {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.red {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.green {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.blue {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Color {
        CProtoItemSocket_Color::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.red = ::std::option::Option::None;
        self.green = ::std::option::Option::None;
        self.blue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Color {
        static instance: CProtoItemSocket_Color = CProtoItemSocket_Color {
            socket: ::protobuf::MessageField::none(),
            red: ::std::option::Option::None,
            green: ::std::option::Option::None,
            blue: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_Color {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_Color").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_Color {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Color {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_Strange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Strange {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Strange.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Strange.strange_type)
    pub strange_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Strange.strange_value)
    pub strange_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_Strange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Strange {
    fn default() -> &'a CProtoItemSocket_Strange {
        <CProtoItemSocket_Strange as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Strange {
    pub fn new() -> CProtoItemSocket_Strange {
        ::std::default::Default::default()
    }

    // optional uint32 strange_type = 2;

    pub fn strange_type(&self) -> u32 {
        self.strange_type.unwrap_or(0)
    }

    pub fn clear_strange_type(&mut self) {
        self.strange_type = ::std::option::Option::None;
    }

    pub fn has_strange_type(&self) -> bool {
        self.strange_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_type(&mut self, v: u32) {
        self.strange_type = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_value = 3;

    pub fn strange_value(&self) -> u32 {
        self.strange_value.unwrap_or(0)
    }

    pub fn clear_strange_value(&mut self) {
        self.strange_value = ::std::option::Option::None;
    }

    pub fn has_strange_value(&self) -> bool {
        self.strange_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_value(&mut self, v: u32) {
        self.strange_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_Strange| { &m.socket },
            |m: &mut CProtoItemSocket_Strange| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_type",
            |m: &CProtoItemSocket_Strange| { &m.strange_type },
            |m: &mut CProtoItemSocket_Strange| { &mut m.strange_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_value",
            |m: &CProtoItemSocket_Strange| { &m.strange_value },
            |m: &mut CProtoItemSocket_Strange| { &mut m.strange_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_Strange>(
            "CProtoItemSocket_Strange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_Strange {
    const NAME: &'static str = "CProtoItemSocket_Strange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.strange_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.strange_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strange_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.strange_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.strange_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.strange_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Strange {
        CProtoItemSocket_Strange::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.strange_type = ::std::option::Option::None;
        self.strange_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Strange {
        static instance: CProtoItemSocket_Strange = CProtoItemSocket_Strange {
            socket: ::protobuf::MessageField::none(),
            strange_type: ::std::option::Option::None,
            strange_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_Strange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_Strange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_Strange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Strange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.strange_type)
    pub strange_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.strange_value)
    pub strange_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.ability_effect)
    pub ability_effect: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    fn default() -> &'a CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        <CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    pub fn new() -> CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        ::std::default::Default::default()
    }

    // optional uint32 strange_type = 2;

    pub fn strange_type(&self) -> u32 {
        self.strange_type.unwrap_or(0)
    }

    pub fn clear_strange_type(&mut self) {
        self.strange_type = ::std::option::Option::None;
    }

    pub fn has_strange_type(&self) -> bool {
        self.strange_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_type(&mut self, v: u32) {
        self.strange_type = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_value = 3;

    pub fn strange_value(&self) -> u32 {
        self.strange_value.unwrap_or(0)
    }

    pub fn clear_strange_value(&mut self) {
        self.strange_value = ::std::option::Option::None;
    }

    pub fn has_strange_value(&self) -> bool {
        self.strange_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_value(&mut self, v: u32) {
        self.strange_value = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_effect = 4;

    pub fn ability_effect(&self) -> u32 {
        self.ability_effect.unwrap_or(0)
    }

    pub fn clear_ability_effect(&mut self) {
        self.ability_effect = ::std::option::Option::None;
    }

    pub fn has_ability_effect(&self) -> bool {
        self.ability_effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_effect(&mut self, v: u32) {
        self.ability_effect = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &m.socket },
            |m: &mut CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_type",
            |m: &CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &m.strange_type },
            |m: &mut CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &mut m.strange_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_value",
            |m: &CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &m.strange_value },
            |m: &mut CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &mut m.strange_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_effect",
            |m: &CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &m.ability_effect },
            |m: &mut CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY| { &mut m.ability_effect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY>(
            "CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    const NAME: &'static str = "CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.strange_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.strange_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ability_effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strange_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.strange_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ability_effect {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.strange_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.strange_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ability_effect {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.strange_type = ::std::option::Option::None;
        self.strange_value = ::std::option::Option::None;
        self.ability_effect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        static instance: CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY = CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
            socket: ::protobuf::MessageField::none(),
            strange_type: ::std::option::Option::None,
            strange_value: ::std::option::Option::None,
            ability_effect: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_Spectator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Spectator {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Spectator.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Spectator.games_viewed)
    pub games_viewed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Spectator.corporation_id)
    pub corporation_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Spectator.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Spectator.team_id)
    pub team_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_Spectator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Spectator {
    fn default() -> &'a CProtoItemSocket_Spectator {
        <CProtoItemSocket_Spectator as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Spectator {
    pub fn new() -> CProtoItemSocket_Spectator {
        ::std::default::Default::default()
    }

    // optional uint32 games_viewed = 2;

    pub fn games_viewed(&self) -> u32 {
        self.games_viewed.unwrap_or(0)
    }

    pub fn clear_games_viewed(&mut self) {
        self.games_viewed = ::std::option::Option::None;
    }

    pub fn has_games_viewed(&self) -> bool {
        self.games_viewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_viewed(&mut self, v: u32) {
        self.games_viewed = ::std::option::Option::Some(v);
    }

    // optional uint32 corporation_id = 3;

    pub fn corporation_id(&self) -> u32 {
        self.corporation_id.unwrap_or(0)
    }

    pub fn clear_corporation_id(&mut self) {
        self.corporation_id = ::std::option::Option::None;
    }

    pub fn has_corporation_id(&self) -> bool {
        self.corporation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corporation_id(&mut self, v: u32) {
        self.corporation_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 4;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 5;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_Spectator| { &m.socket },
            |m: &mut CProtoItemSocket_Spectator| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "games_viewed",
            |m: &CProtoItemSocket_Spectator| { &m.games_viewed },
            |m: &mut CProtoItemSocket_Spectator| { &mut m.games_viewed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "corporation_id",
            |m: &CProtoItemSocket_Spectator| { &m.corporation_id },
            |m: &mut CProtoItemSocket_Spectator| { &mut m.corporation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CProtoItemSocket_Spectator| { &m.league_id },
            |m: &mut CProtoItemSocket_Spectator| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CProtoItemSocket_Spectator| { &m.team_id },
            |m: &mut CProtoItemSocket_Spectator| { &mut m.team_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_Spectator>(
            "CProtoItemSocket_Spectator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_Spectator {
    const NAME: &'static str = "CProtoItemSocket_Spectator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.games_viewed = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.corporation_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.games_viewed {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.corporation_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.games_viewed {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.corporation_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Spectator {
        CProtoItemSocket_Spectator::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.games_viewed = ::std::option::Option::None;
        self.corporation_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Spectator {
        static instance: CProtoItemSocket_Spectator = CProtoItemSocket_Spectator {
            socket: ::protobuf::MessageField::none(),
            games_viewed: ::std::option::Option::None,
            corporation_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_Spectator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_Spectator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_Spectator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Spectator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_AssetModifier)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_AssetModifier {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_AssetModifier.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_AssetModifier.asset_modifier)
    pub asset_modifier: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_AssetModifier.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_AssetModifier {
    fn default() -> &'a CProtoItemSocket_AssetModifier {
        <CProtoItemSocket_AssetModifier as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_AssetModifier {
    pub fn new() -> CProtoItemSocket_AssetModifier {
        ::std::default::Default::default()
    }

    // optional uint32 asset_modifier = 2;

    pub fn asset_modifier(&self) -> u32 {
        self.asset_modifier.unwrap_or(0)
    }

    pub fn clear_asset_modifier(&mut self) {
        self.asset_modifier = ::std::option::Option::None;
    }

    pub fn has_asset_modifier(&self) -> bool {
        self.asset_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_modifier(&mut self, v: u32) {
        self.asset_modifier = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_AssetModifier| { &m.socket },
            |m: &mut CProtoItemSocket_AssetModifier| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "asset_modifier",
            |m: &CProtoItemSocket_AssetModifier| { &m.asset_modifier },
            |m: &mut CProtoItemSocket_AssetModifier| { &mut m.asset_modifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_AssetModifier>(
            "CProtoItemSocket_AssetModifier",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_AssetModifier {
    const NAME: &'static str = "CProtoItemSocket_AssetModifier";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.asset_modifier = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.asset_modifier {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.asset_modifier {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_AssetModifier {
        CProtoItemSocket_AssetModifier::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.asset_modifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_AssetModifier {
        static instance: CProtoItemSocket_AssetModifier = CProtoItemSocket_AssetModifier {
            socket: ::protobuf::MessageField::none(),
            asset_modifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_AssetModifier {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_AssetModifier").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_AssetModifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_AssetModifier {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.asset_modifier)
    pub asset_modifier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.anim_modifier)
    pub anim_modifier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.ability_effect)
    pub ability_effect: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn default() -> &'a CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        <CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    pub fn new() -> CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        ::std::default::Default::default()
    }

    // optional uint32 asset_modifier = 2;

    pub fn asset_modifier(&self) -> u32 {
        self.asset_modifier.unwrap_or(0)
    }

    pub fn clear_asset_modifier(&mut self) {
        self.asset_modifier = ::std::option::Option::None;
    }

    pub fn has_asset_modifier(&self) -> bool {
        self.asset_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_modifier(&mut self, v: u32) {
        self.asset_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 anim_modifier = 3;

    pub fn anim_modifier(&self) -> u32 {
        self.anim_modifier.unwrap_or(0)
    }

    pub fn clear_anim_modifier(&mut self) {
        self.anim_modifier = ::std::option::Option::None;
    }

    pub fn has_anim_modifier(&self) -> bool {
        self.anim_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anim_modifier(&mut self, v: u32) {
        self.anim_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_effect = 4;

    pub fn ability_effect(&self) -> u32 {
        self.ability_effect.unwrap_or(0)
    }

    pub fn clear_ability_effect(&mut self) {
        self.ability_effect = ::std::option::Option::None;
    }

    pub fn has_ability_effect(&self) -> bool {
        self.ability_effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_effect(&mut self, v: u32) {
        self.ability_effect = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &m.socket },
            |m: &mut CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "asset_modifier",
            |m: &CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &m.asset_modifier },
            |m: &mut CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &mut m.asset_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "anim_modifier",
            |m: &CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &m.anim_modifier },
            |m: &mut CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &mut m.anim_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_effect",
            |m: &CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &m.ability_effect },
            |m: &mut CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY| { &mut m.ability_effect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY>(
            "CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    const NAME: &'static str = "CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.asset_modifier = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.anim_modifier = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ability_effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.asset_modifier {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.anim_modifier {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ability_effect {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.asset_modifier {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.anim_modifier {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ability_effect {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.asset_modifier = ::std::option::Option::None;
        self.anim_modifier = ::std::option::Option::None;
        self.ability_effect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        static instance: CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY = CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
            socket: ::protobuf::MessageField::none(),
            asset_modifier: ::std::option::Option::None,
            anim_modifier: ::std::option::Option::None,
            ability_effect: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_Autograph)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Autograph {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Autograph.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Autograph.autograph)
    pub autograph: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Autograph.autograph_id)
    pub autograph_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_Autograph.autograph_score)
    pub autograph_score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_Autograph.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Autograph {
    fn default() -> &'a CProtoItemSocket_Autograph {
        <CProtoItemSocket_Autograph as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Autograph {
    pub fn new() -> CProtoItemSocket_Autograph {
        ::std::default::Default::default()
    }

    // optional string autograph = 2;

    pub fn autograph(&self) -> &str {
        match self.autograph.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_autograph(&mut self) {
        self.autograph = ::std::option::Option::None;
    }

    pub fn has_autograph(&self) -> bool {
        self.autograph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph(&mut self, v: ::std::string::String) {
        self.autograph = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autograph(&mut self) -> &mut ::std::string::String {
        if self.autograph.is_none() {
            self.autograph = ::std::option::Option::Some(::std::string::String::new());
        }
        self.autograph.as_mut().unwrap()
    }

    // Take field
    pub fn take_autograph(&mut self) -> ::std::string::String {
        self.autograph.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 autograph_id = 3;

    pub fn autograph_id(&self) -> u32 {
        self.autograph_id.unwrap_or(0)
    }

    pub fn clear_autograph_id(&mut self) {
        self.autograph_id = ::std::option::Option::None;
    }

    pub fn has_autograph_id(&self) -> bool {
        self.autograph_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_id(&mut self, v: u32) {
        self.autograph_id = ::std::option::Option::Some(v);
    }

    // optional uint32 autograph_score = 4;

    pub fn autograph_score(&self) -> u32 {
        self.autograph_score.unwrap_or(0)
    }

    pub fn clear_autograph_score(&mut self) {
        self.autograph_score = ::std::option::Option::None;
    }

    pub fn has_autograph_score(&self) -> bool {
        self.autograph_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_score(&mut self, v: u32) {
        self.autograph_score = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_Autograph| { &m.socket },
            |m: &mut CProtoItemSocket_Autograph| { &mut m.socket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autograph",
            |m: &CProtoItemSocket_Autograph| { &m.autograph },
            |m: &mut CProtoItemSocket_Autograph| { &mut m.autograph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autograph_id",
            |m: &CProtoItemSocket_Autograph| { &m.autograph_id },
            |m: &mut CProtoItemSocket_Autograph| { &mut m.autograph_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autograph_score",
            |m: &CProtoItemSocket_Autograph| { &m.autograph_score },
            |m: &mut CProtoItemSocket_Autograph| { &mut m.autograph_score },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_Autograph>(
            "CProtoItemSocket_Autograph",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_Autograph {
    const NAME: &'static str = "CProtoItemSocket_Autograph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                18 => {
                    self.autograph = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.autograph_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.autograph_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.autograph.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.autograph_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.autograph_score {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.autograph.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.autograph_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.autograph_score {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Autograph {
        CProtoItemSocket_Autograph::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.autograph = ::std::option::Option::None;
        self.autograph_id = ::std::option::Option::None;
        self.autograph_score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Autograph {
        static instance: CProtoItemSocket_Autograph = CProtoItemSocket_Autograph {
            socket: ::protobuf::MessageField::none(),
            autograph: ::std::option::Option::None,
            autograph_id: ::std::option::Option::None,
            autograph_score: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_Autograph {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_Autograph").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_Autograph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Autograph {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemSocket_StaticVisuals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_StaticVisuals {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemSocket_StaticVisuals.socket)
    pub socket: ::protobuf::MessageField<CProtoItemSocket>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemSocket_StaticVisuals.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_StaticVisuals {
    fn default() -> &'a CProtoItemSocket_StaticVisuals {
        <CProtoItemSocket_StaticVisuals as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_StaticVisuals {
    pub fn new() -> CProtoItemSocket_StaticVisuals {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CProtoItemSocket>(
            "socket",
            |m: &CProtoItemSocket_StaticVisuals| { &m.socket },
            |m: &mut CProtoItemSocket_StaticVisuals| { &mut m.socket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemSocket_StaticVisuals>(
            "CProtoItemSocket_StaticVisuals",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemSocket_StaticVisuals {
    const NAME: &'static str = "CProtoItemSocket_StaticVisuals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_StaticVisuals {
        CProtoItemSocket_StaticVisuals::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_StaticVisuals {
        static instance: CProtoItemSocket_StaticVisuals = CProtoItemSocket_StaticVisuals {
            socket: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemSocket_StaticVisuals {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemSocket_StaticVisuals").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemSocket_StaticVisuals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_StaticVisuals {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CAttribute_String)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_String {
    // message fields
    // @@protoc_insertion_point(field:dota.CAttribute_String.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CAttribute_String.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_String {
    fn default() -> &'a CAttribute_String {
        <CAttribute_String as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    // optional string value = 1;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CAttribute_String| { &m.value },
            |m: &mut CAttribute_String| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_String>(
            "CAttribute_String",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_String {
    const NAME: &'static str = "CAttribute_String";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_String {
        static instance: CAttribute_String = CAttribute_String {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_String {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_String").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_String {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CWorkshop_GetItemDailyRevenue_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetItemDailyRevenue_Request {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Request.item_id)
    pub item_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Request.date_start)
    pub date_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Request.date_end)
    pub date_end: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_GetItemDailyRevenue_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetItemDailyRevenue_Request {
    fn default() -> &'a CWorkshop_GetItemDailyRevenue_Request {
        <CWorkshop_GetItemDailyRevenue_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetItemDailyRevenue_Request {
    pub fn new() -> CWorkshop_GetItemDailyRevenue_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_id = 2;

    pub fn item_id(&self) -> u32 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 date_start = 3;

    pub fn date_start(&self) -> u32 {
        self.date_start.unwrap_or(0)
    }

    pub fn clear_date_start(&mut self) {
        self.date_start = ::std::option::Option::None;
    }

    pub fn has_date_start(&self) -> bool {
        self.date_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_start(&mut self, v: u32) {
        self.date_start = ::std::option::Option::Some(v);
    }

    // optional uint32 date_end = 4;

    pub fn date_end(&self) -> u32 {
        self.date_end.unwrap_or(0)
    }

    pub fn clear_date_end(&mut self) {
        self.date_end = ::std::option::Option::None;
    }

    pub fn has_date_end(&self) -> bool {
        self.date_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_end(&mut self, v: u32) {
        self.date_end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_GetItemDailyRevenue_Request| { &m.appid },
            |m: &mut CWorkshop_GetItemDailyRevenue_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CWorkshop_GetItemDailyRevenue_Request| { &m.item_id },
            |m: &mut CWorkshop_GetItemDailyRevenue_Request| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date_start",
            |m: &CWorkshop_GetItemDailyRevenue_Request| { &m.date_start },
            |m: &mut CWorkshop_GetItemDailyRevenue_Request| { &mut m.date_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date_end",
            |m: &CWorkshop_GetItemDailyRevenue_Request| { &m.date_end },
            |m: &mut CWorkshop_GetItemDailyRevenue_Request| { &mut m.date_end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetItemDailyRevenue_Request>(
            "CWorkshop_GetItemDailyRevenue_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetItemDailyRevenue_Request {
    const NAME: &'static str = "CWorkshop_GetItemDailyRevenue_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.date_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.date_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.date_start {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.date_end {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date_start {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.date_end {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetItemDailyRevenue_Request {
        CWorkshop_GetItemDailyRevenue_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.date_start = ::std::option::Option::None;
        self.date_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetItemDailyRevenue_Request {
        static instance: CWorkshop_GetItemDailyRevenue_Request = CWorkshop_GetItemDailyRevenue_Request {
            appid: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            date_start: ::std::option::Option::None,
            date_end: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetItemDailyRevenue_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetItemDailyRevenue_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetItemDailyRevenue_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetItemDailyRevenue_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CWorkshop_GetItemDailyRevenue_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetItemDailyRevenue_Response {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Response.country_revenue)
    pub country_revenue: ::std::vec::Vec<cworkshop_get_item_daily_revenue_response::CountryDailyRevenue>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_GetItemDailyRevenue_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetItemDailyRevenue_Response {
    fn default() -> &'a CWorkshop_GetItemDailyRevenue_Response {
        <CWorkshop_GetItemDailyRevenue_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetItemDailyRevenue_Response {
    pub fn new() -> CWorkshop_GetItemDailyRevenue_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "country_revenue",
            |m: &CWorkshop_GetItemDailyRevenue_Response| { &m.country_revenue },
            |m: &mut CWorkshop_GetItemDailyRevenue_Response| { &mut m.country_revenue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetItemDailyRevenue_Response>(
            "CWorkshop_GetItemDailyRevenue_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetItemDailyRevenue_Response {
    const NAME: &'static str = "CWorkshop_GetItemDailyRevenue_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country_revenue.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.country_revenue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.country_revenue {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetItemDailyRevenue_Response {
        CWorkshop_GetItemDailyRevenue_Response::new()
    }

    fn clear(&mut self) {
        self.country_revenue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetItemDailyRevenue_Response {
        static instance: CWorkshop_GetItemDailyRevenue_Response = CWorkshop_GetItemDailyRevenue_Response {
            country_revenue: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetItemDailyRevenue_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetItemDailyRevenue_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetItemDailyRevenue_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetItemDailyRevenue_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_GetItemDailyRevenue_Response`
pub mod cworkshop_get_item_daily_revenue_response {
    // @@protoc_insertion_point(message:dota.CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CountryDailyRevenue {
        // message fields
        // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.country_code)
        pub country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.date)
        pub date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.revenue_usd)
        pub revenue_usd: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:dota.CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.units)
        pub units: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CountryDailyRevenue {
        fn default() -> &'a CountryDailyRevenue {
            <CountryDailyRevenue as ::protobuf::Message>::default_instance()
        }
    }

    impl CountryDailyRevenue {
        pub fn new() -> CountryDailyRevenue {
            ::std::default::Default::default()
        }

        // optional string country_code = 1;

        pub fn country_code(&self) -> &str {
            match self.country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country_code(&mut self) {
            self.country_code = ::std::option::Option::None;
        }

        pub fn has_country_code(&self) -> bool {
            self.country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country_code(&mut self, v: ::std::string::String) {
            self.country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
            if self.country_code.is_none() {
                self.country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_country_code(&mut self) -> ::std::string::String {
            self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 date = 2;

        pub fn date(&self) -> u32 {
            self.date.unwrap_or(0)
        }

        pub fn clear_date(&mut self) {
            self.date = ::std::option::Option::None;
        }

        pub fn has_date(&self) -> bool {
            self.date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_date(&mut self, v: u32) {
            self.date = ::std::option::Option::Some(v);
        }

        // optional int64 revenue_usd = 3;

        pub fn revenue_usd(&self) -> i64 {
            self.revenue_usd.unwrap_or(0)
        }

        pub fn clear_revenue_usd(&mut self) {
            self.revenue_usd = ::std::option::Option::None;
        }

        pub fn has_revenue_usd(&self) -> bool {
            self.revenue_usd.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_usd(&mut self, v: i64) {
            self.revenue_usd = ::std::option::Option::Some(v);
        }

        // optional int32 units = 4;

        pub fn units(&self) -> i32 {
            self.units.unwrap_or(0)
        }

        pub fn clear_units(&mut self) {
            self.units = ::std::option::Option::None;
        }

        pub fn has_units(&self) -> bool {
            self.units.is_some()
        }

        // Param is passed by value, moved
        pub fn set_units(&mut self, v: i32) {
            self.units = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "country_code",
                |m: &CountryDailyRevenue| { &m.country_code },
                |m: &mut CountryDailyRevenue| { &mut m.country_code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "date",
                |m: &CountryDailyRevenue| { &m.date },
                |m: &mut CountryDailyRevenue| { &mut m.date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_usd",
                |m: &CountryDailyRevenue| { &m.revenue_usd },
                |m: &mut CountryDailyRevenue| { &mut m.revenue_usd },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "units",
                |m: &CountryDailyRevenue| { &m.units },
                |m: &mut CountryDailyRevenue| { &mut m.units },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountryDailyRevenue>(
                "CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CountryDailyRevenue {
        const NAME: &'static str = "CountryDailyRevenue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.revenue_usd = ::std::option::Option::Some(is.read_int64()?);
                    },
                    32 => {
                        self.units = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.country_code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.date {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.revenue_usd {
                my_size += ::protobuf::rt::int64_size(3, v);
            }
            if let Some(v) = self.units {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.country_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.date {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.revenue_usd {
                os.write_int64(3, v)?;
            }
            if let Some(v) = self.units {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CountryDailyRevenue {
            CountryDailyRevenue::new()
        }

        fn clear(&mut self) {
            self.country_code = ::std::option::Option::None;
            self.date = ::std::option::Option::None;
            self.revenue_usd = ::std::option::Option::None;
            self.units = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CountryDailyRevenue {
            static instance: CountryDailyRevenue = CountryDailyRevenue {
                country_code: ::std::option::Option::None,
                date: ::std::option::Option::None,
                revenue_usd: ::std::option::Option::None,
                units: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CountryDailyRevenue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CountryDailyRevenue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CountryDailyRevenue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CWorkshop_GetPackageDailyRevenue_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetPackageDailyRevenue_Request {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Request.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Request.date_start)
    pub date_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Request.date_end)
    pub date_end: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_GetPackageDailyRevenue_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetPackageDailyRevenue_Request {
    fn default() -> &'a CWorkshop_GetPackageDailyRevenue_Request {
        <CWorkshop_GetPackageDailyRevenue_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetPackageDailyRevenue_Request {
    pub fn new() -> CWorkshop_GetPackageDailyRevenue_Request {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 date_start = 2;

    pub fn date_start(&self) -> u32 {
        self.date_start.unwrap_or(0)
    }

    pub fn clear_date_start(&mut self) {
        self.date_start = ::std::option::Option::None;
    }

    pub fn has_date_start(&self) -> bool {
        self.date_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_start(&mut self, v: u32) {
        self.date_start = ::std::option::Option::Some(v);
    }

    // optional uint32 date_end = 3;

    pub fn date_end(&self) -> u32 {
        self.date_end.unwrap_or(0)
    }

    pub fn clear_date_end(&mut self) {
        self.date_end = ::std::option::Option::None;
    }

    pub fn has_date_end(&self) -> bool {
        self.date_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_end(&mut self, v: u32) {
        self.date_end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packageid",
            |m: &CWorkshop_GetPackageDailyRevenue_Request| { &m.packageid },
            |m: &mut CWorkshop_GetPackageDailyRevenue_Request| { &mut m.packageid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date_start",
            |m: &CWorkshop_GetPackageDailyRevenue_Request| { &m.date_start },
            |m: &mut CWorkshop_GetPackageDailyRevenue_Request| { &mut m.date_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date_end",
            |m: &CWorkshop_GetPackageDailyRevenue_Request| { &m.date_end },
            |m: &mut CWorkshop_GetPackageDailyRevenue_Request| { &mut m.date_end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetPackageDailyRevenue_Request>(
            "CWorkshop_GetPackageDailyRevenue_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetPackageDailyRevenue_Request {
    const NAME: &'static str = "CWorkshop_GetPackageDailyRevenue_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.date_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.date_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.date_start {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.date_end {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.date_start {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date_end {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetPackageDailyRevenue_Request {
        CWorkshop_GetPackageDailyRevenue_Request::new()
    }

    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.date_start = ::std::option::Option::None;
        self.date_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetPackageDailyRevenue_Request {
        static instance: CWorkshop_GetPackageDailyRevenue_Request = CWorkshop_GetPackageDailyRevenue_Request {
            packageid: ::std::option::Option::None,
            date_start: ::std::option::Option::None,
            date_end: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetPackageDailyRevenue_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetPackageDailyRevenue_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetPackageDailyRevenue_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetPackageDailyRevenue_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CWorkshop_GetPackageDailyRevenue_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetPackageDailyRevenue_Response {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Response.country_revenue)
    pub country_revenue: ::std::vec::Vec<cworkshop_get_package_daily_revenue_response::CountryDailyRevenue>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_GetPackageDailyRevenue_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetPackageDailyRevenue_Response {
    fn default() -> &'a CWorkshop_GetPackageDailyRevenue_Response {
        <CWorkshop_GetPackageDailyRevenue_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetPackageDailyRevenue_Response {
    pub fn new() -> CWorkshop_GetPackageDailyRevenue_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "country_revenue",
            |m: &CWorkshop_GetPackageDailyRevenue_Response| { &m.country_revenue },
            |m: &mut CWorkshop_GetPackageDailyRevenue_Response| { &mut m.country_revenue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetPackageDailyRevenue_Response>(
            "CWorkshop_GetPackageDailyRevenue_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetPackageDailyRevenue_Response {
    const NAME: &'static str = "CWorkshop_GetPackageDailyRevenue_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country_revenue.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.country_revenue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.country_revenue {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetPackageDailyRevenue_Response {
        CWorkshop_GetPackageDailyRevenue_Response::new()
    }

    fn clear(&mut self) {
        self.country_revenue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetPackageDailyRevenue_Response {
        static instance: CWorkshop_GetPackageDailyRevenue_Response = CWorkshop_GetPackageDailyRevenue_Response {
            country_revenue: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetPackageDailyRevenue_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetPackageDailyRevenue_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetPackageDailyRevenue_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetPackageDailyRevenue_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_GetPackageDailyRevenue_Response`
pub mod cworkshop_get_package_daily_revenue_response {
    // @@protoc_insertion_point(message:dota.CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CountryDailyRevenue {
        // message fields
        // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.country_code)
        pub country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.date)
        pub date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.revenue_usd)
        pub revenue_usd: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:dota.CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.units)
        pub units: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CountryDailyRevenue {
        fn default() -> &'a CountryDailyRevenue {
            <CountryDailyRevenue as ::protobuf::Message>::default_instance()
        }
    }

    impl CountryDailyRevenue {
        pub fn new() -> CountryDailyRevenue {
            ::std::default::Default::default()
        }

        // optional string country_code = 1;

        pub fn country_code(&self) -> &str {
            match self.country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country_code(&mut self) {
            self.country_code = ::std::option::Option::None;
        }

        pub fn has_country_code(&self) -> bool {
            self.country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country_code(&mut self, v: ::std::string::String) {
            self.country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
            if self.country_code.is_none() {
                self.country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_country_code(&mut self) -> ::std::string::String {
            self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 date = 2;

        pub fn date(&self) -> u32 {
            self.date.unwrap_or(0)
        }

        pub fn clear_date(&mut self) {
            self.date = ::std::option::Option::None;
        }

        pub fn has_date(&self) -> bool {
            self.date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_date(&mut self, v: u32) {
            self.date = ::std::option::Option::Some(v);
        }

        // optional int64 revenue_usd = 3;

        pub fn revenue_usd(&self) -> i64 {
            self.revenue_usd.unwrap_or(0)
        }

        pub fn clear_revenue_usd(&mut self) {
            self.revenue_usd = ::std::option::Option::None;
        }

        pub fn has_revenue_usd(&self) -> bool {
            self.revenue_usd.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_usd(&mut self, v: i64) {
            self.revenue_usd = ::std::option::Option::Some(v);
        }

        // optional int32 units = 4;

        pub fn units(&self) -> i32 {
            self.units.unwrap_or(0)
        }

        pub fn clear_units(&mut self) {
            self.units = ::std::option::Option::None;
        }

        pub fn has_units(&self) -> bool {
            self.units.is_some()
        }

        // Param is passed by value, moved
        pub fn set_units(&mut self, v: i32) {
            self.units = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "country_code",
                |m: &CountryDailyRevenue| { &m.country_code },
                |m: &mut CountryDailyRevenue| { &mut m.country_code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "date",
                |m: &CountryDailyRevenue| { &m.date },
                |m: &mut CountryDailyRevenue| { &mut m.date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_usd",
                |m: &CountryDailyRevenue| { &m.revenue_usd },
                |m: &mut CountryDailyRevenue| { &mut m.revenue_usd },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "units",
                |m: &CountryDailyRevenue| { &m.units },
                |m: &mut CountryDailyRevenue| { &mut m.units },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountryDailyRevenue>(
                "CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CountryDailyRevenue {
        const NAME: &'static str = "CountryDailyRevenue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.revenue_usd = ::std::option::Option::Some(is.read_int64()?);
                    },
                    32 => {
                        self.units = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.country_code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.date {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.revenue_usd {
                my_size += ::protobuf::rt::int64_size(3, v);
            }
            if let Some(v) = self.units {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.country_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.date {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.revenue_usd {
                os.write_int64(3, v)?;
            }
            if let Some(v) = self.units {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CountryDailyRevenue {
            CountryDailyRevenue::new()
        }

        fn clear(&mut self) {
            self.country_code = ::std::option::Option::None;
            self.date = ::std::option::Option::None;
            self.revenue_usd = ::std::option::Option::None;
            self.units = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CountryDailyRevenue {
            static instance: CountryDailyRevenue = CountryDailyRevenue {
                country_code: ::std::option::Option::None,
                date: ::std::option::Option::None,
                revenue_usd: ::std::option::Option::None,
                units: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CountryDailyRevenue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CountryDailyRevenue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CountryDailyRevenue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSQLGCToGCGrantBackpackSlots)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSQLGCToGCGrantBackpackSlots {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSQLGCToGCGrantBackpackSlots.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSQLGCToGCGrantBackpackSlots.add_slots)
    pub add_slots: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSQLGCToGCGrantBackpackSlots.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSQLGCToGCGrantBackpackSlots {
    fn default() -> &'a CMsgSQLGCToGCGrantBackpackSlots {
        <CMsgSQLGCToGCGrantBackpackSlots as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSQLGCToGCGrantBackpackSlots {
    pub fn new() -> CMsgSQLGCToGCGrantBackpackSlots {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 add_slots = 2;

    pub fn add_slots(&self) -> u32 {
        self.add_slots.unwrap_or(0)
    }

    pub fn clear_add_slots(&mut self) {
        self.add_slots = ::std::option::Option::None;
    }

    pub fn has_add_slots(&self) -> bool {
        self.add_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_slots(&mut self, v: u32) {
        self.add_slots = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgSQLGCToGCGrantBackpackSlots| { &m.account_id },
            |m: &mut CMsgSQLGCToGCGrantBackpackSlots| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_slots",
            |m: &CMsgSQLGCToGCGrantBackpackSlots| { &m.add_slots },
            |m: &mut CMsgSQLGCToGCGrantBackpackSlots| { &mut m.add_slots },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSQLGCToGCGrantBackpackSlots>(
            "CMsgSQLGCToGCGrantBackpackSlots",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSQLGCToGCGrantBackpackSlots {
    const NAME: &'static str = "CMsgSQLGCToGCGrantBackpackSlots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.add_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.add_slots {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.add_slots {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSQLGCToGCGrantBackpackSlots {
        CMsgSQLGCToGCGrantBackpackSlots::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.add_slots = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSQLGCToGCGrantBackpackSlots {
        static instance: CMsgSQLGCToGCGrantBackpackSlots = CMsgSQLGCToGCGrantBackpackSlots {
            account_id: ::std::option::Option::None,
            add_slots: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSQLGCToGCGrantBackpackSlots {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSQLGCToGCGrantBackpackSlots").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSQLGCToGCGrantBackpackSlots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSQLGCToGCGrantBackpackSlots {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCLookupAccountName)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLookupAccountName {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCLookupAccountName.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCLookupAccountName.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLookupAccountName {
    fn default() -> &'a CMsgClientToGCLookupAccountName {
        <CMsgClientToGCLookupAccountName as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLookupAccountName {
    pub fn new() -> CMsgClientToGCLookupAccountName {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgClientToGCLookupAccountName| { &m.account_id },
            |m: &mut CMsgClientToGCLookupAccountName| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCLookupAccountName>(
            "CMsgClientToGCLookupAccountName",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCLookupAccountName {
    const NAME: &'static str = "CMsgClientToGCLookupAccountName";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLookupAccountName {
        CMsgClientToGCLookupAccountName::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLookupAccountName {
        static instance: CMsgClientToGCLookupAccountName = CMsgClientToGCLookupAccountName {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCLookupAccountName {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCLookupAccountName").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCLookupAccountName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLookupAccountName {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCLookupAccountNameResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLookupAccountNameResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCLookupAccountNameResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCLookupAccountNameResponse.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCLookupAccountNameResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLookupAccountNameResponse {
    fn default() -> &'a CMsgClientToGCLookupAccountNameResponse {
        <CMsgClientToGCLookupAccountNameResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLookupAccountNameResponse {
    pub fn new() -> CMsgClientToGCLookupAccountNameResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string account_name = 2;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgClientToGCLookupAccountNameResponse| { &m.account_id },
            |m: &mut CMsgClientToGCLookupAccountNameResponse| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name",
            |m: &CMsgClientToGCLookupAccountNameResponse| { &m.account_name },
            |m: &mut CMsgClientToGCLookupAccountNameResponse| { &mut m.account_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCLookupAccountNameResponse>(
            "CMsgClientToGCLookupAccountNameResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCLookupAccountNameResponse {
    const NAME: &'static str = "CMsgClientToGCLookupAccountNameResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLookupAccountNameResponse {
        CMsgClientToGCLookupAccountNameResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.account_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLookupAccountNameResponse {
        static instance: CMsgClientToGCLookupAccountNameResponse = CMsgClientToGCLookupAccountNameResponse {
            account_id: ::std::option::Option::None,
            account_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCLookupAccountNameResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCLookupAccountNameResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCLookupAccountNameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLookupAccountNameResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCreateStaticRecipe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateStaticRecipe {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipe.items)
    pub items: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe::Item>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipe.recipe_def_index)
    pub recipe_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateStaticRecipe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateStaticRecipe {
    fn default() -> &'a CMsgClientToGCCreateStaticRecipe {
        <CMsgClientToGCCreateStaticRecipe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateStaticRecipe {
    pub fn new() -> CMsgClientToGCCreateStaticRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 recipe_def_index = 2;

    pub fn recipe_def_index(&self) -> u32 {
        self.recipe_def_index.unwrap_or(0)
    }

    pub fn clear_recipe_def_index(&mut self) {
        self.recipe_def_index = ::std::option::Option::None;
    }

    pub fn has_recipe_def_index(&self) -> bool {
        self.recipe_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipe_def_index(&mut self, v: u32) {
        self.recipe_def_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgClientToGCCreateStaticRecipe| { &m.items },
            |m: &mut CMsgClientToGCCreateStaticRecipe| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipe_def_index",
            |m: &CMsgClientToGCCreateStaticRecipe| { &m.recipe_def_index },
            |m: &mut CMsgClientToGCCreateStaticRecipe| { &mut m.recipe_def_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCreateStaticRecipe>(
            "CMsgClientToGCCreateStaticRecipe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipe {
    const NAME: &'static str = "CMsgClientToGCCreateStaticRecipe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                16 => {
                    self.recipe_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.recipe_def_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.recipe_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateStaticRecipe {
        CMsgClientToGCCreateStaticRecipe::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.recipe_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipe {
        static instance: CMsgClientToGCCreateStaticRecipe = CMsgClientToGCCreateStaticRecipe {
            items: ::std::vec::Vec::new(),
            recipe_def_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCreateStaticRecipe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateStaticRecipe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCreateStaticRecipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCreateStaticRecipe`
pub mod cmsg_client_to_gccreate_static_recipe {
    // @@protoc_insertion_point(message:dota.CMsgClientToGCCreateStaticRecipe.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipe.Item.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipe.Item.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateStaticRecipe.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 slot_id = 2;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &Item| { &m.item_id },
                |m: &mut Item| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &Item| { &m.slot_id },
                |m: &mut Item| { &mut m.slot_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                "CMsgClientToGCCreateStaticRecipe.Item",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.slot_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.slot_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_id: ::std::option::Option::None,
                slot_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Item {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateStaticRecipe.Item").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Item {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCreateStaticRecipeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateStaticRecipeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccreate_static_recipe_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.output_items)
    pub output_items: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe_response::OutputItem>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.input_errors)
    pub input_errors: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe_response::InputError>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.additional_outputs)
    pub additional_outputs: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe_response::AdditionalOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateStaticRecipeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateStaticRecipeResponse {
    fn default() -> &'a CMsgClientToGCCreateStaticRecipeResponse {
        <CMsgClientToGCCreateStaticRecipeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateStaticRecipeResponse {
    pub fn new() -> CMsgClientToGCCreateStaticRecipeResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccreate_static_recipe_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccreate_static_recipe_response::EResponse::eResponse_Success),
            None => cmsg_client_to_gccreate_static_recipe_response::EResponse::eResponse_Success,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccreate_static_recipe_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCreateStaticRecipeResponse| { &m.response },
            |m: &mut CMsgClientToGCCreateStaticRecipeResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_items",
            |m: &CMsgClientToGCCreateStaticRecipeResponse| { &m.output_items },
            |m: &mut CMsgClientToGCCreateStaticRecipeResponse| { &mut m.output_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_errors",
            |m: &CMsgClientToGCCreateStaticRecipeResponse| { &m.input_errors },
            |m: &mut CMsgClientToGCCreateStaticRecipeResponse| { &mut m.input_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_outputs",
            |m: &CMsgClientToGCCreateStaticRecipeResponse| { &m.additional_outputs },
            |m: &mut CMsgClientToGCCreateStaticRecipeResponse| { &mut m.additional_outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCreateStaticRecipeResponse>(
            "CMsgClientToGCCreateStaticRecipeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipeResponse {
    const NAME: &'static str = "CMsgClientToGCCreateStaticRecipeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.output_items.push(is.read_message()?);
                },
                26 => {
                    self.input_errors.push(is.read_message()?);
                },
                34 => {
                    self.additional_outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.output_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.input_errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.additional_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.output_items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.input_errors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.additional_outputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateStaticRecipeResponse {
        CMsgClientToGCCreateStaticRecipeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.output_items.clear();
        self.input_errors.clear();
        self.additional_outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipeResponse {
        static instance: CMsgClientToGCCreateStaticRecipeResponse = CMsgClientToGCCreateStaticRecipeResponse {
            response: ::std::option::Option::None,
            output_items: ::std::vec::Vec::new(),
            input_errors: ::std::vec::Vec::new(),
            additional_outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCreateStaticRecipeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateStaticRecipeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCreateStaticRecipeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCreateStaticRecipeResponse`
pub mod cmsg_client_to_gccreate_static_recipe_response {
    // @@protoc_insertion_point(message:dota.CMsgClientToGCCreateStaticRecipeResponse.OutputItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OutputItem {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.OutputItem.def_index)
        pub def_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.OutputItem.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.OutputItem.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateStaticRecipeResponse.OutputItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OutputItem {
        fn default() -> &'a OutputItem {
            <OutputItem as ::protobuf::Message>::default_instance()
        }
    }

    impl OutputItem {
        pub fn new() -> OutputItem {
            ::std::default::Default::default()
        }

        // optional uint32 def_index = 1;

        pub fn def_index(&self) -> u32 {
            self.def_index.unwrap_or(0)
        }

        pub fn clear_def_index(&mut self) {
            self.def_index = ::std::option::Option::None;
        }

        pub fn has_def_index(&self) -> bool {
            self.def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_def_index(&mut self, v: u32) {
            self.def_index = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 2;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 slot_id = 3;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "def_index",
                |m: &OutputItem| { &m.def_index },
                |m: &mut OutputItem| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &OutputItem| { &m.item_id },
                |m: &mut OutputItem| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &OutputItem| { &m.slot_id },
                |m: &mut OutputItem| { &mut m.slot_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutputItem>(
                "CMsgClientToGCCreateStaticRecipeResponse.OutputItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OutputItem {
        const NAME: &'static str = "OutputItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.def_index {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.def_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.slot_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OutputItem {
            OutputItem::new()
        }

        fn clear(&mut self) {
            self.def_index = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.slot_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OutputItem {
            static instance: OutputItem = OutputItem {
                def_index: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                slot_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OutputItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateStaticRecipeResponse.OutputItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OutputItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OutputItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgClientToGCCreateStaticRecipeResponse.InputError)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InputError {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.InputError.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.InputError.error)
        pub error: ::std::option::Option<::protobuf::EnumOrUnknown<EResponse>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateStaticRecipeResponse.InputError.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InputError {
        fn default() -> &'a InputError {
            <InputError as ::protobuf::Message>::default_instance()
        }
    }

    impl InputError {
        pub fn new() -> InputError {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional .dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse error = 2;

        pub fn error(&self) -> EResponse {
            match self.error {
                Some(e) => e.enum_value_or(EResponse::eResponse_Success),
                None => EResponse::eResponse_Success,
            }
        }

        pub fn clear_error(&mut self) {
            self.error = ::std::option::Option::None;
        }

        pub fn has_error(&self) -> bool {
            self.error.is_some()
        }

        // Param is passed by value, moved
        pub fn set_error(&mut self, v: EResponse) {
            self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &InputError| { &m.slot_id },
                |m: &mut InputError| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "error",
                |m: &InputError| { &m.error },
                |m: &mut InputError| { &mut m.error },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputError>(
                "CMsgClientToGCCreateStaticRecipeResponse.InputError",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InputError {
        const NAME: &'static str = "InputError";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.error {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.error {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InputError {
            InputError::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.error = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InputError {
            static instance: InputError = InputError {
                slot_id: ::std::option::Option::None,
                error: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InputError {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateStaticRecipeResponse.InputError").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InputError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InputError {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalOutput {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput.value)
        pub value: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalOutput {
        fn default() -> &'a AdditionalOutput {
            <AdditionalOutput as ::protobuf::Message>::default_instance()
        }
    }

    impl AdditionalOutput {
        pub fn new() -> AdditionalOutput {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional uint64 value = 2;

        pub fn value(&self) -> u64 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u64) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &AdditionalOutput| { &m.slot_id },
                |m: &mut AdditionalOutput| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &AdditionalOutput| { &m.value },
                |m: &mut AdditionalOutput| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalOutput>(
                "CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AdditionalOutput {
        const NAME: &'static str = "AdditionalOutput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalOutput {
            AdditionalOutput::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalOutput {
            static instance: AdditionalOutput = AdditionalOutput {
                slot_id: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AdditionalOutput {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdditionalOutput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AdditionalOutput {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_Success)
        eResponse_Success = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_OfferingDisabled)
        eResponse_OfferingDisabled = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_InvalidItems)
        eResponse_InvalidItems = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_InternalError)
        eResponse_InternalError = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_MissingLeague)
        eResponse_MissingLeague = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_MissingEvent)
        eResponse_MissingEvent = 5,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::eResponse_Success),
                1 => ::std::option::Option::Some(EResponse::eResponse_OfferingDisabled),
                2 => ::std::option::Option::Some(EResponse::eResponse_InvalidItems),
                3 => ::std::option::Option::Some(EResponse::eResponse_InternalError),
                4 => ::std::option::Option::Some(EResponse::eResponse_MissingLeague),
                5 => ::std::option::Option::Some(EResponse::eResponse_MissingEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "eResponse_Success" => ::std::option::Option::Some(EResponse::eResponse_Success),
                "eResponse_OfferingDisabled" => ::std::option::Option::Some(EResponse::eResponse_OfferingDisabled),
                "eResponse_InvalidItems" => ::std::option::Option::Some(EResponse::eResponse_InvalidItems),
                "eResponse_InternalError" => ::std::option::Option::Some(EResponse::eResponse_InternalError),
                "eResponse_MissingLeague" => ::std::option::Option::Some(EResponse::eResponse_MissingLeague),
                "eResponse_MissingEvent" => ::std::option::Option::Some(EResponse::eResponse_MissingEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::eResponse_Success,
            EResponse::eResponse_OfferingDisabled,
            EResponse::eResponse_InvalidItems,
            EResponse::eResponse_InternalError,
            EResponse::eResponse_MissingLeague,
            EResponse::eResponse_MissingEvent,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCreateStaticRecipeResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::eResponse_Success
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCreateStaticRecipeResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgProcessTransactionOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProcessTransactionOrder {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.steam_txn_id)
    pub steam_txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.partner_txn_id)
    pub partner_txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.time_stamp)
    pub time_stamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.watermark)
    pub watermark: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.purchase_report_status)
    pub purchase_report_status: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.items)
    pub items: ::std::vec::Vec<cmsg_process_transaction_order::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgProcessTransactionOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProcessTransactionOrder {
    fn default() -> &'a CMsgProcessTransactionOrder {
        <CMsgProcessTransactionOrder as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessTransactionOrder {
    pub fn new() -> CMsgProcessTransactionOrder {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    // optional uint64 steam_txn_id = 2;

    pub fn steam_txn_id(&self) -> u64 {
        self.steam_txn_id.unwrap_or(0)
    }

    pub fn clear_steam_txn_id(&mut self) {
        self.steam_txn_id = ::std::option::Option::None;
    }

    pub fn has_steam_txn_id(&self) -> bool {
        self.steam_txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_txn_id(&mut self, v: u64) {
        self.steam_txn_id = ::std::option::Option::Some(v);
    }

    // optional uint64 partner_txn_id = 3;

    pub fn partner_txn_id(&self) -> u64 {
        self.partner_txn_id.unwrap_or(0)
    }

    pub fn clear_partner_txn_id(&mut self) {
        self.partner_txn_id = ::std::option::Option::None;
    }

    pub fn has_partner_txn_id(&self) -> bool {
        self.partner_txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_txn_id(&mut self, v: u64) {
        self.partner_txn_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id = 4;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_stamp = 5;

    pub fn time_stamp(&self) -> u32 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u32) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional uint64 watermark = 6;

    pub fn watermark(&self) -> u64 {
        self.watermark.unwrap_or(0)
    }

    pub fn clear_watermark(&mut self) {
        self.watermark = ::std::option::Option::None;
    }

    pub fn has_watermark(&self) -> bool {
        self.watermark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watermark(&mut self, v: u64) {
        self.watermark = ::std::option::Option::Some(v);
    }

    // optional int32 purchase_report_status = 7;

    pub fn purchase_report_status(&self) -> i32 {
        self.purchase_report_status.unwrap_or(0)
    }

    pub fn clear_purchase_report_status(&mut self) {
        self.purchase_report_status = ::std::option::Option::None;
    }

    pub fn has_purchase_report_status(&self) -> bool {
        self.purchase_report_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_report_status(&mut self, v: i32) {
        self.purchase_report_status = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 8;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgProcessTransactionOrder| { &m.txn_id },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.txn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_txn_id",
            |m: &CMsgProcessTransactionOrder| { &m.steam_txn_id },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.steam_txn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partner_txn_id",
            |m: &CMsgProcessTransactionOrder| { &m.partner_txn_id },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.partner_txn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgProcessTransactionOrder| { &m.steam_id },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_stamp",
            |m: &CMsgProcessTransactionOrder| { &m.time_stamp },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.time_stamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watermark",
            |m: &CMsgProcessTransactionOrder| { &m.watermark },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.watermark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_report_status",
            |m: &CMsgProcessTransactionOrder| { &m.purchase_report_status },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.purchase_report_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgProcessTransactionOrder| { &m.currency },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgProcessTransactionOrder| { &m.items },
            |m: &mut CMsgProcessTransactionOrder| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProcessTransactionOrder>(
            "CMsgProcessTransactionOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgProcessTransactionOrder {
    const NAME: &'static str = "CMsgProcessTransactionOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.steam_txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.partner_txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.time_stamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.watermark = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.purchase_report_status = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steam_txn_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.partner_txn_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.watermark {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.purchase_report_status {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steam_txn_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.partner_txn_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.watermark {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.purchase_report_status {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(8, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProcessTransactionOrder {
        CMsgProcessTransactionOrder::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.steam_txn_id = ::std::option::Option::None;
        self.partner_txn_id = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.time_stamp = ::std::option::Option::None;
        self.watermark = ::std::option::Option::None;
        self.purchase_report_status = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProcessTransactionOrder {
        static instance: CMsgProcessTransactionOrder = CMsgProcessTransactionOrder {
            txn_id: ::std::option::Option::None,
            steam_txn_id: ::std::option::Option::None,
            partner_txn_id: ::std::option::Option::None,
            steam_id: ::std::option::Option::None,
            time_stamp: ::std::option::Option::None,
            watermark: ::std::option::Option::None,
            purchase_report_status: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgProcessTransactionOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProcessTransactionOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProcessTransactionOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessTransactionOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgProcessTransactionOrder`
pub mod cmsg_process_transaction_order {
    // @@protoc_insertion_point(message:dota.CMsgProcessTransactionOrder.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.item_def_index)
        pub item_def_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.item_price)
        pub item_price: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.quantity)
        pub quantity: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.category_desc)
        pub category_desc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.store_purchase_type)
        pub store_purchase_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.source_reference_id)
        pub source_reference_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.parent_stack_index)
        pub parent_stack_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.default_price)
        pub default_price: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgProcessTransactionOrder.Item.is_user_facing)
        pub is_user_facing: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgProcessTransactionOrder.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint32 item_def_index = 1;

        pub fn item_def_index(&self) -> u32 {
            self.item_def_index.unwrap_or(0)
        }

        pub fn clear_item_def_index(&mut self) {
            self.item_def_index = ::std::option::Option::None;
        }

        pub fn has_item_def_index(&self) -> bool {
            self.item_def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def_index(&mut self, v: u32) {
            self.item_def_index = ::std::option::Option::Some(v);
        }

        // optional uint32 item_price = 2;

        pub fn item_price(&self) -> u32 {
            self.item_price.unwrap_or(0)
        }

        pub fn clear_item_price(&mut self) {
            self.item_price = ::std::option::Option::None;
        }

        pub fn has_item_price(&self) -> bool {
            self.item_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_price(&mut self, v: u32) {
            self.item_price = ::std::option::Option::Some(v);
        }

        // optional uint32 quantity = 3;

        pub fn quantity(&self) -> u32 {
            self.quantity.unwrap_or(0)
        }

        pub fn clear_quantity(&mut self) {
            self.quantity = ::std::option::Option::None;
        }

        pub fn has_quantity(&self) -> bool {
            self.quantity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quantity(&mut self, v: u32) {
            self.quantity = ::std::option::Option::Some(v);
        }

        // optional string category_desc = 4;

        pub fn category_desc(&self) -> &str {
            match self.category_desc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category_desc(&mut self) {
            self.category_desc = ::std::option::Option::None;
        }

        pub fn has_category_desc(&self) -> bool {
            self.category_desc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category_desc(&mut self, v: ::std::string::String) {
            self.category_desc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category_desc(&mut self) -> &mut ::std::string::String {
            if self.category_desc.is_none() {
                self.category_desc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.category_desc.as_mut().unwrap()
        }

        // Take field
        pub fn take_category_desc(&mut self) -> ::std::string::String {
            self.category_desc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 store_purchase_type = 5;

        pub fn store_purchase_type(&self) -> u32 {
            self.store_purchase_type.unwrap_or(0)
        }

        pub fn clear_store_purchase_type(&mut self) {
            self.store_purchase_type = ::std::option::Option::None;
        }

        pub fn has_store_purchase_type(&self) -> bool {
            self.store_purchase_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_store_purchase_type(&mut self, v: u32) {
            self.store_purchase_type = ::std::option::Option::Some(v);
        }

        // optional uint64 source_reference_id = 6;

        pub fn source_reference_id(&self) -> u64 {
            self.source_reference_id.unwrap_or(0)
        }

        pub fn clear_source_reference_id(&mut self) {
            self.source_reference_id = ::std::option::Option::None;
        }

        pub fn has_source_reference_id(&self) -> bool {
            self.source_reference_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_reference_id(&mut self, v: u64) {
            self.source_reference_id = ::std::option::Option::Some(v);
        }

        // optional int32 parent_stack_index = 7;

        pub fn parent_stack_index(&self) -> i32 {
            self.parent_stack_index.unwrap_or(0)
        }

        pub fn clear_parent_stack_index(&mut self) {
            self.parent_stack_index = ::std::option::Option::None;
        }

        pub fn has_parent_stack_index(&self) -> bool {
            self.parent_stack_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_stack_index(&mut self, v: i32) {
            self.parent_stack_index = ::std::option::Option::Some(v);
        }

        // optional bool default_price = 8;

        pub fn default_price(&self) -> bool {
            self.default_price.unwrap_or(false)
        }

        pub fn clear_default_price(&mut self) {
            self.default_price = ::std::option::Option::None;
        }

        pub fn has_default_price(&self) -> bool {
            self.default_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_price(&mut self, v: bool) {
            self.default_price = ::std::option::Option::Some(v);
        }

        // optional bool is_user_facing = 9;

        pub fn is_user_facing(&self) -> bool {
            self.is_user_facing.unwrap_or(false)
        }

        pub fn clear_is_user_facing(&mut self) {
            self.is_user_facing = ::std::option::Option::None;
        }

        pub fn has_is_user_facing(&self) -> bool {
            self.is_user_facing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_user_facing(&mut self, v: bool) {
            self.is_user_facing = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_def_index",
                |m: &Item| { &m.item_def_index },
                |m: &mut Item| { &mut m.item_def_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_price",
                |m: &Item| { &m.item_price },
                |m: &mut Item| { &mut m.item_price },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quantity",
                |m: &Item| { &m.quantity },
                |m: &mut Item| { &mut m.quantity },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "category_desc",
                |m: &Item| { &m.category_desc },
                |m: &mut Item| { &mut m.category_desc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "store_purchase_type",
                |m: &Item| { &m.store_purchase_type },
                |m: &mut Item| { &mut m.store_purchase_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_reference_id",
                |m: &Item| { &m.source_reference_id },
                |m: &mut Item| { &mut m.source_reference_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "parent_stack_index",
                |m: &Item| { &m.parent_stack_index },
                |m: &mut Item| { &mut m.parent_stack_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default_price",
                |m: &Item| { &m.default_price },
                |m: &mut Item| { &mut m.default_price },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_user_facing",
                |m: &Item| { &m.is_user_facing },
                |m: &mut Item| { &mut m.is_user_facing },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                "CMsgProcessTransactionOrder.Item",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_price = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.category_desc = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.store_purchase_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.source_reference_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.parent_stack_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.default_price = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.is_user_facing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def_index {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_price {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.quantity {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.category_desc.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.store_purchase_type {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.source_reference_id {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.parent_stack_index {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.default_price {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_user_facing {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_def_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_price {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.quantity {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.category_desc.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.store_purchase_type {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.source_reference_id {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.parent_stack_index {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.default_price {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.is_user_facing {
                os.write_bool(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_def_index = ::std::option::Option::None;
            self.item_price = ::std::option::Option::None;
            self.quantity = ::std::option::Option::None;
            self.category_desc = ::std::option::Option::None;
            self.store_purchase_type = ::std::option::Option::None;
            self.source_reference_id = ::std::option::Option::None;
            self.parent_stack_index = ::std::option::Option::None;
            self.default_price = ::std::option::Option::None;
            self.is_user_facing = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_def_index: ::std::option::Option::None,
                item_price: ::std::option::Option::None,
                quantity: ::std::option::Option::None,
                category_desc: ::std::option::Option::None,
                store_purchase_type: ::std::option::Option::None,
                source_reference_id: ::std::option::Option::None,
                parent_stack_index: ::std::option::Option::None,
                default_price: ::std::option::Option::None,
                is_user_facing: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Item {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgProcessTransactionOrder.Item").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Item {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCStoreProcessCDKeyTransaction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessCDKeyTransaction {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCStoreProcessCDKeyTransaction.order)
    pub order: ::protobuf::MessageField<CMsgProcessTransactionOrder>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCStoreProcessCDKeyTransaction.reason_code)
    pub reason_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCStoreProcessCDKeyTransaction.partner)
    pub partner: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCStoreProcessCDKeyTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessCDKeyTransaction {
    fn default() -> &'a CMsgGCToGCStoreProcessCDKeyTransaction {
        <CMsgGCToGCStoreProcessCDKeyTransaction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessCDKeyTransaction {
    pub fn new() -> CMsgGCToGCStoreProcessCDKeyTransaction {
        ::std::default::Default::default()
    }

    // optional uint32 reason_code = 2;

    pub fn reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }

    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }

    // optional uint32 partner = 3;

    pub fn partner(&self) -> u32 {
        self.partner.unwrap_or(0)
    }

    pub fn clear_partner(&mut self) {
        self.partner = ::std::option::Option::None;
    }

    pub fn has_partner(&self) -> bool {
        self.partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner(&mut self, v: u32) {
        self.partner = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProcessTransactionOrder>(
            "order",
            |m: &CMsgGCToGCStoreProcessCDKeyTransaction| { &m.order },
            |m: &mut CMsgGCToGCStoreProcessCDKeyTransaction| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason_code",
            |m: &CMsgGCToGCStoreProcessCDKeyTransaction| { &m.reason_code },
            |m: &mut CMsgGCToGCStoreProcessCDKeyTransaction| { &mut m.reason_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partner",
            |m: &CMsgGCToGCStoreProcessCDKeyTransaction| { &m.partner },
            |m: &mut CMsgGCToGCStoreProcessCDKeyTransaction| { &mut m.partner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCStoreProcessCDKeyTransaction>(
            "CMsgGCToGCStoreProcessCDKeyTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessCDKeyTransaction {
    const NAME: &'static str = "CMsgGCToGCStoreProcessCDKeyTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.order)?;
                },
                16 => {
                    self.reason_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.partner = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason_code {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.partner {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.partner {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessCDKeyTransaction {
        CMsgGCToGCStoreProcessCDKeyTransaction::new()
    }

    fn clear(&mut self) {
        self.order.clear();
        self.reason_code = ::std::option::Option::None;
        self.partner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessCDKeyTransaction {
        static instance: CMsgGCToGCStoreProcessCDKeyTransaction = CMsgGCToGCStoreProcessCDKeyTransaction {
            order: ::protobuf::MessageField::none(),
            reason_code: ::std::option::Option::None,
            partner: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCStoreProcessCDKeyTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessCDKeyTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCStoreProcessCDKeyTransactionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCStoreProcessCDKeyTransactionResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCStoreProcessCDKeyTransactionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn default() -> &'a CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        <CMsgGCToGCStoreProcessCDKeyTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    pub fn new() -> CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCToGCStoreProcessCDKeyTransactionResponse| { &m.success },
            |m: &mut CMsgGCToGCStoreProcessCDKeyTransactionResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCStoreProcessCDKeyTransactionResponse>(
            "CMsgGCToGCStoreProcessCDKeyTransactionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    const NAME: &'static str = "CMsgGCToGCStoreProcessCDKeyTransactionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        CMsgGCToGCStoreProcessCDKeyTransactionResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        static instance: CMsgGCToGCStoreProcessCDKeyTransactionResponse = CMsgGCToGCStoreProcessCDKeyTransactionResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCStoreProcessCDKeyTransactionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCStoreProcessSettlement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessSettlement {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCStoreProcessSettlement.order)
    pub order: ::protobuf::MessageField<CMsgProcessTransactionOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCStoreProcessSettlement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessSettlement {
    fn default() -> &'a CMsgGCToGCStoreProcessSettlement {
        <CMsgGCToGCStoreProcessSettlement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessSettlement {
    pub fn new() -> CMsgGCToGCStoreProcessSettlement {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgProcessTransactionOrder>(
            "order",
            |m: &CMsgGCToGCStoreProcessSettlement| { &m.order },
            |m: &mut CMsgGCToGCStoreProcessSettlement| { &mut m.order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCStoreProcessSettlement>(
            "CMsgGCToGCStoreProcessSettlement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessSettlement {
    const NAME: &'static str = "CMsgGCToGCStoreProcessSettlement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.order)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessSettlement {
        CMsgGCToGCStoreProcessSettlement::new()
    }

    fn clear(&mut self) {
        self.order.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessSettlement {
        static instance: CMsgGCToGCStoreProcessSettlement = CMsgGCToGCStoreProcessSettlement {
            order: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCStoreProcessSettlement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCStoreProcessSettlement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCStoreProcessSettlement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessSettlement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCStoreProcessSettlementResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessSettlementResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCStoreProcessSettlementResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCStoreProcessSettlementResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessSettlementResponse {
    fn default() -> &'a CMsgGCToGCStoreProcessSettlementResponse {
        <CMsgGCToGCStoreProcessSettlementResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessSettlementResponse {
    pub fn new() -> CMsgGCToGCStoreProcessSettlementResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCToGCStoreProcessSettlementResponse| { &m.success },
            |m: &mut CMsgGCToGCStoreProcessSettlementResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCStoreProcessSettlementResponse>(
            "CMsgGCToGCStoreProcessSettlementResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessSettlementResponse {
    const NAME: &'static str = "CMsgGCToGCStoreProcessSettlementResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessSettlementResponse {
        CMsgGCToGCStoreProcessSettlementResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessSettlementResponse {
        static instance: CMsgGCToGCStoreProcessSettlementResponse = CMsgGCToGCStoreProcessSettlementResponse {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCStoreProcessSettlementResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCStoreProcessSettlementResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCStoreProcessSettlementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessSettlementResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCBroadcastConsoleCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBroadcastConsoleCommand {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastConsoleCommand.con_command)
    pub con_command: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastConsoleCommand.report_output)
    pub report_output: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastConsoleCommand.sending_gc)
    pub sending_gc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastConsoleCommand.output_initiator)
    pub output_initiator: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCBroadcastConsoleCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBroadcastConsoleCommand {
    fn default() -> &'a CMsgGCToGCBroadcastConsoleCommand {
        <CMsgGCToGCBroadcastConsoleCommand as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBroadcastConsoleCommand {
    pub fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        ::std::default::Default::default()
    }

    // optional string con_command = 1;

    pub fn con_command(&self) -> &str {
        match self.con_command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_con_command(&mut self) {
        self.con_command = ::std::option::Option::None;
    }

    pub fn has_con_command(&self) -> bool {
        self.con_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_con_command(&mut self, v: ::std::string::String) {
        self.con_command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_con_command(&mut self) -> &mut ::std::string::String {
        if self.con_command.is_none() {
            self.con_command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.con_command.as_mut().unwrap()
    }

    // Take field
    pub fn take_con_command(&mut self) -> ::std::string::String {
        self.con_command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool report_output = 2;

    pub fn report_output(&self) -> bool {
        self.report_output.unwrap_or(false)
    }

    pub fn clear_report_output(&mut self) {
        self.report_output = ::std::option::Option::None;
    }

    pub fn has_report_output(&self) -> bool {
        self.report_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_output(&mut self, v: bool) {
        self.report_output = ::std::option::Option::Some(v);
    }

    // optional int32 sending_gc = 3;

    pub fn sending_gc(&self) -> i32 {
        self.sending_gc.unwrap_or(0)
    }

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: i32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    // optional string output_initiator = 4;

    pub fn output_initiator(&self) -> &str {
        match self.output_initiator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_output_initiator(&mut self) {
        self.output_initiator = ::std::option::Option::None;
    }

    pub fn has_output_initiator(&self) -> bool {
        self.output_initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_initiator(&mut self, v: ::std::string::String) {
        self.output_initiator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_initiator(&mut self) -> &mut ::std::string::String {
        if self.output_initiator.is_none() {
            self.output_initiator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.output_initiator.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_initiator(&mut self) -> ::std::string::String {
        self.output_initiator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "con_command",
            |m: &CMsgGCToGCBroadcastConsoleCommand| { &m.con_command },
            |m: &mut CMsgGCToGCBroadcastConsoleCommand| { &mut m.con_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "report_output",
            |m: &CMsgGCToGCBroadcastConsoleCommand| { &m.report_output },
            |m: &mut CMsgGCToGCBroadcastConsoleCommand| { &mut m.report_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sending_gc",
            |m: &CMsgGCToGCBroadcastConsoleCommand| { &m.sending_gc },
            |m: &mut CMsgGCToGCBroadcastConsoleCommand| { &mut m.sending_gc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "output_initiator",
            |m: &CMsgGCToGCBroadcastConsoleCommand| { &m.output_initiator },
            |m: &mut CMsgGCToGCBroadcastConsoleCommand| { &mut m.output_initiator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCBroadcastConsoleCommand>(
            "CMsgGCToGCBroadcastConsoleCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCBroadcastConsoleCommand {
    const NAME: &'static str = "CMsgGCToGCBroadcastConsoleCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.con_command = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.report_output = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.sending_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.output_initiator = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.con_command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.report_output {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sending_gc {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.output_initiator.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.con_command.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.report_output {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.sending_gc {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.output_initiator.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        CMsgGCToGCBroadcastConsoleCommand::new()
    }

    fn clear(&mut self) {
        self.con_command = ::std::option::Option::None;
        self.report_output = ::std::option::Option::None;
        self.sending_gc = ::std::option::Option::None;
        self.output_initiator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBroadcastConsoleCommand {
        static instance: CMsgGCToGCBroadcastConsoleCommand = CMsgGCToGCBroadcastConsoleCommand {
            con_command: ::std::option::Option::None,
            report_output: ::std::option::Option::None,
            sending_gc: ::std::option::Option::None,
            output_initiator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCBroadcastConsoleCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCBroadcastConsoleCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCBroadcastConsoleCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBroadcastConsoleCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCConsoleOutput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCConsoleOutput {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCConsoleOutput.initiator)
    pub initiator: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCConsoleOutput.sending_gc)
    pub sending_gc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCConsoleOutput.msgs)
    pub msgs: ::std::vec::Vec<cmsg_gcto_gcconsole_output::OutputLine>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCConsoleOutput.is_last_for_source_job)
    pub is_last_for_source_job: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCConsoleOutput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCConsoleOutput {
    fn default() -> &'a CMsgGCToGCConsoleOutput {
        <CMsgGCToGCConsoleOutput as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCConsoleOutput {
    pub fn new() -> CMsgGCToGCConsoleOutput {
        ::std::default::Default::default()
    }

    // optional string initiator = 1;

    pub fn initiator(&self) -> &str {
        match self.initiator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initiator(&mut self) {
        self.initiator = ::std::option::Option::None;
    }

    pub fn has_initiator(&self) -> bool {
        self.initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: ::std::string::String) {
        self.initiator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiator(&mut self) -> &mut ::std::string::String {
        if self.initiator.is_none() {
            self.initiator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initiator.as_mut().unwrap()
    }

    // Take field
    pub fn take_initiator(&mut self) -> ::std::string::String {
        self.initiator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 sending_gc = 2;

    pub fn sending_gc(&self) -> i32 {
        self.sending_gc.unwrap_or(0)
    }

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: i32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    // optional bool is_last_for_source_job = 4;

    pub fn is_last_for_source_job(&self) -> bool {
        self.is_last_for_source_job.unwrap_or(false)
    }

    pub fn clear_is_last_for_source_job(&mut self) {
        self.is_last_for_source_job = ::std::option::Option::None;
    }

    pub fn has_is_last_for_source_job(&self) -> bool {
        self.is_last_for_source_job.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_last_for_source_job(&mut self, v: bool) {
        self.is_last_for_source_job = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator",
            |m: &CMsgGCToGCConsoleOutput| { &m.initiator },
            |m: &mut CMsgGCToGCConsoleOutput| { &mut m.initiator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sending_gc",
            |m: &CMsgGCToGCConsoleOutput| { &m.sending_gc },
            |m: &mut CMsgGCToGCConsoleOutput| { &mut m.sending_gc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "msgs",
            |m: &CMsgGCToGCConsoleOutput| { &m.msgs },
            |m: &mut CMsgGCToGCConsoleOutput| { &mut m.msgs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_last_for_source_job",
            |m: &CMsgGCToGCConsoleOutput| { &m.is_last_for_source_job },
            |m: &mut CMsgGCToGCConsoleOutput| { &mut m.is_last_for_source_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCConsoleOutput>(
            "CMsgGCToGCConsoleOutput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCConsoleOutput {
    const NAME: &'static str = "CMsgGCToGCConsoleOutput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.initiator = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.sending_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.msgs.push(is.read_message()?);
                },
                32 => {
                    self.is_last_for_source_job = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sending_gc {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_last_for_source_job {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.initiator.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sending_gc {
            os.write_int32(2, v)?;
        }
        for v in &self.msgs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.is_last_for_source_job {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCConsoleOutput {
        CMsgGCToGCConsoleOutput::new()
    }

    fn clear(&mut self) {
        self.initiator = ::std::option::Option::None;
        self.sending_gc = ::std::option::Option::None;
        self.msgs.clear();
        self.is_last_for_source_job = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCConsoleOutput {
        static instance: CMsgGCToGCConsoleOutput = CMsgGCToGCConsoleOutput {
            initiator: ::std::option::Option::None,
            sending_gc: ::std::option::Option::None,
            msgs: ::std::vec::Vec::new(),
            is_last_for_source_job: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCConsoleOutput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCConsoleOutput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCConsoleOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCConsoleOutput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToGCConsoleOutput`
pub mod cmsg_gcto_gcconsole_output {
    // @@protoc_insertion_point(message:dota.CMsgGCToGCConsoleOutput.OutputLine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OutputLine {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToGCConsoleOutput.OutputLine.text)
        pub text: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCConsoleOutput.OutputLine.spew_level)
        pub spew_level: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToGCConsoleOutput.OutputLine.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OutputLine {
        fn default() -> &'a OutputLine {
            <OutputLine as ::protobuf::Message>::default_instance()
        }
    }

    impl OutputLine {
        pub fn new() -> OutputLine {
            ::std::default::Default::default()
        }

        // optional string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 spew_level = 2;

        pub fn spew_level(&self) -> u32 {
            self.spew_level.unwrap_or(0)
        }

        pub fn clear_spew_level(&mut self) {
            self.spew_level = ::std::option::Option::None;
        }

        pub fn has_spew_level(&self) -> bool {
            self.spew_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spew_level(&mut self, v: u32) {
            self.spew_level = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &OutputLine| { &m.text },
                |m: &mut OutputLine| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "spew_level",
                |m: &OutputLine| { &m.spew_level },
                |m: &mut OutputLine| { &mut m.spew_level },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutputLine>(
                "CMsgGCToGCConsoleOutput.OutputLine",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OutputLine {
        const NAME: &'static str = "OutputLine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.spew_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.spew_level {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.spew_level {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OutputLine {
            OutputLine::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.spew_level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OutputLine {
            static instance: OutputLine = OutputLine {
                text: ::std::option::Option::None,
                spew_level: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OutputLine {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToGCConsoleOutput.OutputLine").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OutputLine {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OutputLine {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgItemAges)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemAges {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgItemAges.max_item_id_timestamps)
    pub max_item_id_timestamps: ::std::vec::Vec<cmsg_item_ages::MaxItemIDTimestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgItemAges.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAges {
    fn default() -> &'a CMsgItemAges {
        <CMsgItemAges as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAges {
    pub fn new() -> CMsgItemAges {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_item_id_timestamps",
            |m: &CMsgItemAges| { &m.max_item_id_timestamps },
            |m: &mut CMsgItemAges| { &mut m.max_item_id_timestamps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemAges>(
            "CMsgItemAges",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemAges {
    const NAME: &'static str = "CMsgItemAges";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.max_item_id_timestamps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.max_item_id_timestamps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.max_item_id_timestamps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAges {
        CMsgItemAges::new()
    }

    fn clear(&mut self) {
        self.max_item_id_timestamps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAges {
        static instance: CMsgItemAges = CMsgItemAges {
            max_item_id_timestamps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemAges {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemAges").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemAges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAges {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgItemAges`
pub mod cmsg_item_ages {
    // @@protoc_insertion_point(message:dota.CMsgItemAges.MaxItemIDTimestamp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MaxItemIDTimestamp {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgItemAges.MaxItemIDTimestamp.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgItemAges.MaxItemIDTimestamp.max_item_id)
        pub max_item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgItemAges.MaxItemIDTimestamp.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MaxItemIDTimestamp {
        fn default() -> &'a MaxItemIDTimestamp {
            <MaxItemIDTimestamp as ::protobuf::Message>::default_instance()
        }
    }

    impl MaxItemIDTimestamp {
        pub fn new() -> MaxItemIDTimestamp {
            ::std::default::Default::default()
        }

        // optional uint32 timestamp = 1;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint64 max_item_id = 2;

        pub fn max_item_id(&self) -> u64 {
            self.max_item_id.unwrap_or(0)
        }

        pub fn clear_max_item_id(&mut self) {
            self.max_item_id = ::std::option::Option::None;
        }

        pub fn has_max_item_id(&self) -> bool {
            self.max_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_item_id(&mut self, v: u64) {
            self.max_item_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &MaxItemIDTimestamp| { &m.timestamp },
                |m: &mut MaxItemIDTimestamp| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_item_id",
                |m: &MaxItemIDTimestamp| { &m.max_item_id },
                |m: &mut MaxItemIDTimestamp| { &mut m.max_item_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MaxItemIDTimestamp>(
                "CMsgItemAges.MaxItemIDTimestamp",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MaxItemIDTimestamp {
        const NAME: &'static str = "MaxItemIDTimestamp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.max_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.max_item_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.max_item_id {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MaxItemIDTimestamp {
            MaxItemIDTimestamp::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.max_item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MaxItemIDTimestamp {
            static instance: MaxItemIDTimestamp = MaxItemIDTimestamp {
                timestamp: ::std::option::Option::None,
                max_item_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MaxItemIDTimestamp {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgItemAges.MaxItemIDTimestamp").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MaxItemIDTimestamp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MaxItemIDTimestamp {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCInternalTestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCInternalTestMsg {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCInternalTestMsg.sending_gc)
    pub sending_gc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCInternalTestMsg.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCInternalTestMsg.context)
    pub context: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCInternalTestMsg.message_id)
    pub message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCInternalTestMsg.message_body)
    pub message_body: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCInternalTestMsg.job_id_source)
    pub job_id_source: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCInternalTestMsg.job_id_target)
    pub job_id_target: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCInternalTestMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCInternalTestMsg {
    fn default() -> &'a CMsgGCToGCInternalTestMsg {
        <CMsgGCToGCInternalTestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCInternalTestMsg {
    pub fn new() -> CMsgGCToGCInternalTestMsg {
        ::std::default::Default::default()
    }

    // optional int32 sending_gc = 1;

    pub fn sending_gc(&self) -> i32 {
        self.sending_gc.unwrap_or(0)
    }

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: i32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional uint32 context = 3;

    pub fn context(&self) -> u32 {
        self.context.unwrap_or(0)
    }

    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: u32) {
        self.context = ::std::option::Option::Some(v);
    }

    // optional uint32 message_id = 4;

    pub fn message_id(&self) -> u32 {
        self.message_id.unwrap_or(0)
    }

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }

    // optional bytes message_body = 5;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 job_id_source = 6;

    pub fn job_id_source(&self) -> u64 {
        self.job_id_source.unwrap_or(0)
    }

    pub fn clear_job_id_source(&mut self) {
        self.job_id_source = ::std::option::Option::None;
    }

    pub fn has_job_id_source(&self) -> bool {
        self.job_id_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id_source(&mut self, v: u64) {
        self.job_id_source = ::std::option::Option::Some(v);
    }

    // optional fixed64 job_id_target = 7;

    pub fn job_id_target(&self) -> u64 {
        self.job_id_target.unwrap_or(0)
    }

    pub fn clear_job_id_target(&mut self) {
        self.job_id_target = ::std::option::Option::None;
    }

    pub fn has_job_id_target(&self) -> bool {
        self.job_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id_target(&mut self, v: u64) {
        self.job_id_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sending_gc",
            |m: &CMsgGCToGCInternalTestMsg| { &m.sending_gc },
            |m: &mut CMsgGCToGCInternalTestMsg| { &mut m.sending_gc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &CMsgGCToGCInternalTestMsg| { &m.sender_id },
            |m: &mut CMsgGCToGCInternalTestMsg| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context",
            |m: &CMsgGCToGCInternalTestMsg| { &m.context },
            |m: &mut CMsgGCToGCInternalTestMsg| { &mut m.context },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_id",
            |m: &CMsgGCToGCInternalTestMsg| { &m.message_id },
            |m: &mut CMsgGCToGCInternalTestMsg| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_body",
            |m: &CMsgGCToGCInternalTestMsg| { &m.message_body },
            |m: &mut CMsgGCToGCInternalTestMsg| { &mut m.message_body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "job_id_source",
            |m: &CMsgGCToGCInternalTestMsg| { &m.job_id_source },
            |m: &mut CMsgGCToGCInternalTestMsg| { &mut m.job_id_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "job_id_target",
            |m: &CMsgGCToGCInternalTestMsg| { &m.job_id_target },
            |m: &mut CMsgGCToGCInternalTestMsg| { &mut m.job_id_target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCInternalTestMsg>(
            "CMsgGCToGCInternalTestMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCInternalTestMsg {
    const NAME: &'static str = "CMsgGCToGCInternalTestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sending_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.context = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.message_body = ::std::option::Option::Some(is.read_bytes()?);
                },
                49 => {
                    self.job_id_source = ::std::option::Option::Some(is.read_fixed64()?);
                },
                57 => {
                    self.job_id_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sending_gc {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.context {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.message_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.job_id_source {
            my_size += 1 + 8;
        }
        if let Some(v) = self.job_id_target {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sending_gc {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.context {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.message_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.job_id_source {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.job_id_target {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCInternalTestMsg {
        CMsgGCToGCInternalTestMsg::new()
    }

    fn clear(&mut self) {
        self.sending_gc = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.message_id = ::std::option::Option::None;
        self.message_body = ::std::option::Option::None;
        self.job_id_source = ::std::option::Option::None;
        self.job_id_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCInternalTestMsg {
        static instance: CMsgGCToGCInternalTestMsg = CMsgGCToGCInternalTestMsg {
            sending_gc: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            context: ::std::option::Option::None,
            message_id: ::std::option::Option::None,
            message_body: ::std::option::Option::None,
            job_id_source: ::std::option::Option::None,
            job_id_target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCInternalTestMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCInternalTestMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCInternalTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCInternalTestMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCClientServerVersionsUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCClientServerVersionsUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCClientServerVersionsUpdated.client_min_allowed_version)
    pub client_min_allowed_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCClientServerVersionsUpdated.client_active_version)
    pub client_active_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCClientServerVersionsUpdated.server_active_version)
    pub server_active_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCClientServerVersionsUpdated.server_deployed_version)
    pub server_deployed_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCClientServerVersionsUpdated.what_changed)
    pub what_changed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCClientServerVersionsUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCClientServerVersionsUpdated {
    fn default() -> &'a CMsgGCToGCClientServerVersionsUpdated {
        <CMsgGCToGCClientServerVersionsUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCClientServerVersionsUpdated {
    pub fn new() -> CMsgGCToGCClientServerVersionsUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 client_min_allowed_version = 1;

    pub fn client_min_allowed_version(&self) -> u32 {
        self.client_min_allowed_version.unwrap_or(0)
    }

    pub fn clear_client_min_allowed_version(&mut self) {
        self.client_min_allowed_version = ::std::option::Option::None;
    }

    pub fn has_client_min_allowed_version(&self) -> bool {
        self.client_min_allowed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_min_allowed_version(&mut self, v: u32) {
        self.client_min_allowed_version = ::std::option::Option::Some(v);
    }

    // optional uint32 client_active_version = 2;

    pub fn client_active_version(&self) -> u32 {
        self.client_active_version.unwrap_or(0)
    }

    pub fn clear_client_active_version(&mut self) {
        self.client_active_version = ::std::option::Option::None;
    }

    pub fn has_client_active_version(&self) -> bool {
        self.client_active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_active_version(&mut self, v: u32) {
        self.client_active_version = ::std::option::Option::Some(v);
    }

    // optional uint32 server_active_version = 3;

    pub fn server_active_version(&self) -> u32 {
        self.server_active_version.unwrap_or(0)
    }

    pub fn clear_server_active_version(&mut self) {
        self.server_active_version = ::std::option::Option::None;
    }

    pub fn has_server_active_version(&self) -> bool {
        self.server_active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_active_version(&mut self, v: u32) {
        self.server_active_version = ::std::option::Option::Some(v);
    }

    // optional uint32 server_deployed_version = 4;

    pub fn server_deployed_version(&self) -> u32 {
        self.server_deployed_version.unwrap_or(0)
    }

    pub fn clear_server_deployed_version(&mut self) {
        self.server_deployed_version = ::std::option::Option::None;
    }

    pub fn has_server_deployed_version(&self) -> bool {
        self.server_deployed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_deployed_version(&mut self, v: u32) {
        self.server_deployed_version = ::std::option::Option::Some(v);
    }

    // optional uint32 what_changed = 5;

    pub fn what_changed(&self) -> u32 {
        self.what_changed.unwrap_or(0)
    }

    pub fn clear_what_changed(&mut self) {
        self.what_changed = ::std::option::Option::None;
    }

    pub fn has_what_changed(&self) -> bool {
        self.what_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_what_changed(&mut self, v: u32) {
        self.what_changed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_min_allowed_version",
            |m: &CMsgGCToGCClientServerVersionsUpdated| { &m.client_min_allowed_version },
            |m: &mut CMsgGCToGCClientServerVersionsUpdated| { &mut m.client_min_allowed_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_active_version",
            |m: &CMsgGCToGCClientServerVersionsUpdated| { &m.client_active_version },
            |m: &mut CMsgGCToGCClientServerVersionsUpdated| { &mut m.client_active_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_active_version",
            |m: &CMsgGCToGCClientServerVersionsUpdated| { &m.server_active_version },
            |m: &mut CMsgGCToGCClientServerVersionsUpdated| { &mut m.server_active_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_deployed_version",
            |m: &CMsgGCToGCClientServerVersionsUpdated| { &m.server_deployed_version },
            |m: &mut CMsgGCToGCClientServerVersionsUpdated| { &mut m.server_deployed_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "what_changed",
            |m: &CMsgGCToGCClientServerVersionsUpdated| { &m.what_changed },
            |m: &mut CMsgGCToGCClientServerVersionsUpdated| { &mut m.what_changed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCClientServerVersionsUpdated>(
            "CMsgGCToGCClientServerVersionsUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCClientServerVersionsUpdated {
    const NAME: &'static str = "CMsgGCToGCClientServerVersionsUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_min_allowed_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.client_active_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.server_active_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.server_deployed_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.what_changed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_min_allowed_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_active_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.server_active_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_deployed_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.what_changed {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_min_allowed_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_active_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_active_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_deployed_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.what_changed {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCClientServerVersionsUpdated {
        CMsgGCToGCClientServerVersionsUpdated::new()
    }

    fn clear(&mut self) {
        self.client_min_allowed_version = ::std::option::Option::None;
        self.client_active_version = ::std::option::Option::None;
        self.server_active_version = ::std::option::Option::None;
        self.server_deployed_version = ::std::option::Option::None;
        self.what_changed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCClientServerVersionsUpdated {
        static instance: CMsgGCToGCClientServerVersionsUpdated = CMsgGCToGCClientServerVersionsUpdated {
            client_min_allowed_version: ::std::option::Option::None,
            client_active_version: ::std::option::Option::None,
            server_active_version: ::std::option::Option::None,
            server_deployed_version: ::std::option::Option::None,
            what_changed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCClientServerVersionsUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCClientServerVersionsUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCClientServerVersionsUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCClientServerVersionsUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCBroadcastMessageFromSub)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBroadcastMessageFromSub {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastMessageFromSub.msg_id)
    pub msg_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastMessageFromSub.serialized_msg)
    pub serialized_msg: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastMessageFromSub.account_id_list)
    pub account_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBroadcastMessageFromSub.steam_id_list)
    pub steam_id_list: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCBroadcastMessageFromSub.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBroadcastMessageFromSub {
    fn default() -> &'a CMsgGCToGCBroadcastMessageFromSub {
        <CMsgGCToGCBroadcastMessageFromSub as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBroadcastMessageFromSub {
    pub fn new() -> CMsgGCToGCBroadcastMessageFromSub {
        ::std::default::Default::default()
    }

    // optional uint32 msg_id = 1;

    pub fn msg_id(&self) -> u32 {
        self.msg_id.unwrap_or(0)
    }

    pub fn clear_msg_id(&mut self) {
        self.msg_id = ::std::option::Option::None;
    }

    pub fn has_msg_id(&self) -> bool {
        self.msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_id(&mut self, v: u32) {
        self.msg_id = ::std::option::Option::Some(v);
    }

    // optional bytes serialized_msg = 2;

    pub fn serialized_msg(&self) -> &[u8] {
        match self.serialized_msg.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_msg(&mut self) {
        self.serialized_msg = ::std::option::Option::None;
    }

    pub fn has_serialized_msg(&self) -> bool {
        self.serialized_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_msg.is_none() {
            self.serialized_msg = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_msg(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_msg.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_id",
            |m: &CMsgGCToGCBroadcastMessageFromSub| { &m.msg_id },
            |m: &mut CMsgGCToGCBroadcastMessageFromSub| { &mut m.msg_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_msg",
            |m: &CMsgGCToGCBroadcastMessageFromSub| { &m.serialized_msg },
            |m: &mut CMsgGCToGCBroadcastMessageFromSub| { &mut m.serialized_msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_id_list",
            |m: &CMsgGCToGCBroadcastMessageFromSub| { &m.account_id_list },
            |m: &mut CMsgGCToGCBroadcastMessageFromSub| { &mut m.account_id_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steam_id_list",
            |m: &CMsgGCToGCBroadcastMessageFromSub| { &m.steam_id_list },
            |m: &mut CMsgGCToGCBroadcastMessageFromSub| { &mut m.steam_id_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCBroadcastMessageFromSub>(
            "CMsgGCToGCBroadcastMessageFromSub",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCBroadcastMessageFromSub {
    const NAME: &'static str = "CMsgGCToGCBroadcastMessageFromSub";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.serialized_msg = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_id_list)?;
                },
                24 => {
                    self.account_id_list.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_id_list)?;
                },
                33 => {
                    self.steam_id_list.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.serialized_msg.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.account_id_list {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += 9 * self.steam_id_list.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.serialized_msg.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.account_id_list {
            os.write_uint32(3, *v)?;
        };
        for v in &self.steam_id_list {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBroadcastMessageFromSub {
        CMsgGCToGCBroadcastMessageFromSub::new()
    }

    fn clear(&mut self) {
        self.msg_id = ::std::option::Option::None;
        self.serialized_msg = ::std::option::Option::None;
        self.account_id_list.clear();
        self.steam_id_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBroadcastMessageFromSub {
        static instance: CMsgGCToGCBroadcastMessageFromSub = CMsgGCToGCBroadcastMessageFromSub {
            msg_id: ::std::option::Option::None,
            serialized_msg: ::std::option::Option::None,
            account_id_list: ::std::vec::Vec::new(),
            steam_id_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCBroadcastMessageFromSub {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCBroadcastMessageFromSub").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCBroadcastMessageFromSub {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBroadcastMessageFromSub {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientCurrencyPricePoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCurrencyPricePoints {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientCurrencyPricePoints.price_key)
    pub price_key: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientCurrencyPricePoints.currencies)
    pub currencies: ::std::vec::Vec<cmsg_gcto_client_currency_price_points::Currency>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientCurrencyPricePoints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCurrencyPricePoints {
    fn default() -> &'a CMsgGCToClientCurrencyPricePoints {
        <CMsgGCToClientCurrencyPricePoints as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCurrencyPricePoints {
    pub fn new() -> CMsgGCToClientCurrencyPricePoints {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "price_key",
            |m: &CMsgGCToClientCurrencyPricePoints| { &m.price_key },
            |m: &mut CMsgGCToClientCurrencyPricePoints| { &mut m.price_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "currencies",
            |m: &CMsgGCToClientCurrencyPricePoints| { &m.currencies },
            |m: &mut CMsgGCToClientCurrencyPricePoints| { &mut m.currencies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientCurrencyPricePoints>(
            "CMsgGCToClientCurrencyPricePoints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientCurrencyPricePoints {
    const NAME: &'static str = "CMsgGCToClientCurrencyPricePoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.price_key)?;
                },
                8 => {
                    self.price_key.push(is.read_uint64()?);
                },
                18 => {
                    self.currencies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.price_key {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        for value in &self.currencies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.price_key {
            os.write_uint64(1, *v)?;
        };
        for v in &self.currencies {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCurrencyPricePoints {
        CMsgGCToClientCurrencyPricePoints::new()
    }

    fn clear(&mut self) {
        self.price_key.clear();
        self.currencies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCurrencyPricePoints {
        static instance: CMsgGCToClientCurrencyPricePoints = CMsgGCToClientCurrencyPricePoints {
            price_key: ::std::vec::Vec::new(),
            currencies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientCurrencyPricePoints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientCurrencyPricePoints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientCurrencyPricePoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientCurrencyPricePoints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToClientCurrencyPricePoints`
pub mod cmsg_gcto_client_currency_price_points {
    // @@protoc_insertion_point(message:dota.CMsgGCToClientCurrencyPricePoints.Currency)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Currency {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToClientCurrencyPricePoints.Currency.currency_id)
        pub currency_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToClientCurrencyPricePoints.Currency.currency_price)
        pub currency_price: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToClientCurrencyPricePoints.Currency.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Currency {
        fn default() -> &'a Currency {
            <Currency as ::protobuf::Message>::default_instance()
        }
    }

    impl Currency {
        pub fn new() -> Currency {
            ::std::default::Default::default()
        }

        // optional uint32 currency_id = 1;

        pub fn currency_id(&self) -> u32 {
            self.currency_id.unwrap_or(0)
        }

        pub fn clear_currency_id(&mut self) {
            self.currency_id = ::std::option::Option::None;
        }

        pub fn has_currency_id(&self) -> bool {
            self.currency_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_currency_id(&mut self, v: u32) {
            self.currency_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "currency_id",
                |m: &Currency| { &m.currency_id },
                |m: &mut Currency| { &mut m.currency_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "currency_price",
                |m: &Currency| { &m.currency_price },
                |m: &mut Currency| { &mut m.currency_price },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Currency>(
                "CMsgGCToClientCurrencyPricePoints.Currency",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Currency {
        const NAME: &'static str = "Currency";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.currency_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint64_into(&mut self.currency_price)?;
                    },
                    16 => {
                        self.currency_price.push(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.currency_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.currency_price {
                my_size += ::protobuf::rt::uint64_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.currency_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.currency_price {
                os.write_uint64(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Currency {
            Currency::new()
        }

        fn clear(&mut self) {
            self.currency_id = ::std::option::Option::None;
            self.currency_price.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Currency {
            static instance: Currency = Currency {
                currency_id: ::std::option::Option::None,
                currency_price: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Currency {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToClientCurrencyPricePoints.Currency").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Currency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Currency {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgBannedWordList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBannedWordList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBannedWordList.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBannedWordList.banned_words)
    pub banned_words: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBannedWordList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBannedWordList {
    fn default() -> &'a CMsgBannedWordList {
        <CMsgBannedWordList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBannedWordList {
    pub fn new() -> CMsgBannedWordList {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgBannedWordList| { &m.version },
            |m: &mut CMsgBannedWordList| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "banned_words",
            |m: &CMsgBannedWordList| { &m.banned_words },
            |m: &mut CMsgBannedWordList| { &mut m.banned_words },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBannedWordList>(
            "CMsgBannedWordList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBannedWordList {
    const NAME: &'static str = "CMsgBannedWordList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.banned_words.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.banned_words {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.banned_words {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBannedWordList {
        CMsgBannedWordList::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.banned_words.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBannedWordList {
        static instance: CMsgBannedWordList = CMsgBannedWordList {
            version: ::std::option::Option::None,
            banned_words: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBannedWordList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBannedWordList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBannedWordList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBannedWordList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCFlushSteamInventoryCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCFlushSteamInventoryCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCFlushSteamInventoryCache.keys)
    pub keys: ::std::vec::Vec<cmsg_gcto_gcflush_steam_inventory_cache::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCFlushSteamInventoryCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCFlushSteamInventoryCache {
    fn default() -> &'a CMsgGCToGCFlushSteamInventoryCache {
        <CMsgGCToGCFlushSteamInventoryCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCFlushSteamInventoryCache {
    pub fn new() -> CMsgGCToGCFlushSteamInventoryCache {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &CMsgGCToGCFlushSteamInventoryCache| { &m.keys },
            |m: &mut CMsgGCToGCFlushSteamInventoryCache| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCFlushSteamInventoryCache>(
            "CMsgGCToGCFlushSteamInventoryCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCFlushSteamInventoryCache {
    const NAME: &'static str = "CMsgGCToGCFlushSteamInventoryCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCFlushSteamInventoryCache {
        CMsgGCToGCFlushSteamInventoryCache::new()
    }

    fn clear(&mut self) {
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCFlushSteamInventoryCache {
        static instance: CMsgGCToGCFlushSteamInventoryCache = CMsgGCToGCFlushSteamInventoryCache {
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCFlushSteamInventoryCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCFlushSteamInventoryCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCFlushSteamInventoryCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCFlushSteamInventoryCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToGCFlushSteamInventoryCache`
pub mod cmsg_gcto_gcflush_steam_inventory_cache {
    // @@protoc_insertion_point(message:dota.CMsgGCToGCFlushSteamInventoryCache.Key)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToGCFlushSteamInventoryCache.Key.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCFlushSteamInventoryCache.Key.contextid)
        pub contextid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToGCFlushSteamInventoryCache.Key.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key {
        fn default() -> &'a Key {
            <Key as ::protobuf::Message>::default_instance()
        }
    }

    impl Key {
        pub fn new() -> Key {
            ::std::default::Default::default()
        }

        // optional uint64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint64 contextid = 2;

        pub fn contextid(&self) -> u64 {
            self.contextid.unwrap_or(0)
        }

        pub fn clear_contextid(&mut self) {
            self.contextid = ::std::option::Option::None;
        }

        pub fn has_contextid(&self) -> bool {
            self.contextid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contextid(&mut self, v: u64) {
            self.contextid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &Key| { &m.steamid },
                |m: &mut Key| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "contextid",
                |m: &Key| { &m.contextid },
                |m: &mut Key| { &mut m.contextid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key>(
                "CMsgGCToGCFlushSteamInventoryCache.Key",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key {
        const NAME: &'static str = "Key";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.contextid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.contextid {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.contextid {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key {
            Key::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.contextid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key {
            static instance: Key = Key {
                steamid: ::std::option::Option::None,
                contextid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToGCFlushSteamInventoryCache.Key").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCUpdateSubscriptionItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateSubscriptionItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateSubscriptionItems.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateSubscriptionItems.always_notify)
    pub always_notify: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCUpdateSubscriptionItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSubscriptionItems {
    fn default() -> &'a CMsgGCToGCUpdateSubscriptionItems {
        <CMsgGCToGCUpdateSubscriptionItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSubscriptionItems {
    pub fn new() -> CMsgGCToGCUpdateSubscriptionItems {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool always_notify = 2;

    pub fn always_notify(&self) -> bool {
        self.always_notify.unwrap_or(false)
    }

    pub fn clear_always_notify(&mut self) {
        self.always_notify = ::std::option::Option::None;
    }

    pub fn has_always_notify(&self) -> bool {
        self.always_notify.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_notify(&mut self, v: bool) {
        self.always_notify = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCUpdateSubscriptionItems| { &m.account_id },
            |m: &mut CMsgGCToGCUpdateSubscriptionItems| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "always_notify",
            |m: &CMsgGCToGCUpdateSubscriptionItems| { &m.always_notify },
            |m: &mut CMsgGCToGCUpdateSubscriptionItems| { &mut m.always_notify },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCUpdateSubscriptionItems>(
            "CMsgGCToGCUpdateSubscriptionItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCUpdateSubscriptionItems {
    const NAME: &'static str = "CMsgGCToGCUpdateSubscriptionItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.always_notify = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.always_notify {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.always_notify {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateSubscriptionItems {
        CMsgGCToGCUpdateSubscriptionItems::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.always_notify = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSubscriptionItems {
        static instance: CMsgGCToGCUpdateSubscriptionItems = CMsgGCToGCUpdateSubscriptionItems {
            account_id: ::std::option::Option::None,
            always_notify: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCUpdateSubscriptionItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCUpdateSubscriptionItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCUpdateSubscriptionItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUpdateSubscriptionItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCSelfPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSelfPing {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSelfPing.sample_id)
    pub sample_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCSelfPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSelfPing {
    fn default() -> &'a CMsgGCToGCSelfPing {
        <CMsgGCToGCSelfPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSelfPing {
    pub fn new() -> CMsgGCToGCSelfPing {
        ::std::default::Default::default()
    }

    // optional uint32 sample_id = 1;

    pub fn sample_id(&self) -> u32 {
        self.sample_id.unwrap_or(0)
    }

    pub fn clear_sample_id(&mut self) {
        self.sample_id = ::std::option::Option::None;
    }

    pub fn has_sample_id(&self) -> bool {
        self.sample_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sample_id(&mut self, v: u32) {
        self.sample_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sample_id",
            |m: &CMsgGCToGCSelfPing| { &m.sample_id },
            |m: &mut CMsgGCToGCSelfPing| { &mut m.sample_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCSelfPing>(
            "CMsgGCToGCSelfPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCSelfPing {
    const NAME: &'static str = "CMsgGCToGCSelfPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sample_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sample_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sample_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSelfPing {
        CMsgGCToGCSelfPing::new()
    }

    fn clear(&mut self) {
        self.sample_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSelfPing {
        static instance: CMsgGCToGCSelfPing = CMsgGCToGCSelfPing {
            sample_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCSelfPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCSelfPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCSelfPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSelfPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGetInfuxIntervalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetInfuxIntervalStats {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGetInfuxIntervalStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetInfuxIntervalStats {
    fn default() -> &'a CMsgGCToGCGetInfuxIntervalStats {
        <CMsgGCToGCGetInfuxIntervalStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetInfuxIntervalStats {
    pub fn new() -> CMsgGCToGCGetInfuxIntervalStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetInfuxIntervalStats>(
            "CMsgGCToGCGetInfuxIntervalStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetInfuxIntervalStats {
    const NAME: &'static str = "CMsgGCToGCGetInfuxIntervalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetInfuxIntervalStats {
        CMsgGCToGCGetInfuxIntervalStats::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetInfuxIntervalStats {
        static instance: CMsgGCToGCGetInfuxIntervalStats = CMsgGCToGCGetInfuxIntervalStats {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetInfuxIntervalStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetInfuxIntervalStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetInfuxIntervalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetInfuxIntervalStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCGetInfuxIntervalStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetInfuxIntervalStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetInfuxIntervalStatsResponse.stat_ids)
    pub stat_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetInfuxIntervalStatsResponse.stat_total)
    pub stat_total: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetInfuxIntervalStatsResponse.stat_samples)
    pub stat_samples: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetInfuxIntervalStatsResponse.stat_max)
    pub stat_max: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCGetInfuxIntervalStatsResponse.sample_duration_ms)
    pub sample_duration_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCGetInfuxIntervalStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetInfuxIntervalStatsResponse {
    fn default() -> &'a CMsgGCToGCGetInfuxIntervalStatsResponse {
        <CMsgGCToGCGetInfuxIntervalStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetInfuxIntervalStatsResponse {
    pub fn new() -> CMsgGCToGCGetInfuxIntervalStatsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 sample_duration_ms = 5;

    pub fn sample_duration_ms(&self) -> u32 {
        self.sample_duration_ms.unwrap_or(0)
    }

    pub fn clear_sample_duration_ms(&mut self) {
        self.sample_duration_ms = ::std::option::Option::None;
    }

    pub fn has_sample_duration_ms(&self) -> bool {
        self.sample_duration_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sample_duration_ms(&mut self, v: u32) {
        self.sample_duration_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_ids",
            |m: &CMsgGCToGCGetInfuxIntervalStatsResponse| { &m.stat_ids },
            |m: &mut CMsgGCToGCGetInfuxIntervalStatsResponse| { &mut m.stat_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_total",
            |m: &CMsgGCToGCGetInfuxIntervalStatsResponse| { &m.stat_total },
            |m: &mut CMsgGCToGCGetInfuxIntervalStatsResponse| { &mut m.stat_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_samples",
            |m: &CMsgGCToGCGetInfuxIntervalStatsResponse| { &m.stat_samples },
            |m: &mut CMsgGCToGCGetInfuxIntervalStatsResponse| { &mut m.stat_samples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_max",
            |m: &CMsgGCToGCGetInfuxIntervalStatsResponse| { &m.stat_max },
            |m: &mut CMsgGCToGCGetInfuxIntervalStatsResponse| { &mut m.stat_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sample_duration_ms",
            |m: &CMsgGCToGCGetInfuxIntervalStatsResponse| { &m.sample_duration_ms },
            |m: &mut CMsgGCToGCGetInfuxIntervalStatsResponse| { &mut m.sample_duration_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetInfuxIntervalStatsResponse>(
            "CMsgGCToGCGetInfuxIntervalStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetInfuxIntervalStatsResponse {
    const NAME: &'static str = "CMsgGCToGCGetInfuxIntervalStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.stat_ids)?;
                },
                13 => {
                    self.stat_ids.push(is.read_fixed32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.stat_total)?;
                },
                16 => {
                    self.stat_total.push(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.stat_samples)?;
                },
                24 => {
                    self.stat_samples.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.stat_max)?;
                },
                32 => {
                    self.stat_max.push(is.read_uint32()?);
                },
                40 => {
                    self.sample_duration_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.stat_ids.len() as u64;
        for value in &self.stat_total {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        for value in &self.stat_samples {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.stat_max {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.sample_duration_ms {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stat_ids {
            os.write_fixed32(1, *v)?;
        };
        for v in &self.stat_total {
            os.write_uint64(2, *v)?;
        };
        for v in &self.stat_samples {
            os.write_uint32(3, *v)?;
        };
        for v in &self.stat_max {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.sample_duration_ms {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetInfuxIntervalStatsResponse {
        CMsgGCToGCGetInfuxIntervalStatsResponse::new()
    }

    fn clear(&mut self) {
        self.stat_ids.clear();
        self.stat_total.clear();
        self.stat_samples.clear();
        self.stat_max.clear();
        self.sample_duration_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetInfuxIntervalStatsResponse {
        static instance: CMsgGCToGCGetInfuxIntervalStatsResponse = CMsgGCToGCGetInfuxIntervalStatsResponse {
            stat_ids: ::std::vec::Vec::new(),
            stat_total: ::std::vec::Vec::new(),
            stat_samples: ::std::vec::Vec::new(),
            stat_max: ::std::vec::Vec::new(),
            sample_duration_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetInfuxIntervalStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetInfuxIntervalStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetInfuxIntervalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetInfuxIntervalStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCPurchaseSucceeded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPurchaseSucceeded {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCPurchaseSucceeded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPurchaseSucceeded {
    fn default() -> &'a CMsgGCToGCPurchaseSucceeded {
        <CMsgGCToGCPurchaseSucceeded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPurchaseSucceeded {
    pub fn new() -> CMsgGCToGCPurchaseSucceeded {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCPurchaseSucceeded>(
            "CMsgGCToGCPurchaseSucceeded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCPurchaseSucceeded {
    const NAME: &'static str = "CMsgGCToGCPurchaseSucceeded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPurchaseSucceeded {
        CMsgGCToGCPurchaseSucceeded::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPurchaseSucceeded {
        static instance: CMsgGCToGCPurchaseSucceeded = CMsgGCToGCPurchaseSucceeded {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCPurchaseSucceeded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCPurchaseSucceeded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCPurchaseSucceeded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPurchaseSucceeded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetLimitedItemPurchaseQuantity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetLimitedItemPurchaseQuantity {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetLimitedItemPurchaseQuantity.item_def)
    pub item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetLimitedItemPurchaseQuantity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetLimitedItemPurchaseQuantity {
    fn default() -> &'a CMsgClientToGCGetLimitedItemPurchaseQuantity {
        <CMsgClientToGCGetLimitedItemPurchaseQuantity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetLimitedItemPurchaseQuantity {
    pub fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantity {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CMsgClientToGCGetLimitedItemPurchaseQuantity| { &m.item_def },
            |m: &mut CMsgClientToGCGetLimitedItemPurchaseQuantity| { &mut m.item_def },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetLimitedItemPurchaseQuantity>(
            "CMsgClientToGCGetLimitedItemPurchaseQuantity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetLimitedItemPurchaseQuantity {
    const NAME: &'static str = "CMsgClientToGCGetLimitedItemPurchaseQuantity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantity {
        CMsgClientToGCGetLimitedItemPurchaseQuantity::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetLimitedItemPurchaseQuantity {
        static instance: CMsgClientToGCGetLimitedItemPurchaseQuantity = CMsgClientToGCGetLimitedItemPurchaseQuantity {
            item_def: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetLimitedItemPurchaseQuantity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetLimitedItemPurchaseQuantity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetLimitedItemPurchaseQuantity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetLimitedItemPurchaseQuantity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.quantity_purchased)
    pub quantity_purchased: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    fn default() -> &'a CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        <CMsgClientToGCGetLimitedItemPurchaseQuantityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    pub fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 quantity_purchased = 2;

    pub fn quantity_purchased(&self) -> u32 {
        self.quantity_purchased.unwrap_or(0)
    }

    pub fn clear_quantity_purchased(&mut self) {
        self.quantity_purchased = ::std::option::Option::None;
    }

    pub fn has_quantity_purchased(&self) -> bool {
        self.quantity_purchased.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity_purchased(&mut self, v: u32) {
        self.quantity_purchased = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCGetLimitedItemPurchaseQuantityResponse| { &m.result },
            |m: &mut CMsgClientToGCGetLimitedItemPurchaseQuantityResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity_purchased",
            |m: &CMsgClientToGCGetLimitedItemPurchaseQuantityResponse| { &m.quantity_purchased },
            |m: &mut CMsgClientToGCGetLimitedItemPurchaseQuantityResponse| { &mut m.quantity_purchased },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetLimitedItemPurchaseQuantityResponse>(
            "CMsgClientToGCGetLimitedItemPurchaseQuantityResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    const NAME: &'static str = "CMsgClientToGCGetLimitedItemPurchaseQuantityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.quantity_purchased = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.quantity_purchased {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.quantity_purchased {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        CMsgClientToGCGetLimitedItemPurchaseQuantityResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.quantity_purchased = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        static instance: CMsgClientToGCGetLimitedItemPurchaseQuantityResponse = CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
            result: ::std::option::Option::None,
            quantity_purchased: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetLimitedItemPurchaseQuantityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetLimitedItemPurchaseQuantityResponse`
pub mod cmsg_client_to_gcget_limited_item_purchase_quantity_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eInvalidItemDef)
        k_eInvalidItemDef = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eItemDefNotLimited)
        k_eItemDefNotLimited = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidItemDef),
                6 => ::std::option::Option::Some(EResponse::k_eItemDefNotLimited),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidItemDef" => ::std::option::Option::Some(EResponse::k_eInvalidItemDef),
                "k_eItemDefNotLimited" => ::std::option::Option::Some(EResponse::k_eItemDefNotLimited),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidItemDef,
            EResponse::k_eItemDefNotLimited,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCUpdateWelcomeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateWelcomeMsg {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateWelcomeMsg.server)
    pub server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateWelcomeMsg.new_msg)
    pub new_msg: ::protobuf::MessageField<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateWelcomeMsg.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCUpdateWelcomeMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateWelcomeMsg {
    fn default() -> &'a CMsgGCToGCUpdateWelcomeMsg {
        <CMsgGCToGCUpdateWelcomeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateWelcomeMsg {
    pub fn new() -> CMsgGCToGCUpdateWelcomeMsg {
        ::std::default::Default::default()
    }

    // optional bool server = 1;

    pub fn server(&self) -> bool {
        self.server.unwrap_or(false)
    }

    pub fn clear_server(&mut self) {
        self.server = ::std::option::Option::None;
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: bool) {
        self.server = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 3;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server",
            |m: &CMsgGCToGCUpdateWelcomeMsg| { &m.server },
            |m: &mut CMsgGCToGCUpdateWelcomeMsg| { &mut m.server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::gcsdk_gcmessages::CExtraMsgBlock>(
            "new_msg",
            |m: &CMsgGCToGCUpdateWelcomeMsg| { &m.new_msg },
            |m: &mut CMsgGCToGCUpdateWelcomeMsg| { &mut m.new_msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast",
            |m: &CMsgGCToGCUpdateWelcomeMsg| { &m.broadcast },
            |m: &mut CMsgGCToGCUpdateWelcomeMsg| { &mut m.broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCUpdateWelcomeMsg>(
            "CMsgGCToGCUpdateWelcomeMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCUpdateWelcomeMsg {
    const NAME: &'static str = "CMsgGCToGCUpdateWelcomeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_msg)?;
                },
                24 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server {
            my_size += 1 + 1;
        }
        if let Some(v) = self.new_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.new_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateWelcomeMsg {
        CMsgGCToGCUpdateWelcomeMsg::new()
    }

    fn clear(&mut self) {
        self.server = ::std::option::Option::None;
        self.new_msg.clear();
        self.broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateWelcomeMsg {
        static instance: CMsgGCToGCUpdateWelcomeMsg = CMsgGCToGCUpdateWelcomeMsg {
            server: ::std::option::Option::None,
            new_msg: ::protobuf::MessageField::none(),
            broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCUpdateWelcomeMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCUpdateWelcomeMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCUpdateWelcomeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUpdateWelcomeMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EGCItemMsg)
pub enum EGCItemMsg {
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCBase)
    k_EMsgGCBase = 1000,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCSetItemPosition)
    k_EMsgGCSetItemPosition = 1001,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCDelete)
    k_EMsgGCDelete = 1004,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCVerifyCacheSubscription)
    k_EMsgGCVerifyCacheSubscription = 1005,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCNameItem)
    k_EMsgClientToGCNameItem = 1006,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCPaintItem)
    k_EMsgGCPaintItem = 1009,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCPaintItemResponse)
    k_EMsgGCPaintItemResponse = 1010,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCNameBaseItem)
    k_EMsgGCNameBaseItem = 1019,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCNameBaseItemResponse)
    k_EMsgGCNameBaseItemResponse = 1020,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCUseItemRequest)
    k_EMsgGCUseItemRequest = 1025,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCUseItemResponse)
    k_EMsgGCUseItemResponse = 1026,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCGiftedItems)
    k_EMsgGCGiftedItems = 1027,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCUnwrapGiftRequest)
    k_EMsgGCUnwrapGiftRequest = 1037,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCUnwrapGiftResponse)
    k_EMsgGCUnwrapGiftResponse = 1038,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCSortItems)
    k_EMsgGCSortItems = 1041,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCBackpackSortFinished)
    k_EMsgGCBackpackSortFinished = 1058,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCAdjustItemEquippedState)
    k_EMsgGCAdjustItemEquippedState = 1059,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCItemAcknowledged)
    k_EMsgGCItemAcknowledged = 1062,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCNameItemResponse)
    k_EMsgClientToGCNameItemResponse = 1068,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCApplyStrangePart)
    k_EMsgGCApplyStrangePart = 1073,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCApplyPennantUpgrade)
    k_EMsgGCApplyPennantUpgrade = 1076,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCSetItemPositions)
    k_EMsgGCSetItemPositions = 1077,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCApplyEggEssence)
    k_EMsgGCApplyEggEssence = 1078,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCNameEggEssenceResponse)
    k_EMsgGCNameEggEssenceResponse = 1079,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCExtractGems)
    k_EMsgGCExtractGems = 1086,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCAddSocket)
    k_EMsgGCAddSocket = 1087,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCAddItemToSocket)
    k_EMsgGCAddItemToSocket = 1088,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCAddItemToSocketResponse)
    k_EMsgGCAddItemToSocketResponse = 1089,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCAddSocketResponse)
    k_EMsgGCAddSocketResponse = 1090,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCResetStrangeGemCount)
    k_EMsgGCResetStrangeGemCount = 1091,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRequestCrateItems)
    k_EMsgGCRequestCrateItems = 1092,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRequestCrateItemsResponse)
    k_EMsgGCRequestCrateItemsResponse = 1093,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCExtractGemsResponse)
    k_EMsgGCExtractGemsResponse = 1094,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCResetStrangeGemCountResponse)
    k_EMsgGCResetStrangeGemCountResponse = 1095,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCServerUseItemRequest)
    k_EMsgGCServerUseItemRequest = 1103,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCAddGiftItem)
    k_EMsgGCAddGiftItem = 1104,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCRemoveItemGifterAttributes)
    k_EMsgClientToGCRemoveItemGifterAttributes = 1109,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCRemoveItemName)
    k_EMsgClientToGCRemoveItemName = 1110,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCRemoveItemDescription)
    k_EMsgClientToGCRemoveItemDescription = 1111,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCRemoveItemAttributeResponse)
    k_EMsgClientToGCRemoveItemAttributeResponse = 1112,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCDev_NewItemRequest)
    k_EMsgGCDev_NewItemRequest = 2001,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCDev_NewItemRequestResponse)
    k_EMsgGCDev_NewItemRequestResponse = 2002,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCDev_UnlockAllItemStylesRequest)
    k_EMsgGCDev_UnlockAllItemStylesRequest = 2003,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCDev_UnlockAllItemStylesResponse)
    k_EMsgGCDev_UnlockAllItemStylesResponse = 2004,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCStorePurchaseFinalize)
    k_EMsgGCStorePurchaseFinalize = 2504,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCStorePurchaseFinalizeResponse)
    k_EMsgGCStorePurchaseFinalizeResponse = 2505,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCStorePurchaseCancel)
    k_EMsgGCStorePurchaseCancel = 2506,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCStorePurchaseCancelResponse)
    k_EMsgGCStorePurchaseCancelResponse = 2507,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCStorePurchaseInit)
    k_EMsgGCStorePurchaseInit = 2510,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCStorePurchaseInitResponse)
    k_EMsgGCStorePurchaseInitResponse = 2511,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCBannedWordListUpdated)
    k_EMsgGCToGCBannedWordListUpdated = 2515,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCDirtySDOCache)
    k_EMsgGCToGCDirtySDOCache = 2516,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCUpdateSQLKeyValue)
    k_EMsgGCToGCUpdateSQLKeyValue = 2518,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCBroadcastConsoleCommand)
    k_EMsgGCToGCBroadcastConsoleCommand = 2521,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCServerVersionUpdated)
    k_EMsgGCServerVersionUpdated = 2522,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCApplyAutograph)
    k_EMsgGCApplyAutograph = 2523,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCWebAPIAccountChanged)
    k_EMsgGCToGCWebAPIAccountChanged = 2524,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCClientVersionUpdated)
    k_EMsgGCClientVersionUpdated = 2528,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCUpdateWelcomeMsg)
    k_EMsgGCToGCUpdateWelcomeMsg = 2529,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCPlayerStrangeCountAdjustments)
    k_EMsgGCToGCPlayerStrangeCountAdjustments = 2535,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRequestStoreSalesData)
    k_EMsgGCRequestStoreSalesData = 2536,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRequestStoreSalesDataResponse)
    k_EMsgGCRequestStoreSalesDataResponse = 2537,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRequestStoreSalesDataUpToDateResponse)
    k_EMsgGCRequestStoreSalesDataUpToDateResponse = 2538,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCPingRequest)
    k_EMsgGCToGCPingRequest = 2539,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCPingResponse)
    k_EMsgGCToGCPingResponse = 2540,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGetUserSessionServer)
    k_EMsgGCToGCGetUserSessionServer = 2541,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGetUserSessionServerResponse)
    k_EMsgGCToGCGetUserSessionServerResponse = 2542,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGetUserServerMembers)
    k_EMsgGCToGCGetUserServerMembers = 2543,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGetUserServerMembersResponse)
    k_EMsgGCToGCGetUserServerMembersResponse = 2544,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCCanUseDropRateBonus)
    k_EMsgGCToGCCanUseDropRateBonus = 2547,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgSQLAddDropRateBonus)
    k_EMsgSQLAddDropRateBonus = 2548,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCRefreshSOCache)
    k_EMsgGCToGCRefreshSOCache = 2549,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGrantAccountRolledItems)
    k_EMsgGCToGCGrantAccountRolledItems = 2554,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGrantSelfMadeItemToAccount)
    k_EMsgGCToGCGrantSelfMadeItemToAccount = 2555,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCStatueCraft)
    k_EMsgGCStatueCraft = 2561,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRedeemCode)
    k_EMsgGCRedeemCode = 2562,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRedeemCodeResponse)
    k_EMsgGCRedeemCodeResponse = 2563,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCItemConsumptionRollback)
    k_EMsgGCToGCItemConsumptionRollback = 2564,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCWrapAndDeliverGift)
    k_EMsgClientToGCWrapAndDeliverGift = 2565,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCWrapAndDeliverGiftResponse)
    k_EMsgClientToGCWrapAndDeliverGiftResponse = 2566,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCUnpackBundleResponse)
    k_EMsgClientToGCUnpackBundleResponse = 2567,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToClientStoreTransactionCompleted)
    k_EMsgGCToClientStoreTransactionCompleted = 2568,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCEquipItems)
    k_EMsgClientToGCEquipItems = 2569,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCEquipItemsResponse)
    k_EMsgClientToGCEquipItemsResponse = 2570,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCUnlockItemStyle)
    k_EMsgClientToGCUnlockItemStyle = 2571,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCUnlockItemStyleResponse)
    k_EMsgClientToGCUnlockItemStyleResponse = 2572,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCSetItemInventoryCategory)
    k_EMsgClientToGCSetItemInventoryCategory = 2573,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCUnlockCrate)
    k_EMsgClientToGCUnlockCrate = 2574,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCUnlockCrateResponse)
    k_EMsgClientToGCUnlockCrateResponse = 2575,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCUnpackBundle)
    k_EMsgClientToGCUnpackBundle = 2576,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCSetItemStyle)
    k_EMsgClientToGCSetItemStyle = 2577,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCSetItemStyleResponse)
    k_EMsgClientToGCSetItemStyleResponse = 2578,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgSQLGCToGCGrantBackpackSlots)
    k_EMsgSQLGCToGCGrantBackpackSlots = 2580,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCLookupAccountName)
    k_EMsgClientToGCLookupAccountName = 2581,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCLookupAccountNameResponse)
    k_EMsgClientToGCLookupAccountNameResponse = 2582,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCCreateStaticRecipe)
    k_EMsgClientToGCCreateStaticRecipe = 2584,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCCreateStaticRecipeResponse)
    k_EMsgClientToGCCreateStaticRecipeResponse = 2585,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCStoreProcessCDKeyTransaction)
    k_EMsgGCToGCStoreProcessCDKeyTransaction = 2586,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCStoreProcessCDKeyTransactionResponse)
    k_EMsgGCToGCStoreProcessCDKeyTransactionResponse = 2587,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCStoreProcessSettlement)
    k_EMsgGCToGCStoreProcessSettlement = 2588,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCStoreProcessSettlementResponse)
    k_EMsgGCToGCStoreProcessSettlementResponse = 2589,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCConsoleOutput)
    k_EMsgGCToGCConsoleOutput = 2590,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToClientItemAges)
    k_EMsgGCToClientItemAges = 2591,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCInternalTestMsg)
    k_EMsgGCToGCInternalTestMsg = 2592,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCClientServerVersionsUpdated)
    k_EMsgGCToGCClientServerVersionsUpdated = 2593,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCUseMultipleItemsRequest)
    k_EMsgGCUseMultipleItemsRequest = 2594,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCGetAccountSubscriptionItem)
    k_EMsgGCGetAccountSubscriptionItem = 2595,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCGetAccountSubscriptionItemResponse)
    k_EMsgGCGetAccountSubscriptionItemResponse = 2596,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCBroadcastMessageFromSub)
    k_EMsgGCToGCBroadcastMessageFromSub = 2598,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToClientCurrencyPricePoints)
    k_EMsgGCToClientCurrencyPricePoints = 2599,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCAddSubscriptionTime)
    k_EMsgGCToGCAddSubscriptionTime = 2600,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCFlushSteamInventoryCache)
    k_EMsgGCToGCFlushSteamInventoryCache = 2601,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRequestCrateEscalationLevel)
    k_EMsgGCRequestCrateEscalationLevel = 2602,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCRequestCrateEscalationLevelResponse)
    k_EMsgGCRequestCrateEscalationLevelResponse = 2603,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCUpdateSubscriptionItems)
    k_EMsgGCToGCUpdateSubscriptionItems = 2604,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCSelfPing)
    k_EMsgGCToGCSelfPing = 2605,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGetInfuxIntervalStats)
    k_EMsgGCToGCGetInfuxIntervalStats = 2606,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCGetInfuxIntervalStatsResponse)
    k_EMsgGCToGCGetInfuxIntervalStatsResponse = 2607,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCPurchaseSucceeded)
    k_EMsgGCToGCPurchaseSucceeded = 2608,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCGetLimitedItemPurchaseQuantity)
    k_EMsgClientToGCGetLimitedItemPurchaseQuantity = 2609,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse)
    k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse = 2610,
    // @@protoc_insertion_point(enum_value:dota.EGCItemMsg.k_EMsgGCToGCBetaDeleteItems)
    k_EMsgGCToGCBetaDeleteItems = 2611,
}

impl ::protobuf::Enum for EGCItemMsg {
    const NAME: &'static str = "EGCItemMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCItemMsg> {
        match value {
            1000 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            1001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPosition),
            1004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            1005 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            1006 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItem),
            1009 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            1010 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            1019 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            1020 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            1025 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            1026 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            1027 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            1037 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            1038 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            1041 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            1058 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            1059 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            1062 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            1068 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItemResponse),
            1073 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            1076 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyPennantUpgrade),
            1077 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            1078 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyEggEssence),
            1079 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameEggEssenceResponse),
            1086 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGems),
            1087 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocket),
            1088 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocket),
            1089 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocketResponse),
            1090 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketResponse),
            1091 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCount),
            1092 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItems),
            1093 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItemsResponse),
            1094 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGemsResponse),
            1095 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse),
            1103 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerUseItemRequest),
            1104 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddGiftItem),
            1109 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes),
            1110 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemName),
            1111 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemDescription),
            1112 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse),
            2001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            2002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            2003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesRequest),
            2004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesResponse),
            2504 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            2505 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            2506 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            2507 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            2510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            2511 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            2515 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated),
            2516 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            2518 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            2521 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            2522 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            2523 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            2524 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            2528 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            2529 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg),
            2535 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            2536 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            2537 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            2538 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            2539 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            2540 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            2541 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            2542 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            2543 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            2544 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            2547 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus),
            2548 => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLAddDropRateBonus),
            2549 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCRefreshSOCache),
            2554 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems),
            2555 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            2561 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStatueCraft),
            2562 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCode),
            2563 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCodeResponse),
            2564 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback),
            2565 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift),
            2566 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse),
            2567 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse),
            2568 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted),
            2569 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItems),
            2570 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItemsResponse),
            2571 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyle),
            2572 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse),
            2573 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory),
            2574 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrate),
            2575 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse),
            2576 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundle),
            2577 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyle),
            2578 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse),
            2580 => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots),
            2581 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountName),
            2582 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse),
            2584 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe),
            2585 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse),
            2586 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction),
            2587 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse),
            2588 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement),
            2589 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse),
            2590 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCConsoleOutput),
            2591 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientItemAges),
            2592 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCInternalTestMsg),
            2593 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated),
            2594 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseMultipleItemsRequest),
            2595 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem),
            2596 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse),
            2598 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub),
            2599 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints),
            2600 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime),
            2601 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache),
            2602 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel),
            2603 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse),
            2604 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems),
            2605 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCSelfPing),
            2606 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats),
            2607 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse),
            2608 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded),
            2609 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity),
            2610 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse),
            2611 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBetaDeleteItems),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCItemMsg> {
        match str {
            "k_EMsgGCBase" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            "k_EMsgGCSetItemPosition" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPosition),
            "k_EMsgGCDelete" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            "k_EMsgGCVerifyCacheSubscription" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            "k_EMsgClientToGCNameItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItem),
            "k_EMsgGCPaintItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            "k_EMsgGCPaintItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            "k_EMsgGCNameBaseItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            "k_EMsgGCNameBaseItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            "k_EMsgGCUseItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            "k_EMsgGCUseItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            "k_EMsgGCGiftedItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            "k_EMsgGCUnwrapGiftRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            "k_EMsgGCUnwrapGiftResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            "k_EMsgGCSortItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            "k_EMsgGCBackpackSortFinished" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            "k_EMsgGCAdjustItemEquippedState" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            "k_EMsgGCItemAcknowledged" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            "k_EMsgClientToGCNameItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItemResponse),
            "k_EMsgGCApplyStrangePart" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            "k_EMsgGCApplyPennantUpgrade" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyPennantUpgrade),
            "k_EMsgGCSetItemPositions" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            "k_EMsgGCApplyEggEssence" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyEggEssence),
            "k_EMsgGCNameEggEssenceResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameEggEssenceResponse),
            "k_EMsgGCExtractGems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGems),
            "k_EMsgGCAddSocket" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocket),
            "k_EMsgGCAddItemToSocket" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocket),
            "k_EMsgGCAddItemToSocketResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocketResponse),
            "k_EMsgGCAddSocketResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketResponse),
            "k_EMsgGCResetStrangeGemCount" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCount),
            "k_EMsgGCRequestCrateItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItems),
            "k_EMsgGCRequestCrateItemsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItemsResponse),
            "k_EMsgGCExtractGemsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGemsResponse),
            "k_EMsgGCResetStrangeGemCountResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse),
            "k_EMsgGCServerUseItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerUseItemRequest),
            "k_EMsgGCAddGiftItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddGiftItem),
            "k_EMsgClientToGCRemoveItemGifterAttributes" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes),
            "k_EMsgClientToGCRemoveItemName" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemName),
            "k_EMsgClientToGCRemoveItemDescription" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemDescription),
            "k_EMsgClientToGCRemoveItemAttributeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse),
            "k_EMsgGCDev_NewItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            "k_EMsgGCDev_NewItemRequestResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            "k_EMsgGCDev_UnlockAllItemStylesRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesRequest),
            "k_EMsgGCDev_UnlockAllItemStylesResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesResponse),
            "k_EMsgGCStorePurchaseFinalize" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            "k_EMsgGCStorePurchaseFinalizeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            "k_EMsgGCStorePurchaseCancel" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            "k_EMsgGCStorePurchaseCancelResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            "k_EMsgGCStorePurchaseInit" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            "k_EMsgGCStorePurchaseInitResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            "k_EMsgGCToGCBannedWordListUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated),
            "k_EMsgGCToGCDirtySDOCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            "k_EMsgGCToGCUpdateSQLKeyValue" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            "k_EMsgGCToGCBroadcastConsoleCommand" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            "k_EMsgGCServerVersionUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            "k_EMsgGCApplyAutograph" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            "k_EMsgGCToGCWebAPIAccountChanged" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            "k_EMsgGCClientVersionUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            "k_EMsgGCToGCUpdateWelcomeMsg" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg),
            "k_EMsgGCToGCPlayerStrangeCountAdjustments" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            "k_EMsgGCRequestStoreSalesData" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            "k_EMsgGCRequestStoreSalesDataResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            "k_EMsgGCRequestStoreSalesDataUpToDateResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            "k_EMsgGCToGCPingRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            "k_EMsgGCToGCPingResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            "k_EMsgGCToGCGetUserSessionServer" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            "k_EMsgGCToGCGetUserSessionServerResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            "k_EMsgGCToGCGetUserServerMembers" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            "k_EMsgGCToGCGetUserServerMembersResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            "k_EMsgGCToGCCanUseDropRateBonus" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus),
            "k_EMsgSQLAddDropRateBonus" => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLAddDropRateBonus),
            "k_EMsgGCToGCRefreshSOCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCRefreshSOCache),
            "k_EMsgGCToGCGrantAccountRolledItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems),
            "k_EMsgGCToGCGrantSelfMadeItemToAccount" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            "k_EMsgGCStatueCraft" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStatueCraft),
            "k_EMsgGCRedeemCode" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCode),
            "k_EMsgGCRedeemCodeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCodeResponse),
            "k_EMsgGCToGCItemConsumptionRollback" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback),
            "k_EMsgClientToGCWrapAndDeliverGift" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift),
            "k_EMsgClientToGCWrapAndDeliverGiftResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse),
            "k_EMsgClientToGCUnpackBundleResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse),
            "k_EMsgGCToClientStoreTransactionCompleted" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted),
            "k_EMsgClientToGCEquipItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItems),
            "k_EMsgClientToGCEquipItemsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItemsResponse),
            "k_EMsgClientToGCUnlockItemStyle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyle),
            "k_EMsgClientToGCUnlockItemStyleResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse),
            "k_EMsgClientToGCSetItemInventoryCategory" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory),
            "k_EMsgClientToGCUnlockCrate" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrate),
            "k_EMsgClientToGCUnlockCrateResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse),
            "k_EMsgClientToGCUnpackBundle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundle),
            "k_EMsgClientToGCSetItemStyle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyle),
            "k_EMsgClientToGCSetItemStyleResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse),
            "k_EMsgSQLGCToGCGrantBackpackSlots" => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots),
            "k_EMsgClientToGCLookupAccountName" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountName),
            "k_EMsgClientToGCLookupAccountNameResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse),
            "k_EMsgClientToGCCreateStaticRecipe" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe),
            "k_EMsgClientToGCCreateStaticRecipeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse),
            "k_EMsgGCToGCStoreProcessCDKeyTransaction" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction),
            "k_EMsgGCToGCStoreProcessCDKeyTransactionResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse),
            "k_EMsgGCToGCStoreProcessSettlement" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement),
            "k_EMsgGCToGCStoreProcessSettlementResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse),
            "k_EMsgGCToGCConsoleOutput" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCConsoleOutput),
            "k_EMsgGCToClientItemAges" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientItemAges),
            "k_EMsgGCToGCInternalTestMsg" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCInternalTestMsg),
            "k_EMsgGCToGCClientServerVersionsUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated),
            "k_EMsgGCUseMultipleItemsRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseMultipleItemsRequest),
            "k_EMsgGCGetAccountSubscriptionItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem),
            "k_EMsgGCGetAccountSubscriptionItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse),
            "k_EMsgGCToGCBroadcastMessageFromSub" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub),
            "k_EMsgGCToClientCurrencyPricePoints" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints),
            "k_EMsgGCToGCAddSubscriptionTime" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime),
            "k_EMsgGCToGCFlushSteamInventoryCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache),
            "k_EMsgGCRequestCrateEscalationLevel" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel),
            "k_EMsgGCRequestCrateEscalationLevelResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse),
            "k_EMsgGCToGCUpdateSubscriptionItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems),
            "k_EMsgGCToGCSelfPing" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCSelfPing),
            "k_EMsgGCToGCGetInfuxIntervalStats" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats),
            "k_EMsgGCToGCGetInfuxIntervalStatsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse),
            "k_EMsgGCToGCPurchaseSucceeded" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded),
            "k_EMsgClientToGCGetLimitedItemPurchaseQuantity" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity),
            "k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse),
            "k_EMsgGCToGCBetaDeleteItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBetaDeleteItems),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCItemMsg] = &[
        EGCItemMsg::k_EMsgGCBase,
        EGCItemMsg::k_EMsgGCSetItemPosition,
        EGCItemMsg::k_EMsgGCDelete,
        EGCItemMsg::k_EMsgGCVerifyCacheSubscription,
        EGCItemMsg::k_EMsgClientToGCNameItem,
        EGCItemMsg::k_EMsgGCPaintItem,
        EGCItemMsg::k_EMsgGCPaintItemResponse,
        EGCItemMsg::k_EMsgGCNameBaseItem,
        EGCItemMsg::k_EMsgGCNameBaseItemResponse,
        EGCItemMsg::k_EMsgGCUseItemRequest,
        EGCItemMsg::k_EMsgGCUseItemResponse,
        EGCItemMsg::k_EMsgGCGiftedItems,
        EGCItemMsg::k_EMsgGCUnwrapGiftRequest,
        EGCItemMsg::k_EMsgGCUnwrapGiftResponse,
        EGCItemMsg::k_EMsgGCSortItems,
        EGCItemMsg::k_EMsgGCBackpackSortFinished,
        EGCItemMsg::k_EMsgGCAdjustItemEquippedState,
        EGCItemMsg::k_EMsgGCItemAcknowledged,
        EGCItemMsg::k_EMsgClientToGCNameItemResponse,
        EGCItemMsg::k_EMsgGCApplyStrangePart,
        EGCItemMsg::k_EMsgGCApplyPennantUpgrade,
        EGCItemMsg::k_EMsgGCSetItemPositions,
        EGCItemMsg::k_EMsgGCApplyEggEssence,
        EGCItemMsg::k_EMsgGCNameEggEssenceResponse,
        EGCItemMsg::k_EMsgGCExtractGems,
        EGCItemMsg::k_EMsgGCAddSocket,
        EGCItemMsg::k_EMsgGCAddItemToSocket,
        EGCItemMsg::k_EMsgGCAddItemToSocketResponse,
        EGCItemMsg::k_EMsgGCAddSocketResponse,
        EGCItemMsg::k_EMsgGCResetStrangeGemCount,
        EGCItemMsg::k_EMsgGCRequestCrateItems,
        EGCItemMsg::k_EMsgGCRequestCrateItemsResponse,
        EGCItemMsg::k_EMsgGCExtractGemsResponse,
        EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse,
        EGCItemMsg::k_EMsgGCServerUseItemRequest,
        EGCItemMsg::k_EMsgGCAddGiftItem,
        EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes,
        EGCItemMsg::k_EMsgClientToGCRemoveItemName,
        EGCItemMsg::k_EMsgClientToGCRemoveItemDescription,
        EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse,
        EGCItemMsg::k_EMsgGCDev_NewItemRequest,
        EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse,
        EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesRequest,
        EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalize,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseCancel,
        EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseInit,
        EGCItemMsg::k_EMsgGCStorePurchaseInitResponse,
        EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated,
        EGCItemMsg::k_EMsgGCToGCDirtySDOCache,
        EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue,
        EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand,
        EGCItemMsg::k_EMsgGCServerVersionUpdated,
        EGCItemMsg::k_EMsgGCApplyAutograph,
        EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged,
        EGCItemMsg::k_EMsgGCClientVersionUpdated,
        EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg,
        EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments,
        EGCItemMsg::k_EMsgGCRequestStoreSalesData,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse,
        EGCItemMsg::k_EMsgGCToGCPingRequest,
        EGCItemMsg::k_EMsgGCToGCPingResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServer,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembers,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse,
        EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus,
        EGCItemMsg::k_EMsgSQLAddDropRateBonus,
        EGCItemMsg::k_EMsgGCToGCRefreshSOCache,
        EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems,
        EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount,
        EGCItemMsg::k_EMsgGCStatueCraft,
        EGCItemMsg::k_EMsgGCRedeemCode,
        EGCItemMsg::k_EMsgGCRedeemCodeResponse,
        EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback,
        EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift,
        EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse,
        EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse,
        EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted,
        EGCItemMsg::k_EMsgClientToGCEquipItems,
        EGCItemMsg::k_EMsgClientToGCEquipItemsResponse,
        EGCItemMsg::k_EMsgClientToGCUnlockItemStyle,
        EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse,
        EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory,
        EGCItemMsg::k_EMsgClientToGCUnlockCrate,
        EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse,
        EGCItemMsg::k_EMsgClientToGCUnpackBundle,
        EGCItemMsg::k_EMsgClientToGCSetItemStyle,
        EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse,
        EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots,
        EGCItemMsg::k_EMsgClientToGCLookupAccountName,
        EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse,
        EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe,
        EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse,
        EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction,
        EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse,
        EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement,
        EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse,
        EGCItemMsg::k_EMsgGCToGCConsoleOutput,
        EGCItemMsg::k_EMsgGCToClientItemAges,
        EGCItemMsg::k_EMsgGCToGCInternalTestMsg,
        EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated,
        EGCItemMsg::k_EMsgGCUseMultipleItemsRequest,
        EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem,
        EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse,
        EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub,
        EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints,
        EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime,
        EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache,
        EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel,
        EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse,
        EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems,
        EGCItemMsg::k_EMsgGCToGCSelfPing,
        EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats,
        EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse,
        EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded,
        EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity,
        EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse,
        EGCItemMsg::k_EMsgGCToGCBetaDeleteItems,
    ];
}

impl ::protobuf::EnumFull for EGCItemMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCItemMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCItemMsg::k_EMsgGCBase => 0,
            EGCItemMsg::k_EMsgGCSetItemPosition => 1,
            EGCItemMsg::k_EMsgGCDelete => 2,
            EGCItemMsg::k_EMsgGCVerifyCacheSubscription => 3,
            EGCItemMsg::k_EMsgClientToGCNameItem => 4,
            EGCItemMsg::k_EMsgGCPaintItem => 5,
            EGCItemMsg::k_EMsgGCPaintItemResponse => 6,
            EGCItemMsg::k_EMsgGCNameBaseItem => 7,
            EGCItemMsg::k_EMsgGCNameBaseItemResponse => 8,
            EGCItemMsg::k_EMsgGCUseItemRequest => 9,
            EGCItemMsg::k_EMsgGCUseItemResponse => 10,
            EGCItemMsg::k_EMsgGCGiftedItems => 11,
            EGCItemMsg::k_EMsgGCUnwrapGiftRequest => 12,
            EGCItemMsg::k_EMsgGCUnwrapGiftResponse => 13,
            EGCItemMsg::k_EMsgGCSortItems => 14,
            EGCItemMsg::k_EMsgGCBackpackSortFinished => 15,
            EGCItemMsg::k_EMsgGCAdjustItemEquippedState => 16,
            EGCItemMsg::k_EMsgGCItemAcknowledged => 17,
            EGCItemMsg::k_EMsgClientToGCNameItemResponse => 18,
            EGCItemMsg::k_EMsgGCApplyStrangePart => 19,
            EGCItemMsg::k_EMsgGCApplyPennantUpgrade => 20,
            EGCItemMsg::k_EMsgGCSetItemPositions => 21,
            EGCItemMsg::k_EMsgGCApplyEggEssence => 22,
            EGCItemMsg::k_EMsgGCNameEggEssenceResponse => 23,
            EGCItemMsg::k_EMsgGCExtractGems => 24,
            EGCItemMsg::k_EMsgGCAddSocket => 25,
            EGCItemMsg::k_EMsgGCAddItemToSocket => 26,
            EGCItemMsg::k_EMsgGCAddItemToSocketResponse => 27,
            EGCItemMsg::k_EMsgGCAddSocketResponse => 28,
            EGCItemMsg::k_EMsgGCResetStrangeGemCount => 29,
            EGCItemMsg::k_EMsgGCRequestCrateItems => 30,
            EGCItemMsg::k_EMsgGCRequestCrateItemsResponse => 31,
            EGCItemMsg::k_EMsgGCExtractGemsResponse => 32,
            EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse => 33,
            EGCItemMsg::k_EMsgGCServerUseItemRequest => 34,
            EGCItemMsg::k_EMsgGCAddGiftItem => 35,
            EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes => 36,
            EGCItemMsg::k_EMsgClientToGCRemoveItemName => 37,
            EGCItemMsg::k_EMsgClientToGCRemoveItemDescription => 38,
            EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse => 39,
            EGCItemMsg::k_EMsgGCDev_NewItemRequest => 40,
            EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse => 41,
            EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesRequest => 42,
            EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesResponse => 43,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalize => 44,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse => 45,
            EGCItemMsg::k_EMsgGCStorePurchaseCancel => 46,
            EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse => 47,
            EGCItemMsg::k_EMsgGCStorePurchaseInit => 48,
            EGCItemMsg::k_EMsgGCStorePurchaseInitResponse => 49,
            EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated => 50,
            EGCItemMsg::k_EMsgGCToGCDirtySDOCache => 51,
            EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue => 52,
            EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand => 53,
            EGCItemMsg::k_EMsgGCServerVersionUpdated => 54,
            EGCItemMsg::k_EMsgGCApplyAutograph => 55,
            EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged => 56,
            EGCItemMsg::k_EMsgGCClientVersionUpdated => 57,
            EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg => 58,
            EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments => 59,
            EGCItemMsg::k_EMsgGCRequestStoreSalesData => 60,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse => 61,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse => 62,
            EGCItemMsg::k_EMsgGCToGCPingRequest => 63,
            EGCItemMsg::k_EMsgGCToGCPingResponse => 64,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServer => 65,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse => 66,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembers => 67,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse => 68,
            EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus => 69,
            EGCItemMsg::k_EMsgSQLAddDropRateBonus => 70,
            EGCItemMsg::k_EMsgGCToGCRefreshSOCache => 71,
            EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems => 72,
            EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount => 73,
            EGCItemMsg::k_EMsgGCStatueCraft => 74,
            EGCItemMsg::k_EMsgGCRedeemCode => 75,
            EGCItemMsg::k_EMsgGCRedeemCodeResponse => 76,
            EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback => 77,
            EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift => 78,
            EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse => 79,
            EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse => 80,
            EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted => 81,
            EGCItemMsg::k_EMsgClientToGCEquipItems => 82,
            EGCItemMsg::k_EMsgClientToGCEquipItemsResponse => 83,
            EGCItemMsg::k_EMsgClientToGCUnlockItemStyle => 84,
            EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse => 85,
            EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory => 86,
            EGCItemMsg::k_EMsgClientToGCUnlockCrate => 87,
            EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse => 88,
            EGCItemMsg::k_EMsgClientToGCUnpackBundle => 89,
            EGCItemMsg::k_EMsgClientToGCSetItemStyle => 90,
            EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse => 91,
            EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots => 92,
            EGCItemMsg::k_EMsgClientToGCLookupAccountName => 93,
            EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse => 94,
            EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe => 95,
            EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse => 96,
            EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction => 97,
            EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse => 98,
            EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement => 99,
            EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse => 100,
            EGCItemMsg::k_EMsgGCToGCConsoleOutput => 101,
            EGCItemMsg::k_EMsgGCToClientItemAges => 102,
            EGCItemMsg::k_EMsgGCToGCInternalTestMsg => 103,
            EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated => 104,
            EGCItemMsg::k_EMsgGCUseMultipleItemsRequest => 105,
            EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem => 106,
            EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse => 107,
            EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub => 108,
            EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints => 109,
            EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime => 110,
            EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache => 111,
            EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel => 112,
            EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse => 113,
            EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems => 114,
            EGCItemMsg::k_EMsgGCToGCSelfPing => 115,
            EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats => 116,
            EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse => 117,
            EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded => 118,
            EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity => 119,
            EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse => 120,
            EGCItemMsg::k_EMsgGCToGCBetaDeleteItems => 121,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCItemMsg {
    fn default() -> Self {
        EGCItemMsg::k_EMsgGCBase
    }
}

impl EGCItemMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCItemMsg>("EGCItemMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EGCMsgInitiateTradeResponse)
pub enum EGCMsgInitiateTradeResponse {
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Accepted)
    k_EGCMsgInitiateTradeResponse_Accepted = 0,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Declined)
    k_EGCMsgInitiateTradeResponse_Declined = 1,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator)
    k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator = 2,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_VAC_Banned_Target)
    k_EGCMsgInitiateTradeResponse_VAC_Banned_Target = 3,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Target_Already_Trading)
    k_EGCMsgInitiateTradeResponse_Target_Already_Trading = 4,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Disabled)
    k_EGCMsgInitiateTradeResponse_Disabled = 5,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_NotLoggedIn)
    k_EGCMsgInitiateTradeResponse_NotLoggedIn = 6,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Cancel)
    k_EGCMsgInitiateTradeResponse_Cancel = 7,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TooSoon)
    k_EGCMsgInitiateTradeResponse_TooSoon = 8,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TooSoonPenalty)
    k_EGCMsgInitiateTradeResponse_TooSoonPenalty = 9,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator)
    k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator = 10,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Trade_Banned_Target)
    k_EGCMsgInitiateTradeResponse_Trade_Banned_Target = 11,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED)
    k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED = 12,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator)
    k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator = 13,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Service_Unavailable)
    k_EGCMsgInitiateTradeResponse_Service_Unavailable = 14,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Target_Blocked)
    k_EGCMsgInitiateTradeResponse_Target_Blocked = 15,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail)
    k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail = 16,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_NeedSteamGuard)
    k_EGCMsgInitiateTradeResponse_NeedSteamGuard = 17,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_SteamGuardDuration)
    k_EGCMsgInitiateTradeResponse_SteamGuardDuration = 18,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TheyCannotTrade)
    k_EGCMsgInitiateTradeResponse_TheyCannotTrade = 19,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Recent_Password_Reset)
    k_EGCMsgInitiateTradeResponse_Recent_Password_Reset = 20,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Using_New_Device)
    k_EGCMsgInitiateTradeResponse_Using_New_Device = 21,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie)
    k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie = 22,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TooRecentFriend)
    k_EGCMsgInitiateTradeResponse_TooRecentFriend = 23,
    // @@protoc_insertion_point(enum_value:dota.EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted)
    k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted = 24,
}

impl ::protobuf::Enum for EGCMsgInitiateTradeResponse {
    const NAME: &'static str = "EGCMsgInitiateTradeResponse";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCMsgInitiateTradeResponse> {
        match value {
            0 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            1 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined),
            2 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator),
            3 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target),
            4 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading),
            5 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled),
            6 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn),
            7 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel),
            8 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon),
            9 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty),
            10 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator),
            11 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target),
            12 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED),
            13 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator),
            14 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable),
            15 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked),
            16 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail),
            17 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard),
            18 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration),
            19 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade),
            20 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset),
            21 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device),
            22 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie),
            23 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend),
            24 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCMsgInitiateTradeResponse> {
        match str {
            "k_EGCMsgInitiateTradeResponse_Accepted" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            "k_EGCMsgInitiateTradeResponse_Declined" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined),
            "k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator),
            "k_EGCMsgInitiateTradeResponse_VAC_Banned_Target" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target),
            "k_EGCMsgInitiateTradeResponse_Target_Already_Trading" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading),
            "k_EGCMsgInitiateTradeResponse_Disabled" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled),
            "k_EGCMsgInitiateTradeResponse_NotLoggedIn" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn),
            "k_EGCMsgInitiateTradeResponse_Cancel" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel),
            "k_EGCMsgInitiateTradeResponse_TooSoon" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon),
            "k_EGCMsgInitiateTradeResponse_TooSoonPenalty" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty),
            "k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator),
            "k_EGCMsgInitiateTradeResponse_Trade_Banned_Target" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target),
            "k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED),
            "k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator),
            "k_EGCMsgInitiateTradeResponse_Service_Unavailable" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable),
            "k_EGCMsgInitiateTradeResponse_Target_Blocked" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked),
            "k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail),
            "k_EGCMsgInitiateTradeResponse_NeedSteamGuard" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard),
            "k_EGCMsgInitiateTradeResponse_SteamGuardDuration" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration),
            "k_EGCMsgInitiateTradeResponse_TheyCannotTrade" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade),
            "k_EGCMsgInitiateTradeResponse_Recent_Password_Reset" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset),
            "k_EGCMsgInitiateTradeResponse_Using_New_Device" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device),
            "k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie),
            "k_EGCMsgInitiateTradeResponse_TooRecentFriend" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend),
            "k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCMsgInitiateTradeResponse] = &[
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted,
    ];
}

impl ::protobuf::EnumFull for EGCMsgInitiateTradeResponse {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCMsgInitiateTradeResponse").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGCMsgInitiateTradeResponse {
    fn default() -> Self {
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted
    }
}

impl EGCMsgInitiateTradeResponse {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCMsgInitiateTradeResponse>("EGCMsgInitiateTradeResponse")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15econ_gcmessages.proto\x12\x04dota\x1a\x13steammessages.proto\x1a\
    \x17econ_shared_enums.proto\x1a\x16gcsdk_gcmessages.proto\"b\n\x12CMsgAp\
    plyAutograph\x12*\n\x11autograph_item_id\x18\x01\x20\x01(\x04R\x0fautogr\
    aphItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\x04R\nitemItemId\"\
    \x8f\x01\n\x1bCMsgAdjustItemEquippedState\x12\x17\n\x07item_id\x18\x01\
    \x20\x01(\x04R\x06itemId\x12\x1b\n\tnew_class\x18\x02\x20\x01(\rR\x08new\
    Class\x12\x19\n\x08new_slot\x18\x03\x20\x01(\rR\x07newSlot\x12\x1f\n\x0b\
    style_index\x18\x04\x20\x01(\rR\nstyleIndex\"\xd7\x02\n$CMsgEconPlayerSt\
    rangeCountAdjustment\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountI\
    d\x12~\n\x19strange_count_adjustments\x18\x02\x20\x03(\x0b2B.dota.CMsgEc\
    onPlayerStrangeCountAdjustment.CStrangeCountAdjustmentR\x17strangeCountA\
    djustments\x12\x1d\n\nturbo_mode\x18\x03\x20\x01(\x08R\tturboMode\x1aq\n\
    \x17CStrangeCountAdjustment\x12\x1d\n\nevent_type\x18\x01\x20\x01(\rR\te\
    ventType\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\x12\x1e\n\
    \nadjustment\x18\x03\x20\x01(\rR\nadjustment\"1\n\x14CMsgCraftingRespons\
    e\x12\x19\n\x08item_ids\x18\x01\x20\x03(\x04R\x07itemIds\"S\n\x1bCMsgGCR\
    equestStoreSalesData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\
    \x12\x1a\n\x08currency\x18\x02\x20\x01(\rR\x08currency\"\xf2\x01\n#CMsgG\
    CRequestStoreSalesDataResponse\x12N\n\nsale_price\x18\x01\x20\x03(\x0b2/\
    .dota.CMsgGCRequestStoreSalesDataResponse.PriceR\tsalePrice\x12\x18\n\
    \x07version\x18\x02\x20\x01(\rR\x07version\x12'\n\x0fexpiration_time\x18\
    \x03\x20\x01(\rR\x0eexpirationTime\x1a8\n\x05Price\x12\x19\n\x08item_def\
    \x18\x01\x20\x01(\rR\x07itemDef\x12\x14\n\x05price\x18\x02\x20\x01(\rR\
    \x05price\"p\n+CMsgGCRequestStoreSalesDataUpToDateResponse\x12\x18\n\x07\
    version\x18\x01\x20\x01(\rR\x07version\x12'\n\x0fexpiration_time\x18\x02\
    \x20\x01(\rR\x0eexpirationTime\"\x17\n\x15CMsgGCToGCPingRequest\"\x18\n\
    \x16CMsgGCToGCPingResponse\"?\n\x1eCMsgGCToGCGetUserSessionServer\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"m\n&CMsgGCToGCGetUser\
    SessionServerResponse\x12&\n\x0fserver_steam_id\x18\x01\x20\x01(\x06R\rs\
    erverSteamId\x12\x1b\n\tis_online\x18\x02\x20\x01(\x08R\x08isOnline\"f\n\
    \x1eCMsgGCToGCGetUserServerMembers\x12\x1d\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountId\x12%\n\x0emax_spectators\x18\x02\x20\x01(\rR\rmaxSpectat\
    ors\"T\n&CMsgGCToGCGetUserServerMembersResponse\x12*\n\x11member_account\
    _id\x18\x01\x20\x03(\rR\x0fmemberAccountId\"@\n\x1eCMsgLookupMultipleAcc\
    ountNames\x12\x1e\n\naccountids\x18\x01\x20\x03(\rR\naccountids\"\xbd\
    \x01\n&CMsgLookupMultipleAccountNamesResponse\x12P\n\x08accounts\x18\x01\
    \x20\x03(\x0b24.dota.CMsgLookupMultipleAccountNamesResponse.AccountR\x08\
    accounts\x1aA\n\x07Account\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\tacc\
    ountid\x12\x18\n\x07persona\x18\x02\x20\x01(\tR\x07persona\"=\n\x15CMsgR\
    equestCrateItems\x12$\n\x0ecrate_item_def\x18\x01\x20\x01(\rR\x0ccrateIt\
    emDef\"\xa8\x01\n\x1dCMsgRequestCrateItemsResponse\x12\x1a\n\x08response\
    \x18\x01\x20\x01(\rR\x08response\x12\x1b\n\titem_defs\x18\x02\x20\x03(\r\
    R\x08itemDefs\x12$\n\x0epeek_item_defs\x18\x03\x20\x03(\rR\x0cpeekItemDe\
    fs\"(\n\x07EResult\x12\x0f\n\x0bk_Succeeded\x10\0\x12\x0c\n\x08k_Failed\
    \x10\x01\"G\n\x1fCMsgRequestCrateEscalationLevel\x12$\n\x0ecrate_item_de\
    f\x18\x01\x20\x01(\rR\x0ccrateItemDef\"\xa3\x02\n'CMsgRequestCrateEscala\
    tionLevelResponse\x12\x1a\n\x08response\x18\x01\x20\x01(\rR\x08response\
    \x12+\n\x11escalation_level0\x18\x02\x20\x01(\rR\x10escalationLevel0\x12\
    +\n\x11escalation_level1\x18\x03\x20\x01(\rR\x10escalationLevel1\x12+\n\
    \x11escalation_level2\x18\x04\x20\x01(\rR\x10escalationLevel2\x12+\n\x11\
    escalation_level3\x18\x05\x20\x01(\rR\x10escalationLevel3\"(\n\x07EResul\
    t\x12\x0f\n\x0bk_Succeeded\x10\0\x12\x0c\n\x08k_Failed\x10\x01\"\xe1\x01\
    \n\x1dCMsgGCToGCCanUseDropRateBonus\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12&\n\x0fdrop_rate_bonus\x18\x02\x20\x01(\x02R\rdro\
    pRateBonus\x12!\n\x0cbooster_type\x18\x03\x20\x01(\rR\x0bboosterType\x12\
    ,\n\x12exclusive_item_def\x18\x04\x20\x01(\rR\x10exclusiveItemDef\x12(\n\
    \x10allow_equal_rate\x18\x05\x20\x01(\x08R\x0eallowEqualRate\"\x88\x02\n\
    \x17CMsgSQLAddDropRateBonus\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\ta\
    ccountId\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\x12\x19\n\
    \x08item_def\x18\x03\x20\x01(\rR\x07itemDef\x12&\n\x0fdrop_rate_bonus\
    \x18\x04\x20\x01(\x02R\rdropRateBonus\x12!\n\x0cbooster_type\x18\x05\x20\
    \x01(\rR\x0bboosterType\x12)\n\x10seconds_duration\x18\x06\x20\x01(\rR\
    \x0fsecondsDuration\x12$\n\x0eend_time_stamp\x18\x07\x20\x01(\rR\x0cendT\
    imeStamp\"\x9c\x01\n\x1bCMsgSQLUpgradeBattleBooster\x12\x1d\n\naccount_i\
    d\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08item_def\x18\x02\x20\x01(\
    \rR\x07itemDef\x12\x20\n\x0cbonus_to_add\x18\x03\x20\x01(\x02R\nbonusToA\
    dd\x12!\n\x0cbooster_type\x18\x04\x20\x01(\rR\x0bboosterType\"Q\n\x18CMs\
    gGCToGCRefreshSOCache\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccount\
    Id\x12\x16\n\x06reload\x18\x02\x20\x01(\x08R\x06reload\"\xb8\x01\n\x1dCM\
    sgGCToGCAddSubscriptionTime\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\ta\
    ccountId\x12I\n!matching_subscription_def_indexes\x18\x02\x20\x03(\rR\
    \x1ematchingSubscriptionDefIndexes\x12-\n\x12additional_seconds\x18\x03\
    \x20\x01(\rR\x11additionalSeconds\"\xef\x06\n!CMsgGCToGCGrantAccountRoll\
    edItems\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12B\n\x05i\
    tems\x18\x02\x20\x03(\x0b2,.dota.CMsgGCToGCGrantAccountRolledItems.ItemR\
    \x05items\x12!\n\x0caudit_action\x18\x03\x20\x01(\rR\x0bauditAction\x12\
    \x1d\n\naudit_data\x18\x04\x20\x01(\x04R\tauditData\x1a\xa4\x05\n\x04Ite\
    m\x12\x19\n\x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12\x1d\n\nloot_l\
    ists\x18\x02\x20\x03(\tR\tlootLists\x12!\n\x0cignore_limit\x18\x03\x20\
    \x01(\x08R\x0bignoreLimit\x12\x16\n\x06origin\x18\x04\x20\x01(\rR\x06ori\
    gin\x12l\n\x12dynamic_attributes\x18\x05\x20\x03(\x0b2=.dota.CMsgGCToGCG\
    rantAccountRolledItems.Item.DynamicAttributeR\x11dynamicAttributes\x12{\
    \n\x18additional_audit_entries\x18\x06\x20\x03(\x0b2A.dota.CMsgGCToGCGra\
    ntAccountRolledItems.Item.AdditionalAuditEntryR\x16additionalAuditEntrie\
    s\x12'\n\x0finventory_token\x18\x07\x20\x01(\rR\x0einventoryToken\x1a\
    \x8d\x01\n\x10DynamicAttribute\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12!\n\x0cvalue_uint32\x18\x02\x20\x01(\rR\x0bvalueUint32\x12\x1f\n\
    \x0bvalue_float\x18\x03\x20\x01(\x02R\nvalueFloat\x12!\n\x0cvalue_string\
    \x18\x04\x20\x01(\tR\x0bvalueString\x1a\x82\x01\n\x14AdditionalAuditEntr\
    y\x12(\n\x10owner_account_id\x18\x01\x20\x01(\rR\x0eownerAccountId\x12!\
    \n\x0caudit_action\x18\x02\x20\x01(\rR\x0bauditAction\x12\x1d\n\naudit_d\
    ata\x18\x03\x20\x01(\x04R\tauditData\"r\n\x19CMsgGCToGCBetaDeleteItems\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08item_\
    ids\x18\x02\x20\x03(\x04R\x07itemIds\x12\x1b\n\titem_defs\x18\x03\x20\
    \x03(\rR\x08itemDefs\"j\n$CMsgGCToGCGrantSelfMadeItemToAccount\x12$\n\
    \x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\x12\x1c\n\taccoun\
    tid\x18\x02\x20\x01(\rR\taccountid\"\x97\x02\n\x0bCMsgUseItem\x12\x17\n\
    \x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12&\n\x0ftarget_steam_id\
    \x18\x02\x20\x01(\x06R\rtargetSteamId\x125\n\x17gift__potential_targets\
    \x18\x03\x20\x03(\rR\x14giftPotentialTargets\x12'\n\x10duel__class_lock\
    \x18\x04\x20\x01(\rR\rduelClassLock\x12,\n\x12initiator_steam_id\x18\x05\
    \x20\x01(\x04R\x10initiatorSteamId\x129\n\x19itempack__ack_immediately\
    \x18\x06\x20\x01(\x08R\x16itempackAckImmediately\"z\n\x11CMsgServerUseIt\
    em\x120\n\x14initiator_account_id\x18\x01\x20\x01(\rR\x12initiatorAccoun\
    tId\x123\n\x0cuse_item_msg\x18\x02\x20\x01(\x0b2\x11.dota.CMsgUseItemR\n\
    useItemMsg\"1\n\x14CMsgUseMultipleItems\x12\x19\n\x08item_ids\x18\x01\
    \x20\x03(\x04R\x07itemIds\"_\n!CGCStoreRechargeRedirect_LineItem\x12\x1e\
    \n\x0bitem_def_id\x18\x01\x20\x01(\rR\titemDefId\x12\x1a\n\x08quantity\
    \x18\x02\x20\x01(\rR\x08quantity\"\xfa\x01\n)CMsgGCEconSQLWorkItemEmbedd\
    edRollbackData\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12&\
    \n\x0fdeleted_item_id\x18\x02\x20\x01(\x04R\rdeletedItemId\x12(\n\x10old\
    _audit_action\x18\x03\x20\x01(\rR\x0eoldAuditAction\x12(\n\x10new_audit_\
    action\x18\x04\x20\x01(\rR\x0enewAuditAction\x122\n\x15expected_audit_ac\
    tion\x18\x05\x20\x01(\rR\x13expectedAuditAction\"\xc8\x01\n\x0fCMsgCraft\
    Statue\x12\x16\n\x06heroid\x18\x01\x20\x01(\rR\x06heroid\x12\"\n\x0csequ\
    encename\x18\x02\x20\x01(\tR\x0csequencename\x12\x14\n\x05cycle\x18\x03\
    \x20\x01(\x02R\x05cycle\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0b\
    description\x12)\n\x10pedestal_itemdef\x18\x05\x20\x01(\rR\x0fpedestalIt\
    emdef\x12\x16\n\x06toolid\x18\x06\x20\x01(\x04R\x06toolid\"$\n\x0eCMsgRe\
    deemCode\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\"\xbf\x01\n\x16CM\
    sgRedeemCodeResponse\x12\x1a\n\x08response\x18\x01\x20\x01(\rR\x08respon\
    se\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\"p\n\x0bEResultC\
    ode\x12\x0f\n\x0bk_Succeeded\x10\0\x12\x19\n\x15k_Failed_CodeNotFound\
    \x10\x01\x12\x1c\n\x18k_Failed_CodeAlreadyUsed\x10\x02\x12\x17\n\x13k_Fa\
    iled_OtherError\x10\x03\"\xc7\x01\n\x15CMsgDevNewItemRequest\x12\"\n\rit\
    em_def_name\x18\x03\x20\x01(\tR\x0bitemDefName\x12$\n\x0eloot_list_name\
    \x18\x04\x20\x01(\tR\x0clootListName\x12\"\n\rattr_def_name\x18\x05\x20\
    \x03(\tR\x0battrDefName\x12\x1d\n\nattr_value\x18\x06\x20\x03(\tR\tattrV\
    alue\x12!\n\x0citem_quality\x18\x07\x20\x01(\rR\x0bitemQuality\"9\n\x1dC\
    MsgDevNewItemRequestResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\
    \x07success\"5\n\x1aCMsgDevUnlockAllItemStyles\x12\x17\n\x07item_id\x18\
    \x01\x20\x01(\x04R\x06itemId\">\n\"CMsgDevUnlockAllItemStylesResponse\
    \x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"A\n\x20CMsgGCGet\
    AccountSubscriptionItem\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccou\
    ntId\"G\n(CMsgGCGetAccountSubscriptionItemResponse\x12\x1b\n\tdef_index\
    \x18\x01\x20\x01(\rR\x08defIndex\"K\n\x11CMsgGCAddGiftItem\x12\x1d\n\nac\
    count_id\x18\x01\x20\x01(\rR\taccountId\x12\x17\n\x07item_id\x18\x02\x20\
    \x01(\x04R\x06itemId\"\x8b\x01\n\x20CMsgClientToGCWrapAndDeliverGift\x12\
    \x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12+\n\x12give_to_acco\
    unt_id\x18\x02\x20\x01(\rR\x0fgiveToAccountId\x12!\n\x0cgift_message\x18\
    \x03\x20\x01(\tR\x0bgiftMessage\"\x80\x03\n(CMsgClientToGCWrapAndDeliver\
    GiftResponse\x120\n\x08response\x18\x01\x20\x01(\x0e2\x14.dota.EGCMsgRes\
    ponseR\x08response\x12.\n\x13gifting_charge_uses\x18\x02\x20\x01(\rR\x11\
    giftingChargeUses\x12,\n\x12gifting_charge_max\x18\x03\x20\x01(\x05R\x10\
    giftingChargeMax\x12!\n\x0cgifting_uses\x18\x04\x20\x01(\rR\x0bgiftingUs\
    es\x12\x1f\n\x0bgifting_max\x18\x05\x20\x01(\x05R\ngiftingMax\x120\n\x14\
    gifting_window_hours\x18\x06\x20\x01(\rR\x12giftingWindowHours\x12N\n\
    \x11trade_restriction\x18\x07\x20\x01(\x0e2!.dota.EGCMsgInitiateTradeRes\
    ponseR\x10tradeRestriction\"3\n\x18CMsgClientToGCUnwrapGift\x12\x17\n\
    \x07item_id\x18\x01\x20\x01(\x04R\x06itemId\"\"\n\x20CMsgClientToGCGetGi\
    ftPermissions\"\xb9\x04\n(CMsgClientToGCGetGiftPermissionsResponse\x12!\
    \n\x0cis_unlimited\x18\x01\x20\x01(\x08R\x0bisUnlimited\x12$\n\x0ehas_tw\
    o_factor\x18\x03\x20\x01(\x08R\x0chasTwoFactor\x12N\n\x11sender_permissi\
    on\x18\x06\x20\x01(\x0e2!.dota.EGCMsgInitiateTradeResponseR\x10senderPer\
    mission\x12<\n\x1afriendship_age_requirement\x18\x07\x20\x01(\rR\x18frie\
    ndshipAgeRequirement\x12P\n%friendship_age_requirement_two_factor\x18\
    \x08\x20\x01(\rR!friendshipAgeRequirementTwoFactor\x12n\n\x12friend_perm\
    issions\x18\t\x20\x03(\x0b2?.dota.CMsgClientToGCGetGiftPermissionsRespon\
    se.FriendPermissionR\x11friendPermissions\x1at\n\x10FriendPermission\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12A\n\npermission\x18\
    \x02\x20\x01(\x0e2!.dota.EGCMsgInitiateTradeResponseR\npermission\"5\n\
    \x1aCMsgClientToGCUnpackBundle\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04\
    R\x06itemId\"\x9b\x04\n\"CMsgClientToGCUnpackBundleResponse\x12*\n\x11un\
    packed_item_ids\x18\x01\x20\x03(\x04R\x0funpackedItemIds\x12R\n\x08respo\
    nse\x18\x02\x20\x01(\x0e26.dota.CMsgClientToGCUnpackBundleResponse.EUnpa\
    ckBundleR\x08response\x129\n\x19unpacked_item_def_indexes\x18\x03\x20\
    \x03(\rR\x16unpackedItemDefIndexes\"\xb9\x02\n\rEUnpackBundle\x12\x1c\n\
    \x18k_UnpackBundle_Succeeded\x10\0\x12)\n%k_UnpackBundle_Failed_ItemIsNo\
    tBundle\x10\x01\x125\n1k_UnpackBundle_Failed_UnableToCreateContainedItem\
    \x10\x02\x12&\n\"k_UnpackBundle_Failed_SOCacheError\x10\x03\x12'\n#k_Unp\
    ackBundle_Failed_ItemIsInvalid\x10\x04\x12)\n%k_UnpackBundle_Failed_BadI\
    temQuantity\x10\x05\x12,\n(k_UnpackBundle_Failed_UnableToDeleteItem\x10\
    \x06\"[\n'CMsgGCToClientStoreTransactionCompleted\x12\x15\n\x06txn_id\
    \x18\x01\x20\x01(\x04R\x05txnId\x12\x19\n\x08item_ids\x18\x02\x20\x03(\
    \x04R\x07itemIds\"U\n\x18CMsgClientToGCEquipItems\x129\n\x06equips\x18\
    \x01\x20\x03(\x0b2!.dota.CMsgAdjustItemEquippedStateR\x06equips\"Q\n\x20\
    CMsgClientToGCEquipItemsResponse\x12-\n\x13so_cache_version_id\x18\x01\
    \x20\x01(\x06R\x10soCacheVersionId\"V\n\x1aCMsgClientToGCSetItemStyle\
    \x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12\x1f\n\x0bstyle\
    _index\x18\x02\x20\x01(\rR\nstyleIndex\"\xd7\x01\n\"CMsgClientToGCSetIte\
    mStyleResponse\x12N\n\x08response\x18\x01\x20\x01(\x0e22.dota.CMsgClient\
    ToGCSetItemStyleResponse.ESetStyleR\x08response\"a\n\tESetStyle\x12\x18\
    \n\x14k_SetStyle_Succeeded\x10\0\x12\x15\n\x11k_SetStyle_Failed\x10\x01\
    \x12#\n\x1fk_SetStyle_Failed_StyleIsLocked\x10\x02\"\x96\x01\n\x1dCMsgCl\
    ientToGCUnlockItemStyle\x12$\n\x0eitem_to_unlock\x18\x01\x20\x01(\x04R\
    \x0citemToUnlock\x12\x1f\n\x0bstyle_index\x18\x02\x20\x01(\rR\nstyleInde\
    x\x12.\n\x13consumable_item_ids\x18\x03\x20\x03(\x04R\x11consumableItemI\
    ds\"\xb9\x05\n%CMsgClientToGCUnlockItemStyleResponse\x12T\n\x08response\
    \x18\x01\x20\x01(\x0e28.dota.CMsgClientToGCUnlockItemStyleResponse.EUnlo\
    ckStyleR\x08response\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemI\
    d\x12\x1f\n\x0bstyle_index\x18\x03\x20\x01(\rR\nstyleIndex\x12!\n\x0csty\
    le_prereq\x18\x04\x20\x01(\rR\x0bstylePrereq\"\xdc\x03\n\x0cEUnlockStyle\
    \x12\x1b\n\x17k_UnlockStyle_Succeeded\x10\0\x12\x1f\n\x1bk_UnlockStyle_F\
    ailed_PreReq\x10\x01\x12#\n\x1fk_UnlockStyle_Failed_CantAfford\x10\x02\
    \x12#\n\x1fk_UnlockStyle_Failed_CantCommit\x10\x03\x12&\n\"k_UnlockStyle\
    _Failed_CantLockCache\x10\x04\x12)\n%k_UnlockStyle_Failed_CantAffordAttr\
    ib\x10\x05\x12&\n\"k_UnlockStyle_Failed_CantAffordGem\x10\x06\x12*\n&k_U\
    nlockStyle_Failed_NoCompendiumLevel\x10\x07\x12(\n$k_UnlockStyle_Failed_\
    AlreadyUnlocked\x10\x08\x12#\n\x1fk_UnlockStyle_Failed_OtherError\x10\t\
    \x12&\n\"k_UnlockStyle_Failed_ItemIsInvalid\x10\n\x12&\n\"k_UnlockStyle_\
    Failed_ToolIsInvalid\x10\x0b\"\xb9\x01\n&CMsgClientToGCSetItemInventoryC\
    ategory\x12\x19\n\x08item_ids\x18\x01\x20\x03(\x04R\x07itemIds\x12\x20\n\
    \x0cset_to_value\x18\x02\x20\x01(\rR\nsetToValue\x12+\n\x11remove_catego\
    ries\x18\x03\x20\x01(\rR\x10removeCategories\x12%\n\x0eadd_categories\
    \x18\x04\x20\x01(\rR\raddCategories\"_\n\x19CMsgClientToGCUnlockCrate\
    \x12\"\n\rcrate_item_id\x18\x01\x20\x01(\x04R\x0bcrateItemId\x12\x1e\n\
    \x0bkey_item_id\x18\x02\x20\x01(\x04R\tkeyItemId\"\xe2\x01\n!CMsgClientT\
    oGCUnlockCrateResponse\x12,\n\x06result\x18\x01\x20\x01(\x0e2\x14.dota.E\
    GCMsgResponseR\x06result\x12Q\n\rgranted_items\x18\x02\x20\x03(\x0b2,.do\
    ta.CMsgClientToGCUnlockCrateResponse.ItemR\x0cgrantedItems\x1a<\n\x04Ite\
    m\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12\x1b\n\tdef_in\
    dex\x18\x02\x20\x01(\rR\x08defIndex\"<\n!CMsgClientToGCRemoveItemAttribu\
    te\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\"\xa8\x03\n)CMsg\
    ClientToGCRemoveItemAttributeResponse\x12`\n\x08response\x18\x01\x20\x01\
    (\x0e2D.dota.CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttrib\
    uteR\x08response\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\"\
    \xff\x01\n\x14ERemoveItemAttribute\x12#\n\x1fk_RemoveItemAttribute_Succe\
    eded\x10\0\x12\x20\n\x1ck_RemoveItemAttribute_Failed\x10\x01\x12.\n*k_Re\
    moveItemAttribute_Failed_ItemIsInvalid\x10\x02\x129\n5k_RemoveItemAttrib\
    ute_Failed_AttributeCannotBeRemoved\x10\x03\x125\n1k_RemoveItemAttribute\
    _Failed_AttributeDoesntExist\x10\x04\"v\n\x16CMsgClientToGCNameItem\x12&\
    \n\x0fsubject_item_id\x18\x01\x20\x01(\x04R\rsubjectItemId\x12\x20\n\x0c\
    tool_item_id\x18\x02\x20\x01(\x04R\ntoolItemId\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\"\xb3\x02\n\x1eCMsgClientToGCNameItemResponse\x12J\
    \n\x08response\x18\x01\x20\x01(\x0e2..dota.CMsgClientToGCNameItemRespons\
    e.ENameItemR\x08response\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06i\
    temId\"\xab\x01\n\tENameItem\x12\x18\n\x14k_NameItem_Succeeded\x10\0\x12\
    \x15\n\x11k_NameItem_Failed\x10\x01\x12#\n\x1fk_NameItem_Failed_ToolIsIn\
    valid\x10\x02\x12#\n\x1fk_NameItem_Failed_ItemIsInvalid\x10\x03\x12#\n\
    \x1fk_NameItem_Failed_NameIsInvalid\x10\x04\"S\n\x15CMsgGCSetItemPositio\
    n\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12!\n\x0cnew_pos\
    ition\x18\x02\x20\x01(\rR\x0bnewPosition\"\x92\x03\n%CAttribute_ItemDyna\
    micRecipeComponent\x12\x19\n\x08item_def\x18\x01\x20\x01(\rR\x07itemDef\
    \x12!\n\x0citem_quality\x18\x02\x20\x01(\rR\x0bitemQuality\x12\x1d\n\nit\
    em_flags\x18\x03\x20\x01(\rR\titemFlags\x12+\n\x11attributes_string\x18\
    \x04\x20\x01(\tR\x10attributesString\x12\x1d\n\nitem_count\x18\x05\x20\
    \x01(\rR\titemCount\x12'\n\x0fitems_fulfilled\x18\x06\x20\x01(\rR\x0eite\
    msFulfilled\x12\x1f\n\x0bitem_rarity\x18\x07\x20\x01(\rR\nitemRarity\x12\
    \x1a\n\x08lootlist\x18\x08\x20\x01(\tR\x08lootlist\x12*\n\x11fulfilled_i\
    tem_id\x18\t\x20\x01(\x04R\x0ffulfilledItemId\x12.\n\x13associated_item_\
    def\x18\n\x20\x01(\rR\x11associatedItemDef\"\x90\x02\n\x10CProtoItemSock\
    et\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12$\n\x0eattr_d\
    ef_index\x18\x02\x20\x01(\rR\x0cattrDefIndex\x12#\n\rrequired_type\x18\
    \x03\x20\x01(\rR\x0crequiredType\x12#\n\rrequired_hero\x18\x04\x20\x01(\
    \tR\x0crequiredHero\x12\"\n\rgem_def_index\x18\x05\x20\x01(\rR\x0bgemDef\
    Index\x12!\n\x0cnot_tradable\x18\x06\x20\x01(\x08R\x0bnotTradable\x12,\n\
    \x12required_item_slot\x18\x07\x20\x01(\tR\x10requiredItemSlot\"H\n\x16C\
    ProtoItemSocket_Empty\x12.\n\x06socket\x18\x01\x20\x01(\x0b2\x16.dota.CP\
    rotoItemSocketR\x06socket\"a\n\x17CProtoItemSocket_Effect\x12.\n\x06sock\
    et\x18\x01\x20\x01(\x0b2\x16.dota.CProtoItemSocketR\x06socket\x12\x16\n\
    \x06effect\x18\x02\x20\x01(\rR\x06effect\"\x84\x01\n\x16CProtoItemSocket\
    _Color\x12.\n\x06socket\x18\x01\x20\x01(\x0b2\x16.dota.CProtoItemSocketR\
    \x06socket\x12\x10\n\x03red\x18\x02\x20\x01(\rR\x03red\x12\x14\n\x05gree\
    n\x18\x03\x20\x01(\rR\x05green\x12\x12\n\x04blue\x18\x04\x20\x01(\rR\x04\
    blue\"\x92\x01\n\x18CProtoItemSocket_Strange\x12.\n\x06socket\x18\x01\
    \x20\x01(\x0b2\x16.dota.CProtoItemSocketR\x06socket\x12!\n\x0cstrange_ty\
    pe\x18\x02\x20\x01(\rR\x0bstrangeType\x12#\n\rstrange_value\x18\x03\x20\
    \x01(\rR\x0cstrangeValue\"\xd6\x01\n5CProtoItemSocket_Strange_DESERIALIZ\
    E_FROM_STRING_ONLY\x12.\n\x06socket\x18\x01\x20\x01(\x0b2\x16.dota.CProt\
    oItemSocketR\x06socket\x12!\n\x0cstrange_type\x18\x02\x20\x01(\rR\x0bstr\
    angeType\x12#\n\rstrange_value\x18\x03\x20\x01(\rR\x0cstrangeValue\x12%\
    \n\x0eability_effect\x18\x04\x20\x01(\rR\rabilityEffect\"\xcc\x01\n\x1aC\
    ProtoItemSocket_Spectator\x12.\n\x06socket\x18\x01\x20\x01(\x0b2\x16.dot\
    a.CProtoItemSocketR\x06socket\x12!\n\x0cgames_viewed\x18\x02\x20\x01(\rR\
    \x0bgamesViewed\x12%\n\x0ecorporation_id\x18\x03\x20\x01(\rR\rcorporatio\
    nId\x12\x1b\n\tleague_id\x18\x04\x20\x01(\rR\x08leagueId\x12\x17\n\x07te\
    am_id\x18\x05\x20\x01(\rR\x06teamId\"w\n\x1eCProtoItemSocket_AssetModifi\
    er\x12.\n\x06socket\x18\x01\x20\x01(\x0b2\x16.dota.CProtoItemSocketR\x06\
    socket\x12%\n\x0easset_modifier\x18\x02\x20\x01(\rR\rassetModifier\"\xe0\
    \x01\n;CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY\x12.\
    \n\x06socket\x18\x01\x20\x01(\x0b2\x16.dota.CProtoItemSocketR\x06socket\
    \x12%\n\x0easset_modifier\x18\x02\x20\x01(\rR\rassetModifier\x12#\n\rani\
    m_modifier\x18\x03\x20\x01(\rR\x0canimModifier\x12%\n\x0eability_effect\
    \x18\x04\x20\x01(\rR\rabilityEffect\"\xb6\x01\n\x1aCProtoItemSocket_Auto\
    graph\x12.\n\x06socket\x18\x01\x20\x01(\x0b2\x16.dota.CProtoItemSocketR\
    \x06socket\x12\x1c\n\tautograph\x18\x02\x20\x01(\tR\tautograph\x12!\n\
    \x0cautograph_id\x18\x03\x20\x01(\rR\x0bautographId\x12'\n\x0fautograph_\
    score\x18\x04\x20\x01(\rR\x0eautographScore\"P\n\x1eCProtoItemSocket_Sta\
    ticVisuals\x12.\n\x06socket\x18\x01\x20\x01(\x0b2\x16.dota.CProtoItemSoc\
    ketR\x06socket\")\n\x11CAttribute_String\x12\x14\n\x05value\x18\x01\x20\
    \x01(\tR\x05value\"\x90\x01\n%CWorkshop_GetItemDailyRevenue_Request\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x17\n\x07item_id\x18\
    \x02\x20\x01(\rR\x06itemId\x12\x1d\n\ndate_start\x18\x03\x20\x01(\rR\tda\
    teStart\x12\x19\n\x08date_end\x18\x04\x20\x01(\rR\x07dateEnd\"\x99\x02\n\
    &CWorkshop_GetItemDailyRevenue_Response\x12i\n\x0fcountry_revenue\x18\
    \x01\x20\x03(\x0b2@.dota.CWorkshop_GetItemDailyRevenue_Response.CountryD\
    ailyRevenueR\x0ecountryRevenue\x1a\x83\x01\n\x13CountryDailyRevenue\x12!\
    \n\x0ccountry_code\x18\x01\x20\x01(\tR\x0bcountryCode\x12\x12\n\x04date\
    \x18\x02\x20\x01(\rR\x04date\x12\x1f\n\x0brevenue_usd\x18\x03\x20\x01(\
    \x03R\nrevenueUsd\x12\x14\n\x05units\x18\x04\x20\x01(\x05R\x05units\"\
    \x82\x01\n(CWorkshop_GetPackageDailyRevenue_Request\x12\x1c\n\tpackageid\
    \x18\x01\x20\x01(\rR\tpackageid\x12\x1d\n\ndate_start\x18\x02\x20\x01(\r\
    R\tdateStart\x12\x19\n\x08date_end\x18\x03\x20\x01(\rR\x07dateEnd\"\x9f\
    \x02\n)CWorkshop_GetPackageDailyRevenue_Response\x12l\n\x0fcountry_reven\
    ue\x18\x01\x20\x03(\x0b2C.dota.CWorkshop_GetPackageDailyRevenue_Response\
    .CountryDailyRevenueR\x0ecountryRevenue\x1a\x83\x01\n\x13CountryDailyRev\
    enue\x12!\n\x0ccountry_code\x18\x01\x20\x01(\tR\x0bcountryCode\x12\x12\n\
    \x04date\x18\x02\x20\x01(\rR\x04date\x12\x1f\n\x0brevenue_usd\x18\x03\
    \x20\x01(\x03R\nrevenueUsd\x12\x14\n\x05units\x18\x04\x20\x01(\x05R\x05u\
    nits\"]\n\x1fCMsgSQLGCToGCGrantBackpackSlots\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x1b\n\tadd_slots\x18\x02\x20\x01(\rR\x08\
    addSlots\"@\n\x1fCMsgClientToGCLookupAccountName\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\"k\n'CMsgClientToGCLookupAccountNameResp\
    onse\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12!\n\x0cacco\
    unt_name\x18\x02\x20\x01(\tR\x0baccountName\"\xc9\x01\n\x20CMsgClientToG\
    CCreateStaticRecipe\x12A\n\x05items\x18\x01\x20\x03(\x0b2+.dota.CMsgClie\
    ntToGCCreateStaticRecipe.ItemR\x05items\x12(\n\x10recipe_def_index\x18\
    \x02\x20\x01(\rR\x0erecipeDefIndex\x1a8\n\x04Item\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\x12\x17\n\x07slot_id\x18\x02\x20\x01(\r\
    R\x06slotId\"\xfa\x06\n(CMsgClientToGCCreateStaticRecipeResponse\x12T\n\
    \x08response\x18\x01\x20\x01(\x0e28.dota.CMsgClientToGCCreateStaticRecip\
    eResponse.EResponseR\x08response\x12\\\n\x0coutput_items\x18\x02\x20\x03\
    (\x0b29.dota.CMsgClientToGCCreateStaticRecipeResponse.OutputItemR\x0bout\
    putItems\x12\\\n\x0cinput_errors\x18\x03\x20\x03(\x0b29.dota.CMsgClientT\
    oGCCreateStaticRecipeResponse.InputErrorR\x0binputErrors\x12n\n\x12addit\
    ional_outputs\x18\x04\x20\x03(\x0b2?.dota.CMsgClientToGCCreateStaticReci\
    peResponse.AdditionalOutputR\x11additionalOutputs\x1a[\n\nOutputItem\x12\
    \x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x17\n\x07item_id\
    \x18\x02\x20\x01(\x04R\x06itemId\x12\x17\n\x07slot_id\x18\x03\x20\x01(\r\
    R\x06slotId\x1au\n\nInputError\x12\x17\n\x07slot_id\x18\x01\x20\x01(\rR\
    \x06slotId\x12N\n\x05error\x18\x02\x20\x01(\x0e28.dota.CMsgClientToGCCre\
    ateStaticRecipeResponse.EResponseR\x05error\x1aA\n\x10AdditionalOutput\
    \x12\x17\n\x07slot_id\x18\x01\x20\x01(\rR\x06slotId\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x04R\x05value\"\xb4\x01\n\tEResponse\x12\x15\n\x11eRes\
    ponse_Success\x10\0\x12\x1e\n\x1aeResponse_OfferingDisabled\x10\x01\x12\
    \x1a\n\x16eResponse_InvalidItems\x10\x02\x12\x1b\n\x17eResponse_Internal\
    Error\x10\x03\x12\x1b\n\x17eResponse_MissingLeague\x10\x04\x12\x1a\n\x16\
    eResponse_MissingEvent\x10\x05\"\xcc\x05\n\x1bCMsgProcessTransactionOrde\
    r\x12\x15\n\x06txn_id\x18\x01\x20\x01(\x04R\x05txnId\x12\x20\n\x0csteam_\
    txn_id\x18\x02\x20\x01(\x04R\nsteamTxnId\x12$\n\x0epartner_txn_id\x18\
    \x03\x20\x01(\x04R\x0cpartnerTxnId\x12\x19\n\x08steam_id\x18\x04\x20\x01\
    (\x06R\x07steamId\x12\x1d\n\ntime_stamp\x18\x05\x20\x01(\rR\ttimeStamp\
    \x12\x1c\n\twatermark\x18\x06\x20\x01(\x04R\twatermark\x124\n\x16purchas\
    e_report_status\x18\x07\x20\x01(\x05R\x14purchaseReportStatus\x12\x1a\n\
    \x08currency\x18\x08\x20\x01(\rR\x08currency\x12<\n\x05items\x18\t\x20\
    \x03(\x0b2&.dota.CMsgProcessTransactionOrder.ItemR\x05items\x1a\xe5\x02\
    \n\x04Item\x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\
    \x12\x1d\n\nitem_price\x18\x02\x20\x01(\rR\titemPrice\x12\x1a\n\x08quant\
    ity\x18\x03\x20\x01(\rR\x08quantity\x12#\n\rcategory_desc\x18\x04\x20\
    \x01(\tR\x0ccategoryDesc\x12.\n\x13store_purchase_type\x18\x05\x20\x01(\
    \rR\x11storePurchaseType\x12.\n\x13source_reference_id\x18\x06\x20\x01(\
    \x04R\x11sourceReferenceId\x12,\n\x12parent_stack_index\x18\x07\x20\x01(\
    \x05R\x10parentStackIndex\x12#\n\rdefault_price\x18\x08\x20\x01(\x08R\
    \x0cdefaultPrice\x12$\n\x0eis_user_facing\x18\t\x20\x01(\x08R\x0cisUserF\
    acing\"\x9c\x01\n&CMsgGCToGCStoreProcessCDKeyTransaction\x127\n\x05order\
    \x18\x01\x20\x01(\x0b2!.dota.CMsgProcessTransactionOrderR\x05order\x12\
    \x1f\n\x0breason_code\x18\x02\x20\x01(\rR\nreasonCode\x12\x18\n\x07partn\
    er\x18\x03\x20\x01(\rR\x07partner\"J\n.CMsgGCToGCStoreProcessCDKeyTransa\
    ctionResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"[\n\
    \x20CMsgGCToGCStoreProcessSettlement\x127\n\x05order\x18\x01\x20\x01(\
    \x0b2!.dota.CMsgProcessTransactionOrderR\x05order\"D\n(CMsgGCToGCStorePr\
    ocessSettlementResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07su\
    ccess\"\xb3\x01\n!CMsgGCToGCBroadcastConsoleCommand\x12\x1f\n\x0bcon_com\
    mand\x18\x01\x20\x01(\tR\nconCommand\x12#\n\rreport_output\x18\x02\x20\
    \x01(\x08R\x0creportOutput\x12\x1d\n\nsending_gc\x18\x03\x20\x01(\x05R\t\
    sendingGc\x12)\n\x10output_initiator\x18\x04\x20\x01(\tR\x0foutputInitia\
    tor\"\x89\x02\n\x17CMsgGCToGCConsoleOutput\x12\x1c\n\tinitiator\x18\x01\
    \x20\x01(\tR\tinitiator\x12\x1d\n\nsending_gc\x18\x02\x20\x01(\x05R\tsen\
    dingGc\x12<\n\x04msgs\x18\x03\x20\x03(\x0b2(.dota.CMsgGCToGCConsoleOutpu\
    t.OutputLineR\x04msgs\x122\n\x16is_last_for_source_job\x18\x04\x20\x01(\
    \x08R\x12isLastForSourceJob\x1a?\n\nOutputLine\x12\x12\n\x04text\x18\x01\
    \x20\x01(\tR\x04text\x12\x1d\n\nspew_level\x18\x02\x20\x01(\rR\tspewLeve\
    l\"\xbe\x01\n\x0cCMsgItemAges\x12Z\n\x16max_item_id_timestamps\x18\x01\
    \x20\x03(\x0b2%.dota.CMsgItemAges.MaxItemIDTimestampR\x13maxItemIdTimest\
    amps\x1aR\n\x12MaxItemIDTimestamp\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\
    \rR\ttimestamp\x12\x1e\n\x0bmax_item_id\x18\x02\x20\x01(\x04R\tmaxItemId\
    \"\xfb\x01\n\x19CMsgGCToGCInternalTestMsg\x12\x1d\n\nsending_gc\x18\x01\
    \x20\x01(\x05R\tsendingGc\x12\x1b\n\tsender_id\x18\x02\x20\x01(\x06R\x08\
    senderId\x12\x18\n\x07context\x18\x03\x20\x01(\rR\x07context\x12\x1d\n\n\
    message_id\x18\x04\x20\x01(\rR\tmessageId\x12!\n\x0cmessage_body\x18\x05\
    \x20\x01(\x0cR\x0bmessageBody\x12\"\n\rjob_id_source\x18\x06\x20\x01(\
    \x06R\x0bjobIdSource\x12\"\n\rjob_id_target\x18\x07\x20\x01(\x06R\x0bjob\
    IdTarget\"\xa7\x02\n%CMsgGCToGCClientServerVersionsUpdated\x12;\n\x1acli\
    ent_min_allowed_version\x18\x01\x20\x01(\rR\x17clientMinAllowedVersion\
    \x122\n\x15client_active_version\x18\x02\x20\x01(\rR\x13clientActiveVers\
    ion\x122\n\x15server_active_version\x18\x03\x20\x01(\rR\x13serverActiveV\
    ersion\x126\n\x17server_deployed_version\x18\x04\x20\x01(\rR\x15serverDe\
    ployedVersion\x12!\n\x0cwhat_changed\x18\x05\x20\x01(\rR\x0bwhatChanged\
    \"\xad\x01\n!CMsgGCToGCBroadcastMessageFromSub\x12\x15\n\x06msg_id\x18\
    \x01\x20\x01(\rR\x05msgId\x12%\n\x0eserialized_msg\x18\x02\x20\x01(\x0cR\
    \rserializedMsg\x12&\n\x0faccount_id_list\x18\x03\x20\x03(\rR\raccountId\
    List\x12\"\n\rsteam_id_list\x18\x04\x20\x03(\x06R\x0bsteamIdList\"\xe6\
    \x01\n!CMsgGCToClientCurrencyPricePoints\x12\x1b\n\tprice_key\x18\x01\
    \x20\x03(\x04R\x08priceKey\x12P\n\ncurrencies\x18\x02\x20\x03(\x0b20.dot\
    a.CMsgGCToClientCurrencyPricePoints.CurrencyR\ncurrencies\x1aR\n\x08Curr\
    ency\x12\x1f\n\x0bcurrency_id\x18\x01\x20\x01(\rR\ncurrencyId\x12%\n\x0e\
    currency_price\x18\x02\x20\x03(\x04R\rcurrencyPrice\"Q\n\x12CMsgBannedWo\
    rdList\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12!\n\x0cban\
    ned_words\x18\x02\x20\x03(\tR\x0bbannedWords\"\xa5\x01\n\"CMsgGCToGCFlus\
    hSteamInventoryCache\x12@\n\x04keys\x18\x01\x20\x03(\x0b2,.dota.CMsgGCTo\
    GCFlushSteamInventoryCache.KeyR\x04keys\x1a=\n\x03Key\x12\x18\n\x07steam\
    id\x18\x01\x20\x01(\x04R\x07steamid\x12\x1c\n\tcontextid\x18\x02\x20\x01\
    (\x04R\tcontextid\"g\n!CMsgGCToGCUpdateSubscriptionItems\x12\x1d\n\nacco\
    unt_id\x18\x01\x20\x01(\rR\taccountId\x12#\n\ralways_notify\x18\x02\x20\
    \x01(\x08R\x0calwaysNotify\"1\n\x12CMsgGCToGCSelfPing\x12\x1b\n\tsample_\
    id\x18\x01\x20\x01(\rR\x08sampleId\"!\n\x1fCMsgGCToGCGetInfuxIntervalSta\
    ts\"\xcf\x01\n'CMsgGCToGCGetInfuxIntervalStatsResponse\x12\x19\n\x08stat\
    _ids\x18\x01\x20\x03(\x07R\x07statIds\x12\x1d\n\nstat_total\x18\x02\x20\
    \x03(\x04R\tstatTotal\x12!\n\x0cstat_samples\x18\x03\x20\x03(\rR\x0bstat\
    Samples\x12\x19\n\x08stat_max\x18\x04\x20\x03(\rR\x07statMax\x12,\n\x12s\
    ample_duration_ms\x18\x05\x20\x01(\rR\x10sampleDurationMs\"\x1d\n\x1bCMs\
    gGCToGCPurchaseSucceeded\"I\n,CMsgClientToGCGetLimitedItemPurchaseQuanti\
    ty\x12\x19\n\x08item_def\x18\x01\x20\x01(\rR\x07itemDef\"\xd9\x02\n4CMsg\
    ClientToGCGetLimitedItemPurchaseQuantityResponse\x12\\\n\x06result\x18\
    \x01\x20\x01(\x0e2D.dota.CMsgClientToGCGetLimitedItemPurchaseQuantityRes\
    ponse.EResponseR\x06result\x12-\n\x12quantity_purchased\x18\x02\x20\x01(\
    \rR\x11quantityPurchased\"\x93\x01\n\tEResponse\x12\x14\n\x10k_eInternal\
    Error\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\
    \x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x15\
    \n\x11k_eInvalidItemDef\x10\x05\x12\x18\n\x14k_eItemDefNotLimited\x10\
    \x06\"\x81\x01\n\x1aCMsgGCToGCUpdateWelcomeMsg\x12\x16\n\x06server\x18\
    \x01\x20\x01(\x08R\x06server\x12-\n\x07new_msg\x18\x02\x20\x01(\x0b2\x14\
    .dota.CExtraMsgBlockR\x06newMsg\x12\x1c\n\tbroadcast\x18\x03\x20\x01(\
    \x08R\tbroadcast*\x8f$\n\nEGCItemMsg\x12\x11\n\x0ck_EMsgGCBase\x10\xe8\
    \x07\x12\x1c\n\x17k_EMsgGCSetItemPosition\x10\xe9\x07\x12\x13\n\x0ek_EMs\
    gGCDelete\x10\xec\x07\x12$\n\x1fk_EMsgGCVerifyCacheSubscription\x10\xed\
    \x07\x12\x1d\n\x18k_EMsgClientToGCNameItem\x10\xee\x07\x12\x16\n\x11k_EM\
    sgGCPaintItem\x10\xf1\x07\x12\x1e\n\x19k_EMsgGCPaintItemResponse\x10\xf2\
    \x07\x12\x19\n\x14k_EMsgGCNameBaseItem\x10\xfb\x07\x12!\n\x1ck_EMsgGCNam\
    eBaseItemResponse\x10\xfc\x07\x12\x1b\n\x16k_EMsgGCUseItemRequest\x10\
    \x81\x08\x12\x1c\n\x17k_EMsgGCUseItemResponse\x10\x82\x08\x12\x18\n\x13k\
    _EMsgGCGiftedItems\x10\x83\x08\x12\x1e\n\x19k_EMsgGCUnwrapGiftRequest\
    \x10\x8d\x08\x12\x1f\n\x1ak_EMsgGCUnwrapGiftResponse\x10\x8e\x08\x12\x16\
    \n\x11k_EMsgGCSortItems\x10\x91\x08\x12!\n\x1ck_EMsgGCBackpackSortFinish\
    ed\x10\xa2\x08\x12$\n\x1fk_EMsgGCAdjustItemEquippedState\x10\xa3\x08\x12\
    \x1d\n\x18k_EMsgGCItemAcknowledged\x10\xa6\x08\x12%\n\x20k_EMsgClientToG\
    CNameItemResponse\x10\xac\x08\x12\x1d\n\x18k_EMsgGCApplyStrangePart\x10\
    \xb1\x08\x12\x20\n\x1bk_EMsgGCApplyPennantUpgrade\x10\xb4\x08\x12\x1d\n\
    \x18k_EMsgGCSetItemPositions\x10\xb5\x08\x12\x1c\n\x17k_EMsgGCApplyEggEs\
    sence\x10\xb6\x08\x12#\n\x1ek_EMsgGCNameEggEssenceResponse\x10\xb7\x08\
    \x12\x18\n\x13k_EMsgGCExtractGems\x10\xbe\x08\x12\x16\n\x11k_EMsgGCAddSo\
    cket\x10\xbf\x08\x12\x1c\n\x17k_EMsgGCAddItemToSocket\x10\xc0\x08\x12$\n\
    \x1fk_EMsgGCAddItemToSocketResponse\x10\xc1\x08\x12\x1e\n\x19k_EMsgGCAdd\
    SocketResponse\x10\xc2\x08\x12!\n\x1ck_EMsgGCResetStrangeGemCount\x10\
    \xc3\x08\x12\x1e\n\x19k_EMsgGCRequestCrateItems\x10\xc4\x08\x12&\n!k_EMs\
    gGCRequestCrateItemsResponse\x10\xc5\x08\x12\x20\n\x1bk_EMsgGCExtractGem\
    sResponse\x10\xc6\x08\x12)\n$k_EMsgGCResetStrangeGemCountResponse\x10\
    \xc7\x08\x12!\n\x1ck_EMsgGCServerUseItemRequest\x10\xcf\x08\x12\x18\n\
    \x13k_EMsgGCAddGiftItem\x10\xd0\x08\x12/\n*k_EMsgClientToGCRemoveItemGif\
    terAttributes\x10\xd5\x08\x12#\n\x1ek_EMsgClientToGCRemoveItemName\x10\
    \xd6\x08\x12*\n%k_EMsgClientToGCRemoveItemDescription\x10\xd7\x08\x120\n\
    +k_EMsgClientToGCRemoveItemAttributeResponse\x10\xd8\x08\x12\x1f\n\x1ak_\
    EMsgGCDev_NewItemRequest\x10\xd1\x0f\x12'\n\"k_EMsgGCDev_NewItemRequestR\
    esponse\x10\xd2\x0f\x12+\n&k_EMsgGCDev_UnlockAllItemStylesRequest\x10\
    \xd3\x0f\x12,\n'k_EMsgGCDev_UnlockAllItemStylesResponse\x10\xd4\x0f\x12\
    \"\n\x1dk_EMsgGCStorePurchaseFinalize\x10\xc8\x13\x12*\n%k_EMsgGCStorePu\
    rchaseFinalizeResponse\x10\xc9\x13\x12\x20\n\x1bk_EMsgGCStorePurchaseCan\
    cel\x10\xca\x13\x12(\n#k_EMsgGCStorePurchaseCancelResponse\x10\xcb\x13\
    \x12\x1e\n\x19k_EMsgGCStorePurchaseInit\x10\xce\x13\x12&\n!k_EMsgGCStore\
    PurchaseInitResponse\x10\xcf\x13\x12&\n!k_EMsgGCToGCBannedWordListUpdate\
    d\x10\xd3\x13\x12\x1e\n\x19k_EMsgGCToGCDirtySDOCache\x10\xd4\x13\x12\"\n\
    \x1dk_EMsgGCToGCUpdateSQLKeyValue\x10\xd6\x13\x12(\n#k_EMsgGCToGCBroadca\
    stConsoleCommand\x10\xd9\x13\x12!\n\x1ck_EMsgGCServerVersionUpdated\x10\
    \xda\x13\x12\x1b\n\x16k_EMsgGCApplyAutograph\x10\xdb\x13\x12%\n\x20k_EMs\
    gGCToGCWebAPIAccountChanged\x10\xdc\x13\x12!\n\x1ck_EMsgGCClientVersionU\
    pdated\x10\xe0\x13\x12!\n\x1ck_EMsgGCToGCUpdateWelcomeMsg\x10\xe1\x13\
    \x12.\n)k_EMsgGCToGCPlayerStrangeCountAdjustments\x10\xe7\x13\x12\"\n\
    \x1dk_EMsgGCRequestStoreSalesData\x10\xe8\x13\x12*\n%k_EMsgGCRequestStor\
    eSalesDataResponse\x10\xe9\x13\x122\n-k_EMsgGCRequestStoreSalesDataUpToD\
    ateResponse\x10\xea\x13\x12\x1c\n\x17k_EMsgGCToGCPingRequest\x10\xeb\x13\
    \x12\x1d\n\x18k_EMsgGCToGCPingResponse\x10\xec\x13\x12%\n\x20k_EMsgGCToG\
    CGetUserSessionServer\x10\xed\x13\x12-\n(k_EMsgGCToGCGetUserSessionServe\
    rResponse\x10\xee\x13\x12%\n\x20k_EMsgGCToGCGetUserServerMembers\x10\xef\
    \x13\x12-\n(k_EMsgGCToGCGetUserServerMembersResponse\x10\xf0\x13\x12$\n\
    \x1fk_EMsgGCToGCCanUseDropRateBonus\x10\xf3\x13\x12\x1e\n\x19k_EMsgSQLAd\
    dDropRateBonus\x10\xf4\x13\x12\x1f\n\x1ak_EMsgGCToGCRefreshSOCache\x10\
    \xf5\x13\x12(\n#k_EMsgGCToGCGrantAccountRolledItems\x10\xfa\x13\x12+\n&k\
    _EMsgGCToGCGrantSelfMadeItemToAccount\x10\xfb\x13\x12\x18\n\x13k_EMsgGCS\
    tatueCraft\x10\x81\x14\x12\x17\n\x12k_EMsgGCRedeemCode\x10\x82\x14\x12\
    \x1f\n\x1ak_EMsgGCRedeemCodeResponse\x10\x83\x14\x12(\n#k_EMsgGCToGCItem\
    ConsumptionRollback\x10\x84\x14\x12'\n\"k_EMsgClientToGCWrapAndDeliverGi\
    ft\x10\x85\x14\x12/\n*k_EMsgClientToGCWrapAndDeliverGiftResponse\x10\x86\
    \x14\x12)\n$k_EMsgClientToGCUnpackBundleResponse\x10\x87\x14\x12.\n)k_EM\
    sgGCToClientStoreTransactionCompleted\x10\x88\x14\x12\x1f\n\x1ak_EMsgCli\
    entToGCEquipItems\x10\x89\x14\x12'\n\"k_EMsgClientToGCEquipItemsResponse\
    \x10\x8a\x14\x12$\n\x1fk_EMsgClientToGCUnlockItemStyle\x10\x8b\x14\x12,\
    \n'k_EMsgClientToGCUnlockItemStyleResponse\x10\x8c\x14\x12-\n(k_EMsgClie\
    ntToGCSetItemInventoryCategory\x10\x8d\x14\x12\x20\n\x1bk_EMsgClientToGC\
    UnlockCrate\x10\x8e\x14\x12(\n#k_EMsgClientToGCUnlockCrateResponse\x10\
    \x8f\x14\x12!\n\x1ck_EMsgClientToGCUnpackBundle\x10\x90\x14\x12!\n\x1ck_\
    EMsgClientToGCSetItemStyle\x10\x91\x14\x12)\n$k_EMsgClientToGCSetItemSty\
    leResponse\x10\x92\x14\x12&\n!k_EMsgSQLGCToGCGrantBackpackSlots\x10\x94\
    \x14\x12&\n!k_EMsgClientToGCLookupAccountName\x10\x95\x14\x12.\n)k_EMsgC\
    lientToGCLookupAccountNameResponse\x10\x96\x14\x12'\n\"k_EMsgClientToGCC\
    reateStaticRecipe\x10\x98\x14\x12/\n*k_EMsgClientToGCCreateStaticRecipeR\
    esponse\x10\x99\x14\x12-\n(k_EMsgGCToGCStoreProcessCDKeyTransaction\x10\
    \x9a\x14\x125\n0k_EMsgGCToGCStoreProcessCDKeyTransactionResponse\x10\x9b\
    \x14\x12'\n\"k_EMsgGCToGCStoreProcessSettlement\x10\x9c\x14\x12/\n*k_EMs\
    gGCToGCStoreProcessSettlementResponse\x10\x9d\x14\x12\x1e\n\x19k_EMsgGCT\
    oGCConsoleOutput\x10\x9e\x14\x12\x1d\n\x18k_EMsgGCToClientItemAges\x10\
    \x9f\x14\x12\x20\n\x1bk_EMsgGCToGCInternalTestMsg\x10\xa0\x14\x12,\n'k_E\
    MsgGCToGCClientServerVersionsUpdated\x10\xa1\x14\x12$\n\x1fk_EMsgGCUseMu\
    ltipleItemsRequest\x10\xa2\x14\x12'\n\"k_EMsgGCGetAccountSubscriptionIte\
    m\x10\xa3\x14\x12/\n*k_EMsgGCGetAccountSubscriptionItemResponse\x10\xa4\
    \x14\x12(\n#k_EMsgGCToGCBroadcastMessageFromSub\x10\xa6\x14\x12(\n#k_EMs\
    gGCToClientCurrencyPricePoints\x10\xa7\x14\x12$\n\x1fk_EMsgGCToGCAddSubs\
    criptionTime\x10\xa8\x14\x12)\n$k_EMsgGCToGCFlushSteamInventoryCache\x10\
    \xa9\x14\x12(\n#k_EMsgGCRequestCrateEscalationLevel\x10\xaa\x14\x120\n+k\
    _EMsgGCRequestCrateEscalationLevelResponse\x10\xab\x14\x12(\n#k_EMsgGCTo\
    GCUpdateSubscriptionItems\x10\xac\x14\x12\x19\n\x14k_EMsgGCToGCSelfPing\
    \x10\xad\x14\x12&\n!k_EMsgGCToGCGetInfuxIntervalStats\x10\xae\x14\x12.\n\
    )k_EMsgGCToGCGetInfuxIntervalStatsResponse\x10\xaf\x14\x12\"\n\x1dk_EMsg\
    GCToGCPurchaseSucceeded\x10\xb0\x14\x123\n.k_EMsgClientToGCGetLimitedIte\
    mPurchaseQuantity\x10\xb1\x14\x12;\n6k_EMsgClientToGCGetLimitedItemPurch\
    aseQuantityResponse\x10\xb2\x14\x12\x20\n\x1bk_EMsgGCToGCBetaDeleteItems\
    \x10\xb3\x14*\xb9\n\n\x1bEGCMsgInitiateTradeResponse\x12*\n&k_EGCMsgInit\
    iateTradeResponse_Accepted\x10\0\x12*\n&k_EGCMsgInitiateTradeResponse_De\
    clined\x10\x01\x126\n2k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator\
    \x10\x02\x123\n/k_EGCMsgInitiateTradeResponse_VAC_Banned_Target\x10\x03\
    \x128\n4k_EGCMsgInitiateTradeResponse_Target_Already_Trading\x10\x04\x12\
    *\n&k_EGCMsgInitiateTradeResponse_Disabled\x10\x05\x12-\n)k_EGCMsgInitia\
    teTradeResponse_NotLoggedIn\x10\x06\x12(\n$k_EGCMsgInitiateTradeResponse\
    _Cancel\x10\x07\x12)\n%k_EGCMsgInitiateTradeResponse_TooSoon\x10\x08\x12\
    0\n,k_EGCMsgInitiateTradeResponse_TooSoonPenalty\x10\t\x128\n4k_EGCMsgIn\
    itiateTradeResponse_Trade_Banned_Initiator\x10\n\x125\n1k_EGCMsgInitiate\
    TradeResponse_Trade_Banned_Target\x10\x0b\x12C\n?k_EGCMsgInitiateTradeRe\
    sponse_Free_Account_Initiator_DEPRECATED\x10\x0c\x12:\n6k_EGCMsgInitiate\
    TradeResponse_Shared_Account_Initiator\x10\r\x125\n1k_EGCMsgInitiateTrad\
    eResponse_Service_Unavailable\x10\x0e\x120\n,k_EGCMsgInitiateTradeRespon\
    se_Target_Blocked\x10\x0f\x123\n/k_EGCMsgInitiateTradeResponse_NeedVerif\
    iedEmail\x10\x10\x120\n,k_EGCMsgInitiateTradeResponse_NeedSteamGuard\x10\
    \x11\x124\n0k_EGCMsgInitiateTradeResponse_SteamGuardDuration\x10\x12\x12\
    1\n-k_EGCMsgInitiateTradeResponse_TheyCannotTrade\x10\x13\x127\n3k_EGCMs\
    gInitiateTradeResponse_Recent_Password_Reset\x10\x14\x122\n.k_EGCMsgInit\
    iateTradeResponse_Using_New_Device\x10\x15\x125\n1k_EGCMsgInitiateTradeR\
    esponse_Sent_Invalid_Cookie\x10\x16\x121\n-k_EGCMsgInitiateTradeResponse\
    _TooRecentFriend\x10\x17\x127\n3k_EGCMsgInitiateTradeResponse_WalledFund\
    sNotTrusted\x10\x18B%Z#github.com/dotabuff/manta/dota;dotaJ\xd8\xad\x02\
    \n\x07\x12\x05\0\0\xc5\x07\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\
    \x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\
    \x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\n\t\n\x02\
    \x03\x01\x12\x03\x06\x07\x20\n\t\n\x02\x03\x02\x12\x03\x07\x07\x1f\n\x0b\
    \n\x02\x05\0\x12\x05\t\0\x84\x01\x01\n\n\n\x03\x05\0\x01\x12\x03\t\x05\
    \x0f\n\x0b\n\x04\x05\0\x02\0\x12\x03\n\x08\x1c\n\x0c\n\x05\x05\0\x02\0\
    \x01\x12\x03\n\x08\x14\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\n\x17\x1b\n\
    \x0b\n\x04\x05\0\x02\x01\x12\x03\x0b\x08'\n\x0c\n\x05\x05\0\x02\x01\x01\
    \x12\x03\x0b\x08\x1f\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x0b\"&\n\x0b\
    \n\x04\x05\0\x02\x02\x12\x03\x0c\x08\x1e\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x03\x0c\x08\x16\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0c\x19\x1d\n\
    \x0b\n\x04\x05\0\x02\x03\x12\x03\r\x08/\n\x0c\n\x05\x05\0\x02\x03\x01\
    \x12\x03\r\x08'\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\r*.\n\x0b\n\x04\
    \x05\0\x02\x04\x12\x03\x0e\x08(\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\
    \x0e\x08\x20\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0e#'\n\x0b\n\x04\x05\
    \0\x02\x05\x12\x03\x0f\x08!\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0f\
    \x08\x19\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0f\x1c\x20\n\x0b\n\x04\
    \x05\0\x02\x06\x12\x03\x10\x08)\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\
    \x10\x08!\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x10$(\n\x0b\n\x04\x05\0\
    \x02\x07\x12\x03\x11\x08$\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x11\x08\
    \x1c\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x11\x1f#\n\x0b\n\x04\x05\0\
    \x02\x08\x12\x03\x12\x08,\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x12\x08$\
    \n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x12'+\n\x0b\n\x04\x05\0\x02\t\x12\
    \x03\x13\x08&\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x13\x08\x1e\n\x0c\n\
    \x05\x05\0\x02\t\x02\x12\x03\x13!%\n\x0b\n\x04\x05\0\x02\n\x12\x03\x14\
    \x08'\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x14\x08\x1f\n\x0c\n\x05\x05\0\
    \x02\n\x02\x12\x03\x14\"&\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x15\x08#\n\
    \x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x15\x08\x1b\n\x0c\n\x05\x05\0\x02\
    \x0b\x02\x12\x03\x15\x1e\"\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x16\x08)\n\
    \x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x16\x08!\n\x0c\n\x05\x05\0\x02\x0c\
    \x02\x12\x03\x16$(\n\x0b\n\x04\x05\0\x02\r\x12\x03\x17\x08*\n\x0c\n\x05\
    \x05\0\x02\r\x01\x12\x03\x17\x08\"\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\
    \x17%)\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x18\x08!\n\x0c\n\x05\x05\0\x02\
    \x0e\x01\x12\x03\x18\x08\x19\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x18\
    \x1c\x20\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x19\x08,\n\x0c\n\x05\x05\0\
    \x02\x0f\x01\x12\x03\x19\x08$\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x19'\
    +\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x1a\x08/\n\x0c\n\x05\x05\0\x02\x10\
    \x01\x12\x03\x1a\x08'\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x1a*.\n\x0b\
    \n\x04\x05\0\x02\x11\x12\x03\x1b\x08(\n\x0c\n\x05\x05\0\x02\x11\x01\x12\
    \x03\x1b\x08\x20\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x1b#'\n\x0b\n\x04\
    \x05\0\x02\x12\x12\x03\x1c\x080\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\
    \x1c\x08(\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x1c+/\n\x0b\n\x04\x05\0\
    \x02\x13\x12\x03\x1d\x08(\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x1d\x08\
    \x20\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\x1d#'\n\x0b\n\x04\x05\0\x02\
    \x14\x12\x03\x1e\x08+\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1e\x08#\n\
    \x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x1e&*\n\x0b\n\x04\x05\0\x02\x15\x12\
    \x03\x1f\x08(\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1f\x08\x20\n\x0c\n\
    \x05\x05\0\x02\x15\x02\x12\x03\x1f#'\n\x0b\n\x04\x05\0\x02\x16\x12\x03\
    \x20\x08'\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x20\x08\x1f\n\x0c\n\x05\
    \x05\0\x02\x16\x02\x12\x03\x20\"&\n\x0b\n\x04\x05\0\x02\x17\x12\x03!\x08\
    .\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03!\x08&\n\x0c\n\x05\x05\0\x02\x17\
    \x02\x12\x03!)-\n\x0b\n\x04\x05\0\x02\x18\x12\x03\"\x08#\n\x0c\n\x05\x05\
    \0\x02\x18\x01\x12\x03\"\x08\x1b\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03\"\
    \x1e\"\n\x0b\n\x04\x05\0\x02\x19\x12\x03#\x08!\n\x0c\n\x05\x05\0\x02\x19\
    \x01\x12\x03#\x08\x19\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03#\x1c\x20\n\
    \x0b\n\x04\x05\0\x02\x1a\x12\x03$\x08'\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\
    \x03$\x08\x1f\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03$\"&\n\x0b\n\x04\x05\
    \0\x02\x1b\x12\x03%\x08/\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03%\x08'\n\
    \x0c\n\x05\x05\0\x02\x1b\x02\x12\x03%*.\n\x0b\n\x04\x05\0\x02\x1c\x12\
    \x03&\x08)\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03&\x08!\n\x0c\n\x05\x05\0\
    \x02\x1c\x02\x12\x03&$(\n\x0b\n\x04\x05\0\x02\x1d\x12\x03'\x08,\n\x0c\n\
    \x05\x05\0\x02\x1d\x01\x12\x03'\x08$\n\x0c\n\x05\x05\0\x02\x1d\x02\x12\
    \x03''+\n\x0b\n\x04\x05\0\x02\x1e\x12\x03(\x08)\n\x0c\n\x05\x05\0\x02\
    \x1e\x01\x12\x03(\x08!\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\x03($(\n\x0b\n\
    \x04\x05\0\x02\x1f\x12\x03)\x081\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\x03)\
    \x08)\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x03),0\n\x0b\n\x04\x05\0\x02\x20\
    \x12\x03*\x08+\n\x0c\n\x05\x05\0\x02\x20\x01\x12\x03*\x08#\n\x0c\n\x05\
    \x05\0\x02\x20\x02\x12\x03*&*\n\x0b\n\x04\x05\0\x02!\x12\x03+\x084\n\x0c\
    \n\x05\x05\0\x02!\x01\x12\x03+\x08,\n\x0c\n\x05\x05\0\x02!\x02\x12\x03+/\
    3\n\x0b\n\x04\x05\0\x02\"\x12\x03,\x08,\n\x0c\n\x05\x05\0\x02\"\x01\x12\
    \x03,\x08$\n\x0c\n\x05\x05\0\x02\"\x02\x12\x03,'+\n\x0b\n\x04\x05\0\x02#\
    \x12\x03-\x08#\n\x0c\n\x05\x05\0\x02#\x01\x12\x03-\x08\x1b\n\x0c\n\x05\
    \x05\0\x02#\x02\x12\x03-\x1e\"\n\x0b\n\x04\x05\0\x02$\x12\x03.\x08:\n\
    \x0c\n\x05\x05\0\x02$\x01\x12\x03.\x082\n\x0c\n\x05\x05\0\x02$\x02\x12\
    \x03.59\n\x0b\n\x04\x05\0\x02%\x12\x03/\x08.\n\x0c\n\x05\x05\0\x02%\x01\
    \x12\x03/\x08&\n\x0c\n\x05\x05\0\x02%\x02\x12\x03/)-\n\x0b\n\x04\x05\0\
    \x02&\x12\x030\x085\n\x0c\n\x05\x05\0\x02&\x01\x12\x030\x08-\n\x0c\n\x05\
    \x05\0\x02&\x02\x12\x03004\n\x0b\n\x04\x05\0\x02'\x12\x031\x08;\n\x0c\n\
    \x05\x05\0\x02'\x01\x12\x031\x083\n\x0c\n\x05\x05\0\x02'\x02\x12\x0316:\
    \n\x0b\n\x04\x05\0\x02(\x12\x032\x08*\n\x0c\n\x05\x05\0\x02(\x01\x12\x03\
    2\x08\"\n\x0c\n\x05\x05\0\x02(\x02\x12\x032%)\n\x0b\n\x04\x05\0\x02)\x12\
    \x033\x082\n\x0c\n\x05\x05\0\x02)\x01\x12\x033\x08*\n\x0c\n\x05\x05\0\
    \x02)\x02\x12\x033-1\n\x0b\n\x04\x05\0\x02*\x12\x034\x086\n\x0c\n\x05\
    \x05\0\x02*\x01\x12\x034\x08.\n\x0c\n\x05\x05\0\x02*\x02\x12\x03415\n\
    \x0b\n\x04\x05\0\x02+\x12\x035\x087\n\x0c\n\x05\x05\0\x02+\x01\x12\x035\
    \x08/\n\x0c\n\x05\x05\0\x02+\x02\x12\x03526\n\x0b\n\x04\x05\0\x02,\x12\
    \x036\x08-\n\x0c\n\x05\x05\0\x02,\x01\x12\x036\x08%\n\x0c\n\x05\x05\0\
    \x02,\x02\x12\x036(,\n\x0b\n\x04\x05\0\x02-\x12\x037\x085\n\x0c\n\x05\
    \x05\0\x02-\x01\x12\x037\x08-\n\x0c\n\x05\x05\0\x02-\x02\x12\x03704\n\
    \x0b\n\x04\x05\0\x02.\x12\x038\x08+\n\x0c\n\x05\x05\0\x02.\x01\x12\x038\
    \x08#\n\x0c\n\x05\x05\0\x02.\x02\x12\x038&*\n\x0b\n\x04\x05\0\x02/\x12\
    \x039\x083\n\x0c\n\x05\x05\0\x02/\x01\x12\x039\x08+\n\x0c\n\x05\x05\0\
    \x02/\x02\x12\x039.2\n\x0b\n\x04\x05\0\x020\x12\x03:\x08)\n\x0c\n\x05\
    \x05\0\x020\x01\x12\x03:\x08!\n\x0c\n\x05\x05\0\x020\x02\x12\x03:$(\n\
    \x0b\n\x04\x05\0\x021\x12\x03;\x081\n\x0c\n\x05\x05\0\x021\x01\x12\x03;\
    \x08)\n\x0c\n\x05\x05\0\x021\x02\x12\x03;,0\n\x0b\n\x04\x05\0\x022\x12\
    \x03<\x081\n\x0c\n\x05\x05\0\x022\x01\x12\x03<\x08)\n\x0c\n\x05\x05\0\
    \x022\x02\x12\x03<,0\n\x0b\n\x04\x05\0\x023\x12\x03=\x08)\n\x0c\n\x05\
    \x05\0\x023\x01\x12\x03=\x08!\n\x0c\n\x05\x05\0\x023\x02\x12\x03=$(\n\
    \x0b\n\x04\x05\0\x024\x12\x03>\x08-\n\x0c\n\x05\x05\0\x024\x01\x12\x03>\
    \x08%\n\x0c\n\x05\x05\0\x024\x02\x12\x03>(,\n\x0b\n\x04\x05\0\x025\x12\
    \x03?\x083\n\x0c\n\x05\x05\0\x025\x01\x12\x03?\x08+\n\x0c\n\x05\x05\0\
    \x025\x02\x12\x03?.2\n\x0b\n\x04\x05\0\x026\x12\x03@\x08,\n\x0c\n\x05\
    \x05\0\x026\x01\x12\x03@\x08$\n\x0c\n\x05\x05\0\x026\x02\x12\x03@'+\n\
    \x0b\n\x04\x05\0\x027\x12\x03A\x08&\n\x0c\n\x05\x05\0\x027\x01\x12\x03A\
    \x08\x1e\n\x0c\n\x05\x05\0\x027\x02\x12\x03A!%\n\x0b\n\x04\x05\0\x028\
    \x12\x03B\x080\n\x0c\n\x05\x05\0\x028\x01\x12\x03B\x08(\n\x0c\n\x05\x05\
    \0\x028\x02\x12\x03B+/\n\x0b\n\x04\x05\0\x029\x12\x03C\x08,\n\x0c\n\x05\
    \x05\0\x029\x01\x12\x03C\x08$\n\x0c\n\x05\x05\0\x029\x02\x12\x03C'+\n\
    \x0b\n\x04\x05\0\x02:\x12\x03D\x08,\n\x0c\n\x05\x05\0\x02:\x01\x12\x03D\
    \x08$\n\x0c\n\x05\x05\0\x02:\x02\x12\x03D'+\n\x0b\n\x04\x05\0\x02;\x12\
    \x03E\x089\n\x0c\n\x05\x05\0\x02;\x01\x12\x03E\x081\n\x0c\n\x05\x05\0\
    \x02;\x02\x12\x03E48\n\x0b\n\x04\x05\0\x02<\x12\x03F\x08-\n\x0c\n\x05\
    \x05\0\x02<\x01\x12\x03F\x08%\n\x0c\n\x05\x05\0\x02<\x02\x12\x03F(,\n\
    \x0b\n\x04\x05\0\x02=\x12\x03G\x085\n\x0c\n\x05\x05\0\x02=\x01\x12\x03G\
    \x08-\n\x0c\n\x05\x05\0\x02=\x02\x12\x03G04\n\x0b\n\x04\x05\0\x02>\x12\
    \x03H\x08=\n\x0c\n\x05\x05\0\x02>\x01\x12\x03H\x085\n\x0c\n\x05\x05\0\
    \x02>\x02\x12\x03H8<\n\x0b\n\x04\x05\0\x02?\x12\x03I\x08'\n\x0c\n\x05\
    \x05\0\x02?\x01\x12\x03I\x08\x1f\n\x0c\n\x05\x05\0\x02?\x02\x12\x03I\"&\
    \n\x0b\n\x04\x05\0\x02@\x12\x03J\x08(\n\x0c\n\x05\x05\0\x02@\x01\x12\x03\
    J\x08\x20\n\x0c\n\x05\x05\0\x02@\x02\x12\x03J#'\n\x0b\n\x04\x05\0\x02A\
    \x12\x03K\x080\n\x0c\n\x05\x05\0\x02A\x01\x12\x03K\x08(\n\x0c\n\x05\x05\
    \0\x02A\x02\x12\x03K+/\n\x0b\n\x04\x05\0\x02B\x12\x03L\x088\n\x0c\n\x05\
    \x05\0\x02B\x01\x12\x03L\x080\n\x0c\n\x05\x05\0\x02B\x02\x12\x03L37\n\
    \x0b\n\x04\x05\0\x02C\x12\x03M\x080\n\x0c\n\x05\x05\0\x02C\x01\x12\x03M\
    \x08(\n\x0c\n\x05\x05\0\x02C\x02\x12\x03M+/\n\x0b\n\x04\x05\0\x02D\x12\
    \x03N\x088\n\x0c\n\x05\x05\0\x02D\x01\x12\x03N\x080\n\x0c\n\x05\x05\0\
    \x02D\x02\x12\x03N37\n\x0b\n\x04\x05\0\x02E\x12\x03O\x08/\n\x0c\n\x05\
    \x05\0\x02E\x01\x12\x03O\x08'\n\x0c\n\x05\x05\0\x02E\x02\x12\x03O*.\n\
    \x0b\n\x04\x05\0\x02F\x12\x03P\x08)\n\x0c\n\x05\x05\0\x02F\x01\x12\x03P\
    \x08!\n\x0c\n\x05\x05\0\x02F\x02\x12\x03P$(\n\x0b\n\x04\x05\0\x02G\x12\
    \x03Q\x08*\n\x0c\n\x05\x05\0\x02G\x01\x12\x03Q\x08\"\n\x0c\n\x05\x05\0\
    \x02G\x02\x12\x03Q%)\n\x0b\n\x04\x05\0\x02H\x12\x03R\x083\n\x0c\n\x05\
    \x05\0\x02H\x01\x12\x03R\x08+\n\x0c\n\x05\x05\0\x02H\x02\x12\x03R.2\n\
    \x0b\n\x04\x05\0\x02I\x12\x03S\x086\n\x0c\n\x05\x05\0\x02I\x01\x12\x03S\
    \x08.\n\x0c\n\x05\x05\0\x02I\x02\x12\x03S15\n\x0b\n\x04\x05\0\x02J\x12\
    \x03T\x08#\n\x0c\n\x05\x05\0\x02J\x01\x12\x03T\x08\x1b\n\x0c\n\x05\x05\0\
    \x02J\x02\x12\x03T\x1e\"\n\x0b\n\x04\x05\0\x02K\x12\x03U\x08\"\n\x0c\n\
    \x05\x05\0\x02K\x01\x12\x03U\x08\x1a\n\x0c\n\x05\x05\0\x02K\x02\x12\x03U\
    \x1d!\n\x0b\n\x04\x05\0\x02L\x12\x03V\x08*\n\x0c\n\x05\x05\0\x02L\x01\
    \x12\x03V\x08\"\n\x0c\n\x05\x05\0\x02L\x02\x12\x03V%)\n\x0b\n\x04\x05\0\
    \x02M\x12\x03W\x083\n\x0c\n\x05\x05\0\x02M\x01\x12\x03W\x08+\n\x0c\n\x05\
    \x05\0\x02M\x02\x12\x03W.2\n\x0b\n\x04\x05\0\x02N\x12\x03X\x082\n\x0c\n\
    \x05\x05\0\x02N\x01\x12\x03X\x08*\n\x0c\n\x05\x05\0\x02N\x02\x12\x03X-1\
    \n\x0b\n\x04\x05\0\x02O\x12\x03Y\x08:\n\x0c\n\x05\x05\0\x02O\x01\x12\x03\
    Y\x082\n\x0c\n\x05\x05\0\x02O\x02\x12\x03Y59\n\x0b\n\x04\x05\0\x02P\x12\
    \x03Z\x084\n\x0c\n\x05\x05\0\x02P\x01\x12\x03Z\x08,\n\x0c\n\x05\x05\0\
    \x02P\x02\x12\x03Z/3\n\x0b\n\x04\x05\0\x02Q\x12\x03[\x089\n\x0c\n\x05\
    \x05\0\x02Q\x01\x12\x03[\x081\n\x0c\n\x05\x05\0\x02Q\x02\x12\x03[48\n\
    \x0b\n\x04\x05\0\x02R\x12\x03\\\x08*\n\x0c\n\x05\x05\0\x02R\x01\x12\x03\
    \\\x08\"\n\x0c\n\x05\x05\0\x02R\x02\x12\x03\\%)\n\x0b\n\x04\x05\0\x02S\
    \x12\x03]\x082\n\x0c\n\x05\x05\0\x02S\x01\x12\x03]\x08*\n\x0c\n\x05\x05\
    \0\x02S\x02\x12\x03]-1\n\x0b\n\x04\x05\0\x02T\x12\x03^\x08/\n\x0c\n\x05\
    \x05\0\x02T\x01\x12\x03^\x08'\n\x0c\n\x05\x05\0\x02T\x02\x12\x03^*.\n\
    \x0b\n\x04\x05\0\x02U\x12\x03_\x087\n\x0c\n\x05\x05\0\x02U\x01\x12\x03_\
    \x08/\n\x0c\n\x05\x05\0\x02U\x02\x12\x03_26\n\x0b\n\x04\x05\0\x02V\x12\
    \x03`\x088\n\x0c\n\x05\x05\0\x02V\x01\x12\x03`\x080\n\x0c\n\x05\x05\0\
    \x02V\x02\x12\x03`37\n\x0b\n\x04\x05\0\x02W\x12\x03a\x08+\n\x0c\n\x05\
    \x05\0\x02W\x01\x12\x03a\x08#\n\x0c\n\x05\x05\0\x02W\x02\x12\x03a&*\n\
    \x0b\n\x04\x05\0\x02X\x12\x03b\x083\n\x0c\n\x05\x05\0\x02X\x01\x12\x03b\
    \x08+\n\x0c\n\x05\x05\0\x02X\x02\x12\x03b.2\n\x0b\n\x04\x05\0\x02Y\x12\
    \x03c\x08,\n\x0c\n\x05\x05\0\x02Y\x01\x12\x03c\x08$\n\x0c\n\x05\x05\0\
    \x02Y\x02\x12\x03c'+\n\x0b\n\x04\x05\0\x02Z\x12\x03d\x08,\n\x0c\n\x05\
    \x05\0\x02Z\x01\x12\x03d\x08$\n\x0c\n\x05\x05\0\x02Z\x02\x12\x03d'+\n\
    \x0b\n\x04\x05\0\x02[\x12\x03e\x084\n\x0c\n\x05\x05\0\x02[\x01\x12\x03e\
    \x08,\n\x0c\n\x05\x05\0\x02[\x02\x12\x03e/3\n\x0b\n\x04\x05\0\x02\\\x12\
    \x03f\x081\n\x0c\n\x05\x05\0\x02\\\x01\x12\x03f\x08)\n\x0c\n\x05\x05\0\
    \x02\\\x02\x12\x03f,0\n\x0b\n\x04\x05\0\x02]\x12\x03g\x081\n\x0c\n\x05\
    \x05\0\x02]\x01\x12\x03g\x08)\n\x0c\n\x05\x05\0\x02]\x02\x12\x03g,0\n\
    \x0b\n\x04\x05\0\x02^\x12\x03h\x089\n\x0c\n\x05\x05\0\x02^\x01\x12\x03h\
    \x081\n\x0c\n\x05\x05\0\x02^\x02\x12\x03h48\n\x0b\n\x04\x05\0\x02_\x12\
    \x03i\x082\n\x0c\n\x05\x05\0\x02_\x01\x12\x03i\x08*\n\x0c\n\x05\x05\0\
    \x02_\x02\x12\x03i-1\n\x0b\n\x04\x05\0\x02`\x12\x03j\x08:\n\x0c\n\x05\
    \x05\0\x02`\x01\x12\x03j\x082\n\x0c\n\x05\x05\0\x02`\x02\x12\x03j59\n\
    \x0b\n\x04\x05\0\x02a\x12\x03k\x088\n\x0c\n\x05\x05\0\x02a\x01\x12\x03k\
    \x080\n\x0c\n\x05\x05\0\x02a\x02\x12\x03k37\n\x0b\n\x04\x05\0\x02b\x12\
    \x03l\x08@\n\x0c\n\x05\x05\0\x02b\x01\x12\x03l\x088\n\x0c\n\x05\x05\0\
    \x02b\x02\x12\x03l;?\n\x0b\n\x04\x05\0\x02c\x12\x03m\x082\n\x0c\n\x05\
    \x05\0\x02c\x01\x12\x03m\x08*\n\x0c\n\x05\x05\0\x02c\x02\x12\x03m-1\n\
    \x0b\n\x04\x05\0\x02d\x12\x03n\x08:\n\x0c\n\x05\x05\0\x02d\x01\x12\x03n\
    \x082\n\x0c\n\x05\x05\0\x02d\x02\x12\x03n59\n\x0b\n\x04\x05\0\x02e\x12\
    \x03o\x08)\n\x0c\n\x05\x05\0\x02e\x01\x12\x03o\x08!\n\x0c\n\x05\x05\0\
    \x02e\x02\x12\x03o$(\n\x0b\n\x04\x05\0\x02f\x12\x03p\x08(\n\x0c\n\x05\
    \x05\0\x02f\x01\x12\x03p\x08\x20\n\x0c\n\x05\x05\0\x02f\x02\x12\x03p#'\n\
    \x0b\n\x04\x05\0\x02g\x12\x03q\x08+\n\x0c\n\x05\x05\0\x02g\x01\x12\x03q\
    \x08#\n\x0c\n\x05\x05\0\x02g\x02\x12\x03q&*\n\x0b\n\x04\x05\0\x02h\x12\
    \x03r\x087\n\x0c\n\x05\x05\0\x02h\x01\x12\x03r\x08/\n\x0c\n\x05\x05\0\
    \x02h\x02\x12\x03r26\n\x0b\n\x04\x05\0\x02i\x12\x03s\x08/\n\x0c\n\x05\
    \x05\0\x02i\x01\x12\x03s\x08'\n\x0c\n\x05\x05\0\x02i\x02\x12\x03s*.\n\
    \x0b\n\x04\x05\0\x02j\x12\x03t\x082\n\x0c\n\x05\x05\0\x02j\x01\x12\x03t\
    \x08*\n\x0c\n\x05\x05\0\x02j\x02\x12\x03t-1\n\x0b\n\x04\x05\0\x02k\x12\
    \x03u\x08:\n\x0c\n\x05\x05\0\x02k\x01\x12\x03u\x082\n\x0c\n\x05\x05\0\
    \x02k\x02\x12\x03u59\n\x0b\n\x04\x05\0\x02l\x12\x03v\x083\n\x0c\n\x05\
    \x05\0\x02l\x01\x12\x03v\x08+\n\x0c\n\x05\x05\0\x02l\x02\x12\x03v.2\n\
    \x0b\n\x04\x05\0\x02m\x12\x03w\x083\n\x0c\n\x05\x05\0\x02m\x01\x12\x03w\
    \x08+\n\x0c\n\x05\x05\0\x02m\x02\x12\x03w.2\n\x0b\n\x04\x05\0\x02n\x12\
    \x03x\x08/\n\x0c\n\x05\x05\0\x02n\x01\x12\x03x\x08'\n\x0c\n\x05\x05\0\
    \x02n\x02\x12\x03x*.\n\x0b\n\x04\x05\0\x02o\x12\x03y\x084\n\x0c\n\x05\
    \x05\0\x02o\x01\x12\x03y\x08,\n\x0c\n\x05\x05\0\x02o\x02\x12\x03y/3\n\
    \x0b\n\x04\x05\0\x02p\x12\x03z\x083\n\x0c\n\x05\x05\0\x02p\x01\x12\x03z\
    \x08+\n\x0c\n\x05\x05\0\x02p\x02\x12\x03z.2\n\x0b\n\x04\x05\0\x02q\x12\
    \x03{\x08;\n\x0c\n\x05\x05\0\x02q\x01\x12\x03{\x083\n\x0c\n\x05\x05\0\
    \x02q\x02\x12\x03{6:\n\x0b\n\x04\x05\0\x02r\x12\x03|\x083\n\x0c\n\x05\
    \x05\0\x02r\x01\x12\x03|\x08+\n\x0c\n\x05\x05\0\x02r\x02\x12\x03|.2\n\
    \x0b\n\x04\x05\0\x02s\x12\x03}\x08$\n\x0c\n\x05\x05\0\x02s\x01\x12\x03}\
    \x08\x1c\n\x0c\n\x05\x05\0\x02s\x02\x12\x03}\x1f#\n\x0b\n\x04\x05\0\x02t\
    \x12\x03~\x081\n\x0c\n\x05\x05\0\x02t\x01\x12\x03~\x08)\n\x0c\n\x05\x05\
    \0\x02t\x02\x12\x03~,0\n\x0b\n\x04\x05\0\x02u\x12\x03\x7f\x089\n\x0c\n\
    \x05\x05\0\x02u\x01\x12\x03\x7f\x081\n\x0c\n\x05\x05\0\x02u\x02\x12\x03\
    \x7f48\n\x0c\n\x04\x05\0\x02v\x12\x04\x80\x01\x08-\n\r\n\x05\x05\0\x02v\
    \x01\x12\x04\x80\x01\x08%\n\r\n\x05\x05\0\x02v\x02\x12\x04\x80\x01(,\n\
    \x0c\n\x04\x05\0\x02w\x12\x04\x81\x01\x08>\n\r\n\x05\x05\0\x02w\x01\x12\
    \x04\x81\x01\x086\n\r\n\x05\x05\0\x02w\x02\x12\x04\x81\x019=\n\x0c\n\x04\
    \x05\0\x02x\x12\x04\x82\x01\x08F\n\r\n\x05\x05\0\x02x\x01\x12\x04\x82\
    \x01\x08>\n\r\n\x05\x05\0\x02x\x02\x12\x04\x82\x01AE\n\x0c\n\x04\x05\0\
    \x02y\x12\x04\x83\x01\x08+\n\r\n\x05\x05\0\x02y\x01\x12\x04\x83\x01\x08#\
    \n\r\n\x05\x05\0\x02y\x02\x12\x04\x83\x01&*\n\x0c\n\x02\x05\x01\x12\x06\
    \x86\x01\0\xa0\x01\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\x86\x01\x05\x20\n\
    \x0c\n\x04\x05\x01\x02\0\x12\x04\x87\x01\x083\n\r\n\x05\x05\x01\x02\0\
    \x01\x12\x04\x87\x01\x08.\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\x87\x0112\
    \n\x0c\n\x04\x05\x01\x02\x01\x12\x04\x88\x01\x083\n\r\n\x05\x05\x01\x02\
    \x01\x01\x12\x04\x88\x01\x08.\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\x88\
    \x0112\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\x89\x01\x08?\n\r\n\x05\x05\
    \x01\x02\x02\x01\x12\x04\x89\x01\x08:\n\r\n\x05\x05\x01\x02\x02\x02\x12\
    \x04\x89\x01=>\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\x8a\x01\x08<\n\r\n\
    \x05\x05\x01\x02\x03\x01\x12\x04\x8a\x01\x087\n\r\n\x05\x05\x01\x02\x03\
    \x02\x12\x04\x8a\x01:;\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\x8b\x01\x08A\
    \n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\x8b\x01\x08<\n\r\n\x05\x05\x01\
    \x02\x04\x02\x12\x04\x8b\x01?@\n\x0c\n\x04\x05\x01\x02\x05\x12\x04\x8c\
    \x01\x083\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\x8c\x01\x08.\n\r\n\x05\
    \x05\x01\x02\x05\x02\x12\x04\x8c\x0112\n\x0c\n\x04\x05\x01\x02\x06\x12\
    \x04\x8d\x01\x086\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\x8d\x01\x081\n\r\
    \n\x05\x05\x01\x02\x06\x02\x12\x04\x8d\x0145\n\x0c\n\x04\x05\x01\x02\x07\
    \x12\x04\x8e\x01\x081\n\r\n\x05\x05\x01\x02\x07\x01\x12\x04\x8e\x01\x08,\
    \n\r\n\x05\x05\x01\x02\x07\x02\x12\x04\x8e\x01/0\n\x0c\n\x04\x05\x01\x02\
    \x08\x12\x04\x8f\x01\x082\n\r\n\x05\x05\x01\x02\x08\x01\x12\x04\x8f\x01\
    \x08-\n\r\n\x05\x05\x01\x02\x08\x02\x12\x04\x8f\x0101\n\x0c\n\x04\x05\
    \x01\x02\t\x12\x04\x90\x01\x089\n\r\n\x05\x05\x01\x02\t\x01\x12\x04\x90\
    \x01\x084\n\r\n\x05\x05\x01\x02\t\x02\x12\x04\x90\x0178\n\x0c\n\x04\x05\
    \x01\x02\n\x12\x04\x91\x01\x08B\n\r\n\x05\x05\x01\x02\n\x01\x12\x04\x91\
    \x01\x08<\n\r\n\x05\x05\x01\x02\n\x02\x12\x04\x91\x01?A\n\x0c\n\x04\x05\
    \x01\x02\x0b\x12\x04\x92\x01\x08?\n\r\n\x05\x05\x01\x02\x0b\x01\x12\x04\
    \x92\x01\x089\n\r\n\x05\x05\x01\x02\x0b\x02\x12\x04\x92\x01<>\n\x0c\n\
    \x04\x05\x01\x02\x0c\x12\x04\x93\x01\x08M\n\r\n\x05\x05\x01\x02\x0c\x01\
    \x12\x04\x93\x01\x08G\n\r\n\x05\x05\x01\x02\x0c\x02\x12\x04\x93\x01JL\n\
    \x0c\n\x04\x05\x01\x02\r\x12\x04\x94\x01\x08D\n\r\n\x05\x05\x01\x02\r\
    \x01\x12\x04\x94\x01\x08>\n\r\n\x05\x05\x01\x02\r\x02\x12\x04\x94\x01AC\
    \n\x0c\n\x04\x05\x01\x02\x0e\x12\x04\x95\x01\x08?\n\r\n\x05\x05\x01\x02\
    \x0e\x01\x12\x04\x95\x01\x089\n\r\n\x05\x05\x01\x02\x0e\x02\x12\x04\x95\
    \x01<>\n\x0c\n\x04\x05\x01\x02\x0f\x12\x04\x96\x01\x08:\n\r\n\x05\x05\
    \x01\x02\x0f\x01\x12\x04\x96\x01\x084\n\r\n\x05\x05\x01\x02\x0f\x02\x12\
    \x04\x96\x0179\n\x0c\n\x04\x05\x01\x02\x10\x12\x04\x97\x01\x08=\n\r\n\
    \x05\x05\x01\x02\x10\x01\x12\x04\x97\x01\x087\n\r\n\x05\x05\x01\x02\x10\
    \x02\x12\x04\x97\x01:<\n\x0c\n\x04\x05\x01\x02\x11\x12\x04\x98\x01\x08:\
    \n\r\n\x05\x05\x01\x02\x11\x01\x12\x04\x98\x01\x084\n\r\n\x05\x05\x01\
    \x02\x11\x02\x12\x04\x98\x0179\n\x0c\n\x04\x05\x01\x02\x12\x12\x04\x99\
    \x01\x08>\n\r\n\x05\x05\x01\x02\x12\x01\x12\x04\x99\x01\x088\n\r\n\x05\
    \x05\x01\x02\x12\x02\x12\x04\x99\x01;=\n\x0c\n\x04\x05\x01\x02\x13\x12\
    \x04\x9a\x01\x08;\n\r\n\x05\x05\x01\x02\x13\x01\x12\x04\x9a\x01\x085\n\r\
    \n\x05\x05\x01\x02\x13\x02\x12\x04\x9a\x018:\n\x0c\n\x04\x05\x01\x02\x14\
    \x12\x04\x9b\x01\x08A\n\r\n\x05\x05\x01\x02\x14\x01\x12\x04\x9b\x01\x08;\
    \n\r\n\x05\x05\x01\x02\x14\x02\x12\x04\x9b\x01>@\n\x0c\n\x04\x05\x01\x02\
    \x15\x12\x04\x9c\x01\x08<\n\r\n\x05\x05\x01\x02\x15\x01\x12\x04\x9c\x01\
    \x086\n\r\n\x05\x05\x01\x02\x15\x02\x12\x04\x9c\x019;\n\x0c\n\x04\x05\
    \x01\x02\x16\x12\x04\x9d\x01\x08?\n\r\n\x05\x05\x01\x02\x16\x01\x12\x04\
    \x9d\x01\x089\n\r\n\x05\x05\x01\x02\x16\x02\x12\x04\x9d\x01<>\n\x0c\n\
    \x04\x05\x01\x02\x17\x12\x04\x9e\x01\x08;\n\r\n\x05\x05\x01\x02\x17\x01\
    \x12\x04\x9e\x01\x085\n\r\n\x05\x05\x01\x02\x17\x02\x12\x04\x9e\x018:\n\
    \x0c\n\x04\x05\x01\x02\x18\x12\x04\x9f\x01\x08A\n\r\n\x05\x05\x01\x02\
    \x18\x01\x12\x04\x9f\x01\x08;\n\r\n\x05\x05\x01\x02\x18\x02\x12\x04\x9f\
    \x01>@\n\x0c\n\x02\x04\0\x12\x06\xa2\x01\0\xa5\x01\x01\n\x0b\n\x03\x04\0\
    \x01\x12\x04\xa2\x01\x08\x1a\n\x0c\n\x04\x04\0\x02\0\x12\x04\xa3\x01\x08\
    .\n\r\n\x05\x04\0\x02\0\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\0\x02\
    \0\x05\x12\x04\xa3\x01\x11\x17\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xa3\x01\
    \x18)\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xa3\x01,-\n\x0c\n\x04\x04\0\x02\
    \x01\x12\x04\xa4\x01\x08)\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\xa4\x01\
    \x08\x10\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\xa4\x01\x11\x17\n\r\n\x05\
    \x04\0\x02\x01\x01\x12\x04\xa4\x01\x18$\n\r\n\x05\x04\0\x02\x01\x03\x12\
    \x04\xa4\x01'(\n\x0c\n\x02\x04\x01\x12\x06\xa7\x01\0\xac\x01\x01\n\x0b\n\
    \x03\x04\x01\x01\x12\x04\xa7\x01\x08#\n\x0c\n\x04\x04\x01\x02\0\x12\x04\
    \xa8\x01\x08$\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\xa8\x01\x08\x10\n\r\n\
    \x05\x04\x01\x02\0\x05\x12\x04\xa8\x01\x11\x17\n\r\n\x05\x04\x01\x02\0\
    \x01\x12\x04\xa8\x01\x18\x1f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xa8\x01\
    \"#\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\xa9\x01\x08&\n\r\n\x05\x04\x01\
    \x02\x01\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x01\x02\x01\x05\x12\
    \x04\xa9\x01\x11\x17\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xa9\x01\x18!\
    \n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xa9\x01$%\n\x0c\n\x04\x04\x01\x02\
    \x02\x12\x04\xaa\x01\x08%\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\xaa\x01\
    \x08\x10\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xaa\x01\x11\x17\n\r\n\x05\
    \x04\x01\x02\x02\x01\x12\x04\xaa\x01\x18\x20\n\r\n\x05\x04\x01\x02\x02\
    \x03\x12\x04\xaa\x01#$\n\x0c\n\x04\x04\x01\x02\x03\x12\x04\xab\x01\x08(\
    \n\r\n\x05\x04\x01\x02\x03\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\x04\x01\
    \x02\x03\x05\x12\x04\xab\x01\x11\x17\n\r\n\x05\x04\x01\x02\x03\x01\x12\
    \x04\xab\x01\x18#\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\xab\x01&'\n\x0c\
    \n\x02\x04\x02\x12\x06\xae\x01\0\xb8\x01\x01\n\x0b\n\x03\x04\x02\x01\x12\
    \x04\xae\x01\x08,\n\x0e\n\x04\x04\x02\x03\0\x12\x06\xaf\x01\x08\xb3\x01\
    \t\n\r\n\x05\x04\x02\x03\0\x01\x12\x04\xaf\x01\x10'\n\x0e\n\x06\x04\x02\
    \x03\0\x02\0\x12\x04\xb0\x01\x10/\n\x0f\n\x07\x04\x02\x03\0\x02\0\x04\
    \x12\x04\xb0\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\0\x02\0\x05\x12\x04\xb0\
    \x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\0\x02\0\x01\x12\x04\xb0\x01\x20*\n\
    \x0f\n\x07\x04\x02\x03\0\x02\0\x03\x12\x04\xb0\x01-.\n\x0e\n\x06\x04\x02\
    \x03\0\x02\x01\x12\x04\xb1\x01\x10,\n\x0f\n\x07\x04\x02\x03\0\x02\x01\
    \x04\x12\x04\xb1\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x05\x12\
    \x04\xb1\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x04\xb1\
    \x01\x20'\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x04\xb1\x01*+\n\x0e\
    \n\x06\x04\x02\x03\0\x02\x02\x12\x04\xb2\x01\x10/\n\x0f\n\x07\x04\x02\
    \x03\0\x02\x02\x04\x12\x04\xb2\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\0\x02\
    \x02\x05\x12\x04\xb2\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x01\
    \x12\x04\xb2\x01\x20*\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x03\x12\x04\xb2\
    \x01-.\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xb5\x01\x08'\n\r\n\x05\x04\x02\
    \x02\0\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\
    \xb5\x01\x11\x17\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xb5\x01\x18\"\n\r\n\
    \x05\x04\x02\x02\0\x03\x12\x04\xb5\x01%&\n\x0c\n\x04\x04\x02\x02\x01\x12\
    \x04\xb6\x01\x08l\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\xb6\x01\x08\x10\
    \n\r\n\x05\x04\x02\x02\x01\x06\x12\x04\xb6\x01\x11M\n\r\n\x05\x04\x02\
    \x02\x01\x01\x12\x04\xb6\x01Ng\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xb6\
    \x01jk\n\x0c\n\x04\x04\x02\x02\x02\x12\x04\xb7\x01\x08%\n\r\n\x05\x04\
    \x02\x02\x02\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x02\x02\x02\x05\
    \x12\x04\xb7\x01\x11\x15\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb7\x01\
    \x16\x20\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xb7\x01#$\n\x0c\n\x02\x04\
    \x03\x12\x06\xba\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xba\
    \x01\x08\x1c\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xbb\x01\x08%\n\r\n\x05\
    \x04\x03\x02\0\x04\x12\x04\xbb\x01\x08\x10\n\r\n\x05\x04\x03\x02\0\x05\
    \x12\x04\xbb\x01\x11\x17\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xbb\x01\x18\
    \x20\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xbb\x01#$\n\x0c\n\x02\x04\x04\
    \x12\x06\xbe\x01\0\xc1\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xbe\x01\
    \x08#\n\x0c\n\x04\x04\x04\x02\0\x12\x04\xbf\x01\x08$\n\r\n\x05\x04\x04\
    \x02\0\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\
    \xbf\x01\x11\x17\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xbf\x01\x18\x1f\n\r\
    \n\x05\x04\x04\x02\0\x03\x12\x04\xbf\x01\"#\n\x0c\n\x04\x04\x04\x02\x01\
    \x12\x04\xc0\x01\x08%\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xc0\x01\x08\
    \x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xc0\x01\x11\x17\n\r\n\x05\x04\
    \x04\x02\x01\x01\x12\x04\xc0\x01\x18\x20\n\r\n\x05\x04\x04\x02\x01\x03\
    \x12\x04\xc0\x01#$\n\x0c\n\x02\x04\x05\x12\x06\xc3\x01\0\xcc\x01\x01\n\
    \x0b\n\x03\x04\x05\x01\x12\x04\xc3\x01\x08+\n\x0e\n\x04\x04\x05\x03\0\
    \x12\x06\xc4\x01\x08\xc7\x01\t\n\r\n\x05\x04\x05\x03\0\x01\x12\x04\xc4\
    \x01\x10\x15\n\x0e\n\x06\x04\x05\x03\0\x02\0\x12\x04\xc5\x01\x10-\n\x0f\
    \n\x07\x04\x05\x03\0\x02\0\x04\x12\x04\xc5\x01\x10\x18\n\x0f\n\x07\x04\
    \x05\x03\0\x02\0\x05\x12\x04\xc5\x01\x19\x1f\n\x0f\n\x07\x04\x05\x03\0\
    \x02\0\x01\x12\x04\xc5\x01\x20(\n\x0f\n\x07\x04\x05\x03\0\x02\0\x03\x12\
    \x04\xc5\x01+,\n\x0e\n\x06\x04\x05\x03\0\x02\x01\x12\x04\xc6\x01\x10*\n\
    \x0f\n\x07\x04\x05\x03\0\x02\x01\x04\x12\x04\xc6\x01\x10\x18\n\x0f\n\x07\
    \x04\x05\x03\0\x02\x01\x05\x12\x04\xc6\x01\x19\x1f\n\x0f\n\x07\x04\x05\
    \x03\0\x02\x01\x01\x12\x04\xc6\x01\x20%\n\x0f\n\x07\x04\x05\x03\0\x02\
    \x01\x03\x12\x04\xc6\x01()\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xc9\x01\x08\
    J\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xc9\x01\x08\x10\n\r\n\x05\x04\x05\
    \x02\0\x06\x12\x04\xc9\x01\x11:\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xc9\
    \x01;E\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xc9\x01HI\n\x0c\n\x04\x04\x05\
    \x02\x01\x12\x04\xca\x01\x08$\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xca\
    \x01\x08\x10\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xca\x01\x11\x17\n\r\n\
    \x05\x04\x05\x02\x01\x01\x12\x04\xca\x01\x18\x1f\n\r\n\x05\x04\x05\x02\
    \x01\x03\x12\x04\xca\x01\"#\n\x0c\n\x04\x04\x05\x02\x02\x12\x04\xcb\x01\
    \x08,\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\
    \x04\x05\x02\x02\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\x05\x02\x02\
    \x01\x12\x04\xcb\x01\x18'\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xcb\x01*\
    +\n\x0c\n\x02\x04\x06\x12\x06\xce\x01\0\xd1\x01\x01\n\x0b\n\x03\x04\x06\
    \x01\x12\x04\xce\x01\x083\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xcf\x01\x08$\
    \n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xcf\x01\x08\x10\n\r\n\x05\x04\x06\
    \x02\0\x05\x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\
    \xcf\x01\x18\x1f\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xcf\x01\"#\n\x0c\n\
    \x04\x04\x06\x02\x01\x12\x04\xd0\x01\x08,\n\r\n\x05\x04\x06\x02\x01\x04\
    \x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xd0\x01\
    \x11\x17\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xd0\x01\x18'\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\xd0\x01*+\n\x0c\n\x02\x04\x07\x12\x06\xd3\
    \x01\0\xd4\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xd3\x01\x08\x1d\n\x0c\
    \n\x02\x04\x08\x12\x06\xd6\x01\0\xd7\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xd6\x01\x08\x1e\n\x0c\n\x02\x04\t\x12\x06\xd9\x01\0\xdb\x01\x01\n\
    \x0b\n\x03\x04\t\x01\x12\x04\xd9\x01\x08&\n\x0c\n\x04\x04\t\x02\0\x12\
    \x04\xda\x01\x08'\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xda\x01\x08\x10\n\r\
    \n\x05\x04\t\x02\0\x05\x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xda\x01\x18\"\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xda\x01%&\n\x0c\
    \n\x02\x04\n\x12\x06\xdd\x01\0\xe0\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \xdd\x01\x08.\n\x0c\n\x04\x04\n\x02\0\x12\x04\xde\x01\x08-\n\r\n\x05\x04\
    \n\x02\0\x04\x12\x04\xde\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\
    \xde\x01\x11\x18\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xde\x01\x19(\n\r\n\
    \x05\x04\n\x02\0\x03\x12\x04\xde\x01+,\n\x0c\n\x04\x04\n\x02\x01\x12\x04\
    \xdf\x01\x08$\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xdf\x01\x08\x10\n\r\n\
    \x05\x04\n\x02\x01\x05\x12\x04\xdf\x01\x11\x15\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\xdf\x01\x16\x1f\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xdf\x01\
    \"#\n\x0c\n\x02\x04\x0b\x12\x06\xe2\x01\0\xe5\x01\x01\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xe2\x01\x08&\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xe3\x01\
    \x08'\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\
    \x0b\x02\0\x05\x12\x04\xe3\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\x01\x12\
    \x04\xe3\x01\x18\"\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xe3\x01%&\n\x0c\n\
    \x04\x04\x0b\x02\x01\x12\x04\xe4\x01\x08+\n\r\n\x05\x04\x0b\x02\x01\x04\
    \x12\x04\xe4\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xe4\x01\
    \x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xe4\x01\x18&\n\r\n\x05\
    \x04\x0b\x02\x01\x03\x12\x04\xe4\x01)*\n\x0c\n\x02\x04\x0c\x12\x06\xe7\
    \x01\0\xe9\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xe7\x01\x08.\n\x0c\n\
    \x04\x04\x0c\x02\0\x12\x04\xe8\x01\x08.\n\r\n\x05\x04\x0c\x02\0\x04\x12\
    \x04\xe8\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xe8\x01\x11\x17\
    \n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xe8\x01\x18)\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\xe8\x01,-\n\x0c\n\x02\x04\r\x12\x06\xeb\x01\0\xed\x01\x01\
    \n\x0b\n\x03\x04\r\x01\x12\x04\xeb\x01\x08&\n\x0c\n\x04\x04\r\x02\0\x12\
    \x04\xec\x01\x08'\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xec\x01\x08\x10\n\r\
    \n\x05\x04\r\x02\0\x05\x12\x04\xec\x01\x11\x17\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xec\x01\x18\"\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xec\x01%&\n\x0c\
    \n\x02\x04\x0e\x12\x06\xef\x01\0\xf6\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\
    \x04\xef\x01\x08.\n\x0e\n\x04\x04\x0e\x03\0\x12\x06\xf0\x01\x08\xf3\x01\
    \t\n\r\n\x05\x04\x0e\x03\0\x01\x12\x04\xf0\x01\x10\x17\n\x0e\n\x06\x04\
    \x0e\x03\0\x02\0\x12\x04\xf1\x01\x10.\n\x0f\n\x07\x04\x0e\x03\0\x02\0\
    \x04\x12\x04\xf1\x01\x10\x18\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x05\x12\x04\
    \xf1\x01\x19\x1f\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x01\x12\x04\xf1\x01\x20\
    )\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x03\x12\x04\xf1\x01,-\n\x0e\n\x06\x04\
    \x0e\x03\0\x02\x01\x12\x04\xf2\x01\x10,\n\x0f\n\x07\x04\x0e\x03\0\x02\
    \x01\x04\x12\x04\xf2\x01\x10\x18\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x05\
    \x12\x04\xf2\x01\x19\x1f\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x01\x12\x04\
    \xf2\x01\x20'\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x03\x12\x04\xf2\x01*+\n\
    \x0c\n\x04\x04\x0e\x02\0\x12\x04\xf5\x01\x08M\n\r\n\x05\x04\x0e\x02\0\
    \x04\x12\x04\xf5\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xf5\x01\
    \x11?\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xf5\x01@H\n\r\n\x05\x04\x0e\
    \x02\0\x03\x12\x04\xf5\x01KL\n\x0c\n\x02\x04\x0f\x12\x06\xf8\x01\0\xfa\
    \x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xf8\x01\x08\x1d\n\x0c\n\x04\x04\
    \x0f\x02\0\x12\x04\xf9\x01\x08+\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xf9\
    \x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xf9\x01\x11\x17\n\r\n\
    \x05\x04\x0f\x02\0\x01\x12\x04\xf9\x01\x18&\n\r\n\x05\x04\x0f\x02\0\x03\
    \x12\x04\xf9\x01)*\n\x0c\n\x02\x04\x10\x12\x06\xfc\x01\0\x85\x02\x01\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\xfc\x01\x08%\n\x0e\n\x04\x04\x10\x04\0\
    \x12\x06\xfd\x01\x08\x80\x02\t\n\r\n\x05\x04\x10\x04\0\x01\x12\x04\xfd\
    \x01\r\x14\n\x0e\n\x06\x04\x10\x04\0\x02\0\x12\x04\xfe\x01\x10\x20\n\x0f\
    \n\x07\x04\x10\x04\0\x02\0\x01\x12\x04\xfe\x01\x10\x1b\n\x0f\n\x07\x04\
    \x10\x04\0\x02\0\x02\x12\x04\xfe\x01\x1e\x1f\n\x0e\n\x06\x04\x10\x04\0\
    \x02\x01\x12\x04\xff\x01\x10\x1d\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x01\
    \x12\x04\xff\x01\x10\x18\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x02\x12\x04\
    \xff\x01\x1b\x1c\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x82\x02\x08%\n\r\n\
    \x05\x04\x10\x02\0\x04\x12\x04\x82\x02\x08\x10\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\x82\x02\x11\x17\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x82\x02\
    \x18\x20\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x82\x02#$\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\x83\x02\x08&\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\
    \x83\x02\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\x83\x02\x11\x17\n\
    \r\n\x05\x04\x10\x02\x01\x01\x12\x04\x83\x02\x18!\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\x83\x02$%\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\x84\x02\
    \x08+\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\x84\x02\x08\x10\n\r\n\x05\
    \x04\x10\x02\x02\x05\x12\x04\x84\x02\x11\x17\n\r\n\x05\x04\x10\x02\x02\
    \x01\x12\x04\x84\x02\x18&\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x84\x02)\
    *\n\x0c\n\x02\x04\x11\x12\x06\x87\x02\0\x89\x02\x01\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\x87\x02\x08'\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x88\x02\x08+\
    \n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\x11\
    \x02\0\x05\x12\x04\x88\x02\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\
    \x88\x02\x18&\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x88\x02)*\n\x0c\n\x02\
    \x04\x12\x12\x06\x8b\x02\0\x96\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\
    \x8b\x02\x08/\n\x0e\n\x04\x04\x12\x04\0\x12\x06\x8c\x02\x08\x8f\x02\t\n\
    \r\n\x05\x04\x12\x04\0\x01\x12\x04\x8c\x02\r\x14\n\x0e\n\x06\x04\x12\x04\
    \0\x02\0\x12\x04\x8d\x02\x10\x20\n\x0f\n\x07\x04\x12\x04\0\x02\0\x01\x12\
    \x04\x8d\x02\x10\x1b\n\x0f\n\x07\x04\x12\x04\0\x02\0\x02\x12\x04\x8d\x02\
    \x1e\x1f\n\x0e\n\x06\x04\x12\x04\0\x02\x01\x12\x04\x8e\x02\x10\x1d\n\x0f\
    \n\x07\x04\x12\x04\0\x02\x01\x01\x12\x04\x8e\x02\x10\x18\n\x0f\n\x07\x04\
    \x12\x04\0\x02\x01\x02\x12\x04\x8e\x02\x1b\x1c\n\x0c\n\x04\x04\x12\x02\0\
    \x12\x04\x91\x02\x08%\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\x91\x02\x08\
    \x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x91\x02\x11\x17\n\r\n\x05\x04\
    \x12\x02\0\x01\x12\x04\x91\x02\x18\x20\n\r\n\x05\x04\x12\x02\0\x03\x12\
    \x04\x91\x02#$\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\x92\x02\x08.\n\r\n\
    \x05\x04\x12\x02\x01\x04\x12\x04\x92\x02\x08\x10\n\r\n\x05\x04\x12\x02\
    \x01\x05\x12\x04\x92\x02\x11\x17\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \x92\x02\x18)\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x92\x02,-\n\x0c\n\
    \x04\x04\x12\x02\x02\x12\x04\x93\x02\x08.\n\r\n\x05\x04\x12\x02\x02\x04\
    \x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\x93\x02\
    \x11\x17\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x93\x02\x18)\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\x93\x02,-\n\x0c\n\x04\x04\x12\x02\x03\x12\
    \x04\x94\x02\x08.\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\x94\x02\x08\x10\
    \n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\x94\x02\x11\x17\n\r\n\x05\x04\x12\
    \x02\x03\x01\x12\x04\x94\x02\x18)\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\
    \x94\x02,-\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\x95\x02\x08.\n\r\n\x05\
    \x04\x12\x02\x04\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x12\x02\x04\
    \x05\x12\x04\x95\x02\x11\x17\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\x95\
    \x02\x18)\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\x95\x02,-\n\x0c\n\x02\
    \x04\x13\x12\x06\x98\x02\0\x9e\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \x98\x02\x08%\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x99\x02\x08'\n\r\n\x05\
    \x04\x13\x02\0\x04\x12\x04\x99\x02\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\
    \x12\x04\x99\x02\x11\x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x99\x02\x18\
    \"\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x99\x02%&\n\x0c\n\x04\x04\x13\x02\
    \x01\x12\x04\x9a\x02\x08+\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\x9a\x02\
    \x08\x10\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\x9a\x02\x11\x16\n\r\n\x05\
    \x04\x13\x02\x01\x01\x12\x04\x9a\x02\x17&\n\r\n\x05\x04\x13\x02\x01\x03\
    \x12\x04\x9a\x02)*\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x9b\x02\x08)\n\r\
    \n\x05\x04\x13\x02\x02\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x13\x02\
    \x02\x05\x12\x04\x9b\x02\x11\x17\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\
    \x9b\x02\x18$\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x9b\x02'(\n\x0c\n\
    \x04\x04\x13\x02\x03\x12\x04\x9c\x02\x08/\n\r\n\x05\x04\x13\x02\x03\x04\
    \x12\x04\x9c\x02\x08\x10\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\x9c\x02\
    \x11\x17\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\x9c\x02\x18*\n\r\n\x05\
    \x04\x13\x02\x03\x03\x12\x04\x9c\x02-.\n\x0c\n\x04\x04\x13\x02\x04\x12\
    \x04\x9d\x02\x08+\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\x9d\x02\x08\x10\
    \n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\x9d\x02\x11\x15\n\r\n\x05\x04\x13\
    \x02\x04\x01\x12\x04\x9d\x02\x16&\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\
    \x9d\x02)*\n\x0c\n\x02\x04\x14\x12\x06\xa0\x02\0\xa8\x02\x01\n\x0b\n\x03\
    \x04\x14\x01\x12\x04\xa0\x02\x08\x1f\n\x0c\n\x04\x04\x14\x02\0\x12\x04\
    \xa1\x02\x08'\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xa1\x02\x08\x10\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\xa1\x02\x11\x17\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\xa1\x02\x18\"\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xa1\x02%&\
    \n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xa2\x02\x08$\n\r\n\x05\x04\x14\x02\
    \x01\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\
    \xa2\x02\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xa2\x02\x18\x1f\n\
    \r\n\x05\x04\x14\x02\x01\x03\x12\x04\xa2\x02\"#\n\x0c\n\x04\x04\x14\x02\
    \x02\x12\x04\xa3\x02\x08%\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xa3\x02\
    \x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xa3\x02\x11\x17\n\r\n\x05\
    \x04\x14\x02\x02\x01\x12\x04\xa3\x02\x18\x20\n\r\n\x05\x04\x14\x02\x02\
    \x03\x12\x04\xa3\x02#$\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xa4\x02\x08+\
    \n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xa4\x02\x08\x10\n\r\n\x05\x04\x14\
    \x02\x03\x05\x12\x04\xa4\x02\x11\x16\n\r\n\x05\x04\x14\x02\x03\x01\x12\
    \x04\xa4\x02\x17&\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xa4\x02)*\n\x0c\
    \n\x04\x04\x14\x02\x04\x12\x04\xa5\x02\x08)\n\r\n\x05\x04\x14\x02\x04\
    \x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\xa5\
    \x02\x11\x17\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xa5\x02\x18$\n\r\n\
    \x05\x04\x14\x02\x04\x03\x12\x04\xa5\x02'(\n\x0c\n\x04\x04\x14\x02\x05\
    \x12\x04\xa6\x02\x08-\n\r\n\x05\x04\x14\x02\x05\x04\x12\x04\xa6\x02\x08\
    \x10\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\xa6\x02\x11\x17\n\r\n\x05\x04\
    \x14\x02\x05\x01\x12\x04\xa6\x02\x18(\n\r\n\x05\x04\x14\x02\x05\x03\x12\
    \x04\xa6\x02+,\n\x0c\n\x04\x04\x14\x02\x06\x12\x04\xa7\x02\x08+\n\r\n\
    \x05\x04\x14\x02\x06\x04\x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04\x14\x02\
    \x06\x05\x12\x04\xa7\x02\x11\x17\n\r\n\x05\x04\x14\x02\x06\x01\x12\x04\
    \xa7\x02\x18&\n\r\n\x05\x04\x14\x02\x06\x03\x12\x04\xa7\x02)*\n\x0c\n\
    \x02\x04\x15\x12\x06\xaa\x02\0\xaf\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xaa\x02\x08#\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xab\x02\x08'\n\r\n\
    \x05\x04\x15\x02\0\x04\x12\x04\xab\x02\x08\x10\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xab\x02\
    \x18\"\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xab\x02%&\n\x0c\n\x04\x04\x15\
    \x02\x01\x12\x04\xac\x02\x08%\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xac\
    \x02\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xac\x02\x11\x17\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\xac\x02\x18\x20\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\xac\x02#$\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xad\x02\
    \x08(\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\
    \x04\x15\x02\x02\x05\x12\x04\xad\x02\x11\x16\n\r\n\x05\x04\x15\x02\x02\
    \x01\x12\x04\xad\x02\x17#\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xad\x02&\
    '\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\xae\x02\x08)\n\r\n\x05\x04\x15\x02\
    \x03\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\
    \xae\x02\x11\x17\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xae\x02\x18$\n\r\
    \n\x05\x04\x15\x02\x03\x03\x12\x04\xae\x02'(\n\x0c\n\x02\x04\x16\x12\x06\
    \xb1\x02\0\xb4\x02\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xb1\x02\x08\x20\n\
    \x0c\n\x04\x04\x16\x02\0\x12\x04\xb2\x02\x08'\n\r\n\x05\x04\x16\x02\0\
    \x04\x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xb2\x02\
    \x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb2\x02\x18\"\n\r\n\x05\x04\
    \x16\x02\0\x03\x12\x04\xb2\x02%&\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xb3\
    \x02\x08!\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xb3\x02\x08\x10\n\r\n\
    \x05\x04\x16\x02\x01\x05\x12\x04\xb3\x02\x11\x15\n\r\n\x05\x04\x16\x02\
    \x01\x01\x12\x04\xb3\x02\x16\x1c\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\
    \xb3\x02\x1f\x20\n\x0c\n\x02\x04\x17\x12\x06\xb6\x02\0\xba\x02\x01\n\x0b\
    \n\x03\x04\x17\x01\x12\x04\xb6\x02\x08%\n\x0c\n\x04\x04\x17\x02\0\x12\
    \x04\xb7\x02\x08'\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xb7\x02\x08\x10\n\
    \r\n\x05\x04\x17\x02\0\x05\x12\x04\xb7\x02\x11\x17\n\r\n\x05\x04\x17\x02\
    \0\x01\x12\x04\xb7\x02\x18\"\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xb7\x02\
    %&\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xb8\x02\x08>\n\r\n\x05\x04\x17\
    \x02\x01\x04\x12\x04\xb8\x02\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\
    \x04\xb8\x02\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xb8\x02\x189\
    \n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xb8\x02<=\n\x0c\n\x04\x04\x17\x02\
    \x02\x12\x04\xb9\x02\x08/\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xb9\x02\
    \x08\x10\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xb9\x02\x11\x17\n\r\n\x05\
    \x04\x17\x02\x02\x01\x12\x04\xb9\x02\x18*\n\r\n\x05\x04\x17\x02\x02\x03\
    \x12\x04\xb9\x02-.\n\x0c\n\x02\x04\x18\x12\x06\xbc\x02\0\xd8\x02\x01\n\
    \x0b\n\x03\x04\x18\x01\x12\x04\xbc\x02\x08)\n\x0e\n\x04\x04\x18\x03\0\
    \x12\x06\xbd\x02\x08\xd2\x02\t\n\r\n\x05\x04\x18\x03\0\x01\x12\x04\xbd\
    \x02\x10\x14\n\x10\n\x06\x04\x18\x03\0\x03\0\x12\x06\xbe\x02\x10\xc3\x02\
    \x11\n\x0f\n\x07\x04\x18\x03\0\x03\0\x01\x12\x04\xbe\x02\x18(\n\x10\n\
    \x08\x04\x18\x03\0\x03\0\x02\0\x12\x04\xbf\x02\x181\n\x11\n\t\x04\x18\
    \x03\0\x03\0\x02\0\x04\x12\x04\xbf\x02\x18\x20\n\x11\n\t\x04\x18\x03\0\
    \x03\0\x02\0\x05\x12\x04\xbf\x02!'\n\x11\n\t\x04\x18\x03\0\x03\0\x02\0\
    \x01\x12\x04\xbf\x02(,\n\x11\n\t\x04\x18\x03\0\x03\0\x02\0\x03\x12\x04\
    \xbf\x02/0\n\x10\n\x08\x04\x18\x03\0\x03\0\x02\x01\x12\x04\xc0\x02\x189\
    \n\x11\n\t\x04\x18\x03\0\x03\0\x02\x01\x04\x12\x04\xc0\x02\x18\x20\n\x11\
    \n\t\x04\x18\x03\0\x03\0\x02\x01\x05\x12\x04\xc0\x02!'\n\x11\n\t\x04\x18\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xc0\x02(4\n\x11\n\t\x04\x18\x03\0\x03\0\
    \x02\x01\x03\x12\x04\xc0\x0278\n\x10\n\x08\x04\x18\x03\0\x03\0\x02\x02\
    \x12\x04\xc1\x02\x187\n\x11\n\t\x04\x18\x03\0\x03\0\x02\x02\x04\x12\x04\
    \xc1\x02\x18\x20\n\x11\n\t\x04\x18\x03\0\x03\0\x02\x02\x05\x12\x04\xc1\
    \x02!&\n\x11\n\t\x04\x18\x03\0\x03\0\x02\x02\x01\x12\x04\xc1\x02'2\n\x11\
    \n\t\x04\x18\x03\0\x03\0\x02\x02\x03\x12\x04\xc1\x0256\n\x10\n\x08\x04\
    \x18\x03\0\x03\0\x02\x03\x12\x04\xc2\x02\x189\n\x11\n\t\x04\x18\x03\0\
    \x03\0\x02\x03\x04\x12\x04\xc2\x02\x18\x20\n\x11\n\t\x04\x18\x03\0\x03\0\
    \x02\x03\x05\x12\x04\xc2\x02!'\n\x11\n\t\x04\x18\x03\0\x03\0\x02\x03\x01\
    \x12\x04\xc2\x02(4\n\x11\n\t\x04\x18\x03\0\x03\0\x02\x03\x03\x12\x04\xc2\
    \x0278\n\x10\n\x06\x04\x18\x03\0\x03\x01\x12\x06\xc5\x02\x10\xc9\x02\x11\
    \n\x0f\n\x07\x04\x18\x03\0\x03\x01\x01\x12\x04\xc5\x02\x18,\n\x10\n\x08\
    \x04\x18\x03\0\x03\x01\x02\0\x12\x04\xc6\x02\x18=\n\x11\n\t\x04\x18\x03\
    \0\x03\x01\x02\0\x04\x12\x04\xc6\x02\x18\x20\n\x11\n\t\x04\x18\x03\0\x03\
    \x01\x02\0\x05\x12\x04\xc6\x02!'\n\x11\n\t\x04\x18\x03\0\x03\x01\x02\0\
    \x01\x12\x04\xc6\x02(8\n\x11\n\t\x04\x18\x03\0\x03\x01\x02\0\x03\x12\x04\
    \xc6\x02;<\n\x10\n\x08\x04\x18\x03\0\x03\x01\x02\x01\x12\x04\xc7\x02\x18\
    9\n\x11\n\t\x04\x18\x03\0\x03\x01\x02\x01\x04\x12\x04\xc7\x02\x18\x20\n\
    \x11\n\t\x04\x18\x03\0\x03\x01\x02\x01\x05\x12\x04\xc7\x02!'\n\x11\n\t\
    \x04\x18\x03\0\x03\x01\x02\x01\x01\x12\x04\xc7\x02(4\n\x11\n\t\x04\x18\
    \x03\0\x03\x01\x02\x01\x03\x12\x04\xc7\x0278\n\x10\n\x08\x04\x18\x03\0\
    \x03\x01\x02\x02\x12\x04\xc8\x02\x187\n\x11\n\t\x04\x18\x03\0\x03\x01\
    \x02\x02\x04\x12\x04\xc8\x02\x18\x20\n\x11\n\t\x04\x18\x03\0\x03\x01\x02\
    \x02\x05\x12\x04\xc8\x02!'\n\x11\n\t\x04\x18\x03\0\x03\x01\x02\x02\x01\
    \x12\x04\xc8\x02(2\n\x11\n\t\x04\x18\x03\0\x03\x01\x02\x02\x03\x12\x04\
    \xc8\x0256\n\x0e\n\x06\x04\x18\x03\0\x02\0\x12\x04\xcb\x02\x10-\n\x0f\n\
    \x07\x04\x18\x03\0\x02\0\x04\x12\x04\xcb\x02\x10\x18\n\x0f\n\x07\x04\x18\
    \x03\0\x02\0\x05\x12\x04\xcb\x02\x19\x1f\n\x0f\n\x07\x04\x18\x03\0\x02\0\
    \x01\x12\x04\xcb\x02\x20(\n\x0f\n\x07\x04\x18\x03\0\x02\0\x03\x12\x04\
    \xcb\x02+,\n\x0e\n\x06\x04\x18\x03\0\x02\x01\x12\x04\xcc\x02\x10/\n\x0f\
    \n\x07\x04\x18\x03\0\x02\x01\x04\x12\x04\xcc\x02\x10\x18\n\x0f\n\x07\x04\
    \x18\x03\0\x02\x01\x05\x12\x04\xcc\x02\x19\x1f\n\x0f\n\x07\x04\x18\x03\0\
    \x02\x01\x01\x12\x04\xcc\x02\x20*\n\x0f\n\x07\x04\x18\x03\0\x02\x01\x03\
    \x12\x04\xcc\x02-.\n\x0e\n\x06\x04\x18\x03\0\x02\x02\x12\x04\xcd\x02\x10\
    /\n\x0f\n\x07\x04\x18\x03\0\x02\x02\x04\x12\x04\xcd\x02\x10\x18\n\x0f\n\
    \x07\x04\x18\x03\0\x02\x02\x05\x12\x04\xcd\x02\x19\x1d\n\x0f\n\x07\x04\
    \x18\x03\0\x02\x02\x01\x12\x04\xcd\x02\x1e*\n\x0f\n\x07\x04\x18\x03\0\
    \x02\x02\x03\x12\x04\xcd\x02-.\n\x0e\n\x06\x04\x18\x03\0\x02\x03\x12\x04\
    \xce\x02\x10+\n\x0f\n\x07\x04\x18\x03\0\x02\x03\x04\x12\x04\xce\x02\x10\
    \x18\n\x0f\n\x07\x04\x18\x03\0\x02\x03\x05\x12\x04\xce\x02\x19\x1f\n\x0f\
    \n\x07\x04\x18\x03\0\x02\x03\x01\x12\x04\xce\x02\x20&\n\x0f\n\x07\x04\
    \x18\x03\0\x02\x03\x03\x12\x04\xce\x02)*\n\x0e\n\x06\x04\x18\x03\0\x02\
    \x04\x12\x04\xcf\x02\x10h\n\x0f\n\x07\x04\x18\x03\0\x02\x04\x04\x12\x04\
    \xcf\x02\x10\x18\n\x0f\n\x07\x04\x18\x03\0\x02\x04\x06\x12\x04\xcf\x02\
    \x19P\n\x0f\n\x07\x04\x18\x03\0\x02\x04\x01\x12\x04\xcf\x02Qc\n\x0f\n\
    \x07\x04\x18\x03\0\x02\x04\x03\x12\x04\xcf\x02fg\n\x0e\n\x06\x04\x18\x03\
    \0\x02\x05\x12\x04\xd0\x02\x10r\n\x0f\n\x07\x04\x18\x03\0\x02\x05\x04\
    \x12\x04\xd0\x02\x10\x18\n\x0f\n\x07\x04\x18\x03\0\x02\x05\x06\x12\x04\
    \xd0\x02\x19T\n\x0f\n\x07\x04\x18\x03\0\x02\x05\x01\x12\x04\xd0\x02Um\n\
    \x0f\n\x07\x04\x18\x03\0\x02\x05\x03\x12\x04\xd0\x02pq\n\x0e\n\x06\x04\
    \x18\x03\0\x02\x06\x12\x04\xd1\x02\x104\n\x0f\n\x07\x04\x18\x03\0\x02\
    \x06\x04\x12\x04\xd1\x02\x10\x18\n\x0f\n\x07\x04\x18\x03\0\x02\x06\x05\
    \x12\x04\xd1\x02\x19\x1f\n\x0f\n\x07\x04\x18\x03\0\x02\x06\x01\x12\x04\
    \xd1\x02\x20/\n\x0f\n\x07\x04\x18\x03\0\x02\x06\x03\x12\x04\xd1\x0223\n\
    \x0c\n\x04\x04\x18\x02\0\x12\x04\xd4\x02\x08'\n\r\n\x05\x04\x18\x02\0\
    \x04\x12\x04\xd4\x02\x08\x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xd4\x02\
    \x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xd4\x02\x18\"\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\xd4\x02%&\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xd5\
    \x02\x08B\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xd5\x02\x08\x10\n\r\n\
    \x05\x04\x18\x02\x01\x06\x12\x04\xd5\x02\x117\n\r\n\x05\x04\x18\x02\x01\
    \x01\x12\x04\xd5\x028=\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xd5\x02@A\n\
    \x0c\n\x04\x04\x18\x02\x02\x12\x04\xd6\x02\x08)\n\r\n\x05\x04\x18\x02\
    \x02\x04\x12\x04\xd6\x02\x08\x10\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\
    \xd6\x02\x11\x17\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xd6\x02\x18$\n\r\
    \n\x05\x04\x18\x02\x02\x03\x12\x04\xd6\x02'(\n\x0c\n\x04\x04\x18\x02\x03\
    \x12\x04\xd7\x02\x08'\n\r\n\x05\x04\x18\x02\x03\x04\x12\x04\xd7\x02\x08\
    \x10\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xd7\x02\x11\x17\n\r\n\x05\x04\
    \x18\x02\x03\x01\x12\x04\xd7\x02\x18\"\n\r\n\x05\x04\x18\x02\x03\x03\x12\
    \x04\xd7\x02%&\n\x0c\n\x02\x04\x19\x12\x06\xda\x02\0\xde\x02\x01\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\xda\x02\x08!\n\x0c\n\x04\x04\x19\x02\0\x12\x04\
    \xdb\x02\x08'\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xdb\x02\x08\x10\n\r\n\
    \x05\x04\x19\x02\0\x05\x12\x04\xdb\x02\x11\x17\n\r\n\x05\x04\x19\x02\0\
    \x01\x12\x04\xdb\x02\x18\"\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xdb\x02%&\
    \n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xdc\x02\x08%\n\r\n\x05\x04\x19\x02\
    \x01\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\
    \xdc\x02\x11\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xdc\x02\x18\x20\n\
    \r\n\x05\x04\x19\x02\x01\x03\x12\x04\xdc\x02#$\n\x0c\n\x04\x04\x19\x02\
    \x02\x12\x04\xdd\x02\x08&\n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\xdd\x02\
    \x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xdd\x02\x11\x17\n\r\n\x05\
    \x04\x19\x02\x02\x01\x12\x04\xdd\x02\x18!\n\r\n\x05\x04\x19\x02\x02\x03\
    \x12\x04\xdd\x02$%\n\x0c\n\x02\x04\x1a\x12\x06\xe0\x02\0\xe3\x02\x01\n\
    \x0b\n\x03\x04\x1a\x01\x12\x04\xe0\x02\x08,\n\x0c\n\x04\x04\x1a\x02\0\
    \x12\x04\xe1\x02\x08+\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xe1\x02\x08\
    \x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xe1\x02\x11\x17\n\r\n\x05\x04\
    \x1a\x02\0\x01\x12\x04\xe1\x02\x18&\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\
    \xe1\x02)*\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xe2\x02\x08&\n\r\n\x05\
    \x04\x1a\x02\x01\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x01\
    \x05\x12\x04\xe2\x02\x11\x17\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xe2\
    \x02\x18!\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xe2\x02$%\n\x0c\n\x02\
    \x04\x1b\x12\x06\xe5\x02\0\xec\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\
    \xe5\x02\x08\x13\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xe6\x02\x08$\n\r\n\
    \x05\x04\x1b\x02\0\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\xe6\x02\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xe6\x02\
    \x18\x1f\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe6\x02\"#\n\x0c\n\x04\x04\
    \x1b\x02\x01\x12\x04\xe7\x02\x08-\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\
    \xe7\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xe7\x02\x11\x18\n\
    \r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xe7\x02\x19(\n\r\n\x05\x04\x1b\x02\
    \x01\x03\x12\x04\xe7\x02+,\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xe8\x02\
    \x084\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x02\x05\x12\x04\xe8\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x02\
    \x01\x12\x04\xe8\x02\x18/\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xe8\x022\
    3\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xe9\x02\x08-\n\r\n\x05\x04\x1b\x02\
    \x03\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x03\x05\x12\x04\
    \xe9\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\xe9\x02\x18(\n\r\
    \n\x05\x04\x1b\x02\x03\x03\x12\x04\xe9\x02+,\n\x0c\n\x04\x04\x1b\x02\x04\
    \x12\x04\xea\x02\x08/\n\r\n\x05\x04\x1b\x02\x04\x04\x12\x04\xea\x02\x08\
    \x10\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\xea\x02\x11\x17\n\r\n\x05\x04\
    \x1b\x02\x04\x01\x12\x04\xea\x02\x18*\n\r\n\x05\x04\x1b\x02\x04\x03\x12\
    \x04\xea\x02-.\n\x0c\n\x04\x04\x1b\x02\x05\x12\x04\xeb\x02\x084\n\r\n\
    \x05\x04\x1b\x02\x05\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x05\x05\x12\x04\xeb\x02\x11\x15\n\r\n\x05\x04\x1b\x02\x05\x01\x12\x04\
    \xeb\x02\x16/\n\r\n\x05\x04\x1b\x02\x05\x03\x12\x04\xeb\x0223\n\x0c\n\
    \x02\x04\x1c\x12\x06\xee\x02\0\xf1\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\
    \x04\xee\x02\x08\x19\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xef\x02\x081\n\r\
    \n\x05\x04\x1c\x02\0\x04\x12\x04\xef\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\
    \x05\x12\x04\xef\x02\x11\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xef\x02\
    \x18,\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xef\x02/0\n\x0c\n\x04\x04\x1c\
    \x02\x01\x12\x04\xf0\x02\x08.\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xf0\
    \x02\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xf0\x02\x11\x1c\n\r\n\
    \x05\x04\x1c\x02\x01\x01\x12\x04\xf0\x02\x1d)\n\r\n\x05\x04\x1c\x02\x01\
    \x03\x12\x04\xf0\x02,-\n\x0c\n\x02\x04\x1d\x12\x06\xf3\x02\0\xf5\x02\x01\
    \n\x0b\n\x03\x04\x1d\x01\x12\x04\xf3\x02\x08\x1c\n\x0c\n\x04\x04\x1d\x02\
    \0\x12\x04\xf4\x02\x08%\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xf4\x02\x08\
    \x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xf4\x02\x11\x17\n\r\n\x05\x04\
    \x1d\x02\0\x01\x12\x04\xf4\x02\x18\x20\n\r\n\x05\x04\x1d\x02\0\x03\x12\
    \x04\xf4\x02#$\n\x0c\n\x02\x04\x1e\x12\x06\xf7\x02\0\xfa\x02\x01\n\x0b\n\
    \x03\x04\x1e\x01\x12\x04\xf7\x02\x08)\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\
    \xf8\x02\x08(\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xf8\x02\x08\x10\n\r\n\
    \x05\x04\x1e\x02\0\x05\x12\x04\xf8\x02\x11\x17\n\r\n\x05\x04\x1e\x02\0\
    \x01\x12\x04\xf8\x02\x18#\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xf8\x02&'\
    \n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xf9\x02\x08%\n\r\n\x05\x04\x1e\x02\
    \x01\x04\x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\
    \xf9\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xf9\x02\x18\x20\n\
    \r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xf9\x02#$\n\x0c\n\x02\x04\x1f\x12\
    \x06\xfc\x02\0\x82\x03\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xfc\x02\x081\
    \n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xfd\x02\x08'\n\r\n\x05\x04\x1f\x02\0\
    \x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xfd\x02\
    \x11\x17\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xfd\x02\x18\"\n\r\n\x05\x04\
    \x1f\x02\0\x03\x12\x04\xfd\x02%&\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xfe\
    \x02\x08,\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xfe\x02\x08\x10\n\r\n\
    \x05\x04\x1f\x02\x01\x05\x12\x04\xfe\x02\x11\x17\n\r\n\x05\x04\x1f\x02\
    \x01\x01\x12\x04\xfe\x02\x18'\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xfe\
    \x02*+\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\xff\x02\x08-\n\r\n\x05\x04\
    \x1f\x02\x02\x04\x12\x04\xff\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\
    \x12\x04\xff\x02\x11\x17\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xff\x02\
    \x18(\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xff\x02+,\n\x0c\n\x04\x04\
    \x1f\x02\x03\x12\x04\x80\x03\x08-\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\
    \x80\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x03\x05\x12\x04\x80\x03\x11\x17\n\
    \r\n\x05\x04\x1f\x02\x03\x01\x12\x04\x80\x03\x18(\n\r\n\x05\x04\x1f\x02\
    \x03\x03\x12\x04\x80\x03+,\n\x0c\n\x04\x04\x1f\x02\x04\x12\x04\x81\x03\
    \x082\n\r\n\x05\x04\x1f\x02\x04\x04\x12\x04\x81\x03\x08\x10\n\r\n\x05\
    \x04\x1f\x02\x04\x05\x12\x04\x81\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x04\
    \x01\x12\x04\x81\x03\x18-\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\x81\x030\
    1\n\x0c\n\x02\x04\x20\x12\x06\x84\x03\0\x8b\x03\x01\n\x0b\n\x03\x04\x20\
    \x01\x12\x04\x84\x03\x08\x17\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x85\x03\
    \x08#\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04\
    \x20\x02\0\x05\x12\x04\x85\x03\x11\x17\n\r\n\x05\x04\x20\x02\0\x01\x12\
    \x04\x85\x03\x18\x1e\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x85\x03!\"\n\
    \x0c\n\x04\x04\x20\x02\x01\x12\x04\x86\x03\x08)\n\r\n\x05\x04\x20\x02\
    \x01\x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\
    \x86\x03\x11\x17\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x86\x03\x18$\n\r\
    \n\x05\x04\x20\x02\x01\x03\x12\x04\x86\x03'(\n\x0c\n\x04\x04\x20\x02\x02\
    \x12\x04\x87\x03\x08!\n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\x87\x03\x08\
    \x10\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\x87\x03\x11\x16\n\r\n\x05\x04\
    \x20\x02\x02\x01\x12\x04\x87\x03\x17\x1c\n\r\n\x05\x04\x20\x02\x02\x03\
    \x12\x04\x87\x03\x1f\x20\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\x88\x03\x08\
    (\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\
    \x20\x02\x03\x05\x12\x04\x88\x03\x11\x17\n\r\n\x05\x04\x20\x02\x03\x01\
    \x12\x04\x88\x03\x18#\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\x88\x03&'\n\
    \x0c\n\x04\x04\x20\x02\x04\x12\x04\x89\x03\x08-\n\r\n\x05\x04\x20\x02\
    \x04\x04\x12\x04\x89\x03\x08\x10\n\r\n\x05\x04\x20\x02\x04\x05\x12\x04\
    \x89\x03\x11\x17\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\x89\x03\x18(\n\r\
    \n\x05\x04\x20\x02\x04\x03\x12\x04\x89\x03+,\n\x0c\n\x04\x04\x20\x02\x05\
    \x12\x04\x8a\x03\x08#\n\r\n\x05\x04\x20\x02\x05\x04\x12\x04\x8a\x03\x08\
    \x10\n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\x8a\x03\x11\x17\n\r\n\x05\x04\
    \x20\x02\x05\x01\x12\x04\x8a\x03\x18\x1e\n\r\n\x05\x04\x20\x02\x05\x03\
    \x12\x04\x8a\x03!\"\n\x0c\n\x02\x04!\x12\x06\x8d\x03\0\x8f\x03\x01\n\x0b\
    \n\x03\x04!\x01\x12\x04\x8d\x03\x08\x16\n\x0c\n\x04\x04!\x02\0\x12\x04\
    \x8e\x03\x08!\n\r\n\x05\x04!\x02\0\x04\x12\x04\x8e\x03\x08\x10\n\r\n\x05\
    \x04!\x02\0\x05\x12\x04\x8e\x03\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\
    \x8e\x03\x18\x1c\n\r\n\x05\x04!\x02\0\x03\x12\x04\x8e\x03\x1f\x20\n\x0c\
    \n\x02\x04\"\x12\x06\x91\x03\0\x9b\x03\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \x91\x03\x08\x1e\n\x0e\n\x04\x04\"\x04\0\x12\x06\x92\x03\x08\x97\x03\t\n\
    \r\n\x05\x04\"\x04\0\x01\x12\x04\x92\x03\r\x18\n\x0e\n\x06\x04\"\x04\0\
    \x02\0\x12\x04\x93\x03\x10\x20\n\x0f\n\x07\x04\"\x04\0\x02\0\x01\x12\x04\
    \x93\x03\x10\x1b\n\x0f\n\x07\x04\"\x04\0\x02\0\x02\x12\x04\x93\x03\x1e\
    \x1f\n\x0e\n\x06\x04\"\x04\0\x02\x01\x12\x04\x94\x03\x10*\n\x0f\n\x07\
    \x04\"\x04\0\x02\x01\x01\x12\x04\x94\x03\x10%\n\x0f\n\x07\x04\"\x04\0\
    \x02\x01\x02\x12\x04\x94\x03()\n\x0e\n\x06\x04\"\x04\0\x02\x02\x12\x04\
    \x95\x03\x10-\n\x0f\n\x07\x04\"\x04\0\x02\x02\x01\x12\x04\x95\x03\x10(\n\
    \x0f\n\x07\x04\"\x04\0\x02\x02\x02\x12\x04\x95\x03+,\n\x0e\n\x06\x04\"\
    \x04\0\x02\x03\x12\x04\x96\x03\x10(\n\x0f\n\x07\x04\"\x04\0\x02\x03\x01\
    \x12\x04\x96\x03\x10#\n\x0f\n\x07\x04\"\x04\0\x02\x03\x02\x12\x04\x96\
    \x03&'\n\x0c\n\x04\x04\"\x02\0\x12\x04\x99\x03\x08%\n\r\n\x05\x04\"\x02\
    \0\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\x99\x03\
    \x11\x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x99\x03\x18\x20\n\r\n\x05\x04\
    \"\x02\0\x03\x12\x04\x99\x03#$\n\x0c\n\x04\x04\"\x02\x01\x12\x04\x9a\x03\
    \x08$\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\x9a\x03\x08\x10\n\r\n\x05\x04\
    \"\x02\x01\x05\x12\x04\x9a\x03\x11\x17\n\r\n\x05\x04\"\x02\x01\x01\x12\
    \x04\x9a\x03\x18\x1f\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\x9a\x03\"#\n\
    \x0c\n\x02\x04#\x12\x06\x9d\x03\0\xa3\x03\x01\n\x0b\n\x03\x04#\x01\x12\
    \x04\x9d\x03\x08\x1d\n\x0c\n\x04\x04#\x02\0\x12\x04\x9e\x03\x08*\n\r\n\
    \x05\x04#\x02\0\x04\x12\x04\x9e\x03\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\
    \x04\x9e\x03\x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\x9e\x03\x18%\n\r\n\
    \x05\x04#\x02\0\x03\x12\x04\x9e\x03()\n\x0c\n\x04\x04#\x02\x01\x12\x04\
    \x9f\x03\x08+\n\r\n\x05\x04#\x02\x01\x04\x12\x04\x9f\x03\x08\x10\n\r\n\
    \x05\x04#\x02\x01\x05\x12\x04\x9f\x03\x11\x17\n\r\n\x05\x04#\x02\x01\x01\
    \x12\x04\x9f\x03\x18&\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x9f\x03)*\n\x0c\
    \n\x04\x04#\x02\x02\x12\x04\xa0\x03\x08*\n\r\n\x05\x04#\x02\x02\x04\x12\
    \x04\xa0\x03\x08\x10\n\r\n\x05\x04#\x02\x02\x05\x12\x04\xa0\x03\x11\x17\
    \n\r\n\x05\x04#\x02\x02\x01\x12\x04\xa0\x03\x18%\n\r\n\x05\x04#\x02\x02\
    \x03\x12\x04\xa0\x03()\n\x0c\n\x04\x04#\x02\x03\x12\x04\xa1\x03\x08'\n\r\
    \n\x05\x04#\x02\x03\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04#\x02\x03\
    \x05\x12\x04\xa1\x03\x11\x17\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xa1\x03\
    \x18\"\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xa1\x03%&\n\x0c\n\x04\x04#\x02\
    \x04\x12\x04\xa2\x03\x08)\n\r\n\x05\x04#\x02\x04\x04\x12\x04\xa2\x03\x08\
    \x10\n\r\n\x05\x04#\x02\x04\x05\x12\x04\xa2\x03\x11\x17\n\r\n\x05\x04#\
    \x02\x04\x01\x12\x04\xa2\x03\x18$\n\r\n\x05\x04#\x02\x04\x03\x12\x04\xa2\
    \x03'(\n\x0c\n\x02\x04$\x12\x06\xa5\x03\0\xa7\x03\x01\n\x0b\n\x03\x04$\
    \x01\x12\x04\xa5\x03\x08%\n\x0c\n\x04\x04$\x02\0\x12\x04\xa6\x03\x08\"\n\
    \r\n\x05\x04$\x02\0\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04$\x02\0\x05\
    \x12\x04\xa6\x03\x11\x15\n\r\n\x05\x04$\x02\0\x01\x12\x04\xa6\x03\x16\
    \x1d\n\r\n\x05\x04$\x02\0\x03\x12\x04\xa6\x03\x20!\n\x0c\n\x02\x04%\x12\
    \x06\xa9\x03\0\xab\x03\x01\n\x0b\n\x03\x04%\x01\x12\x04\xa9\x03\x08\"\n\
    \x0c\n\x04\x04%\x02\0\x12\x04\xaa\x03\x08$\n\r\n\x05\x04%\x02\0\x04\x12\
    \x04\xaa\x03\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\xaa\x03\x11\x17\n\
    \r\n\x05\x04%\x02\0\x01\x12\x04\xaa\x03\x18\x1f\n\r\n\x05\x04%\x02\0\x03\
    \x12\x04\xaa\x03\"#\n\x0c\n\x02\x04&\x12\x06\xad\x03\0\xaf\x03\x01\n\x0b\
    \n\x03\x04&\x01\x12\x04\xad\x03\x08*\n\x0c\n\x04\x04&\x02\0\x12\x04\xae\
    \x03\x08\"\n\r\n\x05\x04&\x02\0\x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\
    \x04&\x02\0\x05\x12\x04\xae\x03\x11\x15\n\r\n\x05\x04&\x02\0\x01\x12\x04\
    \xae\x03\x16\x1d\n\r\n\x05\x04&\x02\0\x03\x12\x04\xae\x03\x20!\n\x0c\n\
    \x02\x04'\x12\x06\xb1\x03\0\xb3\x03\x01\n\x0b\n\x03\x04'\x01\x12\x04\xb1\
    \x03\x08(\n\x0c\n\x04\x04'\x02\0\x12\x04\xb2\x03\x08'\n\r\n\x05\x04'\x02\
    \0\x04\x12\x04\xb2\x03\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xb2\x03\
    \x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xb2\x03\x18\"\n\r\n\x05\x04'\
    \x02\0\x03\x12\x04\xb2\x03%&\n\x0c\n\x02\x04(\x12\x06\xb5\x03\0\xb7\x03\
    \x01\n\x0b\n\x03\x04(\x01\x12\x04\xb5\x03\x080\n\x0c\n\x04\x04(\x02\0\
    \x12\x04\xb6\x03\x08&\n\r\n\x05\x04(\x02\0\x04\x12\x04\xb6\x03\x08\x10\n\
    \r\n\x05\x04(\x02\0\x05\x12\x04\xb6\x03\x11\x17\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\xb6\x03\x18!\n\r\n\x05\x04(\x02\0\x03\x12\x04\xb6\x03$%\n\x0c\n\
    \x02\x04)\x12\x06\xb9\x03\0\xbc\x03\x01\n\x0b\n\x03\x04)\x01\x12\x04\xb9\
    \x03\x08\x19\n\x0c\n\x04\x04)\x02\0\x12\x04\xba\x03\x08'\n\r\n\x05\x04)\
    \x02\0\x04\x12\x04\xba\x03\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\xba\
    \x03\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\x04\xba\x03\x18\"\n\r\n\x05\
    \x04)\x02\0\x03\x12\x04\xba\x03%&\n\x0c\n\x04\x04)\x02\x01\x12\x04\xbb\
    \x03\x08$\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\
    \x04)\x02\x01\x05\x12\x04\xbb\x03\x11\x17\n\r\n\x05\x04)\x02\x01\x01\x12\
    \x04\xbb\x03\x18\x1f\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xbb\x03\"#\n\x0c\
    \n\x02\x04*\x12\x06\xbe\x03\0\xc2\x03\x01\n\x0b\n\x03\x04*\x01\x12\x04\
    \xbe\x03\x08(\n\x0c\n\x04\x04*\x02\0\x12\x04\xbf\x03\x08$\n\r\n\x05\x04*\
    \x02\0\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\xbf\
    \x03\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xbf\x03\x18\x1f\n\r\n\x05\
    \x04*\x02\0\x03\x12\x04\xbf\x03\"#\n\x0c\n\x04\x04*\x02\x01\x12\x04\xc0\
    \x03\x08/\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xc0\x03\x08\x10\n\r\n\x05\
    \x04*\x02\x01\x05\x12\x04\xc0\x03\x11\x17\n\r\n\x05\x04*\x02\x01\x01\x12\
    \x04\xc0\x03\x18*\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xc0\x03-.\n\x0c\n\
    \x04\x04*\x02\x02\x12\x04\xc1\x03\x08)\n\r\n\x05\x04*\x02\x02\x04\x12\
    \x04\xc1\x03\x08\x10\n\r\n\x05\x04*\x02\x02\x05\x12\x04\xc1\x03\x11\x17\
    \n\r\n\x05\x04*\x02\x02\x01\x12\x04\xc1\x03\x18$\n\r\n\x05\x04*\x02\x02\
    \x03\x12\x04\xc1\x03'(\n\x0c\n\x02\x04+\x12\x06\xc4\x03\0\xcc\x03\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xc4\x03\x080\n\x0c\n\x04\x04+\x02\0\x12\x04\
    \xc5\x03\x08-\n\r\n\x05\x04+\x02\0\x04\x12\x04\xc5\x03\x08\x10\n\r\n\x05\
    \x04+\x02\0\x06\x12\x04\xc5\x03\x11\x1f\n\r\n\x05\x04+\x02\0\x01\x12\x04\
    \xc5\x03\x20(\n\r\n\x05\x04+\x02\0\x03\x12\x04\xc5\x03+,\n\x0c\n\x04\x04\
    +\x02\x01\x12\x04\xc6\x03\x080\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xc6\
    \x03\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xc6\x03\x11\x17\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\xc6\x03\x18+\n\r\n\x05\x04+\x02\x01\x03\
    \x12\x04\xc6\x03./\n\x0c\n\x04\x04+\x02\x02\x12\x04\xc7\x03\x08.\n\r\n\
    \x05\x04+\x02\x02\x04\x12\x04\xc7\x03\x08\x10\n\r\n\x05\x04+\x02\x02\x05\
    \x12\x04\xc7\x03\x11\x16\n\r\n\x05\x04+\x02\x02\x01\x12\x04\xc7\x03\x17)\
    \n\r\n\x05\x04+\x02\x02\x03\x12\x04\xc7\x03,-\n\x0c\n\x04\x04+\x02\x03\
    \x12\x04\xc8\x03\x08)\n\r\n\x05\x04+\x02\x03\x04\x12\x04\xc8\x03\x08\x10\
    \n\r\n\x05\x04+\x02\x03\x05\x12\x04\xc8\x03\x11\x17\n\r\n\x05\x04+\x02\
    \x03\x01\x12\x04\xc8\x03\x18$\n\r\n\x05\x04+\x02\x03\x03\x12\x04\xc8\x03\
    '(\n\x0c\n\x04\x04+\x02\x04\x12\x04\xc9\x03\x08'\n\r\n\x05\x04+\x02\x04\
    \x04\x12\x04\xc9\x03\x08\x10\n\r\n\x05\x04+\x02\x04\x05\x12\x04\xc9\x03\
    \x11\x16\n\r\n\x05\x04+\x02\x04\x01\x12\x04\xc9\x03\x17\"\n\r\n\x05\x04+\
    \x02\x04\x03\x12\x04\xc9\x03%&\n\x0c\n\x04\x04+\x02\x05\x12\x04\xca\x03\
    \x081\n\r\n\x05\x04+\x02\x05\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x04+\
    \x02\x05\x05\x12\x04\xca\x03\x11\x17\n\r\n\x05\x04+\x02\x05\x01\x12\x04\
    \xca\x03\x18,\n\r\n\x05\x04+\x02\x05\x03\x12\x04\xca\x03/0\n\x0c\n\x04\
    \x04+\x02\x06\x12\x04\xcb\x03\x08C\n\r\n\x05\x04+\x02\x06\x04\x12\x04\
    \xcb\x03\x08\x10\n\r\n\x05\x04+\x02\x06\x06\x12\x04\xcb\x03\x11,\n\r\n\
    \x05\x04+\x02\x06\x01\x12\x04\xcb\x03->\n\r\n\x05\x04+\x02\x06\x03\x12\
    \x04\xcb\x03AB\n\x0c\n\x02\x04,\x12\x06\xce\x03\0\xd0\x03\x01\n\x0b\n\
    \x03\x04,\x01\x12\x04\xce\x03\x08\x20\n\x0c\n\x04\x04,\x02\0\x12\x04\xcf\
    \x03\x08$\n\r\n\x05\x04,\x02\0\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04\
    ,\x02\0\x05\x12\x04\xcf\x03\x11\x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\xcf\
    \x03\x18\x1f\n\r\n\x05\x04,\x02\0\x03\x12\x04\xcf\x03\"#\n\x0c\n\x02\x04\
    -\x12\x06\xd2\x03\0\xd3\x03\x01\n\x0b\n\x03\x04-\x01\x12\x04\xd2\x03\x08\
    (\n\x0c\n\x02\x04.\x12\x06\xd5\x03\0\xe1\x03\x01\n\x0b\n\x03\x04.\x01\
    \x12\x04\xd5\x03\x080\n\x0e\n\x04\x04.\x03\0\x12\x06\xd6\x03\x08\xd9\x03\
    \t\n\r\n\x05\x04.\x03\0\x01\x12\x04\xd6\x03\x10\x20\n\x0e\n\x06\x04.\x03\
    \0\x02\0\x12\x04\xd7\x03\x10/\n\x0f\n\x07\x04.\x03\0\x02\0\x04\x12\x04\
    \xd7\x03\x10\x18\n\x0f\n\x07\x04.\x03\0\x02\0\x05\x12\x04\xd7\x03\x19\
    \x1f\n\x0f\n\x07\x04.\x03\0\x02\0\x01\x12\x04\xd7\x03\x20*\n\x0f\n\x07\
    \x04.\x03\0\x02\0\x03\x12\x04\xd7\x03-.\n\x0e\n\x06\x04.\x03\0\x02\x01\
    \x12\x04\xd8\x03\x10D\n\x0f\n\x07\x04.\x03\0\x02\x01\x04\x12\x04\xd8\x03\
    \x10\x18\n\x0f\n\x07\x04.\x03\0\x02\x01\x06\x12\x04\xd8\x03\x194\n\x0f\n\
    \x07\x04.\x03\0\x02\x01\x01\x12\x04\xd8\x035?\n\x0f\n\x07\x04.\x03\0\x02\
    \x01\x03\x12\x04\xd8\x03BC\n\x0c\n\x04\x04.\x02\0\x12\x04\xdb\x03\x08'\n\
    \r\n\x05\x04.\x02\0\x04\x12\x04\xdb\x03\x08\x10\n\r\n\x05\x04.\x02\0\x05\
    \x12\x04\xdb\x03\x11\x15\n\r\n\x05\x04.\x02\0\x01\x12\x04\xdb\x03\x16\"\
    \n\r\n\x05\x04.\x02\0\x03\x12\x04\xdb\x03%&\n\x0c\n\x04\x04.\x02\x01\x12\
    \x04\xdc\x03\x08)\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xdc\x03\x08\x10\n\r\
    \n\x05\x04.\x02\x01\x05\x12\x04\xdc\x03\x11\x15\n\r\n\x05\x04.\x02\x01\
    \x01\x12\x04\xdc\x03\x16$\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xdc\x03'(\n\
    \x0c\n\x04\x04.\x02\x02\x12\x04\xdd\x03\x08C\n\r\n\x05\x04.\x02\x02\x04\
    \x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04.\x02\x02\x06\x12\x04\xdd\x03\x11,\
    \n\r\n\x05\x04.\x02\x02\x01\x12\x04\xdd\x03->\n\r\n\x05\x04.\x02\x02\x03\
    \x12\x04\xdd\x03AB\n\x0c\n\x04\x04.\x02\x03\x12\x04\xde\x03\x087\n\r\n\
    \x05\x04.\x02\x03\x04\x12\x04\xde\x03\x08\x10\n\r\n\x05\x04.\x02\x03\x05\
    \x12\x04\xde\x03\x11\x17\n\r\n\x05\x04.\x02\x03\x01\x12\x04\xde\x03\x182\
    \n\r\n\x05\x04.\x02\x03\x03\x12\x04\xde\x0356\n\x0c\n\x04\x04.\x02\x04\
    \x12\x04\xdf\x03\x08B\n\r\n\x05\x04.\x02\x04\x04\x12\x04\xdf\x03\x08\x10\
    \n\r\n\x05\x04.\x02\x04\x05\x12\x04\xdf\x03\x11\x17\n\r\n\x05\x04.\x02\
    \x04\x01\x12\x04\xdf\x03\x18=\n\r\n\x05\x04.\x02\x04\x03\x12\x04\xdf\x03\
    @A\n\x0c\n\x04\x04.\x02\x05\x12\x04\xe0\x03\x08b\n\r\n\x05\x04.\x02\x05\
    \x04\x12\x04\xe0\x03\x08\x10\n\r\n\x05\x04.\x02\x05\x06\x12\x04\xe0\x03\
    \x11J\n\r\n\x05\x04.\x02\x05\x01\x12\x04\xe0\x03K]\n\r\n\x05\x04.\x02\
    \x05\x03\x12\x04\xe0\x03`a\n\x0c\n\x02\x04/\x12\x06\xe3\x03\0\xe5\x03\
    \x01\n\x0b\n\x03\x04/\x01\x12\x04\xe3\x03\x08\"\n\x0c\n\x04\x04/\x02\0\
    \x12\x04\xe4\x03\x08$\n\r\n\x05\x04/\x02\0\x04\x12\x04\xe4\x03\x08\x10\n\
    \r\n\x05\x04/\x02\0\x05\x12\x04\xe4\x03\x11\x17\n\r\n\x05\x04/\x02\0\x01\
    \x12\x04\xe4\x03\x18\x1f\n\r\n\x05\x04/\x02\0\x03\x12\x04\xe4\x03\"#\n\
    \x0c\n\x02\x040\x12\x06\xe7\x03\0\xf5\x03\x01\n\x0b\n\x03\x040\x01\x12\
    \x04\xe7\x03\x08*\n\x0e\n\x04\x040\x04\0\x12\x06\xe8\x03\x08\xf0\x03\t\n\
    \r\n\x05\x040\x04\0\x01\x12\x04\xe8\x03\r\x1a\n\x0e\n\x06\x040\x04\0\x02\
    \0\x12\x04\xe9\x03\x10-\n\x0f\n\x07\x040\x04\0\x02\0\x01\x12\x04\xe9\x03\
    \x10(\n\x0f\n\x07\x040\x04\0\x02\0\x02\x12\x04\xe9\x03+,\n\x0e\n\x06\x04\
    0\x04\0\x02\x01\x12\x04\xea\x03\x10:\n\x0f\n\x07\x040\x04\0\x02\x01\x01\
    \x12\x04\xea\x03\x105\n\x0f\n\x07\x040\x04\0\x02\x01\x02\x12\x04\xea\x03\
    89\n\x0e\n\x06\x040\x04\0\x02\x02\x12\x04\xeb\x03\x10F\n\x0f\n\x07\x040\
    \x04\0\x02\x02\x01\x12\x04\xeb\x03\x10A\n\x0f\n\x07\x040\x04\0\x02\x02\
    \x02\x12\x04\xeb\x03DE\n\x0e\n\x06\x040\x04\0\x02\x03\x12\x04\xec\x03\
    \x107\n\x0f\n\x07\x040\x04\0\x02\x03\x01\x12\x04\xec\x03\x102\n\x0f\n\
    \x07\x040\x04\0\x02\x03\x02\x12\x04\xec\x0356\n\x0e\n\x06\x040\x04\0\x02\
    \x04\x12\x04\xed\x03\x108\n\x0f\n\x07\x040\x04\0\x02\x04\x01\x12\x04\xed\
    \x03\x103\n\x0f\n\x07\x040\x04\0\x02\x04\x02\x12\x04\xed\x0367\n\x0e\n\
    \x06\x040\x04\0\x02\x05\x12\x04\xee\x03\x10:\n\x0f\n\x07\x040\x04\0\x02\
    \x05\x01\x12\x04\xee\x03\x105\n\x0f\n\x07\x040\x04\0\x02\x05\x02\x12\x04\
    \xee\x0389\n\x0e\n\x06\x040\x04\0\x02\x06\x12\x04\xef\x03\x10=\n\x0f\n\
    \x07\x040\x04\0\x02\x06\x01\x12\x04\xef\x03\x108\n\x0f\n\x07\x040\x04\0\
    \x02\x06\x02\x12\x04\xef\x03;<\n\x0c\n\x04\x040\x02\0\x12\x04\xf2\x03\
    \x08.\n\r\n\x05\x040\x02\0\x04\x12\x04\xf2\x03\x08\x10\n\r\n\x05\x040\
    \x02\0\x05\x12\x04\xf2\x03\x11\x17\n\r\n\x05\x040\x02\0\x01\x12\x04\xf2\
    \x03\x18)\n\r\n\x05\x040\x02\0\x03\x12\x04\xf2\x03,-\n\x0c\n\x04\x040\
    \x02\x01\x12\x04\xf3\x03\x08O\n\r\n\x05\x040\x02\x01\x04\x12\x04\xf3\x03\
    \x08\x10\n\r\n\x05\x040\x02\x01\x06\x12\x04\xf3\x03\x11A\n\r\n\x05\x040\
    \x02\x01\x01\x12\x04\xf3\x03BJ\n\r\n\x05\x040\x02\x01\x03\x12\x04\xf3\
    \x03MN\n\x0c\n\x04\x040\x02\x02\x12\x04\xf4\x03\x086\n\r\n\x05\x040\x02\
    \x02\x04\x12\x04\xf4\x03\x08\x10\n\r\n\x05\x040\x02\x02\x05\x12\x04\xf4\
    \x03\x11\x17\n\r\n\x05\x040\x02\x02\x01\x12\x04\xf4\x03\x181\n\r\n\x05\
    \x040\x02\x02\x03\x12\x04\xf4\x0345\n\x0c\n\x02\x041\x12\x06\xf7\x03\0\
    \xfa\x03\x01\n\x0b\n\x03\x041\x01\x12\x04\xf7\x03\x08/\n\x0c\n\x04\x041\
    \x02\0\x12\x04\xf8\x03\x08#\n\r\n\x05\x041\x02\0\x04\x12\x04\xf8\x03\x08\
    \x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xf8\x03\x11\x17\n\r\n\x05\x041\x02\
    \0\x01\x12\x04\xf8\x03\x18\x1e\n\r\n\x05\x041\x02\0\x03\x12\x04\xf8\x03!\
    \"\n\x0c\n\x04\x041\x02\x01\x12\x04\xf9\x03\x08%\n\r\n\x05\x041\x02\x01\
    \x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\xf9\x03\
    \x11\x17\n\r\n\x05\x041\x02\x01\x01\x12\x04\xf9\x03\x18\x20\n\r\n\x05\
    \x041\x02\x01\x03\x12\x04\xf9\x03#$\n\x0c\n\x02\x042\x12\x06\xfc\x03\0\
    \xfe\x03\x01\n\x0b\n\x03\x042\x01\x12\x04\xfc\x03\x08\x20\n\x0c\n\x04\
    \x042\x02\0\x12\x04\xfd\x03\x088\n\r\n\x05\x042\x02\0\x04\x12\x04\xfd\
    \x03\x08\x10\n\r\n\x05\x042\x02\0\x06\x12\x04\xfd\x03\x11,\n\r\n\x05\x04\
    2\x02\0\x01\x12\x04\xfd\x03-3\n\r\n\x05\x042\x02\0\x03\x12\x04\xfd\x0367\
    \n\x0c\n\x02\x043\x12\x06\x80\x04\0\x82\x04\x01\n\x0b\n\x03\x043\x01\x12\
    \x04\x80\x04\x08(\n\x0c\n\x04\x043\x02\0\x12\x04\x81\x04\x081\n\r\n\x05\
    \x043\x02\0\x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\
    \x81\x04\x11\x18\n\r\n\x05\x043\x02\0\x01\x12\x04\x81\x04\x19,\n\r\n\x05\
    \x043\x02\0\x03\x12\x04\x81\x04/0\n\x0c\n\x02\x044\x12\x06\x84\x04\0\x87\
    \x04\x01\n\x0b\n\x03\x044\x01\x12\x04\x84\x04\x08\"\n\x0c\n\x04\x044\x02\
    \0\x12\x04\x85\x04\x08$\n\r\n\x05\x044\x02\0\x04\x12\x04\x85\x04\x08\x10\
    \n\r\n\x05\x044\x02\0\x05\x12\x04\x85\x04\x11\x17\n\r\n\x05\x044\x02\0\
    \x01\x12\x04\x85\x04\x18\x1f\n\r\n\x05\x044\x02\0\x03\x12\x04\x85\x04\"#\
    \n\x0c\n\x04\x044\x02\x01\x12\x04\x86\x04\x08(\n\r\n\x05\x044\x02\x01\
    \x04\x12\x04\x86\x04\x08\x10\n\r\n\x05\x044\x02\x01\x05\x12\x04\x86\x04\
    \x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\x86\x04\x18#\n\r\n\x05\x044\
    \x02\x01\x03\x12\x04\x86\x04&'\n\x0c\n\x02\x045\x12\x06\x89\x04\0\x91\
    \x04\x01\n\x0b\n\x03\x045\x01\x12\x04\x89\x04\x08*\n\x0e\n\x04\x045\x04\
    \0\x12\x06\x8a\x04\x08\x8e\x04\t\n\r\n\x05\x045\x04\0\x01\x12\x04\x8a\
    \x04\r\x16\n\x0e\n\x06\x045\x04\0\x02\0\x12\x04\x8b\x04\x10)\n\x0f\n\x07\
    \x045\x04\0\x02\0\x01\x12\x04\x8b\x04\x10$\n\x0f\n\x07\x045\x04\0\x02\0\
    \x02\x12\x04\x8b\x04'(\n\x0e\n\x06\x045\x04\0\x02\x01\x12\x04\x8c\x04\
    \x10&\n\x0f\n\x07\x045\x04\0\x02\x01\x01\x12\x04\x8c\x04\x10!\n\x0f\n\
    \x07\x045\x04\0\x02\x01\x02\x12\x04\x8c\x04$%\n\x0e\n\x06\x045\x04\0\x02\
    \x02\x12\x04\x8d\x04\x104\n\x0f\n\x07\x045\x04\0\x02\x02\x01\x12\x04\x8d\
    \x04\x10/\n\x0f\n\x07\x045\x04\0\x02\x02\x02\x12\x04\x8d\x0423\n\x0c\n\
    \x04\x045\x02\0\x12\x04\x90\x04\x08K\n\r\n\x05\x045\x02\0\x04\x12\x04\
    \x90\x04\x08\x10\n\r\n\x05\x045\x02\0\x06\x12\x04\x90\x04\x11=\n\r\n\x05\
    \x045\x02\0\x01\x12\x04\x90\x04>F\n\r\n\x05\x045\x02\0\x03\x12\x04\x90\
    \x04IJ\n\x0c\n\x02\x046\x12\x06\x93\x04\0\x97\x04\x01\n\x0b\n\x03\x046\
    \x01\x12\x04\x93\x04\x08%\n\x0c\n\x04\x046\x02\0\x12\x04\x94\x04\x08+\n\
    \r\n\x05\x046\x02\0\x04\x12\x04\x94\x04\x08\x10\n\r\n\x05\x046\x02\0\x05\
    \x12\x04\x94\x04\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\x94\x04\x18&\n\
    \r\n\x05\x046\x02\0\x03\x12\x04\x94\x04)*\n\x0c\n\x04\x046\x02\x01\x12\
    \x04\x95\x04\x08(\n\r\n\x05\x046\x02\x01\x04\x12\x04\x95\x04\x08\x10\n\r\
    \n\x05\x046\x02\x01\x05\x12\x04\x95\x04\x11\x17\n\r\n\x05\x046\x02\x01\
    \x01\x12\x04\x95\x04\x18#\n\r\n\x05\x046\x02\x01\x03\x12\x04\x95\x04&'\n\
    \x0c\n\x04\x046\x02\x02\x12\x04\x96\x04\x080\n\r\n\x05\x046\x02\x02\x04\
    \x12\x04\x96\x04\x08\x10\n\r\n\x05\x046\x02\x02\x05\x12\x04\x96\x04\x11\
    \x17\n\r\n\x05\x046\x02\x02\x01\x12\x04\x96\x04\x18+\n\r\n\x05\x046\x02\
    \x02\x03\x12\x04\x96\x04./\n\x0c\n\x02\x047\x12\x06\x99\x04\0\xad\x04\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\x99\x04\x08-\n\x0e\n\x04\x047\x04\0\
    \x12\x06\x9a\x04\x08\xa7\x04\t\n\r\n\x05\x047\x04\0\x01\x12\x04\x9a\x04\
    \r\x19\n\x0e\n\x06\x047\x04\0\x02\0\x12\x04\x9b\x04\x10,\n\x0f\n\x07\x04\
    7\x04\0\x02\0\x01\x12\x04\x9b\x04\x10'\n\x0f\n\x07\x047\x04\0\x02\0\x02\
    \x12\x04\x9b\x04*+\n\x0e\n\x06\x047\x04\0\x02\x01\x12\x04\x9c\x04\x100\n\
    \x0f\n\x07\x047\x04\0\x02\x01\x01\x12\x04\x9c\x04\x10+\n\x0f\n\x07\x047\
    \x04\0\x02\x01\x02\x12\x04\x9c\x04./\n\x0e\n\x06\x047\x04\0\x02\x02\x12\
    \x04\x9d\x04\x104\n\x0f\n\x07\x047\x04\0\x02\x02\x01\x12\x04\x9d\x04\x10\
    /\n\x0f\n\x07\x047\x04\0\x02\x02\x02\x12\x04\x9d\x0423\n\x0e\n\x06\x047\
    \x04\0\x02\x03\x12\x04\x9e\x04\x104\n\x0f\n\x07\x047\x04\0\x02\x03\x01\
    \x12\x04\x9e\x04\x10/\n\x0f\n\x07\x047\x04\0\x02\x03\x02\x12\x04\x9e\x04\
    23\n\x0e\n\x06\x047\x04\0\x02\x04\x12\x04\x9f\x04\x107\n\x0f\n\x07\x047\
    \x04\0\x02\x04\x01\x12\x04\x9f\x04\x102\n\x0f\n\x07\x047\x04\0\x02\x04\
    \x02\x12\x04\x9f\x0456\n\x0e\n\x06\x047\x04\0\x02\x05\x12\x04\xa0\x04\
    \x10:\n\x0f\n\x07\x047\x04\0\x02\x05\x01\x12\x04\xa0\x04\x105\n\x0f\n\
    \x07\x047\x04\0\x02\x05\x02\x12\x04\xa0\x0489\n\x0e\n\x06\x047\x04\0\x02\
    \x06\x12\x04\xa1\x04\x107\n\x0f\n\x07\x047\x04\0\x02\x06\x01\x12\x04\xa1\
    \x04\x102\n\x0f\n\x07\x047\x04\0\x02\x06\x02\x12\x04\xa1\x0456\n\x0e\n\
    \x06\x047\x04\0\x02\x07\x12\x04\xa2\x04\x10;\n\x0f\n\x07\x047\x04\0\x02\
    \x07\x01\x12\x04\xa2\x04\x106\n\x0f\n\x07\x047\x04\0\x02\x07\x02\x12\x04\
    \xa2\x049:\n\x0e\n\x06\x047\x04\0\x02\x08\x12\x04\xa3\x04\x109\n\x0f\n\
    \x07\x047\x04\0\x02\x08\x01\x12\x04\xa3\x04\x104\n\x0f\n\x07\x047\x04\0\
    \x02\x08\x02\x12\x04\xa3\x0478\n\x0e\n\x06\x047\x04\0\x02\t\x12\x04\xa4\
    \x04\x104\n\x0f\n\x07\x047\x04\0\x02\t\x01\x12\x04\xa4\x04\x10/\n\x0f\n\
    \x07\x047\x04\0\x02\t\x02\x12\x04\xa4\x0423\n\x0e\n\x06\x047\x04\0\x02\n\
    \x12\x04\xa5\x04\x108\n\x0f\n\x07\x047\x04\0\x02\n\x01\x12\x04\xa5\x04\
    \x102\n\x0f\n\x07\x047\x04\0\x02\n\x02\x12\x04\xa5\x0457\n\x0e\n\x06\x04\
    7\x04\0\x02\x0b\x12\x04\xa6\x04\x108\n\x0f\n\x07\x047\x04\0\x02\x0b\x01\
    \x12\x04\xa6\x04\x102\n\x0f\n\x07\x047\x04\0\x02\x0b\x02\x12\x04\xa6\x04\
    57\n\x0c\n\x04\x047\x02\0\x12\x04\xa9\x04\x08Q\n\r\n\x05\x047\x02\0\x04\
    \x12\x04\xa9\x04\x08\x10\n\r\n\x05\x047\x02\0\x06\x12\x04\xa9\x04\x11C\n\
    \r\n\x05\x047\x02\0\x01\x12\x04\xa9\x04DL\n\r\n\x05\x047\x02\0\x03\x12\
    \x04\xa9\x04OP\n\x0c\n\x04\x047\x02\x01\x12\x04\xaa\x04\x08$\n\r\n\x05\
    \x047\x02\x01\x04\x12\x04\xaa\x04\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\
    \x04\xaa\x04\x11\x17\n\r\n\x05\x047\x02\x01\x01\x12\x04\xaa\x04\x18\x1f\
    \n\r\n\x05\x047\x02\x01\x03\x12\x04\xaa\x04\"#\n\x0c\n\x04\x047\x02\x02\
    \x12\x04\xab\x04\x08(\n\r\n\x05\x047\x02\x02\x04\x12\x04\xab\x04\x08\x10\
    \n\r\n\x05\x047\x02\x02\x05\x12\x04\xab\x04\x11\x17\n\r\n\x05\x047\x02\
    \x02\x01\x12\x04\xab\x04\x18#\n\r\n\x05\x047\x02\x02\x03\x12\x04\xab\x04\
    &'\n\x0c\n\x04\x047\x02\x03\x12\x04\xac\x04\x08)\n\r\n\x05\x047\x02\x03\
    \x04\x12\x04\xac\x04\x08\x10\n\r\n\x05\x047\x02\x03\x05\x12\x04\xac\x04\
    \x11\x17\n\r\n\x05\x047\x02\x03\x01\x12\x04\xac\x04\x18$\n\r\n\x05\x047\
    \x02\x03\x03\x12\x04\xac\x04'(\n\x0c\n\x02\x048\x12\x06\xaf\x04\0\xb4\
    \x04\x01\n\x0b\n\x03\x048\x01\x12\x04\xaf\x04\x08.\n\x0c\n\x04\x048\x02\
    \0\x12\x04\xb0\x04\x08%\n\r\n\x05\x048\x02\0\x04\x12\x04\xb0\x04\x08\x10\
    \n\r\n\x05\x048\x02\0\x05\x12\x04\xb0\x04\x11\x17\n\r\n\x05\x048\x02\0\
    \x01\x12\x04\xb0\x04\x18\x20\n\r\n\x05\x048\x02\0\x03\x12\x04\xb0\x04#$\
    \n\x0c\n\x04\x048\x02\x01\x12\x04\xb1\x04\x08)\n\r\n\x05\x048\x02\x01\
    \x04\x12\x04\xb1\x04\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\x04\xb1\x04\
    \x11\x17\n\r\n\x05\x048\x02\x01\x01\x12\x04\xb1\x04\x18$\n\r\n\x05\x048\
    \x02\x01\x03\x12\x04\xb1\x04'(\n\x0c\n\x04\x048\x02\x02\x12\x04\xb2\x04\
    \x08.\n\r\n\x05\x048\x02\x02\x04\x12\x04\xb2\x04\x08\x10\n\r\n\x05\x048\
    \x02\x02\x05\x12\x04\xb2\x04\x11\x17\n\r\n\x05\x048\x02\x02\x01\x12\x04\
    \xb2\x04\x18)\n\r\n\x05\x048\x02\x02\x03\x12\x04\xb2\x04,-\n\x0c\n\x04\
    \x048\x02\x03\x12\x04\xb3\x04\x08+\n\r\n\x05\x048\x02\x03\x04\x12\x04\
    \xb3\x04\x08\x10\n\r\n\x05\x048\x02\x03\x05\x12\x04\xb3\x04\x11\x17\n\r\
    \n\x05\x048\x02\x03\x01\x12\x04\xb3\x04\x18&\n\r\n\x05\x048\x02\x03\x03\
    \x12\x04\xb3\x04)*\n\x0c\n\x02\x049\x12\x06\xb6\x04\0\xb9\x04\x01\n\x0b\
    \n\x03\x049\x01\x12\x04\xb6\x04\x08!\n\x0c\n\x04\x049\x02\0\x12\x04\xb7\
    \x04\x08*\n\r\n\x05\x049\x02\0\x04\x12\x04\xb7\x04\x08\x10\n\r\n\x05\x04\
    9\x02\0\x05\x12\x04\xb7\x04\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xb7\
    \x04\x18%\n\r\n\x05\x049\x02\0\x03\x12\x04\xb7\x04()\n\x0c\n\x04\x049\
    \x02\x01\x12\x04\xb8\x04\x08(\n\r\n\x05\x049\x02\x01\x04\x12\x04\xb8\x04\
    \x08\x10\n\r\n\x05\x049\x02\x01\x05\x12\x04\xb8\x04\x11\x17\n\r\n\x05\
    \x049\x02\x01\x01\x12\x04\xb8\x04\x18#\n\r\n\x05\x049\x02\x01\x03\x12\
    \x04\xb8\x04&'\n\x0c\n\x02\x04:\x12\x06\xbb\x04\0\xc3\x04\x01\n\x0b\n\
    \x03\x04:\x01\x12\x04\xbb\x04\x08)\n\x0e\n\x04\x04:\x03\0\x12\x06\xbc\
    \x04\x08\xbf\x04\t\n\r\n\x05\x04:\x03\0\x01\x12\x04\xbc\x04\x10\x14\n\
    \x0e\n\x06\x04:\x03\0\x02\0\x12\x04\xbd\x04\x10,\n\x0f\n\x07\x04:\x03\0\
    \x02\0\x04\x12\x04\xbd\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\0\x05\x12\
    \x04\xbd\x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\0\x01\x12\x04\xbd\x04\
    \x20'\n\x0f\n\x07\x04:\x03\0\x02\0\x03\x12\x04\xbd\x04*+\n\x0e\n\x06\x04\
    :\x03\0\x02\x01\x12\x04\xbe\x04\x10.\n\x0f\n\x07\x04:\x03\0\x02\x01\x04\
    \x12\x04\xbe\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x01\x05\x12\x04\xbe\
    \x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x01\x01\x12\x04\xbe\x04\x20)\n\
    \x0f\n\x07\x04:\x03\0\x02\x01\x03\x12\x04\xbe\x04,-\n\x0c\n\x04\x04:\x02\
    \0\x12\x04\xc1\x04\x08+\n\r\n\x05\x04:\x02\0\x04\x12\x04\xc1\x04\x08\x10\
    \n\r\n\x05\x04:\x02\0\x06\x12\x04\xc1\x04\x11\x1f\n\r\n\x05\x04:\x02\0\
    \x01\x12\x04\xc1\x04\x20&\n\r\n\x05\x04:\x02\0\x03\x12\x04\xc1\x04)*\n\
    \x0c\n\x04\x04:\x02\x01\x12\x04\xc2\x04\x08J\n\r\n\x05\x04:\x02\x01\x04\
    \x12\x04\xc2\x04\x08\x10\n\r\n\x05\x04:\x02\x01\x06\x12\x04\xc2\x04\x117\
    \n\r\n\x05\x04:\x02\x01\x01\x12\x04\xc2\x048E\n\r\n\x05\x04:\x02\x01\x03\
    \x12\x04\xc2\x04HI\n\x0c\n\x02\x04;\x12\x06\xc5\x04\0\xc7\x04\x01\n\x0b\
    \n\x03\x04;\x01\x12\x04\xc5\x04\x08)\n\x0c\n\x04\x04;\x02\0\x12\x04\xc6\
    \x04\x08$\n\r\n\x05\x04;\x02\0\x04\x12\x04\xc6\x04\x08\x10\n\r\n\x05\x04\
    ;\x02\0\x05\x12\x04\xc6\x04\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\xc6\
    \x04\x18\x1f\n\r\n\x05\x04;\x02\0\x03\x12\x04\xc6\x04\"#\n\x0c\n\x02\x04\
    <\x12\x06\xc9\x04\0\xd4\x04\x01\n\x0b\n\x03\x04<\x01\x12\x04\xc9\x04\x08\
    1\n\x0e\n\x04\x04<\x04\0\x12\x06\xca\x04\x08\xd0\x04\t\n\r\n\x05\x04<\
    \x04\0\x01\x12\x04\xca\x04\r!\n\x0e\n\x06\x04<\x04\0\x02\0\x12\x04\xcb\
    \x04\x104\n\x0f\n\x07\x04<\x04\0\x02\0\x01\x12\x04\xcb\x04\x10/\n\x0f\n\
    \x07\x04<\x04\0\x02\0\x02\x12\x04\xcb\x0423\n\x0e\n\x06\x04<\x04\0\x02\
    \x01\x12\x04\xcc\x04\x101\n\x0f\n\x07\x04<\x04\0\x02\x01\x01\x12\x04\xcc\
    \x04\x10,\n\x0f\n\x07\x04<\x04\0\x02\x01\x02\x12\x04\xcc\x04/0\n\x0e\n\
    \x06\x04<\x04\0\x02\x02\x12\x04\xcd\x04\x10?\n\x0f\n\x07\x04<\x04\0\x02\
    \x02\x01\x12\x04\xcd\x04\x10:\n\x0f\n\x07\x04<\x04\0\x02\x02\x02\x12\x04\
    \xcd\x04=>\n\x0e\n\x06\x04<\x04\0\x02\x03\x12\x04\xce\x04\x10J\n\x0f\n\
    \x07\x04<\x04\0\x02\x03\x01\x12\x04\xce\x04\x10E\n\x0f\n\x07\x04<\x04\0\
    \x02\x03\x02\x12\x04\xce\x04HI\n\x0e\n\x06\x04<\x04\0\x02\x04\x12\x04\
    \xcf\x04\x10F\n\x0f\n\x07\x04<\x04\0\x02\x04\x01\x12\x04\xcf\x04\x10A\n\
    \x0f\n\x07\x04<\x04\0\x02\x04\x02\x12\x04\xcf\x04DE\n\x0c\n\x04\x04<\x02\
    \0\x12\x04\xd2\x04\x08]\n\r\n\x05\x04<\x02\0\x04\x12\x04\xd2\x04\x08\x10\
    \n\r\n\x05\x04<\x02\0\x06\x12\x04\xd2\x04\x11O\n\r\n\x05\x04<\x02\0\x01\
    \x12\x04\xd2\x04PX\n\r\n\x05\x04<\x02\0\x03\x12\x04\xd2\x04[\\\n\x0c\n\
    \x04\x04<\x02\x01\x12\x04\xd3\x04\x08$\n\r\n\x05\x04<\x02\x01\x04\x12\
    \x04\xd3\x04\x08\x10\n\r\n\x05\x04<\x02\x01\x05\x12\x04\xd3\x04\x11\x17\
    \n\r\n\x05\x04<\x02\x01\x01\x12\x04\xd3\x04\x18\x1f\n\r\n\x05\x04<\x02\
    \x01\x03\x12\x04\xd3\x04\"#\n\x0c\n\x02\x04=\x12\x06\xd6\x04\0\xda\x04\
    \x01\n\x0b\n\x03\x04=\x01\x12\x04\xd6\x04\x08\x1e\n\x0c\n\x04\x04=\x02\0\
    \x12\x04\xd7\x04\x08,\n\r\n\x05\x04=\x02\0\x04\x12\x04\xd7\x04\x08\x10\n\
    \r\n\x05\x04=\x02\0\x05\x12\x04\xd7\x04\x11\x17\n\r\n\x05\x04=\x02\0\x01\
    \x12\x04\xd7\x04\x18'\n\r\n\x05\x04=\x02\0\x03\x12\x04\xd7\x04*+\n\x0c\n\
    \x04\x04=\x02\x01\x12\x04\xd8\x04\x08)\n\r\n\x05\x04=\x02\x01\x04\x12\
    \x04\xd8\x04\x08\x10\n\r\n\x05\x04=\x02\x01\x05\x12\x04\xd8\x04\x11\x17\
    \n\r\n\x05\x04=\x02\x01\x01\x12\x04\xd8\x04\x18$\n\r\n\x05\x04=\x02\x01\
    \x03\x12\x04\xd8\x04'(\n\x0c\n\x04\x04=\x02\x02\x12\x04\xd9\x04\x08!\n\r\
    \n\x05\x04=\x02\x02\x04\x12\x04\xd9\x04\x08\x10\n\r\n\x05\x04=\x02\x02\
    \x05\x12\x04\xd9\x04\x11\x17\n\r\n\x05\x04=\x02\x02\x01\x12\x04\xd9\x04\
    \x18\x1c\n\r\n\x05\x04=\x02\x02\x03\x12\x04\xd9\x04\x1f\x20\n\x0c\n\x02\
    \x04>\x12\x06\xdc\x04\0\xe7\x04\x01\n\x0b\n\x03\x04>\x01\x12\x04\xdc\x04\
    \x08&\n\x0e\n\x04\x04>\x04\0\x12\x06\xdd\x04\x08\xe3\x04\t\n\r\n\x05\x04\
    >\x04\0\x01\x12\x04\xdd\x04\r\x16\n\x0e\n\x06\x04>\x04\0\x02\0\x12\x04\
    \xde\x04\x10)\n\x0f\n\x07\x04>\x04\0\x02\0\x01\x12\x04\xde\x04\x10$\n\
    \x0f\n\x07\x04>\x04\0\x02\0\x02\x12\x04\xde\x04'(\n\x0e\n\x06\x04>\x04\0\
    \x02\x01\x12\x04\xdf\x04\x10&\n\x0f\n\x07\x04>\x04\0\x02\x01\x01\x12\x04\
    \xdf\x04\x10!\n\x0f\n\x07\x04>\x04\0\x02\x01\x02\x12\x04\xdf\x04$%\n\x0e\
    \n\x06\x04>\x04\0\x02\x02\x12\x04\xe0\x04\x104\n\x0f\n\x07\x04>\x04\0\
    \x02\x02\x01\x12\x04\xe0\x04\x10/\n\x0f\n\x07\x04>\x04\0\x02\x02\x02\x12\
    \x04\xe0\x0423\n\x0e\n\x06\x04>\x04\0\x02\x03\x12\x04\xe1\x04\x104\n\x0f\
    \n\x07\x04>\x04\0\x02\x03\x01\x12\x04\xe1\x04\x10/\n\x0f\n\x07\x04>\x04\
    \0\x02\x03\x02\x12\x04\xe1\x0423\n\x0e\n\x06\x04>\x04\0\x02\x04\x12\x04\
    \xe2\x04\x104\n\x0f\n\x07\x04>\x04\0\x02\x04\x01\x12\x04\xe2\x04\x10/\n\
    \x0f\n\x07\x04>\x04\0\x02\x04\x02\x12\x04\xe2\x0423\n\x0c\n\x04\x04>\x02\
    \0\x12\x04\xe5\x04\x08G\n\r\n\x05\x04>\x02\0\x04\x12\x04\xe5\x04\x08\x10\
    \n\r\n\x05\x04>\x02\0\x06\x12\x04\xe5\x04\x119\n\r\n\x05\x04>\x02\0\x01\
    \x12\x04\xe5\x04:B\n\r\n\x05\x04>\x02\0\x03\x12\x04\xe5\x04EF\n\x0c\n\
    \x04\x04>\x02\x01\x12\x04\xe6\x04\x08$\n\r\n\x05\x04>\x02\x01\x04\x12\
    \x04\xe6\x04\x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xe6\x04\x11\x17\
    \n\r\n\x05\x04>\x02\x01\x01\x12\x04\xe6\x04\x18\x1f\n\r\n\x05\x04>\x02\
    \x01\x03\x12\x04\xe6\x04\"#\n\x0c\n\x02\x04?\x12\x06\xe9\x04\0\xec\x04\
    \x01\n\x0b\n\x03\x04?\x01\x12\x04\xe9\x04\x08\x1d\n\x0c\n\x04\x04?\x02\0\
    \x12\x04\xea\x04\x08$\n\r\n\x05\x04?\x02\0\x04\x12\x04\xea\x04\x08\x10\n\
    \r\n\x05\x04?\x02\0\x05\x12\x04\xea\x04\x11\x17\n\r\n\x05\x04?\x02\0\x01\
    \x12\x04\xea\x04\x18\x1f\n\r\n\x05\x04?\x02\0\x03\x12\x04\xea\x04\"#\n\
    \x0c\n\x04\x04?\x02\x01\x12\x04\xeb\x04\x08)\n\r\n\x05\x04?\x02\x01\x04\
    \x12\x04\xeb\x04\x08\x10\n\r\n\x05\x04?\x02\x01\x05\x12\x04\xeb\x04\x11\
    \x17\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xeb\x04\x18$\n\r\n\x05\x04?\x02\
    \x01\x03\x12\x04\xeb\x04'(\n\x0c\n\x02\x04@\x12\x06\xee\x04\0\xf9\x04\
    \x01\n\x0b\n\x03\x04@\x01\x12\x04\xee\x04\x08-\n\x0c\n\x04\x04@\x02\0\
    \x12\x04\xef\x04\x08%\n\r\n\x05\x04@\x02\0\x04\x12\x04\xef\x04\x08\x10\n\
    \r\n\x05\x04@\x02\0\x05\x12\x04\xef\x04\x11\x17\n\r\n\x05\x04@\x02\0\x01\
    \x12\x04\xef\x04\x18\x20\n\r\n\x05\x04@\x02\0\x03\x12\x04\xef\x04#$\n\
    \x0c\n\x04\x04@\x02\x01\x12\x04\xf0\x04\x08)\n\r\n\x05\x04@\x02\x01\x04\
    \x12\x04\xf0\x04\x08\x10\n\r\n\x05\x04@\x02\x01\x05\x12\x04\xf0\x04\x11\
    \x17\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xf0\x04\x18$\n\r\n\x05\x04@\x02\
    \x01\x03\x12\x04\xf0\x04'(\n\x0c\n\x04\x04@\x02\x02\x12\x04\xf1\x04\x08'\
    \n\r\n\x05\x04@\x02\x02\x04\x12\x04\xf1\x04\x08\x10\n\r\n\x05\x04@\x02\
    \x02\x05\x12\x04\xf1\x04\x11\x17\n\r\n\x05\x04@\x02\x02\x01\x12\x04\xf1\
    \x04\x18\"\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xf1\x04%&\n\x0c\n\x04\x04@\
    \x02\x03\x12\x04\xf2\x04\x08.\n\r\n\x05\x04@\x02\x03\x04\x12\x04\xf2\x04\
    \x08\x10\n\r\n\x05\x04@\x02\x03\x05\x12\x04\xf2\x04\x11\x17\n\r\n\x05\
    \x04@\x02\x03\x01\x12\x04\xf2\x04\x18)\n\r\n\x05\x04@\x02\x03\x03\x12\
    \x04\xf2\x04,-\n\x0c\n\x04\x04@\x02\x04\x12\x04\xf3\x04\x08'\n\r\n\x05\
    \x04@\x02\x04\x04\x12\x04\xf3\x04\x08\x10\n\r\n\x05\x04@\x02\x04\x05\x12\
    \x04\xf3\x04\x11\x17\n\r\n\x05\x04@\x02\x04\x01\x12\x04\xf3\x04\x18\"\n\
    \r\n\x05\x04@\x02\x04\x03\x12\x04\xf3\x04%&\n\x0c\n\x04\x04@\x02\x05\x12\
    \x04\xf4\x04\x08,\n\r\n\x05\x04@\x02\x05\x04\x12\x04\xf4\x04\x08\x10\n\r\
    \n\x05\x04@\x02\x05\x05\x12\x04\xf4\x04\x11\x17\n\r\n\x05\x04@\x02\x05\
    \x01\x12\x04\xf4\x04\x18'\n\r\n\x05\x04@\x02\x05\x03\x12\x04\xf4\x04*+\n\
    \x0c\n\x04\x04@\x02\x06\x12\x04\xf5\x04\x08(\n\r\n\x05\x04@\x02\x06\x04\
    \x12\x04\xf5\x04\x08\x10\n\r\n\x05\x04@\x02\x06\x05\x12\x04\xf5\x04\x11\
    \x17\n\r\n\x05\x04@\x02\x06\x01\x12\x04\xf5\x04\x18#\n\r\n\x05\x04@\x02\
    \x06\x03\x12\x04\xf5\x04&'\n\x0c\n\x04\x04@\x02\x07\x12\x04\xf6\x04\x08%\
    \n\r\n\x05\x04@\x02\x07\x04\x12\x04\xf6\x04\x08\x10\n\r\n\x05\x04@\x02\
    \x07\x05\x12\x04\xf6\x04\x11\x17\n\r\n\x05\x04@\x02\x07\x01\x12\x04\xf6\
    \x04\x18\x20\n\r\n\x05\x04@\x02\x07\x03\x12\x04\xf6\x04#$\n\x0c\n\x04\
    \x04@\x02\x08\x12\x04\xf7\x04\x08.\n\r\n\x05\x04@\x02\x08\x04\x12\x04\
    \xf7\x04\x08\x10\n\r\n\x05\x04@\x02\x08\x05\x12\x04\xf7\x04\x11\x17\n\r\
    \n\x05\x04@\x02\x08\x01\x12\x04\xf7\x04\x18)\n\r\n\x05\x04@\x02\x08\x03\
    \x12\x04\xf7\x04,-\n\x0c\n\x04\x04@\x02\t\x12\x04\xf8\x04\x081\n\r\n\x05\
    \x04@\x02\t\x04\x12\x04\xf8\x04\x08\x10\n\r\n\x05\x04@\x02\t\x05\x12\x04\
    \xf8\x04\x11\x17\n\r\n\x05\x04@\x02\t\x01\x12\x04\xf8\x04\x18+\n\r\n\x05\
    \x04@\x02\t\x03\x12\x04\xf8\x04.0\n\x0c\n\x02\x04A\x12\x06\xfb\x04\0\x83\
    \x05\x01\n\x0b\n\x03\x04A\x01\x12\x04\xfb\x04\x08\x18\n\x0c\n\x04\x04A\
    \x02\0\x12\x04\xfc\x04\x08$\n\r\n\x05\x04A\x02\0\x04\x12\x04\xfc\x04\x08\
    \x10\n\r\n\x05\x04A\x02\0\x05\x12\x04\xfc\x04\x11\x17\n\r\n\x05\x04A\x02\
    \0\x01\x12\x04\xfc\x04\x18\x1f\n\r\n\x05\x04A\x02\0\x03\x12\x04\xfc\x04\
    \"#\n\x0c\n\x04\x04A\x02\x01\x12\x04\xfd\x04\x08+\n\r\n\x05\x04A\x02\x01\
    \x04\x12\x04\xfd\x04\x08\x10\n\r\n\x05\x04A\x02\x01\x05\x12\x04\xfd\x04\
    \x11\x17\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xfd\x04\x18&\n\r\n\x05\x04A\
    \x02\x01\x03\x12\x04\xfd\x04)*\n\x0c\n\x04\x04A\x02\x02\x12\x04\xfe\x04\
    \x08*\n\r\n\x05\x04A\x02\x02\x04\x12\x04\xfe\x04\x08\x10\n\r\n\x05\x04A\
    \x02\x02\x05\x12\x04\xfe\x04\x11\x17\n\r\n\x05\x04A\x02\x02\x01\x12\x04\
    \xfe\x04\x18%\n\r\n\x05\x04A\x02\x02\x03\x12\x04\xfe\x04()\n\x0c\n\x04\
    \x04A\x02\x03\x12\x04\xff\x04\x08*\n\r\n\x05\x04A\x02\x03\x04\x12\x04\
    \xff\x04\x08\x10\n\r\n\x05\x04A\x02\x03\x05\x12\x04\xff\x04\x11\x17\n\r\
    \n\x05\x04A\x02\x03\x01\x12\x04\xff\x04\x18%\n\r\n\x05\x04A\x02\x03\x03\
    \x12\x04\xff\x04()\n\x0c\n\x04\x04A\x02\x04\x12\x04\x80\x05\x08*\n\r\n\
    \x05\x04A\x02\x04\x04\x12\x04\x80\x05\x08\x10\n\r\n\x05\x04A\x02\x04\x05\
    \x12\x04\x80\x05\x11\x17\n\r\n\x05\x04A\x02\x04\x01\x12\x04\x80\x05\x18%\
    \n\r\n\x05\x04A\x02\x04\x03\x12\x04\x80\x05()\n\x0c\n\x04\x04A\x02\x05\
    \x12\x04\x81\x05\x08'\n\r\n\x05\x04A\x02\x05\x04\x12\x04\x81\x05\x08\x10\
    \n\r\n\x05\x04A\x02\x05\x05\x12\x04\x81\x05\x11\x15\n\r\n\x05\x04A\x02\
    \x05\x01\x12\x04\x81\x05\x16\"\n\r\n\x05\x04A\x02\x05\x03\x12\x04\x81\
    \x05%&\n\x0c\n\x04\x04A\x02\x06\x12\x04\x82\x05\x08/\n\r\n\x05\x04A\x02\
    \x06\x04\x12\x04\x82\x05\x08\x10\n\r\n\x05\x04A\x02\x06\x05\x12\x04\x82\
    \x05\x11\x17\n\r\n\x05\x04A\x02\x06\x01\x12\x04\x82\x05\x18*\n\r\n\x05\
    \x04A\x02\x06\x03\x12\x04\x82\x05-.\n\x0c\n\x02\x04B\x12\x06\x85\x05\0\
    \x87\x05\x01\n\x0b\n\x03\x04B\x01\x12\x04\x85\x05\x08\x1e\n\x0c\n\x04\
    \x04B\x02\0\x12\x04\x86\x05\x08-\n\r\n\x05\x04B\x02\0\x04\x12\x04\x86\
    \x05\x08\x10\n\r\n\x05\x04B\x02\0\x06\x12\x04\x86\x05\x11!\n\r\n\x05\x04\
    B\x02\0\x01\x12\x04\x86\x05\"(\n\r\n\x05\x04B\x02\0\x03\x12\x04\x86\x05+\
    ,\n\x0c\n\x02\x04C\x12\x06\x89\x05\0\x8c\x05\x01\n\x0b\n\x03\x04C\x01\
    \x12\x04\x89\x05\x08\x1f\n\x0c\n\x04\x04C\x02\0\x12\x04\x8a\x05\x08-\n\r\
    \n\x05\x04C\x02\0\x04\x12\x04\x8a\x05\x08\x10\n\r\n\x05\x04C\x02\0\x06\
    \x12\x04\x8a\x05\x11!\n\r\n\x05\x04C\x02\0\x01\x12\x04\x8a\x05\"(\n\r\n\
    \x05\x04C\x02\0\x03\x12\x04\x8a\x05+,\n\x0c\n\x04\x04C\x02\x01\x12\x04\
    \x8b\x05\x08#\n\r\n\x05\x04C\x02\x01\x04\x12\x04\x8b\x05\x08\x10\n\r\n\
    \x05\x04C\x02\x01\x05\x12\x04\x8b\x05\x11\x17\n\r\n\x05\x04C\x02\x01\x01\
    \x12\x04\x8b\x05\x18\x1e\n\r\n\x05\x04C\x02\x01\x03\x12\x04\x8b\x05!\"\n\
    \x0c\n\x02\x04D\x12\x06\x8e\x05\0\x93\x05\x01\n\x0b\n\x03\x04D\x01\x12\
    \x04\x8e\x05\x08\x1e\n\x0c\n\x04\x04D\x02\0\x12\x04\x8f\x05\x08-\n\r\n\
    \x05\x04D\x02\0\x04\x12\x04\x8f\x05\x08\x10\n\r\n\x05\x04D\x02\0\x06\x12\
    \x04\x8f\x05\x11!\n\r\n\x05\x04D\x02\0\x01\x12\x04\x8f\x05\"(\n\r\n\x05\
    \x04D\x02\0\x03\x12\x04\x8f\x05+,\n\x0c\n\x04\x04D\x02\x01\x12\x04\x90\
    \x05\x08\x20\n\r\n\x05\x04D\x02\x01\x04\x12\x04\x90\x05\x08\x10\n\r\n\
    \x05\x04D\x02\x01\x05\x12\x04\x90\x05\x11\x17\n\r\n\x05\x04D\x02\x01\x01\
    \x12\x04\x90\x05\x18\x1b\n\r\n\x05\x04D\x02\x01\x03\x12\x04\x90\x05\x1e\
    \x1f\n\x0c\n\x04\x04D\x02\x02\x12\x04\x91\x05\x08\"\n\r\n\x05\x04D\x02\
    \x02\x04\x12\x04\x91\x05\x08\x10\n\r\n\x05\x04D\x02\x02\x05\x12\x04\x91\
    \x05\x11\x17\n\r\n\x05\x04D\x02\x02\x01\x12\x04\x91\x05\x18\x1d\n\r\n\
    \x05\x04D\x02\x02\x03\x12\x04\x91\x05\x20!\n\x0c\n\x04\x04D\x02\x03\x12\
    \x04\x92\x05\x08!\n\r\n\x05\x04D\x02\x03\x04\x12\x04\x92\x05\x08\x10\n\r\
    \n\x05\x04D\x02\x03\x05\x12\x04\x92\x05\x11\x17\n\r\n\x05\x04D\x02\x03\
    \x01\x12\x04\x92\x05\x18\x1c\n\r\n\x05\x04D\x02\x03\x03\x12\x04\x92\x05\
    \x1f\x20\n\x0c\n\x02\x04E\x12\x06\x95\x05\0\x99\x05\x01\n\x0b\n\x03\x04E\
    \x01\x12\x04\x95\x05\x08\x20\n\x0c\n\x04\x04E\x02\0\x12\x04\x96\x05\x08-\
    \n\r\n\x05\x04E\x02\0\x04\x12\x04\x96\x05\x08\x10\n\r\n\x05\x04E\x02\0\
    \x06\x12\x04\x96\x05\x11!\n\r\n\x05\x04E\x02\0\x01\x12\x04\x96\x05\"(\n\
    \r\n\x05\x04E\x02\0\x03\x12\x04\x96\x05+,\n\x0c\n\x04\x04E\x02\x01\x12\
    \x04\x97\x05\x08)\n\r\n\x05\x04E\x02\x01\x04\x12\x04\x97\x05\x08\x10\n\r\
    \n\x05\x04E\x02\x01\x05\x12\x04\x97\x05\x11\x17\n\r\n\x05\x04E\x02\x01\
    \x01\x12\x04\x97\x05\x18$\n\r\n\x05\x04E\x02\x01\x03\x12\x04\x97\x05'(\n\
    \x0c\n\x04\x04E\x02\x02\x12\x04\x98\x05\x08*\n\r\n\x05\x04E\x02\x02\x04\
    \x12\x04\x98\x05\x08\x10\n\r\n\x05\x04E\x02\x02\x05\x12\x04\x98\x05\x11\
    \x17\n\r\n\x05\x04E\x02\x02\x01\x12\x04\x98\x05\x18%\n\r\n\x05\x04E\x02\
    \x02\x03\x12\x04\x98\x05()\n\x0c\n\x02\x04F\x12\x06\x9b\x05\0\xa0\x05\
    \x01\n\x0b\n\x03\x04F\x01\x12\x04\x9b\x05\x08=\n\x0c\n\x04\x04F\x02\0\
    \x12\x04\x9c\x05\x08-\n\r\n\x05\x04F\x02\0\x04\x12\x04\x9c\x05\x08\x10\n\
    \r\n\x05\x04F\x02\0\x06\x12\x04\x9c\x05\x11!\n\r\n\x05\x04F\x02\0\x01\
    \x12\x04\x9c\x05\"(\n\r\n\x05\x04F\x02\0\x03\x12\x04\x9c\x05+,\n\x0c\n\
    \x04\x04F\x02\x01\x12\x04\x9d\x05\x08)\n\r\n\x05\x04F\x02\x01\x04\x12\
    \x04\x9d\x05\x08\x10\n\r\n\x05\x04F\x02\x01\x05\x12\x04\x9d\x05\x11\x17\
    \n\r\n\x05\x04F\x02\x01\x01\x12\x04\x9d\x05\x18$\n\r\n\x05\x04F\x02\x01\
    \x03\x12\x04\x9d\x05'(\n\x0c\n\x04\x04F\x02\x02\x12\x04\x9e\x05\x08*\n\r\
    \n\x05\x04F\x02\x02\x04\x12\x04\x9e\x05\x08\x10\n\r\n\x05\x04F\x02\x02\
    \x05\x12\x04\x9e\x05\x11\x17\n\r\n\x05\x04F\x02\x02\x01\x12\x04\x9e\x05\
    \x18%\n\r\n\x05\x04F\x02\x02\x03\x12\x04\x9e\x05()\n\x0c\n\x04\x04F\x02\
    \x03\x12\x04\x9f\x05\x08+\n\r\n\x05\x04F\x02\x03\x04\x12\x04\x9f\x05\x08\
    \x10\n\r\n\x05\x04F\x02\x03\x05\x12\x04\x9f\x05\x11\x17\n\r\n\x05\x04F\
    \x02\x03\x01\x12\x04\x9f\x05\x18&\n\r\n\x05\x04F\x02\x03\x03\x12\x04\x9f\
    \x05)*\n\x0c\n\x02\x04G\x12\x06\xa2\x05\0\xa8\x05\x01\n\x0b\n\x03\x04G\
    \x01\x12\x04\xa2\x05\x08\"\n\x0c\n\x04\x04G\x02\0\x12\x04\xa3\x05\x08-\n\
    \r\n\x05\x04G\x02\0\x04\x12\x04\xa3\x05\x08\x10\n\r\n\x05\x04G\x02\0\x06\
    \x12\x04\xa3\x05\x11!\n\r\n\x05\x04G\x02\0\x01\x12\x04\xa3\x05\"(\n\r\n\
    \x05\x04G\x02\0\x03\x12\x04\xa3\x05+,\n\x0c\n\x04\x04G\x02\x01\x12\x04\
    \xa4\x05\x08)\n\r\n\x05\x04G\x02\x01\x04\x12\x04\xa4\x05\x08\x10\n\r\n\
    \x05\x04G\x02\x01\x05\x12\x04\xa4\x05\x11\x17\n\r\n\x05\x04G\x02\x01\x01\
    \x12\x04\xa4\x05\x18$\n\r\n\x05\x04G\x02\x01\x03\x12\x04\xa4\x05'(\n\x0c\
    \n\x04\x04G\x02\x02\x12\x04\xa5\x05\x08+\n\r\n\x05\x04G\x02\x02\x04\x12\
    \x04\xa5\x05\x08\x10\n\r\n\x05\x04G\x02\x02\x05\x12\x04\xa5\x05\x11\x17\
    \n\r\n\x05\x04G\x02\x02\x01\x12\x04\xa5\x05\x18&\n\r\n\x05\x04G\x02\x02\
    \x03\x12\x04\xa5\x05)*\n\x0c\n\x04\x04G\x02\x03\x12\x04\xa6\x05\x08&\n\r\
    \n\x05\x04G\x02\x03\x04\x12\x04\xa6\x05\x08\x10\n\r\n\x05\x04G\x02\x03\
    \x05\x12\x04\xa6\x05\x11\x17\n\r\n\x05\x04G\x02\x03\x01\x12\x04\xa6\x05\
    \x18!\n\r\n\x05\x04G\x02\x03\x03\x12\x04\xa6\x05$%\n\x0c\n\x04\x04G\x02\
    \x04\x12\x04\xa7\x05\x08$\n\r\n\x05\x04G\x02\x04\x04\x12\x04\xa7\x05\x08\
    \x10\n\r\n\x05\x04G\x02\x04\x05\x12\x04\xa7\x05\x11\x17\n\r\n\x05\x04G\
    \x02\x04\x01\x12\x04\xa7\x05\x18\x1f\n\r\n\x05\x04G\x02\x04\x03\x12\x04\
    \xa7\x05\"#\n\x0c\n\x02\x04H\x12\x06\xaa\x05\0\xad\x05\x01\n\x0b\n\x03\
    \x04H\x01\x12\x04\xaa\x05\x08&\n\x0c\n\x04\x04H\x02\0\x12\x04\xab\x05\
    \x08-\n\r\n\x05\x04H\x02\0\x04\x12\x04\xab\x05\x08\x10\n\r\n\x05\x04H\
    \x02\0\x06\x12\x04\xab\x05\x11!\n\r\n\x05\x04H\x02\0\x01\x12\x04\xab\x05\
    \"(\n\r\n\x05\x04H\x02\0\x03\x12\x04\xab\x05+,\n\x0c\n\x04\x04H\x02\x01\
    \x12\x04\xac\x05\x08+\n\r\n\x05\x04H\x02\x01\x04\x12\x04\xac\x05\x08\x10\
    \n\r\n\x05\x04H\x02\x01\x05\x12\x04\xac\x05\x11\x17\n\r\n\x05\x04H\x02\
    \x01\x01\x12\x04\xac\x05\x18&\n\r\n\x05\x04H\x02\x01\x03\x12\x04\xac\x05\
    )*\n\x0c\n\x02\x04I\x12\x06\xaf\x05\0\xb4\x05\x01\n\x0b\n\x03\x04I\x01\
    \x12\x04\xaf\x05\x08C\n\x0c\n\x04\x04I\x02\0\x12\x04\xb0\x05\x08-\n\r\n\
    \x05\x04I\x02\0\x04\x12\x04\xb0\x05\x08\x10\n\r\n\x05\x04I\x02\0\x06\x12\
    \x04\xb0\x05\x11!\n\r\n\x05\x04I\x02\0\x01\x12\x04\xb0\x05\"(\n\r\n\x05\
    \x04I\x02\0\x03\x12\x04\xb0\x05+,\n\x0c\n\x04\x04I\x02\x01\x12\x04\xb1\
    \x05\x08+\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xb1\x05\x08\x10\n\r\n\x05\
    \x04I\x02\x01\x05\x12\x04\xb1\x05\x11\x17\n\r\n\x05\x04I\x02\x01\x01\x12\
    \x04\xb1\x05\x18&\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xb1\x05)*\n\x0c\n\
    \x04\x04I\x02\x02\x12\x04\xb2\x05\x08*\n\r\n\x05\x04I\x02\x02\x04\x12\
    \x04\xb2\x05\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xb2\x05\x11\x17\
    \n\r\n\x05\x04I\x02\x02\x01\x12\x04\xb2\x05\x18%\n\r\n\x05\x04I\x02\x02\
    \x03\x12\x04\xb2\x05()\n\x0c\n\x04\x04I\x02\x03\x12\x04\xb3\x05\x08+\n\r\
    \n\x05\x04I\x02\x03\x04\x12\x04\xb3\x05\x08\x10\n\r\n\x05\x04I\x02\x03\
    \x05\x12\x04\xb3\x05\x11\x17\n\r\n\x05\x04I\x02\x03\x01\x12\x04\xb3\x05\
    \x18&\n\r\n\x05\x04I\x02\x03\x03\x12\x04\xb3\x05)*\n\x0c\n\x02\x04J\x12\
    \x06\xb6\x05\0\xbb\x05\x01\n\x0b\n\x03\x04J\x01\x12\x04\xb6\x05\x08\"\n\
    \x0c\n\x04\x04J\x02\0\x12\x04\xb7\x05\x08-\n\r\n\x05\x04J\x02\0\x04\x12\
    \x04\xb7\x05\x08\x10\n\r\n\x05\x04J\x02\0\x06\x12\x04\xb7\x05\x11!\n\r\n\
    \x05\x04J\x02\0\x01\x12\x04\xb7\x05\"(\n\r\n\x05\x04J\x02\0\x03\x12\x04\
    \xb7\x05+,\n\x0c\n\x04\x04J\x02\x01\x12\x04\xb8\x05\x08&\n\r\n\x05\x04J\
    \x02\x01\x04\x12\x04\xb8\x05\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\
    \xb8\x05\x11\x17\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xb8\x05\x18!\n\r\n\
    \x05\x04J\x02\x01\x03\x12\x04\xb8\x05$%\n\x0c\n\x04\x04J\x02\x02\x12\x04\
    \xb9\x05\x08)\n\r\n\x05\x04J\x02\x02\x04\x12\x04\xb9\x05\x08\x10\n\r\n\
    \x05\x04J\x02\x02\x05\x12\x04\xb9\x05\x11\x17\n\r\n\x05\x04J\x02\x02\x01\
    \x12\x04\xb9\x05\x18$\n\r\n\x05\x04J\x02\x02\x03\x12\x04\xb9\x05'(\n\x0c\
    \n\x04\x04J\x02\x03\x12\x04\xba\x05\x08,\n\r\n\x05\x04J\x02\x03\x04\x12\
    \x04\xba\x05\x08\x10\n\r\n\x05\x04J\x02\x03\x05\x12\x04\xba\x05\x11\x17\
    \n\r\n\x05\x04J\x02\x03\x01\x12\x04\xba\x05\x18'\n\r\n\x05\x04J\x02\x03\
    \x03\x12\x04\xba\x05*+\n\x0c\n\x02\x04K\x12\x06\xbd\x05\0\xbf\x05\x01\n\
    \x0b\n\x03\x04K\x01\x12\x04\xbd\x05\x08&\n\x0c\n\x04\x04K\x02\0\x12\x04\
    \xbe\x05\x08-\n\r\n\x05\x04K\x02\0\x04\x12\x04\xbe\x05\x08\x10\n\r\n\x05\
    \x04K\x02\0\x06\x12\x04\xbe\x05\x11!\n\r\n\x05\x04K\x02\0\x01\x12\x04\
    \xbe\x05\"(\n\r\n\x05\x04K\x02\0\x03\x12\x04\xbe\x05+,\n\x0c\n\x02\x04L\
    \x12\x06\xc1\x05\0\xc3\x05\x01\n\x0b\n\x03\x04L\x01\x12\x04\xc1\x05\x08\
    \x19\n\x0c\n\x04\x04L\x02\0\x12\x04\xc2\x05\x08\"\n\r\n\x05\x04L\x02\0\
    \x04\x12\x04\xc2\x05\x08\x10\n\r\n\x05\x04L\x02\0\x05\x12\x04\xc2\x05\
    \x11\x17\n\r\n\x05\x04L\x02\0\x01\x12\x04\xc2\x05\x18\x1d\n\r\n\x05\x04L\
    \x02\0\x03\x12\x04\xc2\x05\x20!\n\x0c\n\x02\x04M\x12\x06\xc5\x05\0\xca\
    \x05\x01\n\x0b\n\x03\x04M\x01\x12\x04\xc5\x05\x08-\n\x0c\n\x04\x04M\x02\
    \0\x12\x04\xc6\x05\x08\"\n\r\n\x05\x04M\x02\0\x04\x12\x04\xc6\x05\x08\
    \x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\xc6\x05\x11\x17\n\r\n\x05\x04M\x02\
    \0\x01\x12\x04\xc6\x05\x18\x1d\n\r\n\x05\x04M\x02\0\x03\x12\x04\xc6\x05\
    \x20!\n\x0c\n\x04\x04M\x02\x01\x12\x04\xc7\x05\x08$\n\r\n\x05\x04M\x02\
    \x01\x04\x12\x04\xc7\x05\x08\x10\n\r\n\x05\x04M\x02\x01\x05\x12\x04\xc7\
    \x05\x11\x17\n\r\n\x05\x04M\x02\x01\x01\x12\x04\xc7\x05\x18\x1f\n\r\n\
    \x05\x04M\x02\x01\x03\x12\x04\xc7\x05\"#\n\x0c\n\x04\x04M\x02\x02\x12\
    \x04\xc8\x05\x08'\n\r\n\x05\x04M\x02\x02\x04\x12\x04\xc8\x05\x08\x10\n\r\
    \n\x05\x04M\x02\x02\x05\x12\x04\xc8\x05\x11\x17\n\r\n\x05\x04M\x02\x02\
    \x01\x12\x04\xc8\x05\x18\"\n\r\n\x05\x04M\x02\x02\x03\x12\x04\xc8\x05%&\
    \n\x0c\n\x04\x04M\x02\x03\x12\x04\xc9\x05\x08%\n\r\n\x05\x04M\x02\x03\
    \x04\x12\x04\xc9\x05\x08\x10\n\r\n\x05\x04M\x02\x03\x05\x12\x04\xc9\x05\
    \x11\x17\n\r\n\x05\x04M\x02\x03\x01\x12\x04\xc9\x05\x18\x20\n\r\n\x05\
    \x04M\x02\x03\x03\x12\x04\xc9\x05#$\n\x0c\n\x02\x04N\x12\x06\xcc\x05\0\
    \xd5\x05\x01\n\x0b\n\x03\x04N\x01\x12\x04\xcc\x05\x08.\n\x0e\n\x04\x04N\
    \x03\0\x12\x06\xcd\x05\x08\xd2\x05\t\n\r\n\x05\x04N\x03\0\x01\x12\x04\
    \xcd\x05\x10#\n\x0e\n\x06\x04N\x03\0\x02\0\x12\x04\xce\x05\x101\n\x0f\n\
    \x07\x04N\x03\0\x02\0\x04\x12\x04\xce\x05\x10\x18\n\x0f\n\x07\x04N\x03\0\
    \x02\0\x05\x12\x04\xce\x05\x19\x1f\n\x0f\n\x07\x04N\x03\0\x02\0\x01\x12\
    \x04\xce\x05\x20,\n\x0f\n\x07\x04N\x03\0\x02\0\x03\x12\x04\xce\x05/0\n\
    \x0e\n\x06\x04N\x03\0\x02\x01\x12\x04\xcf\x05\x10)\n\x0f\n\x07\x04N\x03\
    \0\x02\x01\x04\x12\x04\xcf\x05\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\x01\
    \x05\x12\x04\xcf\x05\x19\x1f\n\x0f\n\x07\x04N\x03\0\x02\x01\x01\x12\x04\
    \xcf\x05\x20$\n\x0f\n\x07\x04N\x03\0\x02\x01\x03\x12\x04\xcf\x05'(\n\x0e\
    \n\x06\x04N\x03\0\x02\x02\x12\x04\xd0\x05\x10/\n\x0f\n\x07\x04N\x03\0\
    \x02\x02\x04\x12\x04\xd0\x05\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\x02\x05\
    \x12\x04\xd0\x05\x19\x1e\n\x0f\n\x07\x04N\x03\0\x02\x02\x01\x12\x04\xd0\
    \x05\x1f*\n\x0f\n\x07\x04N\x03\0\x02\x02\x03\x12\x04\xd0\x05-.\n\x0e\n\
    \x06\x04N\x03\0\x02\x03\x12\x04\xd1\x05\x10)\n\x0f\n\x07\x04N\x03\0\x02\
    \x03\x04\x12\x04\xd1\x05\x10\x18\n\x0f\n\x07\x04N\x03\0\x02\x03\x05\x12\
    \x04\xd1\x05\x19\x1e\n\x0f\n\x07\x04N\x03\0\x02\x03\x01\x12\x04\xd1\x05\
    \x1f$\n\x0f\n\x07\x04N\x03\0\x02\x03\x03\x12\x04\xd1\x05'(\n\x0c\n\x04\
    \x04N\x02\0\x12\x04\xd4\x05\x08`\n\r\n\x05\x04N\x02\0\x04\x12\x04\xd4\
    \x05\x08\x10\n\r\n\x05\x04N\x02\0\x06\x12\x04\xd4\x05\x11K\n\r\n\x05\x04\
    N\x02\0\x01\x12\x04\xd4\x05L[\n\r\n\x05\x04N\x02\0\x03\x12\x04\xd4\x05^_\
    \n\x0c\n\x02\x04O\x12\x06\xd7\x05\0\xdb\x05\x01\n\x0b\n\x03\x04O\x01\x12\
    \x04\xd7\x05\x080\n\x0c\n\x04\x04O\x02\0\x12\x04\xd8\x05\x08&\n\r\n\x05\
    \x04O\x02\0\x04\x12\x04\xd8\x05\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\
    \xd8\x05\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\xd8\x05\x18!\n\r\n\x05\
    \x04O\x02\0\x03\x12\x04\xd8\x05$%\n\x0c\n\x04\x04O\x02\x01\x12\x04\xd9\
    \x05\x08'\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xd9\x05\x08\x10\n\r\n\x05\
    \x04O\x02\x01\x05\x12\x04\xd9\x05\x11\x17\n\r\n\x05\x04O\x02\x01\x01\x12\
    \x04\xd9\x05\x18\"\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xd9\x05%&\n\x0c\n\
    \x04\x04O\x02\x02\x12\x04\xda\x05\x08%\n\r\n\x05\x04O\x02\x02\x04\x12\
    \x04\xda\x05\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xda\x05\x11\x17\
    \n\r\n\x05\x04O\x02\x02\x01\x12\x04\xda\x05\x18\x20\n\r\n\x05\x04O\x02\
    \x02\x03\x12\x04\xda\x05#$\n\x0c\n\x02\x04P\x12\x06\xdd\x05\0\xe6\x05\
    \x01\n\x0b\n\x03\x04P\x01\x12\x04\xdd\x05\x081\n\x0e\n\x04\x04P\x03\0\
    \x12\x06\xde\x05\x08\xe3\x05\t\n\r\n\x05\x04P\x03\0\x01\x12\x04\xde\x05\
    \x10#\n\x0e\n\x06\x04P\x03\0\x02\0\x12\x04\xdf\x05\x101\n\x0f\n\x07\x04P\
    \x03\0\x02\0\x04\x12\x04\xdf\x05\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\0\
    \x05\x12\x04\xdf\x05\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\0\x01\x12\x04\
    \xdf\x05\x20,\n\x0f\n\x07\x04P\x03\0\x02\0\x03\x12\x04\xdf\x05/0\n\x0e\n\
    \x06\x04P\x03\0\x02\x01\x12\x04\xe0\x05\x10)\n\x0f\n\x07\x04P\x03\0\x02\
    \x01\x04\x12\x04\xe0\x05\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x01\x05\x12\
    \x04\xe0\x05\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\x01\x01\x12\x04\xe0\x05\
    \x20$\n\x0f\n\x07\x04P\x03\0\x02\x01\x03\x12\x04\xe0\x05'(\n\x0e\n\x06\
    \x04P\x03\0\x02\x02\x12\x04\xe1\x05\x10/\n\x0f\n\x07\x04P\x03\0\x02\x02\
    \x04\x12\x04\xe1\x05\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x02\x05\x12\x04\
    \xe1\x05\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x02\x01\x12\x04\xe1\x05\x1f*\
    \n\x0f\n\x07\x04P\x03\0\x02\x02\x03\x12\x04\xe1\x05-.\n\x0e\n\x06\x04P\
    \x03\0\x02\x03\x12\x04\xe2\x05\x10)\n\x0f\n\x07\x04P\x03\0\x02\x03\x04\
    \x12\x04\xe2\x05\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x03\x05\x12\x04\xe2\
    \x05\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x03\x01\x12\x04\xe2\x05\x1f$\n\
    \x0f\n\x07\x04P\x03\0\x02\x03\x03\x12\x04\xe2\x05'(\n\x0c\n\x04\x04P\x02\
    \0\x12\x04\xe5\x05\x08c\n\r\n\x05\x04P\x02\0\x04\x12\x04\xe5\x05\x08\x10\
    \n\r\n\x05\x04P\x02\0\x06\x12\x04\xe5\x05\x11N\n\r\n\x05\x04P\x02\0\x01\
    \x12\x04\xe5\x05O^\n\r\n\x05\x04P\x02\0\x03\x12\x04\xe5\x05ab\n\x0c\n\
    \x02\x04Q\x12\x06\xe8\x05\0\xeb\x05\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xe8\
    \x05\x08'\n\x0c\n\x04\x04Q\x02\0\x12\x04\xe9\x05\x08'\n\r\n\x05\x04Q\x02\
    \0\x04\x12\x04\xe9\x05\x08\x10\n\r\n\x05\x04Q\x02\0\x05\x12\x04\xe9\x05\
    \x11\x17\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xe9\x05\x18\"\n\r\n\x05\x04Q\
    \x02\0\x03\x12\x04\xe9\x05%&\n\x0c\n\x04\x04Q\x02\x01\x12\x04\xea\x05\
    \x08&\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xea\x05\x08\x10\n\r\n\x05\x04Q\
    \x02\x01\x05\x12\x04\xea\x05\x11\x17\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\
    \xea\x05\x18!\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xea\x05$%\n\x0c\n\x02\
    \x04R\x12\x06\xed\x05\0\xef\x05\x01\n\x0b\n\x03\x04R\x01\x12\x04\xed\x05\
    \x08'\n\x0c\n\x04\x04R\x02\0\x12\x04\xee\x05\x08'\n\r\n\x05\x04R\x02\0\
    \x04\x12\x04\xee\x05\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\xee\x05\
    \x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\xee\x05\x18\"\n\r\n\x05\x04R\
    \x02\0\x03\x12\x04\xee\x05%&\n\x0c\n\x02\x04S\x12\x06\xf1\x05\0\xf4\x05\
    \x01\n\x0b\n\x03\x04S\x01\x12\x04\xf1\x05\x08/\n\x0c\n\x04\x04S\x02\0\
    \x12\x04\xf2\x05\x08'\n\r\n\x05\x04S\x02\0\x04\x12\x04\xf2\x05\x08\x10\n\
    \r\n\x05\x04S\x02\0\x05\x12\x04\xf2\x05\x11\x17\n\r\n\x05\x04S\x02\0\x01\
    \x12\x04\xf2\x05\x18\"\n\r\n\x05\x04S\x02\0\x03\x12\x04\xf2\x05%&\n\x0c\
    \n\x04\x04S\x02\x01\x12\x04\xf3\x05\x08)\n\r\n\x05\x04S\x02\x01\x04\x12\
    \x04\xf3\x05\x08\x10\n\r\n\x05\x04S\x02\x01\x05\x12\x04\xf3\x05\x11\x17\
    \n\r\n\x05\x04S\x02\x01\x01\x12\x04\xf3\x05\x18$\n\r\n\x05\x04S\x02\x01\
    \x03\x12\x04\xf3\x05'(\n\x0c\n\x02\x04T\x12\x06\xf6\x05\0\xfe\x05\x01\n\
    \x0b\n\x03\x04T\x01\x12\x04\xf6\x05\x08(\n\x0e\n\x04\x04T\x03\0\x12\x06\
    \xf7\x05\x08\xfa\x05\t\n\r\n\x05\x04T\x03\0\x01\x12\x04\xf7\x05\x10\x14\
    \n\x0e\n\x06\x04T\x03\0\x02\0\x12\x04\xf8\x05\x10,\n\x0f\n\x07\x04T\x03\
    \0\x02\0\x04\x12\x04\xf8\x05\x10\x18\n\x0f\n\x07\x04T\x03\0\x02\0\x05\
    \x12\x04\xf8\x05\x19\x1f\n\x0f\n\x07\x04T\x03\0\x02\0\x01\x12\x04\xf8\
    \x05\x20'\n\x0f\n\x07\x04T\x03\0\x02\0\x03\x12\x04\xf8\x05*+\n\x0e\n\x06\
    \x04T\x03\0\x02\x01\x12\x04\xf9\x05\x10,\n\x0f\n\x07\x04T\x03\0\x02\x01\
    \x04\x12\x04\xf9\x05\x10\x18\n\x0f\n\x07\x04T\x03\0\x02\x01\x05\x12\x04\
    \xf9\x05\x19\x1f\n\x0f\n\x07\x04T\x03\0\x02\x01\x01\x12\x04\xf9\x05\x20'\
    \n\x0f\n\x07\x04T\x03\0\x02\x01\x03\x12\x04\xf9\x05*+\n\x0c\n\x04\x04T\
    \x02\0\x12\x04\xfc\x05\x08A\n\r\n\x05\x04T\x02\0\x04\x12\x04\xfc\x05\x08\
    \x10\n\r\n\x05\x04T\x02\0\x06\x12\x04\xfc\x05\x116\n\r\n\x05\x04T\x02\0\
    \x01\x12\x04\xfc\x057<\n\r\n\x05\x04T\x02\0\x03\x12\x04\xfc\x05?@\n\x0c\
    \n\x04\x04T\x02\x01\x12\x04\xfd\x05\x08-\n\r\n\x05\x04T\x02\x01\x04\x12\
    \x04\xfd\x05\x08\x10\n\r\n\x05\x04T\x02\x01\x05\x12\x04\xfd\x05\x11\x17\
    \n\r\n\x05\x04T\x02\x01\x01\x12\x04\xfd\x05\x18(\n\r\n\x05\x04T\x02\x01\
    \x03\x12\x04\xfd\x05+,\n\x0c\n\x02\x04U\x12\x06\x80\x06\0\x9e\x06\x01\n\
    \x0b\n\x03\x04U\x01\x12\x04\x80\x06\x080\n\x0e\n\x04\x04U\x03\0\x12\x06\
    \x81\x06\x08\x85\x06\t\n\r\n\x05\x04U\x03\0\x01\x12\x04\x81\x06\x10\x1a\
    \n\x0e\n\x06\x04U\x03\0\x02\0\x12\x04\x82\x06\x10.\n\x0f\n\x07\x04U\x03\
    \0\x02\0\x04\x12\x04\x82\x06\x10\x18\n\x0f\n\x07\x04U\x03\0\x02\0\x05\
    \x12\x04\x82\x06\x19\x1f\n\x0f\n\x07\x04U\x03\0\x02\0\x01\x12\x04\x82\
    \x06\x20)\n\x0f\n\x07\x04U\x03\0\x02\0\x03\x12\x04\x82\x06,-\n\x0e\n\x06\
    \x04U\x03\0\x02\x01\x12\x04\x83\x06\x10,\n\x0f\n\x07\x04U\x03\0\x02\x01\
    \x04\x12\x04\x83\x06\x10\x18\n\x0f\n\x07\x04U\x03\0\x02\x01\x05\x12\x04\
    \x83\x06\x19\x1f\n\x0f\n\x07\x04U\x03\0\x02\x01\x01\x12\x04\x83\x06\x20'\
    \n\x0f\n\x07\x04U\x03\0\x02\x01\x03\x12\x04\x83\x06*+\n\x0e\n\x06\x04U\
    \x03\0\x02\x02\x12\x04\x84\x06\x10,\n\x0f\n\x07\x04U\x03\0\x02\x02\x04\
    \x12\x04\x84\x06\x10\x18\n\x0f\n\x07\x04U\x03\0\x02\x02\x05\x12\x04\x84\
    \x06\x19\x1f\n\x0f\n\x07\x04U\x03\0\x02\x02\x01\x12\x04\x84\x06\x20'\n\
    \x0f\n\x07\x04U\x03\0\x02\x02\x03\x12\x04\x84\x06*+\n\x0e\n\x04\x04U\x03\
    \x01\x12\x06\x87\x06\x08\x8a\x06\t\n\r\n\x05\x04U\x03\x01\x01\x12\x04\
    \x87\x06\x10\x1a\n\x0e\n\x06\x04U\x03\x01\x02\0\x12\x04\x88\x06\x10,\n\
    \x0f\n\x07\x04U\x03\x01\x02\0\x04\x12\x04\x88\x06\x10\x18\n\x0f\n\x07\
    \x04U\x03\x01\x02\0\x05\x12\x04\x88\x06\x19\x1f\n\x0f\n\x07\x04U\x03\x01\
    \x02\0\x01\x12\x04\x88\x06\x20'\n\x0f\n\x07\x04U\x03\x01\x02\0\x03\x12\
    \x04\x88\x06*+\n\x0e\n\x06\x04U\x03\x01\x02\x01\x12\x04\x89\x06\x10V\n\
    \x0f\n\x07\x04U\x03\x01\x02\x01\x04\x12\x04\x89\x06\x10\x18\n\x0f\n\x07\
    \x04U\x03\x01\x02\x01\x06\x12\x04\x89\x06\x19K\n\x0f\n\x07\x04U\x03\x01\
    \x02\x01\x01\x12\x04\x89\x06LQ\n\x0f\n\x07\x04U\x03\x01\x02\x01\x03\x12\
    \x04\x89\x06TU\n\x0e\n\x04\x04U\x03\x02\x12\x06\x8c\x06\x08\x8f\x06\t\n\
    \r\n\x05\x04U\x03\x02\x01\x12\x04\x8c\x06\x10\x20\n\x0e\n\x06\x04U\x03\
    \x02\x02\0\x12\x04\x8d\x06\x10,\n\x0f\n\x07\x04U\x03\x02\x02\0\x04\x12\
    \x04\x8d\x06\x10\x18\n\x0f\n\x07\x04U\x03\x02\x02\0\x05\x12\x04\x8d\x06\
    \x19\x1f\n\x0f\n\x07\x04U\x03\x02\x02\0\x01\x12\x04\x8d\x06\x20'\n\x0f\n\
    \x07\x04U\x03\x02\x02\0\x03\x12\x04\x8d\x06*+\n\x0e\n\x06\x04U\x03\x02\
    \x02\x01\x12\x04\x8e\x06\x10*\n\x0f\n\x07\x04U\x03\x02\x02\x01\x04\x12\
    \x04\x8e\x06\x10\x18\n\x0f\n\x07\x04U\x03\x02\x02\x01\x05\x12\x04\x8e\
    \x06\x19\x1f\n\x0f\n\x07\x04U\x03\x02\x02\x01\x01\x12\x04\x8e\x06\x20%\n\
    \x0f\n\x07\x04U\x03\x02\x02\x01\x03\x12\x04\x8e\x06()\n\x0e\n\x04\x04U\
    \x04\0\x12\x06\x91\x06\x08\x98\x06\t\n\r\n\x05\x04U\x04\0\x01\x12\x04\
    \x91\x06\r\x16\n\x0e\n\x06\x04U\x04\0\x02\0\x12\x04\x92\x06\x10&\n\x0f\n\
    \x07\x04U\x04\0\x02\0\x01\x12\x04\x92\x06\x10!\n\x0f\n\x07\x04U\x04\0\
    \x02\0\x02\x12\x04\x92\x06$%\n\x0e\n\x06\x04U\x04\0\x02\x01\x12\x04\x93\
    \x06\x10/\n\x0f\n\x07\x04U\x04\0\x02\x01\x01\x12\x04\x93\x06\x10*\n\x0f\
    \n\x07\x04U\x04\0\x02\x01\x02\x12\x04\x93\x06-.\n\x0e\n\x06\x04U\x04\0\
    \x02\x02\x12\x04\x94\x06\x10+\n\x0f\n\x07\x04U\x04\0\x02\x02\x01\x12\x04\
    \x94\x06\x10&\n\x0f\n\x07\x04U\x04\0\x02\x02\x02\x12\x04\x94\x06)*\n\x0e\
    \n\x06\x04U\x04\0\x02\x03\x12\x04\x95\x06\x10,\n\x0f\n\x07\x04U\x04\0\
    \x02\x03\x01\x12\x04\x95\x06\x10'\n\x0f\n\x07\x04U\x04\0\x02\x03\x02\x12\
    \x04\x95\x06*+\n\x0e\n\x06\x04U\x04\0\x02\x04\x12\x04\x96\x06\x10,\n\x0f\
    \n\x07\x04U\x04\0\x02\x04\x01\x12\x04\x96\x06\x10'\n\x0f\n\x07\x04U\x04\
    \0\x02\x04\x02\x12\x04\x96\x06*+\n\x0e\n\x06\x04U\x04\0\x02\x05\x12\x04\
    \x97\x06\x10+\n\x0f\n\x07\x04U\x04\0\x02\x05\x01\x12\x04\x97\x06\x10&\n\
    \x0f\n\x07\x04U\x04\0\x02\x05\x02\x12\x04\x97\x06)*\n\x0c\n\x04\x04U\x02\
    \0\x12\x04\x9a\x06\x08Q\n\r\n\x05\x04U\x02\0\x04\x12\x04\x9a\x06\x08\x10\
    \n\r\n\x05\x04U\x02\0\x06\x12\x04\x9a\x06\x11C\n\r\n\x05\x04U\x02\0\x01\
    \x12\x04\x9a\x06DL\n\r\n\x05\x04U\x02\0\x03\x12\x04\x9a\x06OP\n\x0c\n\
    \x04\x04U\x02\x01\x12\x04\x9b\x06\x08V\n\r\n\x05\x04U\x02\x01\x04\x12\
    \x04\x9b\x06\x08\x10\n\r\n\x05\x04U\x02\x01\x06\x12\x04\x9b\x06\x11D\n\r\
    \n\x05\x04U\x02\x01\x01\x12\x04\x9b\x06EQ\n\r\n\x05\x04U\x02\x01\x03\x12\
    \x04\x9b\x06TU\n\x0c\n\x04\x04U\x02\x02\x12\x04\x9c\x06\x08V\n\r\n\x05\
    \x04U\x02\x02\x04\x12\x04\x9c\x06\x08\x10\n\r\n\x05\x04U\x02\x02\x06\x12\
    \x04\x9c\x06\x11D\n\r\n\x05\x04U\x02\x02\x01\x12\x04\x9c\x06EQ\n\r\n\x05\
    \x04U\x02\x02\x03\x12\x04\x9c\x06TU\n\x0c\n\x04\x04U\x02\x03\x12\x04\x9d\
    \x06\x08b\n\r\n\x05\x04U\x02\x03\x04\x12\x04\x9d\x06\x08\x10\n\r\n\x05\
    \x04U\x02\x03\x06\x12\x04\x9d\x06\x11J\n\r\n\x05\x04U\x02\x03\x01\x12\
    \x04\x9d\x06K]\n\r\n\x05\x04U\x02\x03\x03\x12\x04\x9d\x06`a\n\x0c\n\x02\
    \x04V\x12\x06\xa0\x06\0\xb6\x06\x01\n\x0b\n\x03\x04V\x01\x12\x04\xa0\x06\
    \x08#\n\x0e\n\x04\x04V\x03\0\x12\x06\xa1\x06\x08\xab\x06\t\n\r\n\x05\x04\
    V\x03\0\x01\x12\x04\xa1\x06\x10\x14\n\x0e\n\x06\x04V\x03\0\x02\0\x12\x04\
    \xa2\x06\x103\n\x0f\n\x07\x04V\x03\0\x02\0\x04\x12\x04\xa2\x06\x10\x18\n\
    \x0f\n\x07\x04V\x03\0\x02\0\x05\x12\x04\xa2\x06\x19\x1f\n\x0f\n\x07\x04V\
    \x03\0\x02\0\x01\x12\x04\xa2\x06\x20.\n\x0f\n\x07\x04V\x03\0\x02\0\x03\
    \x12\x04\xa2\x0612\n\x0e\n\x06\x04V\x03\0\x02\x01\x12\x04\xa3\x06\x10/\n\
    \x0f\n\x07\x04V\x03\0\x02\x01\x04\x12\x04\xa3\x06\x10\x18\n\x0f\n\x07\
    \x04V\x03\0\x02\x01\x05\x12\x04\xa3\x06\x19\x1f\n\x0f\n\x07\x04V\x03\0\
    \x02\x01\x01\x12\x04\xa3\x06\x20*\n\x0f\n\x07\x04V\x03\0\x02\x01\x03\x12\
    \x04\xa3\x06-.\n\x0e\n\x06\x04V\x03\0\x02\x02\x12\x04\xa4\x06\x10-\n\x0f\
    \n\x07\x04V\x03\0\x02\x02\x04\x12\x04\xa4\x06\x10\x18\n\x0f\n\x07\x04V\
    \x03\0\x02\x02\x05\x12\x04\xa4\x06\x19\x1f\n\x0f\n\x07\x04V\x03\0\x02\
    \x02\x01\x12\x04\xa4\x06\x20(\n\x0f\n\x07\x04V\x03\0\x02\x02\x03\x12\x04\
    \xa4\x06+,\n\x0e\n\x06\x04V\x03\0\x02\x03\x12\x04\xa5\x06\x102\n\x0f\n\
    \x07\x04V\x03\0\x02\x03\x04\x12\x04\xa5\x06\x10\x18\n\x0f\n\x07\x04V\x03\
    \0\x02\x03\x05\x12\x04\xa5\x06\x19\x1f\n\x0f\n\x07\x04V\x03\0\x02\x03\
    \x01\x12\x04\xa5\x06\x20-\n\x0f\n\x07\x04V\x03\0\x02\x03\x03\x12\x04\xa5\
    \x0601\n\x0e\n\x06\x04V\x03\0\x02\x04\x12\x04\xa6\x06\x108\n\x0f\n\x07\
    \x04V\x03\0\x02\x04\x04\x12\x04\xa6\x06\x10\x18\n\x0f\n\x07\x04V\x03\0\
    \x02\x04\x05\x12\x04\xa6\x06\x19\x1f\n\x0f\n\x07\x04V\x03\0\x02\x04\x01\
    \x12\x04\xa6\x06\x203\n\x0f\n\x07\x04V\x03\0\x02\x04\x03\x12\x04\xa6\x06\
    67\n\x0e\n\x06\x04V\x03\0\x02\x05\x12\x04\xa7\x06\x108\n\x0f\n\x07\x04V\
    \x03\0\x02\x05\x04\x12\x04\xa7\x06\x10\x18\n\x0f\n\x07\x04V\x03\0\x02\
    \x05\x05\x12\x04\xa7\x06\x19\x1f\n\x0f\n\x07\x04V\x03\0\x02\x05\x01\x12\
    \x04\xa7\x06\x203\n\x0f\n\x07\x04V\x03\0\x02\x05\x03\x12\x04\xa7\x0667\n\
    \x0e\n\x06\x04V\x03\0\x02\x06\x12\x04\xa8\x06\x106\n\x0f\n\x07\x04V\x03\
    \0\x02\x06\x04\x12\x04\xa8\x06\x10\x18\n\x0f\n\x07\x04V\x03\0\x02\x06\
    \x05\x12\x04\xa8\x06\x19\x1e\n\x0f\n\x07\x04V\x03\0\x02\x06\x01\x12\x04\
    \xa8\x06\x1f1\n\x0f\n\x07\x04V\x03\0\x02\x06\x03\x12\x04\xa8\x0645\n\x0e\
    \n\x06\x04V\x03\0\x02\x07\x12\x04\xa9\x06\x100\n\x0f\n\x07\x04V\x03\0\
    \x02\x07\x04\x12\x04\xa9\x06\x10\x18\n\x0f\n\x07\x04V\x03\0\x02\x07\x05\
    \x12\x04\xa9\x06\x19\x1d\n\x0f\n\x07\x04V\x03\0\x02\x07\x01\x12\x04\xa9\
    \x06\x1e+\n\x0f\n\x07\x04V\x03\0\x02\x07\x03\x12\x04\xa9\x06./\n\x0e\n\
    \x06\x04V\x03\0\x02\x08\x12\x04\xaa\x06\x101\n\x0f\n\x07\x04V\x03\0\x02\
    \x08\x04\x12\x04\xaa\x06\x10\x18\n\x0f\n\x07\x04V\x03\0\x02\x08\x05\x12\
    \x04\xaa\x06\x19\x1d\n\x0f\n\x07\x04V\x03\0\x02\x08\x01\x12\x04\xaa\x06\
    \x1e,\n\x0f\n\x07\x04V\x03\0\x02\x08\x03\x12\x04\xaa\x06/0\n\x0c\n\x04\
    \x04V\x02\0\x12\x04\xad\x06\x08#\n\r\n\x05\x04V\x02\0\x04\x12\x04\xad\
    \x06\x08\x10\n\r\n\x05\x04V\x02\0\x05\x12\x04\xad\x06\x11\x17\n\r\n\x05\
    \x04V\x02\0\x01\x12\x04\xad\x06\x18\x1e\n\r\n\x05\x04V\x02\0\x03\x12\x04\
    \xad\x06!\"\n\x0c\n\x04\x04V\x02\x01\x12\x04\xae\x06\x08)\n\r\n\x05\x04V\
    \x02\x01\x04\x12\x04\xae\x06\x08\x10\n\r\n\x05\x04V\x02\x01\x05\x12\x04\
    \xae\x06\x11\x17\n\r\n\x05\x04V\x02\x01\x01\x12\x04\xae\x06\x18$\n\r\n\
    \x05\x04V\x02\x01\x03\x12\x04\xae\x06'(\n\x0c\n\x04\x04V\x02\x02\x12\x04\
    \xaf\x06\x08+\n\r\n\x05\x04V\x02\x02\x04\x12\x04\xaf\x06\x08\x10\n\r\n\
    \x05\x04V\x02\x02\x05\x12\x04\xaf\x06\x11\x17\n\r\n\x05\x04V\x02\x02\x01\
    \x12\x04\xaf\x06\x18&\n\r\n\x05\x04V\x02\x02\x03\x12\x04\xaf\x06)*\n\x0c\
    \n\x04\x04V\x02\x03\x12\x04\xb0\x06\x08&\n\r\n\x05\x04V\x02\x03\x04\x12\
    \x04\xb0\x06\x08\x10\n\r\n\x05\x04V\x02\x03\x05\x12\x04\xb0\x06\x11\x18\
    \n\r\n\x05\x04V\x02\x03\x01\x12\x04\xb0\x06\x19!\n\r\n\x05\x04V\x02\x03\
    \x03\x12\x04\xb0\x06$%\n\x0c\n\x04\x04V\x02\x04\x12\x04\xb1\x06\x08'\n\r\
    \n\x05\x04V\x02\x04\x04\x12\x04\xb1\x06\x08\x10\n\r\n\x05\x04V\x02\x04\
    \x05\x12\x04\xb1\x06\x11\x17\n\r\n\x05\x04V\x02\x04\x01\x12\x04\xb1\x06\
    \x18\"\n\r\n\x05\x04V\x02\x04\x03\x12\x04\xb1\x06%&\n\x0c\n\x04\x04V\x02\
    \x05\x12\x04\xb2\x06\x08&\n\r\n\x05\x04V\x02\x05\x04\x12\x04\xb2\x06\x08\
    \x10\n\r\n\x05\x04V\x02\x05\x05\x12\x04\xb2\x06\x11\x17\n\r\n\x05\x04V\
    \x02\x05\x01\x12\x04\xb2\x06\x18!\n\r\n\x05\x04V\x02\x05\x03\x12\x04\xb2\
    \x06$%\n\x0c\n\x04\x04V\x02\x06\x12\x04\xb3\x06\x082\n\r\n\x05\x04V\x02\
    \x06\x04\x12\x04\xb3\x06\x08\x10\n\r\n\x05\x04V\x02\x06\x05\x12\x04\xb3\
    \x06\x11\x16\n\r\n\x05\x04V\x02\x06\x01\x12\x04\xb3\x06\x17-\n\r\n\x05\
    \x04V\x02\x06\x03\x12\x04\xb3\x0601\n\x0c\n\x04\x04V\x02\x07\x12\x04\xb4\
    \x06\x08%\n\r\n\x05\x04V\x02\x07\x04\x12\x04\xb4\x06\x08\x10\n\r\n\x05\
    \x04V\x02\x07\x05\x12\x04\xb4\x06\x11\x17\n\r\n\x05\x04V\x02\x07\x01\x12\
    \x04\xb4\x06\x18\x20\n\r\n\x05\x04V\x02\x07\x03\x12\x04\xb4\x06#$\n\x0c\
    \n\x04\x04V\x02\x08\x12\x04\xb5\x06\x08<\n\r\n\x05\x04V\x02\x08\x04\x12\
    \x04\xb5\x06\x08\x10\n\r\n\x05\x04V\x02\x08\x06\x12\x04\xb5\x06\x111\n\r\
    \n\x05\x04V\x02\x08\x01\x12\x04\xb5\x0627\n\r\n\x05\x04V\x02\x08\x03\x12\
    \x04\xb5\x06:;\n\x0c\n\x02\x04W\x12\x06\xb8\x06\0\xbc\x06\x01\n\x0b\n\
    \x03\x04W\x01\x12\x04\xb8\x06\x08.\n\x0c\n\x04\x04W\x02\0\x12\x04\xb9\
    \x06\x087\n\r\n\x05\x04W\x02\0\x04\x12\x04\xb9\x06\x08\x10\n\r\n\x05\x04\
    W\x02\0\x06\x12\x04\xb9\x06\x11,\n\r\n\x05\x04W\x02\0\x01\x12\x04\xb9\
    \x06-2\n\r\n\x05\x04W\x02\0\x03\x12\x04\xb9\x0656\n\x0c\n\x04\x04W\x02\
    \x01\x12\x04\xba\x06\x08(\n\r\n\x05\x04W\x02\x01\x04\x12\x04\xba\x06\x08\
    \x10\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xba\x06\x11\x17\n\r\n\x05\x04W\
    \x02\x01\x01\x12\x04\xba\x06\x18#\n\r\n\x05\x04W\x02\x01\x03\x12\x04\xba\
    \x06&'\n\x0c\n\x04\x04W\x02\x02\x12\x04\xbb\x06\x08$\n\r\n\x05\x04W\x02\
    \x02\x04\x12\x04\xbb\x06\x08\x10\n\r\n\x05\x04W\x02\x02\x05\x12\x04\xbb\
    \x06\x11\x17\n\r\n\x05\x04W\x02\x02\x01\x12\x04\xbb\x06\x18\x1f\n\r\n\
    \x05\x04W\x02\x02\x03\x12\x04\xbb\x06\"#\n\x0c\n\x02\x04X\x12\x06\xbe\
    \x06\0\xc0\x06\x01\n\x0b\n\x03\x04X\x01\x12\x04\xbe\x06\x086\n\x0c\n\x04\
    \x04X\x02\0\x12\x04\xbf\x06\x08\"\n\r\n\x05\x04X\x02\0\x04\x12\x04\xbf\
    \x06\x08\x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xbf\x06\x11\x15\n\r\n\x05\
    \x04X\x02\0\x01\x12\x04\xbf\x06\x16\x1d\n\r\n\x05\x04X\x02\0\x03\x12\x04\
    \xbf\x06\x20!\n\x0c\n\x02\x04Y\x12\x06\xc2\x06\0\xc4\x06\x01\n\x0b\n\x03\
    \x04Y\x01\x12\x04\xc2\x06\x08(\n\x0c\n\x04\x04Y\x02\0\x12\x04\xc3\x06\
    \x087\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xc3\x06\x08\x10\n\r\n\x05\x04Y\
    \x02\0\x06\x12\x04\xc3\x06\x11,\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xc3\x06\
    -2\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xc3\x0656\n\x0c\n\x02\x04Z\x12\x06\
    \xc6\x06\0\xc8\x06\x01\n\x0b\n\x03\x04Z\x01\x12\x04\xc6\x06\x080\n\x0c\n\
    \x04\x04Z\x02\0\x12\x04\xc7\x06\x08\"\n\r\n\x05\x04Z\x02\0\x04\x12\x04\
    \xc7\x06\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\xc7\x06\x11\x15\n\r\n\
    \x05\x04Z\x02\0\x01\x12\x04\xc7\x06\x16\x1d\n\r\n\x05\x04Z\x02\0\x03\x12\
    \x04\xc7\x06\x20!\n\x0c\n\x02\x04[\x12\x06\xca\x06\0\xcf\x06\x01\n\x0b\n\
    \x03\x04[\x01\x12\x04\xca\x06\x08)\n\x0c\n\x04\x04[\x02\0\x12\x04\xcb\
    \x06\x08(\n\r\n\x05\x04[\x02\0\x04\x12\x04\xcb\x06\x08\x10\n\r\n\x05\x04\
    [\x02\0\x05\x12\x04\xcb\x06\x11\x17\n\r\n\x05\x04[\x02\0\x01\x12\x04\xcb\
    \x06\x18#\n\r\n\x05\x04[\x02\0\x03\x12\x04\xcb\x06&'\n\x0c\n\x04\x04[\
    \x02\x01\x12\x04\xcc\x06\x08(\n\r\n\x05\x04[\x02\x01\x04\x12\x04\xcc\x06\
    \x08\x10\n\r\n\x05\x04[\x02\x01\x05\x12\x04\xcc\x06\x11\x15\n\r\n\x05\
    \x04[\x02\x01\x01\x12\x04\xcc\x06\x16#\n\r\n\x05\x04[\x02\x01\x03\x12\
    \x04\xcc\x06&'\n\x0c\n\x04\x04[\x02\x02\x12\x04\xcd\x06\x08&\n\r\n\x05\
    \x04[\x02\x02\x04\x12\x04\xcd\x06\x08\x10\n\r\n\x05\x04[\x02\x02\x05\x12\
    \x04\xcd\x06\x11\x16\n\r\n\x05\x04[\x02\x02\x01\x12\x04\xcd\x06\x17!\n\r\
    \n\x05\x04[\x02\x02\x03\x12\x04\xcd\x06$%\n\x0c\n\x04\x04[\x02\x03\x12\
    \x04\xce\x06\x08-\n\r\n\x05\x04[\x02\x03\x04\x12\x04\xce\x06\x08\x10\n\r\
    \n\x05\x04[\x02\x03\x05\x12\x04\xce\x06\x11\x17\n\r\n\x05\x04[\x02\x03\
    \x01\x12\x04\xce\x06\x18(\n\r\n\x05\x04[\x02\x03\x03\x12\x04\xce\x06+,\n\
    \x0c\n\x02\x04\\\x12\x06\xd1\x06\0\xdb\x06\x01\n\x0b\n\x03\x04\\\x01\x12\
    \x04\xd1\x06\x08\x1f\n\x0e\n\x04\x04\\\x03\0\x12\x06\xd2\x06\x08\xd5\x06\
    \t\n\r\n\x05\x04\\\x03\0\x01\x12\x04\xd2\x06\x10\x1a\n\x0e\n\x06\x04\\\
    \x03\0\x02\0\x12\x04\xd3\x06\x10)\n\x0f\n\x07\x04\\\x03\0\x02\0\x04\x12\
    \x04\xd3\x06\x10\x18\n\x0f\n\x07\x04\\\x03\0\x02\0\x05\x12\x04\xd3\x06\
    \x19\x1f\n\x0f\n\x07\x04\\\x03\0\x02\0\x01\x12\x04\xd3\x06\x20$\n\x0f\n\
    \x07\x04\\\x03\0\x02\0\x03\x12\x04\xd3\x06'(\n\x0e\n\x06\x04\\\x03\0\x02\
    \x01\x12\x04\xd4\x06\x10/\n\x0f\n\x07\x04\\\x03\0\x02\x01\x04\x12\x04\
    \xd4\x06\x10\x18\n\x0f\n\x07\x04\\\x03\0\x02\x01\x05\x12\x04\xd4\x06\x19\
    \x1f\n\x0f\n\x07\x04\\\x03\0\x02\x01\x01\x12\x04\xd4\x06\x20*\n\x0f\n\
    \x07\x04\\\x03\0\x02\x01\x03\x12\x04\xd4\x06-.\n\x0c\n\x04\x04\\\x02\0\
    \x12\x04\xd7\x06\x08&\n\r\n\x05\x04\\\x02\0\x04\x12\x04\xd7\x06\x08\x10\
    \n\r\n\x05\x04\\\x02\0\x05\x12\x04\xd7\x06\x11\x17\n\r\n\x05\x04\\\x02\0\
    \x01\x12\x04\xd7\x06\x18!\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xd7\x06$%\n\
    \x0c\n\x04\x04\\\x02\x01\x12\x04\xd8\x06\x08&\n\r\n\x05\x04\\\x02\x01\
    \x04\x12\x04\xd8\x06\x08\x10\n\r\n\x05\x04\\\x02\x01\x05\x12\x04\xd8\x06\
    \x11\x16\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\xd8\x06\x17!\n\r\n\x05\x04\
    \\\x02\x01\x03\x12\x04\xd8\x06$%\n\x0c\n\x04\x04\\\x02\x02\x12\x04\xd9\
    \x06\x08=\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\xd9\x06\x08\x10\n\r\n\x05\
    \x04\\\x02\x02\x06\x12\x04\xd9\x06\x113\n\r\n\x05\x04\\\x02\x02\x01\x12\
    \x04\xd9\x0648\n\r\n\x05\x04\\\x02\x02\x03\x12\x04\xd9\x06;<\n\x0c\n\x04\
    \x04\\\x02\x03\x12\x04\xda\x06\x081\n\r\n\x05\x04\\\x02\x03\x04\x12\x04\
    \xda\x06\x08\x10\n\r\n\x05\x04\\\x02\x03\x05\x12\x04\xda\x06\x11\x15\n\r\
    \n\x05\x04\\\x02\x03\x01\x12\x04\xda\x06\x16,\n\r\n\x05\x04\\\x02\x03\
    \x03\x12\x04\xda\x06/0\n\x0c\n\x02\x04]\x12\x06\xdd\x06\0\xe4\x06\x01\n\
    \x0b\n\x03\x04]\x01\x12\x04\xdd\x06\x08\x14\n\x0e\n\x04\x04]\x03\0\x12\
    \x06\xde\x06\x08\xe1\x06\t\n\r\n\x05\x04]\x03\0\x01\x12\x04\xde\x06\x10\
    \"\n\x0e\n\x06\x04]\x03\0\x02\0\x12\x04\xdf\x06\x10.\n\x0f\n\x07\x04]\
    \x03\0\x02\0\x04\x12\x04\xdf\x06\x10\x18\n\x0f\n\x07\x04]\x03\0\x02\0\
    \x05\x12\x04\xdf\x06\x19\x1f\n\x0f\n\x07\x04]\x03\0\x02\0\x01\x12\x04\
    \xdf\x06\x20)\n\x0f\n\x07\x04]\x03\0\x02\0\x03\x12\x04\xdf\x06,-\n\x0e\n\
    \x06\x04]\x03\0\x02\x01\x12\x04\xe0\x06\x100\n\x0f\n\x07\x04]\x03\0\x02\
    \x01\x04\x12\x04\xe0\x06\x10\x18\n\x0f\n\x07\x04]\x03\0\x02\x01\x05\x12\
    \x04\xe0\x06\x19\x1f\n\x0f\n\x07\x04]\x03\0\x02\x01\x01\x12\x04\xe0\x06\
    \x20+\n\x0f\n\x07\x04]\x03\0\x02\x01\x03\x12\x04\xe0\x06./\n\x0c\n\x04\
    \x04]\x02\0\x12\x04\xe3\x06\x08L\n\r\n\x05\x04]\x02\0\x04\x12\x04\xe3\
    \x06\x08\x10\n\r\n\x05\x04]\x02\0\x06\x12\x04\xe3\x06\x110\n\r\n\x05\x04\
    ]\x02\0\x01\x12\x04\xe3\x061G\n\r\n\x05\x04]\x02\0\x03\x12\x04\xe3\x06JK\
    \n\x0c\n\x02\x04^\x12\x06\xe6\x06\0\xee\x06\x01\n\x0b\n\x03\x04^\x01\x12\
    \x04\xe6\x06\x08!\n\x0c\n\x04\x04^\x02\0\x12\x04\xe7\x06\x08&\n\r\n\x05\
    \x04^\x02\0\x04\x12\x04\xe7\x06\x08\x10\n\r\n\x05\x04^\x02\0\x05\x12\x04\
    \xe7\x06\x11\x16\n\r\n\x05\x04^\x02\0\x01\x12\x04\xe7\x06\x17!\n\r\n\x05\
    \x04^\x02\0\x03\x12\x04\xe7\x06$%\n\x0c\n\x04\x04^\x02\x01\x12\x04\xe8\
    \x06\x08'\n\r\n\x05\x04^\x02\x01\x04\x12\x04\xe8\x06\x08\x10\n\r\n\x05\
    \x04^\x02\x01\x05\x12\x04\xe8\x06\x11\x18\n\r\n\x05\x04^\x02\x01\x01\x12\
    \x04\xe8\x06\x19\"\n\r\n\x05\x04^\x02\x01\x03\x12\x04\xe8\x06%&\n\x0c\n\
    \x04\x04^\x02\x02\x12\x04\xe9\x06\x08$\n\r\n\x05\x04^\x02\x02\x04\x12\
    \x04\xe9\x06\x08\x10\n\r\n\x05\x04^\x02\x02\x05\x12\x04\xe9\x06\x11\x17\
    \n\r\n\x05\x04^\x02\x02\x01\x12\x04\xe9\x06\x18\x1f\n\r\n\x05\x04^\x02\
    \x02\x03\x12\x04\xe9\x06\"#\n\x0c\n\x04\x04^\x02\x03\x12\x04\xea\x06\x08\
    '\n\r\n\x05\x04^\x02\x03\x04\x12\x04\xea\x06\x08\x10\n\r\n\x05\x04^\x02\
    \x03\x05\x12\x04\xea\x06\x11\x17\n\r\n\x05\x04^\x02\x03\x01\x12\x04\xea\
    \x06\x18\"\n\r\n\x05\x04^\x02\x03\x03\x12\x04\xea\x06%&\n\x0c\n\x04\x04^\
    \x02\x04\x12\x04\xeb\x06\x08(\n\r\n\x05\x04^\x02\x04\x04\x12\x04\xeb\x06\
    \x08\x10\n\r\n\x05\x04^\x02\x04\x05\x12\x04\xeb\x06\x11\x16\n\r\n\x05\
    \x04^\x02\x04\x01\x12\x04\xeb\x06\x17#\n\r\n\x05\x04^\x02\x04\x03\x12\
    \x04\xeb\x06&'\n\x0c\n\x04\x04^\x02\x05\x12\x04\xec\x06\x08+\n\r\n\x05\
    \x04^\x02\x05\x04\x12\x04\xec\x06\x08\x10\n\r\n\x05\x04^\x02\x05\x05\x12\
    \x04\xec\x06\x11\x18\n\r\n\x05\x04^\x02\x05\x01\x12\x04\xec\x06\x19&\n\r\
    \n\x05\x04^\x02\x05\x03\x12\x04\xec\x06)*\n\x0c\n\x04\x04^\x02\x06\x12\
    \x04\xed\x06\x08+\n\r\n\x05\x04^\x02\x06\x04\x12\x04\xed\x06\x08\x10\n\r\
    \n\x05\x04^\x02\x06\x05\x12\x04\xed\x06\x11\x18\n\r\n\x05\x04^\x02\x06\
    \x01\x12\x04\xed\x06\x19&\n\r\n\x05\x04^\x02\x06\x03\x12\x04\xed\x06)*\n\
    \x0c\n\x02\x04_\x12\x06\xf0\x06\0\xf6\x06\x01\n\x0b\n\x03\x04_\x01\x12\
    \x04\xf0\x06\x08-\n\x0c\n\x04\x04_\x02\0\x12\x04\xf1\x06\x087\n\r\n\x05\
    \x04_\x02\0\x04\x12\x04\xf1\x06\x08\x10\n\r\n\x05\x04_\x02\0\x05\x12\x04\
    \xf1\x06\x11\x17\n\r\n\x05\x04_\x02\0\x01\x12\x04\xf1\x06\x182\n\r\n\x05\
    \x04_\x02\0\x03\x12\x04\xf1\x0656\n\x0c\n\x04\x04_\x02\x01\x12\x04\xf2\
    \x06\x082\n\r\n\x05\x04_\x02\x01\x04\x12\x04\xf2\x06\x08\x10\n\r\n\x05\
    \x04_\x02\x01\x05\x12\x04\xf2\x06\x11\x17\n\r\n\x05\x04_\x02\x01\x01\x12\
    \x04\xf2\x06\x18-\n\r\n\x05\x04_\x02\x01\x03\x12\x04\xf2\x0601\n\x0c\n\
    \x04\x04_\x02\x02\x12\x04\xf3\x06\x082\n\r\n\x05\x04_\x02\x02\x04\x12\
    \x04\xf3\x06\x08\x10\n\r\n\x05\x04_\x02\x02\x05\x12\x04\xf3\x06\x11\x17\
    \n\r\n\x05\x04_\x02\x02\x01\x12\x04\xf3\x06\x18-\n\r\n\x05\x04_\x02\x02\
    \x03\x12\x04\xf3\x0601\n\x0c\n\x04\x04_\x02\x03\x12\x04\xf4\x06\x084\n\r\
    \n\x05\x04_\x02\x03\x04\x12\x04\xf4\x06\x08\x10\n\r\n\x05\x04_\x02\x03\
    \x05\x12\x04\xf4\x06\x11\x17\n\r\n\x05\x04_\x02\x03\x01\x12\x04\xf4\x06\
    \x18/\n\r\n\x05\x04_\x02\x03\x03\x12\x04\xf4\x0623\n\x0c\n\x04\x04_\x02\
    \x04\x12\x04\xf5\x06\x08)\n\r\n\x05\x04_\x02\x04\x04\x12\x04\xf5\x06\x08\
    \x10\n\r\n\x05\x04_\x02\x04\x05\x12\x04\xf5\x06\x11\x17\n\r\n\x05\x04_\
    \x02\x04\x01\x12\x04\xf5\x06\x18$\n\r\n\x05\x04_\x02\x04\x03\x12\x04\xf5\
    \x06'(\n\x0c\n\x02\x04`\x12\x06\xf8\x06\0\xfd\x06\x01\n\x0b\n\x03\x04`\
    \x01\x12\x04\xf8\x06\x08)\n\x0c\n\x04\x04`\x02\0\x12\x04\xf9\x06\x08#\n\
    \r\n\x05\x04`\x02\0\x04\x12\x04\xf9\x06\x08\x10\n\r\n\x05\x04`\x02\0\x05\
    \x12\x04\xf9\x06\x11\x17\n\r\n\x05\x04`\x02\0\x01\x12\x04\xf9\x06\x18\
    \x1e\n\r\n\x05\x04`\x02\0\x03\x12\x04\xf9\x06!\"\n\x0c\n\x04\x04`\x02\
    \x01\x12\x04\xfa\x06\x08*\n\r\n\x05\x04`\x02\x01\x04\x12\x04\xfa\x06\x08\
    \x10\n\r\n\x05\x04`\x02\x01\x05\x12\x04\xfa\x06\x11\x16\n\r\n\x05\x04`\
    \x02\x01\x01\x12\x04\xfa\x06\x17%\n\r\n\x05\x04`\x02\x01\x03\x12\x04\xfa\
    \x06()\n\x0c\n\x04\x04`\x02\x02\x12\x04\xfb\x06\x08,\n\r\n\x05\x04`\x02\
    \x02\x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x04`\x02\x02\x05\x12\x04\xfb\
    \x06\x11\x17\n\r\n\x05\x04`\x02\x02\x01\x12\x04\xfb\x06\x18'\n\r\n\x05\
    \x04`\x02\x02\x03\x12\x04\xfb\x06*+\n\x0c\n\x04\x04`\x02\x03\x12\x04\xfc\
    \x06\x08+\n\r\n\x05\x04`\x02\x03\x04\x12\x04\xfc\x06\x08\x10\n\r\n\x05\
    \x04`\x02\x03\x05\x12\x04\xfc\x06\x11\x18\n\r\n\x05\x04`\x02\x03\x01\x12\
    \x04\xfc\x06\x19&\n\r\n\x05\x04`\x02\x03\x03\x12\x04\xfc\x06)*\n\x0c\n\
    \x02\x04a\x12\x06\xff\x06\0\x87\x07\x01\n\x0b\n\x03\x04a\x01\x12\x04\xff\
    \x06\x08)\n\x0e\n\x04\x04a\x03\0\x12\x06\x80\x07\x08\x83\x07\t\n\r\n\x05\
    \x04a\x03\0\x01\x12\x04\x80\x07\x10\x18\n\x0e\n\x06\x04a\x03\0\x02\0\x12\
    \x04\x81\x07\x100\n\x0f\n\x07\x04a\x03\0\x02\0\x04\x12\x04\x81\x07\x10\
    \x18\n\x0f\n\x07\x04a\x03\0\x02\0\x05\x12\x04\x81\x07\x19\x1f\n\x0f\n\
    \x07\x04a\x03\0\x02\0\x01\x12\x04\x81\x07\x20+\n\x0f\n\x07\x04a\x03\0\
    \x02\0\x03\x12\x04\x81\x07./\n\x0e\n\x06\x04a\x03\0\x02\x01\x12\x04\x82\
    \x07\x103\n\x0f\n\x07\x04a\x03\0\x02\x01\x04\x12\x04\x82\x07\x10\x18\n\
    \x0f\n\x07\x04a\x03\0\x02\x01\x05\x12\x04\x82\x07\x19\x1f\n\x0f\n\x07\
    \x04a\x03\0\x02\x01\x01\x12\x04\x82\x07\x20.\n\x0f\n\x07\x04a\x03\0\x02\
    \x01\x03\x12\x04\x82\x0712\n\x0c\n\x04\x04a\x02\0\x12\x04\x85\x07\x08&\n\
    \r\n\x05\x04a\x02\0\x04\x12\x04\x85\x07\x08\x10\n\r\n\x05\x04a\x02\0\x05\
    \x12\x04\x85\x07\x11\x17\n\r\n\x05\x04a\x02\0\x01\x12\x04\x85\x07\x18!\n\
    \r\n\x05\x04a\x02\0\x03\x12\x04\x85\x07$%\n\x0c\n\x04\x04a\x02\x01\x12\
    \x04\x86\x07\x08K\n\r\n\x05\x04a\x02\x01\x04\x12\x04\x86\x07\x08\x10\n\r\
    \n\x05\x04a\x02\x01\x06\x12\x04\x86\x07\x11;\n\r\n\x05\x04a\x02\x01\x01\
    \x12\x04\x86\x07<F\n\r\n\x05\x04a\x02\x01\x03\x12\x04\x86\x07IJ\n\x0c\n\
    \x02\x04b\x12\x06\x89\x07\0\x8c\x07\x01\n\x0b\n\x03\x04b\x01\x12\x04\x89\
    \x07\x08\x1a\n\x0c\n\x04\x04b\x02\0\x12\x04\x8a\x07\x08$\n\r\n\x05\x04b\
    \x02\0\x04\x12\x04\x8a\x07\x08\x10\n\r\n\x05\x04b\x02\0\x05\x12\x04\x8a\
    \x07\x11\x17\n\r\n\x05\x04b\x02\0\x01\x12\x04\x8a\x07\x18\x1f\n\r\n\x05\
    \x04b\x02\0\x03\x12\x04\x8a\x07\"#\n\x0c\n\x04\x04b\x02\x01\x12\x04\x8b\
    \x07\x08)\n\r\n\x05\x04b\x02\x01\x04\x12\x04\x8b\x07\x08\x10\n\r\n\x05\
    \x04b\x02\x01\x05\x12\x04\x8b\x07\x11\x17\n\r\n\x05\x04b\x02\x01\x01\x12\
    \x04\x8b\x07\x18$\n\r\n\x05\x04b\x02\x01\x03\x12\x04\x8b\x07'(\n\x0c\n\
    \x02\x04c\x12\x06\x8e\x07\0\x95\x07\x01\n\x0b\n\x03\x04c\x01\x12\x04\x8e\
    \x07\x08*\n\x0e\n\x04\x04c\x03\0\x12\x06\x8f\x07\x08\x92\x07\t\n\r\n\x05\
    \x04c\x03\0\x01\x12\x04\x8f\x07\x10\x13\n\x0e\n\x06\x04c\x03\0\x02\0\x12\
    \x04\x90\x07\x10,\n\x0f\n\x07\x04c\x03\0\x02\0\x04\x12\x04\x90\x07\x10\
    \x18\n\x0f\n\x07\x04c\x03\0\x02\0\x05\x12\x04\x90\x07\x19\x1f\n\x0f\n\
    \x07\x04c\x03\0\x02\0\x01\x12\x04\x90\x07\x20'\n\x0f\n\x07\x04c\x03\0\
    \x02\0\x03\x12\x04\x90\x07*+\n\x0e\n\x06\x04c\x03\0\x02\x01\x12\x04\x91\
    \x07\x10.\n\x0f\n\x07\x04c\x03\0\x02\x01\x04\x12\x04\x91\x07\x10\x18\n\
    \x0f\n\x07\x04c\x03\0\x02\x01\x05\x12\x04\x91\x07\x19\x1f\n\x0f\n\x07\
    \x04c\x03\0\x02\x01\x01\x12\x04\x91\x07\x20)\n\x0f\n\x07\x04c\x03\0\x02\
    \x01\x03\x12\x04\x91\x07,-\n\x0c\n\x04\x04c\x02\0\x12\x04\x94\x07\x08A\n\
    \r\n\x05\x04c\x02\0\x04\x12\x04\x94\x07\x08\x10\n\r\n\x05\x04c\x02\0\x06\
    \x12\x04\x94\x07\x117\n\r\n\x05\x04c\x02\0\x01\x12\x04\x94\x078<\n\r\n\
    \x05\x04c\x02\0\x03\x12\x04\x94\x07?@\n\x0c\n\x02\x04d\x12\x06\x97\x07\0\
    \x9a\x07\x01\n\x0b\n\x03\x04d\x01\x12\x04\x97\x07\x08)\n\x0c\n\x04\x04d\
    \x02\0\x12\x04\x98\x07\x08'\n\r\n\x05\x04d\x02\0\x04\x12\x04\x98\x07\x08\
    \x10\n\r\n\x05\x04d\x02\0\x05\x12\x04\x98\x07\x11\x17\n\r\n\x05\x04d\x02\
    \0\x01\x12\x04\x98\x07\x18\"\n\r\n\x05\x04d\x02\0\x03\x12\x04\x98\x07%&\
    \n\x0c\n\x04\x04d\x02\x01\x12\x04\x99\x07\x08(\n\r\n\x05\x04d\x02\x01\
    \x04\x12\x04\x99\x07\x08\x10\n\r\n\x05\x04d\x02\x01\x05\x12\x04\x99\x07\
    \x11\x15\n\r\n\x05\x04d\x02\x01\x01\x12\x04\x99\x07\x16#\n\r\n\x05\x04d\
    \x02\x01\x03\x12\x04\x99\x07&'\n\x0c\n\x02\x04e\x12\x06\x9c\x07\0\x9e\
    \x07\x01\n\x0b\n\x03\x04e\x01\x12\x04\x9c\x07\x08\x1a\n\x0c\n\x04\x04e\
    \x02\0\x12\x04\x9d\x07\x08&\n\r\n\x05\x04e\x02\0\x04\x12\x04\x9d\x07\x08\
    \x10\n\r\n\x05\x04e\x02\0\x05\x12\x04\x9d\x07\x11\x17\n\r\n\x05\x04e\x02\
    \0\x01\x12\x04\x9d\x07\x18!\n\r\n\x05\x04e\x02\0\x03\x12\x04\x9d\x07$%\n\
    \x0c\n\x02\x04f\x12\x06\xa0\x07\0\xa1\x07\x01\n\x0b\n\x03\x04f\x01\x12\
    \x04\xa0\x07\x08'\n\x0c\n\x02\x04g\x12\x06\xa3\x07\0\xa9\x07\x01\n\x0b\n\
    \x03\x04g\x01\x12\x04\xa3\x07\x08/\n\x0c\n\x04\x04g\x02\0\x12\x04\xa4\
    \x07\x08&\n\r\n\x05\x04g\x02\0\x04\x12\x04\xa4\x07\x08\x10\n\r\n\x05\x04\
    g\x02\0\x05\x12\x04\xa4\x07\x11\x18\n\r\n\x05\x04g\x02\0\x01\x12\x04\xa4\
    \x07\x19!\n\r\n\x05\x04g\x02\0\x03\x12\x04\xa4\x07$%\n\x0c\n\x04\x04g\
    \x02\x01\x12\x04\xa5\x07\x08'\n\r\n\x05\x04g\x02\x01\x04\x12\x04\xa5\x07\
    \x08\x10\n\r\n\x05\x04g\x02\x01\x05\x12\x04\xa5\x07\x11\x17\n\r\n\x05\
    \x04g\x02\x01\x01\x12\x04\xa5\x07\x18\"\n\r\n\x05\x04g\x02\x01\x03\x12\
    \x04\xa5\x07%&\n\x0c\n\x04\x04g\x02\x02\x12\x04\xa6\x07\x08)\n\r\n\x05\
    \x04g\x02\x02\x04\x12\x04\xa6\x07\x08\x10\n\r\n\x05\x04g\x02\x02\x05\x12\
    \x04\xa6\x07\x11\x17\n\r\n\x05\x04g\x02\x02\x01\x12\x04\xa6\x07\x18$\n\r\
    \n\x05\x04g\x02\x02\x03\x12\x04\xa6\x07'(\n\x0c\n\x04\x04g\x02\x03\x12\
    \x04\xa7\x07\x08%\n\r\n\x05\x04g\x02\x03\x04\x12\x04\xa7\x07\x08\x10\n\r\
    \n\x05\x04g\x02\x03\x05\x12\x04\xa7\x07\x11\x17\n\r\n\x05\x04g\x02\x03\
    \x01\x12\x04\xa7\x07\x18\x20\n\r\n\x05\x04g\x02\x03\x03\x12\x04\xa7\x07#\
    $\n\x0c\n\x04\x04g\x02\x04\x12\x04\xa8\x07\x08/\n\r\n\x05\x04g\x02\x04\
    \x04\x12\x04\xa8\x07\x08\x10\n\r\n\x05\x04g\x02\x04\x05\x12\x04\xa8\x07\
    \x11\x17\n\r\n\x05\x04g\x02\x04\x01\x12\x04\xa8\x07\x18*\n\r\n\x05\x04g\
    \x02\x04\x03\x12\x04\xa8\x07-.\n\x0c\n\x02\x04h\x12\x06\xab\x07\0\xac\
    \x07\x01\n\x0b\n\x03\x04h\x01\x12\x04\xab\x07\x08#\n\x0c\n\x02\x04i\x12\
    \x06\xae\x07\0\xb0\x07\x01\n\x0b\n\x03\x04i\x01\x12\x04\xae\x07\x084\n\
    \x0c\n\x04\x04i\x02\0\x12\x04\xaf\x07\x08%\n\r\n\x05\x04i\x02\0\x04\x12\
    \x04\xaf\x07\x08\x10\n\r\n\x05\x04i\x02\0\x05\x12\x04\xaf\x07\x11\x17\n\
    \r\n\x05\x04i\x02\0\x01\x12\x04\xaf\x07\x18\x20\n\r\n\x05\x04i\x02\0\x03\
    \x12\x04\xaf\x07#$\n\x0c\n\x02\x04j\x12\x06\xb2\x07\0\xbf\x07\x01\n\x0b\
    \n\x03\x04j\x01\x12\x04\xb2\x07\x08<\n\x0e\n\x04\x04j\x04\0\x12\x06\xb3\
    \x07\x08\xbb\x07\t\n\r\n\x05\x04j\x04\0\x01\x12\x04\xb3\x07\r\x16\n\x0e\
    \n\x06\x04j\x04\0\x02\0\x12\x04\xb4\x07\x10%\n\x0f\n\x07\x04j\x04\0\x02\
    \0\x01\x12\x04\xb4\x07\x10\x20\n\x0f\n\x07\x04j\x04\0\x02\0\x02\x12\x04\
    \xb4\x07#$\n\x0e\n\x06\x04j\x04\0\x02\x01\x12\x04\xb5\x07\x10\x1f\n\x0f\
    \n\x07\x04j\x04\0\x02\x01\x01\x12\x04\xb5\x07\x10\x1a\n\x0f\n\x07\x04j\
    \x04\0\x02\x01\x02\x12\x04\xb5\x07\x1d\x1e\n\x0e\n\x06\x04j\x04\0\x02\
    \x02\x12\x04\xb6\x07\x10\x1f\n\x0f\n\x07\x04j\x04\0\x02\x02\x01\x12\x04\
    \xb6\x07\x10\x1a\n\x0f\n\x07\x04j\x04\0\x02\x02\x02\x12\x04\xb6\x07\x1d\
    \x1e\n\x0e\n\x06\x04j\x04\0\x02\x03\x12\x04\xb7\x07\x10\x20\n\x0f\n\x07\
    \x04j\x04\0\x02\x03\x01\x12\x04\xb7\x07\x10\x1b\n\x0f\n\x07\x04j\x04\0\
    \x02\x03\x02\x12\x04\xb7\x07\x1e\x1f\n\x0e\n\x06\x04j\x04\0\x02\x04\x12\
    \x04\xb8\x07\x10\x1f\n\x0f\n\x07\x04j\x04\0\x02\x04\x01\x12\x04\xb8\x07\
    \x10\x1a\n\x0f\n\x07\x04j\x04\0\x02\x04\x02\x12\x04\xb8\x07\x1d\x1e\n\
    \x0e\n\x06\x04j\x04\0\x02\x05\x12\x04\xb9\x07\x10&\n\x0f\n\x07\x04j\x04\
    \0\x02\x05\x01\x12\x04\xb9\x07\x10!\n\x0f\n\x07\x04j\x04\0\x02\x05\x02\
    \x12\x04\xb9\x07$%\n\x0e\n\x06\x04j\x04\0\x02\x06\x12\x04\xba\x07\x10)\n\
    \x0f\n\x07\x04j\x04\0\x02\x06\x01\x12\x04\xba\x07\x10$\n\x0f\n\x07\x04j\
    \x04\0\x02\x06\x02\x12\x04\xba\x07'(\n\x0c\n\x04\x04j\x02\0\x12\x04\xbd\
    \x07\x08[\n\r\n\x05\x04j\x02\0\x04\x12\x04\xbd\x07\x08\x10\n\r\n\x05\x04\
    j\x02\0\x06\x12\x04\xbd\x07\x11O\n\r\n\x05\x04j\x02\0\x01\x12\x04\xbd\
    \x07PV\n\r\n\x05\x04j\x02\0\x03\x12\x04\xbd\x07YZ\n\x0c\n\x04\x04j\x02\
    \x01\x12\x04\xbe\x07\x08/\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xbe\x07\x08\
    \x10\n\r\n\x05\x04j\x02\x01\x05\x12\x04\xbe\x07\x11\x17\n\r\n\x05\x04j\
    \x02\x01\x01\x12\x04\xbe\x07\x18*\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xbe\
    \x07-.\n\x0c\n\x02\x04k\x12\x06\xc1\x07\0\xc5\x07\x01\n\x0b\n\x03\x04k\
    \x01\x12\x04\xc1\x07\x08\"\n\x0c\n\x04\x04k\x02\0\x12\x04\xc2\x07\x08!\n\
    \r\n\x05\x04k\x02\0\x04\x12\x04\xc2\x07\x08\x10\n\r\n\x05\x04k\x02\0\x05\
    \x12\x04\xc2\x07\x11\x15\n\r\n\x05\x04k\x02\0\x01\x12\x04\xc2\x07\x16\
    \x1c\n\r\n\x05\x04k\x02\0\x03\x12\x04\xc2\x07\x1f\x20\n\x0c\n\x04\x04k\
    \x02\x01\x12\x04\xc3\x07\x08,\n\r\n\x05\x04k\x02\x01\x04\x12\x04\xc3\x07\
    \x08\x10\n\r\n\x05\x04k\x02\x01\x06\x12\x04\xc3\x07\x11\x1f\n\r\n\x05\
    \x04k\x02\x01\x01\x12\x04\xc3\x07\x20'\n\r\n\x05\x04k\x02\x01\x03\x12\
    \x04\xc3\x07*+\n\x0c\n\x04\x04k\x02\x02\x12\x04\xc4\x07\x08$\n\r\n\x05\
    \x04k\x02\x02\x04\x12\x04\xc4\x07\x08\x10\n\r\n\x05\x04k\x02\x02\x05\x12\
    \x04\xc4\x07\x11\x15\n\r\n\x05\x04k\x02\x02\x01\x12\x04\xc4\x07\x16\x1f\
    \n\r\n\x05\x04k\x02\x02\x03\x12\x04\xc4\x07\"#\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::econ_shared_enums::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(127);
            messages.push(CMsgApplyAutograph::generated_message_descriptor_data());
            messages.push(CMsgAdjustItemEquippedState::generated_message_descriptor_data());
            messages.push(CMsgEconPlayerStrangeCountAdjustment::generated_message_descriptor_data());
            messages.push(CMsgCraftingResponse::generated_message_descriptor_data());
            messages.push(CMsgGCRequestStoreSalesData::generated_message_descriptor_data());
            messages.push(CMsgGCRequestStoreSalesDataResponse::generated_message_descriptor_data());
            messages.push(CMsgGCRequestStoreSalesDataUpToDateResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCPingRequest::generated_message_descriptor_data());
            messages.push(CMsgGCToGCPingResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserSessionServer::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserSessionServerResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserServerMembers::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserServerMembersResponse::generated_message_descriptor_data());
            messages.push(CMsgLookupMultipleAccountNames::generated_message_descriptor_data());
            messages.push(CMsgLookupMultipleAccountNamesResponse::generated_message_descriptor_data());
            messages.push(CMsgRequestCrateItems::generated_message_descriptor_data());
            messages.push(CMsgRequestCrateItemsResponse::generated_message_descriptor_data());
            messages.push(CMsgRequestCrateEscalationLevel::generated_message_descriptor_data());
            messages.push(CMsgRequestCrateEscalationLevelResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCCanUseDropRateBonus::generated_message_descriptor_data());
            messages.push(CMsgSQLAddDropRateBonus::generated_message_descriptor_data());
            messages.push(CMsgSQLUpgradeBattleBooster::generated_message_descriptor_data());
            messages.push(CMsgGCToGCRefreshSOCache::generated_message_descriptor_data());
            messages.push(CMsgGCToGCAddSubscriptionTime::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGrantAccountRolledItems::generated_message_descriptor_data());
            messages.push(CMsgGCToGCBetaDeleteItems::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGrantSelfMadeItemToAccount::generated_message_descriptor_data());
            messages.push(CMsgUseItem::generated_message_descriptor_data());
            messages.push(CMsgServerUseItem::generated_message_descriptor_data());
            messages.push(CMsgUseMultipleItems::generated_message_descriptor_data());
            messages.push(CGCStoreRechargeRedirect_LineItem::generated_message_descriptor_data());
            messages.push(CMsgGCEconSQLWorkItemEmbeddedRollbackData::generated_message_descriptor_data());
            messages.push(CMsgCraftStatue::generated_message_descriptor_data());
            messages.push(CMsgRedeemCode::generated_message_descriptor_data());
            messages.push(CMsgRedeemCodeResponse::generated_message_descriptor_data());
            messages.push(CMsgDevNewItemRequest::generated_message_descriptor_data());
            messages.push(CMsgDevNewItemRequestResponse::generated_message_descriptor_data());
            messages.push(CMsgDevUnlockAllItemStyles::generated_message_descriptor_data());
            messages.push(CMsgDevUnlockAllItemStylesResponse::generated_message_descriptor_data());
            messages.push(CMsgGCGetAccountSubscriptionItem::generated_message_descriptor_data());
            messages.push(CMsgGCGetAccountSubscriptionItemResponse::generated_message_descriptor_data());
            messages.push(CMsgGCAddGiftItem::generated_message_descriptor_data());
            messages.push(CMsgClientToGCWrapAndDeliverGift::generated_message_descriptor_data());
            messages.push(CMsgClientToGCWrapAndDeliverGiftResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCUnwrapGift::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetGiftPermissions::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetGiftPermissionsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCUnpackBundle::generated_message_descriptor_data());
            messages.push(CMsgClientToGCUnpackBundleResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientStoreTransactionCompleted::generated_message_descriptor_data());
            messages.push(CMsgClientToGCEquipItems::generated_message_descriptor_data());
            messages.push(CMsgClientToGCEquipItemsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetItemStyle::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetItemStyleResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCUnlockItemStyle::generated_message_descriptor_data());
            messages.push(CMsgClientToGCUnlockItemStyleResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSetItemInventoryCategory::generated_message_descriptor_data());
            messages.push(CMsgClientToGCUnlockCrate::generated_message_descriptor_data());
            messages.push(CMsgClientToGCUnlockCrateResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRemoveItemAttribute::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRemoveItemAttributeResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCNameItem::generated_message_descriptor_data());
            messages.push(CMsgClientToGCNameItemResponse::generated_message_descriptor_data());
            messages.push(CMsgGCSetItemPosition::generated_message_descriptor_data());
            messages.push(CAttribute_ItemDynamicRecipeComponent::generated_message_descriptor_data());
            messages.push(CProtoItemSocket::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_Empty::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_Effect::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_Color::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_Strange::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_Spectator::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_AssetModifier::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_Autograph::generated_message_descriptor_data());
            messages.push(CProtoItemSocket_StaticVisuals::generated_message_descriptor_data());
            messages.push(CAttribute_String::generated_message_descriptor_data());
            messages.push(CWorkshop_GetItemDailyRevenue_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetItemDailyRevenue_Response::generated_message_descriptor_data());
            messages.push(CWorkshop_GetPackageDailyRevenue_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetPackageDailyRevenue_Response::generated_message_descriptor_data());
            messages.push(CMsgSQLGCToGCGrantBackpackSlots::generated_message_descriptor_data());
            messages.push(CMsgClientToGCLookupAccountName::generated_message_descriptor_data());
            messages.push(CMsgClientToGCLookupAccountNameResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCreateStaticRecipe::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCreateStaticRecipeResponse::generated_message_descriptor_data());
            messages.push(CMsgProcessTransactionOrder::generated_message_descriptor_data());
            messages.push(CMsgGCToGCStoreProcessCDKeyTransaction::generated_message_descriptor_data());
            messages.push(CMsgGCToGCStoreProcessCDKeyTransactionResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCStoreProcessSettlement::generated_message_descriptor_data());
            messages.push(CMsgGCToGCStoreProcessSettlementResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCBroadcastConsoleCommand::generated_message_descriptor_data());
            messages.push(CMsgGCToGCConsoleOutput::generated_message_descriptor_data());
            messages.push(CMsgItemAges::generated_message_descriptor_data());
            messages.push(CMsgGCToGCInternalTestMsg::generated_message_descriptor_data());
            messages.push(CMsgGCToGCClientServerVersionsUpdated::generated_message_descriptor_data());
            messages.push(CMsgGCToGCBroadcastMessageFromSub::generated_message_descriptor_data());
            messages.push(CMsgGCToClientCurrencyPricePoints::generated_message_descriptor_data());
            messages.push(CMsgBannedWordList::generated_message_descriptor_data());
            messages.push(CMsgGCToGCFlushSteamInventoryCache::generated_message_descriptor_data());
            messages.push(CMsgGCToGCUpdateSubscriptionItems::generated_message_descriptor_data());
            messages.push(CMsgGCToGCSelfPing::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetInfuxIntervalStats::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetInfuxIntervalStatsResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCPurchaseSucceeded::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetLimitedItemPurchaseQuantity::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetLimitedItemPurchaseQuantityResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCUpdateWelcomeMsg::generated_message_descriptor_data());
            messages.push(cmsg_econ_player_strange_count_adjustment::CStrangeCountAdjustment::generated_message_descriptor_data());
            messages.push(cmsg_gcrequest_store_sales_data_response::Price::generated_message_descriptor_data());
            messages.push(cmsg_lookup_multiple_account_names_response::Account::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcgrant_account_rolled_items::Item::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcgrant_account_rolled_items::item::DynamicAttribute::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcgrant_account_rolled_items::item::AdditionalAuditEntry::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gcget_gift_permissions_response::FriendPermission::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gcunlock_crate_response::Item::generated_message_descriptor_data());
            messages.push(cworkshop_get_item_daily_revenue_response::CountryDailyRevenue::generated_message_descriptor_data());
            messages.push(cworkshop_get_package_daily_revenue_response::CountryDailyRevenue::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gccreate_static_recipe::Item::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gccreate_static_recipe_response::OutputItem::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gccreate_static_recipe_response::InputError::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gccreate_static_recipe_response::AdditionalOutput::generated_message_descriptor_data());
            messages.push(cmsg_process_transaction_order::Item::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcconsole_output::OutputLine::generated_message_descriptor_data());
            messages.push(cmsg_item_ages::MaxItemIDTimestamp::generated_message_descriptor_data());
            messages.push(cmsg_gcto_client_currency_price_points::Currency::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcflush_steam_inventory_cache::Key::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(12);
            enums.push(EGCItemMsg::generated_enum_descriptor_data());
            enums.push(EGCMsgInitiateTradeResponse::generated_enum_descriptor_data());
            enums.push(cmsg_request_crate_items_response::EResult::generated_enum_descriptor_data());
            enums.push(cmsg_request_crate_escalation_level_response::EResult::generated_enum_descriptor_data());
            enums.push(cmsg_redeem_code_response::EResultCode::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcunpack_bundle_response::EUnpackBundle::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcset_item_style_response::ESetStyle::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcunlock_item_style_response::EUnlockStyle::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcname_item_response::ENameItem::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccreate_static_recipe_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
