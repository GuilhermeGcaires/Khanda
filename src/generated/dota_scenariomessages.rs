// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_scenariomessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CScenario_Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenario_Position {
    // message fields
    // @@protoc_insertion_point(field:dota.CScenario_Position.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CScenario_Position.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CScenario_Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenario_Position {
    fn default() -> &'a CScenario_Position {
        <CScenario_Position as ::protobuf::Message>::default_instance()
    }
}

impl CScenario_Position {
    pub fn new() -> CScenario_Position {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CScenario_Position| { &m.x },
            |m: &mut CScenario_Position| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CScenario_Position| { &m.y },
            |m: &mut CScenario_Position| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CScenario_Position>(
            "CScenario_Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CScenario_Position {
    const NAME: &'static str = "CScenario_Position";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenario_Position {
        CScenario_Position::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenario_Position {
        static instance: CScenario_Position = CScenario_Position {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CScenario_Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CScenario_Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CScenario_Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CScenario_Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CScenarioGame_RoshanSpawner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioGame_RoshanSpawner {
    // message fields
    // @@protoc_insertion_point(field:dota.CScenarioGame_RoshanSpawner.kill_count)
    pub kill_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CScenarioGame_RoshanSpawner.state)
    pub state: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CScenarioGame_RoshanSpawner.cooldown)
    pub cooldown: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CScenarioGame_RoshanSpawner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioGame_RoshanSpawner {
    fn default() -> &'a CScenarioGame_RoshanSpawner {
        <CScenarioGame_RoshanSpawner as ::protobuf::Message>::default_instance()
    }
}

impl CScenarioGame_RoshanSpawner {
    pub fn new() -> CScenarioGame_RoshanSpawner {
        ::std::default::Default::default()
    }

    // optional int32 kill_count = 1;

    pub fn kill_count(&self) -> i32 {
        self.kill_count.unwrap_or(0)
    }

    pub fn clear_kill_count(&mut self) {
        self.kill_count = ::std::option::Option::None;
    }

    pub fn has_kill_count(&self) -> bool {
        self.kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_count(&mut self, v: i32) {
        self.kill_count = ::std::option::Option::Some(v);
    }

    // optional int32 state = 2;

    pub fn state(&self) -> i32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional float cooldown = 3;

    pub fn cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(0.)
    }

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kill_count",
            |m: &CScenarioGame_RoshanSpawner| { &m.kill_count },
            |m: &mut CScenarioGame_RoshanSpawner| { &mut m.kill_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CScenarioGame_RoshanSpawner| { &m.state },
            |m: &mut CScenarioGame_RoshanSpawner| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown",
            |m: &CScenarioGame_RoshanSpawner| { &m.cooldown },
            |m: &mut CScenarioGame_RoshanSpawner| { &mut m.cooldown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CScenarioGame_RoshanSpawner>(
            "CScenarioGame_RoshanSpawner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CScenarioGame_RoshanSpawner {
    const NAME: &'static str = "CScenarioGame_RoshanSpawner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kill_count = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.state = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.cooldown = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kill_count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.cooldown {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kill_count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioGame_RoshanSpawner {
        CScenarioGame_RoshanSpawner::new()
    }

    fn clear(&mut self) {
        self.kill_count = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.cooldown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioGame_RoshanSpawner {
        static instance: CScenarioGame_RoshanSpawner = CScenarioGame_RoshanSpawner {
            kill_count: ::std::option::Option::None,
            state: ::std::option::Option::None,
            cooldown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CScenarioGame_RoshanSpawner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CScenarioGame_RoshanSpawner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CScenarioGame_RoshanSpawner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CScenarioGame_RoshanSpawner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CScenarioEnt_Courier)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_Courier {
    // message fields
    // @@protoc_insertion_point(field:dota.CScenarioEnt_Courier.team_number)
    pub team_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_Courier.owner_player_id)
    pub owner_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_Courier.cooldown)
    pub cooldown: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CScenarioEnt_Courier.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_Courier {
    fn default() -> &'a CScenarioEnt_Courier {
        <CScenarioEnt_Courier as ::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_Courier {
    pub fn new() -> CScenarioEnt_Courier {
        ::std::default::Default::default()
    }

    // optional int32 team_number = 1;

    pub fn team_number(&self) -> i32 {
        self.team_number.unwrap_or(0)
    }

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: i32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    // optional int32 owner_player_id = 2;

    pub fn owner_player_id(&self) -> i32 {
        self.owner_player_id.unwrap_or(0)
    }

    pub fn clear_owner_player_id(&mut self) {
        self.owner_player_id = ::std::option::Option::None;
    }

    pub fn has_owner_player_id(&self) -> bool {
        self.owner_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_player_id(&mut self, v: i32) {
        self.owner_player_id = ::std::option::Option::Some(v);
    }

    // optional float cooldown = 3;

    pub fn cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(0.)
    }

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_number",
            |m: &CScenarioEnt_Courier| { &m.team_number },
            |m: &mut CScenarioEnt_Courier| { &mut m.team_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_player_id",
            |m: &CScenarioEnt_Courier| { &m.owner_player_id },
            |m: &mut CScenarioEnt_Courier| { &mut m.owner_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown",
            |m: &CScenarioEnt_Courier| { &m.cooldown },
            |m: &mut CScenarioEnt_Courier| { &mut m.cooldown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CScenarioEnt_Courier>(
            "CScenarioEnt_Courier",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CScenarioEnt_Courier {
    const NAME: &'static str = "CScenarioEnt_Courier";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_number = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.cooldown = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_number {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.cooldown {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_Courier {
        CScenarioEnt_Courier::new()
    }

    fn clear(&mut self) {
        self.team_number = ::std::option::Option::None;
        self.owner_player_id = ::std::option::Option::None;
        self.cooldown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_Courier {
        static instance: CScenarioEnt_Courier = CScenarioEnt_Courier {
            team_number: ::std::option::Option::None,
            owner_player_id: ::std::option::Option::None,
            cooldown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CScenarioEnt_Courier {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CScenarioEnt_Courier").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CScenarioEnt_Courier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CScenarioEnt_Courier {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CScenarioEnt_NPC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_NPC {
    // message fields
    // @@protoc_insertion_point(field:dota.CScenarioEnt_NPC.position)
    pub position: ::protobuf::MessageField<CScenario_Position>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_NPC.unit_name)
    pub unit_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_NPC.team_number)
    pub team_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_NPC.health_frac)
    pub health_frac: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_NPC.owning_camp)
    pub owning_camp: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_NPC.owning_camp_position)
    pub owning_camp_position: ::protobuf::MessageField<CScenario_Position>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_NPC.invade_goal)
    pub invade_goal: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CScenarioEnt_NPC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_NPC {
    fn default() -> &'a CScenarioEnt_NPC {
        <CScenarioEnt_NPC as ::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_NPC {
    pub fn new() -> CScenarioEnt_NPC {
        ::std::default::Default::default()
    }

    // optional string unit_name = 2;

    pub fn unit_name(&self) -> &str {
        match self.unit_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unit_name(&mut self) {
        self.unit_name = ::std::option::Option::None;
    }

    pub fn has_unit_name(&self) -> bool {
        self.unit_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_name(&mut self, v: ::std::string::String) {
        self.unit_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_name(&mut self) -> &mut ::std::string::String {
        if self.unit_name.is_none() {
            self.unit_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unit_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_name(&mut self) -> ::std::string::String {
        self.unit_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 team_number = 3;

    pub fn team_number(&self) -> i32 {
        self.team_number.unwrap_or(0)
    }

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: i32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    // optional float health_frac = 4;

    pub fn health_frac(&self) -> f32 {
        self.health_frac.unwrap_or(0.)
    }

    pub fn clear_health_frac(&mut self) {
        self.health_frac = ::std::option::Option::None;
    }

    pub fn has_health_frac(&self) -> bool {
        self.health_frac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_frac(&mut self, v: f32) {
        self.health_frac = ::std::option::Option::Some(v);
    }

    // optional string owning_camp = 10;

    pub fn owning_camp(&self) -> &str {
        match self.owning_camp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_owning_camp(&mut self) {
        self.owning_camp = ::std::option::Option::None;
    }

    pub fn has_owning_camp(&self) -> bool {
        self.owning_camp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_camp(&mut self, v: ::std::string::String) {
        self.owning_camp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owning_camp(&mut self) -> &mut ::std::string::String {
        if self.owning_camp.is_none() {
            self.owning_camp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.owning_camp.as_mut().unwrap()
    }

    // Take field
    pub fn take_owning_camp(&mut self) -> ::std::string::String {
        self.owning_camp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string invade_goal = 20;

    pub fn invade_goal(&self) -> &str {
        match self.invade_goal.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invade_goal(&mut self) {
        self.invade_goal = ::std::option::Option::None;
    }

    pub fn has_invade_goal(&self) -> bool {
        self.invade_goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invade_goal(&mut self, v: ::std::string::String) {
        self.invade_goal = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invade_goal(&mut self) -> &mut ::std::string::String {
        if self.invade_goal.is_none() {
            self.invade_goal = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invade_goal.as_mut().unwrap()
    }

    // Take field
    pub fn take_invade_goal(&mut self) -> ::std::string::String {
        self.invade_goal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CScenario_Position>(
            "position",
            |m: &CScenarioEnt_NPC| { &m.position },
            |m: &mut CScenarioEnt_NPC| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_name",
            |m: &CScenarioEnt_NPC| { &m.unit_name },
            |m: &mut CScenarioEnt_NPC| { &mut m.unit_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_number",
            |m: &CScenarioEnt_NPC| { &m.team_number },
            |m: &mut CScenarioEnt_NPC| { &mut m.team_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health_frac",
            |m: &CScenarioEnt_NPC| { &m.health_frac },
            |m: &mut CScenarioEnt_NPC| { &mut m.health_frac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_camp",
            |m: &CScenarioEnt_NPC| { &m.owning_camp },
            |m: &mut CScenarioEnt_NPC| { &mut m.owning_camp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CScenario_Position>(
            "owning_camp_position",
            |m: &CScenarioEnt_NPC| { &m.owning_camp_position },
            |m: &mut CScenarioEnt_NPC| { &mut m.owning_camp_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invade_goal",
            |m: &CScenarioEnt_NPC| { &m.invade_goal },
            |m: &mut CScenarioEnt_NPC| { &mut m.invade_goal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CScenarioEnt_NPC>(
            "CScenarioEnt_NPC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CScenarioEnt_NPC {
    const NAME: &'static str = "CScenarioEnt_NPC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                18 => {
                    self.unit_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.team_number = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.health_frac = ::std::option::Option::Some(is.read_float()?);
                },
                82 => {
                    self.owning_camp = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owning_camp_position)?;
                },
                162 => {
                    self.invade_goal = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.team_number {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.health_frac {
            my_size += 1 + 4;
        }
        if let Some(v) = self.owning_camp.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.owning_camp_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.invade_goal.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.unit_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.team_number {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.health_frac {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.owning_camp.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.owning_camp_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.invade_goal.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_NPC {
        CScenarioEnt_NPC::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.unit_name = ::std::option::Option::None;
        self.team_number = ::std::option::Option::None;
        self.health_frac = ::std::option::Option::None;
        self.owning_camp = ::std::option::Option::None;
        self.owning_camp_position.clear();
        self.invade_goal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_NPC {
        static instance: CScenarioEnt_NPC = CScenarioEnt_NPC {
            position: ::protobuf::MessageField::none(),
            unit_name: ::std::option::Option::None,
            team_number: ::std::option::Option::None,
            health_frac: ::std::option::Option::None,
            owning_camp: ::std::option::Option::None,
            owning_camp_position: ::protobuf::MessageField::none(),
            invade_goal: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CScenarioEnt_NPC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CScenarioEnt_NPC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CScenarioEnt_NPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CScenarioEnt_NPC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CScenarioEnt_SpiritBear)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_SpiritBear {
    // message fields
    // @@protoc_insertion_point(field:dota.CScenarioEnt_SpiritBear.owner_id)
    pub owner_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CScenarioEnt_SpiritBear.team_id)
    pub team_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CScenarioEnt_SpiritBear.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_SpiritBear {
    fn default() -> &'a CScenarioEnt_SpiritBear {
        <CScenarioEnt_SpiritBear as ::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_SpiritBear {
    pub fn new() -> CScenarioEnt_SpiritBear {
        ::std::default::Default::default()
    }

    // optional int32 owner_id = 1;

    pub fn owner_id(&self) -> i32 {
        self.owner_id.unwrap_or(0)
    }

    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: i32) {
        self.owner_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id = 2;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_id",
            |m: &CScenarioEnt_SpiritBear| { &m.owner_id },
            |m: &mut CScenarioEnt_SpiritBear| { &mut m.owner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CScenarioEnt_SpiritBear| { &m.team_id },
            |m: &mut CScenarioEnt_SpiritBear| { &mut m.team_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CScenarioEnt_SpiritBear>(
            "CScenarioEnt_SpiritBear",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CScenarioEnt_SpiritBear {
    const NAME: &'static str = "CScenarioEnt_SpiritBear";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owner_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_SpiritBear {
        CScenarioEnt_SpiritBear::new()
    }

    fn clear(&mut self) {
        self.owner_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_SpiritBear {
        static instance: CScenarioEnt_SpiritBear = CScenarioEnt_SpiritBear {
            owner_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CScenarioEnt_SpiritBear {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CScenarioEnt_SpiritBear").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CScenarioEnt_SpiritBear {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CScenarioEnt_SpiritBear {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CScenarioEnt_DroppedItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_DroppedItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CScenarioEnt_DroppedItem.position)
    pub position: ::protobuf::MessageField<CScenario_Position>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CScenarioEnt_DroppedItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_DroppedItem {
    fn default() -> &'a CScenarioEnt_DroppedItem {
        <CScenarioEnt_DroppedItem as ::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_DroppedItem {
    pub fn new() -> CScenarioEnt_DroppedItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CScenario_Position>(
            "position",
            |m: &CScenarioEnt_DroppedItem| { &m.position },
            |m: &mut CScenarioEnt_DroppedItem| { &mut m.position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CScenarioEnt_DroppedItem>(
            "CScenarioEnt_DroppedItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CScenarioEnt_DroppedItem {
    const NAME: &'static str = "CScenarioEnt_DroppedItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_DroppedItem {
        CScenarioEnt_DroppedItem::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_DroppedItem {
        static instance: CScenarioEnt_DroppedItem = CScenarioEnt_DroppedItem {
            position: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CScenarioEnt_DroppedItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CScenarioEnt_DroppedItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CScenarioEnt_DroppedItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CScenarioEnt_DroppedItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDotaScenario)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDotaScenario {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.game)
    pub game: ::protobuf::MessageField<cmsg_dota_scenario::Game>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.teams)
    pub teams: ::std::vec::Vec<cmsg_dota_scenario::Team>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.heroes)
    pub heroes: ::std::vec::Vec<cmsg_dota_scenario::Hero>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.stock)
    pub stock: ::std::vec::Vec<cmsg_dota_scenario::Stock>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.buildings)
    pub buildings: ::std::vec::Vec<cmsg_dota_scenario::Building>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.entities)
    pub entities: ::std::vec::Vec<cmsg_dota_scenario::Entity>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.items)
    pub items: ::std::vec::Vec<cmsg_dota_scenario::Item>,
    // @@protoc_insertion_point(field:dota.CMsgDotaScenario.modifiers)
    pub modifiers: ::std::vec::Vec<cmsg_dota_scenario::Modifier>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDotaScenario {
    fn default() -> &'a CMsgDotaScenario {
        <CMsgDotaScenario as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDotaScenario {
    pub fn new() -> CMsgDotaScenario {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgDotaScenario| { &m.lobby_id },
            |m: &mut CMsgDotaScenario| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dota_scenario::Game>(
            "game",
            |m: &CMsgDotaScenario| { &m.game },
            |m: &mut CMsgDotaScenario| { &mut m.game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CMsgDotaScenario| { &m.teams },
            |m: &mut CMsgDotaScenario| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "heroes",
            |m: &CMsgDotaScenario| { &m.heroes },
            |m: &mut CMsgDotaScenario| { &mut m.heroes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stock",
            |m: &CMsgDotaScenario| { &m.stock },
            |m: &mut CMsgDotaScenario| { &mut m.stock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buildings",
            |m: &CMsgDotaScenario| { &m.buildings },
            |m: &mut CMsgDotaScenario| { &mut m.buildings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entities",
            |m: &CMsgDotaScenario| { &m.entities },
            |m: &mut CMsgDotaScenario| { &mut m.entities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgDotaScenario| { &m.items },
            |m: &mut CMsgDotaScenario| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &CMsgDotaScenario| { &m.modifiers },
            |m: &mut CMsgDotaScenario| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDotaScenario>(
            "CMsgDotaScenario",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDotaScenario {
    const NAME: &'static str = "CMsgDotaScenario";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game)?;
                },
                26 => {
                    self.teams.push(is.read_message()?);
                },
                34 => {
                    self.heroes.push(is.read_message()?);
                },
                42 => {
                    self.stock.push(is.read_message()?);
                },
                50 => {
                    self.buildings.push(is.read_message()?);
                },
                58 => {
                    self.entities.push(is.read_message()?);
                },
                66 => {
                    self.items.push(is.read_message()?);
                },
                74 => {
                    self.modifiers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.stock {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.heroes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.stock {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.buildings {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.entities {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.modifiers {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDotaScenario {
        CMsgDotaScenario::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.game.clear();
        self.teams.clear();
        self.heroes.clear();
        self.stock.clear();
        self.buildings.clear();
        self.entities.clear();
        self.items.clear();
        self.modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDotaScenario {
        static instance: CMsgDotaScenario = CMsgDotaScenario {
            lobby_id: ::std::option::Option::None,
            game: ::protobuf::MessageField::none(),
            teams: ::std::vec::Vec::new(),
            heroes: ::std::vec::Vec::new(),
            stock: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            entities: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            modifiers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDotaScenario {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDotaScenario").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDotaScenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDotaScenario {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDotaScenario`
pub mod cmsg_dota_scenario {
    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.EntityRef)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EntityRef {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.EntityRef.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.EntityRef.neutral_stash_id)
        pub neutral_stash_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.EntityRef.entity_idx)
        pub entity_idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.EntityRef.roshan)
        pub roshan: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.EntityRef.ability_name)
        pub ability_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.EntityRef.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EntityRef {
        fn default() -> &'a EntityRef {
            <EntityRef as ::protobuf::Message>::default_instance()
        }
    }

    impl EntityRef {
        pub fn new() -> EntityRef {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 neutral_stash_id = 2;

        pub fn neutral_stash_id(&self) -> i32 {
            self.neutral_stash_id.unwrap_or(0)
        }

        pub fn clear_neutral_stash_id(&mut self) {
            self.neutral_stash_id = ::std::option::Option::None;
        }

        pub fn has_neutral_stash_id(&self) -> bool {
            self.neutral_stash_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_stash_id(&mut self, v: i32) {
            self.neutral_stash_id = ::std::option::Option::Some(v);
        }

        // optional int32 entity_idx = 3;

        pub fn entity_idx(&self) -> i32 {
            self.entity_idx.unwrap_or(0)
        }

        pub fn clear_entity_idx(&mut self) {
            self.entity_idx = ::std::option::Option::None;
        }

        pub fn has_entity_idx(&self) -> bool {
            self.entity_idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_idx(&mut self, v: i32) {
            self.entity_idx = ::std::option::Option::Some(v);
        }

        // optional bool roshan = 4;

        pub fn roshan(&self) -> bool {
            self.roshan.unwrap_or(false)
        }

        pub fn clear_roshan(&mut self) {
            self.roshan = ::std::option::Option::None;
        }

        pub fn has_roshan(&self) -> bool {
            self.roshan.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan(&mut self, v: bool) {
            self.roshan = ::std::option::Option::Some(v);
        }

        // optional string ability_name = 10;

        pub fn ability_name(&self) -> &str {
            match self.ability_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ability_name(&mut self) {
            self.ability_name = ::std::option::Option::None;
        }

        pub fn has_ability_name(&self) -> bool {
            self.ability_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ability_name(&mut self, v: ::std::string::String) {
            self.ability_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ability_name(&mut self) -> &mut ::std::string::String {
            if self.ability_name.is_none() {
                self.ability_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ability_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_ability_name(&mut self) -> ::std::string::String {
            self.ability_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &EntityRef| { &m.player_id },
                |m: &mut EntityRef| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "neutral_stash_id",
                |m: &EntityRef| { &m.neutral_stash_id },
                |m: &mut EntityRef| { &mut m.neutral_stash_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_idx",
                |m: &EntityRef| { &m.entity_idx },
                |m: &mut EntityRef| { &mut m.entity_idx },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "roshan",
                |m: &EntityRef| { &m.roshan },
                |m: &mut EntityRef| { &mut m.roshan },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ability_name",
                |m: &EntityRef| { &m.ability_name },
                |m: &mut EntityRef| { &mut m.ability_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntityRef>(
                "CMsgDotaScenario.EntityRef",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EntityRef {
        const NAME: &'static str = "EntityRef";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.neutral_stash_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.entity_idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.roshan = ::std::option::Option::Some(is.read_bool()?);
                    },
                    82 => {
                        self.ability_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.neutral_stash_id {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.entity_idx {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.roshan {
                my_size += 1 + 1;
            }
            if let Some(v) = self.ability_name.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.neutral_stash_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.entity_idx {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.roshan {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.ability_name.as_ref() {
                os.write_string(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EntityRef {
            EntityRef::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.neutral_stash_id = ::std::option::Option::None;
            self.entity_idx = ::std::option::Option::None;
            self.roshan = ::std::option::Option::None;
            self.ability_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EntityRef {
            static instance: EntityRef = EntityRef {
                player_id: ::std::option::Option::None,
                neutral_stash_id: ::std::option::Option::None,
                entity_idx: ::std::option::Option::None,
                roshan: ::std::option::Option::None,
                ability_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EntityRef {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.EntityRef").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EntityRef {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EntityRef {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Game)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Game {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Game.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Game.game_mode)
        pub game_mode: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Game.clock_time)
        pub clock_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Game.internal_time)
        pub internal_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Game.roshan)
        pub roshan: ::protobuf::MessageField<super::CScenarioGame_RoshanSpawner>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Game.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Game {
        fn default() -> &'a Game {
            <Game as ::protobuf::Message>::default_instance()
        }
    }

    impl Game {
        pub fn new() -> Game {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional int32 game_mode = 2;

        pub fn game_mode(&self) -> i32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: i32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional float clock_time = 3;

        pub fn clock_time(&self) -> f32 {
            self.clock_time.unwrap_or(0.)
        }

        pub fn clear_clock_time(&mut self) {
            self.clock_time = ::std::option::Option::None;
        }

        pub fn has_clock_time(&self) -> bool {
            self.clock_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clock_time(&mut self, v: f32) {
            self.clock_time = ::std::option::Option::Some(v);
        }

        // optional float internal_time = 4;

        pub fn internal_time(&self) -> f32 {
            self.internal_time.unwrap_or(0.)
        }

        pub fn clear_internal_time(&mut self) {
            self.internal_time = ::std::option::Option::None;
        }

        pub fn has_internal_time(&self) -> bool {
            self.internal_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_time(&mut self, v: f32) {
            self.internal_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &Game| { &m.match_id },
                |m: &mut Game| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_mode",
                |m: &Game| { &m.game_mode },
                |m: &mut Game| { &mut m.game_mode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "clock_time",
                |m: &Game| { &m.clock_time },
                |m: &mut Game| { &mut m.clock_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "internal_time",
                |m: &Game| { &m.internal_time },
                |m: &mut Game| { &mut m.internal_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CScenarioGame_RoshanSpawner>(
                "roshan",
                |m: &Game| { &m.roshan },
                |m: &mut Game| { &mut m.roshan },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Game>(
                "CMsgDotaScenario.Game",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Game {
        const NAME: &'static str = "Game";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.game_mode = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.clock_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.internal_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.roshan)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_mode {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.clock_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.internal_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.roshan.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_mode {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.clock_time {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.internal_time {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.roshan.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Game {
            Game::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.game_mode = ::std::option::Option::None;
            self.clock_time = ::std::option::Option::None;
            self.internal_time = ::std::option::Option::None;
            self.roshan.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Game {
            static instance: Game = Game {
                match_id: ::std::option::Option::None,
                game_mode: ::std::option::Option::None,
                clock_time: ::std::option::Option::None,
                internal_time: ::std::option::Option::None,
                roshan: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Game {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Game").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Game {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Game {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.TeamNeutralItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamNeutralItem {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.TeamNeutralItem.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.TeamNeutralItem.consumed)
        pub consumed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.TeamNeutralItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamNeutralItem {
        fn default() -> &'a TeamNeutralItem {
            <TeamNeutralItem as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamNeutralItem {
        pub fn new() -> TeamNeutralItem {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool consumed = 2;

        pub fn consumed(&self) -> bool {
            self.consumed.unwrap_or(false)
        }

        pub fn clear_consumed(&mut self) {
            self.consumed = ::std::option::Option::None;
        }

        pub fn has_consumed(&self) -> bool {
            self.consumed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_consumed(&mut self, v: bool) {
            self.consumed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &TeamNeutralItem| { &m.name },
                |m: &mut TeamNeutralItem| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "consumed",
                |m: &TeamNeutralItem| { &m.consumed },
                |m: &mut TeamNeutralItem| { &mut m.consumed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamNeutralItem>(
                "CMsgDotaScenario.TeamNeutralItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamNeutralItem {
        const NAME: &'static str = "TeamNeutralItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.consumed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.consumed {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.consumed {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamNeutralItem {
            TeamNeutralItem::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.consumed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamNeutralItem {
            static instance: TeamNeutralItem = TeamNeutralItem {
                name: ::std::option::Option::None,
                consumed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamNeutralItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.TeamNeutralItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamNeutralItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamNeutralItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Team.team_number)
        pub team_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Team.neutral_items)
        pub neutral_items: ::std::vec::Vec<TeamNeutralItem>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Team.hero_kills)
        pub hero_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Team.tower_kills)
        pub tower_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Team.barracks_kills)
        pub barracks_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Team.glyph_cooldown)
        pub glyph_cooldown: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Team.radar_cooldown)
        pub radar_cooldown: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Team.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional int32 team_number = 1;

        pub fn team_number(&self) -> i32 {
            self.team_number.unwrap_or(0)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: i32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional int32 hero_kills = 3;

        pub fn hero_kills(&self) -> i32 {
            self.hero_kills.unwrap_or(0)
        }

        pub fn clear_hero_kills(&mut self) {
            self.hero_kills = ::std::option::Option::None;
        }

        pub fn has_hero_kills(&self) -> bool {
            self.hero_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_kills(&mut self, v: i32) {
            self.hero_kills = ::std::option::Option::Some(v);
        }

        // optional int32 tower_kills = 4;

        pub fn tower_kills(&self) -> i32 {
            self.tower_kills.unwrap_or(0)
        }

        pub fn clear_tower_kills(&mut self) {
            self.tower_kills = ::std::option::Option::None;
        }

        pub fn has_tower_kills(&self) -> bool {
            self.tower_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_kills(&mut self, v: i32) {
            self.tower_kills = ::std::option::Option::Some(v);
        }

        // optional int32 barracks_kills = 5;

        pub fn barracks_kills(&self) -> i32 {
            self.barracks_kills.unwrap_or(0)
        }

        pub fn clear_barracks_kills(&mut self) {
            self.barracks_kills = ::std::option::Option::None;
        }

        pub fn has_barracks_kills(&self) -> bool {
            self.barracks_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_barracks_kills(&mut self, v: i32) {
            self.barracks_kills = ::std::option::Option::Some(v);
        }

        // optional float glyph_cooldown = 6;

        pub fn glyph_cooldown(&self) -> f32 {
            self.glyph_cooldown.unwrap_or(0.)
        }

        pub fn clear_glyph_cooldown(&mut self) {
            self.glyph_cooldown = ::std::option::Option::None;
        }

        pub fn has_glyph_cooldown(&self) -> bool {
            self.glyph_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_glyph_cooldown(&mut self, v: f32) {
            self.glyph_cooldown = ::std::option::Option::Some(v);
        }

        // optional float radar_cooldown = 7;

        pub fn radar_cooldown(&self) -> f32 {
            self.radar_cooldown.unwrap_or(0.)
        }

        pub fn clear_radar_cooldown(&mut self) {
            self.radar_cooldown = ::std::option::Option::None;
        }

        pub fn has_radar_cooldown(&self) -> bool {
            self.radar_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radar_cooldown(&mut self, v: f32) {
            self.radar_cooldown = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_number",
                |m: &Team| { &m.team_number },
                |m: &mut Team| { &mut m.team_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "neutral_items",
                |m: &Team| { &m.neutral_items },
                |m: &mut Team| { &mut m.neutral_items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_kills",
                |m: &Team| { &m.hero_kills },
                |m: &mut Team| { &mut m.hero_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_kills",
                |m: &Team| { &m.tower_kills },
                |m: &mut Team| { &mut m.tower_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "barracks_kills",
                |m: &Team| { &m.barracks_kills },
                |m: &mut Team| { &mut m.barracks_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "glyph_cooldown",
                |m: &Team| { &m.glyph_cooldown },
                |m: &mut Team| { &mut m.glyph_cooldown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radar_cooldown",
                |m: &Team| { &m.radar_cooldown },
                |m: &mut Team| { &mut m.radar_cooldown },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Team>(
                "CMsgDotaScenario.Team",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.neutral_items.push(is.read_message()?);
                    },
                    24 => {
                        self.hero_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.tower_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.barracks_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    53 => {
                        self.glyph_cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    61 => {
                        self.radar_cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_number {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.neutral_items {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.hero_kills {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.tower_kills {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.barracks_kills {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.glyph_cooldown {
                my_size += 1 + 4;
            }
            if let Some(v) = self.radar_cooldown {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team_number {
                os.write_int32(1, v)?;
            }
            for v in &self.neutral_items {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.hero_kills {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.tower_kills {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.barracks_kills {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.glyph_cooldown {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.radar_cooldown {
                os.write_float(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.team_number = ::std::option::Option::None;
            self.neutral_items.clear();
            self.hero_kills = ::std::option::Option::None;
            self.tower_kills = ::std::option::Option::None;
            self.barracks_kills = ::std::option::Option::None;
            self.glyph_cooldown = ::std::option::Option::None;
            self.radar_cooldown = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                team_number: ::std::option::Option::None,
                neutral_items: ::std::vec::Vec::new(),
                hero_kills: ::std::option::Option::None,
                tower_kills: ::std::option::Option::None,
                barracks_kills: ::std::option::Option::None,
                glyph_cooldown: ::std::option::Option::None,
                radar_cooldown: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Team {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Team").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Team {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Team {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.HeroHeroInt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroHeroInt {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.HeroHeroInt.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.HeroHeroInt.value)
        pub value: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.HeroHeroInt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroHeroInt {
        fn default() -> &'a HeroHeroInt {
            <HeroHeroInt as ::protobuf::Message>::default_instance()
        }
    }

    impl HeroHeroInt {
        pub fn new() -> HeroHeroInt {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 value = 2;

        pub fn value(&self) -> i32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: i32) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &HeroHeroInt| { &m.player_id },
                |m: &mut HeroHeroInt| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &HeroHeroInt| { &m.value },
                |m: &mut HeroHeroInt| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroHeroInt>(
                "CMsgDotaScenario.HeroHeroInt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HeroHeroInt {
        const NAME: &'static str = "HeroHeroInt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroHeroInt {
            HeroHeroInt::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroHeroInt {
            static instance: HeroHeroInt = HeroHeroInt {
                player_id: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HeroHeroInt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.HeroHeroInt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HeroHeroInt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HeroHeroInt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.HeroHeroFloat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroHeroFloat {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.HeroHeroFloat.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.HeroHeroFloat.value)
        pub value: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.HeroHeroFloat.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroHeroFloat {
        fn default() -> &'a HeroHeroFloat {
            <HeroHeroFloat as ::protobuf::Message>::default_instance()
        }
    }

    impl HeroHeroFloat {
        pub fn new() -> HeroHeroFloat {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional float value = 2;

        pub fn value(&self) -> f32 {
            self.value.unwrap_or(0.)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: f32) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &HeroHeroFloat| { &m.player_id },
                |m: &mut HeroHeroFloat| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &HeroHeroFloat| { &m.value },
                |m: &mut HeroHeroFloat| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroHeroFloat>(
                "CMsgDotaScenario.HeroHeroFloat",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HeroHeroFloat {
        const NAME: &'static str = "HeroHeroFloat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    21 => {
                        self.value = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroHeroFloat {
            HeroHeroFloat::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroHeroFloat {
            static instance: HeroHeroFloat = HeroHeroFloat {
                player_id: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HeroHeroFloat {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.HeroHeroFloat").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HeroHeroFloat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HeroHeroFloat {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.DamageStatsByType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DamageStatsByType {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.DamageStatsByType.damage_type)
        pub damage_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.DamageStatsByType.received_pre_reduction)
        pub received_pre_reduction: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.DamageStatsByType.received_post_reduction)
        pub received_post_reduction: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.DamageStatsByType.outgoing_pre_reduction)
        pub outgoing_pre_reduction: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.DamageStatsByType.outgoing_post_reduction)
        pub outgoing_post_reduction: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.DamageStatsByType.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DamageStatsByType {
        fn default() -> &'a DamageStatsByType {
            <DamageStatsByType as ::protobuf::Message>::default_instance()
        }
    }

    impl DamageStatsByType {
        pub fn new() -> DamageStatsByType {
            ::std::default::Default::default()
        }

        // optional int32 damage_type = 1;

        pub fn damage_type(&self) -> i32 {
            self.damage_type.unwrap_or(0)
        }

        pub fn clear_damage_type(&mut self) {
            self.damage_type = ::std::option::Option::None;
        }

        pub fn has_damage_type(&self) -> bool {
            self.damage_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage_type(&mut self, v: i32) {
            self.damage_type = ::std::option::Option::Some(v);
        }

        // optional int32 received_pre_reduction = 2;

        pub fn received_pre_reduction(&self) -> i32 {
            self.received_pre_reduction.unwrap_or(0)
        }

        pub fn clear_received_pre_reduction(&mut self) {
            self.received_pre_reduction = ::std::option::Option::None;
        }

        pub fn has_received_pre_reduction(&self) -> bool {
            self.received_pre_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_received_pre_reduction(&mut self, v: i32) {
            self.received_pre_reduction = ::std::option::Option::Some(v);
        }

        // optional int32 received_post_reduction = 3;

        pub fn received_post_reduction(&self) -> i32 {
            self.received_post_reduction.unwrap_or(0)
        }

        pub fn clear_received_post_reduction(&mut self) {
            self.received_post_reduction = ::std::option::Option::None;
        }

        pub fn has_received_post_reduction(&self) -> bool {
            self.received_post_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_received_post_reduction(&mut self, v: i32) {
            self.received_post_reduction = ::std::option::Option::Some(v);
        }

        // optional int32 outgoing_pre_reduction = 4;

        pub fn outgoing_pre_reduction(&self) -> i32 {
            self.outgoing_pre_reduction.unwrap_or(0)
        }

        pub fn clear_outgoing_pre_reduction(&mut self) {
            self.outgoing_pre_reduction = ::std::option::Option::None;
        }

        pub fn has_outgoing_pre_reduction(&self) -> bool {
            self.outgoing_pre_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outgoing_pre_reduction(&mut self, v: i32) {
            self.outgoing_pre_reduction = ::std::option::Option::Some(v);
        }

        // optional int32 outgoing_post_reduction = 5;

        pub fn outgoing_post_reduction(&self) -> i32 {
            self.outgoing_post_reduction.unwrap_or(0)
        }

        pub fn clear_outgoing_post_reduction(&mut self) {
            self.outgoing_post_reduction = ::std::option::Option::None;
        }

        pub fn has_outgoing_post_reduction(&self) -> bool {
            self.outgoing_post_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outgoing_post_reduction(&mut self, v: i32) {
            self.outgoing_post_reduction = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "damage_type",
                |m: &DamageStatsByType| { &m.damage_type },
                |m: &mut DamageStatsByType| { &mut m.damage_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "received_pre_reduction",
                |m: &DamageStatsByType| { &m.received_pre_reduction },
                |m: &mut DamageStatsByType| { &mut m.received_pre_reduction },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "received_post_reduction",
                |m: &DamageStatsByType| { &m.received_post_reduction },
                |m: &mut DamageStatsByType| { &mut m.received_post_reduction },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "outgoing_pre_reduction",
                |m: &DamageStatsByType| { &m.outgoing_pre_reduction },
                |m: &mut DamageStatsByType| { &mut m.outgoing_pre_reduction },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "outgoing_post_reduction",
                |m: &DamageStatsByType| { &m.outgoing_post_reduction },
                |m: &mut DamageStatsByType| { &mut m.outgoing_post_reduction },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DamageStatsByType>(
                "CMsgDotaScenario.DamageStatsByType",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DamageStatsByType {
        const NAME: &'static str = "DamageStatsByType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.damage_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.received_pre_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.received_post_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.outgoing_pre_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.outgoing_post_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.damage_type {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.received_pre_reduction {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.received_post_reduction {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.outgoing_pre_reduction {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.outgoing_post_reduction {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.damage_type {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.received_pre_reduction {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.received_post_reduction {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.outgoing_pre_reduction {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.outgoing_post_reduction {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DamageStatsByType {
            DamageStatsByType::new()
        }

        fn clear(&mut self) {
            self.damage_type = ::std::option::Option::None;
            self.received_pre_reduction = ::std::option::Option::None;
            self.received_post_reduction = ::std::option::Option::None;
            self.outgoing_pre_reduction = ::std::option::Option::None;
            self.outgoing_post_reduction = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DamageStatsByType {
            static instance: DamageStatsByType = DamageStatsByType {
                damage_type: ::std::option::Option::None,
                received_pre_reduction: ::std::option::Option::None,
                received_post_reduction: ::std::option::Option::None,
                outgoing_pre_reduction: ::std::option::Option::None,
                outgoing_post_reduction: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DamageStatsByType {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.DamageStatsByType").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DamageStatsByType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DamageStatsByType {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.HeroAbility)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroAbility {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.HeroAbility.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.HeroAbility.level)
        pub level: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.HeroAbility.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroAbility {
        fn default() -> &'a HeroAbility {
            <HeroAbility as ::protobuf::Message>::default_instance()
        }
    }

    impl HeroAbility {
        pub fn new() -> HeroAbility {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 level = 2;

        pub fn level(&self) -> i32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: i32) {
            self.level = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &HeroAbility| { &m.name },
                |m: &mut HeroAbility| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &HeroAbility| { &m.level },
                |m: &mut HeroAbility| { &mut m.level },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroAbility>(
                "CMsgDotaScenario.HeroAbility",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HeroAbility {
        const NAME: &'static str = "HeroAbility";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.level {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroAbility {
            HeroAbility::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroAbility {
            static instance: HeroAbility = HeroAbility {
                name: ::std::option::Option::None,
                level: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HeroAbility {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.HeroAbility").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HeroAbility {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HeroAbility {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Hero)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Hero {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.team_id)
        pub team_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.hero)
        pub hero: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.total_xp)
        pub total_xp: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.bkb_charges_used)
        pub bkb_charges_used: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.aeon_charges_used)
        pub aeon_charges_used: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.reliable_gold)
        pub reliable_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.unreliable_gold)
        pub unreliable_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.total_earned_gold)
        pub total_earned_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.shared_gold)
        pub shared_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.hero_kill_gold)
        pub hero_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.creep_kill_gold)
        pub creep_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.neutral_kill_gold)
        pub neutral_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.courier_gold)
        pub courier_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.bounty_gold)
        pub bounty_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.roshan_gold)
        pub roshan_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.building_gold)
        pub building_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.other_gold)
        pub other_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.income_gold)
        pub income_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.ward_kill_gold)
        pub ward_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.ability_gold)
        pub ability_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.denies)
        pub denies: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.last_hits)
        pub last_hits: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.last_hit_streak)
        pub last_hit_streak: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.last_hit_multikill)
        pub last_hit_multikill: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.nearby_creep_death_count)
        pub nearby_creep_death_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.claimed_deny_count)
        pub claimed_deny_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.claimed_miss_count)
        pub claimed_miss_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.miss_count)
        pub miss_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.buyback_cooldown_time)
        pub buyback_cooldown_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.buyback_gold_limit_time)
        pub buyback_gold_limit_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.stun_duration)
        pub stun_duration: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.healing)
        pub healing: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.tower_kills)
        pub tower_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.roshan_kills)
        pub roshan_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.observer_wards_placed)
        pub observer_wards_placed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.sentry_wards_placed)
        pub sentry_wards_placed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.creeps_stacked)
        pub creeps_stacked: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.camps_stacked)
        pub camps_stacked: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.rune_pickups)
        pub rune_pickups: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.gold_spent_on_support)
        pub gold_spent_on_support: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.hero_damage)
        pub hero_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.wards_purchased)
        pub wards_purchased: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.wards_destroyed)
        pub wards_destroyed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.gold_spent_on_consumables)
        pub gold_spent_on_consumables: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.gold_spent_on_items)
        pub gold_spent_on_items: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.gold_spent_on_buybacks)
        pub gold_spent_on_buybacks: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.gold_lost_to_death)
        pub gold_lost_to_death: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.kills)
        pub kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.assists)
        pub assists: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.deaths)
        pub deaths: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.kill_streak)
        pub kill_streak: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.respawn_seconds)
        pub respawn_seconds: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.last_buyback_time)
        pub last_buyback_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.first_blood_claimed)
        pub first_blood_claimed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.first_blood_given)
        pub first_blood_given: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.bounty_runes)
        pub bounty_runes: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.outposts_captured)
        pub outposts_captured: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.position)
        pub position: ::protobuf::MessageField<super::CScenario_Position>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.enemy_kills)
        pub enemy_kills: ::std::vec::Vec<HeroHeroInt>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.damage_stats)
        pub damage_stats: ::std::vec::Vec<DamageStatsByType>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Hero.abilities)
        pub abilities: ::std::vec::Vec<HeroAbility>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Hero.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Hero {
        fn default() -> &'a Hero {
            <Hero as ::protobuf::Message>::default_instance()
        }
    }

    impl Hero {
        pub fn new() -> Hero {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional int32 player_id = 2;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 team_id = 3;

        pub fn team_id(&self) -> i32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: i32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string hero = 4;

        pub fn hero(&self) -> &str {
            match self.hero.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: ::std::string::String) {
            self.hero = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero(&mut self) -> &mut ::std::string::String {
            if self.hero.is_none() {
                self.hero = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero(&mut self) -> ::std::string::String {
            self.hero.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 total_xp = 5;

        pub fn total_xp(&self) -> i32 {
            self.total_xp.unwrap_or(0)
        }

        pub fn clear_total_xp(&mut self) {
            self.total_xp = ::std::option::Option::None;
        }

        pub fn has_total_xp(&self) -> bool {
            self.total_xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_xp(&mut self, v: i32) {
            self.total_xp = ::std::option::Option::Some(v);
        }

        // optional int32 bkb_charges_used = 6;

        pub fn bkb_charges_used(&self) -> i32 {
            self.bkb_charges_used.unwrap_or(0)
        }

        pub fn clear_bkb_charges_used(&mut self) {
            self.bkb_charges_used = ::std::option::Option::None;
        }

        pub fn has_bkb_charges_used(&self) -> bool {
            self.bkb_charges_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bkb_charges_used(&mut self, v: i32) {
            self.bkb_charges_used = ::std::option::Option::Some(v);
        }

        // optional int32 aeon_charges_used = 7;

        pub fn aeon_charges_used(&self) -> i32 {
            self.aeon_charges_used.unwrap_or(0)
        }

        pub fn clear_aeon_charges_used(&mut self) {
            self.aeon_charges_used = ::std::option::Option::None;
        }

        pub fn has_aeon_charges_used(&self) -> bool {
            self.aeon_charges_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_aeon_charges_used(&mut self, v: i32) {
            self.aeon_charges_used = ::std::option::Option::Some(v);
        }

        // optional int32 reliable_gold = 8;

        pub fn reliable_gold(&self) -> i32 {
            self.reliable_gold.unwrap_or(0)
        }

        pub fn clear_reliable_gold(&mut self) {
            self.reliable_gold = ::std::option::Option::None;
        }

        pub fn has_reliable_gold(&self) -> bool {
            self.reliable_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reliable_gold(&mut self, v: i32) {
            self.reliable_gold = ::std::option::Option::Some(v);
        }

        // optional int32 unreliable_gold = 9;

        pub fn unreliable_gold(&self) -> i32 {
            self.unreliable_gold.unwrap_or(0)
        }

        pub fn clear_unreliable_gold(&mut self) {
            self.unreliable_gold = ::std::option::Option::None;
        }

        pub fn has_unreliable_gold(&self) -> bool {
            self.unreliable_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unreliable_gold(&mut self, v: i32) {
            self.unreliable_gold = ::std::option::Option::Some(v);
        }

        // optional int32 total_earned_gold = 10;

        pub fn total_earned_gold(&self) -> i32 {
            self.total_earned_gold.unwrap_or(0)
        }

        pub fn clear_total_earned_gold(&mut self) {
            self.total_earned_gold = ::std::option::Option::None;
        }

        pub fn has_total_earned_gold(&self) -> bool {
            self.total_earned_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_earned_gold(&mut self, v: i32) {
            self.total_earned_gold = ::std::option::Option::Some(v);
        }

        // optional int32 shared_gold = 11;

        pub fn shared_gold(&self) -> i32 {
            self.shared_gold.unwrap_or(0)
        }

        pub fn clear_shared_gold(&mut self) {
            self.shared_gold = ::std::option::Option::None;
        }

        pub fn has_shared_gold(&self) -> bool {
            self.shared_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shared_gold(&mut self, v: i32) {
            self.shared_gold = ::std::option::Option::Some(v);
        }

        // optional int32 hero_kill_gold = 12;

        pub fn hero_kill_gold(&self) -> i32 {
            self.hero_kill_gold.unwrap_or(0)
        }

        pub fn clear_hero_kill_gold(&mut self) {
            self.hero_kill_gold = ::std::option::Option::None;
        }

        pub fn has_hero_kill_gold(&self) -> bool {
            self.hero_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_kill_gold(&mut self, v: i32) {
            self.hero_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 creep_kill_gold = 13;

        pub fn creep_kill_gold(&self) -> i32 {
            self.creep_kill_gold.unwrap_or(0)
        }

        pub fn clear_creep_kill_gold(&mut self) {
            self.creep_kill_gold = ::std::option::Option::None;
        }

        pub fn has_creep_kill_gold(&self) -> bool {
            self.creep_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_kill_gold(&mut self, v: i32) {
            self.creep_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 neutral_kill_gold = 14;

        pub fn neutral_kill_gold(&self) -> i32 {
            self.neutral_kill_gold.unwrap_or(0)
        }

        pub fn clear_neutral_kill_gold(&mut self) {
            self.neutral_kill_gold = ::std::option::Option::None;
        }

        pub fn has_neutral_kill_gold(&self) -> bool {
            self.neutral_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_kill_gold(&mut self, v: i32) {
            self.neutral_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 courier_gold = 15;

        pub fn courier_gold(&self) -> i32 {
            self.courier_gold.unwrap_or(0)
        }

        pub fn clear_courier_gold(&mut self) {
            self.courier_gold = ::std::option::Option::None;
        }

        pub fn has_courier_gold(&self) -> bool {
            self.courier_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_courier_gold(&mut self, v: i32) {
            self.courier_gold = ::std::option::Option::Some(v);
        }

        // optional int32 bounty_gold = 16;

        pub fn bounty_gold(&self) -> i32 {
            self.bounty_gold.unwrap_or(0)
        }

        pub fn clear_bounty_gold(&mut self) {
            self.bounty_gold = ::std::option::Option::None;
        }

        pub fn has_bounty_gold(&self) -> bool {
            self.bounty_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bounty_gold(&mut self, v: i32) {
            self.bounty_gold = ::std::option::Option::Some(v);
        }

        // optional int32 roshan_gold = 17;

        pub fn roshan_gold(&self) -> i32 {
            self.roshan_gold.unwrap_or(0)
        }

        pub fn clear_roshan_gold(&mut self) {
            self.roshan_gold = ::std::option::Option::None;
        }

        pub fn has_roshan_gold(&self) -> bool {
            self.roshan_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan_gold(&mut self, v: i32) {
            self.roshan_gold = ::std::option::Option::Some(v);
        }

        // optional int32 building_gold = 18;

        pub fn building_gold(&self) -> i32 {
            self.building_gold.unwrap_or(0)
        }

        pub fn clear_building_gold(&mut self) {
            self.building_gold = ::std::option::Option::None;
        }

        pub fn has_building_gold(&self) -> bool {
            self.building_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_building_gold(&mut self, v: i32) {
            self.building_gold = ::std::option::Option::Some(v);
        }

        // optional int32 other_gold = 19;

        pub fn other_gold(&self) -> i32 {
            self.other_gold.unwrap_or(0)
        }

        pub fn clear_other_gold(&mut self) {
            self.other_gold = ::std::option::Option::None;
        }

        pub fn has_other_gold(&self) -> bool {
            self.other_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_other_gold(&mut self, v: i32) {
            self.other_gold = ::std::option::Option::Some(v);
        }

        // optional int32 income_gold = 26;

        pub fn income_gold(&self) -> i32 {
            self.income_gold.unwrap_or(0)
        }

        pub fn clear_income_gold(&mut self) {
            self.income_gold = ::std::option::Option::None;
        }

        pub fn has_income_gold(&self) -> bool {
            self.income_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_income_gold(&mut self, v: i32) {
            self.income_gold = ::std::option::Option::Some(v);
        }

        // optional int32 ward_kill_gold = 27;

        pub fn ward_kill_gold(&self) -> i32 {
            self.ward_kill_gold.unwrap_or(0)
        }

        pub fn clear_ward_kill_gold(&mut self) {
            self.ward_kill_gold = ::std::option::Option::None;
        }

        pub fn has_ward_kill_gold(&self) -> bool {
            self.ward_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ward_kill_gold(&mut self, v: i32) {
            self.ward_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 ability_gold = 28;

        pub fn ability_gold(&self) -> i32 {
            self.ability_gold.unwrap_or(0)
        }

        pub fn clear_ability_gold(&mut self) {
            self.ability_gold = ::std::option::Option::None;
        }

        pub fn has_ability_gold(&self) -> bool {
            self.ability_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ability_gold(&mut self, v: i32) {
            self.ability_gold = ::std::option::Option::Some(v);
        }

        // optional int32 denies = 29;

        pub fn denies(&self) -> i32 {
            self.denies.unwrap_or(0)
        }

        pub fn clear_denies(&mut self) {
            self.denies = ::std::option::Option::None;
        }

        pub fn has_denies(&self) -> bool {
            self.denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies(&mut self, v: i32) {
            self.denies = ::std::option::Option::Some(v);
        }

        // optional int32 last_hits = 30;

        pub fn last_hits(&self) -> i32 {
            self.last_hits.unwrap_or(0)
        }

        pub fn clear_last_hits(&mut self) {
            self.last_hits = ::std::option::Option::None;
        }

        pub fn has_last_hits(&self) -> bool {
            self.last_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hits(&mut self, v: i32) {
            self.last_hits = ::std::option::Option::Some(v);
        }

        // optional int32 last_hit_streak = 31;

        pub fn last_hit_streak(&self) -> i32 {
            self.last_hit_streak.unwrap_or(0)
        }

        pub fn clear_last_hit_streak(&mut self) {
            self.last_hit_streak = ::std::option::Option::None;
        }

        pub fn has_last_hit_streak(&self) -> bool {
            self.last_hit_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hit_streak(&mut self, v: i32) {
            self.last_hit_streak = ::std::option::Option::Some(v);
        }

        // optional int32 last_hit_multikill = 32;

        pub fn last_hit_multikill(&self) -> i32 {
            self.last_hit_multikill.unwrap_or(0)
        }

        pub fn clear_last_hit_multikill(&mut self) {
            self.last_hit_multikill = ::std::option::Option::None;
        }

        pub fn has_last_hit_multikill(&self) -> bool {
            self.last_hit_multikill.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hit_multikill(&mut self, v: i32) {
            self.last_hit_multikill = ::std::option::Option::Some(v);
        }

        // optional int32 nearby_creep_death_count = 33;

        pub fn nearby_creep_death_count(&self) -> i32 {
            self.nearby_creep_death_count.unwrap_or(0)
        }

        pub fn clear_nearby_creep_death_count(&mut self) {
            self.nearby_creep_death_count = ::std::option::Option::None;
        }

        pub fn has_nearby_creep_death_count(&self) -> bool {
            self.nearby_creep_death_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nearby_creep_death_count(&mut self, v: i32) {
            self.nearby_creep_death_count = ::std::option::Option::Some(v);
        }

        // optional int32 claimed_deny_count = 34;

        pub fn claimed_deny_count(&self) -> i32 {
            self.claimed_deny_count.unwrap_or(0)
        }

        pub fn clear_claimed_deny_count(&mut self) {
            self.claimed_deny_count = ::std::option::Option::None;
        }

        pub fn has_claimed_deny_count(&self) -> bool {
            self.claimed_deny_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_deny_count(&mut self, v: i32) {
            self.claimed_deny_count = ::std::option::Option::Some(v);
        }

        // optional int32 claimed_miss_count = 35;

        pub fn claimed_miss_count(&self) -> i32 {
            self.claimed_miss_count.unwrap_or(0)
        }

        pub fn clear_claimed_miss_count(&mut self) {
            self.claimed_miss_count = ::std::option::Option::None;
        }

        pub fn has_claimed_miss_count(&self) -> bool {
            self.claimed_miss_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_miss_count(&mut self, v: i32) {
            self.claimed_miss_count = ::std::option::Option::Some(v);
        }

        // optional int32 miss_count = 36;

        pub fn miss_count(&self) -> i32 {
            self.miss_count.unwrap_or(0)
        }

        pub fn clear_miss_count(&mut self) {
            self.miss_count = ::std::option::Option::None;
        }

        pub fn has_miss_count(&self) -> bool {
            self.miss_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_miss_count(&mut self, v: i32) {
            self.miss_count = ::std::option::Option::Some(v);
        }

        // optional float buyback_cooldown_time = 40;

        pub fn buyback_cooldown_time(&self) -> f32 {
            self.buyback_cooldown_time.unwrap_or(0.)
        }

        pub fn clear_buyback_cooldown_time(&mut self) {
            self.buyback_cooldown_time = ::std::option::Option::None;
        }

        pub fn has_buyback_cooldown_time(&self) -> bool {
            self.buyback_cooldown_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buyback_cooldown_time(&mut self, v: f32) {
            self.buyback_cooldown_time = ::std::option::Option::Some(v);
        }

        // optional float buyback_gold_limit_time = 41;

        pub fn buyback_gold_limit_time(&self) -> f32 {
            self.buyback_gold_limit_time.unwrap_or(0.)
        }

        pub fn clear_buyback_gold_limit_time(&mut self) {
            self.buyback_gold_limit_time = ::std::option::Option::None;
        }

        pub fn has_buyback_gold_limit_time(&self) -> bool {
            self.buyback_gold_limit_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buyback_gold_limit_time(&mut self, v: f32) {
            self.buyback_gold_limit_time = ::std::option::Option::Some(v);
        }

        // optional float stun_duration = 44;

        pub fn stun_duration(&self) -> f32 {
            self.stun_duration.unwrap_or(0.)
        }

        pub fn clear_stun_duration(&mut self) {
            self.stun_duration = ::std::option::Option::None;
        }

        pub fn has_stun_duration(&self) -> bool {
            self.stun_duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stun_duration(&mut self, v: f32) {
            self.stun_duration = ::std::option::Option::Some(v);
        }

        // optional float healing = 45;

        pub fn healing(&self) -> f32 {
            self.healing.unwrap_or(0.)
        }

        pub fn clear_healing(&mut self) {
            self.healing = ::std::option::Option::None;
        }

        pub fn has_healing(&self) -> bool {
            self.healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healing(&mut self, v: f32) {
            self.healing = ::std::option::Option::Some(v);
        }

        // optional int32 tower_kills = 46;

        pub fn tower_kills(&self) -> i32 {
            self.tower_kills.unwrap_or(0)
        }

        pub fn clear_tower_kills(&mut self) {
            self.tower_kills = ::std::option::Option::None;
        }

        pub fn has_tower_kills(&self) -> bool {
            self.tower_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_kills(&mut self, v: i32) {
            self.tower_kills = ::std::option::Option::Some(v);
        }

        // optional int32 roshan_kills = 47;

        pub fn roshan_kills(&self) -> i32 {
            self.roshan_kills.unwrap_or(0)
        }

        pub fn clear_roshan_kills(&mut self) {
            self.roshan_kills = ::std::option::Option::None;
        }

        pub fn has_roshan_kills(&self) -> bool {
            self.roshan_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan_kills(&mut self, v: i32) {
            self.roshan_kills = ::std::option::Option::Some(v);
        }

        // optional int32 observer_wards_placed = 48;

        pub fn observer_wards_placed(&self) -> i32 {
            self.observer_wards_placed.unwrap_or(0)
        }

        pub fn clear_observer_wards_placed(&mut self) {
            self.observer_wards_placed = ::std::option::Option::None;
        }

        pub fn has_observer_wards_placed(&self) -> bool {
            self.observer_wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_observer_wards_placed(&mut self, v: i32) {
            self.observer_wards_placed = ::std::option::Option::Some(v);
        }

        // optional int32 sentry_wards_placed = 49;

        pub fn sentry_wards_placed(&self) -> i32 {
            self.sentry_wards_placed.unwrap_or(0)
        }

        pub fn clear_sentry_wards_placed(&mut self) {
            self.sentry_wards_placed = ::std::option::Option::None;
        }

        pub fn has_sentry_wards_placed(&self) -> bool {
            self.sentry_wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sentry_wards_placed(&mut self, v: i32) {
            self.sentry_wards_placed = ::std::option::Option::Some(v);
        }

        // optional int32 creeps_stacked = 50;

        pub fn creeps_stacked(&self) -> i32 {
            self.creeps_stacked.unwrap_or(0)
        }

        pub fn clear_creeps_stacked(&mut self) {
            self.creeps_stacked = ::std::option::Option::None;
        }

        pub fn has_creeps_stacked(&self) -> bool {
            self.creeps_stacked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creeps_stacked(&mut self, v: i32) {
            self.creeps_stacked = ::std::option::Option::Some(v);
        }

        // optional int32 camps_stacked = 51;

        pub fn camps_stacked(&self) -> i32 {
            self.camps_stacked.unwrap_or(0)
        }

        pub fn clear_camps_stacked(&mut self) {
            self.camps_stacked = ::std::option::Option::None;
        }

        pub fn has_camps_stacked(&self) -> bool {
            self.camps_stacked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_camps_stacked(&mut self, v: i32) {
            self.camps_stacked = ::std::option::Option::Some(v);
        }

        // optional int32 rune_pickups = 52;

        pub fn rune_pickups(&self) -> i32 {
            self.rune_pickups.unwrap_or(0)
        }

        pub fn clear_rune_pickups(&mut self) {
            self.rune_pickups = ::std::option::Option::None;
        }

        pub fn has_rune_pickups(&self) -> bool {
            self.rune_pickups.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rune_pickups(&mut self, v: i32) {
            self.rune_pickups = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_support = 53;

        pub fn gold_spent_on_support(&self) -> i32 {
            self.gold_spent_on_support.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_support(&mut self) {
            self.gold_spent_on_support = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_support(&self) -> bool {
            self.gold_spent_on_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_support(&mut self, v: i32) {
            self.gold_spent_on_support = ::std::option::Option::Some(v);
        }

        // optional int32 hero_damage = 54;

        pub fn hero_damage(&self) -> i32 {
            self.hero_damage.unwrap_or(0)
        }

        pub fn clear_hero_damage(&mut self) {
            self.hero_damage = ::std::option::Option::None;
        }

        pub fn has_hero_damage(&self) -> bool {
            self.hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_damage(&mut self, v: i32) {
            self.hero_damage = ::std::option::Option::Some(v);
        }

        // optional int32 wards_purchased = 55;

        pub fn wards_purchased(&self) -> i32 {
            self.wards_purchased.unwrap_or(0)
        }

        pub fn clear_wards_purchased(&mut self) {
            self.wards_purchased = ::std::option::Option::None;
        }

        pub fn has_wards_purchased(&self) -> bool {
            self.wards_purchased.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_purchased(&mut self, v: i32) {
            self.wards_purchased = ::std::option::Option::Some(v);
        }

        // optional int32 wards_destroyed = 56;

        pub fn wards_destroyed(&self) -> i32 {
            self.wards_destroyed.unwrap_or(0)
        }

        pub fn clear_wards_destroyed(&mut self) {
            self.wards_destroyed = ::std::option::Option::None;
        }

        pub fn has_wards_destroyed(&self) -> bool {
            self.wards_destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_destroyed(&mut self, v: i32) {
            self.wards_destroyed = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_consumables = 58;

        pub fn gold_spent_on_consumables(&self) -> i32 {
            self.gold_spent_on_consumables.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_consumables(&mut self) {
            self.gold_spent_on_consumables = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_consumables(&self) -> bool {
            self.gold_spent_on_consumables.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_consumables(&mut self, v: i32) {
            self.gold_spent_on_consumables = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_items = 59;

        pub fn gold_spent_on_items(&self) -> i32 {
            self.gold_spent_on_items.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_items(&mut self) {
            self.gold_spent_on_items = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_items(&self) -> bool {
            self.gold_spent_on_items.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_items(&mut self, v: i32) {
            self.gold_spent_on_items = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_buybacks = 60;

        pub fn gold_spent_on_buybacks(&self) -> i32 {
            self.gold_spent_on_buybacks.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_buybacks(&mut self) {
            self.gold_spent_on_buybacks = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_buybacks(&self) -> bool {
            self.gold_spent_on_buybacks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_buybacks(&mut self, v: i32) {
            self.gold_spent_on_buybacks = ::std::option::Option::Some(v);
        }

        // optional int32 gold_lost_to_death = 61;

        pub fn gold_lost_to_death(&self) -> i32 {
            self.gold_lost_to_death.unwrap_or(0)
        }

        pub fn clear_gold_lost_to_death(&mut self) {
            self.gold_lost_to_death = ::std::option::Option::None;
        }

        pub fn has_gold_lost_to_death(&self) -> bool {
            self.gold_lost_to_death.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_lost_to_death(&mut self, v: i32) {
            self.gold_lost_to_death = ::std::option::Option::Some(v);
        }

        // optional int32 kills = 62;

        pub fn kills(&self) -> i32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: i32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional int32 assists = 63;

        pub fn assists(&self) -> i32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: i32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional int32 deaths = 64;

        pub fn deaths(&self) -> i32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: i32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional int32 kill_streak = 65;

        pub fn kill_streak(&self) -> i32 {
            self.kill_streak.unwrap_or(0)
        }

        pub fn clear_kill_streak(&mut self) {
            self.kill_streak = ::std::option::Option::None;
        }

        pub fn has_kill_streak(&self) -> bool {
            self.kill_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_streak(&mut self, v: i32) {
            self.kill_streak = ::std::option::Option::Some(v);
        }

        // optional int32 respawn_seconds = 68;

        pub fn respawn_seconds(&self) -> i32 {
            self.respawn_seconds.unwrap_or(0)
        }

        pub fn clear_respawn_seconds(&mut self) {
            self.respawn_seconds = ::std::option::Option::None;
        }

        pub fn has_respawn_seconds(&self) -> bool {
            self.respawn_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_seconds(&mut self, v: i32) {
            self.respawn_seconds = ::std::option::Option::Some(v);
        }

        // optional int32 last_buyback_time = 69;

        pub fn last_buyback_time(&self) -> i32 {
            self.last_buyback_time.unwrap_or(0)
        }

        pub fn clear_last_buyback_time(&mut self) {
            self.last_buyback_time = ::std::option::Option::None;
        }

        pub fn has_last_buyback_time(&self) -> bool {
            self.last_buyback_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_buyback_time(&mut self, v: i32) {
            self.last_buyback_time = ::std::option::Option::Some(v);
        }

        // optional bool first_blood_claimed = 71;

        pub fn first_blood_claimed(&self) -> bool {
            self.first_blood_claimed.unwrap_or(false)
        }

        pub fn clear_first_blood_claimed(&mut self) {
            self.first_blood_claimed = ::std::option::Option::None;
        }

        pub fn has_first_blood_claimed(&self) -> bool {
            self.first_blood_claimed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_blood_claimed(&mut self, v: bool) {
            self.first_blood_claimed = ::std::option::Option::Some(v);
        }

        // optional bool first_blood_given = 72;

        pub fn first_blood_given(&self) -> bool {
            self.first_blood_given.unwrap_or(false)
        }

        pub fn clear_first_blood_given(&mut self) {
            self.first_blood_given = ::std::option::Option::None;
        }

        pub fn has_first_blood_given(&self) -> bool {
            self.first_blood_given.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_blood_given(&mut self, v: bool) {
            self.first_blood_given = ::std::option::Option::Some(v);
        }

        // optional int32 bounty_runes = 73;

        pub fn bounty_runes(&self) -> i32 {
            self.bounty_runes.unwrap_or(0)
        }

        pub fn clear_bounty_runes(&mut self) {
            self.bounty_runes = ::std::option::Option::None;
        }

        pub fn has_bounty_runes(&self) -> bool {
            self.bounty_runes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bounty_runes(&mut self, v: i32) {
            self.bounty_runes = ::std::option::Option::Some(v);
        }

        // optional int32 outposts_captured = 74;

        pub fn outposts_captured(&self) -> i32 {
            self.outposts_captured.unwrap_or(0)
        }

        pub fn clear_outposts_captured(&mut self) {
            self.outposts_captured = ::std::option::Option::None;
        }

        pub fn has_outposts_captured(&self) -> bool {
            self.outposts_captured.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outposts_captured(&mut self, v: i32) {
            self.outposts_captured = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(63);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Hero| { &m.steam_id },
                |m: &mut Hero| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &Hero| { &m.player_id },
                |m: &mut Hero| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Hero| { &m.team_id },
                |m: &mut Hero| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero",
                |m: &Hero| { &m.hero },
                |m: &mut Hero| { &mut m.hero },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_xp",
                |m: &Hero| { &m.total_xp },
                |m: &mut Hero| { &mut m.total_xp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bkb_charges_used",
                |m: &Hero| { &m.bkb_charges_used },
                |m: &mut Hero| { &mut m.bkb_charges_used },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "aeon_charges_used",
                |m: &Hero| { &m.aeon_charges_used },
                |m: &mut Hero| { &mut m.aeon_charges_used },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reliable_gold",
                |m: &Hero| { &m.reliable_gold },
                |m: &mut Hero| { &mut m.reliable_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unreliable_gold",
                |m: &Hero| { &m.unreliable_gold },
                |m: &mut Hero| { &mut m.unreliable_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_earned_gold",
                |m: &Hero| { &m.total_earned_gold },
                |m: &mut Hero| { &mut m.total_earned_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "shared_gold",
                |m: &Hero| { &m.shared_gold },
                |m: &mut Hero| { &mut m.shared_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_kill_gold",
                |m: &Hero| { &m.hero_kill_gold },
                |m: &mut Hero| { &mut m.hero_kill_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creep_kill_gold",
                |m: &Hero| { &m.creep_kill_gold },
                |m: &mut Hero| { &mut m.creep_kill_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "neutral_kill_gold",
                |m: &Hero| { &m.neutral_kill_gold },
                |m: &mut Hero| { &mut m.neutral_kill_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "courier_gold",
                |m: &Hero| { &m.courier_gold },
                |m: &mut Hero| { &mut m.courier_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bounty_gold",
                |m: &Hero| { &m.bounty_gold },
                |m: &mut Hero| { &mut m.bounty_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "roshan_gold",
                |m: &Hero| { &m.roshan_gold },
                |m: &mut Hero| { &mut m.roshan_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "building_gold",
                |m: &Hero| { &m.building_gold },
                |m: &mut Hero| { &mut m.building_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "other_gold",
                |m: &Hero| { &m.other_gold },
                |m: &mut Hero| { &mut m.other_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "income_gold",
                |m: &Hero| { &m.income_gold },
                |m: &mut Hero| { &mut m.income_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ward_kill_gold",
                |m: &Hero| { &m.ward_kill_gold },
                |m: &mut Hero| { &mut m.ward_kill_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ability_gold",
                |m: &Hero| { &m.ability_gold },
                |m: &mut Hero| { &mut m.ability_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "denies",
                |m: &Hero| { &m.denies },
                |m: &mut Hero| { &mut m.denies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_hits",
                |m: &Hero| { &m.last_hits },
                |m: &mut Hero| { &mut m.last_hits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_hit_streak",
                |m: &Hero| { &m.last_hit_streak },
                |m: &mut Hero| { &mut m.last_hit_streak },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_hit_multikill",
                |m: &Hero| { &m.last_hit_multikill },
                |m: &mut Hero| { &mut m.last_hit_multikill },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "nearby_creep_death_count",
                |m: &Hero| { &m.nearby_creep_death_count },
                |m: &mut Hero| { &mut m.nearby_creep_death_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "claimed_deny_count",
                |m: &Hero| { &m.claimed_deny_count },
                |m: &mut Hero| { &mut m.claimed_deny_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "claimed_miss_count",
                |m: &Hero| { &m.claimed_miss_count },
                |m: &mut Hero| { &mut m.claimed_miss_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "miss_count",
                |m: &Hero| { &m.miss_count },
                |m: &mut Hero| { &mut m.miss_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "buyback_cooldown_time",
                |m: &Hero| { &m.buyback_cooldown_time },
                |m: &mut Hero| { &mut m.buyback_cooldown_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "buyback_gold_limit_time",
                |m: &Hero| { &m.buyback_gold_limit_time },
                |m: &mut Hero| { &mut m.buyback_gold_limit_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stun_duration",
                |m: &Hero| { &m.stun_duration },
                |m: &mut Hero| { &mut m.stun_duration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "healing",
                |m: &Hero| { &m.healing },
                |m: &mut Hero| { &mut m.healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_kills",
                |m: &Hero| { &m.tower_kills },
                |m: &mut Hero| { &mut m.tower_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "roshan_kills",
                |m: &Hero| { &m.roshan_kills },
                |m: &mut Hero| { &mut m.roshan_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "observer_wards_placed",
                |m: &Hero| { &m.observer_wards_placed },
                |m: &mut Hero| { &mut m.observer_wards_placed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sentry_wards_placed",
                |m: &Hero| { &m.sentry_wards_placed },
                |m: &mut Hero| { &mut m.sentry_wards_placed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "creeps_stacked",
                |m: &Hero| { &m.creeps_stacked },
                |m: &mut Hero| { &mut m.creeps_stacked },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "camps_stacked",
                |m: &Hero| { &m.camps_stacked },
                |m: &mut Hero| { &mut m.camps_stacked },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rune_pickups",
                |m: &Hero| { &m.rune_pickups },
                |m: &mut Hero| { &mut m.rune_pickups },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_spent_on_support",
                |m: &Hero| { &m.gold_spent_on_support },
                |m: &mut Hero| { &mut m.gold_spent_on_support },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_damage",
                |m: &Hero| { &m.hero_damage },
                |m: &mut Hero| { &mut m.hero_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wards_purchased",
                |m: &Hero| { &m.wards_purchased },
                |m: &mut Hero| { &mut m.wards_purchased },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wards_destroyed",
                |m: &Hero| { &m.wards_destroyed },
                |m: &mut Hero| { &mut m.wards_destroyed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_spent_on_consumables",
                |m: &Hero| { &m.gold_spent_on_consumables },
                |m: &mut Hero| { &mut m.gold_spent_on_consumables },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_spent_on_items",
                |m: &Hero| { &m.gold_spent_on_items },
                |m: &mut Hero| { &mut m.gold_spent_on_items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_spent_on_buybacks",
                |m: &Hero| { &m.gold_spent_on_buybacks },
                |m: &mut Hero| { &mut m.gold_spent_on_buybacks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_lost_to_death",
                |m: &Hero| { &m.gold_lost_to_death },
                |m: &mut Hero| { &mut m.gold_lost_to_death },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &Hero| { &m.kills },
                |m: &mut Hero| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists",
                |m: &Hero| { &m.assists },
                |m: &mut Hero| { &mut m.assists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &Hero| { &m.deaths },
                |m: &mut Hero| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kill_streak",
                |m: &Hero| { &m.kill_streak },
                |m: &mut Hero| { &mut m.kill_streak },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "respawn_seconds",
                |m: &Hero| { &m.respawn_seconds },
                |m: &mut Hero| { &mut m.respawn_seconds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_buyback_time",
                |m: &Hero| { &m.last_buyback_time },
                |m: &mut Hero| { &mut m.last_buyback_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "first_blood_claimed",
                |m: &Hero| { &m.first_blood_claimed },
                |m: &mut Hero| { &mut m.first_blood_claimed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "first_blood_given",
                |m: &Hero| { &m.first_blood_given },
                |m: &mut Hero| { &mut m.first_blood_given },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bounty_runes",
                |m: &Hero| { &m.bounty_runes },
                |m: &mut Hero| { &mut m.bounty_runes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "outposts_captured",
                |m: &Hero| { &m.outposts_captured },
                |m: &mut Hero| { &mut m.outposts_captured },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CScenario_Position>(
                "position",
                |m: &Hero| { &m.position },
                |m: &mut Hero| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "enemy_kills",
                |m: &Hero| { &m.enemy_kills },
                |m: &mut Hero| { &mut m.enemy_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "damage_stats",
                |m: &Hero| { &m.damage_stats },
                |m: &mut Hero| { &mut m.damage_stats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "abilities",
                |m: &Hero| { &m.abilities },
                |m: &mut Hero| { &mut m.abilities },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hero>(
                "CMsgDotaScenario.Hero",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Hero {
        const NAME: &'static str = "Hero";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.hero = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.total_xp = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.bkb_charges_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.aeon_charges_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.reliable_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.unreliable_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.total_earned_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.shared_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.hero_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    104 => {
                        self.creep_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.neutral_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.courier_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.bounty_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    136 => {
                        self.roshan_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    144 => {
                        self.building_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    152 => {
                        self.other_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    208 => {
                        self.income_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    216 => {
                        self.ward_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    224 => {
                        self.ability_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    232 => {
                        self.denies = ::std::option::Option::Some(is.read_int32()?);
                    },
                    240 => {
                        self.last_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    248 => {
                        self.last_hit_streak = ::std::option::Option::Some(is.read_int32()?);
                    },
                    256 => {
                        self.last_hit_multikill = ::std::option::Option::Some(is.read_int32()?);
                    },
                    264 => {
                        self.nearby_creep_death_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    272 => {
                        self.claimed_deny_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    280 => {
                        self.claimed_miss_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    288 => {
                        self.miss_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    325 => {
                        self.buyback_cooldown_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    333 => {
                        self.buyback_gold_limit_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    357 => {
                        self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    365 => {
                        self.healing = ::std::option::Option::Some(is.read_float()?);
                    },
                    368 => {
                        self.tower_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    376 => {
                        self.roshan_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    384 => {
                        self.observer_wards_placed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    392 => {
                        self.sentry_wards_placed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    400 => {
                        self.creeps_stacked = ::std::option::Option::Some(is.read_int32()?);
                    },
                    408 => {
                        self.camps_stacked = ::std::option::Option::Some(is.read_int32()?);
                    },
                    416 => {
                        self.rune_pickups = ::std::option::Option::Some(is.read_int32()?);
                    },
                    424 => {
                        self.gold_spent_on_support = ::std::option::Option::Some(is.read_int32()?);
                    },
                    432 => {
                        self.hero_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    440 => {
                        self.wards_purchased = ::std::option::Option::Some(is.read_int32()?);
                    },
                    448 => {
                        self.wards_destroyed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    464 => {
                        self.gold_spent_on_consumables = ::std::option::Option::Some(is.read_int32()?);
                    },
                    472 => {
                        self.gold_spent_on_items = ::std::option::Option::Some(is.read_int32()?);
                    },
                    480 => {
                        self.gold_spent_on_buybacks = ::std::option::Option::Some(is.read_int32()?);
                    },
                    488 => {
                        self.gold_lost_to_death = ::std::option::Option::Some(is.read_int32()?);
                    },
                    496 => {
                        self.kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    504 => {
                        self.assists = ::std::option::Option::Some(is.read_int32()?);
                    },
                    512 => {
                        self.deaths = ::std::option::Option::Some(is.read_int32()?);
                    },
                    520 => {
                        self.kill_streak = ::std::option::Option::Some(is.read_int32()?);
                    },
                    544 => {
                        self.respawn_seconds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    552 => {
                        self.last_buyback_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    568 => {
                        self.first_blood_claimed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    576 => {
                        self.first_blood_given = ::std::option::Option::Some(is.read_bool()?);
                    },
                    584 => {
                        self.bounty_runes = ::std::option::Option::Some(is.read_int32()?);
                    },
                    592 => {
                        self.outposts_captured = ::std::option::Option::Some(is.read_int32()?);
                    },
                    602 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    1202 => {
                        self.enemy_kills.push(is.read_message()?);
                    },
                    1210 => {
                        self.damage_stats.push(is.read_message()?);
                    },
                    1218 => {
                        self.abilities.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.hero.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.total_xp {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.bkb_charges_used {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.aeon_charges_used {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.reliable_gold {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.unreliable_gold {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.total_earned_gold {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.shared_gold {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.hero_kill_gold {
                my_size += ::protobuf::rt::int32_size(12, v);
            }
            if let Some(v) = self.creep_kill_gold {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.neutral_kill_gold {
                my_size += ::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.courier_gold {
                my_size += ::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.bounty_gold {
                my_size += ::protobuf::rt::int32_size(16, v);
            }
            if let Some(v) = self.roshan_gold {
                my_size += ::protobuf::rt::int32_size(17, v);
            }
            if let Some(v) = self.building_gold {
                my_size += ::protobuf::rt::int32_size(18, v);
            }
            if let Some(v) = self.other_gold {
                my_size += ::protobuf::rt::int32_size(19, v);
            }
            if let Some(v) = self.income_gold {
                my_size += ::protobuf::rt::int32_size(26, v);
            }
            if let Some(v) = self.ward_kill_gold {
                my_size += ::protobuf::rt::int32_size(27, v);
            }
            if let Some(v) = self.ability_gold {
                my_size += ::protobuf::rt::int32_size(28, v);
            }
            if let Some(v) = self.denies {
                my_size += ::protobuf::rt::int32_size(29, v);
            }
            if let Some(v) = self.last_hits {
                my_size += ::protobuf::rt::int32_size(30, v);
            }
            if let Some(v) = self.last_hit_streak {
                my_size += ::protobuf::rt::int32_size(31, v);
            }
            if let Some(v) = self.last_hit_multikill {
                my_size += ::protobuf::rt::int32_size(32, v);
            }
            if let Some(v) = self.nearby_creep_death_count {
                my_size += ::protobuf::rt::int32_size(33, v);
            }
            if let Some(v) = self.claimed_deny_count {
                my_size += ::protobuf::rt::int32_size(34, v);
            }
            if let Some(v) = self.claimed_miss_count {
                my_size += ::protobuf::rt::int32_size(35, v);
            }
            if let Some(v) = self.miss_count {
                my_size += ::protobuf::rt::int32_size(36, v);
            }
            if let Some(v) = self.buyback_cooldown_time {
                my_size += 2 + 4;
            }
            if let Some(v) = self.buyback_gold_limit_time {
                my_size += 2 + 4;
            }
            if let Some(v) = self.stun_duration {
                my_size += 2 + 4;
            }
            if let Some(v) = self.healing {
                my_size += 2 + 4;
            }
            if let Some(v) = self.tower_kills {
                my_size += ::protobuf::rt::int32_size(46, v);
            }
            if let Some(v) = self.roshan_kills {
                my_size += ::protobuf::rt::int32_size(47, v);
            }
            if let Some(v) = self.observer_wards_placed {
                my_size += ::protobuf::rt::int32_size(48, v);
            }
            if let Some(v) = self.sentry_wards_placed {
                my_size += ::protobuf::rt::int32_size(49, v);
            }
            if let Some(v) = self.creeps_stacked {
                my_size += ::protobuf::rt::int32_size(50, v);
            }
            if let Some(v) = self.camps_stacked {
                my_size += ::protobuf::rt::int32_size(51, v);
            }
            if let Some(v) = self.rune_pickups {
                my_size += ::protobuf::rt::int32_size(52, v);
            }
            if let Some(v) = self.gold_spent_on_support {
                my_size += ::protobuf::rt::int32_size(53, v);
            }
            if let Some(v) = self.hero_damage {
                my_size += ::protobuf::rt::int32_size(54, v);
            }
            if let Some(v) = self.wards_purchased {
                my_size += ::protobuf::rt::int32_size(55, v);
            }
            if let Some(v) = self.wards_destroyed {
                my_size += ::protobuf::rt::int32_size(56, v);
            }
            if let Some(v) = self.gold_spent_on_consumables {
                my_size += ::protobuf::rt::int32_size(58, v);
            }
            if let Some(v) = self.gold_spent_on_items {
                my_size += ::protobuf::rt::int32_size(59, v);
            }
            if let Some(v) = self.gold_spent_on_buybacks {
                my_size += ::protobuf::rt::int32_size(60, v);
            }
            if let Some(v) = self.gold_lost_to_death {
                my_size += ::protobuf::rt::int32_size(61, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::int32_size(62, v);
            }
            if let Some(v) = self.assists {
                my_size += ::protobuf::rt::int32_size(63, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::int32_size(64, v);
            }
            if let Some(v) = self.kill_streak {
                my_size += ::protobuf::rt::int32_size(65, v);
            }
            if let Some(v) = self.respawn_seconds {
                my_size += ::protobuf::rt::int32_size(68, v);
            }
            if let Some(v) = self.last_buyback_time {
                my_size += ::protobuf::rt::int32_size(69, v);
            }
            if let Some(v) = self.first_blood_claimed {
                my_size += 2 + 1;
            }
            if let Some(v) = self.first_blood_given {
                my_size += 2 + 1;
            }
            if let Some(v) = self.bounty_runes {
                my_size += ::protobuf::rt::int32_size(73, v);
            }
            if let Some(v) = self.outposts_captured {
                my_size += ::protobuf::rt::int32_size(74, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.enemy_kills {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.damage_stats {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.abilities {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.player_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.hero.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.total_xp {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.bkb_charges_used {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.aeon_charges_used {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.reliable_gold {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.unreliable_gold {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.total_earned_gold {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.shared_gold {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.hero_kill_gold {
                os.write_int32(12, v)?;
            }
            if let Some(v) = self.creep_kill_gold {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.neutral_kill_gold {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.courier_gold {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.bounty_gold {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.roshan_gold {
                os.write_int32(17, v)?;
            }
            if let Some(v) = self.building_gold {
                os.write_int32(18, v)?;
            }
            if let Some(v) = self.other_gold {
                os.write_int32(19, v)?;
            }
            if let Some(v) = self.income_gold {
                os.write_int32(26, v)?;
            }
            if let Some(v) = self.ward_kill_gold {
                os.write_int32(27, v)?;
            }
            if let Some(v) = self.ability_gold {
                os.write_int32(28, v)?;
            }
            if let Some(v) = self.denies {
                os.write_int32(29, v)?;
            }
            if let Some(v) = self.last_hits {
                os.write_int32(30, v)?;
            }
            if let Some(v) = self.last_hit_streak {
                os.write_int32(31, v)?;
            }
            if let Some(v) = self.last_hit_multikill {
                os.write_int32(32, v)?;
            }
            if let Some(v) = self.nearby_creep_death_count {
                os.write_int32(33, v)?;
            }
            if let Some(v) = self.claimed_deny_count {
                os.write_int32(34, v)?;
            }
            if let Some(v) = self.claimed_miss_count {
                os.write_int32(35, v)?;
            }
            if let Some(v) = self.miss_count {
                os.write_int32(36, v)?;
            }
            if let Some(v) = self.buyback_cooldown_time {
                os.write_float(40, v)?;
            }
            if let Some(v) = self.buyback_gold_limit_time {
                os.write_float(41, v)?;
            }
            if let Some(v) = self.stun_duration {
                os.write_float(44, v)?;
            }
            if let Some(v) = self.healing {
                os.write_float(45, v)?;
            }
            if let Some(v) = self.tower_kills {
                os.write_int32(46, v)?;
            }
            if let Some(v) = self.roshan_kills {
                os.write_int32(47, v)?;
            }
            if let Some(v) = self.observer_wards_placed {
                os.write_int32(48, v)?;
            }
            if let Some(v) = self.sentry_wards_placed {
                os.write_int32(49, v)?;
            }
            if let Some(v) = self.creeps_stacked {
                os.write_int32(50, v)?;
            }
            if let Some(v) = self.camps_stacked {
                os.write_int32(51, v)?;
            }
            if let Some(v) = self.rune_pickups {
                os.write_int32(52, v)?;
            }
            if let Some(v) = self.gold_spent_on_support {
                os.write_int32(53, v)?;
            }
            if let Some(v) = self.hero_damage {
                os.write_int32(54, v)?;
            }
            if let Some(v) = self.wards_purchased {
                os.write_int32(55, v)?;
            }
            if let Some(v) = self.wards_destroyed {
                os.write_int32(56, v)?;
            }
            if let Some(v) = self.gold_spent_on_consumables {
                os.write_int32(58, v)?;
            }
            if let Some(v) = self.gold_spent_on_items {
                os.write_int32(59, v)?;
            }
            if let Some(v) = self.gold_spent_on_buybacks {
                os.write_int32(60, v)?;
            }
            if let Some(v) = self.gold_lost_to_death {
                os.write_int32(61, v)?;
            }
            if let Some(v) = self.kills {
                os.write_int32(62, v)?;
            }
            if let Some(v) = self.assists {
                os.write_int32(63, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_int32(64, v)?;
            }
            if let Some(v) = self.kill_streak {
                os.write_int32(65, v)?;
            }
            if let Some(v) = self.respawn_seconds {
                os.write_int32(68, v)?;
            }
            if let Some(v) = self.last_buyback_time {
                os.write_int32(69, v)?;
            }
            if let Some(v) = self.first_blood_claimed {
                os.write_bool(71, v)?;
            }
            if let Some(v) = self.first_blood_given {
                os.write_bool(72, v)?;
            }
            if let Some(v) = self.bounty_runes {
                os.write_int32(73, v)?;
            }
            if let Some(v) = self.outposts_captured {
                os.write_int32(74, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(75, v, os)?;
            }
            for v in &self.enemy_kills {
                ::protobuf::rt::write_message_field_with_cached_size(150, v, os)?;
            };
            for v in &self.damage_stats {
                ::protobuf::rt::write_message_field_with_cached_size(151, v, os)?;
            };
            for v in &self.abilities {
                ::protobuf::rt::write_message_field_with_cached_size(152, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Hero {
            Hero::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.player_id = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.hero = ::std::option::Option::None;
            self.total_xp = ::std::option::Option::None;
            self.bkb_charges_used = ::std::option::Option::None;
            self.aeon_charges_used = ::std::option::Option::None;
            self.reliable_gold = ::std::option::Option::None;
            self.unreliable_gold = ::std::option::Option::None;
            self.total_earned_gold = ::std::option::Option::None;
            self.shared_gold = ::std::option::Option::None;
            self.hero_kill_gold = ::std::option::Option::None;
            self.creep_kill_gold = ::std::option::Option::None;
            self.neutral_kill_gold = ::std::option::Option::None;
            self.courier_gold = ::std::option::Option::None;
            self.bounty_gold = ::std::option::Option::None;
            self.roshan_gold = ::std::option::Option::None;
            self.building_gold = ::std::option::Option::None;
            self.other_gold = ::std::option::Option::None;
            self.income_gold = ::std::option::Option::None;
            self.ward_kill_gold = ::std::option::Option::None;
            self.ability_gold = ::std::option::Option::None;
            self.denies = ::std::option::Option::None;
            self.last_hits = ::std::option::Option::None;
            self.last_hit_streak = ::std::option::Option::None;
            self.last_hit_multikill = ::std::option::Option::None;
            self.nearby_creep_death_count = ::std::option::Option::None;
            self.claimed_deny_count = ::std::option::Option::None;
            self.claimed_miss_count = ::std::option::Option::None;
            self.miss_count = ::std::option::Option::None;
            self.buyback_cooldown_time = ::std::option::Option::None;
            self.buyback_gold_limit_time = ::std::option::Option::None;
            self.stun_duration = ::std::option::Option::None;
            self.healing = ::std::option::Option::None;
            self.tower_kills = ::std::option::Option::None;
            self.roshan_kills = ::std::option::Option::None;
            self.observer_wards_placed = ::std::option::Option::None;
            self.sentry_wards_placed = ::std::option::Option::None;
            self.creeps_stacked = ::std::option::Option::None;
            self.camps_stacked = ::std::option::Option::None;
            self.rune_pickups = ::std::option::Option::None;
            self.gold_spent_on_support = ::std::option::Option::None;
            self.hero_damage = ::std::option::Option::None;
            self.wards_purchased = ::std::option::Option::None;
            self.wards_destroyed = ::std::option::Option::None;
            self.gold_spent_on_consumables = ::std::option::Option::None;
            self.gold_spent_on_items = ::std::option::Option::None;
            self.gold_spent_on_buybacks = ::std::option::Option::None;
            self.gold_lost_to_death = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.kill_streak = ::std::option::Option::None;
            self.respawn_seconds = ::std::option::Option::None;
            self.last_buyback_time = ::std::option::Option::None;
            self.first_blood_claimed = ::std::option::Option::None;
            self.first_blood_given = ::std::option::Option::None;
            self.bounty_runes = ::std::option::Option::None;
            self.outposts_captured = ::std::option::Option::None;
            self.position.clear();
            self.enemy_kills.clear();
            self.damage_stats.clear();
            self.abilities.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Hero {
            static instance: Hero = Hero {
                steam_id: ::std::option::Option::None,
                player_id: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                hero: ::std::option::Option::None,
                total_xp: ::std::option::Option::None,
                bkb_charges_used: ::std::option::Option::None,
                aeon_charges_used: ::std::option::Option::None,
                reliable_gold: ::std::option::Option::None,
                unreliable_gold: ::std::option::Option::None,
                total_earned_gold: ::std::option::Option::None,
                shared_gold: ::std::option::Option::None,
                hero_kill_gold: ::std::option::Option::None,
                creep_kill_gold: ::std::option::Option::None,
                neutral_kill_gold: ::std::option::Option::None,
                courier_gold: ::std::option::Option::None,
                bounty_gold: ::std::option::Option::None,
                roshan_gold: ::std::option::Option::None,
                building_gold: ::std::option::Option::None,
                other_gold: ::std::option::Option::None,
                income_gold: ::std::option::Option::None,
                ward_kill_gold: ::std::option::Option::None,
                ability_gold: ::std::option::Option::None,
                denies: ::std::option::Option::None,
                last_hits: ::std::option::Option::None,
                last_hit_streak: ::std::option::Option::None,
                last_hit_multikill: ::std::option::Option::None,
                nearby_creep_death_count: ::std::option::Option::None,
                claimed_deny_count: ::std::option::Option::None,
                claimed_miss_count: ::std::option::Option::None,
                miss_count: ::std::option::Option::None,
                buyback_cooldown_time: ::std::option::Option::None,
                buyback_gold_limit_time: ::std::option::Option::None,
                stun_duration: ::std::option::Option::None,
                healing: ::std::option::Option::None,
                tower_kills: ::std::option::Option::None,
                roshan_kills: ::std::option::Option::None,
                observer_wards_placed: ::std::option::Option::None,
                sentry_wards_placed: ::std::option::Option::None,
                creeps_stacked: ::std::option::Option::None,
                camps_stacked: ::std::option::Option::None,
                rune_pickups: ::std::option::Option::None,
                gold_spent_on_support: ::std::option::Option::None,
                hero_damage: ::std::option::Option::None,
                wards_purchased: ::std::option::Option::None,
                wards_destroyed: ::std::option::Option::None,
                gold_spent_on_consumables: ::std::option::Option::None,
                gold_spent_on_items: ::std::option::Option::None,
                gold_spent_on_buybacks: ::std::option::Option::None,
                gold_lost_to_death: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                kill_streak: ::std::option::Option::None,
                respawn_seconds: ::std::option::Option::None,
                last_buyback_time: ::std::option::Option::None,
                first_blood_claimed: ::std::option::Option::None,
                first_blood_given: ::std::option::Option::None,
                bounty_runes: ::std::option::Option::None,
                outposts_captured: ::std::option::Option::None,
                position: ::protobuf::MessageField::none(),
                enemy_kills: ::std::vec::Vec::new(),
                damage_stats: ::std::vec::Vec::new(),
                abilities: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Hero {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Hero").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Hero {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Hero {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Stock)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stock {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Stock.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Stock.team_number)
        pub team_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Stock.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Stock.current_stock)
        pub current_stock: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Stock.cooldown)
        pub cooldown: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Stock.bonus_stock)
        pub bonus_stock: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Stock.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stock {
        fn default() -> &'a Stock {
            <Stock as ::protobuf::Message>::default_instance()
        }
    }

    impl Stock {
        pub fn new() -> Stock {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 team_number = 2;

        pub fn team_number(&self) -> i32 {
            self.team_number.unwrap_or(0)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: i32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional int32 player_id = 3;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 current_stock = 4;

        pub fn current_stock(&self) -> i32 {
            self.current_stock.unwrap_or(0)
        }

        pub fn clear_current_stock(&mut self) {
            self.current_stock = ::std::option::Option::None;
        }

        pub fn has_current_stock(&self) -> bool {
            self.current_stock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_current_stock(&mut self, v: i32) {
            self.current_stock = ::std::option::Option::Some(v);
        }

        // optional float cooldown = 5;

        pub fn cooldown(&self) -> f32 {
            self.cooldown.unwrap_or(0.)
        }

        pub fn clear_cooldown(&mut self) {
            self.cooldown = ::std::option::Option::None;
        }

        pub fn has_cooldown(&self) -> bool {
            self.cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cooldown(&mut self, v: f32) {
            self.cooldown = ::std::option::Option::Some(v);
        }

        // optional int32 bonus_stock = 6;

        pub fn bonus_stock(&self) -> i32 {
            self.bonus_stock.unwrap_or(0)
        }

        pub fn clear_bonus_stock(&mut self) {
            self.bonus_stock = ::std::option::Option::None;
        }

        pub fn has_bonus_stock(&self) -> bool {
            self.bonus_stock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_stock(&mut self, v: i32) {
            self.bonus_stock = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Stock| { &m.name },
                |m: &mut Stock| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_number",
                |m: &Stock| { &m.team_number },
                |m: &mut Stock| { &mut m.team_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &Stock| { &m.player_id },
                |m: &mut Stock| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "current_stock",
                |m: &Stock| { &m.current_stock },
                |m: &mut Stock| { &mut m.current_stock },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cooldown",
                |m: &Stock| { &m.cooldown },
                |m: &mut Stock| { &mut m.cooldown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bonus_stock",
                |m: &Stock| { &m.bonus_stock },
                |m: &mut Stock| { &mut m.bonus_stock },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stock>(
                "CMsgDotaScenario.Stock",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stock {
        const NAME: &'static str = "Stock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.team_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.current_stock = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.bonus_stock = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.team_number {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.current_stock {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.cooldown {
                my_size += 1 + 4;
            }
            if let Some(v) = self.bonus_stock {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.team_number {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.player_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.current_stock {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.cooldown {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.bonus_stock {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stock {
            Stock::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.team_number = ::std::option::Option::None;
            self.player_id = ::std::option::Option::None;
            self.current_stock = ::std::option::Option::None;
            self.cooldown = ::std::option::Option::None;
            self.bonus_stock = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stock {
            static instance: Stock = Stock {
                name: ::std::option::Option::None,
                team_number: ::std::option::Option::None,
                player_id: ::std::option::Option::None,
                current_stock: ::std::option::Option::None,
                cooldown: ::std::option::Option::None,
                bonus_stock: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stock {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Stock").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stock {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stock {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Building)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Building {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Building.entity_name)
        pub entity_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Building.entity_class)
        pub entity_class: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Building.team_id)
        pub team_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Building.is_destroyed)
        pub is_destroyed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Building.health_frac)
        pub health_frac: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Building.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Building {
        fn default() -> &'a Building {
            <Building as ::protobuf::Message>::default_instance()
        }
    }

    impl Building {
        pub fn new() -> Building {
            ::std::default::Default::default()
        }

        // optional string entity_name = 1;

        pub fn entity_name(&self) -> &str {
            match self.entity_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_entity_name(&mut self) {
            self.entity_name = ::std::option::Option::None;
        }

        pub fn has_entity_name(&self) -> bool {
            self.entity_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_name(&mut self, v: ::std::string::String) {
            self.entity_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_entity_name(&mut self) -> &mut ::std::string::String {
            if self.entity_name.is_none() {
                self.entity_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.entity_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_entity_name(&mut self) -> ::std::string::String {
            self.entity_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string entity_class = 2;

        pub fn entity_class(&self) -> &str {
            match self.entity_class.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_entity_class(&mut self) {
            self.entity_class = ::std::option::Option::None;
        }

        pub fn has_entity_class(&self) -> bool {
            self.entity_class.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_class(&mut self, v: ::std::string::String) {
            self.entity_class = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_entity_class(&mut self) -> &mut ::std::string::String {
            if self.entity_class.is_none() {
                self.entity_class = ::std::option::Option::Some(::std::string::String::new());
            }
            self.entity_class.as_mut().unwrap()
        }

        // Take field
        pub fn take_entity_class(&mut self) -> ::std::string::String {
            self.entity_class.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 team_id = 3;

        pub fn team_id(&self) -> i32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: i32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional bool is_destroyed = 4;

        pub fn is_destroyed(&self) -> bool {
            self.is_destroyed.unwrap_or(false)
        }

        pub fn clear_is_destroyed(&mut self) {
            self.is_destroyed = ::std::option::Option::None;
        }

        pub fn has_is_destroyed(&self) -> bool {
            self.is_destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_destroyed(&mut self, v: bool) {
            self.is_destroyed = ::std::option::Option::Some(v);
        }

        // optional float health_frac = 5;

        pub fn health_frac(&self) -> f32 {
            self.health_frac.unwrap_or(0.)
        }

        pub fn clear_health_frac(&mut self) {
            self.health_frac = ::std::option::Option::None;
        }

        pub fn has_health_frac(&self) -> bool {
            self.health_frac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_health_frac(&mut self, v: f32) {
            self.health_frac = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_name",
                |m: &Building| { &m.entity_name },
                |m: &mut Building| { &mut m.entity_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_class",
                |m: &Building| { &m.entity_class },
                |m: &mut Building| { &mut m.entity_class },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Building| { &m.team_id },
                |m: &mut Building| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_destroyed",
                |m: &Building| { &m.is_destroyed },
                |m: &mut Building| { &mut m.is_destroyed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "health_frac",
                |m: &Building| { &m.health_frac },
                |m: &mut Building| { &mut m.health_frac },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Building>(
                "CMsgDotaScenario.Building",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Building {
        const NAME: &'static str = "Building";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.entity_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.entity_class = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.is_destroyed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    45 => {
                        self.health_frac = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.entity_class.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.is_destroyed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.health_frac {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.entity_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.entity_class.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.is_destroyed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.health_frac {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Building {
            Building::new()
        }

        fn clear(&mut self) {
            self.entity_name = ::std::option::Option::None;
            self.entity_class = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.is_destroyed = ::std::option::Option::None;
            self.health_frac = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Building {
            static instance: Building = Building {
                entity_name: ::std::option::Option::None,
                entity_class: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                is_destroyed: ::std::option::Option::None,
                health_frac: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Building {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Building").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Building {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Building {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Entity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entity {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Entity.courier)
        pub courier: ::protobuf::MessageField<super::CScenarioEnt_Courier>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Entity.npc)
        pub npc: ::protobuf::MessageField<super::CScenarioEnt_NPC>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Entity.spirit_bear)
        pub spirit_bear: ::protobuf::MessageField<super::CScenarioEnt_SpiritBear>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Entity.dropped_item)
        pub dropped_item: ::protobuf::MessageField<super::CScenarioEnt_DroppedItem>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Entity.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entity {
        fn default() -> &'a Entity {
            <Entity as ::protobuf::Message>::default_instance()
        }
    }

    impl Entity {
        pub fn new() -> Entity {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CScenarioEnt_Courier>(
                "courier",
                |m: &Entity| { &m.courier },
                |m: &mut Entity| { &mut m.courier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CScenarioEnt_NPC>(
                "npc",
                |m: &Entity| { &m.npc },
                |m: &mut Entity| { &mut m.npc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CScenarioEnt_SpiritBear>(
                "spirit_bear",
                |m: &Entity| { &m.spirit_bear },
                |m: &mut Entity| { &mut m.spirit_bear },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CScenarioEnt_DroppedItem>(
                "dropped_item",
                |m: &Entity| { &m.dropped_item },
                |m: &mut Entity| { &mut m.dropped_item },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entity>(
                "CMsgDotaScenario.Entity",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entity {
        const NAME: &'static str = "Entity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.courier)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.npc)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.spirit_bear)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.dropped_item)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.courier.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.npc.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.spirit_bear.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dropped_item.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.courier.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.npc.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.spirit_bear.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.dropped_item.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entity {
            Entity::new()
        }

        fn clear(&mut self) {
            self.courier.clear();
            self.npc.clear();
            self.spirit_bear.clear();
            self.dropped_item.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entity {
            static instance: Entity = Entity {
                courier: ::protobuf::MessageField::none(),
                npc: ::protobuf::MessageField::none(),
                spirit_bear: ::protobuf::MessageField::none(),
                dropped_item: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entity {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Entity").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entity {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.location)
        pub location: ::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.owner_id)
        pub owner_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.item_slot)
        pub item_slot: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.neutral_drop_team)
        pub neutral_drop_team: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.charges)
        pub charges: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.secondary_charges)
        pub secondary_charges: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.lifetime)
        pub lifetime: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Item.stored_rune_type)
        pub stored_rune_type: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Item.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 owner_id = 3;

        pub fn owner_id(&self) -> i32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: i32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional int32 item_slot = 4;

        pub fn item_slot(&self) -> i32 {
            self.item_slot.unwrap_or(0)
        }

        pub fn clear_item_slot(&mut self) {
            self.item_slot = ::std::option::Option::None;
        }

        pub fn has_item_slot(&self) -> bool {
            self.item_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_slot(&mut self, v: i32) {
            self.item_slot = ::std::option::Option::Some(v);
        }

        // optional int32 neutral_drop_team = 5;

        pub fn neutral_drop_team(&self) -> i32 {
            self.neutral_drop_team.unwrap_or(0)
        }

        pub fn clear_neutral_drop_team(&mut self) {
            self.neutral_drop_team = ::std::option::Option::None;
        }

        pub fn has_neutral_drop_team(&self) -> bool {
            self.neutral_drop_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_drop_team(&mut self, v: i32) {
            self.neutral_drop_team = ::std::option::Option::Some(v);
        }

        // optional int32 charges = 6;

        pub fn charges(&self) -> i32 {
            self.charges.unwrap_or(0)
        }

        pub fn clear_charges(&mut self) {
            self.charges = ::std::option::Option::None;
        }

        pub fn has_charges(&self) -> bool {
            self.charges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_charges(&mut self, v: i32) {
            self.charges = ::std::option::Option::Some(v);
        }

        // optional int32 secondary_charges = 7;

        pub fn secondary_charges(&self) -> i32 {
            self.secondary_charges.unwrap_or(0)
        }

        pub fn clear_secondary_charges(&mut self) {
            self.secondary_charges = ::std::option::Option::None;
        }

        pub fn has_secondary_charges(&self) -> bool {
            self.secondary_charges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_secondary_charges(&mut self, v: i32) {
            self.secondary_charges = ::std::option::Option::Some(v);
        }

        // optional float lifetime = 8;

        pub fn lifetime(&self) -> f32 {
            self.lifetime.unwrap_or(0.)
        }

        pub fn clear_lifetime(&mut self) {
            self.lifetime = ::std::option::Option::None;
        }

        pub fn has_lifetime(&self) -> bool {
            self.lifetime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lifetime(&mut self, v: f32) {
            self.lifetime = ::std::option::Option::Some(v);
        }

        // optional int32 stored_rune_type = 9;

        pub fn stored_rune_type(&self) -> i32 {
            self.stored_rune_type.unwrap_or(0)
        }

        pub fn clear_stored_rune_type(&mut self) {
            self.stored_rune_type = ::std::option::Option::None;
        }

        pub fn has_stored_rune_type(&self) -> bool {
            self.stored_rune_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stored_rune_type(&mut self, v: i32) {
            self.stored_rune_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Item| { &m.name },
                |m: &mut Item| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EntityRef>(
                "location",
                |m: &Item| { &m.location },
                |m: &mut Item| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &Item| { &m.owner_id },
                |m: &mut Item| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_slot",
                |m: &Item| { &m.item_slot },
                |m: &mut Item| { &mut m.item_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "neutral_drop_team",
                |m: &Item| { &m.neutral_drop_team },
                |m: &mut Item| { &mut m.neutral_drop_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "charges",
                |m: &Item| { &m.charges },
                |m: &mut Item| { &mut m.charges },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "secondary_charges",
                |m: &Item| { &m.secondary_charges },
                |m: &mut Item| { &mut m.secondary_charges },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lifetime",
                |m: &Item| { &m.lifetime },
                |m: &mut Item| { &mut m.lifetime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stored_rune_type",
                |m: &Item| { &m.stored_rune_type },
                |m: &mut Item| { &mut m.stored_rune_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                "CMsgDotaScenario.Item",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                    },
                    24 => {
                        self.owner_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.item_slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.neutral_drop_team = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.charges = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                    },
                    69 => {
                        self.lifetime = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.stored_rune_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.location.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.item_slot {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.neutral_drop_team {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.charges {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.secondary_charges {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.lifetime {
                my_size += 1 + 4;
            }
            if let Some(v) = self.stored_rune_type {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.location.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.owner_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.item_slot {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.neutral_drop_team {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.charges {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.secondary_charges {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.lifetime {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.stored_rune_type {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.location.clear();
            self.owner_id = ::std::option::Option::None;
            self.item_slot = ::std::option::Option::None;
            self.neutral_drop_team = ::std::option::Option::None;
            self.charges = ::std::option::Option::None;
            self.secondary_charges = ::std::option::Option::None;
            self.lifetime = ::std::option::Option::None;
            self.stored_rune_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                name: ::std::option::Option::None,
                location: ::protobuf::MessageField::none(),
                owner_id: ::std::option::Option::None,
                item_slot: ::std::option::Option::None,
                neutral_drop_team: ::std::option::Option::None,
                charges: ::std::option::Option::None,
                secondary_charges: ::std::option::Option::None,
                lifetime: ::std::option::Option::None,
                stored_rune_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Item {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Item").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Item {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDotaScenario.Modifier)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Modifier {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.parent)
        pub parent: ::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.caster)
        pub caster: ::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.ability)
        pub ability: ::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.duration)
        pub duration: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.lifetime_remaining)
        pub lifetime_remaining: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.stack_count)
        pub stack_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.create_even_if_existing)
        pub create_even_if_existing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.create_without_caster)
        pub create_without_caster: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.create_without_ability)
        pub create_without_ability: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.moonshard_consumed_bonus)
        pub moonshard_consumed_bonus: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.moonshard_consumed_bonus_night_vision)
        pub moonshard_consumed_bonus_night_vision: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.wardtruesight_range)
        pub wardtruesight_range: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_all_stats)
        pub ultimate_scepter_consumed_alchemist_bonus_all_stats: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_health)
        pub ultimate_scepter_consumed_alchemist_bonus_health: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_mana)
        pub ultimate_scepter_consumed_alchemist_bonus_mana: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDotaScenario.Modifier.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Modifier {
        fn default() -> &'a Modifier {
            <Modifier as ::protobuf::Message>::default_instance()
        }
    }

    impl Modifier {
        pub fn new() -> Modifier {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float duration = 5;

        pub fn duration(&self) -> f32 {
            self.duration.unwrap_or(0.)
        }

        pub fn clear_duration(&mut self) {
            self.duration = ::std::option::Option::None;
        }

        pub fn has_duration(&self) -> bool {
            self.duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration(&mut self, v: f32) {
            self.duration = ::std::option::Option::Some(v);
        }

        // optional float lifetime_remaining = 6;

        pub fn lifetime_remaining(&self) -> f32 {
            self.lifetime_remaining.unwrap_or(0.)
        }

        pub fn clear_lifetime_remaining(&mut self) {
            self.lifetime_remaining = ::std::option::Option::None;
        }

        pub fn has_lifetime_remaining(&self) -> bool {
            self.lifetime_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lifetime_remaining(&mut self, v: f32) {
            self.lifetime_remaining = ::std::option::Option::Some(v);
        }

        // optional int32 stack_count = 7;

        pub fn stack_count(&self) -> i32 {
            self.stack_count.unwrap_or(0)
        }

        pub fn clear_stack_count(&mut self) {
            self.stack_count = ::std::option::Option::None;
        }

        pub fn has_stack_count(&self) -> bool {
            self.stack_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stack_count(&mut self, v: i32) {
            self.stack_count = ::std::option::Option::Some(v);
        }

        // optional bool create_even_if_existing = 8;

        pub fn create_even_if_existing(&self) -> bool {
            self.create_even_if_existing.unwrap_or(false)
        }

        pub fn clear_create_even_if_existing(&mut self) {
            self.create_even_if_existing = ::std::option::Option::None;
        }

        pub fn has_create_even_if_existing(&self) -> bool {
            self.create_even_if_existing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_create_even_if_existing(&mut self, v: bool) {
            self.create_even_if_existing = ::std::option::Option::Some(v);
        }

        // optional bool create_without_caster = 9;

        pub fn create_without_caster(&self) -> bool {
            self.create_without_caster.unwrap_or(false)
        }

        pub fn clear_create_without_caster(&mut self) {
            self.create_without_caster = ::std::option::Option::None;
        }

        pub fn has_create_without_caster(&self) -> bool {
            self.create_without_caster.is_some()
        }

        // Param is passed by value, moved
        pub fn set_create_without_caster(&mut self, v: bool) {
            self.create_without_caster = ::std::option::Option::Some(v);
        }

        // optional bool create_without_ability = 10;

        pub fn create_without_ability(&self) -> bool {
            self.create_without_ability.unwrap_or(false)
        }

        pub fn clear_create_without_ability(&mut self) {
            self.create_without_ability = ::std::option::Option::None;
        }

        pub fn has_create_without_ability(&self) -> bool {
            self.create_without_ability.is_some()
        }

        // Param is passed by value, moved
        pub fn set_create_without_ability(&mut self, v: bool) {
            self.create_without_ability = ::std::option::Option::Some(v);
        }

        // optional int32 moonshard_consumed_bonus = 100;

        pub fn moonshard_consumed_bonus(&self) -> i32 {
            self.moonshard_consumed_bonus.unwrap_or(0)
        }

        pub fn clear_moonshard_consumed_bonus(&mut self) {
            self.moonshard_consumed_bonus = ::std::option::Option::None;
        }

        pub fn has_moonshard_consumed_bonus(&self) -> bool {
            self.moonshard_consumed_bonus.is_some()
        }

        // Param is passed by value, moved
        pub fn set_moonshard_consumed_bonus(&mut self, v: i32) {
            self.moonshard_consumed_bonus = ::std::option::Option::Some(v);
        }

        // optional int32 moonshard_consumed_bonus_night_vision = 101;

        pub fn moonshard_consumed_bonus_night_vision(&self) -> i32 {
            self.moonshard_consumed_bonus_night_vision.unwrap_or(0)
        }

        pub fn clear_moonshard_consumed_bonus_night_vision(&mut self) {
            self.moonshard_consumed_bonus_night_vision = ::std::option::Option::None;
        }

        pub fn has_moonshard_consumed_bonus_night_vision(&self) -> bool {
            self.moonshard_consumed_bonus_night_vision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_moonshard_consumed_bonus_night_vision(&mut self, v: i32) {
            self.moonshard_consumed_bonus_night_vision = ::std::option::Option::Some(v);
        }

        // optional int32 wardtruesight_range = 110;

        pub fn wardtruesight_range(&self) -> i32 {
            self.wardtruesight_range.unwrap_or(0)
        }

        pub fn clear_wardtruesight_range(&mut self) {
            self.wardtruesight_range = ::std::option::Option::None;
        }

        pub fn has_wardtruesight_range(&self) -> bool {
            self.wardtruesight_range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wardtruesight_range(&mut self, v: i32) {
            self.wardtruesight_range = ::std::option::Option::Some(v);
        }

        // optional int32 ultimate_scepter_consumed_alchemist_bonus_all_stats = 120;

        pub fn ultimate_scepter_consumed_alchemist_bonus_all_stats(&self) -> i32 {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats.unwrap_or(0)
        }

        pub fn clear_ultimate_scepter_consumed_alchemist_bonus_all_stats(&mut self) {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::None;
        }

        pub fn has_ultimate_scepter_consumed_alchemist_bonus_all_stats(&self) -> bool {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_scepter_consumed_alchemist_bonus_all_stats(&mut self, v: i32) {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::Some(v);
        }

        // optional int32 ultimate_scepter_consumed_alchemist_bonus_health = 121;

        pub fn ultimate_scepter_consumed_alchemist_bonus_health(&self) -> i32 {
            self.ultimate_scepter_consumed_alchemist_bonus_health.unwrap_or(0)
        }

        pub fn clear_ultimate_scepter_consumed_alchemist_bonus_health(&mut self) {
            self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::None;
        }

        pub fn has_ultimate_scepter_consumed_alchemist_bonus_health(&self) -> bool {
            self.ultimate_scepter_consumed_alchemist_bonus_health.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_scepter_consumed_alchemist_bonus_health(&mut self, v: i32) {
            self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::Some(v);
        }

        // optional int32 ultimate_scepter_consumed_alchemist_bonus_mana = 122;

        pub fn ultimate_scepter_consumed_alchemist_bonus_mana(&self) -> i32 {
            self.ultimate_scepter_consumed_alchemist_bonus_mana.unwrap_or(0)
        }

        pub fn clear_ultimate_scepter_consumed_alchemist_bonus_mana(&mut self) {
            self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::None;
        }

        pub fn has_ultimate_scepter_consumed_alchemist_bonus_mana(&self) -> bool {
            self.ultimate_scepter_consumed_alchemist_bonus_mana.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_scepter_consumed_alchemist_bonus_mana(&mut self, v: i32) {
            self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(16);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Modifier| { &m.name },
                |m: &mut Modifier| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EntityRef>(
                "parent",
                |m: &Modifier| { &m.parent },
                |m: &mut Modifier| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EntityRef>(
                "caster",
                |m: &Modifier| { &m.caster },
                |m: &mut Modifier| { &mut m.caster },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EntityRef>(
                "ability",
                |m: &Modifier| { &m.ability },
                |m: &mut Modifier| { &mut m.ability },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "duration",
                |m: &Modifier| { &m.duration },
                |m: &mut Modifier| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lifetime_remaining",
                |m: &Modifier| { &m.lifetime_remaining },
                |m: &mut Modifier| { &mut m.lifetime_remaining },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stack_count",
                |m: &Modifier| { &m.stack_count },
                |m: &mut Modifier| { &mut m.stack_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "create_even_if_existing",
                |m: &Modifier| { &m.create_even_if_existing },
                |m: &mut Modifier| { &mut m.create_even_if_existing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "create_without_caster",
                |m: &Modifier| { &m.create_without_caster },
                |m: &mut Modifier| { &mut m.create_without_caster },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "create_without_ability",
                |m: &Modifier| { &m.create_without_ability },
                |m: &mut Modifier| { &mut m.create_without_ability },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "moonshard_consumed_bonus",
                |m: &Modifier| { &m.moonshard_consumed_bonus },
                |m: &mut Modifier| { &mut m.moonshard_consumed_bonus },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "moonshard_consumed_bonus_night_vision",
                |m: &Modifier| { &m.moonshard_consumed_bonus_night_vision },
                |m: &mut Modifier| { &mut m.moonshard_consumed_bonus_night_vision },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wardtruesight_range",
                |m: &Modifier| { &m.wardtruesight_range },
                |m: &mut Modifier| { &mut m.wardtruesight_range },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ultimate_scepter_consumed_alchemist_bonus_all_stats",
                |m: &Modifier| { &m.ultimate_scepter_consumed_alchemist_bonus_all_stats },
                |m: &mut Modifier| { &mut m.ultimate_scepter_consumed_alchemist_bonus_all_stats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ultimate_scepter_consumed_alchemist_bonus_health",
                |m: &Modifier| { &m.ultimate_scepter_consumed_alchemist_bonus_health },
                |m: &mut Modifier| { &mut m.ultimate_scepter_consumed_alchemist_bonus_health },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ultimate_scepter_consumed_alchemist_bonus_mana",
                |m: &Modifier| { &m.ultimate_scepter_consumed_alchemist_bonus_mana },
                |m: &mut Modifier| { &mut m.ultimate_scepter_consumed_alchemist_bonus_mana },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Modifier>(
                "CMsgDotaScenario.Modifier",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Modifier {
        const NAME: &'static str = "Modifier";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.parent)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.caster)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ability)?;
                    },
                    45 => {
                        self.duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    53 => {
                        self.lifetime_remaining = ::std::option::Option::Some(is.read_float()?);
                    },
                    56 => {
                        self.stack_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.create_even_if_existing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.create_without_caster = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.create_without_ability = ::std::option::Option::Some(is.read_bool()?);
                    },
                    800 => {
                        self.moonshard_consumed_bonus = ::std::option::Option::Some(is.read_int32()?);
                    },
                    808 => {
                        self.moonshard_consumed_bonus_night_vision = ::std::option::Option::Some(is.read_int32()?);
                    },
                    880 => {
                        self.wardtruesight_range = ::std::option::Option::Some(is.read_int32()?);
                    },
                    960 => {
                        self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::Some(is.read_int32()?);
                    },
                    968 => {
                        self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::Some(is.read_int32()?);
                    },
                    976 => {
                        self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.parent.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.caster.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.ability.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.duration {
                my_size += 1 + 4;
            }
            if let Some(v) = self.lifetime_remaining {
                my_size += 1 + 4;
            }
            if let Some(v) = self.stack_count {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.create_even_if_existing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.create_without_caster {
                my_size += 1 + 1;
            }
            if let Some(v) = self.create_without_ability {
                my_size += 1 + 1;
            }
            if let Some(v) = self.moonshard_consumed_bonus {
                my_size += ::protobuf::rt::int32_size(100, v);
            }
            if let Some(v) = self.moonshard_consumed_bonus_night_vision {
                my_size += ::protobuf::rt::int32_size(101, v);
            }
            if let Some(v) = self.wardtruesight_range {
                my_size += ::protobuf::rt::int32_size(110, v);
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_all_stats {
                my_size += ::protobuf::rt::int32_size(120, v);
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_health {
                my_size += ::protobuf::rt::int32_size(121, v);
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_mana {
                my_size += ::protobuf::rt::int32_size(122, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.parent.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.caster.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.ability.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.duration {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.lifetime_remaining {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.stack_count {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.create_even_if_existing {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.create_without_caster {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.create_without_ability {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.moonshard_consumed_bonus {
                os.write_int32(100, v)?;
            }
            if let Some(v) = self.moonshard_consumed_bonus_night_vision {
                os.write_int32(101, v)?;
            }
            if let Some(v) = self.wardtruesight_range {
                os.write_int32(110, v)?;
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_all_stats {
                os.write_int32(120, v)?;
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_health {
                os.write_int32(121, v)?;
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_mana {
                os.write_int32(122, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Modifier {
            Modifier::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.parent.clear();
            self.caster.clear();
            self.ability.clear();
            self.duration = ::std::option::Option::None;
            self.lifetime_remaining = ::std::option::Option::None;
            self.stack_count = ::std::option::Option::None;
            self.create_even_if_existing = ::std::option::Option::None;
            self.create_without_caster = ::std::option::Option::None;
            self.create_without_ability = ::std::option::Option::None;
            self.moonshard_consumed_bonus = ::std::option::Option::None;
            self.moonshard_consumed_bonus_night_vision = ::std::option::Option::None;
            self.wardtruesight_range = ::std::option::Option::None;
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::None;
            self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::None;
            self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Modifier {
            static instance: Modifier = Modifier {
                name: ::std::option::Option::None,
                parent: ::protobuf::MessageField::none(),
                caster: ::protobuf::MessageField::none(),
                ability: ::protobuf::MessageField::none(),
                duration: ::std::option::Option::None,
                lifetime_remaining: ::std::option::Option::None,
                stack_count: ::std::option::Option::None,
                create_even_if_existing: ::std::option::Option::None,
                create_without_caster: ::std::option::Option::None,
                create_without_ability: ::std::option::Option::None,
                moonshard_consumed_bonus: ::std::option::Option::None,
                moonshard_consumed_bonus_night_vision: ::std::option::Option::None,
                wardtruesight_range: ::std::option::Option::None,
                ultimate_scepter_consumed_alchemist_bonus_all_stats: ::std::option::Option::None,
                ultimate_scepter_consumed_alchemist_bonus_health: ::std::option::Option::None,
                ultimate_scepter_consumed_alchemist_bonus_mana: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Modifier {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDotaScenario.Modifier").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Modifier {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Modifier {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bdota_scenariomessages.proto\x12\x04dota\x1a\x17dota_shared_enums.p\
    roto\"0\n\x12CScenario_Position\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01\
    x\x12\x0c\n\x01y\x18\x02\x20\x01(\x02R\x01y\"n\n\x1bCScenarioGame_Roshan\
    Spawner\x12\x1d\n\nkill_count\x18\x01\x20\x01(\x05R\tkillCount\x12\x14\n\
    \x05state\x18\x02\x20\x01(\x05R\x05state\x12\x1a\n\x08cooldown\x18\x03\
    \x20\x01(\x02R\x08cooldown\"{\n\x14CScenarioEnt_Courier\x12\x1f\n\x0btea\
    m_number\x18\x01\x20\x01(\x05R\nteamNumber\x12&\n\x0fowner_player_id\x18\
    \x02\x20\x01(\x05R\rownerPlayerId\x12\x1a\n\x08cooldown\x18\x03\x20\x01(\
    \x02R\x08cooldown\"\xb5\x02\n\x10CScenarioEnt_NPC\x124\n\x08position\x18\
    \x01\x20\x01(\x0b2\x18.dota.CScenario_PositionR\x08position\x12\x1b\n\tu\
    nit_name\x18\x02\x20\x01(\tR\x08unitName\x12\x1f\n\x0bteam_number\x18\
    \x03\x20\x01(\x05R\nteamNumber\x12\x1f\n\x0bhealth_frac\x18\x04\x20\x01(\
    \x02R\nhealthFrac\x12\x1f\n\x0bowning_camp\x18\n\x20\x01(\tR\nowningCamp\
    \x12J\n\x14owning_camp_position\x18\x0b\x20\x01(\x0b2\x18.dota.CScenario\
    _PositionR\x12owningCampPosition\x12\x1f\n\x0binvade_goal\x18\x14\x20\
    \x01(\tR\ninvadeGoal\"M\n\x17CScenarioEnt_SpiritBear\x12\x19\n\x08owner_\
    id\x18\x01\x20\x01(\x05R\x07ownerId\x12\x17\n\x07team_id\x18\x02\x20\x01\
    (\x05R\x06teamId\"P\n\x18CScenarioEnt_DroppedItem\x124\n\x08position\x18\
    \x01\x20\x01(\x0b2\x18.dota.CScenario_PositionR\x08position\"\xfd/\n\x10\
    CMsgDotaScenario\x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x04R\x07lobbyId\
    \x12/\n\x04game\x18\x02\x20\x01(\x0b2\x1b.dota.CMsgDotaScenario.GameR\
    \x04game\x121\n\x05teams\x18\x03\x20\x03(\x0b2\x1b.dota.CMsgDotaScenario\
    .TeamR\x05teams\x123\n\x06heroes\x18\x04\x20\x03(\x0b2\x1b.dota.CMsgDota\
    Scenario.HeroR\x06heroes\x122\n\x05stock\x18\x05\x20\x03(\x0b2\x1c.dota.\
    CMsgDotaScenario.StockR\x05stock\x12=\n\tbuildings\x18\x06\x20\x03(\x0b2\
    \x1f.dota.CMsgDotaScenario.BuildingR\tbuildings\x129\n\x08entities\x18\
    \x07\x20\x03(\x0b2\x1d.dota.CMsgDotaScenario.EntityR\x08entities\x121\n\
    \x05items\x18\x08\x20\x03(\x0b2\x1b.dota.CMsgDotaScenario.ItemR\x05items\
    \x12=\n\tmodifiers\x18\t\x20\x03(\x0b2\x1f.dota.CMsgDotaScenario.Modifie\
    rR\tmodifiers\x1a\xac\x01\n\tEntityRef\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\x05R\x08playerId\x12(\n\x10neutral_stash_id\x18\x02\x20\x01(\x05R\
    \x0eneutralStashId\x12\x1d\n\nentity_idx\x18\x03\x20\x01(\x05R\tentityId\
    x\x12\x16\n\x06roshan\x18\x04\x20\x01(\x08R\x06roshan\x12!\n\x0cability_\
    name\x18\n\x20\x01(\tR\x0babilityName\x1a\xbd\x01\n\x04Game\x12\x19\n\
    \x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\n\tgame_mode\x18\
    \x02\x20\x01(\x05R\x08gameMode\x12\x1d\n\nclock_time\x18\x03\x20\x01(\
    \x02R\tclockTime\x12#\n\rinternal_time\x18\x04\x20\x01(\x02R\x0cinternal\
    Time\x129\n\x06roshan\x18\x05\x20\x01(\x0b2!.dota.CScenarioGame_RoshanSp\
    awnerR\x06roshan\x1aA\n\x0fTeamNeutralItem\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x1a\n\x08consumed\x18\x02\x20\x01(\x08R\x08consumed\
    \x1a\xa9\x02\n\x04Team\x12\x1f\n\x0bteam_number\x18\x01\x20\x01(\x05R\nt\
    eamNumber\x12K\n\rneutral_items\x18\x02\x20\x03(\x0b2&.dota.CMsgDotaScen\
    ario.TeamNeutralItemR\x0cneutralItems\x12\x1d\n\nhero_kills\x18\x03\x20\
    \x01(\x05R\theroKills\x12\x1f\n\x0btower_kills\x18\x04\x20\x01(\x05R\nto\
    werKills\x12%\n\x0ebarracks_kills\x18\x05\x20\x01(\x05R\rbarracksKills\
    \x12%\n\x0eglyph_cooldown\x18\x06\x20\x01(\x02R\rglyphCooldown\x12%\n\
    \x0eradar_cooldown\x18\x07\x20\x01(\x02R\rradarCooldown\x1a@\n\x0bHeroHe\
    roInt\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x05R\x05value\x1aB\n\rHeroHeroFloat\x12\x1b\n\
    \tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x02R\x05value\x1a\x90\x02\n\x11DamageStatsByType\x12\x1f\n\x0b\
    damage_type\x18\x01\x20\x01(\x05R\ndamageType\x124\n\x16received_pre_red\
    uction\x18\x02\x20\x01(\x05R\x14receivedPreReduction\x126\n\x17received_\
    post_reduction\x18\x03\x20\x01(\x05R\x15receivedPostReduction\x124\n\x16\
    outgoing_pre_reduction\x18\x04\x20\x01(\x05R\x14outgoingPreReduction\x12\
    6\n\x17outgoing_post_reduction\x18\x05\x20\x01(\x05R\x15outgoingPostRedu\
    ction\x1a7\n\x0bHeroAbility\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    e\x12\x14\n\x05level\x18\x02\x20\x01(\x05R\x05level\x1a\xed\x13\n\x04Her\
    o\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\x1b\n\tplay\
    er_id\x18\x02\x20\x01(\x05R\x08playerId\x12\x17\n\x07team_id\x18\x03\x20\
    \x01(\x05R\x06teamId\x12\x12\n\x04hero\x18\x04\x20\x01(\tR\x04hero\x12\
    \x19\n\x08total_xp\x18\x05\x20\x01(\x05R\x07totalXp\x12(\n\x10bkb_charge\
    s_used\x18\x06\x20\x01(\x05R\x0ebkbChargesUsed\x12*\n\x11aeon_charges_us\
    ed\x18\x07\x20\x01(\x05R\x0faeonChargesUsed\x12#\n\rreliable_gold\x18\
    \x08\x20\x01(\x05R\x0creliableGold\x12'\n\x0funreliable_gold\x18\t\x20\
    \x01(\x05R\x0eunreliableGold\x12*\n\x11total_earned_gold\x18\n\x20\x01(\
    \x05R\x0ftotalEarnedGold\x12\x1f\n\x0bshared_gold\x18\x0b\x20\x01(\x05R\
    \nsharedGold\x12$\n\x0ehero_kill_gold\x18\x0c\x20\x01(\x05R\x0cheroKillG\
    old\x12&\n\x0fcreep_kill_gold\x18\r\x20\x01(\x05R\rcreepKillGold\x12*\n\
    \x11neutral_kill_gold\x18\x0e\x20\x01(\x05R\x0fneutralKillGold\x12!\n\
    \x0ccourier_gold\x18\x0f\x20\x01(\x05R\x0bcourierGold\x12\x1f\n\x0bbount\
    y_gold\x18\x10\x20\x01(\x05R\nbountyGold\x12\x1f\n\x0broshan_gold\x18\
    \x11\x20\x01(\x05R\nroshanGold\x12#\n\rbuilding_gold\x18\x12\x20\x01(\
    \x05R\x0cbuildingGold\x12\x1d\n\nother_gold\x18\x13\x20\x01(\x05R\tother\
    Gold\x12\x1f\n\x0bincome_gold\x18\x1a\x20\x01(\x05R\nincomeGold\x12$\n\
    \x0eward_kill_gold\x18\x1b\x20\x01(\x05R\x0cwardKillGold\x12!\n\x0cabili\
    ty_gold\x18\x1c\x20\x01(\x05R\x0babilityGold\x12\x16\n\x06denies\x18\x1d\
    \x20\x01(\x05R\x06denies\x12\x1b\n\tlast_hits\x18\x1e\x20\x01(\x05R\x08l\
    astHits\x12&\n\x0flast_hit_streak\x18\x1f\x20\x01(\x05R\rlastHitStreak\
    \x12,\n\x12last_hit_multikill\x18\x20\x20\x01(\x05R\x10lastHitMultikill\
    \x127\n\x18nearby_creep_death_count\x18!\x20\x01(\x05R\x15nearbyCreepDea\
    thCount\x12,\n\x12claimed_deny_count\x18\"\x20\x01(\x05R\x10claimedDenyC\
    ount\x12,\n\x12claimed_miss_count\x18#\x20\x01(\x05R\x10claimedMissCount\
    \x12\x1d\n\nmiss_count\x18$\x20\x01(\x05R\tmissCount\x122\n\x15buyback_c\
    ooldown_time\x18(\x20\x01(\x02R\x13buybackCooldownTime\x125\n\x17buyback\
    _gold_limit_time\x18)\x20\x01(\x02R\x14buybackGoldLimitTime\x12#\n\rstun\
    _duration\x18,\x20\x01(\x02R\x0cstunDuration\x12\x18\n\x07healing\x18-\
    \x20\x01(\x02R\x07healing\x12\x1f\n\x0btower_kills\x18.\x20\x01(\x05R\nt\
    owerKills\x12!\n\x0croshan_kills\x18/\x20\x01(\x05R\x0broshanKills\x122\
    \n\x15observer_wards_placed\x180\x20\x01(\x05R\x13observerWardsPlaced\
    \x12.\n\x13sentry_wards_placed\x181\x20\x01(\x05R\x11sentryWardsPlaced\
    \x12%\n\x0ecreeps_stacked\x182\x20\x01(\x05R\rcreepsStacked\x12#\n\rcamp\
    s_stacked\x183\x20\x01(\x05R\x0ccampsStacked\x12!\n\x0crune_pickups\x184\
    \x20\x01(\x05R\x0brunePickups\x121\n\x15gold_spent_on_support\x185\x20\
    \x01(\x05R\x12goldSpentOnSupport\x12\x1f\n\x0bhero_damage\x186\x20\x01(\
    \x05R\nheroDamage\x12'\n\x0fwards_purchased\x187\x20\x01(\x05R\x0ewardsP\
    urchased\x12'\n\x0fwards_destroyed\x188\x20\x01(\x05R\x0ewardsDestroyed\
    \x129\n\x19gold_spent_on_consumables\x18:\x20\x01(\x05R\x16goldSpentOnCo\
    nsumables\x12-\n\x13gold_spent_on_items\x18;\x20\x01(\x05R\x10goldSpentO\
    nItems\x123\n\x16gold_spent_on_buybacks\x18<\x20\x01(\x05R\x13goldSpentO\
    nBuybacks\x12+\n\x12gold_lost_to_death\x18=\x20\x01(\x05R\x0fgoldLostToD\
    eath\x12\x14\n\x05kills\x18>\x20\x01(\x05R\x05kills\x12\x18\n\x07assists\
    \x18?\x20\x01(\x05R\x07assists\x12\x16\n\x06deaths\x18@\x20\x01(\x05R\
    \x06deaths\x12\x1f\n\x0bkill_streak\x18A\x20\x01(\x05R\nkillStreak\x12'\
    \n\x0frespawn_seconds\x18D\x20\x01(\x05R\x0erespawnSeconds\x12*\n\x11las\
    t_buyback_time\x18E\x20\x01(\x05R\x0flastBuybackTime\x12.\n\x13first_blo\
    od_claimed\x18G\x20\x01(\x08R\x11firstBloodClaimed\x12*\n\x11first_blood\
    _given\x18H\x20\x01(\x08R\x0ffirstBloodGiven\x12!\n\x0cbounty_runes\x18I\
    \x20\x01(\x05R\x0bbountyRunes\x12+\n\x11outposts_captured\x18J\x20\x01(\
    \x05R\x10outpostsCaptured\x124\n\x08position\x18K\x20\x01(\x0b2\x18.dota\
    .CScenario_PositionR\x08position\x12D\n\x0benemy_kills\x18\x96\x01\x20\
    \x03(\x0b2\".dota.CMsgDotaScenario.HeroHeroIntR\nenemyKills\x12L\n\x0cda\
    mage_stats\x18\x97\x01\x20\x03(\x0b2(.dota.CMsgDotaScenario.DamageStatsB\
    yTypeR\x0bdamageStats\x12A\n\tabilities\x18\x98\x01\x20\x03(\x0b2\".dota\
    .CMsgDotaScenario.HeroAbilityR\tabilities\x1a\xbb\x01\n\x05Stock\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1f\n\x0bteam_number\x18\x02\
    \x20\x01(\x05R\nteamNumber\x12\x1b\n\tplayer_id\x18\x03\x20\x01(\x05R\
    \x08playerId\x12#\n\rcurrent_stock\x18\x04\x20\x01(\x05R\x0ccurrentStock\
    \x12\x1a\n\x08cooldown\x18\x05\x20\x01(\x02R\x08cooldown\x12\x1f\n\x0bbo\
    nus_stock\x18\x06\x20\x01(\x05R\nbonusStock\x1a\xab\x01\n\x08Building\
    \x12\x1f\n\x0bentity_name\x18\x01\x20\x01(\tR\nentityName\x12!\n\x0centi\
    ty_class\x18\x02\x20\x01(\tR\x0bentityClass\x12\x17\n\x07team_id\x18\x03\
    \x20\x01(\x05R\x06teamId\x12!\n\x0cis_destroyed\x18\x04\x20\x01(\x08R\
    \x0bisDestroyed\x12\x1f\n\x0bhealth_frac\x18\x05\x20\x01(\x02R\nhealthFr\
    ac\x1a\xeb\x01\n\x06Entity\x124\n\x07courier\x18\x01\x20\x01(\x0b2\x1a.d\
    ota.CScenarioEnt_CourierR\x07courier\x12(\n\x03npc\x18\x02\x20\x01(\x0b2\
    \x16.dota.CScenarioEnt_NPCR\x03npc\x12>\n\x0bspirit_bear\x18\x03\x20\x01\
    (\x0b2\x1d.dota.CScenarioEnt_SpiritBearR\nspiritBear\x12A\n\x0cdropped_i\
    tem\x18\x04\x20\x01(\x0b2\x1e.dota.CScenarioEnt_DroppedItemR\x0bdroppedI\
    tem\x1a\xc9\x02\n\x04Item\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12<\n\x08location\x18\x02\x20\x01(\x0b2\x20.dota.CMsgDotaScenario.Enti\
    tyRefR\x08location\x12\x19\n\x08owner_id\x18\x03\x20\x01(\x05R\x07ownerI\
    d\x12\x1b\n\titem_slot\x18\x04\x20\x01(\x05R\x08itemSlot\x12*\n\x11neutr\
    al_drop_team\x18\x05\x20\x01(\x05R\x0fneutralDropTeam\x12\x18\n\x07charg\
    es\x18\x06\x20\x01(\x05R\x07charges\x12+\n\x11secondary_charges\x18\x07\
    \x20\x01(\x05R\x10secondaryCharges\x12\x1a\n\x08lifetime\x18\x08\x20\x01\
    (\x02R\x08lifetime\x12(\n\x10stored_rune_type\x18\t\x20\x01(\x05R\x0esto\
    redRuneType\x1a\xce\x07\n\x08Modifier\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x128\n\x06parent\x18\x02\x20\x01(\x0b2\x20.dota.CMsgDotaScen\
    ario.EntityRefR\x06parent\x128\n\x06caster\x18\x03\x20\x01(\x0b2\x20.dot\
    a.CMsgDotaScenario.EntityRefR\x06caster\x12:\n\x07ability\x18\x04\x20\
    \x01(\x0b2\x20.dota.CMsgDotaScenario.EntityRefR\x07ability\x12\x1a\n\x08\
    duration\x18\x05\x20\x01(\x02R\x08duration\x12-\n\x12lifetime_remaining\
    \x18\x06\x20\x01(\x02R\x11lifetimeRemaining\x12\x1f\n\x0bstack_count\x18\
    \x07\x20\x01(\x05R\nstackCount\x125\n\x17create_even_if_existing\x18\x08\
    \x20\x01(\x08R\x14createEvenIfExisting\x122\n\x15create_without_caster\
    \x18\t\x20\x01(\x08R\x13createWithoutCaster\x124\n\x16create_without_abi\
    lity\x18\n\x20\x01(\x08R\x14createWithoutAbility\x128\n\x18moonshard_con\
    sumed_bonus\x18d\x20\x01(\x05R\x16moonshardConsumedBonus\x12P\n%moonshar\
    d_consumed_bonus_night_vision\x18e\x20\x01(\x05R!moonshardConsumedBonusN\
    ightVision\x12/\n\x13wardtruesight_range\x18n\x20\x01(\x05R\x12wardtrues\
    ightRange\x12j\n3ultimate_scepter_consumed_alchemist_bonus_all_stats\x18\
    x\x20\x01(\x05R-ultimateScepterConsumedAlchemistBonusAllStats\x12e\n0ult\
    imate_scepter_consumed_alchemist_bonus_health\x18y\x20\x01(\x05R+ultimat\
    eScepterConsumedAlchemistBonusHealth\x12a\n.ultimate_scepter_consumed_al\
    chemist_bonus_mana\x18z\x20\x01(\x05R)ultimateScepterConsumedAlchemistBo\
    nusManaB%Z#github.com/dotabuff/manta/dota;dotaJ\xefh\n\x07\x12\x05\0\0\
    \xe4\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\
    \x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\
    \n\t\n\x02\x03\0\x12\x03\x05\x07\x20\n\n\n\x02\x04\0\x12\x04\x07\0\n\x01\
    \n\n\n\x03\x04\0\x01\x12\x03\x07\x08\x1a\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    \x08\x08\x1d\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x08\x08\x10\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03\x08\x11\x16\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x08\x17\x18\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x08\x1b\x1c\n\x0b\n\x04\
    \x04\0\x02\x01\x12\x03\t\x08\x1d\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\t\
    \x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\t\x11\x16\n\x0c\n\x05\x04\
    \0\x02\x01\x01\x12\x03\t\x17\x18\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\t\
    \x1b\x1c\n\n\n\x02\x04\x01\x12\x04\x0c\0\x10\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03\x0c\x08#\n\x0b\n\x04\x04\x01\x02\0\x12\x03\r\x08&\n\x0c\n\x05\
    \x04\x01\x02\0\x04\x12\x03\r\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03\r\x11\x16\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\r\x17!\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03\r$%\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x0e\
    \x08!\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x0e\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x01\x05\x12\x03\x0e\x11\x16\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03\x0e\x17\x1c\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x0e\x1f\x20\
    \n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x0f\x08$\n\x0c\n\x05\x04\x01\x02\
    \x02\x04\x12\x03\x0f\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x0f\
    \x11\x16\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x0f\x17\x1f\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x03\x0f\"#\n\n\n\x02\x04\x02\x12\x04\x12\0\x16\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03\x12\x08\x1c\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03\x13\x08'\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03\x13\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x13\x11\x16\n\x0c\n\x05\x04\x02\x02\
    \0\x01\x12\x03\x13\x17\"\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x13%&\n\
    \x0b\n\x04\x04\x02\x02\x01\x12\x03\x14\x08+\n\x0c\n\x05\x04\x02\x02\x01\
    \x04\x12\x03\x14\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x14\x11\
    \x16\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x14\x17&\n\x0c\n\x05\x04\
    \x02\x02\x01\x03\x12\x03\x14)*\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x15\
    \x08$\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03\x15\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\x02\x05\x12\x03\x15\x11\x16\n\x0c\n\x05\x04\x02\x02\x02\x01\
    \x12\x03\x15\x17\x1f\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x15\"#\n\n\
    \n\x02\x04\x03\x12\x04\x18\0\x20\x01\n\n\n\x03\x04\x03\x01\x12\x03\x18\
    \x08\x18\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x19\x081\n\x0c\n\x05\x04\x03\
    \x02\0\x04\x12\x03\x19\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03\x19\
    \x11#\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x19$,\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03\x19/0\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\x1a\x08&\n\
    \x0c\n\x05\x04\x03\x02\x01\x04\x12\x03\x1a\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x01\x05\x12\x03\x1a\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\
    \x1a\x18!\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x1a$%\n\x0b\n\x04\x04\
    \x03\x02\x02\x12\x03\x1b\x08'\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03\
    \x1b\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03\x1b\x11\x16\n\x0c\n\
    \x05\x04\x03\x02\x02\x01\x12\x03\x1b\x17\"\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x03\x1b%&\n\x0b\n\x04\x04\x03\x02\x03\x12\x03\x1c\x08'\n\x0c\n\
    \x05\x04\x03\x02\x03\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\
    \x05\x12\x03\x1c\x11\x16\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03\x1c\x17\
    \"\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03\x1c%&\n\x0b\n\x04\x04\x03\x02\
    \x04\x12\x03\x1d\x08)\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03\x1d\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03\x1d\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x04\x01\x12\x03\x1d\x18#\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\
    \x03\x1d&(\n\x0b\n\x04\x04\x03\x02\x05\x12\x03\x1e\x08>\n\x0c\n\x05\x04\
    \x03\x02\x05\x04\x12\x03\x1e\x08\x10\n\x0c\n\x05\x04\x03\x02\x05\x06\x12\
    \x03\x1e\x11#\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03\x1e$8\n\x0c\n\x05\
    \x04\x03\x02\x05\x03\x12\x03\x1e;=\n\x0b\n\x04\x04\x03\x02\x06\x12\x03\
    \x1f\x08)\n\x0c\n\x05\x04\x03\x02\x06\x04\x12\x03\x1f\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\x06\x05\x12\x03\x1f\x11\x17\n\x0c\n\x05\x04\x03\x02\x06\
    \x01\x12\x03\x1f\x18#\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03\x1f&(\n\n\
    \n\x02\x04\x04\x12\x04\"\0%\x01\n\n\n\x03\x04\x04\x01\x12\x03\"\x08\x1f\
    \n\x0b\n\x04\x04\x04\x02\0\x12\x03#\x08$\n\x0c\n\x05\x04\x04\x02\0\x04\
    \x12\x03#\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03#\x11\x16\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03#\x17\x1f\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03#\"#\n\x0b\n\x04\x04\x04\x02\x01\x12\x03$\x08#\n\x0c\n\x05\x04\
    \x04\x02\x01\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\
    \x03$\x11\x16\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03$\x17\x1e\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03$!\"\n\n\n\x02\x04\x05\x12\x04'\0)\x01\n\
    \n\n\x03\x04\x05\x01\x12\x03'\x08\x20\n\x0b\n\x04\x04\x05\x02\0\x12\x03(\
    \x081\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\0\x06\x12\x03(\x11#\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03($,\n\x0c\
    \n\x05\x04\x05\x02\0\x03\x12\x03(/0\n\x0b\n\x02\x04\x06\x12\x05+\0\xe4\
    \x01\x01\n\n\n\x03\x04\x06\x01\x12\x03+\x08\x18\n\x0c\n\x04\x04\x06\x03\
    \0\x12\x04,\x082\t\n\x0c\n\x05\x04\x06\x03\0\x01\x12\x03,\x10\x19\n\r\n\
    \x06\x04\x06\x03\0\x02\0\x12\x03-\x10-\n\x0e\n\x07\x04\x06\x03\0\x02\0\
    \x04\x12\x03-\x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\0\x05\x12\x03-\x19\
    \x1e\n\x0e\n\x07\x04\x06\x03\0\x02\0\x01\x12\x03-\x1f(\n\x0e\n\x07\x04\
    \x06\x03\0\x02\0\x03\x12\x03-+,\n\r\n\x06\x04\x06\x03\0\x02\x01\x12\x03.\
    \x104\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x04\x12\x03.\x10\x18\n\x0e\n\x07\
    \x04\x06\x03\0\x02\x01\x05\x12\x03.\x19\x1e\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x01\x01\x12\x03.\x1f/\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x03\x12\x03\
    .23\n\r\n\x06\x04\x06\x03\0\x02\x02\x12\x03/\x10.\n\x0e\n\x07\x04\x06\
    \x03\0\x02\x02\x04\x12\x03/\x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x02\
    \x05\x12\x03/\x19\x1e\n\x0e\n\x07\x04\x06\x03\0\x02\x02\x01\x12\x03/\x1f\
    )\n\x0e\n\x07\x04\x06\x03\0\x02\x02\x03\x12\x03/,-\n\r\n\x06\x04\x06\x03\
    \0\x02\x03\x12\x030\x10)\n\x0e\n\x07\x04\x06\x03\0\x02\x03\x04\x12\x030\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x03\x05\x12\x030\x19\x1d\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x03\x01\x12\x030\x1e$\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x03\x03\x12\x030'(\n\r\n\x06\x04\x06\x03\0\x02\x04\x12\x031\x102\n\
    \x0e\n\x07\x04\x06\x03\0\x02\x04\x04\x12\x031\x10\x18\n\x0e\n\x07\x04\
    \x06\x03\0\x02\x04\x05\x12\x031\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\
    \x04\x01\x12\x031\x20,\n\x0e\n\x07\x04\x06\x03\0\x02\x04\x03\x12\x031/1\
    \n\x0c\n\x04\x04\x06\x03\x01\x12\x044\x08:\t\n\x0c\n\x05\x04\x06\x03\x01\
    \x01\x12\x034\x10\x14\n\r\n\x06\x04\x06\x03\x01\x02\0\x12\x035\x10-\n\
    \x0e\n\x07\x04\x06\x03\x01\x02\0\x04\x12\x035\x10\x18\n\x0e\n\x07\x04\
    \x06\x03\x01\x02\0\x05\x12\x035\x19\x1f\n\x0e\n\x07\x04\x06\x03\x01\x02\
    \0\x01\x12\x035\x20(\n\x0e\n\x07\x04\x06\x03\x01\x02\0\x03\x12\x035+,\n\
    \r\n\x06\x04\x06\x03\x01\x02\x01\x12\x036\x10-\n\x0e\n\x07\x04\x06\x03\
    \x01\x02\x01\x04\x12\x036\x10\x18\n\x0e\n\x07\x04\x06\x03\x01\x02\x01\
    \x05\x12\x036\x19\x1e\n\x0e\n\x07\x04\x06\x03\x01\x02\x01\x01\x12\x036\
    \x1f(\n\x0e\n\x07\x04\x06\x03\x01\x02\x01\x03\x12\x036+,\n\r\n\x06\x04\
    \x06\x03\x01\x02\x02\x12\x037\x10.\n\x0e\n\x07\x04\x06\x03\x01\x02\x02\
    \x04\x12\x037\x10\x18\n\x0e\n\x07\x04\x06\x03\x01\x02\x02\x05\x12\x037\
    \x19\x1e\n\x0e\n\x07\x04\x06\x03\x01\x02\x02\x01\x12\x037\x1f)\n\x0e\n\
    \x07\x04\x06\x03\x01\x02\x02\x03\x12\x037,-\n\r\n\x06\x04\x06\x03\x01\
    \x02\x03\x12\x038\x101\n\x0e\n\x07\x04\x06\x03\x01\x02\x03\x04\x12\x038\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\x01\x02\x03\x05\x12\x038\x19\x1e\n\x0e\
    \n\x07\x04\x06\x03\x01\x02\x03\x01\x12\x038\x1f,\n\x0e\n\x07\x04\x06\x03\
    \x01\x02\x03\x03\x12\x038/0\n\r\n\x06\x04\x06\x03\x01\x02\x04\x12\x039\
    \x10@\n\x0e\n\x07\x04\x06\x03\x01\x02\x04\x04\x12\x039\x10\x18\n\x0e\n\
    \x07\x04\x06\x03\x01\x02\x04\x06\x12\x039\x194\n\x0e\n\x07\x04\x06\x03\
    \x01\x02\x04\x01\x12\x0395;\n\x0e\n\x07\x04\x06\x03\x01\x02\x04\x03\x12\
    \x039>?\n\x0c\n\x04\x04\x06\x03\x02\x12\x04<\x08?\t\n\x0c\n\x05\x04\x06\
    \x03\x02\x01\x12\x03<\x10\x1f\n\r\n\x06\x04\x06\x03\x02\x02\0\x12\x03=\
    \x10)\n\x0e\n\x07\x04\x06\x03\x02\x02\0\x04\x12\x03=\x10\x18\n\x0e\n\x07\
    \x04\x06\x03\x02\x02\0\x05\x12\x03=\x19\x1f\n\x0e\n\x07\x04\x06\x03\x02\
    \x02\0\x01\x12\x03=\x20$\n\x0e\n\x07\x04\x06\x03\x02\x02\0\x03\x12\x03='\
    (\n\r\n\x06\x04\x06\x03\x02\x02\x01\x12\x03>\x10+\n\x0e\n\x07\x04\x06\
    \x03\x02\x02\x01\x04\x12\x03>\x10\x18\n\x0e\n\x07\x04\x06\x03\x02\x02\
    \x01\x05\x12\x03>\x19\x1d\n\x0e\n\x07\x04\x06\x03\x02\x02\x01\x01\x12\
    \x03>\x1e&\n\x0e\n\x07\x04\x06\x03\x02\x02\x01\x03\x12\x03>)*\n\x0c\n\
    \x04\x04\x06\x03\x03\x12\x04A\x08I\t\n\x0c\n\x05\x04\x06\x03\x03\x01\x12\
    \x03A\x10\x14\n\r\n\x06\x04\x06\x03\x03\x02\0\x12\x03B\x10/\n\x0e\n\x07\
    \x04\x06\x03\x03\x02\0\x04\x12\x03B\x10\x18\n\x0e\n\x07\x04\x06\x03\x03\
    \x02\0\x05\x12\x03B\x19\x1e\n\x0e\n\x07\x04\x06\x03\x03\x02\0\x01\x12\
    \x03B\x1f*\n\x0e\n\x07\x04\x06\x03\x03\x02\0\x03\x12\x03B-.\n\r\n\x06\
    \x04\x06\x03\x03\x02\x01\x12\x03C\x10L\n\x0e\n\x07\x04\x06\x03\x03\x02\
    \x01\x04\x12\x03C\x10\x18\n\x0e\n\x07\x04\x06\x03\x03\x02\x01\x06\x12\
    \x03C\x199\n\x0e\n\x07\x04\x06\x03\x03\x02\x01\x01\x12\x03C:G\n\x0e\n\
    \x07\x04\x06\x03\x03\x02\x01\x03\x12\x03CJK\n\r\n\x06\x04\x06\x03\x03\
    \x02\x02\x12\x03D\x10.\n\x0e\n\x07\x04\x06\x03\x03\x02\x02\x04\x12\x03D\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\x03\x02\x02\x05\x12\x03D\x19\x1e\n\x0e\
    \n\x07\x04\x06\x03\x03\x02\x02\x01\x12\x03D\x1f)\n\x0e\n\x07\x04\x06\x03\
    \x03\x02\x02\x03\x12\x03D,-\n\r\n\x06\x04\x06\x03\x03\x02\x03\x12\x03E\
    \x10/\n\x0e\n\x07\x04\x06\x03\x03\x02\x03\x04\x12\x03E\x10\x18\n\x0e\n\
    \x07\x04\x06\x03\x03\x02\x03\x05\x12\x03E\x19\x1e\n\x0e\n\x07\x04\x06\
    \x03\x03\x02\x03\x01\x12\x03E\x1f*\n\x0e\n\x07\x04\x06\x03\x03\x02\x03\
    \x03\x12\x03E-.\n\r\n\x06\x04\x06\x03\x03\x02\x04\x12\x03F\x102\n\x0e\n\
    \x07\x04\x06\x03\x03\x02\x04\x04\x12\x03F\x10\x18\n\x0e\n\x07\x04\x06\
    \x03\x03\x02\x04\x05\x12\x03F\x19\x1e\n\x0e\n\x07\x04\x06\x03\x03\x02\
    \x04\x01\x12\x03F\x1f-\n\x0e\n\x07\x04\x06\x03\x03\x02\x04\x03\x12\x03F0\
    1\n\r\n\x06\x04\x06\x03\x03\x02\x05\x12\x03G\x102\n\x0e\n\x07\x04\x06\
    \x03\x03\x02\x05\x04\x12\x03G\x10\x18\n\x0e\n\x07\x04\x06\x03\x03\x02\
    \x05\x05\x12\x03G\x19\x1e\n\x0e\n\x07\x04\x06\x03\x03\x02\x05\x01\x12\
    \x03G\x1f-\n\x0e\n\x07\x04\x06\x03\x03\x02\x05\x03\x12\x03G01\n\r\n\x06\
    \x04\x06\x03\x03\x02\x06\x12\x03H\x102\n\x0e\n\x07\x04\x06\x03\x03\x02\
    \x06\x04\x12\x03H\x10\x18\n\x0e\n\x07\x04\x06\x03\x03\x02\x06\x05\x12\
    \x03H\x19\x1e\n\x0e\n\x07\x04\x06\x03\x03\x02\x06\x01\x12\x03H\x1f-\n\
    \x0e\n\x07\x04\x06\x03\x03\x02\x06\x03\x12\x03H01\n\x0c\n\x04\x04\x06\
    \x03\x04\x12\x04K\x08N\t\n\x0c\n\x05\x04\x06\x03\x04\x01\x12\x03K\x10\
    \x1b\n\r\n\x06\x04\x06\x03\x04\x02\0\x12\x03L\x10-\n\x0e\n\x07\x04\x06\
    \x03\x04\x02\0\x04\x12\x03L\x10\x18\n\x0e\n\x07\x04\x06\x03\x04\x02\0\
    \x05\x12\x03L\x19\x1e\n\x0e\n\x07\x04\x06\x03\x04\x02\0\x01\x12\x03L\x1f\
    (\n\x0e\n\x07\x04\x06\x03\x04\x02\0\x03\x12\x03L+,\n\r\n\x06\x04\x06\x03\
    \x04\x02\x01\x12\x03M\x10)\n\x0e\n\x07\x04\x06\x03\x04\x02\x01\x04\x12\
    \x03M\x10\x18\n\x0e\n\x07\x04\x06\x03\x04\x02\x01\x05\x12\x03M\x19\x1e\n\
    \x0e\n\x07\x04\x06\x03\x04\x02\x01\x01\x12\x03M\x1f$\n\x0e\n\x07\x04\x06\
    \x03\x04\x02\x01\x03\x12\x03M'(\n\x0c\n\x04\x04\x06\x03\x05\x12\x04P\x08\
    S\t\n\x0c\n\x05\x04\x06\x03\x05\x01\x12\x03P\x10\x1d\n\r\n\x06\x04\x06\
    \x03\x05\x02\0\x12\x03Q\x10-\n\x0e\n\x07\x04\x06\x03\x05\x02\0\x04\x12\
    \x03Q\x10\x18\n\x0e\n\x07\x04\x06\x03\x05\x02\0\x05\x12\x03Q\x19\x1e\n\
    \x0e\n\x07\x04\x06\x03\x05\x02\0\x01\x12\x03Q\x1f(\n\x0e\n\x07\x04\x06\
    \x03\x05\x02\0\x03\x12\x03Q+,\n\r\n\x06\x04\x06\x03\x05\x02\x01\x12\x03R\
    \x10)\n\x0e\n\x07\x04\x06\x03\x05\x02\x01\x04\x12\x03R\x10\x18\n\x0e\n\
    \x07\x04\x06\x03\x05\x02\x01\x05\x12\x03R\x19\x1e\n\x0e\n\x07\x04\x06\
    \x03\x05\x02\x01\x01\x12\x03R\x1f$\n\x0e\n\x07\x04\x06\x03\x05\x02\x01\
    \x03\x12\x03R'(\n\x0c\n\x04\x04\x06\x03\x06\x12\x04U\x08[\t\n\x0c\n\x05\
    \x04\x06\x03\x06\x01\x12\x03U\x10!\n\r\n\x06\x04\x06\x03\x06\x02\0\x12\
    \x03V\x10/\n\x0e\n\x07\x04\x06\x03\x06\x02\0\x04\x12\x03V\x10\x18\n\x0e\
    \n\x07\x04\x06\x03\x06\x02\0\x05\x12\x03V\x19\x1e\n\x0e\n\x07\x04\x06\
    \x03\x06\x02\0\x01\x12\x03V\x1f*\n\x0e\n\x07\x04\x06\x03\x06\x02\0\x03\
    \x12\x03V-.\n\r\n\x06\x04\x06\x03\x06\x02\x01\x12\x03W\x10:\n\x0e\n\x07\
    \x04\x06\x03\x06\x02\x01\x04\x12\x03W\x10\x18\n\x0e\n\x07\x04\x06\x03\
    \x06\x02\x01\x05\x12\x03W\x19\x1e\n\x0e\n\x07\x04\x06\x03\x06\x02\x01\
    \x01\x12\x03W\x1f5\n\x0e\n\x07\x04\x06\x03\x06\x02\x01\x03\x12\x03W89\n\
    \r\n\x06\x04\x06\x03\x06\x02\x02\x12\x03X\x10;\n\x0e\n\x07\x04\x06\x03\
    \x06\x02\x02\x04\x12\x03X\x10\x18\n\x0e\n\x07\x04\x06\x03\x06\x02\x02\
    \x05\x12\x03X\x19\x1e\n\x0e\n\x07\x04\x06\x03\x06\x02\x02\x01\x12\x03X\
    \x1f6\n\x0e\n\x07\x04\x06\x03\x06\x02\x02\x03\x12\x03X9:\n\r\n\x06\x04\
    \x06\x03\x06\x02\x03\x12\x03Y\x10:\n\x0e\n\x07\x04\x06\x03\x06\x02\x03\
    \x04\x12\x03Y\x10\x18\n\x0e\n\x07\x04\x06\x03\x06\x02\x03\x05\x12\x03Y\
    \x19\x1e\n\x0e\n\x07\x04\x06\x03\x06\x02\x03\x01\x12\x03Y\x1f5\n\x0e\n\
    \x07\x04\x06\x03\x06\x02\x03\x03\x12\x03Y89\n\r\n\x06\x04\x06\x03\x06\
    \x02\x04\x12\x03Z\x10;\n\x0e\n\x07\x04\x06\x03\x06\x02\x04\x04\x12\x03Z\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\x06\x02\x04\x05\x12\x03Z\x19\x1e\n\x0e\
    \n\x07\x04\x06\x03\x06\x02\x04\x01\x12\x03Z\x1f6\n\x0e\n\x07\x04\x06\x03\
    \x06\x02\x04\x03\x12\x03Z9:\n\x0c\n\x04\x04\x06\x03\x07\x12\x04]\x08`\t\
    \n\x0c\n\x05\x04\x06\x03\x07\x01\x12\x03]\x10\x1b\n\r\n\x06\x04\x06\x03\
    \x07\x02\0\x12\x03^\x10)\n\x0e\n\x07\x04\x06\x03\x07\x02\0\x04\x12\x03^\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\x07\x02\0\x05\x12\x03^\x19\x1f\n\x0e\n\
    \x07\x04\x06\x03\x07\x02\0\x01\x12\x03^\x20$\n\x0e\n\x07\x04\x06\x03\x07\
    \x02\0\x03\x12\x03^'(\n\r\n\x06\x04\x06\x03\x07\x02\x01\x12\x03_\x10)\n\
    \x0e\n\x07\x04\x06\x03\x07\x02\x01\x04\x12\x03_\x10\x18\n\x0e\n\x07\x04\
    \x06\x03\x07\x02\x01\x05\x12\x03_\x19\x1e\n\x0e\n\x07\x04\x06\x03\x07\
    \x02\x01\x01\x12\x03_\x1f$\n\x0e\n\x07\x04\x06\x03\x07\x02\x01\x03\x12\
    \x03_'(\n\r\n\x04\x04\x06\x03\x08\x12\x05b\x08\xa2\x01\t\n\x0c\n\x05\x04\
    \x06\x03\x08\x01\x12\x03b\x10\x14\n\r\n\x06\x04\x06\x03\x08\x02\0\x12\
    \x03c\x10.\n\x0e\n\x07\x04\x06\x03\x08\x02\0\x04\x12\x03c\x10\x18\n\x0e\
    \n\x07\x04\x06\x03\x08\x02\0\x05\x12\x03c\x19\x20\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\0\x01\x12\x03c!)\n\x0e\n\x07\x04\x06\x03\x08\x02\0\x03\x12\
    \x03c,-\n\r\n\x06\x04\x06\x03\x08\x02\x01\x12\x03d\x10-\n\x0e\n\x07\x04\
    \x06\x03\x08\x02\x01\x04\x12\x03d\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\
    \x02\x01\x05\x12\x03d\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x01\x01\
    \x12\x03d\x1f(\n\x0e\n\x07\x04\x06\x03\x08\x02\x01\x03\x12\x03d+,\n\r\n\
    \x06\x04\x06\x03\x08\x02\x02\x12\x03e\x10+\n\x0e\n\x07\x04\x06\x03\x08\
    \x02\x02\x04\x12\x03e\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x02\x05\
    \x12\x03e\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x02\x01\x12\x03e\x1f&\
    \n\x0e\n\x07\x04\x06\x03\x08\x02\x02\x03\x12\x03e)*\n\r\n\x06\x04\x06\
    \x03\x08\x02\x03\x12\x03f\x10)\n\x0e\n\x07\x04\x06\x03\x08\x02\x03\x04\
    \x12\x03f\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x03\x05\x12\x03f\x19\
    \x1f\n\x0e\n\x07\x04\x06\x03\x08\x02\x03\x01\x12\x03f\x20$\n\x0e\n\x07\
    \x04\x06\x03\x08\x02\x03\x03\x12\x03f'(\n\r\n\x06\x04\x06\x03\x08\x02\
    \x04\x12\x03g\x10,\n\x0e\n\x07\x04\x06\x03\x08\x02\x04\x04\x12\x03g\x10\
    \x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x04\x05\x12\x03g\x19\x1e\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\x04\x01\x12\x03g\x1f'\n\x0e\n\x07\x04\x06\x03\
    \x08\x02\x04\x03\x12\x03g*+\n\r\n\x06\x04\x06\x03\x08\x02\x05\x12\x03h\
    \x104\n\x0e\n\x07\x04\x06\x03\x08\x02\x05\x04\x12\x03h\x10\x18\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\x05\x05\x12\x03h\x19\x1e\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x05\x01\x12\x03h\x1f/\n\x0e\n\x07\x04\x06\x03\x08\x02\x05\
    \x03\x12\x03h23\n\r\n\x06\x04\x06\x03\x08\x02\x06\x12\x03i\x105\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\x06\x04\x12\x03i\x10\x18\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x06\x05\x12\x03i\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x06\x01\x12\x03i\x1f0\n\x0e\n\x07\x04\x06\x03\x08\x02\x06\x03\x12\x03i3\
    4\n\r\n\x06\x04\x06\x03\x08\x02\x07\x12\x03j\x101\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x07\x04\x12\x03j\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x07\x05\x12\x03j\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x07\x01\x12\
    \x03j\x1f,\n\x0e\n\x07\x04\x06\x03\x08\x02\x07\x03\x12\x03j/0\n\r\n\x06\
    \x04\x06\x03\x08\x02\x08\x12\x03k\x103\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x08\x04\x12\x03k\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x08\x05\x12\
    \x03k\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x08\x01\x12\x03k\x1f.\n\
    \x0e\n\x07\x04\x06\x03\x08\x02\x08\x03\x12\x03k12\n\r\n\x06\x04\x06\x03\
    \x08\x02\t\x12\x03l\x106\n\x0e\n\x07\x04\x06\x03\x08\x02\t\x04\x12\x03l\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\t\x05\x12\x03l\x19\x1e\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\t\x01\x12\x03l\x1f0\n\x0e\n\x07\x04\x06\x03\x08\
    \x02\t\x03\x12\x03l35\n\r\n\x06\x04\x06\x03\x08\x02\n\x12\x03m\x100\n\
    \x0e\n\x07\x04\x06\x03\x08\x02\n\x04\x12\x03m\x10\x18\n\x0e\n\x07\x04\
    \x06\x03\x08\x02\n\x05\x12\x03m\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \n\x01\x12\x03m\x1f*\n\x0e\n\x07\x04\x06\x03\x08\x02\n\x03\x12\x03m-/\n\
    \r\n\x06\x04\x06\x03\x08\x02\x0b\x12\x03n\x103\n\x0e\n\x07\x04\x06\x03\
    \x08\x02\x0b\x04\x12\x03n\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x0b\
    \x05\x12\x03n\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x0b\x01\x12\x03n\
    \x1f-\n\x0e\n\x07\x04\x06\x03\x08\x02\x0b\x03\x12\x03n02\n\r\n\x06\x04\
    \x06\x03\x08\x02\x0c\x12\x03o\x104\n\x0e\n\x07\x04\x06\x03\x08\x02\x0c\
    \x04\x12\x03o\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x0c\x05\x12\x03o\
    \x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x0c\x01\x12\x03o\x1f.\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\x0c\x03\x12\x03o13\n\r\n\x06\x04\x06\x03\x08\
    \x02\r\x12\x03p\x106\n\x0e\n\x07\x04\x06\x03\x08\x02\r\x04\x12\x03p\x10\
    \x18\n\x0e\n\x07\x04\x06\x03\x08\x02\r\x05\x12\x03p\x19\x1e\n\x0e\n\x07\
    \x04\x06\x03\x08\x02\r\x01\x12\x03p\x1f0\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \r\x03\x12\x03p35\n\r\n\x06\x04\x06\x03\x08\x02\x0e\x12\x03q\x101\n\x0e\
    \n\x07\x04\x06\x03\x08\x02\x0e\x04\x12\x03q\x10\x18\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x0e\x05\x12\x03q\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x0e\x01\x12\x03q\x1f+\n\x0e\n\x07\x04\x06\x03\x08\x02\x0e\x03\x12\x03q.\
    0\n\r\n\x06\x04\x06\x03\x08\x02\x0f\x12\x03r\x100\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x0f\x04\x12\x03r\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x0f\x05\x12\x03r\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x0f\x01\x12\
    \x03r\x1f*\n\x0e\n\x07\x04\x06\x03\x08\x02\x0f\x03\x12\x03r-/\n\r\n\x06\
    \x04\x06\x03\x08\x02\x10\x12\x03s\x100\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x10\x04\x12\x03s\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x10\x05\x12\
    \x03s\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x10\x01\x12\x03s\x1f*\n\
    \x0e\n\x07\x04\x06\x03\x08\x02\x10\x03\x12\x03s-/\n\r\n\x06\x04\x06\x03\
    \x08\x02\x11\x12\x03t\x102\n\x0e\n\x07\x04\x06\x03\x08\x02\x11\x04\x12\
    \x03t\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x11\x05\x12\x03t\x19\x1e\n\
    \x0e\n\x07\x04\x06\x03\x08\x02\x11\x01\x12\x03t\x1f,\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x11\x03\x12\x03t/1\n\r\n\x06\x04\x06\x03\x08\x02\x12\x12\
    \x03u\x10/\n\x0e\n\x07\x04\x06\x03\x08\x02\x12\x04\x12\x03u\x10\x18\n\
    \x0e\n\x07\x04\x06\x03\x08\x02\x12\x05\x12\x03u\x19\x1e\n\x0e\n\x07\x04\
    \x06\x03\x08\x02\x12\x01\x12\x03u\x1f)\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x12\x03\x12\x03u,.\n\r\n\x06\x04\x06\x03\x08\x02\x13\x12\x03v\x100\n\
    \x0e\n\x07\x04\x06\x03\x08\x02\x13\x04\x12\x03v\x10\x18\n\x0e\n\x07\x04\
    \x06\x03\x08\x02\x13\x05\x12\x03v\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\
    \x02\x13\x01\x12\x03v\x1f*\n\x0e\n\x07\x04\x06\x03\x08\x02\x13\x03\x12\
    \x03v-/\n\r\n\x06\x04\x06\x03\x08\x02\x14\x12\x03w\x103\n\x0e\n\x07\x04\
    \x06\x03\x08\x02\x14\x04\x12\x03w\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\
    \x02\x14\x05\x12\x03w\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x14\x01\
    \x12\x03w\x1f-\n\x0e\n\x07\x04\x06\x03\x08\x02\x14\x03\x12\x03w02\n\r\n\
    \x06\x04\x06\x03\x08\x02\x15\x12\x03x\x101\n\x0e\n\x07\x04\x06\x03\x08\
    \x02\x15\x04\x12\x03x\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x15\x05\
    \x12\x03x\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x15\x01\x12\x03x\x1f+\
    \n\x0e\n\x07\x04\x06\x03\x08\x02\x15\x03\x12\x03x.0\n\r\n\x06\x04\x06\
    \x03\x08\x02\x16\x12\x03y\x10+\n\x0e\n\x07\x04\x06\x03\x08\x02\x16\x04\
    \x12\x03y\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x16\x05\x12\x03y\x19\
    \x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x16\x01\x12\x03y\x1f%\n\x0e\n\x07\
    \x04\x06\x03\x08\x02\x16\x03\x12\x03y(*\n\r\n\x06\x04\x06\x03\x08\x02\
    \x17\x12\x03z\x10.\n\x0e\n\x07\x04\x06\x03\x08\x02\x17\x04\x12\x03z\x10\
    \x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x17\x05\x12\x03z\x19\x1e\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\x17\x01\x12\x03z\x1f(\n\x0e\n\x07\x04\x06\x03\
    \x08\x02\x17\x03\x12\x03z+-\n\r\n\x06\x04\x06\x03\x08\x02\x18\x12\x03{\
    \x104\n\x0e\n\x07\x04\x06\x03\x08\x02\x18\x04\x12\x03{\x10\x18\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\x18\x05\x12\x03{\x19\x1e\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x18\x01\x12\x03{\x1f.\n\x0e\n\x07\x04\x06\x03\x08\x02\x18\
    \x03\x12\x03{13\n\r\n\x06\x04\x06\x03\x08\x02\x19\x12\x03|\x107\n\x0e\n\
    \x07\x04\x06\x03\x08\x02\x19\x04\x12\x03|\x10\x18\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x19\x05\x12\x03|\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x19\x01\x12\x03|\x1f1\n\x0e\n\x07\x04\x06\x03\x08\x02\x19\x03\x12\x03|4\
    6\n\r\n\x06\x04\x06\x03\x08\x02\x1a\x12\x03}\x10=\n\x0e\n\x07\x04\x06\
    \x03\x08\x02\x1a\x04\x12\x03}\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x1a\x05\x12\x03}\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x1a\x01\x12\
    \x03}\x1f7\n\x0e\n\x07\x04\x06\x03\x08\x02\x1a\x03\x12\x03}:<\n\r\n\x06\
    \x04\x06\x03\x08\x02\x1b\x12\x03~\x107\n\x0e\n\x07\x04\x06\x03\x08\x02\
    \x1b\x04\x12\x03~\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x1b\x05\x12\
    \x03~\x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x1b\x01\x12\x03~\x1f1\n\
    \x0e\n\x07\x04\x06\x03\x08\x02\x1b\x03\x12\x03~46\n\r\n\x06\x04\x06\x03\
    \x08\x02\x1c\x12\x03\x7f\x107\n\x0e\n\x07\x04\x06\x03\x08\x02\x1c\x04\
    \x12\x03\x7f\x10\x18\n\x0e\n\x07\x04\x06\x03\x08\x02\x1c\x05\x12\x03\x7f\
    \x19\x1e\n\x0e\n\x07\x04\x06\x03\x08\x02\x1c\x01\x12\x03\x7f\x1f1\n\x0e\
    \n\x07\x04\x06\x03\x08\x02\x1c\x03\x12\x03\x7f46\n\x0e\n\x06\x04\x06\x03\
    \x08\x02\x1d\x12\x04\x80\x01\x10/\n\x0f\n\x07\x04\x06\x03\x08\x02\x1d\
    \x04\x12\x04\x80\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02\x1d\x05\x12\
    \x04\x80\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02\x1d\x01\x12\x04\x80\
    \x01\x1f)\n\x0f\n\x07\x04\x06\x03\x08\x02\x1d\x03\x12\x04\x80\x01,.\n\
    \x0e\n\x06\x04\x06\x03\x08\x02\x1e\x12\x04\x81\x01\x10:\n\x0f\n\x07\x04\
    \x06\x03\x08\x02\x1e\x04\x12\x04\x81\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\
    \x08\x02\x1e\x05\x12\x04\x81\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02\
    \x1e\x01\x12\x04\x81\x01\x1f4\n\x0f\n\x07\x04\x06\x03\x08\x02\x1e\x03\
    \x12\x04\x81\x0179\n\x0e\n\x06\x04\x06\x03\x08\x02\x1f\x12\x04\x82\x01\
    \x10<\n\x0f\n\x07\x04\x06\x03\x08\x02\x1f\x04\x12\x04\x82\x01\x10\x18\n\
    \x0f\n\x07\x04\x06\x03\x08\x02\x1f\x05\x12\x04\x82\x01\x19\x1e\n\x0f\n\
    \x07\x04\x06\x03\x08\x02\x1f\x01\x12\x04\x82\x01\x1f6\n\x0f\n\x07\x04\
    \x06\x03\x08\x02\x1f\x03\x12\x04\x82\x019;\n\x0e\n\x06\x04\x06\x03\x08\
    \x02\x20\x12\x04\x83\x01\x102\n\x0f\n\x07\x04\x06\x03\x08\x02\x20\x04\
    \x12\x04\x83\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02\x20\x05\x12\x04\
    \x83\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02\x20\x01\x12\x04\x83\x01\
    \x1f,\n\x0f\n\x07\x04\x06\x03\x08\x02\x20\x03\x12\x04\x83\x01/1\n\x0e\n\
    \x06\x04\x06\x03\x08\x02!\x12\x04\x84\x01\x10,\n\x0f\n\x07\x04\x06\x03\
    \x08\x02!\x04\x12\x04\x84\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02!\
    \x05\x12\x04\x84\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02!\x01\x12\
    \x04\x84\x01\x1f&\n\x0f\n\x07\x04\x06\x03\x08\x02!\x03\x12\x04\x84\x01)+\
    \n\x0e\n\x06\x04\x06\x03\x08\x02\"\x12\x04\x85\x01\x100\n\x0f\n\x07\x04\
    \x06\x03\x08\x02\"\x04\x12\x04\x85\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\
    \x08\x02\"\x05\x12\x04\x85\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02\"\
    \x01\x12\x04\x85\x01\x1f*\n\x0f\n\x07\x04\x06\x03\x08\x02\"\x03\x12\x04\
    \x85\x01-/\n\x0e\n\x06\x04\x06\x03\x08\x02#\x12\x04\x86\x01\x101\n\x0f\n\
    \x07\x04\x06\x03\x08\x02#\x04\x12\x04\x86\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\x08\x02#\x05\x12\x04\x86\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\
    \x08\x02#\x01\x12\x04\x86\x01\x1f+\n\x0f\n\x07\x04\x06\x03\x08\x02#\x03\
    \x12\x04\x86\x01.0\n\x0e\n\x06\x04\x06\x03\x08\x02$\x12\x04\x87\x01\x10:\
    \n\x0f\n\x07\x04\x06\x03\x08\x02$\x04\x12\x04\x87\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\x08\x02$\x05\x12\x04\x87\x01\x19\x1e\n\x0f\n\x07\x04\
    \x06\x03\x08\x02$\x01\x12\x04\x87\x01\x1f4\n\x0f\n\x07\x04\x06\x03\x08\
    \x02$\x03\x12\x04\x87\x0179\n\x0e\n\x06\x04\x06\x03\x08\x02%\x12\x04\x88\
    \x01\x108\n\x0f\n\x07\x04\x06\x03\x08\x02%\x04\x12\x04\x88\x01\x10\x18\n\
    \x0f\n\x07\x04\x06\x03\x08\x02%\x05\x12\x04\x88\x01\x19\x1e\n\x0f\n\x07\
    \x04\x06\x03\x08\x02%\x01\x12\x04\x88\x01\x1f2\n\x0f\n\x07\x04\x06\x03\
    \x08\x02%\x03\x12\x04\x88\x0157\n\x0e\n\x06\x04\x06\x03\x08\x02&\x12\x04\
    \x89\x01\x103\n\x0f\n\x07\x04\x06\x03\x08\x02&\x04\x12\x04\x89\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\x08\x02&\x05\x12\x04\x89\x01\x19\x1e\n\x0f\
    \n\x07\x04\x06\x03\x08\x02&\x01\x12\x04\x89\x01\x1f-\n\x0f\n\x07\x04\x06\
    \x03\x08\x02&\x03\x12\x04\x89\x0102\n\x0e\n\x06\x04\x06\x03\x08\x02'\x12\
    \x04\x8a\x01\x102\n\x0f\n\x07\x04\x06\x03\x08\x02'\x04\x12\x04\x8a\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02'\x05\x12\x04\x8a\x01\x19\x1e\n\
    \x0f\n\x07\x04\x06\x03\x08\x02'\x01\x12\x04\x8a\x01\x1f,\n\x0f\n\x07\x04\
    \x06\x03\x08\x02'\x03\x12\x04\x8a\x01/1\n\x0e\n\x06\x04\x06\x03\x08\x02(\
    \x12\x04\x8b\x01\x101\n\x0f\n\x07\x04\x06\x03\x08\x02(\x04\x12\x04\x8b\
    \x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02(\x05\x12\x04\x8b\x01\x19\
    \x1e\n\x0f\n\x07\x04\x06\x03\x08\x02(\x01\x12\x04\x8b\x01\x1f+\n\x0f\n\
    \x07\x04\x06\x03\x08\x02(\x03\x12\x04\x8b\x01.0\n\x0e\n\x06\x04\x06\x03\
    \x08\x02)\x12\x04\x8c\x01\x10:\n\x0f\n\x07\x04\x06\x03\x08\x02)\x04\x12\
    \x04\x8c\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02)\x05\x12\x04\x8c\
    \x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02)\x01\x12\x04\x8c\x01\x1f4\n\
    \x0f\n\x07\x04\x06\x03\x08\x02)\x03\x12\x04\x8c\x0179\n\x0e\n\x06\x04\
    \x06\x03\x08\x02*\x12\x04\x8d\x01\x100\n\x0f\n\x07\x04\x06\x03\x08\x02*\
    \x04\x12\x04\x8d\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02*\x05\x12\
    \x04\x8d\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02*\x01\x12\x04\x8d\
    \x01\x1f*\n\x0f\n\x07\x04\x06\x03\x08\x02*\x03\x12\x04\x8d\x01-/\n\x0e\n\
    \x06\x04\x06\x03\x08\x02+\x12\x04\x8e\x01\x104\n\x0f\n\x07\x04\x06\x03\
    \x08\x02+\x04\x12\x04\x8e\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02+\
    \x05\x12\x04\x8e\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02+\x01\x12\
    \x04\x8e\x01\x1f.\n\x0f\n\x07\x04\x06\x03\x08\x02+\x03\x12\x04\x8e\x0113\
    \n\x0e\n\x06\x04\x06\x03\x08\x02,\x12\x04\x8f\x01\x104\n\x0f\n\x07\x04\
    \x06\x03\x08\x02,\x04\x12\x04\x8f\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\
    \x08\x02,\x05\x12\x04\x8f\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x02,\
    \x01\x12\x04\x8f\x01\x1f.\n\x0f\n\x07\x04\x06\x03\x08\x02,\x03\x12\x04\
    \x8f\x0113\n\x0e\n\x06\x04\x06\x03\x08\x02-\x12\x04\x90\x01\x10>\n\x0f\n\
    \x07\x04\x06\x03\x08\x02-\x04\x12\x04\x90\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\x08\x02-\x05\x12\x04\x90\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\
    \x08\x02-\x01\x12\x04\x90\x01\x1f8\n\x0f\n\x07\x04\x06\x03\x08\x02-\x03\
    \x12\x04\x90\x01;=\n\x0e\n\x06\x04\x06\x03\x08\x02.\x12\x04\x91\x01\x108\
    \n\x0f\n\x07\x04\x06\x03\x08\x02.\x04\x12\x04\x91\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\x08\x02.\x05\x12\x04\x91\x01\x19\x1e\n\x0f\n\x07\x04\
    \x06\x03\x08\x02.\x01\x12\x04\x91\x01\x1f2\n\x0f\n\x07\x04\x06\x03\x08\
    \x02.\x03\x12\x04\x91\x0157\n\x0e\n\x06\x04\x06\x03\x08\x02/\x12\x04\x92\
    \x01\x10;\n\x0f\n\x07\x04\x06\x03\x08\x02/\x04\x12\x04\x92\x01\x10\x18\n\
    \x0f\n\x07\x04\x06\x03\x08\x02/\x05\x12\x04\x92\x01\x19\x1e\n\x0f\n\x07\
    \x04\x06\x03\x08\x02/\x01\x12\x04\x92\x01\x1f5\n\x0f\n\x07\x04\x06\x03\
    \x08\x02/\x03\x12\x04\x92\x018:\n\x0e\n\x06\x04\x06\x03\x08\x020\x12\x04\
    \x93\x01\x107\n\x0f\n\x07\x04\x06\x03\x08\x020\x04\x12\x04\x93\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\x08\x020\x05\x12\x04\x93\x01\x19\x1e\n\x0f\
    \n\x07\x04\x06\x03\x08\x020\x01\x12\x04\x93\x01\x1f1\n\x0f\n\x07\x04\x06\
    \x03\x08\x020\x03\x12\x04\x93\x0146\n\x0e\n\x06\x04\x06\x03\x08\x021\x12\
    \x04\x94\x01\x10*\n\x0f\n\x07\x04\x06\x03\x08\x021\x04\x12\x04\x94\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x021\x05\x12\x04\x94\x01\x19\x1e\n\
    \x0f\n\x07\x04\x06\x03\x08\x021\x01\x12\x04\x94\x01\x1f$\n\x0f\n\x07\x04\
    \x06\x03\x08\x021\x03\x12\x04\x94\x01')\n\x0e\n\x06\x04\x06\x03\x08\x022\
    \x12\x04\x95\x01\x10,\n\x0f\n\x07\x04\x06\x03\x08\x022\x04\x12\x04\x95\
    \x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x022\x05\x12\x04\x95\x01\x19\
    \x1e\n\x0f\n\x07\x04\x06\x03\x08\x022\x01\x12\x04\x95\x01\x1f&\n\x0f\n\
    \x07\x04\x06\x03\x08\x022\x03\x12\x04\x95\x01)+\n\x0e\n\x06\x04\x06\x03\
    \x08\x023\x12\x04\x96\x01\x10+\n\x0f\n\x07\x04\x06\x03\x08\x023\x04\x12\
    \x04\x96\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x023\x05\x12\x04\x96\
    \x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x023\x01\x12\x04\x96\x01\x1f%\n\
    \x0f\n\x07\x04\x06\x03\x08\x023\x03\x12\x04\x96\x01(*\n\x0e\n\x06\x04\
    \x06\x03\x08\x024\x12\x04\x97\x01\x100\n\x0f\n\x07\x04\x06\x03\x08\x024\
    \x04\x12\x04\x97\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x024\x05\x12\
    \x04\x97\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x024\x01\x12\x04\x97\
    \x01\x1f*\n\x0f\n\x07\x04\x06\x03\x08\x024\x03\x12\x04\x97\x01-/\n\x0e\n\
    \x06\x04\x06\x03\x08\x025\x12\x04\x98\x01\x104\n\x0f\n\x07\x04\x06\x03\
    \x08\x025\x04\x12\x04\x98\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x025\
    \x05\x12\x04\x98\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x025\x01\x12\
    \x04\x98\x01\x1f.\n\x0f\n\x07\x04\x06\x03\x08\x025\x03\x12\x04\x98\x0113\
    \n\x0e\n\x06\x04\x06\x03\x08\x026\x12\x04\x99\x01\x106\n\x0f\n\x07\x04\
    \x06\x03\x08\x026\x04\x12\x04\x99\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\
    \x08\x026\x05\x12\x04\x99\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x08\x026\
    \x01\x12\x04\x99\x01\x1f0\n\x0f\n\x07\x04\x06\x03\x08\x026\x03\x12\x04\
    \x99\x0135\n\x0e\n\x06\x04\x06\x03\x08\x027\x12\x04\x9a\x01\x107\n\x0f\n\
    \x07\x04\x06\x03\x08\x027\x04\x12\x04\x9a\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\x08\x027\x05\x12\x04\x9a\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\
    \x08\x027\x01\x12\x04\x9a\x01\x1e1\n\x0f\n\x07\x04\x06\x03\x08\x027\x03\
    \x12\x04\x9a\x0146\n\x0e\n\x06\x04\x06\x03\x08\x028\x12\x04\x9b\x01\x105\
    \n\x0f\n\x07\x04\x06\x03\x08\x028\x04\x12\x04\x9b\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\x08\x028\x05\x12\x04\x9b\x01\x19\x1d\n\x0f\n\x07\x04\
    \x06\x03\x08\x028\x01\x12\x04\x9b\x01\x1e/\n\x0f\n\x07\x04\x06\x03\x08\
    \x028\x03\x12\x04\x9b\x0124\n\x0e\n\x06\x04\x06\x03\x08\x029\x12\x04\x9c\
    \x01\x101\n\x0f\n\x07\x04\x06\x03\x08\x029\x04\x12\x04\x9c\x01\x10\x18\n\
    \x0f\n\x07\x04\x06\x03\x08\x029\x05\x12\x04\x9c\x01\x19\x1e\n\x0f\n\x07\
    \x04\x06\x03\x08\x029\x01\x12\x04\x9c\x01\x1f+\n\x0f\n\x07\x04\x06\x03\
    \x08\x029\x03\x12\x04\x9c\x01.0\n\x0e\n\x06\x04\x06\x03\x08\x02:\x12\x04\
    \x9d\x01\x106\n\x0f\n\x07\x04\x06\x03\x08\x02:\x04\x12\x04\x9d\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\x08\x02:\x05\x12\x04\x9d\x01\x19\x1e\n\x0f\
    \n\x07\x04\x06\x03\x08\x02:\x01\x12\x04\x9d\x01\x1f0\n\x0f\n\x07\x04\x06\
    \x03\x08\x02:\x03\x12\x04\x9d\x0135\n\x0e\n\x06\x04\x06\x03\x08\x02;\x12\
    \x04\x9e\x01\x10:\n\x0f\n\x07\x04\x06\x03\x08\x02;\x04\x12\x04\x9e\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02;\x06\x12\x04\x9e\x01\x19+\n\x0f\
    \n\x07\x04\x06\x03\x08\x02;\x01\x12\x04\x9e\x01,4\n\x0f\n\x07\x04\x06\
    \x03\x08\x02;\x03\x12\x04\x9e\x0179\n\x0e\n\x06\x04\x06\x03\x08\x02<\x12\
    \x04\x9f\x01\x10H\n\x0f\n\x07\x04\x06\x03\x08\x02<\x04\x12\x04\x9f\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02<\x06\x12\x04\x9f\x01\x195\n\x0f\
    \n\x07\x04\x06\x03\x08\x02<\x01\x12\x04\x9f\x016A\n\x0f\n\x07\x04\x06\
    \x03\x08\x02<\x03\x12\x04\x9f\x01DG\n\x0e\n\x06\x04\x06\x03\x08\x02=\x12\
    \x04\xa0\x01\x10O\n\x0f\n\x07\x04\x06\x03\x08\x02=\x04\x12\x04\xa0\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02=\x06\x12\x04\xa0\x01\x19;\n\x0f\
    \n\x07\x04\x06\x03\x08\x02=\x01\x12\x04\xa0\x01<H\n\x0f\n\x07\x04\x06\
    \x03\x08\x02=\x03\x12\x04\xa0\x01KN\n\x0e\n\x06\x04\x06\x03\x08\x02>\x12\
    \x04\xa1\x01\x10F\n\x0f\n\x07\x04\x06\x03\x08\x02>\x04\x12\x04\xa1\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\x08\x02>\x06\x12\x04\xa1\x01\x195\n\x0f\
    \n\x07\x04\x06\x03\x08\x02>\x01\x12\x04\xa1\x016?\n\x0f\n\x07\x04\x06\
    \x03\x08\x02>\x03\x12\x04\xa1\x01BE\n\x0e\n\x04\x04\x06\x03\t\x12\x06\
    \xa4\x01\x08\xab\x01\t\n\r\n\x05\x04\x06\x03\t\x01\x12\x04\xa4\x01\x10\
    \x15\n\x0e\n\x06\x04\x06\x03\t\x02\0\x12\x04\xa5\x01\x10)\n\x0f\n\x07\
    \x04\x06\x03\t\x02\0\x04\x12\x04\xa5\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\
    \t\x02\0\x05\x12\x04\xa5\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\t\x02\0\x01\
    \x12\x04\xa5\x01\x20$\n\x0f\n\x07\x04\x06\x03\t\x02\0\x03\x12\x04\xa5\
    \x01'(\n\x0e\n\x06\x04\x06\x03\t\x02\x01\x12\x04\xa6\x01\x10/\n\x0f\n\
    \x07\x04\x06\x03\t\x02\x01\x04\x12\x04\xa6\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\t\x02\x01\x05\x12\x04\xa6\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\t\
    \x02\x01\x01\x12\x04\xa6\x01\x1f*\n\x0f\n\x07\x04\x06\x03\t\x02\x01\x03\
    \x12\x04\xa6\x01-.\n\x0e\n\x06\x04\x06\x03\t\x02\x02\x12\x04\xa7\x01\x10\
    -\n\x0f\n\x07\x04\x06\x03\t\x02\x02\x04\x12\x04\xa7\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\t\x02\x02\x05\x12\x04\xa7\x01\x19\x1e\n\x0f\n\x07\x04\
    \x06\x03\t\x02\x02\x01\x12\x04\xa7\x01\x1f(\n\x0f\n\x07\x04\x06\x03\t\
    \x02\x02\x03\x12\x04\xa7\x01+,\n\x0e\n\x06\x04\x06\x03\t\x02\x03\x12\x04\
    \xa8\x01\x101\n\x0f\n\x07\x04\x06\x03\t\x02\x03\x04\x12\x04\xa8\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\t\x02\x03\x05\x12\x04\xa8\x01\x19\x1e\n\x0f\
    \n\x07\x04\x06\x03\t\x02\x03\x01\x12\x04\xa8\x01\x1f,\n\x0f\n\x07\x04\
    \x06\x03\t\x02\x03\x03\x12\x04\xa8\x01/0\n\x0e\n\x06\x04\x06\x03\t\x02\
    \x04\x12\x04\xa9\x01\x10,\n\x0f\n\x07\x04\x06\x03\t\x02\x04\x04\x12\x04\
    \xa9\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\t\x02\x04\x05\x12\x04\xa9\x01\
    \x19\x1e\n\x0f\n\x07\x04\x06\x03\t\x02\x04\x01\x12\x04\xa9\x01\x1f'\n\
    \x0f\n\x07\x04\x06\x03\t\x02\x04\x03\x12\x04\xa9\x01*+\n\x0e\n\x06\x04\
    \x06\x03\t\x02\x05\x12\x04\xaa\x01\x10/\n\x0f\n\x07\x04\x06\x03\t\x02\
    \x05\x04\x12\x04\xaa\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\t\x02\x05\x05\
    \x12\x04\xaa\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\t\x02\x05\x01\x12\x04\
    \xaa\x01\x1f*\n\x0f\n\x07\x04\x06\x03\t\x02\x05\x03\x12\x04\xaa\x01-.\n\
    \x0e\n\x04\x04\x06\x03\n\x12\x06\xad\x01\x08\xb3\x01\t\n\r\n\x05\x04\x06\
    \x03\n\x01\x12\x04\xad\x01\x10\x18\n\x0e\n\x06\x04\x06\x03\n\x02\0\x12\
    \x04\xae\x01\x100\n\x0f\n\x07\x04\x06\x03\n\x02\0\x04\x12\x04\xae\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\n\x02\0\x05\x12\x04\xae\x01\x19\x1f\n\
    \x0f\n\x07\x04\x06\x03\n\x02\0\x01\x12\x04\xae\x01\x20+\n\x0f\n\x07\x04\
    \x06\x03\n\x02\0\x03\x12\x04\xae\x01./\n\x0e\n\x06\x04\x06\x03\n\x02\x01\
    \x12\x04\xaf\x01\x101\n\x0f\n\x07\x04\x06\x03\n\x02\x01\x04\x12\x04\xaf\
    \x01\x10\x18\n\x0f\n\x07\x04\x06\x03\n\x02\x01\x05\x12\x04\xaf\x01\x19\
    \x1f\n\x0f\n\x07\x04\x06\x03\n\x02\x01\x01\x12\x04\xaf\x01\x20,\n\x0f\n\
    \x07\x04\x06\x03\n\x02\x01\x03\x12\x04\xaf\x01/0\n\x0e\n\x06\x04\x06\x03\
    \n\x02\x02\x12\x04\xb0\x01\x10+\n\x0f\n\x07\x04\x06\x03\n\x02\x02\x04\
    \x12\x04\xb0\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\n\x02\x02\x05\x12\x04\
    \xb0\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\n\x02\x02\x01\x12\x04\xb0\x01\
    \x1f&\n\x0f\n\x07\x04\x06\x03\n\x02\x02\x03\x12\x04\xb0\x01)*\n\x0e\n\
    \x06\x04\x06\x03\n\x02\x03\x12\x04\xb1\x01\x10/\n\x0f\n\x07\x04\x06\x03\
    \n\x02\x03\x04\x12\x04\xb1\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\n\x02\x03\
    \x05\x12\x04\xb1\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\n\x02\x03\x01\x12\
    \x04\xb1\x01\x1e*\n\x0f\n\x07\x04\x06\x03\n\x02\x03\x03\x12\x04\xb1\x01-\
    .\n\x0e\n\x06\x04\x06\x03\n\x02\x04\x12\x04\xb2\x01\x10/\n\x0f\n\x07\x04\
    \x06\x03\n\x02\x04\x04\x12\x04\xb2\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\n\
    \x02\x04\x05\x12\x04\xb2\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\n\x02\x04\
    \x01\x12\x04\xb2\x01\x1f*\n\x0f\n\x07\x04\x06\x03\n\x02\x04\x03\x12\x04\
    \xb2\x01-.\n\x0e\n\x04\x04\x06\x03\x0b\x12\x06\xb5\x01\x08\xba\x01\t\n\r\
    \n\x05\x04\x06\x03\x0b\x01\x12\x04\xb5\x01\x10\x16\n\x0e\n\x06\x04\x06\
    \x03\x0b\x02\0\x12\x04\xb6\x01\x10:\n\x0f\n\x07\x04\x06\x03\x0b\x02\0\
    \x04\x12\x04\xb6\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x0b\x02\0\x06\x12\
    \x04\xb6\x01\x19-\n\x0f\n\x07\x04\x06\x03\x0b\x02\0\x01\x12\x04\xb6\x01.\
    5\n\x0f\n\x07\x04\x06\x03\x0b\x02\0\x03\x12\x04\xb6\x0189\n\x0e\n\x06\
    \x04\x06\x03\x0b\x02\x01\x12\x04\xb7\x01\x102\n\x0f\n\x07\x04\x06\x03\
    \x0b\x02\x01\x04\x12\x04\xb7\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x0b\x02\
    \x01\x06\x12\x04\xb7\x01\x19)\n\x0f\n\x07\x04\x06\x03\x0b\x02\x01\x01\
    \x12\x04\xb7\x01*-\n\x0f\n\x07\x04\x06\x03\x0b\x02\x01\x03\x12\x04\xb7\
    \x0101\n\x0e\n\x06\x04\x06\x03\x0b\x02\x02\x12\x04\xb8\x01\x10A\n\x0f\n\
    \x07\x04\x06\x03\x0b\x02\x02\x04\x12\x04\xb8\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\x0b\x02\x02\x06\x12\x04\xb8\x01\x190\n\x0f\n\x07\x04\x06\x03\
    \x0b\x02\x02\x01\x12\x04\xb8\x011<\n\x0f\n\x07\x04\x06\x03\x0b\x02\x02\
    \x03\x12\x04\xb8\x01?@\n\x0e\n\x06\x04\x06\x03\x0b\x02\x03\x12\x04\xb9\
    \x01\x10C\n\x0f\n\x07\x04\x06\x03\x0b\x02\x03\x04\x12\x04\xb9\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\x0b\x02\x03\x06\x12\x04\xb9\x01\x191\n\x0f\
    \n\x07\x04\x06\x03\x0b\x02\x03\x01\x12\x04\xb9\x012>\n\x0f\n\x07\x04\x06\
    \x03\x0b\x02\x03\x03\x12\x04\xb9\x01AB\n\x0e\n\x04\x04\x06\x03\x0c\x12\
    \x06\xbc\x01\x08\xc6\x01\t\n\r\n\x05\x04\x06\x03\x0c\x01\x12\x04\xbc\x01\
    \x10\x14\n\x0e\n\x06\x04\x06\x03\x0c\x02\0\x12\x04\xbd\x01\x10)\n\x0f\n\
    \x07\x04\x06\x03\x0c\x02\0\x04\x12\x04\xbd\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\x0c\x02\0\x05\x12\x04\xbd\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\
    \x0c\x02\0\x01\x12\x04\xbd\x01\x20$\n\x0f\n\x07\x04\x06\x03\x0c\x02\0\
    \x03\x12\x04\xbd\x01'(\n\x0e\n\x06\x04\x06\x03\x0c\x02\x01\x12\x04\xbe\
    \x01\x10A\n\x0f\n\x07\x04\x06\x03\x0c\x02\x01\x04\x12\x04\xbe\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\x0c\x02\x01\x06\x12\x04\xbe\x01\x193\n\x0f\
    \n\x07\x04\x06\x03\x0c\x02\x01\x01\x12\x04\xbe\x014<\n\x0f\n\x07\x04\x06\
    \x03\x0c\x02\x01\x03\x12\x04\xbe\x01?@\n\x0e\n\x06\x04\x06\x03\x0c\x02\
    \x02\x12\x04\xbf\x01\x10,\n\x0f\n\x07\x04\x06\x03\x0c\x02\x02\x04\x12\
    \x04\xbf\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x0c\x02\x02\x05\x12\x04\xbf\
    \x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x0c\x02\x02\x01\x12\x04\xbf\x01\x1f\
    '\n\x0f\n\x07\x04\x06\x03\x0c\x02\x02\x03\x12\x04\xbf\x01*+\n\x0e\n\x06\
    \x04\x06\x03\x0c\x02\x03\x12\x04\xc0\x01\x10-\n\x0f\n\x07\x04\x06\x03\
    \x0c\x02\x03\x04\x12\x04\xc0\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x0c\x02\
    \x03\x05\x12\x04\xc0\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x0c\x02\x03\x01\
    \x12\x04\xc0\x01\x1f(\n\x0f\n\x07\x04\x06\x03\x0c\x02\x03\x03\x12\x04\
    \xc0\x01+,\n\x0e\n\x06\x04\x06\x03\x0c\x02\x04\x12\x04\xc1\x01\x105\n\
    \x0f\n\x07\x04\x06\x03\x0c\x02\x04\x04\x12\x04\xc1\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\x0c\x02\x04\x05\x12\x04\xc1\x01\x19\x1e\n\x0f\n\x07\x04\
    \x06\x03\x0c\x02\x04\x01\x12\x04\xc1\x01\x1f0\n\x0f\n\x07\x04\x06\x03\
    \x0c\x02\x04\x03\x12\x04\xc1\x0134\n\x0e\n\x06\x04\x06\x03\x0c\x02\x05\
    \x12\x04\xc2\x01\x10+\n\x0f\n\x07\x04\x06\x03\x0c\x02\x05\x04\x12\x04\
    \xc2\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x0c\x02\x05\x05\x12\x04\xc2\x01\
    \x19\x1e\n\x0f\n\x07\x04\x06\x03\x0c\x02\x05\x01\x12\x04\xc2\x01\x1f&\n\
    \x0f\n\x07\x04\x06\x03\x0c\x02\x05\x03\x12\x04\xc2\x01)*\n\x0e\n\x06\x04\
    \x06\x03\x0c\x02\x06\x12\x04\xc3\x01\x105\n\x0f\n\x07\x04\x06\x03\x0c\
    \x02\x06\x04\x12\x04\xc3\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\x0c\x02\x06\
    \x05\x12\x04\xc3\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\x0c\x02\x06\x01\x12\
    \x04\xc3\x01\x1f0\n\x0f\n\x07\x04\x06\x03\x0c\x02\x06\x03\x12\x04\xc3\
    \x0134\n\x0e\n\x06\x04\x06\x03\x0c\x02\x07\x12\x04\xc4\x01\x10,\n\x0f\n\
    \x07\x04\x06\x03\x0c\x02\x07\x04\x12\x04\xc4\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\x0c\x02\x07\x05\x12\x04\xc4\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\
    \x0c\x02\x07\x01\x12\x04\xc4\x01\x1f'\n\x0f\n\x07\x04\x06\x03\x0c\x02\
    \x07\x03\x12\x04\xc4\x01*+\n\x0e\n\x06\x04\x06\x03\x0c\x02\x08\x12\x04\
    \xc5\x01\x104\n\x0f\n\x07\x04\x06\x03\x0c\x02\x08\x04\x12\x04\xc5\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\x0c\x02\x08\x05\x12\x04\xc5\x01\x19\x1e\
    \n\x0f\n\x07\x04\x06\x03\x0c\x02\x08\x01\x12\x04\xc5\x01\x1f/\n\x0f\n\
    \x07\x04\x06\x03\x0c\x02\x08\x03\x12\x04\xc5\x0123\n\x0e\n\x04\x04\x06\
    \x03\r\x12\x06\xc8\x01\x08\xd9\x01\t\n\r\n\x05\x04\x06\x03\r\x01\x12\x04\
    \xc8\x01\x10\x18\n\x0e\n\x06\x04\x06\x03\r\x02\0\x12\x04\xc9\x01\x10)\n\
    \x0f\n\x07\x04\x06\x03\r\x02\0\x04\x12\x04\xc9\x01\x10\x18\n\x0f\n\x07\
    \x04\x06\x03\r\x02\0\x05\x12\x04\xc9\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\
    \r\x02\0\x01\x12\x04\xc9\x01\x20$\n\x0f\n\x07\x04\x06\x03\r\x02\0\x03\
    \x12\x04\xc9\x01'(\n\x0e\n\x06\x04\x06\x03\r\x02\x01\x12\x04\xca\x01\x10\
    ?\n\x0f\n\x07\x04\x06\x03\r\x02\x01\x04\x12\x04\xca\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\r\x02\x01\x06\x12\x04\xca\x01\x193\n\x0f\n\x07\x04\x06\
    \x03\r\x02\x01\x01\x12\x04\xca\x014:\n\x0f\n\x07\x04\x06\x03\r\x02\x01\
    \x03\x12\x04\xca\x01=>\n\x0e\n\x06\x04\x06\x03\r\x02\x02\x12\x04\xcb\x01\
    \x10?\n\x0f\n\x07\x04\x06\x03\r\x02\x02\x04\x12\x04\xcb\x01\x10\x18\n\
    \x0f\n\x07\x04\x06\x03\r\x02\x02\x06\x12\x04\xcb\x01\x193\n\x0f\n\x07\
    \x04\x06\x03\r\x02\x02\x01\x12\x04\xcb\x014:\n\x0f\n\x07\x04\x06\x03\r\
    \x02\x02\x03\x12\x04\xcb\x01=>\n\x0e\n\x06\x04\x06\x03\r\x02\x03\x12\x04\
    \xcc\x01\x10@\n\x0f\n\x07\x04\x06\x03\r\x02\x03\x04\x12\x04\xcc\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\r\x02\x03\x06\x12\x04\xcc\x01\x193\n\x0f\n\
    \x07\x04\x06\x03\r\x02\x03\x01\x12\x04\xcc\x014;\n\x0f\n\x07\x04\x06\x03\
    \r\x02\x03\x03\x12\x04\xcc\x01>?\n\x0e\n\x06\x04\x06\x03\r\x02\x04\x12\
    \x04\xcd\x01\x10,\n\x0f\n\x07\x04\x06\x03\r\x02\x04\x04\x12\x04\xcd\x01\
    \x10\x18\n\x0f\n\x07\x04\x06\x03\r\x02\x04\x05\x12\x04\xcd\x01\x19\x1e\n\
    \x0f\n\x07\x04\x06\x03\r\x02\x04\x01\x12\x04\xcd\x01\x1f'\n\x0f\n\x07\
    \x04\x06\x03\r\x02\x04\x03\x12\x04\xcd\x01*+\n\x0e\n\x06\x04\x06\x03\r\
    \x02\x05\x12\x04\xce\x01\x106\n\x0f\n\x07\x04\x06\x03\r\x02\x05\x04\x12\
    \x04\xce\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\r\x02\x05\x05\x12\x04\xce\
    \x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\r\x02\x05\x01\x12\x04\xce\x01\x1f1\
    \n\x0f\n\x07\x04\x06\x03\r\x02\x05\x03\x12\x04\xce\x0145\n\x0e\n\x06\x04\
    \x06\x03\r\x02\x06\x12\x04\xcf\x01\x10/\n\x0f\n\x07\x04\x06\x03\r\x02\
    \x06\x04\x12\x04\xcf\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\r\x02\x06\x05\
    \x12\x04\xcf\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\r\x02\x06\x01\x12\x04\
    \xcf\x01\x1f*\n\x0f\n\x07\x04\x06\x03\r\x02\x06\x03\x12\x04\xcf\x01-.\n\
    \x0e\n\x06\x04\x06\x03\r\x02\x07\x12\x04\xd0\x01\x10:\n\x0f\n\x07\x04\
    \x06\x03\r\x02\x07\x04\x12\x04\xd0\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\r\
    \x02\x07\x05\x12\x04\xd0\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\r\x02\x07\
    \x01\x12\x04\xd0\x01\x1e5\n\x0f\n\x07\x04\x06\x03\r\x02\x07\x03\x12\x04\
    \xd0\x0189\n\x0e\n\x06\x04\x06\x03\r\x02\x08\x12\x04\xd1\x01\x108\n\x0f\
    \n\x07\x04\x06\x03\r\x02\x08\x04\x12\x04\xd1\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\r\x02\x08\x05\x12\x04\xd1\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\r\
    \x02\x08\x01\x12\x04\xd1\x01\x1e3\n\x0f\n\x07\x04\x06\x03\r\x02\x08\x03\
    \x12\x04\xd1\x0167\n\x0e\n\x06\x04\x06\x03\r\x02\t\x12\x04\xd2\x01\x10:\
    \n\x0f\n\x07\x04\x06\x03\r\x02\t\x04\x12\x04\xd2\x01\x10\x18\n\x0f\n\x07\
    \x04\x06\x03\r\x02\t\x05\x12\x04\xd2\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\
    \r\x02\t\x01\x12\x04\xd2\x01\x1e4\n\x0f\n\x07\x04\x06\x03\r\x02\t\x03\
    \x12\x04\xd2\x0179\n\x0e\n\x06\x04\x06\x03\r\x02\n\x12\x04\xd3\x01\x10>\
    \n\x0f\n\x07\x04\x06\x03\r\x02\n\x04\x12\x04\xd3\x01\x10\x18\n\x0f\n\x07\
    \x04\x06\x03\r\x02\n\x05\x12\x04\xd3\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\
    \r\x02\n\x01\x12\x04\xd3\x01\x1f7\n\x0f\n\x07\x04\x06\x03\r\x02\n\x03\
    \x12\x04\xd3\x01:=\n\x0e\n\x06\x04\x06\x03\r\x02\x0b\x12\x04\xd4\x01\x10\
    K\n\x0f\n\x07\x04\x06\x03\r\x02\x0b\x04\x12\x04\xd4\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\r\x02\x0b\x05\x12\x04\xd4\x01\x19\x1e\n\x0f\n\x07\x04\
    \x06\x03\r\x02\x0b\x01\x12\x04\xd4\x01\x1fD\n\x0f\n\x07\x04\x06\x03\r\
    \x02\x0b\x03\x12\x04\xd4\x01GJ\n\x0e\n\x06\x04\x06\x03\r\x02\x0c\x12\x04\
    \xd5\x01\x109\n\x0f\n\x07\x04\x06\x03\r\x02\x0c\x04\x12\x04\xd5\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\r\x02\x0c\x05\x12\x04\xd5\x01\x19\x1e\n\x0f\
    \n\x07\x04\x06\x03\r\x02\x0c\x01\x12\x04\xd5\x01\x1f2\n\x0f\n\x07\x04\
    \x06\x03\r\x02\x0c\x03\x12\x04\xd5\x0158\n\x0e\n\x06\x04\x06\x03\r\x02\r\
    \x12\x04\xd6\x01\x10Y\n\x0f\n\x07\x04\x06\x03\r\x02\r\x04\x12\x04\xd6\
    \x01\x10\x18\n\x0f\n\x07\x04\x06\x03\r\x02\r\x05\x12\x04\xd6\x01\x19\x1e\
    \n\x0f\n\x07\x04\x06\x03\r\x02\r\x01\x12\x04\xd6\x01\x1fR\n\x0f\n\x07\
    \x04\x06\x03\r\x02\r\x03\x12\x04\xd6\x01UX\n\x0e\n\x06\x04\x06\x03\r\x02\
    \x0e\x12\x04\xd7\x01\x10V\n\x0f\n\x07\x04\x06\x03\r\x02\x0e\x04\x12\x04\
    \xd7\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\r\x02\x0e\x05\x12\x04\xd7\x01\
    \x19\x1e\n\x0f\n\x07\x04\x06\x03\r\x02\x0e\x01\x12\x04\xd7\x01\x1fO\n\
    \x0f\n\x07\x04\x06\x03\r\x02\x0e\x03\x12\x04\xd7\x01RU\n\x0e\n\x06\x04\
    \x06\x03\r\x02\x0f\x12\x04\xd8\x01\x10T\n\x0f\n\x07\x04\x06\x03\r\x02\
    \x0f\x04\x12\x04\xd8\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\r\x02\x0f\x05\
    \x12\x04\xd8\x01\x19\x1e\n\x0f\n\x07\x04\x06\x03\r\x02\x0f\x01\x12\x04\
    \xd8\x01\x1fM\n\x0f\n\x07\x04\x06\x03\r\x02\x0f\x03\x12\x04\xd8\x01PS\n\
    \x0c\n\x04\x04\x06\x02\0\x12\x04\xdb\x01\x08%\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xdb\x01\
    \x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xdb\x01\x18\x20\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\xdb\x01#$\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\
    \xdc\x01\x080\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xdc\x01\x08\x10\n\r\
    \n\x05\x04\x06\x02\x01\x06\x12\x04\xdc\x01\x11&\n\r\n\x05\x04\x06\x02\
    \x01\x01\x12\x04\xdc\x01'+\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xdc\x01\
    ./\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xdd\x01\x081\n\r\n\x05\x04\x06\
    \x02\x02\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\x06\x02\x02\x06\x12\
    \x04\xdd\x01\x11&\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xdd\x01',\n\r\n\
    \x05\x04\x06\x02\x02\x03\x12\x04\xdd\x01/0\n\x0c\n\x04\x04\x06\x02\x03\
    \x12\x04\xde\x01\x082\n\r\n\x05\x04\x06\x02\x03\x04\x12\x04\xde\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\xde\x01\x11&\n\r\n\x05\x04\
    \x06\x02\x03\x01\x12\x04\xde\x01'-\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\
    \xde\x0101\n\x0c\n\x04\x04\x06\x02\x04\x12\x04\xdf\x01\x082\n\r\n\x05\
    \x04\x06\x02\x04\x04\x12\x04\xdf\x01\x08\x10\n\r\n\x05\x04\x06\x02\x04\
    \x06\x12\x04\xdf\x01\x11'\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\xdf\x01(\
    -\n\r\n\x05\x04\x06\x02\x04\x03\x12\x04\xdf\x0101\n\x0c\n\x04\x04\x06\
    \x02\x05\x12\x04\xe0\x01\x089\n\r\n\x05\x04\x06\x02\x05\x04\x12\x04\xe0\
    \x01\x08\x10\n\r\n\x05\x04\x06\x02\x05\x06\x12\x04\xe0\x01\x11*\n\r\n\
    \x05\x04\x06\x02\x05\x01\x12\x04\xe0\x01+4\n\r\n\x05\x04\x06\x02\x05\x03\
    \x12\x04\xe0\x0178\n\x0c\n\x04\x04\x06\x02\x06\x12\x04\xe1\x01\x086\n\r\
    \n\x05\x04\x06\x02\x06\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x06\x02\
    \x06\x06\x12\x04\xe1\x01\x11(\n\r\n\x05\x04\x06\x02\x06\x01\x12\x04\xe1\
    \x01)1\n\r\n\x05\x04\x06\x02\x06\x03\x12\x04\xe1\x0145\n\x0c\n\x04\x04\
    \x06\x02\x07\x12\x04\xe2\x01\x081\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04\
    \xe2\x01\x08\x10\n\r\n\x05\x04\x06\x02\x07\x06\x12\x04\xe2\x01\x11&\n\r\
    \n\x05\x04\x06\x02\x07\x01\x12\x04\xe2\x01',\n\r\n\x05\x04\x06\x02\x07\
    \x03\x12\x04\xe2\x01/0\n\x0c\n\x04\x04\x06\x02\x08\x12\x04\xe3\x01\x089\
    \n\r\n\x05\x04\x06\x02\x08\x04\x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x06\
    \x02\x08\x06\x12\x04\xe3\x01\x11*\n\r\n\x05\x04\x06\x02\x08\x01\x12\x04\
    \xe3\x01+4\n\r\n\x05\x04\x06\x02\x08\x03\x12\x04\xe3\x0178\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(CScenario_Position::generated_message_descriptor_data());
            messages.push(CScenarioGame_RoshanSpawner::generated_message_descriptor_data());
            messages.push(CScenarioEnt_Courier::generated_message_descriptor_data());
            messages.push(CScenarioEnt_NPC::generated_message_descriptor_data());
            messages.push(CScenarioEnt_SpiritBear::generated_message_descriptor_data());
            messages.push(CScenarioEnt_DroppedItem::generated_message_descriptor_data());
            messages.push(CMsgDotaScenario::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::EntityRef::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Game::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::TeamNeutralItem::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Team::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::HeroHeroInt::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::HeroHeroFloat::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::DamageStatsByType::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::HeroAbility::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Hero::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Stock::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Building::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Entity::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Item::generated_message_descriptor_data());
            messages.push(cmsg_dota_scenario::Modifier::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
