// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_clientmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_MapPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_MapPing {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_MapPing.location_ping)
    pub location_ping: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_LocationPing>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_MapPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_MapPing {
    fn default() -> &'a CDOTAClientMsg_MapPing {
        <CDOTAClientMsg_MapPing as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_MapPing {
    pub fn new() -> CDOTAClientMsg_MapPing {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_LocationPing>(
            "location_ping",
            |m: &CDOTAClientMsg_MapPing| { &m.location_ping },
            |m: &mut CDOTAClientMsg_MapPing| { &mut m.location_ping },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_MapPing>(
            "CDOTAClientMsg_MapPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_MapPing {
    const NAME: &'static str = "CDOTAClientMsg_MapPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location_ping)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.location_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.location_ping.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_MapPing {
        CDOTAClientMsg_MapPing::new()
    }

    fn clear(&mut self) {
        self.location_ping.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_MapPing {
        static instance: CDOTAClientMsg_MapPing = CDOTAClientMsg_MapPing {
            location_ping: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_MapPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_MapPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_MapPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_MapPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ItemAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ItemAlert.item_alert)
    pub item_alert: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_ItemAlert>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ItemAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ItemAlert {
    fn default() -> &'a CDOTAClientMsg_ItemAlert {
        <CDOTAClientMsg_ItemAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ItemAlert {
    pub fn new() -> CDOTAClientMsg_ItemAlert {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_ItemAlert>(
            "item_alert",
            |m: &CDOTAClientMsg_ItemAlert| { &m.item_alert },
            |m: &mut CDOTAClientMsg_ItemAlert| { &mut m.item_alert },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ItemAlert>(
            "CDOTAClientMsg_ItemAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ItemAlert {
    const NAME: &'static str = "CDOTAClientMsg_ItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item_alert)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_alert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ItemAlert {
        CDOTAClientMsg_ItemAlert::new()
    }

    fn clear(&mut self) {
        self.item_alert.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ItemAlert {
        static instance: CDOTAClientMsg_ItemAlert = CDOTAClientMsg_ItemAlert {
            item_alert: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ItemAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ItemAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ItemAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ItemAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_EnemyItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EnemyItemAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EnemyItemAlert.item_entindex)
    pub item_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EnemyItemAlert.rune_type)
    pub rune_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EnemyItemAlert.item_level)
    pub item_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EnemyItemAlert.primary_charges)
    pub primary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EnemyItemAlert.secondary_charges)
    pub secondary_charges: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_EnemyItemAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EnemyItemAlert {
    fn default() -> &'a CDOTAClientMsg_EnemyItemAlert {
        <CDOTAClientMsg_EnemyItemAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EnemyItemAlert {
    pub fn new() -> CDOTAClientMsg_EnemyItemAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_entindex = 1;

    pub fn item_entindex(&self) -> i32 {
        self.item_entindex.unwrap_or(0)
    }

    pub fn clear_item_entindex(&mut self) {
        self.item_entindex = ::std::option::Option::None;
    }

    pub fn has_item_entindex(&self) -> bool {
        self.item_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_entindex(&mut self, v: i32) {
        self.item_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 rune_type = 2;

    pub fn rune_type(&self) -> i32 {
        self.rune_type.unwrap_or(0)
    }

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: i32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    // optional int32 item_level = 3;

    pub fn item_level(&self) -> i32 {
        self.item_level.unwrap_or(0)
    }

    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: i32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 primary_charges = 4;

    pub fn primary_charges(&self) -> i32 {
        self.primary_charges.unwrap_or(0)
    }

    pub fn clear_primary_charges(&mut self) {
        self.primary_charges = ::std::option::Option::None;
    }

    pub fn has_primary_charges(&self) -> bool {
        self.primary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_charges(&mut self, v: i32) {
        self.primary_charges = ::std::option::Option::Some(v);
    }

    // optional int32 secondary_charges = 5;

    pub fn secondary_charges(&self) -> i32 {
        self.secondary_charges.unwrap_or(0)
    }

    pub fn clear_secondary_charges(&mut self) {
        self.secondary_charges = ::std::option::Option::None;
    }

    pub fn has_secondary_charges(&self) -> bool {
        self.secondary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_charges(&mut self, v: i32) {
        self.secondary_charges = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_entindex",
            |m: &CDOTAClientMsg_EnemyItemAlert| { &m.item_entindex },
            |m: &mut CDOTAClientMsg_EnemyItemAlert| { &mut m.item_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rune_type",
            |m: &CDOTAClientMsg_EnemyItemAlert| { &m.rune_type },
            |m: &mut CDOTAClientMsg_EnemyItemAlert| { &mut m.rune_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_level",
            |m: &CDOTAClientMsg_EnemyItemAlert| { &m.item_level },
            |m: &mut CDOTAClientMsg_EnemyItemAlert| { &mut m.item_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_charges",
            |m: &CDOTAClientMsg_EnemyItemAlert| { &m.primary_charges },
            |m: &mut CDOTAClientMsg_EnemyItemAlert| { &mut m.primary_charges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary_charges",
            |m: &CDOTAClientMsg_EnemyItemAlert| { &m.secondary_charges },
            |m: &mut CDOTAClientMsg_EnemyItemAlert| { &mut m.secondary_charges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_EnemyItemAlert>(
            "CDOTAClientMsg_EnemyItemAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_EnemyItemAlert {
    const NAME: &'static str = "CDOTAClientMsg_EnemyItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.rune_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_level = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.primary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.rune_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_level {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.primary_charges {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.secondary_charges {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_level {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.primary_charges {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.secondary_charges {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EnemyItemAlert {
        CDOTAClientMsg_EnemyItemAlert::new()
    }

    fn clear(&mut self) {
        self.item_entindex = ::std::option::Option::None;
        self.rune_type = ::std::option::Option::None;
        self.item_level = ::std::option::Option::None;
        self.primary_charges = ::std::option::Option::None;
        self.secondary_charges = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EnemyItemAlert {
        static instance: CDOTAClientMsg_EnemyItemAlert = CDOTAClientMsg_EnemyItemAlert {
            item_entindex: ::std::option::Option::None,
            rune_type: ::std::option::Option::None,
            item_level: ::std::option::Option::None,
            primary_charges: ::std::option::Option::None,
            secondary_charges: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_EnemyItemAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_EnemyItemAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_EnemyItemAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_EnemyItemAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ModifierAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ModifierAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ModifierAlert.buff_internal_index)
    pub buff_internal_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ModifierAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ModifierAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ModifierAlert {
    fn default() -> &'a CDOTAClientMsg_ModifierAlert {
        <CDOTAClientMsg_ModifierAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ModifierAlert {
    pub fn new() -> CDOTAClientMsg_ModifierAlert {
        ::std::default::Default::default()
    }

    // optional int32 buff_internal_index = 1;

    pub fn buff_internal_index(&self) -> i32 {
        self.buff_internal_index.unwrap_or(0)
    }

    pub fn clear_buff_internal_index(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
    }

    pub fn has_buff_internal_index(&self) -> bool {
        self.buff_internal_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_internal_index(&mut self, v: i32) {
        self.buff_internal_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buff_internal_index",
            |m: &CDOTAClientMsg_ModifierAlert| { &m.buff_internal_index },
            |m: &mut CDOTAClientMsg_ModifierAlert| { &mut m.buff_internal_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_ModifierAlert| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_ModifierAlert| { &mut m.target_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ModifierAlert>(
            "CDOTAClientMsg_ModifierAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ModifierAlert {
    const NAME: &'static str = "CDOTAClientMsg_ModifierAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.buff_internal_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.buff_internal_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.buff_internal_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ModifierAlert {
        CDOTAClientMsg_ModifierAlert::new()
    }

    fn clear(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ModifierAlert {
        static instance: CDOTAClientMsg_ModifierAlert = CDOTAClientMsg_ModifierAlert {
            buff_internal_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ModifierAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ModifierAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ModifierAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ModifierAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ClickedBuff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ClickedBuff {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ClickedBuff.buff_internal_index)
    pub buff_internal_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ClickedBuff.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ClickedBuff.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ClickedBuff {
    fn default() -> &'a CDOTAClientMsg_ClickedBuff {
        <CDOTAClientMsg_ClickedBuff as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ClickedBuff {
    pub fn new() -> CDOTAClientMsg_ClickedBuff {
        ::std::default::Default::default()
    }

    // optional int32 buff_internal_index = 1;

    pub fn buff_internal_index(&self) -> i32 {
        self.buff_internal_index.unwrap_or(0)
    }

    pub fn clear_buff_internal_index(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
    }

    pub fn has_buff_internal_index(&self) -> bool {
        self.buff_internal_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_internal_index(&mut self, v: i32) {
        self.buff_internal_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buff_internal_index",
            |m: &CDOTAClientMsg_ClickedBuff| { &m.buff_internal_index },
            |m: &mut CDOTAClientMsg_ClickedBuff| { &mut m.buff_internal_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_ClickedBuff| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_ClickedBuff| { &mut m.target_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ClickedBuff>(
            "CDOTAClientMsg_ClickedBuff",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ClickedBuff {
    const NAME: &'static str = "CDOTAClientMsg_ClickedBuff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.buff_internal_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.buff_internal_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.buff_internal_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ClickedBuff {
        CDOTAClientMsg_ClickedBuff::new()
    }

    fn clear(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ClickedBuff {
        static instance: CDOTAClientMsg_ClickedBuff = CDOTAClientMsg_ClickedBuff {
            buff_internal_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ClickedBuff {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ClickedBuff").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ClickedBuff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ClickedBuff {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_HPManaAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_HPManaAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_HPManaAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_HPManaAlert.show_raw_values)
    pub show_raw_values: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_HPManaAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_HPManaAlert {
    fn default() -> &'a CDOTAClientMsg_HPManaAlert {
        <CDOTAClientMsg_HPManaAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_HPManaAlert {
    pub fn new() -> CDOTAClientMsg_HPManaAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional bool show_raw_values = 2;

    pub fn show_raw_values(&self) -> bool {
        self.show_raw_values.unwrap_or(false)
    }

    pub fn clear_show_raw_values(&mut self) {
        self.show_raw_values = ::std::option::Option::None;
    }

    pub fn has_show_raw_values(&self) -> bool {
        self.show_raw_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_raw_values(&mut self, v: bool) {
        self.show_raw_values = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_HPManaAlert| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_HPManaAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_raw_values",
            |m: &CDOTAClientMsg_HPManaAlert| { &m.show_raw_values },
            |m: &mut CDOTAClientMsg_HPManaAlert| { &mut m.show_raw_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_HPManaAlert>(
            "CDOTAClientMsg_HPManaAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_HPManaAlert {
    const NAME: &'static str = "CDOTAClientMsg_HPManaAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.show_raw_values = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.show_raw_values {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.show_raw_values {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_HPManaAlert {
        CDOTAClientMsg_HPManaAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.show_raw_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_HPManaAlert {
        static instance: CDOTAClientMsg_HPManaAlert = CDOTAClientMsg_HPManaAlert {
            target_entindex: ::std::option::Option::None,
            show_raw_values: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_HPManaAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_HPManaAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_HPManaAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_HPManaAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_NeutralCampAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_NeutralCampAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_NeutralCampAlert.spawner_entindex)
    pub spawner_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_NeutralCampAlert.unit_entindex)
    pub unit_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_NeutralCampAlert.stack_request)
    pub stack_request: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_NeutralCampAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_NeutralCampAlert {
    fn default() -> &'a CDOTAClientMsg_NeutralCampAlert {
        <CDOTAClientMsg_NeutralCampAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_NeutralCampAlert {
    pub fn new() -> CDOTAClientMsg_NeutralCampAlert {
        ::std::default::Default::default()
    }

    // optional int32 spawner_entindex = 1;

    pub fn spawner_entindex(&self) -> i32 {
        self.spawner_entindex.unwrap_or(0)
    }

    pub fn clear_spawner_entindex(&mut self) {
        self.spawner_entindex = ::std::option::Option::None;
    }

    pub fn has_spawner_entindex(&self) -> bool {
        self.spawner_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawner_entindex(&mut self, v: i32) {
        self.spawner_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 unit_entindex = 2;

    pub fn unit_entindex(&self) -> i32 {
        self.unit_entindex.unwrap_or(0)
    }

    pub fn clear_unit_entindex(&mut self) {
        self.unit_entindex = ::std::option::Option::None;
    }

    pub fn has_unit_entindex(&self) -> bool {
        self.unit_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_entindex(&mut self, v: i32) {
        self.unit_entindex = ::std::option::Option::Some(v);
    }

    // optional bool stack_request = 3;

    pub fn stack_request(&self) -> bool {
        self.stack_request.unwrap_or(false)
    }

    pub fn clear_stack_request(&mut self) {
        self.stack_request = ::std::option::Option::None;
    }

    pub fn has_stack_request(&self) -> bool {
        self.stack_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_request(&mut self, v: bool) {
        self.stack_request = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawner_entindex",
            |m: &CDOTAClientMsg_NeutralCampAlert| { &m.spawner_entindex },
            |m: &mut CDOTAClientMsg_NeutralCampAlert| { &mut m.spawner_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_entindex",
            |m: &CDOTAClientMsg_NeutralCampAlert| { &m.unit_entindex },
            |m: &mut CDOTAClientMsg_NeutralCampAlert| { &mut m.unit_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_request",
            |m: &CDOTAClientMsg_NeutralCampAlert| { &m.stack_request },
            |m: &mut CDOTAClientMsg_NeutralCampAlert| { &mut m.stack_request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_NeutralCampAlert>(
            "CDOTAClientMsg_NeutralCampAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_NeutralCampAlert {
    const NAME: &'static str = "CDOTAClientMsg_NeutralCampAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawner_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.unit_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.stack_request = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawner_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.unit_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.stack_request {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spawner_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.unit_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.stack_request {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_NeutralCampAlert {
        CDOTAClientMsg_NeutralCampAlert::new()
    }

    fn clear(&mut self) {
        self.spawner_entindex = ::std::option::Option::None;
        self.unit_entindex = ::std::option::Option::None;
        self.stack_request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_NeutralCampAlert {
        static instance: CDOTAClientMsg_NeutralCampAlert = CDOTAClientMsg_NeutralCampAlert {
            spawner_entindex: ::std::option::Option::None,
            unit_entindex: ::std::option::Option::None,
            stack_request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_NeutralCampAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_NeutralCampAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_NeutralCampAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_NeutralCampAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_GlyphAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GlyphAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_GlyphAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_GlyphAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GlyphAlert {
    fn default() -> &'a CDOTAClientMsg_GlyphAlert {
        <CDOTAClientMsg_GlyphAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GlyphAlert {
    pub fn new() -> CDOTAClientMsg_GlyphAlert {
        ::std::default::Default::default()
    }

    // optional bool negative = 1;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative",
            |m: &CDOTAClientMsg_GlyphAlert| { &m.negative },
            |m: &mut CDOTAClientMsg_GlyphAlert| { &mut m.negative },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_GlyphAlert>(
            "CDOTAClientMsg_GlyphAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_GlyphAlert {
    const NAME: &'static str = "CDOTAClientMsg_GlyphAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.negative {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GlyphAlert {
        CDOTAClientMsg_GlyphAlert::new()
    }

    fn clear(&mut self) {
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GlyphAlert {
        static instance: CDOTAClientMsg_GlyphAlert = CDOTAClientMsg_GlyphAlert {
            negative: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_GlyphAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_GlyphAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_GlyphAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_GlyphAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_RadarAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RadarAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RadarAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_RadarAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RadarAlert {
    fn default() -> &'a CDOTAClientMsg_RadarAlert {
        <CDOTAClientMsg_RadarAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RadarAlert {
    pub fn new() -> CDOTAClientMsg_RadarAlert {
        ::std::default::Default::default()
    }

    // optional bool negative = 1;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative",
            |m: &CDOTAClientMsg_RadarAlert| { &m.negative },
            |m: &mut CDOTAClientMsg_RadarAlert| { &mut m.negative },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_RadarAlert>(
            "CDOTAClientMsg_RadarAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_RadarAlert {
    const NAME: &'static str = "CDOTAClientMsg_RadarAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.negative {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RadarAlert {
        CDOTAClientMsg_RadarAlert::new()
    }

    fn clear(&mut self) {
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RadarAlert {
        static instance: CDOTAClientMsg_RadarAlert = CDOTAClientMsg_RadarAlert {
            negative: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_RadarAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_RadarAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_RadarAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_RadarAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_MapLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_MapLine {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_MapLine.mapline)
    pub mapline: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_MapLine>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_MapLine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_MapLine {
    fn default() -> &'a CDOTAClientMsg_MapLine {
        <CDOTAClientMsg_MapLine as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_MapLine {
    pub fn new() -> CDOTAClientMsg_MapLine {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_MapLine>(
            "mapline",
            |m: &CDOTAClientMsg_MapLine| { &m.mapline },
            |m: &mut CDOTAClientMsg_MapLine| { &mut m.mapline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_MapLine>(
            "CDOTAClientMsg_MapLine",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_MapLine {
    const NAME: &'static str = "CDOTAClientMsg_MapLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mapline)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mapline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mapline.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_MapLine {
        CDOTAClientMsg_MapLine::new()
    }

    fn clear(&mut self) {
        self.mapline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_MapLine {
        static instance: CDOTAClientMsg_MapLine = CDOTAClientMsg_MapLine {
            mapline: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_MapLine {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_MapLine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_MapLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_MapLine {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_AspectRatio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AspectRatio {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AspectRatio.ratio)
    pub ratio: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_AspectRatio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AspectRatio {
    fn default() -> &'a CDOTAClientMsg_AspectRatio {
        <CDOTAClientMsg_AspectRatio as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AspectRatio {
    pub fn new() -> CDOTAClientMsg_AspectRatio {
        ::std::default::Default::default()
    }

    // optional float ratio = 1;

    pub fn ratio(&self) -> f32 {
        self.ratio.unwrap_or(0.)
    }

    pub fn clear_ratio(&mut self) {
        self.ratio = ::std::option::Option::None;
    }

    pub fn has_ratio(&self) -> bool {
        self.ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratio(&mut self, v: f32) {
        self.ratio = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ratio",
            |m: &CDOTAClientMsg_AspectRatio| { &m.ratio },
            |m: &mut CDOTAClientMsg_AspectRatio| { &mut m.ratio },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_AspectRatio>(
            "CDOTAClientMsg_AspectRatio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_AspectRatio {
    const NAME: &'static str = "CDOTAClientMsg_AspectRatio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ratio = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ratio {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ratio {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AspectRatio {
        CDOTAClientMsg_AspectRatio::new()
    }

    fn clear(&mut self) {
        self.ratio = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AspectRatio {
        static instance: CDOTAClientMsg_AspectRatio = CDOTAClientMsg_AspectRatio {
            ratio: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_AspectRatio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_AspectRatio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_AspectRatio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_AspectRatio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_UnitsAutoAttackMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UnitsAutoAttackMode {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_UnitsAutoAttackMode.mode)
    pub mode: ::std::option::Option<::protobuf::EnumOrUnknown<cdotaclient_msg_units_auto_attack_mode::EMode>>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_UnitsAutoAttackMode.unit_type)
    pub unit_type: ::std::option::Option<::protobuf::EnumOrUnknown<cdotaclient_msg_units_auto_attack_mode::EUnitType>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_UnitsAutoAttackMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UnitsAutoAttackMode {
    fn default() -> &'a CDOTAClientMsg_UnitsAutoAttackMode {
        <CDOTAClientMsg_UnitsAutoAttackMode as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UnitsAutoAttackMode {
    pub fn new() -> CDOTAClientMsg_UnitsAutoAttackMode {
        ::std::default::Default::default()
    }

    // optional .dota.CDOTAClientMsg_UnitsAutoAttackMode.EMode mode = 1;

    pub fn mode(&self) -> cdotaclient_msg_units_auto_attack_mode::EMode {
        match self.mode {
            Some(e) => e.enum_value_or(cdotaclient_msg_units_auto_attack_mode::EMode::INVALID),
            None => cdotaclient_msg_units_auto_attack_mode::EMode::INVALID,
        }
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: cdotaclient_msg_units_auto_attack_mode::EMode) {
        self.mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.CDOTAClientMsg_UnitsAutoAttackMode.EUnitType unit_type = 2;

    pub fn unit_type(&self) -> cdotaclient_msg_units_auto_attack_mode::EUnitType {
        match self.unit_type {
            Some(e) => e.enum_value_or(cdotaclient_msg_units_auto_attack_mode::EUnitType::NORMAL),
            None => cdotaclient_msg_units_auto_attack_mode::EUnitType::NORMAL,
        }
    }

    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: cdotaclient_msg_units_auto_attack_mode::EUnitType) {
        self.unit_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &CDOTAClientMsg_UnitsAutoAttackMode| { &m.mode },
            |m: &mut CDOTAClientMsg_UnitsAutoAttackMode| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_type",
            |m: &CDOTAClientMsg_UnitsAutoAttackMode| { &m.unit_type },
            |m: &mut CDOTAClientMsg_UnitsAutoAttackMode| { &mut m.unit_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_UnitsAutoAttackMode>(
            "CDOTAClientMsg_UnitsAutoAttackMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_UnitsAutoAttackMode {
    const NAME: &'static str = "CDOTAClientMsg_UnitsAutoAttackMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.unit_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.unit_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UnitsAutoAttackMode {
        CDOTAClientMsg_UnitsAutoAttackMode::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.unit_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UnitsAutoAttackMode {
        static instance: CDOTAClientMsg_UnitsAutoAttackMode = CDOTAClientMsg_UnitsAutoAttackMode {
            mode: ::std::option::Option::None,
            unit_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_UnitsAutoAttackMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_UnitsAutoAttackMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_UnitsAutoAttackMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_UnitsAutoAttackMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAClientMsg_UnitsAutoAttackMode`
pub mod cdotaclient_msg_units_auto_attack_mode {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CDOTAClientMsg_UnitsAutoAttackMode.EMode)
    pub enum EMode {
        // @@protoc_insertion_point(enum_value:dota.CDOTAClientMsg_UnitsAutoAttackMode.EMode.INVALID)
        INVALID = -1,
        // @@protoc_insertion_point(enum_value:dota.CDOTAClientMsg_UnitsAutoAttackMode.EMode.NEVER)
        NEVER = 0,
        // @@protoc_insertion_point(enum_value:dota.CDOTAClientMsg_UnitsAutoAttackMode.EMode.AFTER_SPELLCAST)
        AFTER_SPELLCAST = 1,
        // @@protoc_insertion_point(enum_value:dota.CDOTAClientMsg_UnitsAutoAttackMode.EMode.ALWAYS)
        ALWAYS = 2,
    }

    impl ::protobuf::Enum for EMode {
        const NAME: &'static str = "EMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EMode> {
            match value {
                -1 => ::std::option::Option::Some(EMode::INVALID),
                0 => ::std::option::Option::Some(EMode::NEVER),
                1 => ::std::option::Option::Some(EMode::AFTER_SPELLCAST),
                2 => ::std::option::Option::Some(EMode::ALWAYS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EMode> {
            match str {
                "INVALID" => ::std::option::Option::Some(EMode::INVALID),
                "NEVER" => ::std::option::Option::Some(EMode::NEVER),
                "AFTER_SPELLCAST" => ::std::option::Option::Some(EMode::AFTER_SPELLCAST),
                "ALWAYS" => ::std::option::Option::Some(EMode::ALWAYS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EMode] = &[
            EMode::INVALID,
            EMode::NEVER,
            EMode::AFTER_SPELLCAST,
            EMode::ALWAYS,
        ];
    }

    impl ::protobuf::EnumFull for EMode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CDOTAClientMsg_UnitsAutoAttackMode.EMode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EMode::INVALID => 0,
                EMode::NEVER => 1,
                EMode::AFTER_SPELLCAST => 2,
                EMode::ALWAYS => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EMode {
        fn default() -> Self {
            EMode::INVALID
        }
    }

    impl EMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EMode>("CDOTAClientMsg_UnitsAutoAttackMode.EMode")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CDOTAClientMsg_UnitsAutoAttackMode.EUnitType)
    pub enum EUnitType {
        // @@protoc_insertion_point(enum_value:dota.CDOTAClientMsg_UnitsAutoAttackMode.EUnitType.NORMAL)
        NORMAL = 0,
        // @@protoc_insertion_point(enum_value:dota.CDOTAClientMsg_UnitsAutoAttackMode.EUnitType.SUMMONED)
        SUMMONED = 1,
    }

    impl ::protobuf::Enum for EUnitType {
        const NAME: &'static str = "EUnitType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EUnitType> {
            match value {
                0 => ::std::option::Option::Some(EUnitType::NORMAL),
                1 => ::std::option::Option::Some(EUnitType::SUMMONED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EUnitType> {
            match str {
                "NORMAL" => ::std::option::Option::Some(EUnitType::NORMAL),
                "SUMMONED" => ::std::option::Option::Some(EUnitType::SUMMONED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EUnitType] = &[
            EUnitType::NORMAL,
            EUnitType::SUMMONED,
        ];
    }

    impl ::protobuf::EnumFull for EUnitType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CDOTAClientMsg_UnitsAutoAttackMode.EUnitType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EUnitType {
        fn default() -> Self {
            EUnitType::NORMAL
        }
    }

    impl EUnitType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EUnitType>("CDOTAClientMsg_UnitsAutoAttackMode.EUnitType")
        }
    }
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_UnitsAutoAttackAfterSpell)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_UnitsAutoAttackAfterSpell.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_UnitsAutoAttackAfterSpell.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    fn default() -> &'a CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        <CDOTAClientMsg_UnitsAutoAttackAfterSpell as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    pub fn new() -> CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &CDOTAClientMsg_UnitsAutoAttackAfterSpell| { &m.enabled },
            |m: &mut CDOTAClientMsg_UnitsAutoAttackAfterSpell| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_UnitsAutoAttackAfterSpell>(
            "CDOTAClientMsg_UnitsAutoAttackAfterSpell",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    const NAME: &'static str = "CDOTAClientMsg_UnitsAutoAttackAfterSpell";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        CDOTAClientMsg_UnitsAutoAttackAfterSpell::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        static instance: CDOTAClientMsg_UnitsAutoAttackAfterSpell = CDOTAClientMsg_UnitsAutoAttackAfterSpell {
            enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_UnitsAutoAttackAfterSpell").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_TeleportRequiresHalt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_TeleportRequiresHalt {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_TeleportRequiresHalt.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_TeleportRequiresHalt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_TeleportRequiresHalt {
    fn default() -> &'a CDOTAClientMsg_TeleportRequiresHalt {
        <CDOTAClientMsg_TeleportRequiresHalt as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_TeleportRequiresHalt {
    pub fn new() -> CDOTAClientMsg_TeleportRequiresHalt {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &CDOTAClientMsg_TeleportRequiresHalt| { &m.enabled },
            |m: &mut CDOTAClientMsg_TeleportRequiresHalt| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_TeleportRequiresHalt>(
            "CDOTAClientMsg_TeleportRequiresHalt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_TeleportRequiresHalt {
    const NAME: &'static str = "CDOTAClientMsg_TeleportRequiresHalt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_TeleportRequiresHalt {
        CDOTAClientMsg_TeleportRequiresHalt::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_TeleportRequiresHalt {
        static instance: CDOTAClientMsg_TeleportRequiresHalt = CDOTAClientMsg_TeleportRequiresHalt {
            enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_TeleportRequiresHalt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_TeleportRequiresHalt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_TeleportRequiresHalt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_TeleportRequiresHalt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ChannelRequiresHalt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChannelRequiresHalt {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChannelRequiresHalt.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ChannelRequiresHalt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChannelRequiresHalt {
    fn default() -> &'a CDOTAClientMsg_ChannelRequiresHalt {
        <CDOTAClientMsg_ChannelRequiresHalt as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChannelRequiresHalt {
    pub fn new() -> CDOTAClientMsg_ChannelRequiresHalt {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &CDOTAClientMsg_ChannelRequiresHalt| { &m.enabled },
            |m: &mut CDOTAClientMsg_ChannelRequiresHalt| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ChannelRequiresHalt>(
            "CDOTAClientMsg_ChannelRequiresHalt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ChannelRequiresHalt {
    const NAME: &'static str = "CDOTAClientMsg_ChannelRequiresHalt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChannelRequiresHalt {
        CDOTAClientMsg_ChannelRequiresHalt::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChannelRequiresHalt {
        static instance: CDOTAClientMsg_ChannelRequiresHalt = CDOTAClientMsg_ChannelRequiresHalt {
            enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ChannelRequiresHalt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ChannelRequiresHalt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ChannelRequiresHalt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ChannelRequiresHalt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SearchString)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SearchString {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SearchString.search)
    pub search: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SearchString.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SearchString {
    fn default() -> &'a CDOTAClientMsg_SearchString {
        <CDOTAClientMsg_SearchString as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SearchString {
    pub fn new() -> CDOTAClientMsg_SearchString {
        ::std::default::Default::default()
    }

    // optional string search = 1;

    pub fn search(&self) -> &str {
        match self.search.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search(&mut self) {
        self.search = ::std::option::Option::None;
    }

    pub fn has_search(&self) -> bool {
        self.search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: ::std::string::String) {
        self.search = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut ::std::string::String {
        if self.search.is_none() {
            self.search = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search.as_mut().unwrap()
    }

    // Take field
    pub fn take_search(&mut self) -> ::std::string::String {
        self.search.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search",
            |m: &CDOTAClientMsg_SearchString| { &m.search },
            |m: &mut CDOTAClientMsg_SearchString| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SearchString>(
            "CDOTAClientMsg_SearchString",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SearchString {
    const NAME: &'static str = "CDOTAClientMsg_SearchString";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.search.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.search.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SearchString {
        CDOTAClientMsg_SearchString::new()
    }

    fn clear(&mut self) {
        self.search = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SearchString {
        static instance: CDOTAClientMsg_SearchString = CDOTAClientMsg_SearchString {
            search: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SearchString {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SearchString").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SearchString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SearchString {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_Pause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_Pause {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_Pause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_Pause {
    fn default() -> &'a CDOTAClientMsg_Pause {
        <CDOTAClientMsg_Pause as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_Pause {
    pub fn new() -> CDOTAClientMsg_Pause {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_Pause>(
            "CDOTAClientMsg_Pause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_Pause {
    const NAME: &'static str = "CDOTAClientMsg_Pause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_Pause {
        CDOTAClientMsg_Pause::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_Pause {
        static instance: CDOTAClientMsg_Pause = CDOTAClientMsg_Pause {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_Pause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_Pause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_Pause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_Pause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ShopViewMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ShopViewMode {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ShopViewMode.mode)
    pub mode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ShopViewMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ShopViewMode {
    fn default() -> &'a CDOTAClientMsg_ShopViewMode {
        <CDOTAClientMsg_ShopViewMode as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ShopViewMode {
    pub fn new() -> CDOTAClientMsg_ShopViewMode {
        ::std::default::Default::default()
    }

    // optional uint32 mode = 1;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &CDOTAClientMsg_ShopViewMode| { &m.mode },
            |m: &mut CDOTAClientMsg_ShopViewMode| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ShopViewMode>(
            "CDOTAClientMsg_ShopViewMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ShopViewMode {
    const NAME: &'static str = "CDOTAClientMsg_ShopViewMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ShopViewMode {
        CDOTAClientMsg_ShopViewMode::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ShopViewMode {
        static instance: CDOTAClientMsg_ShopViewMode = CDOTAClientMsg_ShopViewMode {
            mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ShopViewMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ShopViewMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ShopViewMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ShopViewMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SetUnitShareFlag)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetUnitShareFlag {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetUnitShareFlag.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetUnitShareFlag.flag)
    pub flag: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetUnitShareFlag.state)
    pub state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SetUnitShareFlag.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetUnitShareFlag {
    fn default() -> &'a CDOTAClientMsg_SetUnitShareFlag {
        <CDOTAClientMsg_SetUnitShareFlag as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetUnitShareFlag {
    pub fn new() -> CDOTAClientMsg_SetUnitShareFlag {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 flag = 2;

    pub fn flag(&self) -> u32 {
        self.flag.unwrap_or(0)
    }

    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }

    // optional bool state = 3;

    pub fn state(&self) -> bool {
        self.state.unwrap_or(false)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_SetUnitShareFlag| { &m.player_id },
            |m: &mut CDOTAClientMsg_SetUnitShareFlag| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flag",
            |m: &CDOTAClientMsg_SetUnitShareFlag| { &m.flag },
            |m: &mut CDOTAClientMsg_SetUnitShareFlag| { &mut m.flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CDOTAClientMsg_SetUnitShareFlag| { &m.state },
            |m: &mut CDOTAClientMsg_SetUnitShareFlag| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SetUnitShareFlag>(
            "CDOTAClientMsg_SetUnitShareFlag",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SetUnitShareFlag {
    const NAME: &'static str = "CDOTAClientMsg_SetUnitShareFlag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.flag = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetUnitShareFlag {
        CDOTAClientMsg_SetUnitShareFlag::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.flag = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetUnitShareFlag {
        static instance: CDOTAClientMsg_SetUnitShareFlag = CDOTAClientMsg_SetUnitShareFlag {
            player_id: ::std::option::Option::None,
            flag: ::std::option::Option::None,
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SetUnitShareFlag {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SetUnitShareFlag").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SetUnitShareFlag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SetUnitShareFlag {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SwapRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SwapRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SwapRequest.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SwapRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SwapRequest {
    fn default() -> &'a CDOTAClientMsg_SwapRequest {
        <CDOTAClientMsg_SwapRequest as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SwapRequest {
    pub fn new() -> CDOTAClientMsg_SwapRequest {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_SwapRequest| { &m.player_id },
            |m: &mut CDOTAClientMsg_SwapRequest| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SwapRequest>(
            "CDOTAClientMsg_SwapRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SwapRequest {
    const NAME: &'static str = "CDOTAClientMsg_SwapRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SwapRequest {
        CDOTAClientMsg_SwapRequest::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SwapRequest {
        static instance: CDOTAClientMsg_SwapRequest = CDOTAClientMsg_SwapRequest {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SwapRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SwapRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SwapRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SwapRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SwapAccept)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SwapAccept {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SwapAccept.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SwapAccept.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SwapAccept {
    fn default() -> &'a CDOTAClientMsg_SwapAccept {
        <CDOTAClientMsg_SwapAccept as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SwapAccept {
    pub fn new() -> CDOTAClientMsg_SwapAccept {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_SwapAccept| { &m.player_id },
            |m: &mut CDOTAClientMsg_SwapAccept| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SwapAccept>(
            "CDOTAClientMsg_SwapAccept",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SwapAccept {
    const NAME: &'static str = "CDOTAClientMsg_SwapAccept";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SwapAccept {
        CDOTAClientMsg_SwapAccept::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SwapAccept {
        static instance: CDOTAClientMsg_SwapAccept = CDOTAClientMsg_SwapAccept {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SwapAccept {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SwapAccept").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SwapAccept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SwapAccept {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_WorldLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_WorldLine {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_WorldLine.worldline)
    pub worldline: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_WorldLine>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_WorldLine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_WorldLine {
    fn default() -> &'a CDOTAClientMsg_WorldLine {
        <CDOTAClientMsg_WorldLine as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_WorldLine {
    pub fn new() -> CDOTAClientMsg_WorldLine {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_WorldLine>(
            "worldline",
            |m: &CDOTAClientMsg_WorldLine| { &m.worldline },
            |m: &mut CDOTAClientMsg_WorldLine| { &mut m.worldline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_WorldLine>(
            "CDOTAClientMsg_WorldLine",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_WorldLine {
    const NAME: &'static str = "CDOTAClientMsg_WorldLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.worldline)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.worldline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.worldline.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_WorldLine {
        CDOTAClientMsg_WorldLine::new()
    }

    fn clear(&mut self) {
        self.worldline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_WorldLine {
        static instance: CDOTAClientMsg_WorldLine = CDOTAClientMsg_WorldLine {
            worldline: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_WorldLine {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_WorldLine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_WorldLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_WorldLine {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_RequestGraphUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RequestGraphUpdate {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_RequestGraphUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RequestGraphUpdate {
    fn default() -> &'a CDOTAClientMsg_RequestGraphUpdate {
        <CDOTAClientMsg_RequestGraphUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RequestGraphUpdate {
    pub fn new() -> CDOTAClientMsg_RequestGraphUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_RequestGraphUpdate>(
            "CDOTAClientMsg_RequestGraphUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_RequestGraphUpdate {
    const NAME: &'static str = "CDOTAClientMsg_RequestGraphUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RequestGraphUpdate {
        CDOTAClientMsg_RequestGraphUpdate::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RequestGraphUpdate {
        static instance: CDOTAClientMsg_RequestGraphUpdate = CDOTAClientMsg_RequestGraphUpdate {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_RequestGraphUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_RequestGraphUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_RequestGraphUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_RequestGraphUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ChatWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChatWheel {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChatWheel.chat_message_id)
    pub chat_message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChatWheel.param_hero_id)
    pub param_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChatWheel.emoticon_id)
    pub emoticon_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ChatWheel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChatWheel {
    fn default() -> &'a CDOTAClientMsg_ChatWheel {
        <CDOTAClientMsg_ChatWheel as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChatWheel {
    pub fn new() -> CDOTAClientMsg_ChatWheel {
        ::std::default::Default::default()
    }

    // optional uint32 chat_message_id = 1;

    pub fn chat_message_id(&self) -> u32 {
        self.chat_message_id.unwrap_or(0)
    }

    pub fn clear_chat_message_id(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
    }

    pub fn has_chat_message_id(&self) -> bool {
        self.chat_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_message_id(&mut self, v: u32) {
        self.chat_message_id = ::std::option::Option::Some(v);
    }

    // optional uint32 param_hero_id = 2;

    pub fn param_hero_id(&self) -> u32 {
        self.param_hero_id.unwrap_or(0)
    }

    pub fn clear_param_hero_id(&mut self) {
        self.param_hero_id = ::std::option::Option::None;
    }

    pub fn has_param_hero_id(&self) -> bool {
        self.param_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_hero_id(&mut self, v: u32) {
        self.param_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 emoticon_id = 3;

    pub fn emoticon_id(&self) -> u32 {
        self.emoticon_id.unwrap_or(0)
    }

    pub fn clear_emoticon_id(&mut self) {
        self.emoticon_id = ::std::option::Option::None;
    }

    pub fn has_emoticon_id(&self) -> bool {
        self.emoticon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon_id(&mut self, v: u32) {
        self.emoticon_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_message_id",
            |m: &CDOTAClientMsg_ChatWheel| { &m.chat_message_id },
            |m: &mut CDOTAClientMsg_ChatWheel| { &mut m.chat_message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_hero_id",
            |m: &CDOTAClientMsg_ChatWheel| { &m.param_hero_id },
            |m: &mut CDOTAClientMsg_ChatWheel| { &mut m.param_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "emoticon_id",
            |m: &CDOTAClientMsg_ChatWheel| { &m.emoticon_id },
            |m: &mut CDOTAClientMsg_ChatWheel| { &mut m.emoticon_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ChatWheel>(
            "CDOTAClientMsg_ChatWheel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ChatWheel {
    const NAME: &'static str = "CDOTAClientMsg_ChatWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.param_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.emoticon_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_message_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.param_hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.emoticon_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.param_hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.emoticon_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChatWheel {
        CDOTAClientMsg_ChatWheel::new()
    }

    fn clear(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
        self.param_hero_id = ::std::option::Option::None;
        self.emoticon_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChatWheel {
        static instance: CDOTAClientMsg_ChatWheel = CDOTAClientMsg_ChatWheel {
            chat_message_id: ::std::option::Option::None,
            param_hero_id: ::std::option::Option::None,
            emoticon_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ChatWheel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ChatWheel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ChatWheel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ChatWheel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SendStatPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SendStatPopup {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SendStatPopup.statpopup)
    pub statpopup: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_SendStatPopup>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SendStatPopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SendStatPopup {
    fn default() -> &'a CDOTAClientMsg_SendStatPopup {
        <CDOTAClientMsg_SendStatPopup as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SendStatPopup {
    pub fn new() -> CDOTAClientMsg_SendStatPopup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_SendStatPopup>(
            "statpopup",
            |m: &CDOTAClientMsg_SendStatPopup| { &m.statpopup },
            |m: &mut CDOTAClientMsg_SendStatPopup| { &mut m.statpopup },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SendStatPopup>(
            "CDOTAClientMsg_SendStatPopup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SendStatPopup {
    const NAME: &'static str = "CDOTAClientMsg_SendStatPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.statpopup)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.statpopup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.statpopup.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SendStatPopup {
        CDOTAClientMsg_SendStatPopup::new()
    }

    fn clear(&mut self) {
        self.statpopup.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SendStatPopup {
        static instance: CDOTAClientMsg_SendStatPopup = CDOTAClientMsg_SendStatPopup {
            statpopup: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SendStatPopup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SendStatPopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SendStatPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SendStatPopup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_DismissAllStatPopups)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DismissAllStatPopups {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DismissAllStatPopups.dismissallmsg)
    pub dismissallmsg: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_DismissAllStatPopups.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DismissAllStatPopups {
    fn default() -> &'a CDOTAClientMsg_DismissAllStatPopups {
        <CDOTAClientMsg_DismissAllStatPopups as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DismissAllStatPopups {
    pub fn new() -> CDOTAClientMsg_DismissAllStatPopups {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>(
            "dismissallmsg",
            |m: &CDOTAClientMsg_DismissAllStatPopups| { &m.dismissallmsg },
            |m: &mut CDOTAClientMsg_DismissAllStatPopups| { &mut m.dismissallmsg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_DismissAllStatPopups>(
            "CDOTAClientMsg_DismissAllStatPopups",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_DismissAllStatPopups {
    const NAME: &'static str = "CDOTAClientMsg_DismissAllStatPopups";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dismissallmsg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dismissallmsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dismissallmsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DismissAllStatPopups {
        CDOTAClientMsg_DismissAllStatPopups::new()
    }

    fn clear(&mut self) {
        self.dismissallmsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DismissAllStatPopups {
        static instance: CDOTAClientMsg_DismissAllStatPopups = CDOTAClientMsg_DismissAllStatPopups {
            dismissallmsg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_DismissAllStatPopups {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_DismissAllStatPopups").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_DismissAllStatPopups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_DismissAllStatPopups {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_BeginLastHitChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BeginLastHitChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_BeginLastHitChallenge.chosen_lane)
    pub chosen_lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_BeginLastHitChallenge.helper_enabled)
    pub helper_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_BeginLastHitChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BeginLastHitChallenge {
    fn default() -> &'a CDOTAClientMsg_BeginLastHitChallenge {
        <CDOTAClientMsg_BeginLastHitChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BeginLastHitChallenge {
    pub fn new() -> CDOTAClientMsg_BeginLastHitChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 chosen_lane = 1;

    pub fn chosen_lane(&self) -> u32 {
        self.chosen_lane.unwrap_or(0)
    }

    pub fn clear_chosen_lane(&mut self) {
        self.chosen_lane = ::std::option::Option::None;
    }

    pub fn has_chosen_lane(&self) -> bool {
        self.chosen_lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chosen_lane(&mut self, v: u32) {
        self.chosen_lane = ::std::option::Option::Some(v);
    }

    // optional bool helper_enabled = 2;

    pub fn helper_enabled(&self) -> bool {
        self.helper_enabled.unwrap_or(false)
    }

    pub fn clear_helper_enabled(&mut self) {
        self.helper_enabled = ::std::option::Option::None;
    }

    pub fn has_helper_enabled(&self) -> bool {
        self.helper_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_helper_enabled(&mut self, v: bool) {
        self.helper_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chosen_lane",
            |m: &CDOTAClientMsg_BeginLastHitChallenge| { &m.chosen_lane },
            |m: &mut CDOTAClientMsg_BeginLastHitChallenge| { &mut m.chosen_lane },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "helper_enabled",
            |m: &CDOTAClientMsg_BeginLastHitChallenge| { &m.helper_enabled },
            |m: &mut CDOTAClientMsg_BeginLastHitChallenge| { &mut m.helper_enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_BeginLastHitChallenge>(
            "CDOTAClientMsg_BeginLastHitChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_BeginLastHitChallenge {
    const NAME: &'static str = "CDOTAClientMsg_BeginLastHitChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chosen_lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.helper_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chosen_lane {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.helper_enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chosen_lane {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.helper_enabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BeginLastHitChallenge {
        CDOTAClientMsg_BeginLastHitChallenge::new()
    }

    fn clear(&mut self) {
        self.chosen_lane = ::std::option::Option::None;
        self.helper_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BeginLastHitChallenge {
        static instance: CDOTAClientMsg_BeginLastHitChallenge = CDOTAClientMsg_BeginLastHitChallenge {
            chosen_lane: ::std::option::Option::None,
            helper_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_BeginLastHitChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_BeginLastHitChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_BeginLastHitChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_BeginLastHitChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_UpdateQuickBuyItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UpdateQuickBuyItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_UpdateQuickBuyItem.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_UpdateQuickBuyItem.purchasable)
    pub purchasable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_UpdateQuickBuyItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UpdateQuickBuyItem {
    fn default() -> &'a CDOTAClientMsg_UpdateQuickBuyItem {
        <CDOTAClientMsg_UpdateQuickBuyItem as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UpdateQuickBuyItem {
    pub fn new() -> CDOTAClientMsg_UpdateQuickBuyItem {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional bool purchasable = 2;

    pub fn purchasable(&self) -> bool {
        self.purchasable.unwrap_or(false)
    }

    pub fn clear_purchasable(&mut self) {
        self.purchasable = ::std::option::Option::None;
    }

    pub fn has_purchasable(&self) -> bool {
        self.purchasable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchasable(&mut self, v: bool) {
        self.purchasable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAClientMsg_UpdateQuickBuyItem| { &m.item_ability_id },
            |m: &mut CDOTAClientMsg_UpdateQuickBuyItem| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchasable",
            |m: &CDOTAClientMsg_UpdateQuickBuyItem| { &m.purchasable },
            |m: &mut CDOTAClientMsg_UpdateQuickBuyItem| { &mut m.purchasable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_UpdateQuickBuyItem>(
            "CDOTAClientMsg_UpdateQuickBuyItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_UpdateQuickBuyItem {
    const NAME: &'static str = "CDOTAClientMsg_UpdateQuickBuyItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.purchasable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.purchasable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchasable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UpdateQuickBuyItem {
        CDOTAClientMsg_UpdateQuickBuyItem::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.purchasable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UpdateQuickBuyItem {
        static instance: CDOTAClientMsg_UpdateQuickBuyItem = CDOTAClientMsg_UpdateQuickBuyItem {
            item_ability_id: ::std::option::Option::None,
            purchasable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_UpdateQuickBuyItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_UpdateQuickBuyItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_UpdateQuickBuyItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_UpdateQuickBuyItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_UpdateQuickBuy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UpdateQuickBuy {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_UpdateQuickBuy.items)
    pub items: ::std::vec::Vec<CDOTAClientMsg_UpdateQuickBuyItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_UpdateQuickBuy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UpdateQuickBuy {
    fn default() -> &'a CDOTAClientMsg_UpdateQuickBuy {
        <CDOTAClientMsg_UpdateQuickBuy as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UpdateQuickBuy {
    pub fn new() -> CDOTAClientMsg_UpdateQuickBuy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CDOTAClientMsg_UpdateQuickBuy| { &m.items },
            |m: &mut CDOTAClientMsg_UpdateQuickBuy| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_UpdateQuickBuy>(
            "CDOTAClientMsg_UpdateQuickBuy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_UpdateQuickBuy {
    const NAME: &'static str = "CDOTAClientMsg_UpdateQuickBuy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UpdateQuickBuy {
        CDOTAClientMsg_UpdateQuickBuy::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UpdateQuickBuy {
        static instance: CDOTAClientMsg_UpdateQuickBuy = CDOTAClientMsg_UpdateQuickBuy {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_UpdateQuickBuy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_UpdateQuickBuy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_UpdateQuickBuy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_UpdateQuickBuy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_RecordVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RecordVote {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RecordVote.choice_index)
    pub choice_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_RecordVote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RecordVote {
    fn default() -> &'a CDOTAClientMsg_RecordVote {
        <CDOTAClientMsg_RecordVote as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RecordVote {
    pub fn new() -> CDOTAClientMsg_RecordVote {
        ::std::default::Default::default()
    }

    // optional int32 choice_index = 1;

    pub fn choice_index(&self) -> i32 {
        self.choice_index.unwrap_or(0)
    }

    pub fn clear_choice_index(&mut self) {
        self.choice_index = ::std::option::Option::None;
    }

    pub fn has_choice_index(&self) -> bool {
        self.choice_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice_index(&mut self, v: i32) {
        self.choice_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "choice_index",
            |m: &CDOTAClientMsg_RecordVote| { &m.choice_index },
            |m: &mut CDOTAClientMsg_RecordVote| { &mut m.choice_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_RecordVote>(
            "CDOTAClientMsg_RecordVote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_RecordVote {
    const NAME: &'static str = "CDOTAClientMsg_RecordVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.choice_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.choice_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.choice_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RecordVote {
        CDOTAClientMsg_RecordVote::new()
    }

    fn clear(&mut self) {
        self.choice_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RecordVote {
        static instance: CDOTAClientMsg_RecordVote = CDOTAClientMsg_RecordVote {
            choice_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_RecordVote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_RecordVote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_RecordVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_RecordVote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_WillPurchaseAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_WillPurchaseAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_WillPurchaseAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_WillPurchaseAlert.gold_remaining)
    pub gold_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_WillPurchaseAlert.suggestion_player_id)
    pub suggestion_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_WillPurchaseAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_WillPurchaseAlert {
    fn default() -> &'a CDOTAClientMsg_WillPurchaseAlert {
        <CDOTAClientMsg_WillPurchaseAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_WillPurchaseAlert {
    pub fn new() -> CDOTAClientMsg_WillPurchaseAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_remaining = 2;

    pub fn gold_remaining(&self) -> u32 {
        self.gold_remaining.unwrap_or(0)
    }

    pub fn clear_gold_remaining(&mut self) {
        self.gold_remaining = ::std::option::Option::None;
    }

    pub fn has_gold_remaining(&self) -> bool {
        self.gold_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_remaining(&mut self, v: u32) {
        self.gold_remaining = ::std::option::Option::Some(v);
    }

    // optional int32 suggestion_player_id = 3;

    pub fn suggestion_player_id(&self) -> i32 {
        self.suggestion_player_id.unwrap_or(0)
    }

    pub fn clear_suggestion_player_id(&mut self) {
        self.suggestion_player_id = ::std::option::Option::None;
    }

    pub fn has_suggestion_player_id(&self) -> bool {
        self.suggestion_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suggestion_player_id(&mut self, v: i32) {
        self.suggestion_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAClientMsg_WillPurchaseAlert| { &m.item_ability_id },
            |m: &mut CDOTAClientMsg_WillPurchaseAlert| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold_remaining",
            |m: &CDOTAClientMsg_WillPurchaseAlert| { &m.gold_remaining },
            |m: &mut CDOTAClientMsg_WillPurchaseAlert| { &mut m.gold_remaining },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suggestion_player_id",
            |m: &CDOTAClientMsg_WillPurchaseAlert| { &m.suggestion_player_id },
            |m: &mut CDOTAClientMsg_WillPurchaseAlert| { &mut m.suggestion_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_WillPurchaseAlert>(
            "CDOTAClientMsg_WillPurchaseAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_WillPurchaseAlert {
    const NAME: &'static str = "CDOTAClientMsg_WillPurchaseAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.gold_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.suggestion_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gold_remaining {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.suggestion_player_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gold_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.suggestion_player_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_WillPurchaseAlert {
        CDOTAClientMsg_WillPurchaseAlert::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.gold_remaining = ::std::option::Option::None;
        self.suggestion_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_WillPurchaseAlert {
        static instance: CDOTAClientMsg_WillPurchaseAlert = CDOTAClientMsg_WillPurchaseAlert {
            item_ability_id: ::std::option::Option::None,
            gold_remaining: ::std::option::Option::None,
            suggestion_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_WillPurchaseAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_WillPurchaseAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_WillPurchaseAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_WillPurchaseAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_BuyBackStateAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BuyBackStateAlert {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_BuyBackStateAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BuyBackStateAlert {
    fn default() -> &'a CDOTAClientMsg_BuyBackStateAlert {
        <CDOTAClientMsg_BuyBackStateAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BuyBackStateAlert {
    pub fn new() -> CDOTAClientMsg_BuyBackStateAlert {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_BuyBackStateAlert>(
            "CDOTAClientMsg_BuyBackStateAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_BuyBackStateAlert {
    const NAME: &'static str = "CDOTAClientMsg_BuyBackStateAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BuyBackStateAlert {
        CDOTAClientMsg_BuyBackStateAlert::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BuyBackStateAlert {
        static instance: CDOTAClientMsg_BuyBackStateAlert = CDOTAClientMsg_BuyBackStateAlert {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_BuyBackStateAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_BuyBackStateAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_BuyBackStateAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_BuyBackStateAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_QuickBuyAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_QuickBuyAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuickBuyAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuickBuyAlert.gold_cost)
    pub gold_cost: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuickBuyAlert.item_cooldown_seconds)
    pub item_cooldown_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuickBuyAlert.show_buyback)
    pub show_buyback: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_QuickBuyAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_QuickBuyAlert {
    fn default() -> &'a CDOTAClientMsg_QuickBuyAlert {
        <CDOTAClientMsg_QuickBuyAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_QuickBuyAlert {
    pub fn new() -> CDOTAClientMsg_QuickBuyAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 gold_cost = 2;

    pub fn gold_cost(&self) -> i32 {
        self.gold_cost.unwrap_or(0)
    }

    pub fn clear_gold_cost(&mut self) {
        self.gold_cost = ::std::option::Option::None;
    }

    pub fn has_gold_cost(&self) -> bool {
        self.gold_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_cost(&mut self, v: i32) {
        self.gold_cost = ::std::option::Option::Some(v);
    }

    // optional int32 item_cooldown_seconds = 3;

    pub fn item_cooldown_seconds(&self) -> i32 {
        self.item_cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_item_cooldown_seconds(&mut self) {
        self.item_cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_item_cooldown_seconds(&self) -> bool {
        self.item_cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_cooldown_seconds(&mut self, v: i32) {
        self.item_cooldown_seconds = ::std::option::Option::Some(v);
    }

    // optional bool show_buyback = 4;

    pub fn show_buyback(&self) -> bool {
        self.show_buyback.unwrap_or(false)
    }

    pub fn clear_show_buyback(&mut self) {
        self.show_buyback = ::std::option::Option::None;
    }

    pub fn has_show_buyback(&self) -> bool {
        self.show_buyback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_buyback(&mut self, v: bool) {
        self.show_buyback = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAClientMsg_QuickBuyAlert| { &m.item_ability_id },
            |m: &mut CDOTAClientMsg_QuickBuyAlert| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold_cost",
            |m: &CDOTAClientMsg_QuickBuyAlert| { &m.gold_cost },
            |m: &mut CDOTAClientMsg_QuickBuyAlert| { &mut m.gold_cost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_cooldown_seconds",
            |m: &CDOTAClientMsg_QuickBuyAlert| { &m.item_cooldown_seconds },
            |m: &mut CDOTAClientMsg_QuickBuyAlert| { &mut m.item_cooldown_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_buyback",
            |m: &CDOTAClientMsg_QuickBuyAlert| { &m.show_buyback },
            |m: &mut CDOTAClientMsg_QuickBuyAlert| { &mut m.show_buyback },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_QuickBuyAlert>(
            "CDOTAClientMsg_QuickBuyAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_QuickBuyAlert {
    const NAME: &'static str = "CDOTAClientMsg_QuickBuyAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.gold_cost = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.show_buyback = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gold_cost {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_cooldown_seconds {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.show_buyback {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gold_cost {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_cooldown_seconds {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.show_buyback {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_QuickBuyAlert {
        CDOTAClientMsg_QuickBuyAlert::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.gold_cost = ::std::option::Option::None;
        self.item_cooldown_seconds = ::std::option::Option::None;
        self.show_buyback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_QuickBuyAlert {
        static instance: CDOTAClientMsg_QuickBuyAlert = CDOTAClientMsg_QuickBuyAlert {
            item_ability_id: ::std::option::Option::None,
            gold_cost: ::std::option::Option::None,
            item_cooldown_seconds: ::std::option::Option::None,
            show_buyback: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_QuickBuyAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_QuickBuyAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_QuickBuyAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_QuickBuyAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PlayerShowCase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerShowCase {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PlayerShowCase.showcase)
    pub showcase: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PlayerShowCase.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerShowCase {
    fn default() -> &'a CDOTAClientMsg_PlayerShowCase {
        <CDOTAClientMsg_PlayerShowCase as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerShowCase {
    pub fn new() -> CDOTAClientMsg_PlayerShowCase {
        ::std::default::Default::default()
    }

    // optional bool showcase = 1;

    pub fn showcase(&self) -> bool {
        self.showcase.unwrap_or(false)
    }

    pub fn clear_showcase(&mut self) {
        self.showcase = ::std::option::Option::None;
    }

    pub fn has_showcase(&self) -> bool {
        self.showcase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase(&mut self, v: bool) {
        self.showcase = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "showcase",
            |m: &CDOTAClientMsg_PlayerShowCase| { &m.showcase },
            |m: &mut CDOTAClientMsg_PlayerShowCase| { &mut m.showcase },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PlayerShowCase>(
            "CDOTAClientMsg_PlayerShowCase",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PlayerShowCase {
    const NAME: &'static str = "CDOTAClientMsg_PlayerShowCase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.showcase = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.showcase {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.showcase {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerShowCase {
        CDOTAClientMsg_PlayerShowCase::new()
    }

    fn clear(&mut self) {
        self.showcase = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerShowCase {
        static instance: CDOTAClientMsg_PlayerShowCase = CDOTAClientMsg_PlayerShowCase {
            showcase: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PlayerShowCase {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PlayerShowCase").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PlayerShowCase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PlayerShowCase {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_CameraZoomAmount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_CameraZoomAmount {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_CameraZoomAmount.zoom_amount)
    pub zoom_amount: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_CameraZoomAmount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_CameraZoomAmount {
    fn default() -> &'a CDOTAClientMsg_CameraZoomAmount {
        <CDOTAClientMsg_CameraZoomAmount as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_CameraZoomAmount {
    pub fn new() -> CDOTAClientMsg_CameraZoomAmount {
        ::std::default::Default::default()
    }

    // optional float zoom_amount = 1;

    pub fn zoom_amount(&self) -> f32 {
        self.zoom_amount.unwrap_or(0.)
    }

    pub fn clear_zoom_amount(&mut self) {
        self.zoom_amount = ::std::option::Option::None;
    }

    pub fn has_zoom_amount(&self) -> bool {
        self.zoom_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom_amount(&mut self, v: f32) {
        self.zoom_amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom_amount",
            |m: &CDOTAClientMsg_CameraZoomAmount| { &m.zoom_amount },
            |m: &mut CDOTAClientMsg_CameraZoomAmount| { &mut m.zoom_amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_CameraZoomAmount>(
            "CDOTAClientMsg_CameraZoomAmount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_CameraZoomAmount {
    const NAME: &'static str = "CDOTAClientMsg_CameraZoomAmount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.zoom_amount = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.zoom_amount {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.zoom_amount {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_CameraZoomAmount {
        CDOTAClientMsg_CameraZoomAmount::new()
    }

    fn clear(&mut self) {
        self.zoom_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_CameraZoomAmount {
        static instance: CDOTAClientMsg_CameraZoomAmount = CDOTAClientMsg_CameraZoomAmount {
            zoom_amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_CameraZoomAmount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_CameraZoomAmount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_CameraZoomAmount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_CameraZoomAmount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_BroadcasterUsingCameraman)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BroadcasterUsingCameraman {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_BroadcasterUsingCameraman.cameraman)
    pub cameraman: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_BroadcasterUsingCameraman.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BroadcasterUsingCameraman {
    fn default() -> &'a CDOTAClientMsg_BroadcasterUsingCameraman {
        <CDOTAClientMsg_BroadcasterUsingCameraman as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BroadcasterUsingCameraman {
    pub fn new() -> CDOTAClientMsg_BroadcasterUsingCameraman {
        ::std::default::Default::default()
    }

    // optional bool cameraman = 1;

    pub fn cameraman(&self) -> bool {
        self.cameraman.unwrap_or(false)
    }

    pub fn clear_cameraman(&mut self) {
        self.cameraman = ::std::option::Option::None;
    }

    pub fn has_cameraman(&self) -> bool {
        self.cameraman.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cameraman(&mut self, v: bool) {
        self.cameraman = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cameraman",
            |m: &CDOTAClientMsg_BroadcasterUsingCameraman| { &m.cameraman },
            |m: &mut CDOTAClientMsg_BroadcasterUsingCameraman| { &mut m.cameraman },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_BroadcasterUsingCameraman>(
            "CDOTAClientMsg_BroadcasterUsingCameraman",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_BroadcasterUsingCameraman {
    const NAME: &'static str = "CDOTAClientMsg_BroadcasterUsingCameraman";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cameraman = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cameraman {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cameraman {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BroadcasterUsingCameraman {
        CDOTAClientMsg_BroadcasterUsingCameraman::new()
    }

    fn clear(&mut self) {
        self.cameraman = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BroadcasterUsingCameraman {
        static instance: CDOTAClientMsg_BroadcasterUsingCameraman = CDOTAClientMsg_BroadcasterUsingCameraman {
            cameraman: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_BroadcasterUsingCameraman {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_BroadcasterUsingCameraman").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_BroadcasterUsingCameraman {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_BroadcasterUsingCameraman {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    fn default() -> &'a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        <CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    pub fn new() -> CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator| { &m.enabled },
            |m: &mut CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator>(
            "CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    const NAME: &'static str = "CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        static instance: CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator = CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
            enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_FillEmptySlotsWithBots)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_FillEmptySlotsWithBots {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_FillEmptySlotsWithBots.fillwithbots)
    pub fillwithbots: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_FillEmptySlotsWithBots.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_FillEmptySlotsWithBots {
    fn default() -> &'a CDOTAClientMsg_FillEmptySlotsWithBots {
        <CDOTAClientMsg_FillEmptySlotsWithBots as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_FillEmptySlotsWithBots {
    pub fn new() -> CDOTAClientMsg_FillEmptySlotsWithBots {
        ::std::default::Default::default()
    }

    // optional bool fillwithbots = 1;

    pub fn fillwithbots(&self) -> bool {
        self.fillwithbots.unwrap_or(false)
    }

    pub fn clear_fillwithbots(&mut self) {
        self.fillwithbots = ::std::option::Option::None;
    }

    pub fn has_fillwithbots(&self) -> bool {
        self.fillwithbots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fillwithbots(&mut self, v: bool) {
        self.fillwithbots = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fillwithbots",
            |m: &CDOTAClientMsg_FillEmptySlotsWithBots| { &m.fillwithbots },
            |m: &mut CDOTAClientMsg_FillEmptySlotsWithBots| { &mut m.fillwithbots },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_FillEmptySlotsWithBots>(
            "CDOTAClientMsg_FillEmptySlotsWithBots",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_FillEmptySlotsWithBots {
    const NAME: &'static str = "CDOTAClientMsg_FillEmptySlotsWithBots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fillwithbots = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fillwithbots {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fillwithbots {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_FillEmptySlotsWithBots {
        CDOTAClientMsg_FillEmptySlotsWithBots::new()
    }

    fn clear(&mut self) {
        self.fillwithbots = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_FillEmptySlotsWithBots {
        static instance: CDOTAClientMsg_FillEmptySlotsWithBots = CDOTAClientMsg_FillEmptySlotsWithBots {
            fillwithbots: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_FillEmptySlotsWithBots {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_FillEmptySlotsWithBots").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_FillEmptySlotsWithBots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_FillEmptySlotsWithBots {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_HeroStatueLike)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_HeroStatueLike {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_HeroStatueLike.owner_player_id)
    pub owner_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_HeroStatueLike.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_HeroStatueLike {
    fn default() -> &'a CDOTAClientMsg_HeroStatueLike {
        <CDOTAClientMsg_HeroStatueLike as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_HeroStatueLike {
    pub fn new() -> CDOTAClientMsg_HeroStatueLike {
        ::std::default::Default::default()
    }

    // optional int32 owner_player_id = 1;

    pub fn owner_player_id(&self) -> i32 {
        self.owner_player_id.unwrap_or(0)
    }

    pub fn clear_owner_player_id(&mut self) {
        self.owner_player_id = ::std::option::Option::None;
    }

    pub fn has_owner_player_id(&self) -> bool {
        self.owner_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_player_id(&mut self, v: i32) {
        self.owner_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_player_id",
            |m: &CDOTAClientMsg_HeroStatueLike| { &m.owner_player_id },
            |m: &mut CDOTAClientMsg_HeroStatueLike| { &mut m.owner_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_HeroStatueLike>(
            "CDOTAClientMsg_HeroStatueLike",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_HeroStatueLike {
    const NAME: &'static str = "CDOTAClientMsg_HeroStatueLike";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owner_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_HeroStatueLike {
        CDOTAClientMsg_HeroStatueLike::new()
    }

    fn clear(&mut self) {
        self.owner_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_HeroStatueLike {
        static instance: CDOTAClientMsg_HeroStatueLike = CDOTAClientMsg_HeroStatueLike {
            owner_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_HeroStatueLike {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_HeroStatueLike").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_HeroStatueLike {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_HeroStatueLike {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_EventCNY2015Cmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EventCNY2015Cmd {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EventCNY2015Cmd.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_EventCNY2015Cmd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EventCNY2015Cmd {
    fn default() -> &'a CDOTAClientMsg_EventCNY2015Cmd {
        <CDOTAClientMsg_EventCNY2015Cmd as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EventCNY2015Cmd {
    pub fn new() -> CDOTAClientMsg_EventCNY2015Cmd {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDOTAClientMsg_EventCNY2015Cmd| { &m.data },
            |m: &mut CDOTAClientMsg_EventCNY2015Cmd| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_EventCNY2015Cmd>(
            "CDOTAClientMsg_EventCNY2015Cmd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_EventCNY2015Cmd {
    const NAME: &'static str = "CDOTAClientMsg_EventCNY2015Cmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EventCNY2015Cmd {
        CDOTAClientMsg_EventCNY2015Cmd::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EventCNY2015Cmd {
        static instance: CDOTAClientMsg_EventCNY2015Cmd = CDOTAClientMsg_EventCNY2015Cmd {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_EventCNY2015Cmd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_EventCNY2015Cmd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_EventCNY2015Cmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_EventCNY2015Cmd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_DemoHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DemoHero {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DemoHero.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DemoHero.hero_id_to_spawn)
    pub hero_id_to_spawn: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DemoHero.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DemoHero.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DemoHero.style_index)
    pub style_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DemoHero.keep_existing_demohero)
    pub keep_existing_demohero: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_DemoHero.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DemoHero {
    fn default() -> &'a CDOTAClientMsg_DemoHero {
        <CDOTAClientMsg_DemoHero as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DemoHero {
    pub fn new() -> CDOTAClientMsg_DemoHero {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id_to_spawn = 2;

    pub fn hero_id_to_spawn(&self) -> i32 {
        self.hero_id_to_spawn.unwrap_or(0)
    }

    pub fn clear_hero_id_to_spawn(&mut self) {
        self.hero_id_to_spawn = ::std::option::Option::None;
    }

    pub fn has_hero_id_to_spawn(&self) -> bool {
        self.hero_id_to_spawn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id_to_spawn(&mut self, v: i32) {
        self.hero_id_to_spawn = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 5;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    // optional bool keep_existing_demohero = 6;

    pub fn keep_existing_demohero(&self) -> bool {
        self.keep_existing_demohero.unwrap_or(false)
    }

    pub fn clear_keep_existing_demohero(&mut self) {
        self.keep_existing_demohero = ::std::option::Option::None;
    }

    pub fn has_keep_existing_demohero(&self) -> bool {
        self.keep_existing_demohero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keep_existing_demohero(&mut self, v: bool) {
        self.keep_existing_demohero = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CDOTAClientMsg_DemoHero| { &m.hero_id },
            |m: &mut CDOTAClientMsg_DemoHero| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id_to_spawn",
            |m: &CDOTAClientMsg_DemoHero| { &m.hero_id_to_spawn },
            |m: &mut CDOTAClientMsg_DemoHero| { &mut m.hero_id_to_spawn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_defs",
            |m: &CDOTAClientMsg_DemoHero| { &m.item_defs },
            |m: &mut CDOTAClientMsg_DemoHero| { &mut m.item_defs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CDOTAClientMsg_DemoHero| { &m.item_ids },
            |m: &mut CDOTAClientMsg_DemoHero| { &mut m.item_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_index",
            |m: &CDOTAClientMsg_DemoHero| { &m.style_index },
            |m: &mut CDOTAClientMsg_DemoHero| { &mut m.style_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keep_existing_demohero",
            |m: &CDOTAClientMsg_DemoHero| { &m.keep_existing_demohero },
            |m: &mut CDOTAClientMsg_DemoHero| { &mut m.keep_existing_demohero },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_DemoHero>(
            "CDOTAClientMsg_DemoHero",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_DemoHero {
    const NAME: &'static str = "CDOTAClientMsg_DemoHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hero_id_to_spawn = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                24 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                32 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                40 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.keep_existing_demohero = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_id_to_spawn {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.item_defs {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.keep_existing_demohero {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_id_to_spawn {
            os.write_int32(2, v)?;
        }
        for v in &self.item_defs {
            os.write_uint32(3, *v)?;
        };
        for v in &self.item_ids {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.style_index {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.keep_existing_demohero {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DemoHero {
        CDOTAClientMsg_DemoHero::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.hero_id_to_spawn = ::std::option::Option::None;
        self.item_defs.clear();
        self.item_ids.clear();
        self.style_index = ::std::option::Option::None;
        self.keep_existing_demohero = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DemoHero {
        static instance: CDOTAClientMsg_DemoHero = CDOTAClientMsg_DemoHero {
            hero_id: ::std::option::Option::None,
            hero_id_to_spawn: ::std::option::Option::None,
            item_defs: ::std::vec::Vec::new(),
            item_ids: ::std::vec::Vec::new(),
            style_index: ::std::option::Option::None,
            keep_existing_demohero: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_DemoHero {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_DemoHero").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_DemoHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_DemoHero {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ChallengeSelect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChallengeSelect {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChallengeSelect.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChallengeSelect.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChallengeSelect.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ChallengeSelect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChallengeSelect {
    fn default() -> &'a CDOTAClientMsg_ChallengeSelect {
        <CDOTAClientMsg_ChallengeSelect as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChallengeSelect {
    pub fn new() -> CDOTAClientMsg_ChallengeSelect {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 2;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sequence_id = 3;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAClientMsg_ChallengeSelect| { &m.event_id },
            |m: &mut CDOTAClientMsg_ChallengeSelect| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CDOTAClientMsg_ChallengeSelect| { &m.slot_id },
            |m: &mut CDOTAClientMsg_ChallengeSelect| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_id",
            |m: &CDOTAClientMsg_ChallengeSelect| { &m.sequence_id },
            |m: &mut CDOTAClientMsg_ChallengeSelect| { &mut m.sequence_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ChallengeSelect>(
            "CDOTAClientMsg_ChallengeSelect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ChallengeSelect {
    const NAME: &'static str = "CDOTAClientMsg_ChallengeSelect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChallengeSelect {
        CDOTAClientMsg_ChallengeSelect::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChallengeSelect {
        static instance: CDOTAClientMsg_ChallengeSelect = CDOTAClientMsg_ChallengeSelect {
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ChallengeSelect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ChallengeSelect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ChallengeSelect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ChallengeSelect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ChallengeReroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChallengeReroll {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChallengeReroll.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChallengeReroll.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChallengeReroll.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChallengeReroll.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ChallengeReroll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChallengeReroll {
    fn default() -> &'a CDOTAClientMsg_ChallengeReroll {
        <CDOTAClientMsg_ChallengeReroll as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChallengeReroll {
    pub fn new() -> CDOTAClientMsg_ChallengeReroll {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 slot_id = 2;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sequence_id = 3;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 4;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAClientMsg_ChallengeReroll| { &m.event_id },
            |m: &mut CDOTAClientMsg_ChallengeReroll| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CDOTAClientMsg_ChallengeReroll| { &m.slot_id },
            |m: &mut CDOTAClientMsg_ChallengeReroll| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_id",
            |m: &CDOTAClientMsg_ChallengeReroll| { &m.sequence_id },
            |m: &mut CDOTAClientMsg_ChallengeReroll| { &mut m.sequence_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CDOTAClientMsg_ChallengeReroll| { &m.hero_id },
            |m: &mut CDOTAClientMsg_ChallengeReroll| { &mut m.hero_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ChallengeReroll>(
            "CDOTAClientMsg_ChallengeReroll",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ChallengeReroll {
    const NAME: &'static str = "CDOTAClientMsg_ChallengeReroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChallengeReroll {
        CDOTAClientMsg_ChallengeReroll::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChallengeReroll {
        static instance: CDOTAClientMsg_ChallengeReroll = CDOTAClientMsg_ChallengeReroll {
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ChallengeReroll {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ChallengeReroll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ChallengeReroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ChallengeReroll {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_CoinWager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_CoinWager {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_CoinWager.wager_amount)
    pub wager_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_CoinWager.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_CoinWager {
    fn default() -> &'a CDOTAClientMsg_CoinWager {
        <CDOTAClientMsg_CoinWager as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_CoinWager {
    pub fn new() -> CDOTAClientMsg_CoinWager {
        ::std::default::Default::default()
    }

    // optional uint32 wager_amount = 1;

    pub fn wager_amount(&self) -> u32 {
        self.wager_amount.unwrap_or(0)
    }

    pub fn clear_wager_amount(&mut self) {
        self.wager_amount = ::std::option::Option::None;
    }

    pub fn has_wager_amount(&self) -> bool {
        self.wager_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_amount(&mut self, v: u32) {
        self.wager_amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wager_amount",
            |m: &CDOTAClientMsg_CoinWager| { &m.wager_amount },
            |m: &mut CDOTAClientMsg_CoinWager| { &mut m.wager_amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_CoinWager>(
            "CDOTAClientMsg_CoinWager",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_CoinWager {
    const NAME: &'static str = "CDOTAClientMsg_CoinWager";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wager_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wager_amount {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.wager_amount {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_CoinWager {
        CDOTAClientMsg_CoinWager::new()
    }

    fn clear(&mut self) {
        self.wager_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_CoinWager {
        static instance: CDOTAClientMsg_CoinWager = CDOTAClientMsg_CoinWager {
            wager_amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_CoinWager {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_CoinWager").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_CoinWager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_CoinWager {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_CoinWagerToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_CoinWagerToken {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_CoinWagerToken.wager_token_item_id)
    pub wager_token_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_CoinWagerToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_CoinWagerToken {
    fn default() -> &'a CDOTAClientMsg_CoinWagerToken {
        <CDOTAClientMsg_CoinWagerToken as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_CoinWagerToken {
    pub fn new() -> CDOTAClientMsg_CoinWagerToken {
        ::std::default::Default::default()
    }

    // optional uint64 wager_token_item_id = 1;

    pub fn wager_token_item_id(&self) -> u64 {
        self.wager_token_item_id.unwrap_or(0)
    }

    pub fn clear_wager_token_item_id(&mut self) {
        self.wager_token_item_id = ::std::option::Option::None;
    }

    pub fn has_wager_token_item_id(&self) -> bool {
        self.wager_token_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_token_item_id(&mut self, v: u64) {
        self.wager_token_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wager_token_item_id",
            |m: &CDOTAClientMsg_CoinWagerToken| { &m.wager_token_item_id },
            |m: &mut CDOTAClientMsg_CoinWagerToken| { &mut m.wager_token_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_CoinWagerToken>(
            "CDOTAClientMsg_CoinWagerToken",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_CoinWagerToken {
    const NAME: &'static str = "CDOTAClientMsg_CoinWagerToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wager_token_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wager_token_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.wager_token_item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_CoinWagerToken {
        CDOTAClientMsg_CoinWagerToken::new()
    }

    fn clear(&mut self) {
        self.wager_token_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_CoinWagerToken {
        static instance: CDOTAClientMsg_CoinWagerToken = CDOTAClientMsg_CoinWagerToken {
            wager_token_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_CoinWagerToken {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_CoinWagerToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_CoinWagerToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_CoinWagerToken {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_RankWager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RankWager {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RankWager.announce_wager)
    pub announce_wager: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_RankWager.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RankWager {
    fn default() -> &'a CDOTAClientMsg_RankWager {
        <CDOTAClientMsg_RankWager as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RankWager {
    pub fn new() -> CDOTAClientMsg_RankWager {
        ::std::default::Default::default()
    }

    // optional bool announce_wager = 1;

    pub fn announce_wager(&self) -> bool {
        self.announce_wager.unwrap_or(false)
    }

    pub fn clear_announce_wager(&mut self) {
        self.announce_wager = ::std::option::Option::None;
    }

    pub fn has_announce_wager(&self) -> bool {
        self.announce_wager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announce_wager(&mut self, v: bool) {
        self.announce_wager = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "announce_wager",
            |m: &CDOTAClientMsg_RankWager| { &m.announce_wager },
            |m: &mut CDOTAClientMsg_RankWager| { &mut m.announce_wager },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_RankWager>(
            "CDOTAClientMsg_RankWager",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_RankWager {
    const NAME: &'static str = "CDOTAClientMsg_RankWager";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.announce_wager = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.announce_wager {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.announce_wager {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RankWager {
        CDOTAClientMsg_RankWager::new()
    }

    fn clear(&mut self) {
        self.announce_wager = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RankWager {
        static instance: CDOTAClientMsg_RankWager = CDOTAClientMsg_RankWager {
            announce_wager: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_RankWager {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_RankWager").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_RankWager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_RankWager {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PlayerBounty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerBounty {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PlayerBounty.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PlayerBounty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerBounty {
    fn default() -> &'a CDOTAClientMsg_PlayerBounty {
        <CDOTAClientMsg_PlayerBounty as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerBounty {
    pub fn new() -> CDOTAClientMsg_PlayerBounty {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_PlayerBounty| { &m.player_id },
            |m: &mut CDOTAClientMsg_PlayerBounty| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PlayerBounty>(
            "CDOTAClientMsg_PlayerBounty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PlayerBounty {
    const NAME: &'static str = "CDOTAClientMsg_PlayerBounty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerBounty {
        CDOTAClientMsg_PlayerBounty::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerBounty {
        static instance: CDOTAClientMsg_PlayerBounty = CDOTAClientMsg_PlayerBounty {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PlayerBounty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PlayerBounty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PlayerBounty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PlayerBounty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_EventPointsTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EventPointsTip {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EventPointsTip.recipient_player_id)
    pub recipient_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_EventPointsTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EventPointsTip {
    fn default() -> &'a CDOTAClientMsg_EventPointsTip {
        <CDOTAClientMsg_EventPointsTip as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EventPointsTip {
    pub fn new() -> CDOTAClientMsg_EventPointsTip {
        ::std::default::Default::default()
    }

    // optional int32 recipient_player_id = 1;

    pub fn recipient_player_id(&self) -> i32 {
        self.recipient_player_id.unwrap_or(0)
    }

    pub fn clear_recipient_player_id(&mut self) {
        self.recipient_player_id = ::std::option::Option::None;
    }

    pub fn has_recipient_player_id(&self) -> bool {
        self.recipient_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_player_id(&mut self, v: i32) {
        self.recipient_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipient_player_id",
            |m: &CDOTAClientMsg_EventPointsTip| { &m.recipient_player_id },
            |m: &mut CDOTAClientMsg_EventPointsTip| { &mut m.recipient_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_EventPointsTip>(
            "CDOTAClientMsg_EventPointsTip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_EventPointsTip {
    const NAME: &'static str = "CDOTAClientMsg_EventPointsTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recipient_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recipient_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EventPointsTip {
        CDOTAClientMsg_EventPointsTip::new()
    }

    fn clear(&mut self) {
        self.recipient_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EventPointsTip {
        static instance: CDOTAClientMsg_EventPointsTip = CDOTAClientMsg_EventPointsTip {
            recipient_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_EventPointsTip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_EventPointsTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_EventPointsTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_EventPointsTip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ExecuteOrders)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ExecuteOrders {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ExecuteOrders.orders)
    pub orders: ::std::vec::Vec<super::dota_commonmessages::CDOTAMsg_UnitOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ExecuteOrders.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ExecuteOrders {
    fn default() -> &'a CDOTAClientMsg_ExecuteOrders {
        <CDOTAClientMsg_ExecuteOrders as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ExecuteOrders {
    pub fn new() -> CDOTAClientMsg_ExecuteOrders {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "orders",
            |m: &CDOTAClientMsg_ExecuteOrders| { &m.orders },
            |m: &mut CDOTAClientMsg_ExecuteOrders| { &mut m.orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ExecuteOrders>(
            "CDOTAClientMsg_ExecuteOrders",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ExecuteOrders {
    const NAME: &'static str = "CDOTAClientMsg_ExecuteOrders";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.orders {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ExecuteOrders {
        CDOTAClientMsg_ExecuteOrders::new()
    }

    fn clear(&mut self) {
        self.orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ExecuteOrders {
        static instance: CDOTAClientMsg_ExecuteOrders = CDOTAClientMsg_ExecuteOrders {
            orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ExecuteOrders {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ExecuteOrders").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ExecuteOrders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ExecuteOrders {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_XPAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_XPAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_XPAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_XPAlert.damage_taken)
    pub damage_taken: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_XPAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_XPAlert {
    fn default() -> &'a CDOTAClientMsg_XPAlert {
        <CDOTAClientMsg_XPAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_XPAlert {
    pub fn new() -> CDOTAClientMsg_XPAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_taken = 2;

    pub fn damage_taken(&self) -> u32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: u32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_XPAlert| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_XPAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_taken",
            |m: &CDOTAClientMsg_XPAlert| { &m.damage_taken },
            |m: &mut CDOTAClientMsg_XPAlert| { &mut m.damage_taken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_XPAlert>(
            "CDOTAClientMsg_XPAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_XPAlert {
    const NAME: &'static str = "CDOTAClientMsg_XPAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_XPAlert {
        CDOTAClientMsg_XPAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_XPAlert {
        static instance: CDOTAClientMsg_XPAlert = CDOTAClientMsg_XPAlert {
            target_entindex: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_XPAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_XPAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_XPAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_XPAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_TalentTreeAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_TalentTreeAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_TalentTreeAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_TalentTreeAlert.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_TalentTreeAlert.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_TalentTreeAlert.learned)
    pub learned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_TalentTreeAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_TalentTreeAlert {
    fn default() -> &'a CDOTAClientMsg_TalentTreeAlert {
        <CDOTAClientMsg_TalentTreeAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_TalentTreeAlert {
    pub fn new() -> CDOTAClientMsg_TalentTreeAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 2;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 slot = 3;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional bool learned = 4;

    pub fn learned(&self) -> bool {
        self.learned.unwrap_or(false)
    }

    pub fn clear_learned(&mut self) {
        self.learned = ::std::option::Option::None;
    }

    pub fn has_learned(&self) -> bool {
        self.learned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_learned(&mut self, v: bool) {
        self.learned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_TalentTreeAlert| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_TalentTreeAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CDOTAClientMsg_TalentTreeAlert| { &m.ability_id },
            |m: &mut CDOTAClientMsg_TalentTreeAlert| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CDOTAClientMsg_TalentTreeAlert| { &m.slot },
            |m: &mut CDOTAClientMsg_TalentTreeAlert| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "learned",
            |m: &CDOTAClientMsg_TalentTreeAlert| { &m.learned },
            |m: &mut CDOTAClientMsg_TalentTreeAlert| { &mut m.learned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_TalentTreeAlert>(
            "CDOTAClientMsg_TalentTreeAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_TalentTreeAlert {
    const NAME: &'static str = "CDOTAClientMsg_TalentTreeAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.learned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.learned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.learned {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_TalentTreeAlert {
        CDOTAClientMsg_TalentTreeAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.learned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_TalentTreeAlert {
        static instance: CDOTAClientMsg_TalentTreeAlert = CDOTAClientMsg_TalentTreeAlert {
            target_entindex: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            learned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_TalentTreeAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_TalentTreeAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_TalentTreeAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_TalentTreeAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_KillcamDamageTaken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_KillcamDamageTaken {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_KillcamDamageTaken.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_KillcamDamageTaken.damage_taken)
    pub damage_taken: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_KillcamDamageTaken.item_type)
    pub item_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_KillcamDamageTaken.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_KillcamDamageTaken.hero_name)
    pub hero_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_KillcamDamageTaken.damage_color)
    pub damage_color: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_KillcamDamageTaken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_KillcamDamageTaken {
    fn default() -> &'a CDOTAClientMsg_KillcamDamageTaken {
        <CDOTAClientMsg_KillcamDamageTaken as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_KillcamDamageTaken {
    pub fn new() -> CDOTAClientMsg_KillcamDamageTaken {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_taken = 2;

    pub fn damage_taken(&self) -> u32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: u32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 3;

    pub fn item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 4;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional string hero_name = 5;

    pub fn hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_name(&mut self) {
        self.hero_name = ::std::option::Option::None;
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string damage_color = 6;

    pub fn damage_color(&self) -> &str {
        match self.damage_color.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_damage_color(&mut self) {
        self.damage_color = ::std::option::Option::None;
    }

    pub fn has_damage_color(&self) -> bool {
        self.damage_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_color(&mut self, v: ::std::string::String) {
        self.damage_color = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_damage_color(&mut self) -> &mut ::std::string::String {
        if self.damage_color.is_none() {
            self.damage_color = ::std::option::Option::Some(::std::string::String::new());
        }
        self.damage_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_damage_color(&mut self) -> ::std::string::String {
        self.damage_color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_KillcamDamageTaken| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_KillcamDamageTaken| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_taken",
            |m: &CDOTAClientMsg_KillcamDamageTaken| { &m.damage_taken },
            |m: &mut CDOTAClientMsg_KillcamDamageTaken| { &mut m.damage_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_type",
            |m: &CDOTAClientMsg_KillcamDamageTaken| { &m.item_type },
            |m: &mut CDOTAClientMsg_KillcamDamageTaken| { &mut m.item_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAClientMsg_KillcamDamageTaken| { &m.item_ability_id },
            |m: &mut CDOTAClientMsg_KillcamDamageTaken| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_name",
            |m: &CDOTAClientMsg_KillcamDamageTaken| { &m.hero_name },
            |m: &mut CDOTAClientMsg_KillcamDamageTaken| { &mut m.hero_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_color",
            |m: &CDOTAClientMsg_KillcamDamageTaken| { &m.damage_color },
            |m: &mut CDOTAClientMsg_KillcamDamageTaken| { &mut m.damage_color },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_KillcamDamageTaken>(
            "CDOTAClientMsg_KillcamDamageTaken",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_KillcamDamageTaken {
    const NAME: &'static str = "CDOTAClientMsg_KillcamDamageTaken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.hero_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.damage_color = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.hero_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.damage_color.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hero_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.damage_color.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_KillcamDamageTaken {
        CDOTAClientMsg_KillcamDamageTaken::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.hero_name = ::std::option::Option::None;
        self.damage_color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_KillcamDamageTaken {
        static instance: CDOTAClientMsg_KillcamDamageTaken = CDOTAClientMsg_KillcamDamageTaken {
            target_entindex: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            item_type: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            hero_name: ::std::option::Option::None,
            damage_color: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_KillcamDamageTaken {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_KillcamDamageTaken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_KillcamDamageTaken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_KillcamDamageTaken {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_KillMyHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_KillMyHero {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_KillMyHero.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_KillMyHero {
    fn default() -> &'a CDOTAClientMsg_KillMyHero {
        <CDOTAClientMsg_KillMyHero as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_KillMyHero {
    pub fn new() -> CDOTAClientMsg_KillMyHero {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_KillMyHero>(
            "CDOTAClientMsg_KillMyHero",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_KillMyHero {
    const NAME: &'static str = "CDOTAClientMsg_KillMyHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_KillMyHero {
        CDOTAClientMsg_KillMyHero::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_KillMyHero {
        static instance: CDOTAClientMsg_KillMyHero = CDOTAClientMsg_KillMyHero {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_KillMyHero {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_KillMyHero").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_KillMyHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_KillMyHero {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_QuestStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_QuestStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuestStatus.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuestStatus.challenge_id)
    pub challenge_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuestStatus.progress)
    pub progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuestStatus.goal)
    pub goal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuestStatus.query)
    pub query: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuestStatus.fail_gametime)
    pub fail_gametime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_QuestStatus.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_QuestStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_QuestStatus {
    fn default() -> &'a CDOTAClientMsg_QuestStatus {
        <CDOTAClientMsg_QuestStatus as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_QuestStatus {
    pub fn new() -> CDOTAClientMsg_QuestStatus {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_id = 2;

    pub fn challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    // optional uint32 progress = 3;

    pub fn progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional uint32 goal = 4;

    pub fn goal(&self) -> u32 {
        self.goal.unwrap_or(0)
    }

    pub fn clear_goal(&mut self) {
        self.goal = ::std::option::Option::None;
    }

    pub fn has_goal(&self) -> bool {
        self.goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goal(&mut self, v: u32) {
        self.goal = ::std::option::Option::Some(v);
    }

    // optional uint32 query = 5;

    pub fn query(&self) -> u32 {
        self.query.unwrap_or(0)
    }

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: u32) {
        self.query = ::std::option::Option::Some(v);
    }

    // optional float fail_gametime = 6;

    pub fn fail_gametime(&self) -> f32 {
        self.fail_gametime.unwrap_or(0.)
    }

    pub fn clear_fail_gametime(&mut self) {
        self.fail_gametime = ::std::option::Option::None;
    }

    pub fn has_fail_gametime(&self) -> bool {
        self.fail_gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fail_gametime(&mut self, v: f32) {
        self.fail_gametime = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 7;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CDOTAClientMsg_QuestStatus| { &m.quest_id },
            |m: &mut CDOTAClientMsg_QuestStatus| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_id",
            |m: &CDOTAClientMsg_QuestStatus| { &m.challenge_id },
            |m: &mut CDOTAClientMsg_QuestStatus| { &mut m.challenge_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CDOTAClientMsg_QuestStatus| { &m.progress },
            |m: &mut CDOTAClientMsg_QuestStatus| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "goal",
            |m: &CDOTAClientMsg_QuestStatus| { &m.goal },
            |m: &mut CDOTAClientMsg_QuestStatus| { &mut m.goal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "query",
            |m: &CDOTAClientMsg_QuestStatus| { &m.query },
            |m: &mut CDOTAClientMsg_QuestStatus| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fail_gametime",
            |m: &CDOTAClientMsg_QuestStatus| { &m.fail_gametime },
            |m: &mut CDOTAClientMsg_QuestStatus| { &mut m.fail_gametime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAClientMsg_QuestStatus| { &m.item_ability_id },
            |m: &mut CDOTAClientMsg_QuestStatus| { &mut m.item_ability_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_QuestStatus>(
            "CDOTAClientMsg_QuestStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_QuestStatus {
    const NAME: &'static str = "CDOTAClientMsg_QuestStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.goal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.query = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.fail_gametime = ::std::option::Option::Some(is.read_float()?);
                },
                56 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.challenge_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.goal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.query {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.fail_gametime {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.challenge_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.goal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.query {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.fail_gametime {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_QuestStatus {
        CDOTAClientMsg_QuestStatus::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.challenge_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.goal = ::std::option::Option::None;
        self.query = ::std::option::Option::None;
        self.fail_gametime = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_QuestStatus {
        static instance: CDOTAClientMsg_QuestStatus = CDOTAClientMsg_QuestStatus {
            quest_id: ::std::option::Option::None,
            challenge_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            goal: ::std::option::Option::None,
            query: ::std::option::Option::None,
            fail_gametime: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_QuestStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_QuestStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_QuestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_QuestStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ToggleAutoattack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ToggleAutoattack {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ToggleAutoattack.mode)
    pub mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ToggleAutoattack.show_message)
    pub show_message: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ToggleAutoattack.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ToggleAutoattack {
    fn default() -> &'a CDOTAClientMsg_ToggleAutoattack {
        <CDOTAClientMsg_ToggleAutoattack as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ToggleAutoattack {
    pub fn new() -> CDOTAClientMsg_ToggleAutoattack {
        ::std::default::Default::default()
    }

    // optional int32 mode = 1;

    pub fn mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional bool show_message = 2;

    pub fn show_message(&self) -> bool {
        self.show_message.unwrap_or(false)
    }

    pub fn clear_show_message(&mut self) {
        self.show_message = ::std::option::Option::None;
    }

    pub fn has_show_message(&self) -> bool {
        self.show_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_message(&mut self, v: bool) {
        self.show_message = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &CDOTAClientMsg_ToggleAutoattack| { &m.mode },
            |m: &mut CDOTAClientMsg_ToggleAutoattack| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_message",
            |m: &CDOTAClientMsg_ToggleAutoattack| { &m.show_message },
            |m: &mut CDOTAClientMsg_ToggleAutoattack| { &mut m.show_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ToggleAutoattack>(
            "CDOTAClientMsg_ToggleAutoattack",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ToggleAutoattack {
    const NAME: &'static str = "CDOTAClientMsg_ToggleAutoattack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.show_message = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.show_message {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.show_message {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ToggleAutoattack {
        CDOTAClientMsg_ToggleAutoattack::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.show_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ToggleAutoattack {
        static instance: CDOTAClientMsg_ToggleAutoattack = CDOTAClientMsg_ToggleAutoattack {
            mode: ::std::option::Option::None,
            show_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ToggleAutoattack {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ToggleAutoattack").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ToggleAutoattack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ToggleAutoattack {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SpecialAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SpecialAbility {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SpecialAbility.ability_index)
    pub ability_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SpecialAbility.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SpecialAbility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SpecialAbility {
    fn default() -> &'a CDOTAClientMsg_SpecialAbility {
        <CDOTAClientMsg_SpecialAbility as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SpecialAbility {
    pub fn new() -> CDOTAClientMsg_SpecialAbility {
        ::std::default::Default::default()
    }

    // optional uint32 ability_index = 1;

    pub fn ability_index(&self) -> u32 {
        self.ability_index.unwrap_or(0)
    }

    pub fn clear_ability_index(&mut self) {
        self.ability_index = ::std::option::Option::None;
    }

    pub fn has_ability_index(&self) -> bool {
        self.ability_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_index(&mut self, v: u32) {
        self.ability_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_index",
            |m: &CDOTAClientMsg_SpecialAbility| { &m.ability_index },
            |m: &mut CDOTAClientMsg_SpecialAbility| { &mut m.ability_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_SpecialAbility| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_SpecialAbility| { &mut m.target_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SpecialAbility>(
            "CDOTAClientMsg_SpecialAbility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SpecialAbility {
    const NAME: &'static str = "CDOTAClientMsg_SpecialAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SpecialAbility {
        CDOTAClientMsg_SpecialAbility::new()
    }

    fn clear(&mut self) {
        self.ability_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SpecialAbility {
        static instance: CDOTAClientMsg_SpecialAbility = CDOTAClientMsg_SpecialAbility {
            ability_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SpecialAbility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SpecialAbility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SpecialAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SpecialAbility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SetEnemyStartingPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetEnemyStartingPosition {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetEnemyStartingPosition.enemy_player_id)
    pub enemy_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetEnemyStartingPosition.enemy_starting_position)
    pub enemy_starting_position: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SetEnemyStartingPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetEnemyStartingPosition {
    fn default() -> &'a CDOTAClientMsg_SetEnemyStartingPosition {
        <CDOTAClientMsg_SetEnemyStartingPosition as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetEnemyStartingPosition {
    pub fn new() -> CDOTAClientMsg_SetEnemyStartingPosition {
        ::std::default::Default::default()
    }

    // optional int32 enemy_player_id = 1;

    pub fn enemy_player_id(&self) -> i32 {
        self.enemy_player_id.unwrap_or(0)
    }

    pub fn clear_enemy_player_id(&mut self) {
        self.enemy_player_id = ::std::option::Option::None;
    }

    pub fn has_enemy_player_id(&self) -> bool {
        self.enemy_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_player_id(&mut self, v: i32) {
        self.enemy_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_starting_position = 2;

    pub fn enemy_starting_position(&self) -> u32 {
        self.enemy_starting_position.unwrap_or(0)
    }

    pub fn clear_enemy_starting_position(&mut self) {
        self.enemy_starting_position = ::std::option::Option::None;
    }

    pub fn has_enemy_starting_position(&self) -> bool {
        self.enemy_starting_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_starting_position(&mut self, v: u32) {
        self.enemy_starting_position = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_player_id",
            |m: &CDOTAClientMsg_SetEnemyStartingPosition| { &m.enemy_player_id },
            |m: &mut CDOTAClientMsg_SetEnemyStartingPosition| { &mut m.enemy_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_starting_position",
            |m: &CDOTAClientMsg_SetEnemyStartingPosition| { &m.enemy_starting_position },
            |m: &mut CDOTAClientMsg_SetEnemyStartingPosition| { &mut m.enemy_starting_position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SetEnemyStartingPosition>(
            "CDOTAClientMsg_SetEnemyStartingPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SetEnemyStartingPosition {
    const NAME: &'static str = "CDOTAClientMsg_SetEnemyStartingPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enemy_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.enemy_starting_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enemy_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.enemy_starting_position {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enemy_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.enemy_starting_position {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetEnemyStartingPosition {
        CDOTAClientMsg_SetEnemyStartingPosition::new()
    }

    fn clear(&mut self) {
        self.enemy_player_id = ::std::option::Option::None;
        self.enemy_starting_position = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetEnemyStartingPosition {
        static instance: CDOTAClientMsg_SetEnemyStartingPosition = CDOTAClientMsg_SetEnemyStartingPosition {
            enemy_player_id: ::std::option::Option::None,
            enemy_starting_position: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SetEnemyStartingPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SetEnemyStartingPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SetEnemyStartingPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SetEnemyStartingPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SetDesiredWardPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetDesiredWardPlacement {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetDesiredWardPlacement.ward_index)
    pub ward_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetDesiredWardPlacement.ward_x)
    pub ward_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetDesiredWardPlacement.ward_y)
    pub ward_y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SetDesiredWardPlacement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetDesiredWardPlacement {
    fn default() -> &'a CDOTAClientMsg_SetDesiredWardPlacement {
        <CDOTAClientMsg_SetDesiredWardPlacement as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetDesiredWardPlacement {
    pub fn new() -> CDOTAClientMsg_SetDesiredWardPlacement {
        ::std::default::Default::default()
    }

    // optional uint32 ward_index = 1;

    pub fn ward_index(&self) -> u32 {
        self.ward_index.unwrap_or(0)
    }

    pub fn clear_ward_index(&mut self) {
        self.ward_index = ::std::option::Option::None;
    }

    pub fn has_ward_index(&self) -> bool {
        self.ward_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ward_index(&mut self, v: u32) {
        self.ward_index = ::std::option::Option::Some(v);
    }

    // optional float ward_x = 2;

    pub fn ward_x(&self) -> f32 {
        self.ward_x.unwrap_or(0.)
    }

    pub fn clear_ward_x(&mut self) {
        self.ward_x = ::std::option::Option::None;
    }

    pub fn has_ward_x(&self) -> bool {
        self.ward_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ward_x(&mut self, v: f32) {
        self.ward_x = ::std::option::Option::Some(v);
    }

    // optional float ward_y = 3;

    pub fn ward_y(&self) -> f32 {
        self.ward_y.unwrap_or(0.)
    }

    pub fn clear_ward_y(&mut self) {
        self.ward_y = ::std::option::Option::None;
    }

    pub fn has_ward_y(&self) -> bool {
        self.ward_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ward_y(&mut self, v: f32) {
        self.ward_y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ward_index",
            |m: &CDOTAClientMsg_SetDesiredWardPlacement| { &m.ward_index },
            |m: &mut CDOTAClientMsg_SetDesiredWardPlacement| { &mut m.ward_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ward_x",
            |m: &CDOTAClientMsg_SetDesiredWardPlacement| { &m.ward_x },
            |m: &mut CDOTAClientMsg_SetDesiredWardPlacement| { &mut m.ward_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ward_y",
            |m: &CDOTAClientMsg_SetDesiredWardPlacement| { &m.ward_y },
            |m: &mut CDOTAClientMsg_SetDesiredWardPlacement| { &mut m.ward_y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SetDesiredWardPlacement>(
            "CDOTAClientMsg_SetDesiredWardPlacement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SetDesiredWardPlacement {
    const NAME: &'static str = "CDOTAClientMsg_SetDesiredWardPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ward_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.ward_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.ward_y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ward_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ward_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ward_y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ward_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ward_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.ward_y {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetDesiredWardPlacement {
        CDOTAClientMsg_SetDesiredWardPlacement::new()
    }

    fn clear(&mut self) {
        self.ward_index = ::std::option::Option::None;
        self.ward_x = ::std::option::Option::None;
        self.ward_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetDesiredWardPlacement {
        static instance: CDOTAClientMsg_SetDesiredWardPlacement = CDOTAClientMsg_SetDesiredWardPlacement {
            ward_index: ::std::option::Option::None,
            ward_x: ::std::option::Option::None,
            ward_y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SetDesiredWardPlacement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SetDesiredWardPlacement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SetDesiredWardPlacement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SetDesiredWardPlacement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_RollDice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RollDice {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RollDice.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RollDice.roll_min)
    pub roll_min: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RollDice.roll_max)
    pub roll_max: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_RollDice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RollDice {
    fn default() -> &'a CDOTAClientMsg_RollDice {
        <CDOTAClientMsg_RollDice as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RollDice {
    pub fn new() -> CDOTAClientMsg_RollDice {
        ::std::default::Default::default()
    }

    // optional uint32 channel_type = 1;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_min = 2;

    pub fn roll_min(&self) -> u32 {
        self.roll_min.unwrap_or(0)
    }

    pub fn clear_roll_min(&mut self) {
        self.roll_min = ::std::option::Option::None;
    }

    pub fn has_roll_min(&self) -> bool {
        self.roll_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_min(&mut self, v: u32) {
        self.roll_min = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_max = 3;

    pub fn roll_max(&self) -> u32 {
        self.roll_max.unwrap_or(0)
    }

    pub fn clear_roll_max(&mut self) {
        self.roll_max = ::std::option::Option::None;
    }

    pub fn has_roll_max(&self) -> bool {
        self.roll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_max(&mut self, v: u32) {
        self.roll_max = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_type",
            |m: &CDOTAClientMsg_RollDice| { &m.channel_type },
            |m: &mut CDOTAClientMsg_RollDice| { &mut m.channel_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roll_min",
            |m: &CDOTAClientMsg_RollDice| { &m.roll_min },
            |m: &mut CDOTAClientMsg_RollDice| { &mut m.roll_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roll_max",
            |m: &CDOTAClientMsg_RollDice| { &m.roll_max },
            |m: &mut CDOTAClientMsg_RollDice| { &mut m.roll_max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_RollDice>(
            "CDOTAClientMsg_RollDice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_RollDice {
    const NAME: &'static str = "CDOTAClientMsg_RollDice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.roll_min = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.roll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.roll_min {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.roll_max {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.roll_min {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.roll_max {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RollDice {
        CDOTAClientMsg_RollDice::new()
    }

    fn clear(&mut self) {
        self.channel_type = ::std::option::Option::None;
        self.roll_min = ::std::option::Option::None;
        self.roll_max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RollDice {
        static instance: CDOTAClientMsg_RollDice = CDOTAClientMsg_RollDice {
            channel_type: ::std::option::Option::None,
            roll_min: ::std::option::Option::None,
            roll_max: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_RollDice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_RollDice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_RollDice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_RollDice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_FlipCoin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_FlipCoin {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_FlipCoin.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_FlipCoin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_FlipCoin {
    fn default() -> &'a CDOTAClientMsg_FlipCoin {
        <CDOTAClientMsg_FlipCoin as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_FlipCoin {
    pub fn new() -> CDOTAClientMsg_FlipCoin {
        ::std::default::Default::default()
    }

    // optional uint32 channel_type = 1;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_type",
            |m: &CDOTAClientMsg_FlipCoin| { &m.channel_type },
            |m: &mut CDOTAClientMsg_FlipCoin| { &mut m.channel_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_FlipCoin>(
            "CDOTAClientMsg_FlipCoin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_FlipCoin {
    const NAME: &'static str = "CDOTAClientMsg_FlipCoin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_FlipCoin {
        CDOTAClientMsg_FlipCoin::new()
    }

    fn clear(&mut self) {
        self.channel_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_FlipCoin {
        static instance: CDOTAClientMsg_FlipCoin = CDOTAClientMsg_FlipCoin {
            channel_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_FlipCoin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_FlipCoin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_FlipCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_FlipCoin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_RequestItemSuggestions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RequestItemSuggestions {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_RequestItemSuggestions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RequestItemSuggestions {
    fn default() -> &'a CDOTAClientMsg_RequestItemSuggestions {
        <CDOTAClientMsg_RequestItemSuggestions as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RequestItemSuggestions {
    pub fn new() -> CDOTAClientMsg_RequestItemSuggestions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_RequestItemSuggestions>(
            "CDOTAClientMsg_RequestItemSuggestions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_RequestItemSuggestions {
    const NAME: &'static str = "CDOTAClientMsg_RequestItemSuggestions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RequestItemSuggestions {
        CDOTAClientMsg_RequestItemSuggestions::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RequestItemSuggestions {
        static instance: CDOTAClientMsg_RequestItemSuggestions = CDOTAClientMsg_RequestItemSuggestions {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_RequestItemSuggestions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_RequestItemSuggestions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_RequestItemSuggestions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_RequestItemSuggestions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_MakeTeamCaptain)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_MakeTeamCaptain {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_MakeTeamCaptain.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_MakeTeamCaptain.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_MakeTeamCaptain {
    fn default() -> &'a CDOTAClientMsg_MakeTeamCaptain {
        <CDOTAClientMsg_MakeTeamCaptain as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_MakeTeamCaptain {
    pub fn new() -> CDOTAClientMsg_MakeTeamCaptain {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_MakeTeamCaptain| { &m.player_id },
            |m: &mut CDOTAClientMsg_MakeTeamCaptain| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_MakeTeamCaptain>(
            "CDOTAClientMsg_MakeTeamCaptain",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_MakeTeamCaptain {
    const NAME: &'static str = "CDOTAClientMsg_MakeTeamCaptain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_MakeTeamCaptain {
        CDOTAClientMsg_MakeTeamCaptain::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_MakeTeamCaptain {
        static instance: CDOTAClientMsg_MakeTeamCaptain = CDOTAClientMsg_MakeTeamCaptain {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_MakeTeamCaptain {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_MakeTeamCaptain").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_MakeTeamCaptain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_MakeTeamCaptain {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_HelpTipSystemStateChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_HelpTipSystemStateChanged {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_HelpTipSystemStateChanged.tip_displayed)
    pub tip_displayed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_HelpTipSystemStateChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_HelpTipSystemStateChanged {
    fn default() -> &'a CDOTAClientMsg_HelpTipSystemStateChanged {
        <CDOTAClientMsg_HelpTipSystemStateChanged as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_HelpTipSystemStateChanged {
    pub fn new() -> CDOTAClientMsg_HelpTipSystemStateChanged {
        ::std::default::Default::default()
    }

    // optional bool tip_displayed = 1;

    pub fn tip_displayed(&self) -> bool {
        self.tip_displayed.unwrap_or(false)
    }

    pub fn clear_tip_displayed(&mut self) {
        self.tip_displayed = ::std::option::Option::None;
    }

    pub fn has_tip_displayed(&self) -> bool {
        self.tip_displayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_displayed(&mut self, v: bool) {
        self.tip_displayed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_displayed",
            |m: &CDOTAClientMsg_HelpTipSystemStateChanged| { &m.tip_displayed },
            |m: &mut CDOTAClientMsg_HelpTipSystemStateChanged| { &mut m.tip_displayed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_HelpTipSystemStateChanged>(
            "CDOTAClientMsg_HelpTipSystemStateChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_HelpTipSystemStateChanged {
    const NAME: &'static str = "CDOTAClientMsg_HelpTipSystemStateChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tip_displayed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tip_displayed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tip_displayed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_HelpTipSystemStateChanged {
        CDOTAClientMsg_HelpTipSystemStateChanged::new()
    }

    fn clear(&mut self) {
        self.tip_displayed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_HelpTipSystemStateChanged {
        static instance: CDOTAClientMsg_HelpTipSystemStateChanged = CDOTAClientMsg_HelpTipSystemStateChanged {
            tip_displayed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_HelpTipSystemStateChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_HelpTipSystemStateChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_HelpTipSystemStateChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_HelpTipSystemStateChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_RequestBulkCombatLog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RequestBulkCombatLog {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RequestBulkCombatLog.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RequestBulkCombatLog.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RequestBulkCombatLog.recent_player_death)
    pub recent_player_death: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_RequestBulkCombatLog.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_RequestBulkCombatLog.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RequestBulkCombatLog {
    fn default() -> &'a CDOTAClientMsg_RequestBulkCombatLog {
        <CDOTAClientMsg_RequestBulkCombatLog as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RequestBulkCombatLog {
    pub fn new() -> CDOTAClientMsg_RequestBulkCombatLog {
        ::std::default::Default::default()
    }

    // optional float game_time = 1;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool recent_player_death = 3;

    pub fn recent_player_death(&self) -> bool {
        self.recent_player_death.unwrap_or(false)
    }

    pub fn clear_recent_player_death(&mut self) {
        self.recent_player_death = ::std::option::Option::None;
    }

    pub fn has_recent_player_death(&self) -> bool {
        self.recent_player_death.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_player_death(&mut self, v: bool) {
        self.recent_player_death = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 4;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_time",
            |m: &CDOTAClientMsg_RequestBulkCombatLog| { &m.game_time },
            |m: &mut CDOTAClientMsg_RequestBulkCombatLog| { &mut m.game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAClientMsg_RequestBulkCombatLog| { &m.duration },
            |m: &mut CDOTAClientMsg_RequestBulkCombatLog| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_player_death",
            |m: &CDOTAClientMsg_RequestBulkCombatLog| { &m.recent_player_death },
            |m: &mut CDOTAClientMsg_RequestBulkCombatLog| { &mut m.recent_player_death },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_RequestBulkCombatLog| { &m.player_id },
            |m: &mut CDOTAClientMsg_RequestBulkCombatLog| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_RequestBulkCombatLog>(
            "CDOTAClientMsg_RequestBulkCombatLog",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_RequestBulkCombatLog {
    const NAME: &'static str = "CDOTAClientMsg_RequestBulkCombatLog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.recent_player_death = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.recent_player_death {
            my_size += 1 + 1;
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.recent_player_death {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RequestBulkCombatLog {
        CDOTAClientMsg_RequestBulkCombatLog::new()
    }

    fn clear(&mut self) {
        self.game_time = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.recent_player_death = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RequestBulkCombatLog {
        static instance: CDOTAClientMsg_RequestBulkCombatLog = CDOTAClientMsg_RequestBulkCombatLog {
            game_time: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            recent_player_death: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_RequestBulkCombatLog {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_RequestBulkCombatLog").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_RequestBulkCombatLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_RequestBulkCombatLog {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_AbilityDraftRequestAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AbilityDraftRequestAbility {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AbilityDraftRequestAbility.requested_ability_id)
    pub requested_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AbilityDraftRequestAbility.ctrl_is_down)
    pub ctrl_is_down: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_AbilityDraftRequestAbility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AbilityDraftRequestAbility {
    fn default() -> &'a CDOTAClientMsg_AbilityDraftRequestAbility {
        <CDOTAClientMsg_AbilityDraftRequestAbility as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AbilityDraftRequestAbility {
    pub fn new() -> CDOTAClientMsg_AbilityDraftRequestAbility {
        ::std::default::Default::default()
    }

    // optional int32 requested_ability_id = 1;

    pub fn requested_ability_id(&self) -> i32 {
        self.requested_ability_id.unwrap_or(0)
    }

    pub fn clear_requested_ability_id(&mut self) {
        self.requested_ability_id = ::std::option::Option::None;
    }

    pub fn has_requested_ability_id(&self) -> bool {
        self.requested_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_ability_id(&mut self, v: i32) {
        self.requested_ability_id = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_is_down = 2;

    pub fn ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.unwrap_or(false)
    }

    pub fn clear_ctrl_is_down(&mut self) {
        self.ctrl_is_down = ::std::option::Option::None;
    }

    pub fn has_ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_is_down(&mut self, v: bool) {
        self.ctrl_is_down = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requested_ability_id",
            |m: &CDOTAClientMsg_AbilityDraftRequestAbility| { &m.requested_ability_id },
            |m: &mut CDOTAClientMsg_AbilityDraftRequestAbility| { &mut m.requested_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctrl_is_down",
            |m: &CDOTAClientMsg_AbilityDraftRequestAbility| { &m.ctrl_is_down },
            |m: &mut CDOTAClientMsg_AbilityDraftRequestAbility| { &mut m.ctrl_is_down },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_AbilityDraftRequestAbility>(
            "CDOTAClientMsg_AbilityDraftRequestAbility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_AbilityDraftRequestAbility {
    const NAME: &'static str = "CDOTAClientMsg_AbilityDraftRequestAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.requested_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ctrl_is_down = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requested_ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ctrl_is_down {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.requested_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ctrl_is_down {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AbilityDraftRequestAbility {
        CDOTAClientMsg_AbilityDraftRequestAbility::new()
    }

    fn clear(&mut self) {
        self.requested_ability_id = ::std::option::Option::None;
        self.ctrl_is_down = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AbilityDraftRequestAbility {
        static instance: CDOTAClientMsg_AbilityDraftRequestAbility = CDOTAClientMsg_AbilityDraftRequestAbility {
            requested_ability_id: ::std::option::Option::None,
            ctrl_is_down: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_AbilityDraftRequestAbility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_AbilityDraftRequestAbility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_AbilityDraftRequestAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_AbilityDraftRequestAbility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_GuideSelectOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GuideSelectOption {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_GuideSelectOption.option)
    pub option: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_GuideSelectOption.force_recalculate)
    pub force_recalculate: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_GuideSelectOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GuideSelectOption {
    fn default() -> &'a CDOTAClientMsg_GuideSelectOption {
        <CDOTAClientMsg_GuideSelectOption as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GuideSelectOption {
    pub fn new() -> CDOTAClientMsg_GuideSelectOption {
        ::std::default::Default::default()
    }

    // optional uint32 option = 1;

    pub fn option(&self) -> u32 {
        self.option.unwrap_or(0)
    }

    pub fn clear_option(&mut self) {
        self.option = ::std::option::Option::None;
    }

    pub fn has_option(&self) -> bool {
        self.option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: u32) {
        self.option = ::std::option::Option::Some(v);
    }

    // optional bool force_recalculate = 2;

    pub fn force_recalculate(&self) -> bool {
        self.force_recalculate.unwrap_or(false)
    }

    pub fn clear_force_recalculate(&mut self) {
        self.force_recalculate = ::std::option::Option::None;
    }

    pub fn has_force_recalculate(&self) -> bool {
        self.force_recalculate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_recalculate(&mut self, v: bool) {
        self.force_recalculate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "option",
            |m: &CDOTAClientMsg_GuideSelectOption| { &m.option },
            |m: &mut CDOTAClientMsg_GuideSelectOption| { &mut m.option },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_recalculate",
            |m: &CDOTAClientMsg_GuideSelectOption| { &m.force_recalculate },
            |m: &mut CDOTAClientMsg_GuideSelectOption| { &mut m.force_recalculate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_GuideSelectOption>(
            "CDOTAClientMsg_GuideSelectOption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_GuideSelectOption {
    const NAME: &'static str = "CDOTAClientMsg_GuideSelectOption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.option = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.force_recalculate = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.option {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.force_recalculate {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.option {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_recalculate {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GuideSelectOption {
        CDOTAClientMsg_GuideSelectOption::new()
    }

    fn clear(&mut self) {
        self.option = ::std::option::Option::None;
        self.force_recalculate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GuideSelectOption {
        static instance: CDOTAClientMsg_GuideSelectOption = CDOTAClientMsg_GuideSelectOption {
            option: ::std::option::Option::None,
            force_recalculate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_GuideSelectOption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_GuideSelectOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_GuideSelectOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_GuideSelectOption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_GuideSelected)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GuideSelected {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_GuideSelected.guide_workshop_id)
    pub guide_workshop_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_GuideSelected.is_plus_guide)
    pub is_plus_guide: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_GuideSelected.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GuideSelected {
    fn default() -> &'a CDOTAClientMsg_GuideSelected {
        <CDOTAClientMsg_GuideSelected as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GuideSelected {
    pub fn new() -> CDOTAClientMsg_GuideSelected {
        ::std::default::Default::default()
    }

    // optional uint64 guide_workshop_id = 1;

    pub fn guide_workshop_id(&self) -> u64 {
        self.guide_workshop_id.unwrap_or(0)
    }

    pub fn clear_guide_workshop_id(&mut self) {
        self.guide_workshop_id = ::std::option::Option::None;
    }

    pub fn has_guide_workshop_id(&self) -> bool {
        self.guide_workshop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guide_workshop_id(&mut self, v: u64) {
        self.guide_workshop_id = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_guide = 2;

    pub fn is_plus_guide(&self) -> bool {
        self.is_plus_guide.unwrap_or(false)
    }

    pub fn clear_is_plus_guide(&mut self) {
        self.is_plus_guide = ::std::option::Option::None;
    }

    pub fn has_is_plus_guide(&self) -> bool {
        self.is_plus_guide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_guide(&mut self, v: bool) {
        self.is_plus_guide = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guide_workshop_id",
            |m: &CDOTAClientMsg_GuideSelected| { &m.guide_workshop_id },
            |m: &mut CDOTAClientMsg_GuideSelected| { &mut m.guide_workshop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_plus_guide",
            |m: &CDOTAClientMsg_GuideSelected| { &m.is_plus_guide },
            |m: &mut CDOTAClientMsg_GuideSelected| { &mut m.is_plus_guide },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_GuideSelected>(
            "CDOTAClientMsg_GuideSelected",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_GuideSelected {
    const NAME: &'static str = "CDOTAClientMsg_GuideSelected";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guide_workshop_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.is_plus_guide = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guide_workshop_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.is_plus_guide {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guide_workshop_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_plus_guide {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GuideSelected {
        CDOTAClientMsg_GuideSelected::new()
    }

    fn clear(&mut self) {
        self.guide_workshop_id = ::std::option::Option::None;
        self.is_plus_guide = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GuideSelected {
        static instance: CDOTAClientMsg_GuideSelected = CDOTAClientMsg_GuideSelected {
            guide_workshop_id: ::std::option::Option::None,
            is_plus_guide: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_GuideSelected {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_GuideSelected").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_GuideSelected {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_GuideSelected {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_DamageReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DamageReport {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DamageReport.target_hero_id)
    pub target_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DamageReport.source_hero_id)
    pub source_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DamageReport.damage_amount)
    pub damage_amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DamageReport.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_DamageReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DamageReport {
    fn default() -> &'a CDOTAClientMsg_DamageReport {
        <CDOTAClientMsg_DamageReport as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DamageReport {
    pub fn new() -> CDOTAClientMsg_DamageReport {
        ::std::default::Default::default()
    }

    // optional uint32 target_hero_id = 1;

    pub fn target_hero_id(&self) -> u32 {
        self.target_hero_id.unwrap_or(0)
    }

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: u32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 source_hero_id = 2;

    pub fn source_hero_id(&self) -> u32 {
        self.source_hero_id.unwrap_or(0)
    }

    pub fn clear_source_hero_id(&mut self) {
        self.source_hero_id = ::std::option::Option::None;
    }

    pub fn has_source_hero_id(&self) -> bool {
        self.source_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_hero_id(&mut self, v: u32) {
        self.source_hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 damage_amount = 3;

    pub fn damage_amount(&self) -> i32 {
        self.damage_amount.unwrap_or(0)
    }

    pub fn clear_damage_amount(&mut self) {
        self.damage_amount = ::std::option::Option::None;
    }

    pub fn has_damage_amount(&self) -> bool {
        self.damage_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_amount(&mut self, v: i32) {
        self.damage_amount = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 4;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_hero_id",
            |m: &CDOTAClientMsg_DamageReport| { &m.target_hero_id },
            |m: &mut CDOTAClientMsg_DamageReport| { &mut m.target_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_hero_id",
            |m: &CDOTAClientMsg_DamageReport| { &m.source_hero_id },
            |m: &mut CDOTAClientMsg_DamageReport| { &mut m.source_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_amount",
            |m: &CDOTAClientMsg_DamageReport| { &m.damage_amount },
            |m: &mut CDOTAClientMsg_DamageReport| { &mut m.damage_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast",
            |m: &CDOTAClientMsg_DamageReport| { &m.broadcast },
            |m: &mut CDOTAClientMsg_DamageReport| { &mut m.broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_DamageReport>(
            "CDOTAClientMsg_DamageReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_DamageReport {
    const NAME: &'static str = "CDOTAClientMsg_DamageReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.source_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.damage_amount = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_hero_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.source_hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.damage_amount {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.source_hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.damage_amount {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DamageReport {
        CDOTAClientMsg_DamageReport::new()
    }

    fn clear(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
        self.source_hero_id = ::std::option::Option::None;
        self.damage_amount = ::std::option::Option::None;
        self.broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DamageReport {
        static instance: CDOTAClientMsg_DamageReport = CDOTAClientMsg_DamageReport {
            target_hero_id: ::std::option::Option::None,
            source_hero_id: ::std::option::Option::None,
            damage_amount: ::std::option::Option::None,
            broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_DamageReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_DamageReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_DamageReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_DamageReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SalutePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SalutePlayer {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SalutePlayer.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SalutePlayer.event_id)
    pub event_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SalutePlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SalutePlayer {
    fn default() -> &'a CDOTAClientMsg_SalutePlayer {
        <CDOTAClientMsg_SalutePlayer as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SalutePlayer {
    pub fn new() -> CDOTAClientMsg_SalutePlayer {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 event_id = 2;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAClientMsg_SalutePlayer| { &m.target_player_id },
            |m: &mut CDOTAClientMsg_SalutePlayer| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAClientMsg_SalutePlayer| { &m.event_id },
            |m: &mut CDOTAClientMsg_SalutePlayer| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SalutePlayer>(
            "CDOTAClientMsg_SalutePlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SalutePlayer {
    const NAME: &'static str = "CDOTAClientMsg_SalutePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SalutePlayer {
        CDOTAClientMsg_SalutePlayer::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SalutePlayer {
        static instance: CDOTAClientMsg_SalutePlayer = CDOTAClientMsg_SalutePlayer {
            target_player_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SalutePlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SalutePlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SalutePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SalutePlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_TipAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_TipAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_TipAlert.tip_text)
    pub tip_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_TipAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_TipAlert {
    fn default() -> &'a CDOTAClientMsg_TipAlert {
        <CDOTAClientMsg_TipAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_TipAlert {
    pub fn new() -> CDOTAClientMsg_TipAlert {
        ::std::default::Default::default()
    }

    // optional string tip_text = 1;

    pub fn tip_text(&self) -> &str {
        match self.tip_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_text(&mut self) {
        self.tip_text = ::std::option::Option::None;
    }

    pub fn has_tip_text(&self) -> bool {
        self.tip_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_text(&mut self, v: ::std::string::String) {
        self.tip_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_text(&mut self) -> &mut ::std::string::String {
        if self.tip_text.is_none() {
            self.tip_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_text(&mut self) -> ::std::string::String {
        self.tip_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_text",
            |m: &CDOTAClientMsg_TipAlert| { &m.tip_text },
            |m: &mut CDOTAClientMsg_TipAlert| { &mut m.tip_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_TipAlert>(
            "CDOTAClientMsg_TipAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_TipAlert {
    const NAME: &'static str = "CDOTAClientMsg_TipAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tip_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tip_text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tip_text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_TipAlert {
        CDOTAClientMsg_TipAlert::new()
    }

    fn clear(&mut self) {
        self.tip_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_TipAlert {
        static instance: CDOTAClientMsg_TipAlert = CDOTAClientMsg_TipAlert {
            tip_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_TipAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_TipAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_TipAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_TipAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_EmptyTeleportAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EmptyTeleportAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EmptyTeleportAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_EmptyTeleportAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EmptyTeleportAlert {
    fn default() -> &'a CDOTAClientMsg_EmptyTeleportAlert {
        <CDOTAClientMsg_EmptyTeleportAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EmptyTeleportAlert {
    pub fn new() -> CDOTAClientMsg_EmptyTeleportAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_EmptyTeleportAlert| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_EmptyTeleportAlert| { &mut m.target_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_EmptyTeleportAlert>(
            "CDOTAClientMsg_EmptyTeleportAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_EmptyTeleportAlert {
    const NAME: &'static str = "CDOTAClientMsg_EmptyTeleportAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EmptyTeleportAlert {
        CDOTAClientMsg_EmptyTeleportAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EmptyTeleportAlert {
        static instance: CDOTAClientMsg_EmptyTeleportAlert = CDOTAClientMsg_EmptyTeleportAlert {
            target_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_EmptyTeleportAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_EmptyTeleportAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_EmptyTeleportAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_EmptyTeleportAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_SetCavernMapVariant)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetCavernMapVariant {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_SetCavernMapVariant.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_SetCavernMapVariant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetCavernMapVariant {
    fn default() -> &'a CDOTAClientMsg_SetCavernMapVariant {
        <CDOTAClientMsg_SetCavernMapVariant as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetCavernMapVariant {
    pub fn new() -> CDOTAClientMsg_SetCavernMapVariant {
        ::std::default::Default::default()
    }

    // optional uint32 map_variant = 1;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(0)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_variant",
            |m: &CDOTAClientMsg_SetCavernMapVariant| { &m.map_variant },
            |m: &mut CDOTAClientMsg_SetCavernMapVariant| { &mut m.map_variant },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_SetCavernMapVariant>(
            "CDOTAClientMsg_SetCavernMapVariant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_SetCavernMapVariant {
    const NAME: &'static str = "CDOTAClientMsg_SetCavernMapVariant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_variant {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_variant {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetCavernMapVariant {
        CDOTAClientMsg_SetCavernMapVariant::new()
    }

    fn clear(&mut self) {
        self.map_variant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetCavernMapVariant {
        static instance: CDOTAClientMsg_SetCavernMapVariant = CDOTAClientMsg_SetCavernMapVariant {
            map_variant: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_SetCavernMapVariant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_SetCavernMapVariant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_SetCavernMapVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_SetCavernMapVariant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PauseGameOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PauseGameOrder {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PauseGameOrder.order_id)
    pub order_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PauseGameOrder.data)
    pub data: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PauseGameOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PauseGameOrder {
    fn default() -> &'a CDOTAClientMsg_PauseGameOrder {
        <CDOTAClientMsg_PauseGameOrder as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PauseGameOrder {
    pub fn new() -> CDOTAClientMsg_PauseGameOrder {
        ::std::default::Default::default()
    }

    // optional int32 order_id = 1;

    pub fn order_id(&self) -> i32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;

    pub fn data(&self) -> i32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order_id",
            |m: &CDOTAClientMsg_PauseGameOrder| { &m.order_id },
            |m: &mut CDOTAClientMsg_PauseGameOrder| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDOTAClientMsg_PauseGameOrder| { &m.data },
            |m: &mut CDOTAClientMsg_PauseGameOrder| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PauseGameOrder>(
            "CDOTAClientMsg_PauseGameOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PauseGameOrder {
    const NAME: &'static str = "CDOTAClientMsg_PauseGameOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.data = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.order_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PauseGameOrder {
        CDOTAClientMsg_PauseGameOrder::new()
    }

    fn clear(&mut self) {
        self.order_id = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PauseGameOrder {
        static instance: CDOTAClientMsg_PauseGameOrder = CDOTAClientMsg_PauseGameOrder {
            order_id: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PauseGameOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PauseGameOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PauseGameOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PauseGameOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_VersusScene_PlayerBehavior)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_VersusScene_PlayerBehavior {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_VersusScene_PlayerBehavior.behavior)
    pub behavior: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_commonmessages::EDOTAVersusScenePlayerBehavior>>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_VersusScene_PlayerBehavior.play_activity)
    pub play_activity: ::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlayActivity>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_VersusScene_PlayerBehavior.chat_wheel)
    pub chat_wheel: ::protobuf::MessageField<super::dota_commonmessages::VersusScene_ChatWheel>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_VersusScene_PlayerBehavior.playback_rate)
    pub playback_rate: ::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlaybackRate>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_VersusScene_PlayerBehavior.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_VersusScene_PlayerBehavior {
    fn default() -> &'a CDOTAClientMsg_VersusScene_PlayerBehavior {
        <CDOTAClientMsg_VersusScene_PlayerBehavior as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_VersusScene_PlayerBehavior {
    pub fn new() -> CDOTAClientMsg_VersusScene_PlayerBehavior {
        ::std::default::Default::default()
    }

    // optional .dota.EDOTAVersusScenePlayerBehavior behavior = 1;

    pub fn behavior(&self) -> super::dota_commonmessages::EDOTAVersusScenePlayerBehavior {
        match self.behavior {
            Some(e) => e.enum_value_or(super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY),
            None => super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY,
        }
    }

    pub fn clear_behavior(&mut self) {
        self.behavior = ::std::option::Option::None;
    }

    pub fn has_behavior(&self) -> bool {
        self.behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_behavior(&mut self, v: super::dota_commonmessages::EDOTAVersusScenePlayerBehavior) {
        self.behavior = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "behavior",
            |m: &CDOTAClientMsg_VersusScene_PlayerBehavior| { &m.behavior },
            |m: &mut CDOTAClientMsg_VersusScene_PlayerBehavior| { &mut m.behavior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::VersusScene_PlayActivity>(
            "play_activity",
            |m: &CDOTAClientMsg_VersusScene_PlayerBehavior| { &m.play_activity },
            |m: &mut CDOTAClientMsg_VersusScene_PlayerBehavior| { &mut m.play_activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::VersusScene_ChatWheel>(
            "chat_wheel",
            |m: &CDOTAClientMsg_VersusScene_PlayerBehavior| { &m.chat_wheel },
            |m: &mut CDOTAClientMsg_VersusScene_PlayerBehavior| { &mut m.chat_wheel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::VersusScene_PlaybackRate>(
            "playback_rate",
            |m: &CDOTAClientMsg_VersusScene_PlayerBehavior| { &m.playback_rate },
            |m: &mut CDOTAClientMsg_VersusScene_PlayerBehavior| { &mut m.playback_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_VersusScene_PlayerBehavior>(
            "CDOTAClientMsg_VersusScene_PlayerBehavior",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_VersusScene_PlayerBehavior {
    const NAME: &'static str = "CDOTAClientMsg_VersusScene_PlayerBehavior";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.behavior = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.play_activity)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_wheel)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.playback_rate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.behavior {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.play_activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.behavior {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.play_activity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_VersusScene_PlayerBehavior {
        CDOTAClientMsg_VersusScene_PlayerBehavior::new()
    }

    fn clear(&mut self) {
        self.behavior = ::std::option::Option::None;
        self.play_activity.clear();
        self.chat_wheel.clear();
        self.playback_rate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_VersusScene_PlayerBehavior {
        static instance: CDOTAClientMsg_VersusScene_PlayerBehavior = CDOTAClientMsg_VersusScene_PlayerBehavior {
            behavior: ::std::option::Option::None,
            play_activity: ::protobuf::MessageField::none(),
            chat_wheel: ::protobuf::MessageField::none(),
            playback_rate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_VersusScene_PlayerBehavior {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_VersusScene_PlayerBehavior").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_VersusScene_PlayerBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_VersusScene_PlayerBehavior {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_EmptyItemSlotAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EmptyItemSlotAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EmptyItemSlotAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_EmptyItemSlotAlert.slot_index)
    pub slot_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_EmptyItemSlotAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EmptyItemSlotAlert {
    fn default() -> &'a CDOTAClientMsg_EmptyItemSlotAlert {
        <CDOTAClientMsg_EmptyItemSlotAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EmptyItemSlotAlert {
    pub fn new() -> CDOTAClientMsg_EmptyItemSlotAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 slot_index = 2;

    pub fn slot_index(&self) -> i32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: i32) {
        self.slot_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_EmptyItemSlotAlert| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_EmptyItemSlotAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_index",
            |m: &CDOTAClientMsg_EmptyItemSlotAlert| { &m.slot_index },
            |m: &mut CDOTAClientMsg_EmptyItemSlotAlert| { &mut m.slot_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_EmptyItemSlotAlert>(
            "CDOTAClientMsg_EmptyItemSlotAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_EmptyItemSlotAlert {
    const NAME: &'static str = "CDOTAClientMsg_EmptyItemSlotAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EmptyItemSlotAlert {
        CDOTAClientMsg_EmptyItemSlotAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EmptyItemSlotAlert {
        static instance: CDOTAClientMsg_EmptyItemSlotAlert = CDOTAClientMsg_EmptyItemSlotAlert {
            target_entindex: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_EmptyItemSlotAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_EmptyItemSlotAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_EmptyItemSlotAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_EmptyItemSlotAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_AddOverwatchReportMarker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AddOverwatchReportMarker {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AddOverwatchReportMarker.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AddOverwatchReportMarker.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EOverwatchReportReason>>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AddOverwatchReportMarker.seconds_ago)
    pub seconds_ago: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_AddOverwatchReportMarker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AddOverwatchReportMarker {
    fn default() -> &'a CDOTAClientMsg_AddOverwatchReportMarker {
        <CDOTAClientMsg_AddOverwatchReportMarker as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AddOverwatchReportMarker {
    pub fn new() -> CDOTAClientMsg_AddOverwatchReportMarker {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EOverwatchReportReason reason = 2;

    pub fn reason(&self) -> super::dota_shared_enums::EOverwatchReportReason {
        match self.reason {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EOverwatchReportReason::k_EOverwatchReportReason_Unknown),
            None => super::dota_shared_enums::EOverwatchReportReason::k_EOverwatchReportReason_Unknown,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: super::dota_shared_enums::EOverwatchReportReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 seconds_ago = 4;

    pub fn seconds_ago(&self) -> u32 {
        self.seconds_ago.unwrap_or(0)
    }

    pub fn clear_seconds_ago(&mut self) {
        self.seconds_ago = ::std::option::Option::None;
    }

    pub fn has_seconds_ago(&self) -> bool {
        self.seconds_ago.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_ago(&mut self, v: u32) {
        self.seconds_ago = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAClientMsg_AddOverwatchReportMarker| { &m.target_player_id },
            |m: &mut CDOTAClientMsg_AddOverwatchReportMarker| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CDOTAClientMsg_AddOverwatchReportMarker| { &m.reason },
            |m: &mut CDOTAClientMsg_AddOverwatchReportMarker| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_ago",
            |m: &CDOTAClientMsg_AddOverwatchReportMarker| { &m.seconds_ago },
            |m: &mut CDOTAClientMsg_AddOverwatchReportMarker| { &mut m.seconds_ago },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_AddOverwatchReportMarker>(
            "CDOTAClientMsg_AddOverwatchReportMarker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_AddOverwatchReportMarker {
    const NAME: &'static str = "CDOTAClientMsg_AddOverwatchReportMarker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.seconds_ago = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.seconds_ago {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.seconds_ago {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AddOverwatchReportMarker {
        CDOTAClientMsg_AddOverwatchReportMarker::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.seconds_ago = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AddOverwatchReportMarker {
        static instance: CDOTAClientMsg_AddOverwatchReportMarker = CDOTAClientMsg_AddOverwatchReportMarker {
            target_player_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            seconds_ago: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_AddOverwatchReportMarker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_AddOverwatchReportMarker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_AddOverwatchReportMarker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_AddOverwatchReportMarker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_AddCommunicationsReportMarker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AddCommunicationsReportMarker {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AddCommunicationsReportMarker.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_AddCommunicationsReportMarker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AddCommunicationsReportMarker {
    fn default() -> &'a CDOTAClientMsg_AddCommunicationsReportMarker {
        <CDOTAClientMsg_AddCommunicationsReportMarker as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AddCommunicationsReportMarker {
    pub fn new() -> CDOTAClientMsg_AddCommunicationsReportMarker {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAClientMsg_AddCommunicationsReportMarker| { &m.target_player_id },
            |m: &mut CDOTAClientMsg_AddCommunicationsReportMarker| { &mut m.target_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_AddCommunicationsReportMarker>(
            "CDOTAClientMsg_AddCommunicationsReportMarker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_AddCommunicationsReportMarker {
    const NAME: &'static str = "CDOTAClientMsg_AddCommunicationsReportMarker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AddCommunicationsReportMarker {
        CDOTAClientMsg_AddCommunicationsReportMarker::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AddCommunicationsReportMarker {
        static instance: CDOTAClientMsg_AddCommunicationsReportMarker = CDOTAClientMsg_AddCommunicationsReportMarker {
            target_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_AddCommunicationsReportMarker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_AddCommunicationsReportMarker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_AddCommunicationsReportMarker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_AddCommunicationsReportMarker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_AddCommunicationsBlockMarker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AddCommunicationsBlockMarker {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AddCommunicationsBlockMarker.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_AddCommunicationsBlockMarker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AddCommunicationsBlockMarker {
    fn default() -> &'a CDOTAClientMsg_AddCommunicationsBlockMarker {
        <CDOTAClientMsg_AddCommunicationsBlockMarker as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AddCommunicationsBlockMarker {
    pub fn new() -> CDOTAClientMsg_AddCommunicationsBlockMarker {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAClientMsg_AddCommunicationsBlockMarker| { &m.target_player_id },
            |m: &mut CDOTAClientMsg_AddCommunicationsBlockMarker| { &mut m.target_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_AddCommunicationsBlockMarker>(
            "CDOTAClientMsg_AddCommunicationsBlockMarker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_AddCommunicationsBlockMarker {
    const NAME: &'static str = "CDOTAClientMsg_AddCommunicationsBlockMarker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AddCommunicationsBlockMarker {
        CDOTAClientMsg_AddCommunicationsBlockMarker::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AddCommunicationsBlockMarker {
        static instance: CDOTAClientMsg_AddCommunicationsBlockMarker = CDOTAClientMsg_AddCommunicationsBlockMarker {
            target_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_AddCommunicationsBlockMarker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_AddCommunicationsBlockMarker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_AddCommunicationsBlockMarker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_AddCommunicationsBlockMarker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_AghsStatusAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AghsStatusAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AghsStatusAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AghsStatusAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AghsStatusAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_AghsStatusAlert.alert_type)
    pub alert_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_AghsStatusAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AghsStatusAlert {
    fn default() -> &'a CDOTAClientMsg_AghsStatusAlert {
        <CDOTAClientMsg_AghsStatusAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AghsStatusAlert {
    pub fn new() -> CDOTAClientMsg_AghsStatusAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(0)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 3;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 alert_type = 4;

    pub fn alert_type(&self) -> u32 {
        self.alert_type.unwrap_or(0)
    }

    pub fn clear_alert_type(&mut self) {
        self.alert_type = ::std::option::Option::None;
    }

    pub fn has_alert_type(&self) -> bool {
        self.alert_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alert_type(&mut self, v: u32) {
        self.alert_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_id",
            |m: &CDOTAClientMsg_AghsStatusAlert| { &m.source_player_id },
            |m: &mut CDOTAClientMsg_AghsStatusAlert| { &mut m.source_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAClientMsg_AghsStatusAlert| { &m.target_player_id },
            |m: &mut CDOTAClientMsg_AghsStatusAlert| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_AghsStatusAlert| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_AghsStatusAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alert_type",
            |m: &CDOTAClientMsg_AghsStatusAlert| { &m.alert_type },
            |m: &mut CDOTAClientMsg_AghsStatusAlert| { &mut m.alert_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_AghsStatusAlert>(
            "CDOTAClientMsg_AghsStatusAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_AghsStatusAlert {
    const NAME: &'static str = "CDOTAClientMsg_AghsStatusAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.alert_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.alert_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.alert_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AghsStatusAlert {
        CDOTAClientMsg_AghsStatusAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.alert_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AghsStatusAlert {
        static instance: CDOTAClientMsg_AghsStatusAlert = CDOTAClientMsg_AghsStatusAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            alert_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_AghsStatusAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_AghsStatusAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_AghsStatusAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_AghsStatusAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PerfReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PerfReport {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_frame_time)
    pub average_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_frame_time)
    pub max_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_compute_time)
    pub average_compute_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_compute_time)
    pub max_compute_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_client_tick_time)
    pub average_client_tick_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_client_tick_time)
    pub max_client_tick_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_client_simulate_time)
    pub average_client_simulate_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_client_simulate_time)
    pub max_client_simulate_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_output_time)
    pub average_output_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_output_time)
    pub max_output_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_wait_for_rendering_to_complete_time)
    pub average_wait_for_rendering_to_complete_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_wait_for_rendering_to_complete_time)
    pub max_wait_for_rendering_to_complete_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_swap_time)
    pub average_swap_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_swap_time)
    pub max_swap_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_frame_update_time)
    pub average_frame_update_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_frame_update_time)
    pub max_frame_update_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_idle_time)
    pub average_idle_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_idle_time)
    pub max_idle_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.average_input_processing_time)
    pub average_input_processing_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PerfReport.max_input_processing_time)
    pub max_input_processing_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PerfReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PerfReport {
    fn default() -> &'a CDOTAClientMsg_PerfReport {
        <CDOTAClientMsg_PerfReport as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PerfReport {
    pub fn new() -> CDOTAClientMsg_PerfReport {
        ::std::default::Default::default()
    }

    // optional float average_frame_time = 1;

    pub fn average_frame_time(&self) -> f32 {
        self.average_frame_time.unwrap_or(0.)
    }

    pub fn clear_average_frame_time(&mut self) {
        self.average_frame_time = ::std::option::Option::None;
    }

    pub fn has_average_frame_time(&self) -> bool {
        self.average_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_frame_time(&mut self, v: f32) {
        self.average_frame_time = ::std::option::Option::Some(v);
    }

    // optional float max_frame_time = 2;

    pub fn max_frame_time(&self) -> f32 {
        self.max_frame_time.unwrap_or(0.)
    }

    pub fn clear_max_frame_time(&mut self) {
        self.max_frame_time = ::std::option::Option::None;
    }

    pub fn has_max_frame_time(&self) -> bool {
        self.max_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_frame_time(&mut self, v: f32) {
        self.max_frame_time = ::std::option::Option::Some(v);
    }

    // optional float average_compute_time = 3;

    pub fn average_compute_time(&self) -> f32 {
        self.average_compute_time.unwrap_or(0.)
    }

    pub fn clear_average_compute_time(&mut self) {
        self.average_compute_time = ::std::option::Option::None;
    }

    pub fn has_average_compute_time(&self) -> bool {
        self.average_compute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_compute_time(&mut self, v: f32) {
        self.average_compute_time = ::std::option::Option::Some(v);
    }

    // optional float max_compute_time = 4;

    pub fn max_compute_time(&self) -> f32 {
        self.max_compute_time.unwrap_or(0.)
    }

    pub fn clear_max_compute_time(&mut self) {
        self.max_compute_time = ::std::option::Option::None;
    }

    pub fn has_max_compute_time(&self) -> bool {
        self.max_compute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_compute_time(&mut self, v: f32) {
        self.max_compute_time = ::std::option::Option::Some(v);
    }

    // optional float average_client_tick_time = 5;

    pub fn average_client_tick_time(&self) -> f32 {
        self.average_client_tick_time.unwrap_or(0.)
    }

    pub fn clear_average_client_tick_time(&mut self) {
        self.average_client_tick_time = ::std::option::Option::None;
    }

    pub fn has_average_client_tick_time(&self) -> bool {
        self.average_client_tick_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_client_tick_time(&mut self, v: f32) {
        self.average_client_tick_time = ::std::option::Option::Some(v);
    }

    // optional float max_client_tick_time = 6;

    pub fn max_client_tick_time(&self) -> f32 {
        self.max_client_tick_time.unwrap_or(0.)
    }

    pub fn clear_max_client_tick_time(&mut self) {
        self.max_client_tick_time = ::std::option::Option::None;
    }

    pub fn has_max_client_tick_time(&self) -> bool {
        self.max_client_tick_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_client_tick_time(&mut self, v: f32) {
        self.max_client_tick_time = ::std::option::Option::Some(v);
    }

    // optional float average_client_simulate_time = 7;

    pub fn average_client_simulate_time(&self) -> f32 {
        self.average_client_simulate_time.unwrap_or(0.)
    }

    pub fn clear_average_client_simulate_time(&mut self) {
        self.average_client_simulate_time = ::std::option::Option::None;
    }

    pub fn has_average_client_simulate_time(&self) -> bool {
        self.average_client_simulate_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_client_simulate_time(&mut self, v: f32) {
        self.average_client_simulate_time = ::std::option::Option::Some(v);
    }

    // optional float max_client_simulate_time = 8;

    pub fn max_client_simulate_time(&self) -> f32 {
        self.max_client_simulate_time.unwrap_or(0.)
    }

    pub fn clear_max_client_simulate_time(&mut self) {
        self.max_client_simulate_time = ::std::option::Option::None;
    }

    pub fn has_max_client_simulate_time(&self) -> bool {
        self.max_client_simulate_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_client_simulate_time(&mut self, v: f32) {
        self.max_client_simulate_time = ::std::option::Option::Some(v);
    }

    // optional float average_output_time = 9;

    pub fn average_output_time(&self) -> f32 {
        self.average_output_time.unwrap_or(0.)
    }

    pub fn clear_average_output_time(&mut self) {
        self.average_output_time = ::std::option::Option::None;
    }

    pub fn has_average_output_time(&self) -> bool {
        self.average_output_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_output_time(&mut self, v: f32) {
        self.average_output_time = ::std::option::Option::Some(v);
    }

    // optional float max_output_time = 10;

    pub fn max_output_time(&self) -> f32 {
        self.max_output_time.unwrap_or(0.)
    }

    pub fn clear_max_output_time(&mut self) {
        self.max_output_time = ::std::option::Option::None;
    }

    pub fn has_max_output_time(&self) -> bool {
        self.max_output_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_output_time(&mut self, v: f32) {
        self.max_output_time = ::std::option::Option::Some(v);
    }

    // optional float average_wait_for_rendering_to_complete_time = 11;

    pub fn average_wait_for_rendering_to_complete_time(&self) -> f32 {
        self.average_wait_for_rendering_to_complete_time.unwrap_or(0.)
    }

    pub fn clear_average_wait_for_rendering_to_complete_time(&mut self) {
        self.average_wait_for_rendering_to_complete_time = ::std::option::Option::None;
    }

    pub fn has_average_wait_for_rendering_to_complete_time(&self) -> bool {
        self.average_wait_for_rendering_to_complete_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_wait_for_rendering_to_complete_time(&mut self, v: f32) {
        self.average_wait_for_rendering_to_complete_time = ::std::option::Option::Some(v);
    }

    // optional float max_wait_for_rendering_to_complete_time = 12;

    pub fn max_wait_for_rendering_to_complete_time(&self) -> f32 {
        self.max_wait_for_rendering_to_complete_time.unwrap_or(0.)
    }

    pub fn clear_max_wait_for_rendering_to_complete_time(&mut self) {
        self.max_wait_for_rendering_to_complete_time = ::std::option::Option::None;
    }

    pub fn has_max_wait_for_rendering_to_complete_time(&self) -> bool {
        self.max_wait_for_rendering_to_complete_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_wait_for_rendering_to_complete_time(&mut self, v: f32) {
        self.max_wait_for_rendering_to_complete_time = ::std::option::Option::Some(v);
    }

    // optional float average_swap_time = 13;

    pub fn average_swap_time(&self) -> f32 {
        self.average_swap_time.unwrap_or(0.)
    }

    pub fn clear_average_swap_time(&mut self) {
        self.average_swap_time = ::std::option::Option::None;
    }

    pub fn has_average_swap_time(&self) -> bool {
        self.average_swap_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_swap_time(&mut self, v: f32) {
        self.average_swap_time = ::std::option::Option::Some(v);
    }

    // optional float max_swap_time = 14;

    pub fn max_swap_time(&self) -> f32 {
        self.max_swap_time.unwrap_or(0.)
    }

    pub fn clear_max_swap_time(&mut self) {
        self.max_swap_time = ::std::option::Option::None;
    }

    pub fn has_max_swap_time(&self) -> bool {
        self.max_swap_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_swap_time(&mut self, v: f32) {
        self.max_swap_time = ::std::option::Option::Some(v);
    }

    // optional float average_frame_update_time = 15;

    pub fn average_frame_update_time(&self) -> f32 {
        self.average_frame_update_time.unwrap_or(0.)
    }

    pub fn clear_average_frame_update_time(&mut self) {
        self.average_frame_update_time = ::std::option::Option::None;
    }

    pub fn has_average_frame_update_time(&self) -> bool {
        self.average_frame_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_frame_update_time(&mut self, v: f32) {
        self.average_frame_update_time = ::std::option::Option::Some(v);
    }

    // optional float max_frame_update_time = 16;

    pub fn max_frame_update_time(&self) -> f32 {
        self.max_frame_update_time.unwrap_or(0.)
    }

    pub fn clear_max_frame_update_time(&mut self) {
        self.max_frame_update_time = ::std::option::Option::None;
    }

    pub fn has_max_frame_update_time(&self) -> bool {
        self.max_frame_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_frame_update_time(&mut self, v: f32) {
        self.max_frame_update_time = ::std::option::Option::Some(v);
    }

    // optional float average_idle_time = 17;

    pub fn average_idle_time(&self) -> f32 {
        self.average_idle_time.unwrap_or(0.)
    }

    pub fn clear_average_idle_time(&mut self) {
        self.average_idle_time = ::std::option::Option::None;
    }

    pub fn has_average_idle_time(&self) -> bool {
        self.average_idle_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_idle_time(&mut self, v: f32) {
        self.average_idle_time = ::std::option::Option::Some(v);
    }

    // optional float max_idle_time = 18;

    pub fn max_idle_time(&self) -> f32 {
        self.max_idle_time.unwrap_or(0.)
    }

    pub fn clear_max_idle_time(&mut self) {
        self.max_idle_time = ::std::option::Option::None;
    }

    pub fn has_max_idle_time(&self) -> bool {
        self.max_idle_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_idle_time(&mut self, v: f32) {
        self.max_idle_time = ::std::option::Option::Some(v);
    }

    // optional float average_input_processing_time = 19;

    pub fn average_input_processing_time(&self) -> f32 {
        self.average_input_processing_time.unwrap_or(0.)
    }

    pub fn clear_average_input_processing_time(&mut self) {
        self.average_input_processing_time = ::std::option::Option::None;
    }

    pub fn has_average_input_processing_time(&self) -> bool {
        self.average_input_processing_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_input_processing_time(&mut self, v: f32) {
        self.average_input_processing_time = ::std::option::Option::Some(v);
    }

    // optional float max_input_processing_time = 20;

    pub fn max_input_processing_time(&self) -> f32 {
        self.max_input_processing_time.unwrap_or(0.)
    }

    pub fn clear_max_input_processing_time(&mut self) {
        self.max_input_processing_time = ::std::option::Option::None;
    }

    pub fn has_max_input_processing_time(&self) -> bool {
        self.max_input_processing_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_input_processing_time(&mut self, v: f32) {
        self.max_input_processing_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_frame_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_frame_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_frame_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_frame_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_frame_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_frame_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_compute_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_compute_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_compute_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_compute_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_compute_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_compute_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_client_tick_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_client_tick_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_client_tick_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_client_tick_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_client_tick_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_client_tick_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_client_simulate_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_client_simulate_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_client_simulate_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_client_simulate_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_client_simulate_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_client_simulate_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_output_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_output_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_output_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_output_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_output_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_output_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_wait_for_rendering_to_complete_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_wait_for_rendering_to_complete_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_wait_for_rendering_to_complete_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_wait_for_rendering_to_complete_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_wait_for_rendering_to_complete_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_wait_for_rendering_to_complete_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_swap_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_swap_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_swap_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_swap_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_swap_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_swap_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_frame_update_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_frame_update_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_frame_update_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_frame_update_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_frame_update_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_frame_update_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_idle_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_idle_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_idle_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_idle_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_idle_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_idle_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_input_processing_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.average_input_processing_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.average_input_processing_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_input_processing_time",
            |m: &CDOTAClientMsg_PerfReport| { &m.max_input_processing_time },
            |m: &mut CDOTAClientMsg_PerfReport| { &mut m.max_input_processing_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PerfReport>(
            "CDOTAClientMsg_PerfReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PerfReport {
    const NAME: &'static str = "CDOTAClientMsg_PerfReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.average_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.max_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.average_compute_time = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.max_compute_time = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.average_client_tick_time = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.max_client_tick_time = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.average_client_simulate_time = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.max_client_simulate_time = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.average_output_time = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.max_output_time = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.average_wait_for_rendering_to_complete_time = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.max_wait_for_rendering_to_complete_time = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.average_swap_time = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.max_swap_time = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.average_frame_update_time = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.max_frame_update_time = ::std::option::Option::Some(is.read_float()?);
                },
                141 => {
                    self.average_idle_time = ::std::option::Option::Some(is.read_float()?);
                },
                149 => {
                    self.max_idle_time = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.average_input_processing_time = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.max_input_processing_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_frame_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_frame_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_compute_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_compute_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_client_tick_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_client_tick_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_client_simulate_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_client_simulate_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_output_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_output_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_wait_for_rendering_to_complete_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_wait_for_rendering_to_complete_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_swap_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_swap_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_frame_update_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_frame_update_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.average_idle_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.max_idle_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.average_input_processing_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.max_input_processing_time {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.average_frame_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.max_frame_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.average_compute_time {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.max_compute_time {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.average_client_tick_time {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.max_client_tick_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.average_client_simulate_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.max_client_simulate_time {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.average_output_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.max_output_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.average_wait_for_rendering_to_complete_time {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.max_wait_for_rendering_to_complete_time {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.average_swap_time {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.max_swap_time {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.average_frame_update_time {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.max_frame_update_time {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.average_idle_time {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.max_idle_time {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.average_input_processing_time {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.max_input_processing_time {
            os.write_float(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PerfReport {
        CDOTAClientMsg_PerfReport::new()
    }

    fn clear(&mut self) {
        self.average_frame_time = ::std::option::Option::None;
        self.max_frame_time = ::std::option::Option::None;
        self.average_compute_time = ::std::option::Option::None;
        self.max_compute_time = ::std::option::Option::None;
        self.average_client_tick_time = ::std::option::Option::None;
        self.max_client_tick_time = ::std::option::Option::None;
        self.average_client_simulate_time = ::std::option::Option::None;
        self.max_client_simulate_time = ::std::option::Option::None;
        self.average_output_time = ::std::option::Option::None;
        self.max_output_time = ::std::option::Option::None;
        self.average_wait_for_rendering_to_complete_time = ::std::option::Option::None;
        self.max_wait_for_rendering_to_complete_time = ::std::option::Option::None;
        self.average_swap_time = ::std::option::Option::None;
        self.max_swap_time = ::std::option::Option::None;
        self.average_frame_update_time = ::std::option::Option::None;
        self.max_frame_update_time = ::std::option::Option::None;
        self.average_idle_time = ::std::option::Option::None;
        self.max_idle_time = ::std::option::Option::None;
        self.average_input_processing_time = ::std::option::Option::None;
        self.max_input_processing_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PerfReport {
        static instance: CDOTAClientMsg_PerfReport = CDOTAClientMsg_PerfReport {
            average_frame_time: ::std::option::Option::None,
            max_frame_time: ::std::option::Option::None,
            average_compute_time: ::std::option::Option::None,
            max_compute_time: ::std::option::Option::None,
            average_client_tick_time: ::std::option::Option::None,
            max_client_tick_time: ::std::option::Option::None,
            average_client_simulate_time: ::std::option::Option::None,
            max_client_simulate_time: ::std::option::Option::None,
            average_output_time: ::std::option::Option::None,
            max_output_time: ::std::option::Option::None,
            average_wait_for_rendering_to_complete_time: ::std::option::Option::None,
            max_wait_for_rendering_to_complete_time: ::std::option::Option::None,
            average_swap_time: ::std::option::Option::None,
            max_swap_time: ::std::option::Option::None,
            average_frame_update_time: ::std::option::Option::None,
            max_frame_update_time: ::std::option::Option::None,
            average_idle_time: ::std::option::Option::None,
            max_idle_time: ::std::option::Option::None,
            average_input_processing_time: ::std::option::Option::None,
            max_input_processing_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PerfReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PerfReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PerfReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PerfReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ContextualTips_Subscribe_Entry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ContextualTips_Subscribe_Entry.unsubscribe)
    pub unsubscribe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ContextualTips_Subscribe_Entry.tip_id)
    pub tip_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ContextualTips_Subscribe_Entry.prior_display_count)
    pub prior_display_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ContextualTips_Subscribe_Entry.variants_seen)
    pub variants_seen: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ContextualTips_Subscribe_Entry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    fn default() -> &'a CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        <CDOTAClientMsg_ContextualTips_Subscribe_Entry as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    pub fn new() -> CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        ::std::default::Default::default()
    }

    // optional bool unsubscribe = 1;

    pub fn unsubscribe(&self) -> bool {
        self.unsubscribe.unwrap_or(false)
    }

    pub fn clear_unsubscribe(&mut self) {
        self.unsubscribe = ::std::option::Option::None;
    }

    pub fn has_unsubscribe(&self) -> bool {
        self.unsubscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe(&mut self, v: bool) {
        self.unsubscribe = ::std::option::Option::Some(v);
    }

    // optional int32 tip_id = 2;

    pub fn tip_id(&self) -> i32 {
        self.tip_id.unwrap_or(0)
    }

    pub fn clear_tip_id(&mut self) {
        self.tip_id = ::std::option::Option::None;
    }

    pub fn has_tip_id(&self) -> bool {
        self.tip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_id(&mut self, v: i32) {
        self.tip_id = ::std::option::Option::Some(v);
    }

    // optional int32 prior_display_count = 3;

    pub fn prior_display_count(&self) -> i32 {
        self.prior_display_count.unwrap_or(0)
    }

    pub fn clear_prior_display_count(&mut self) {
        self.prior_display_count = ::std::option::Option::None;
    }

    pub fn has_prior_display_count(&self) -> bool {
        self.prior_display_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prior_display_count(&mut self, v: i32) {
        self.prior_display_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsubscribe",
            |m: &CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &m.unsubscribe },
            |m: &mut CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &mut m.unsubscribe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_id",
            |m: &CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &m.tip_id },
            |m: &mut CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &mut m.tip_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prior_display_count",
            |m: &CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &m.prior_display_count },
            |m: &mut CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &mut m.prior_display_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variants_seen",
            |m: &CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &m.variants_seen },
            |m: &mut CDOTAClientMsg_ContextualTips_Subscribe_Entry| { &mut m.variants_seen },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ContextualTips_Subscribe_Entry>(
            "CDOTAClientMsg_ContextualTips_Subscribe_Entry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    const NAME: &'static str = "CDOTAClientMsg_ContextualTips_Subscribe_Entry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unsubscribe = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.tip_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.prior_display_count = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.variants_seen)?;
                },
                32 => {
                    self.variants_seen.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unsubscribe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tip_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.prior_display_count {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.variants_seen {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unsubscribe {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tip_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.prior_display_count {
            os.write_int32(3, v)?;
        }
        for v in &self.variants_seen {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        CDOTAClientMsg_ContextualTips_Subscribe_Entry::new()
    }

    fn clear(&mut self) {
        self.unsubscribe = ::std::option::Option::None;
        self.tip_id = ::std::option::Option::None;
        self.prior_display_count = ::std::option::Option::None;
        self.variants_seen.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        static instance: CDOTAClientMsg_ContextualTips_Subscribe_Entry = CDOTAClientMsg_ContextualTips_Subscribe_Entry {
            unsubscribe: ::std::option::Option::None,
            tip_id: ::std::option::Option::None,
            prior_display_count: ::std::option::Option::None,
            variants_seen: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ContextualTips_Subscribe_Entry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ContextualTips_Subscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ContextualTips_Subscribe {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ContextualTips_Subscribe.tips)
    pub tips: ::std::vec::Vec<CDOTAClientMsg_ContextualTips_Subscribe_Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ContextualTips_Subscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ContextualTips_Subscribe {
    fn default() -> &'a CDOTAClientMsg_ContextualTips_Subscribe {
        <CDOTAClientMsg_ContextualTips_Subscribe as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ContextualTips_Subscribe {
    pub fn new() -> CDOTAClientMsg_ContextualTips_Subscribe {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tips",
            |m: &CDOTAClientMsg_ContextualTips_Subscribe| { &m.tips },
            |m: &mut CDOTAClientMsg_ContextualTips_Subscribe| { &mut m.tips },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ContextualTips_Subscribe>(
            "CDOTAClientMsg_ContextualTips_Subscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ContextualTips_Subscribe {
    const NAME: &'static str = "CDOTAClientMsg_ContextualTips_Subscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tips.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tips {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ContextualTips_Subscribe {
        CDOTAClientMsg_ContextualTips_Subscribe::new()
    }

    fn clear(&mut self) {
        self.tips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ContextualTips_Subscribe {
        static instance: CDOTAClientMsg_ContextualTips_Subscribe = CDOTAClientMsg_ContextualTips_Subscribe {
            tips: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ContextualTips_Subscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ContextualTips_Subscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ContextualTips_Subscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ContextualTips_Subscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChatMessage {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChatMessage.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChatMessage.message_text)
    pub message_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChatMessage {
    fn default() -> &'a CDOTAClientMsg_ChatMessage {
        <CDOTAClientMsg_ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChatMessage {
    pub fn new() -> CDOTAClientMsg_ChatMessage {
        ::std::default::Default::default()
    }

    // optional uint32 channel_type = 1;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional string message_text = 2;

    pub fn message_text(&self) -> &str {
        match self.message_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_text(&mut self) {
        self.message_text = ::std::option::Option::None;
    }

    pub fn has_message_text(&self) -> bool {
        self.message_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_text(&mut self, v: ::std::string::String) {
        self.message_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_text(&mut self) -> &mut ::std::string::String {
        if self.message_text.is_none() {
            self.message_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_text(&mut self) -> ::std::string::String {
        self.message_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_type",
            |m: &CDOTAClientMsg_ChatMessage| { &m.channel_type },
            |m: &mut CDOTAClientMsg_ChatMessage| { &mut m.channel_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_text",
            |m: &CDOTAClientMsg_ChatMessage| { &m.message_text },
            |m: &mut CDOTAClientMsg_ChatMessage| { &mut m.message_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ChatMessage>(
            "CDOTAClientMsg_ChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ChatMessage {
    const NAME: &'static str = "CDOTAClientMsg_ChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message_text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChatMessage {
        CDOTAClientMsg_ChatMessage::new()
    }

    fn clear(&mut self) {
        self.channel_type = ::std::option::Option::None;
        self.message_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChatMessage {
        static instance: CDOTAClientMsg_ChatMessage = CDOTAClientMsg_ChatMessage {
            channel_type: ::std::option::Option::None,
            message_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_DuelAccepted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DuelAccepted {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DuelAccepted.challenger_player_id)
    pub challenger_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_DuelAccepted.accepter_player_id)
    pub accepter_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_DuelAccepted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DuelAccepted {
    fn default() -> &'a CDOTAClientMsg_DuelAccepted {
        <CDOTAClientMsg_DuelAccepted as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DuelAccepted {
    pub fn new() -> CDOTAClientMsg_DuelAccepted {
        ::std::default::Default::default()
    }

    // optional int32 challenger_player_id = 1;

    pub fn challenger_player_id(&self) -> i32 {
        self.challenger_player_id.unwrap_or(0)
    }

    pub fn clear_challenger_player_id(&mut self) {
        self.challenger_player_id = ::std::option::Option::None;
    }

    pub fn has_challenger_player_id(&self) -> bool {
        self.challenger_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenger_player_id(&mut self, v: i32) {
        self.challenger_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 accepter_player_id = 2;

    pub fn accepter_player_id(&self) -> i32 {
        self.accepter_player_id.unwrap_or(0)
    }

    pub fn clear_accepter_player_id(&mut self) {
        self.accepter_player_id = ::std::option::Option::None;
    }

    pub fn has_accepter_player_id(&self) -> bool {
        self.accepter_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accepter_player_id(&mut self, v: i32) {
        self.accepter_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenger_player_id",
            |m: &CDOTAClientMsg_DuelAccepted| { &m.challenger_player_id },
            |m: &mut CDOTAClientMsg_DuelAccepted| { &mut m.challenger_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accepter_player_id",
            |m: &CDOTAClientMsg_DuelAccepted| { &m.accepter_player_id },
            |m: &mut CDOTAClientMsg_DuelAccepted| { &mut m.accepter_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_DuelAccepted>(
            "CDOTAClientMsg_DuelAccepted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_DuelAccepted {
    const NAME: &'static str = "CDOTAClientMsg_DuelAccepted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.challenger_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.accepter_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenger_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.accepter_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenger_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.accepter_player_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DuelAccepted {
        CDOTAClientMsg_DuelAccepted::new()
    }

    fn clear(&mut self) {
        self.challenger_player_id = ::std::option::Option::None;
        self.accepter_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DuelAccepted {
        static instance: CDOTAClientMsg_DuelAccepted = CDOTAClientMsg_DuelAccepted {
            challenger_player_id: ::std::option::Option::None,
            accepter_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_DuelAccepted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_DuelAccepted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_DuelAccepted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_DuelAccepted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_ChooseNeutralItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChooseNeutralItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChooseNeutralItem.neutral_item_index)
    pub neutral_item_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChooseNeutralItem.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_ChooseNeutralItem.slot_index)
    pub slot_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_ChooseNeutralItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChooseNeutralItem {
    fn default() -> &'a CDOTAClientMsg_ChooseNeutralItem {
        <CDOTAClientMsg_ChooseNeutralItem as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChooseNeutralItem {
    pub fn new() -> CDOTAClientMsg_ChooseNeutralItem {
        ::std::default::Default::default()
    }

    // optional int32 neutral_item_index = 1;

    pub fn neutral_item_index(&self) -> i32 {
        self.neutral_item_index.unwrap_or(0)
    }

    pub fn clear_neutral_item_index(&mut self) {
        self.neutral_item_index = ::std::option::Option::None;
    }

    pub fn has_neutral_item_index(&self) -> bool {
        self.neutral_item_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_item_index(&mut self, v: i32) {
        self.neutral_item_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 slot_index = 3;

    pub fn slot_index(&self) -> i32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: i32) {
        self.slot_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "neutral_item_index",
            |m: &CDOTAClientMsg_ChooseNeutralItem| { &m.neutral_item_index },
            |m: &mut CDOTAClientMsg_ChooseNeutralItem| { &mut m.neutral_item_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAClientMsg_ChooseNeutralItem| { &m.target_entindex },
            |m: &mut CDOTAClientMsg_ChooseNeutralItem| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_index",
            |m: &CDOTAClientMsg_ChooseNeutralItem| { &m.slot_index },
            |m: &mut CDOTAClientMsg_ChooseNeutralItem| { &mut m.slot_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_ChooseNeutralItem>(
            "CDOTAClientMsg_ChooseNeutralItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_ChooseNeutralItem {
    const NAME: &'static str = "CDOTAClientMsg_ChooseNeutralItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.neutral_item_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.neutral_item_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.neutral_item_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChooseNeutralItem {
        CDOTAClientMsg_ChooseNeutralItem::new()
    }

    fn clear(&mut self) {
        self.neutral_item_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChooseNeutralItem {
        static instance: CDOTAClientMsg_ChooseNeutralItem = CDOTAClientMsg_ChooseNeutralItem {
            neutral_item_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_ChooseNeutralItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_ChooseNeutralItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_ChooseNeutralItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_ChooseNeutralItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PlayerDraftPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftPick {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PlayerDraftPick.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PlayerDraftPick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftPick {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftPick {
        <CDOTAClientMsg_PlayerDraftPick as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftPick {
    pub fn new() -> CDOTAClientMsg_PlayerDraftPick {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_PlayerDraftPick| { &m.player_id },
            |m: &mut CDOTAClientMsg_PlayerDraftPick| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PlayerDraftPick>(
            "CDOTAClientMsg_PlayerDraftPick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PlayerDraftPick {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftPick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftPick {
        CDOTAClientMsg_PlayerDraftPick::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftPick {
        static instance: CDOTAClientMsg_PlayerDraftPick = CDOTAClientMsg_PlayerDraftPick {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PlayerDraftPick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PlayerDraftPick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PlayerDraftPick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PlayerDraftPick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PlayerDraftSuggest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftSuggest {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PlayerDraftSuggest.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PlayerDraftSuggest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftSuggest {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftSuggest {
        <CDOTAClientMsg_PlayerDraftSuggest as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftSuggest {
    pub fn new() -> CDOTAClientMsg_PlayerDraftSuggest {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAClientMsg_PlayerDraftSuggest| { &m.player_id },
            |m: &mut CDOTAClientMsg_PlayerDraftSuggest| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PlayerDraftSuggest>(
            "CDOTAClientMsg_PlayerDraftSuggest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PlayerDraftSuggest {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftSuggest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftSuggest {
        CDOTAClientMsg_PlayerDraftSuggest::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftSuggest {
        static instance: CDOTAClientMsg_PlayerDraftSuggest = CDOTAClientMsg_PlayerDraftSuggest {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PlayerDraftSuggest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PlayerDraftSuggest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PlayerDraftSuggest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PlayerDraftSuggest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PlayerDraftPreferRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftPreferRole {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PlayerDraftPreferRole.role_idx)
    pub role_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PlayerDraftPreferRole.desired)
    pub desired: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PlayerDraftPreferRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftPreferRole {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftPreferRole {
        <CDOTAClientMsg_PlayerDraftPreferRole as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftPreferRole {
    pub fn new() -> CDOTAClientMsg_PlayerDraftPreferRole {
        ::std::default::Default::default()
    }

    // optional int32 role_idx = 1;

    pub fn role_idx(&self) -> i32 {
        self.role_idx.unwrap_or(0)
    }

    pub fn clear_role_idx(&mut self) {
        self.role_idx = ::std::option::Option::None;
    }

    pub fn has_role_idx(&self) -> bool {
        self.role_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_idx(&mut self, v: i32) {
        self.role_idx = ::std::option::Option::Some(v);
    }

    // optional bool desired = 2;

    pub fn desired(&self) -> bool {
        self.desired.unwrap_or(false)
    }

    pub fn clear_desired(&mut self) {
        self.desired = ::std::option::Option::None;
    }

    pub fn has_desired(&self) -> bool {
        self.desired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired(&mut self, v: bool) {
        self.desired = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_idx",
            |m: &CDOTAClientMsg_PlayerDraftPreferRole| { &m.role_idx },
            |m: &mut CDOTAClientMsg_PlayerDraftPreferRole| { &mut m.role_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired",
            |m: &CDOTAClientMsg_PlayerDraftPreferRole| { &m.desired },
            |m: &mut CDOTAClientMsg_PlayerDraftPreferRole| { &mut m.desired },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PlayerDraftPreferRole>(
            "CDOTAClientMsg_PlayerDraftPreferRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PlayerDraftPreferRole {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftPreferRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.desired = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.desired {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.role_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.desired {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftPreferRole {
        CDOTAClientMsg_PlayerDraftPreferRole::new()
    }

    fn clear(&mut self) {
        self.role_idx = ::std::option::Option::None;
        self.desired = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftPreferRole {
        static instance: CDOTAClientMsg_PlayerDraftPreferRole = CDOTAClientMsg_PlayerDraftPreferRole {
            role_idx: ::std::option::Option::None,
            desired: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PlayerDraftPreferRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PlayerDraftPreferRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PlayerDraftPreferRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PlayerDraftPreferRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAClientMsg_PlayerDraftPreferTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftPreferTeam {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientMsg_PlayerDraftPreferTeam.team)
    pub team: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientMsg_PlayerDraftPreferTeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftPreferTeam {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftPreferTeam {
        <CDOTAClientMsg_PlayerDraftPreferTeam as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftPreferTeam {
    pub fn new() -> CDOTAClientMsg_PlayerDraftPreferTeam {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CDOTAClientMsg_PlayerDraftPreferTeam| { &m.team },
            |m: &mut CDOTAClientMsg_PlayerDraftPreferTeam| { &mut m.team },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientMsg_PlayerDraftPreferTeam>(
            "CDOTAClientMsg_PlayerDraftPreferTeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientMsg_PlayerDraftPreferTeam {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftPreferTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftPreferTeam {
        CDOTAClientMsg_PlayerDraftPreferTeam::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftPreferTeam {
        static instance: CDOTAClientMsg_PlayerDraftPreferTeam = CDOTAClientMsg_PlayerDraftPreferTeam {
            team: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientMsg_PlayerDraftPreferTeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientMsg_PlayerDraftPreferTeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientMsg_PlayerDraftPreferTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientMsg_PlayerDraftPreferTeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDotaClientMessages)
pub enum EDotaClientMessages {
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_MapLine)
    DOTA_CM_MapLine = 301,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AspectRatio)
    DOTA_CM_AspectRatio = 302,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_MapPing)
    DOTA_CM_MapPing = 303,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_UnitsAutoAttack)
    DOTA_CM_UnitsAutoAttack = 304,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SearchString)
    DOTA_CM_SearchString = 307,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_Pause)
    DOTA_CM_Pause = 308,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ShopViewMode)
    DOTA_CM_ShopViewMode = 309,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SetUnitShareFlag)
    DOTA_CM_SetUnitShareFlag = 310,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SwapRequest)
    DOTA_CM_SwapRequest = 311,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SwapAccept)
    DOTA_CM_SwapAccept = 312,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_WorldLine)
    DOTA_CM_WorldLine = 313,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_RequestGraphUpdate)
    DOTA_CM_RequestGraphUpdate = 314,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ItemAlert)
    DOTA_CM_ItemAlert = 315,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ChatWheel)
    DOTA_CM_ChatWheel = 316,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SendStatPopup)
    DOTA_CM_SendStatPopup = 317,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_BeginLastHitChallenge)
    DOTA_CM_BeginLastHitChallenge = 318,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_UpdateQuickBuy)
    DOTA_CM_UpdateQuickBuy = 319,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_UpdateCoachListen)
    DOTA_CM_UpdateCoachListen = 320,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_CoachHUDPing)
    DOTA_CM_CoachHUDPing = 321,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_RecordVote)
    DOTA_CM_RecordVote = 322,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_UnitsAutoAttackAfterSpell)
    DOTA_CM_UnitsAutoAttackAfterSpell = 323,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_WillPurchaseAlert)
    DOTA_CM_WillPurchaseAlert = 324,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayerShowCase)
    DOTA_CM_PlayerShowCase = 325,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_TeleportRequiresHalt)
    DOTA_CM_TeleportRequiresHalt = 326,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_CameraZoomAmount)
    DOTA_CM_CameraZoomAmount = 327,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_BroadcasterUsingCamerman)
    DOTA_CM_BroadcasterUsingCamerman = 328,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_BroadcasterUsingAssistedCameraOperator)
    DOTA_CM_BroadcasterUsingAssistedCameraOperator = 329,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_EnemyItemAlert)
    DOTA_CM_EnemyItemAlert = 330,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_FreeInventory)
    DOTA_CM_FreeInventory = 331,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_BuyBackStateAlert)
    DOTA_CM_BuyBackStateAlert = 332,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_QuickBuyAlert)
    DOTA_CM_QuickBuyAlert = 333,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_HeroStatueLike)
    DOTA_CM_HeroStatueLike = 334,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ModifierAlert)
    DOTA_CM_ModifierAlert = 335,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_TeamShowcaseEditor)
    DOTA_CM_TeamShowcaseEditor = 336,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_HPManaAlert)
    DOTA_CM_HPManaAlert = 337,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_GlyphAlert)
    DOTA_CM_GlyphAlert = 338,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_TeamShowcaseClientData)
    DOTA_CM_TeamShowcaseClientData = 339,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayTeamShowcase)
    DOTA_CM_PlayTeamShowcase = 340,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_EventCNY2015Cmd)
    DOTA_CM_EventCNY2015Cmd = 341,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_FillEmptySlotsWithBots)
    DOTA_CM_FillEmptySlotsWithBots = 342,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_DemoHero)
    DOTA_CM_DemoHero = 343,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AbilityLearnModeToggled)
    DOTA_CM_AbilityLearnModeToggled = 344,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AbilityStartUse)
    DOTA_CM_AbilityStartUse = 345,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ChallengeSelect)
    DOTA_CM_ChallengeSelect = 346,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ChallengeReroll)
    DOTA_CM_ChallengeReroll = 347,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ClickedBuff)
    DOTA_CM_ClickedBuff = 348,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_CoinWager)
    DOTA_CM_CoinWager = 349,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ExecuteOrders)
    DOTA_CM_ExecuteOrders = 350,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_XPAlert)
    DOTA_CM_XPAlert = 351,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_EventPointsTip)
    DOTA_CM_EventPointsTip = 353,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_KillMyHero)
    DOTA_CM_KillMyHero = 355,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_QuestStatus)
    DOTA_CM_QuestStatus = 356,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ToggleAutoattack)
    DOTA_CM_ToggleAutoattack = 357,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SpecialAbility)
    DOTA_CM_SpecialAbility = 358,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_KillcamDamageTaken)
    DOTA_CM_KillcamDamageTaken = 359,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SetEnemyStartingPosition)
    DOTA_CM_SetEnemyStartingPosition = 360,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SetDesiredWardPlacement)
    DOTA_CM_SetDesiredWardPlacement = 361,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_RollDice)
    DOTA_CM_RollDice = 362,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_FlipCoin)
    DOTA_CM_FlipCoin = 363,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_RequestItemSuggestions)
    DOTA_CM_RequestItemSuggestions = 364,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_MakeTeamCaptain)
    DOTA_CM_MakeTeamCaptain = 365,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_CoinWagerToken)
    DOTA_CM_CoinWagerToken = 366,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_RankWager)
    DOTA_CM_RankWager = 367,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_DismissAllStatPopups)
    DOTA_CM_DismissAllStatPopups = 368,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_HelpTipSystemStateChanged)
    DOTA_CM_HelpTipSystemStateChanged = 369,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ChannelRequiresHalt)
    DOTA_CM_ChannelRequiresHalt = 370,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_RequestBulkCombatLog)
    DOTA_CM_RequestBulkCombatLog = 371,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AbilityDraftRequestAbility)
    DOTA_CM_AbilityDraftRequestAbility = 372,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_GuideSelectOption)
    DOTA_CM_GuideSelectOption = 373,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_GuideSelected)
    DOTA_CM_GuideSelected = 374,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_DamageReport)
    DOTA_CM_DamageReport = 375,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SalutePlayer)
    DOTA_CM_SalutePlayer = 376,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SprayWheel)
    DOTA_CM_SprayWheel = 377,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_TipAlert)
    DOTA_CM_TipAlert = 378,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_EmptyTeleportAlert)
    DOTA_CM_EmptyTeleportAlert = 379,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_RadarAlert)
    DOTA_CM_RadarAlert = 380,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_TalentTreeAlert)
    DOTA_CM_TalentTreeAlert = 381,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_SetCavernMapVariant)
    DOTA_CM_SetCavernMapVariant = 382,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PauseGameOrder)
    DOTA_CM_PauseGameOrder = 383,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_VersusScene_PlayerBehavior)
    DOTA_CM_VersusScene_PlayerBehavior = 384,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayerBounty)
    DOTA_CM_PlayerBounty = 385,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayerBountyCancel)
    DOTA_CM_PlayerBountyCancel = 386,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_EmptyItemSlotAlert)
    DOTA_CM_EmptyItemSlotAlert = 388,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AddOverwatchReportMarker)
    DOTA_CM_AddOverwatchReportMarker = 389,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AghsStatusAlert)
    DOTA_CM_AghsStatusAlert = 390,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PerfReport)
    DOTA_CM_PerfReport = 391,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ContextualTips_Subscribe)
    DOTA_CM_ContextualTips_Subscribe = 393,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ChatMessage)
    DOTA_CM_ChatMessage = 394,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AddCommunicationsReportMarker)
    DOTA_CM_AddCommunicationsReportMarker = 395,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_AddCommunicationsBlockMarker)
    DOTA_CM_AddCommunicationsBlockMarker = 396,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_NeutralCampAlert)
    DOTA_CM_NeutralCampAlert = 397,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_DuelAccepted)
    DOTA_CM_DuelAccepted = 398,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_ChooseNeutralItem)
    DOTA_CM_ChooseNeutralItem = 399,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayerDraftPick)
    DOTA_CM_PlayerDraftPick = 800,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayerDraftSuggest)
    DOTA_CM_PlayerDraftSuggest = 801,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayerDraftPreferRole)
    DOTA_CM_PlayerDraftPreferRole = 802,
    // @@protoc_insertion_point(enum_value:dota.EDotaClientMessages.DOTA_CM_PlayerDraftPreferTeam)
    DOTA_CM_PlayerDraftPreferTeam = 803,
}

impl ::protobuf::Enum for EDotaClientMessages {
    const NAME: &'static str = "EDotaClientMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaClientMessages> {
        match value {
            301 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapLine),
            302 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AspectRatio),
            303 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapPing),
            304 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttack),
            307 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SearchString),
            308 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_Pause),
            309 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ShopViewMode),
            310 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetUnitShareFlag),
            311 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapRequest),
            312 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapAccept),
            313 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WorldLine),
            314 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestGraphUpdate),
            315 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ItemAlert),
            316 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatWheel),
            317 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SendStatPopup),
            318 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BeginLastHitChallenge),
            319 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateQuickBuy),
            320 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateCoachListen),
            321 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoachHUDPing),
            322 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RecordVote),
            323 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttackAfterSpell),
            324 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WillPurchaseAlert),
            325 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerShowCase),
            326 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeleportRequiresHalt),
            327 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CameraZoomAmount),
            328 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingCamerman),
            329 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingAssistedCameraOperator),
            330 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EnemyItemAlert),
            331 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FreeInventory),
            332 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BuyBackStateAlert),
            333 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuickBuyAlert),
            334 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HeroStatueLike),
            335 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ModifierAlert),
            336 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseEditor),
            337 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HPManaAlert),
            338 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GlyphAlert),
            339 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseClientData),
            340 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayTeamShowcase),
            341 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventCNY2015Cmd),
            342 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FillEmptySlotsWithBots),
            343 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DemoHero),
            344 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityLearnModeToggled),
            345 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityStartUse),
            346 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeSelect),
            347 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeReroll),
            348 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ClickedBuff),
            349 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWager),
            350 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ExecuteOrders),
            351 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_XPAlert),
            353 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventPointsTip),
            355 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillMyHero),
            356 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuestStatus),
            357 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ToggleAutoattack),
            358 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SpecialAbility),
            359 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillcamDamageTaken),
            360 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetEnemyStartingPosition),
            361 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetDesiredWardPlacement),
            362 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RollDice),
            363 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FlipCoin),
            364 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestItemSuggestions),
            365 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MakeTeamCaptain),
            366 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWagerToken),
            367 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RankWager),
            368 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DismissAllStatPopups),
            369 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HelpTipSystemStateChanged),
            370 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChannelRequiresHalt),
            371 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestBulkCombatLog),
            372 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityDraftRequestAbility),
            373 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelectOption),
            374 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelected),
            375 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DamageReport),
            376 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SalutePlayer),
            377 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SprayWheel),
            378 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TipAlert),
            379 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyTeleportAlert),
            380 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RadarAlert),
            381 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TalentTreeAlert),
            382 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetCavernMapVariant),
            383 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PauseGameOrder),
            384 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_VersusScene_PlayerBehavior),
            385 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBounty),
            386 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBountyCancel),
            388 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyItemSlotAlert),
            389 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddOverwatchReportMarker),
            390 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AghsStatusAlert),
            391 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PerfReport),
            393 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ContextualTips_Subscribe),
            394 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatMessage),
            395 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsReportMarker),
            396 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsBlockMarker),
            397 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_NeutralCampAlert),
            398 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DuelAccepted),
            399 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChooseNeutralItem),
            800 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPick),
            801 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftSuggest),
            802 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferRole),
            803 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferTeam),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDotaClientMessages> {
        match str {
            "DOTA_CM_MapLine" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapLine),
            "DOTA_CM_AspectRatio" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AspectRatio),
            "DOTA_CM_MapPing" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapPing),
            "DOTA_CM_UnitsAutoAttack" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttack),
            "DOTA_CM_SearchString" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SearchString),
            "DOTA_CM_Pause" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_Pause),
            "DOTA_CM_ShopViewMode" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ShopViewMode),
            "DOTA_CM_SetUnitShareFlag" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetUnitShareFlag),
            "DOTA_CM_SwapRequest" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapRequest),
            "DOTA_CM_SwapAccept" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapAccept),
            "DOTA_CM_WorldLine" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WorldLine),
            "DOTA_CM_RequestGraphUpdate" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestGraphUpdate),
            "DOTA_CM_ItemAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ItemAlert),
            "DOTA_CM_ChatWheel" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatWheel),
            "DOTA_CM_SendStatPopup" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SendStatPopup),
            "DOTA_CM_BeginLastHitChallenge" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BeginLastHitChallenge),
            "DOTA_CM_UpdateQuickBuy" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateQuickBuy),
            "DOTA_CM_UpdateCoachListen" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateCoachListen),
            "DOTA_CM_CoachHUDPing" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoachHUDPing),
            "DOTA_CM_RecordVote" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RecordVote),
            "DOTA_CM_UnitsAutoAttackAfterSpell" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttackAfterSpell),
            "DOTA_CM_WillPurchaseAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WillPurchaseAlert),
            "DOTA_CM_PlayerShowCase" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerShowCase),
            "DOTA_CM_TeleportRequiresHalt" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeleportRequiresHalt),
            "DOTA_CM_CameraZoomAmount" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CameraZoomAmount),
            "DOTA_CM_BroadcasterUsingCamerman" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingCamerman),
            "DOTA_CM_BroadcasterUsingAssistedCameraOperator" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingAssistedCameraOperator),
            "DOTA_CM_EnemyItemAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EnemyItemAlert),
            "DOTA_CM_FreeInventory" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FreeInventory),
            "DOTA_CM_BuyBackStateAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BuyBackStateAlert),
            "DOTA_CM_QuickBuyAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuickBuyAlert),
            "DOTA_CM_HeroStatueLike" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HeroStatueLike),
            "DOTA_CM_ModifierAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ModifierAlert),
            "DOTA_CM_TeamShowcaseEditor" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseEditor),
            "DOTA_CM_HPManaAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HPManaAlert),
            "DOTA_CM_GlyphAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GlyphAlert),
            "DOTA_CM_TeamShowcaseClientData" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseClientData),
            "DOTA_CM_PlayTeamShowcase" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayTeamShowcase),
            "DOTA_CM_EventCNY2015Cmd" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventCNY2015Cmd),
            "DOTA_CM_FillEmptySlotsWithBots" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FillEmptySlotsWithBots),
            "DOTA_CM_DemoHero" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DemoHero),
            "DOTA_CM_AbilityLearnModeToggled" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityLearnModeToggled),
            "DOTA_CM_AbilityStartUse" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityStartUse),
            "DOTA_CM_ChallengeSelect" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeSelect),
            "DOTA_CM_ChallengeReroll" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeReroll),
            "DOTA_CM_ClickedBuff" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ClickedBuff),
            "DOTA_CM_CoinWager" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWager),
            "DOTA_CM_ExecuteOrders" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ExecuteOrders),
            "DOTA_CM_XPAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_XPAlert),
            "DOTA_CM_EventPointsTip" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventPointsTip),
            "DOTA_CM_KillMyHero" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillMyHero),
            "DOTA_CM_QuestStatus" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuestStatus),
            "DOTA_CM_ToggleAutoattack" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ToggleAutoattack),
            "DOTA_CM_SpecialAbility" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SpecialAbility),
            "DOTA_CM_KillcamDamageTaken" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillcamDamageTaken),
            "DOTA_CM_SetEnemyStartingPosition" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetEnemyStartingPosition),
            "DOTA_CM_SetDesiredWardPlacement" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetDesiredWardPlacement),
            "DOTA_CM_RollDice" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RollDice),
            "DOTA_CM_FlipCoin" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FlipCoin),
            "DOTA_CM_RequestItemSuggestions" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestItemSuggestions),
            "DOTA_CM_MakeTeamCaptain" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MakeTeamCaptain),
            "DOTA_CM_CoinWagerToken" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWagerToken),
            "DOTA_CM_RankWager" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RankWager),
            "DOTA_CM_DismissAllStatPopups" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DismissAllStatPopups),
            "DOTA_CM_HelpTipSystemStateChanged" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HelpTipSystemStateChanged),
            "DOTA_CM_ChannelRequiresHalt" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChannelRequiresHalt),
            "DOTA_CM_RequestBulkCombatLog" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestBulkCombatLog),
            "DOTA_CM_AbilityDraftRequestAbility" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityDraftRequestAbility),
            "DOTA_CM_GuideSelectOption" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelectOption),
            "DOTA_CM_GuideSelected" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelected),
            "DOTA_CM_DamageReport" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DamageReport),
            "DOTA_CM_SalutePlayer" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SalutePlayer),
            "DOTA_CM_SprayWheel" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SprayWheel),
            "DOTA_CM_TipAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TipAlert),
            "DOTA_CM_EmptyTeleportAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyTeleportAlert),
            "DOTA_CM_RadarAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RadarAlert),
            "DOTA_CM_TalentTreeAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TalentTreeAlert),
            "DOTA_CM_SetCavernMapVariant" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetCavernMapVariant),
            "DOTA_CM_PauseGameOrder" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PauseGameOrder),
            "DOTA_CM_VersusScene_PlayerBehavior" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_VersusScene_PlayerBehavior),
            "DOTA_CM_PlayerBounty" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBounty),
            "DOTA_CM_PlayerBountyCancel" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBountyCancel),
            "DOTA_CM_EmptyItemSlotAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyItemSlotAlert),
            "DOTA_CM_AddOverwatchReportMarker" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddOverwatchReportMarker),
            "DOTA_CM_AghsStatusAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AghsStatusAlert),
            "DOTA_CM_PerfReport" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PerfReport),
            "DOTA_CM_ContextualTips_Subscribe" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ContextualTips_Subscribe),
            "DOTA_CM_ChatMessage" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatMessage),
            "DOTA_CM_AddCommunicationsReportMarker" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsReportMarker),
            "DOTA_CM_AddCommunicationsBlockMarker" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsBlockMarker),
            "DOTA_CM_NeutralCampAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_NeutralCampAlert),
            "DOTA_CM_DuelAccepted" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DuelAccepted),
            "DOTA_CM_ChooseNeutralItem" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChooseNeutralItem),
            "DOTA_CM_PlayerDraftPick" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPick),
            "DOTA_CM_PlayerDraftSuggest" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftSuggest),
            "DOTA_CM_PlayerDraftPreferRole" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferRole),
            "DOTA_CM_PlayerDraftPreferTeam" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferTeam),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDotaClientMessages] = &[
        EDotaClientMessages::DOTA_CM_MapLine,
        EDotaClientMessages::DOTA_CM_AspectRatio,
        EDotaClientMessages::DOTA_CM_MapPing,
        EDotaClientMessages::DOTA_CM_UnitsAutoAttack,
        EDotaClientMessages::DOTA_CM_SearchString,
        EDotaClientMessages::DOTA_CM_Pause,
        EDotaClientMessages::DOTA_CM_ShopViewMode,
        EDotaClientMessages::DOTA_CM_SetUnitShareFlag,
        EDotaClientMessages::DOTA_CM_SwapRequest,
        EDotaClientMessages::DOTA_CM_SwapAccept,
        EDotaClientMessages::DOTA_CM_WorldLine,
        EDotaClientMessages::DOTA_CM_RequestGraphUpdate,
        EDotaClientMessages::DOTA_CM_ItemAlert,
        EDotaClientMessages::DOTA_CM_ChatWheel,
        EDotaClientMessages::DOTA_CM_SendStatPopup,
        EDotaClientMessages::DOTA_CM_BeginLastHitChallenge,
        EDotaClientMessages::DOTA_CM_UpdateQuickBuy,
        EDotaClientMessages::DOTA_CM_UpdateCoachListen,
        EDotaClientMessages::DOTA_CM_CoachHUDPing,
        EDotaClientMessages::DOTA_CM_RecordVote,
        EDotaClientMessages::DOTA_CM_UnitsAutoAttackAfterSpell,
        EDotaClientMessages::DOTA_CM_WillPurchaseAlert,
        EDotaClientMessages::DOTA_CM_PlayerShowCase,
        EDotaClientMessages::DOTA_CM_TeleportRequiresHalt,
        EDotaClientMessages::DOTA_CM_CameraZoomAmount,
        EDotaClientMessages::DOTA_CM_BroadcasterUsingCamerman,
        EDotaClientMessages::DOTA_CM_BroadcasterUsingAssistedCameraOperator,
        EDotaClientMessages::DOTA_CM_EnemyItemAlert,
        EDotaClientMessages::DOTA_CM_FreeInventory,
        EDotaClientMessages::DOTA_CM_BuyBackStateAlert,
        EDotaClientMessages::DOTA_CM_QuickBuyAlert,
        EDotaClientMessages::DOTA_CM_HeroStatueLike,
        EDotaClientMessages::DOTA_CM_ModifierAlert,
        EDotaClientMessages::DOTA_CM_TeamShowcaseEditor,
        EDotaClientMessages::DOTA_CM_HPManaAlert,
        EDotaClientMessages::DOTA_CM_GlyphAlert,
        EDotaClientMessages::DOTA_CM_TeamShowcaseClientData,
        EDotaClientMessages::DOTA_CM_PlayTeamShowcase,
        EDotaClientMessages::DOTA_CM_EventCNY2015Cmd,
        EDotaClientMessages::DOTA_CM_FillEmptySlotsWithBots,
        EDotaClientMessages::DOTA_CM_DemoHero,
        EDotaClientMessages::DOTA_CM_AbilityLearnModeToggled,
        EDotaClientMessages::DOTA_CM_AbilityStartUse,
        EDotaClientMessages::DOTA_CM_ChallengeSelect,
        EDotaClientMessages::DOTA_CM_ChallengeReroll,
        EDotaClientMessages::DOTA_CM_ClickedBuff,
        EDotaClientMessages::DOTA_CM_CoinWager,
        EDotaClientMessages::DOTA_CM_ExecuteOrders,
        EDotaClientMessages::DOTA_CM_XPAlert,
        EDotaClientMessages::DOTA_CM_EventPointsTip,
        EDotaClientMessages::DOTA_CM_KillMyHero,
        EDotaClientMessages::DOTA_CM_QuestStatus,
        EDotaClientMessages::DOTA_CM_ToggleAutoattack,
        EDotaClientMessages::DOTA_CM_SpecialAbility,
        EDotaClientMessages::DOTA_CM_KillcamDamageTaken,
        EDotaClientMessages::DOTA_CM_SetEnemyStartingPosition,
        EDotaClientMessages::DOTA_CM_SetDesiredWardPlacement,
        EDotaClientMessages::DOTA_CM_RollDice,
        EDotaClientMessages::DOTA_CM_FlipCoin,
        EDotaClientMessages::DOTA_CM_RequestItemSuggestions,
        EDotaClientMessages::DOTA_CM_MakeTeamCaptain,
        EDotaClientMessages::DOTA_CM_CoinWagerToken,
        EDotaClientMessages::DOTA_CM_RankWager,
        EDotaClientMessages::DOTA_CM_DismissAllStatPopups,
        EDotaClientMessages::DOTA_CM_HelpTipSystemStateChanged,
        EDotaClientMessages::DOTA_CM_ChannelRequiresHalt,
        EDotaClientMessages::DOTA_CM_RequestBulkCombatLog,
        EDotaClientMessages::DOTA_CM_AbilityDraftRequestAbility,
        EDotaClientMessages::DOTA_CM_GuideSelectOption,
        EDotaClientMessages::DOTA_CM_GuideSelected,
        EDotaClientMessages::DOTA_CM_DamageReport,
        EDotaClientMessages::DOTA_CM_SalutePlayer,
        EDotaClientMessages::DOTA_CM_SprayWheel,
        EDotaClientMessages::DOTA_CM_TipAlert,
        EDotaClientMessages::DOTA_CM_EmptyTeleportAlert,
        EDotaClientMessages::DOTA_CM_RadarAlert,
        EDotaClientMessages::DOTA_CM_TalentTreeAlert,
        EDotaClientMessages::DOTA_CM_SetCavernMapVariant,
        EDotaClientMessages::DOTA_CM_PauseGameOrder,
        EDotaClientMessages::DOTA_CM_VersusScene_PlayerBehavior,
        EDotaClientMessages::DOTA_CM_PlayerBounty,
        EDotaClientMessages::DOTA_CM_PlayerBountyCancel,
        EDotaClientMessages::DOTA_CM_EmptyItemSlotAlert,
        EDotaClientMessages::DOTA_CM_AddOverwatchReportMarker,
        EDotaClientMessages::DOTA_CM_AghsStatusAlert,
        EDotaClientMessages::DOTA_CM_PerfReport,
        EDotaClientMessages::DOTA_CM_ContextualTips_Subscribe,
        EDotaClientMessages::DOTA_CM_ChatMessage,
        EDotaClientMessages::DOTA_CM_AddCommunicationsReportMarker,
        EDotaClientMessages::DOTA_CM_AddCommunicationsBlockMarker,
        EDotaClientMessages::DOTA_CM_NeutralCampAlert,
        EDotaClientMessages::DOTA_CM_DuelAccepted,
        EDotaClientMessages::DOTA_CM_ChooseNeutralItem,
        EDotaClientMessages::DOTA_CM_PlayerDraftPick,
        EDotaClientMessages::DOTA_CM_PlayerDraftSuggest,
        EDotaClientMessages::DOTA_CM_PlayerDraftPreferRole,
        EDotaClientMessages::DOTA_CM_PlayerDraftPreferTeam,
    ];
}

impl ::protobuf::EnumFull for EDotaClientMessages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDotaClientMessages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDotaClientMessages::DOTA_CM_MapLine => 0,
            EDotaClientMessages::DOTA_CM_AspectRatio => 1,
            EDotaClientMessages::DOTA_CM_MapPing => 2,
            EDotaClientMessages::DOTA_CM_UnitsAutoAttack => 3,
            EDotaClientMessages::DOTA_CM_SearchString => 4,
            EDotaClientMessages::DOTA_CM_Pause => 5,
            EDotaClientMessages::DOTA_CM_ShopViewMode => 6,
            EDotaClientMessages::DOTA_CM_SetUnitShareFlag => 7,
            EDotaClientMessages::DOTA_CM_SwapRequest => 8,
            EDotaClientMessages::DOTA_CM_SwapAccept => 9,
            EDotaClientMessages::DOTA_CM_WorldLine => 10,
            EDotaClientMessages::DOTA_CM_RequestGraphUpdate => 11,
            EDotaClientMessages::DOTA_CM_ItemAlert => 12,
            EDotaClientMessages::DOTA_CM_ChatWheel => 13,
            EDotaClientMessages::DOTA_CM_SendStatPopup => 14,
            EDotaClientMessages::DOTA_CM_BeginLastHitChallenge => 15,
            EDotaClientMessages::DOTA_CM_UpdateQuickBuy => 16,
            EDotaClientMessages::DOTA_CM_UpdateCoachListen => 17,
            EDotaClientMessages::DOTA_CM_CoachHUDPing => 18,
            EDotaClientMessages::DOTA_CM_RecordVote => 19,
            EDotaClientMessages::DOTA_CM_UnitsAutoAttackAfterSpell => 20,
            EDotaClientMessages::DOTA_CM_WillPurchaseAlert => 21,
            EDotaClientMessages::DOTA_CM_PlayerShowCase => 22,
            EDotaClientMessages::DOTA_CM_TeleportRequiresHalt => 23,
            EDotaClientMessages::DOTA_CM_CameraZoomAmount => 24,
            EDotaClientMessages::DOTA_CM_BroadcasterUsingCamerman => 25,
            EDotaClientMessages::DOTA_CM_BroadcasterUsingAssistedCameraOperator => 26,
            EDotaClientMessages::DOTA_CM_EnemyItemAlert => 27,
            EDotaClientMessages::DOTA_CM_FreeInventory => 28,
            EDotaClientMessages::DOTA_CM_BuyBackStateAlert => 29,
            EDotaClientMessages::DOTA_CM_QuickBuyAlert => 30,
            EDotaClientMessages::DOTA_CM_HeroStatueLike => 31,
            EDotaClientMessages::DOTA_CM_ModifierAlert => 32,
            EDotaClientMessages::DOTA_CM_TeamShowcaseEditor => 33,
            EDotaClientMessages::DOTA_CM_HPManaAlert => 34,
            EDotaClientMessages::DOTA_CM_GlyphAlert => 35,
            EDotaClientMessages::DOTA_CM_TeamShowcaseClientData => 36,
            EDotaClientMessages::DOTA_CM_PlayTeamShowcase => 37,
            EDotaClientMessages::DOTA_CM_EventCNY2015Cmd => 38,
            EDotaClientMessages::DOTA_CM_FillEmptySlotsWithBots => 39,
            EDotaClientMessages::DOTA_CM_DemoHero => 40,
            EDotaClientMessages::DOTA_CM_AbilityLearnModeToggled => 41,
            EDotaClientMessages::DOTA_CM_AbilityStartUse => 42,
            EDotaClientMessages::DOTA_CM_ChallengeSelect => 43,
            EDotaClientMessages::DOTA_CM_ChallengeReroll => 44,
            EDotaClientMessages::DOTA_CM_ClickedBuff => 45,
            EDotaClientMessages::DOTA_CM_CoinWager => 46,
            EDotaClientMessages::DOTA_CM_ExecuteOrders => 47,
            EDotaClientMessages::DOTA_CM_XPAlert => 48,
            EDotaClientMessages::DOTA_CM_EventPointsTip => 49,
            EDotaClientMessages::DOTA_CM_KillMyHero => 50,
            EDotaClientMessages::DOTA_CM_QuestStatus => 51,
            EDotaClientMessages::DOTA_CM_ToggleAutoattack => 52,
            EDotaClientMessages::DOTA_CM_SpecialAbility => 53,
            EDotaClientMessages::DOTA_CM_KillcamDamageTaken => 54,
            EDotaClientMessages::DOTA_CM_SetEnemyStartingPosition => 55,
            EDotaClientMessages::DOTA_CM_SetDesiredWardPlacement => 56,
            EDotaClientMessages::DOTA_CM_RollDice => 57,
            EDotaClientMessages::DOTA_CM_FlipCoin => 58,
            EDotaClientMessages::DOTA_CM_RequestItemSuggestions => 59,
            EDotaClientMessages::DOTA_CM_MakeTeamCaptain => 60,
            EDotaClientMessages::DOTA_CM_CoinWagerToken => 61,
            EDotaClientMessages::DOTA_CM_RankWager => 62,
            EDotaClientMessages::DOTA_CM_DismissAllStatPopups => 63,
            EDotaClientMessages::DOTA_CM_HelpTipSystemStateChanged => 64,
            EDotaClientMessages::DOTA_CM_ChannelRequiresHalt => 65,
            EDotaClientMessages::DOTA_CM_RequestBulkCombatLog => 66,
            EDotaClientMessages::DOTA_CM_AbilityDraftRequestAbility => 67,
            EDotaClientMessages::DOTA_CM_GuideSelectOption => 68,
            EDotaClientMessages::DOTA_CM_GuideSelected => 69,
            EDotaClientMessages::DOTA_CM_DamageReport => 70,
            EDotaClientMessages::DOTA_CM_SalutePlayer => 71,
            EDotaClientMessages::DOTA_CM_SprayWheel => 72,
            EDotaClientMessages::DOTA_CM_TipAlert => 73,
            EDotaClientMessages::DOTA_CM_EmptyTeleportAlert => 74,
            EDotaClientMessages::DOTA_CM_RadarAlert => 75,
            EDotaClientMessages::DOTA_CM_TalentTreeAlert => 76,
            EDotaClientMessages::DOTA_CM_SetCavernMapVariant => 77,
            EDotaClientMessages::DOTA_CM_PauseGameOrder => 78,
            EDotaClientMessages::DOTA_CM_VersusScene_PlayerBehavior => 79,
            EDotaClientMessages::DOTA_CM_PlayerBounty => 80,
            EDotaClientMessages::DOTA_CM_PlayerBountyCancel => 81,
            EDotaClientMessages::DOTA_CM_EmptyItemSlotAlert => 82,
            EDotaClientMessages::DOTA_CM_AddOverwatchReportMarker => 83,
            EDotaClientMessages::DOTA_CM_AghsStatusAlert => 84,
            EDotaClientMessages::DOTA_CM_PerfReport => 85,
            EDotaClientMessages::DOTA_CM_ContextualTips_Subscribe => 86,
            EDotaClientMessages::DOTA_CM_ChatMessage => 87,
            EDotaClientMessages::DOTA_CM_AddCommunicationsReportMarker => 88,
            EDotaClientMessages::DOTA_CM_AddCommunicationsBlockMarker => 89,
            EDotaClientMessages::DOTA_CM_NeutralCampAlert => 90,
            EDotaClientMessages::DOTA_CM_DuelAccepted => 91,
            EDotaClientMessages::DOTA_CM_ChooseNeutralItem => 92,
            EDotaClientMessages::DOTA_CM_PlayerDraftPick => 93,
            EDotaClientMessages::DOTA_CM_PlayerDraftSuggest => 94,
            EDotaClientMessages::DOTA_CM_PlayerDraftPreferRole => 95,
            EDotaClientMessages::DOTA_CM_PlayerDraftPreferTeam => 96,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDotaClientMessages {
    fn default() -> Self {
        EDotaClientMessages::DOTA_CM_MapLine
    }
}

impl EDotaClientMessages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDotaClientMessages>("EDotaClientMessages")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19dota_clientmessages.proto\x12\x04dota\x1a\x19dota_commonmessages.p\
    roto\x1a\x17dota_shared_enums.proto\"Z\n\x16CDOTAClientMsg_MapPing\x12@\
    \n\rlocation_ping\x18\x01\x20\x01(\x0b2\x1b.dota.CDOTAMsg_LocationPingR\
    \x0clocationPing\"S\n\x18CDOTAClientMsg_ItemAlert\x127\n\nitem_alert\x18\
    \x01\x20\x01(\x0b2\x18.dota.CDOTAMsg_ItemAlertR\titemAlert\"\xd6\x01\n\
    \x1dCDOTAClientMsg_EnemyItemAlert\x12#\n\ritem_entindex\x18\x01\x20\x01(\
    \x05R\x0citemEntindex\x12\x1b\n\trune_type\x18\x02\x20\x01(\x05R\x08rune\
    Type\x12\x1d\n\nitem_level\x18\x03\x20\x01(\x05R\titemLevel\x12'\n\x0fpr\
    imary_charges\x18\x04\x20\x01(\x05R\x0eprimaryCharges\x12+\n\x11secondar\
    y_charges\x18\x05\x20\x01(\x05R\x10secondaryCharges\"w\n\x1cCDOTAClientM\
    sg_ModifierAlert\x12.\n\x13buff_internal_index\x18\x01\x20\x01(\x05R\x11\
    buffInternalIndex\x12'\n\x0ftarget_entindex\x18\x02\x20\x01(\x05R\x0etar\
    getEntindex\"u\n\x1aCDOTAClientMsg_ClickedBuff\x12.\n\x13buff_internal_i\
    ndex\x18\x01\x20\x01(\x05R\x11buffInternalIndex\x12'\n\x0ftarget_entinde\
    x\x18\x02\x20\x01(\x05R\x0etargetEntindex\"m\n\x1aCDOTAClientMsg_HPManaA\
    lert\x12'\n\x0ftarget_entindex\x18\x01\x20\x01(\x05R\x0etargetEntindex\
    \x12&\n\x0fshow_raw_values\x18\x02\x20\x01(\x08R\rshowRawValues\"\x96\
    \x01\n\x1fCDOTAClientMsg_NeutralCampAlert\x12)\n\x10spawner_entindex\x18\
    \x01\x20\x01(\x05R\x0fspawnerEntindex\x12#\n\runit_entindex\x18\x02\x20\
    \x01(\x05R\x0cunitEntindex\x12#\n\rstack_request\x18\x03\x20\x01(\x08R\
    \x0cstackRequest\"7\n\x19CDOTAClientMsg_GlyphAlert\x12\x1a\n\x08negative\
    \x18\x01\x20\x01(\x08R\x08negative\"7\n\x19CDOTAClientMsg_RadarAlert\x12\
    \x1a\n\x08negative\x18\x01\x20\x01(\x08R\x08negative\"J\n\x16CDOTAClient\
    Msg_MapLine\x120\n\x07mapline\x18\x01\x20\x01(\x0b2\x16.dota.CDOTAMsg_Ma\
    pLineR\x07mapline\"2\n\x1aCDOTAClientMsg_AspectRatio\x12\x14\n\x05ratio\
    \x18\x01\x20\x01(\x02R\x05ratio\"\xab\x02\n\"CDOTAClientMsg_UnitsAutoAtt\
    ackMode\x12B\n\x04mode\x18\x01\x20\x01(\x0e2..dota.CDOTAClientMsg_UnitsA\
    utoAttackMode.EModeR\x04mode\x12O\n\tunit_type\x18\x02\x20\x01(\x0e22.do\
    ta.CDOTAClientMsg_UnitsAutoAttackMode.EUnitTypeR\x08unitType\"I\n\x05EMo\
    de\x12\x14\n\x07INVALID\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\
    \t\n\x05NEVER\x10\0\x12\x13\n\x0fAFTER_SPELLCAST\x10\x01\x12\n\n\x06ALWA\
    YS\x10\x02\"%\n\tEUnitType\x12\n\n\x06NORMAL\x10\0\x12\x0c\n\x08SUMMONED\
    \x10\x01\"D\n(CDOTAClientMsg_UnitsAutoAttackAfterSpell\x12\x18\n\x07enab\
    led\x18\x01\x20\x01(\x08R\x07enabled\"?\n#CDOTAClientMsg_TeleportRequire\
    sHalt\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\">\n\"CDOTAC\
    lientMsg_ChannelRequiresHalt\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\
    \x07enabled\"5\n\x1bCDOTAClientMsg_SearchString\x12\x16\n\x06search\x18\
    \x01\x20\x01(\tR\x06search\"\x16\n\x14CDOTAClientMsg_Pause\"1\n\x1bCDOTA\
    ClientMsg_ShopViewMode\x12\x12\n\x04mode\x18\x01\x20\x01(\rR\x04mode\"h\
    \n\x1fCDOTAClientMsg_SetUnitShareFlag\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\x05R\x08playerId\x12\x12\n\x04flag\x18\x02\x20\x01(\rR\x04flag\x12\
    \x14\n\x05state\x18\x03\x20\x01(\x08R\x05state\"9\n\x1aCDOTAClientMsg_Sw\
    apRequest\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\"8\n\
    \x19CDOTAClientMsg_SwapAccept\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\
    \x08playerId\"R\n\x18CDOTAClientMsg_WorldLine\x126\n\tworldline\x18\x01\
    \x20\x01(\x0b2\x18.dota.CDOTAMsg_WorldLineR\tworldline\"#\n!CDOTAClientM\
    sg_RequestGraphUpdate\"\x87\x01\n\x18CDOTAClientMsg_ChatWheel\x12&\n\x0f\
    chat_message_id\x18\x01\x20\x01(\rR\rchatMessageId\x12\"\n\rparam_hero_i\
    d\x18\x02\x20\x01(\rR\x0bparamHeroId\x12\x1f\n\x0bemoticon_id\x18\x03\
    \x20\x01(\rR\nemoticonId\"Z\n\x1cCDOTAClientMsg_SendStatPopup\x12:\n\tst\
    atpopup\x18\x01\x20\x01(\x0b2\x1c.dota.CDOTAMsg_SendStatPopupR\tstatpopu\
    p\"p\n#CDOTAClientMsg_DismissAllStatPopups\x12I\n\rdismissallmsg\x18\x01\
    \x20\x01(\x0b2#.dota.CDOTAMsg_DismissAllStatPopupsR\rdismissallmsg\"n\n$\
    CDOTAClientMsg_BeginLastHitChallenge\x12\x1f\n\x0bchosen_lane\x18\x01\
    \x20\x01(\rR\nchosenLane\x12%\n\x0ehelper_enabled\x18\x02\x20\x01(\x08R\
    \rhelperEnabled\"m\n!CDOTAClientMsg_UpdateQuickBuyItem\x12&\n\x0fitem_ab\
    ility_id\x18\x01\x20\x01(\x05R\ritemAbilityId\x12\x20\n\x0bpurchasable\
    \x18\x02\x20\x01(\x08R\x0bpurchasable\"^\n\x1dCDOTAClientMsg_UpdateQuick\
    Buy\x12=\n\x05items\x18\x01\x20\x03(\x0b2'.dota.CDOTAClientMsg_UpdateQui\
    ckBuyItemR\x05items\">\n\x19CDOTAClientMsg_RecordVote\x12!\n\x0cchoice_i\
    ndex\x18\x01\x20\x01(\x05R\x0bchoiceIndex\"\xa3\x01\n\x20CDOTAClientMsg_\
    WillPurchaseAlert\x12&\n\x0fitem_ability_id\x18\x01\x20\x01(\x05R\ritemA\
    bilityId\x12%\n\x0egold_remaining\x18\x02\x20\x01(\rR\rgoldRemaining\x12\
    0\n\x14suggestion_player_id\x18\x03\x20\x01(\x05R\x12suggestionPlayerId\
    \"\"\n\x20CDOTAClientMsg_BuyBackStateAlert\"\xba\x01\n\x1cCDOTAClientMsg\
    _QuickBuyAlert\x12&\n\x0fitem_ability_id\x18\x01\x20\x01(\x05R\ritemAbil\
    ityId\x12\x1b\n\tgold_cost\x18\x02\x20\x01(\x05R\x08goldCost\x122\n\x15i\
    tem_cooldown_seconds\x18\x03\x20\x01(\x05R\x13itemCooldownSeconds\x12!\n\
    \x0cshow_buyback\x18\x04\x20\x01(\x08R\x0bshowBuyback\";\n\x1dCDOTAClien\
    tMsg_PlayerShowCase\x12\x1a\n\x08showcase\x18\x01\x20\x01(\x08R\x08showc\
    ase\"B\n\x1fCDOTAClientMsg_CameraZoomAmount\x12\x1f\n\x0bzoom_amount\x18\
    \x01\x20\x01(\x02R\nzoomAmount\"H\n(CDOTAClientMsg_BroadcasterUsingCamer\
    aman\x12\x1c\n\tcameraman\x18\x01\x20\x01(\x08R\tcameraman\"Q\n5CDOTACli\
    entMsg_BroadcasterUsingAssistedCameraOperator\x12\x18\n\x07enabled\x18\
    \x01\x20\x01(\x08R\x07enabled\"K\n%CDOTAClientMsg_FillEmptySlotsWithBots\
    \x12\"\n\x0cfillwithbots\x18\x01\x20\x01(\x08R\x0cfillwithbots\"G\n\x1dC\
    DOTAClientMsg_HeroStatueLike\x12&\n\x0fowner_player_id\x18\x01\x20\x01(\
    \x05R\rownerPlayerId\"4\n\x1eCDOTAClientMsg_EventCNY2015Cmd\x12\x12\n\
    \x04data\x18\x01\x20\x01(\x0cR\x04data\"\xea\x01\n\x17CDOTAClientMsg_Dem\
    oHero\x12\x17\n\x07hero_id\x18\x01\x20\x01(\x05R\x06heroId\x12'\n\x10her\
    o_id_to_spawn\x18\x02\x20\x01(\x05R\rheroIdToSpawn\x12\x1b\n\titem_defs\
    \x18\x03\x20\x03(\rR\x08itemDefs\x12\x19\n\x08item_ids\x18\x04\x20\x03(\
    \x04R\x07itemIds\x12\x1f\n\x0bstyle_index\x18\x05\x20\x01(\rR\nstyleInde\
    x\x124\n\x16keep_existing_demohero\x18\x06\x20\x01(\x08R\x14keepExisting\
    Demohero\"u\n\x1eCDOTAClientMsg_ChallengeSelect\x12\x19\n\x08event_id\
    \x18\x01\x20\x01(\rR\x07eventId\x12\x17\n\x07slot_id\x18\x02\x20\x01(\rR\
    \x06slotId\x12\x1f\n\x0bsequence_id\x18\x03\x20\x01(\rR\nsequenceId\"\
    \x9c\x01\n\x1eCDOTAClientMsg_ChallengeReroll\x12'\n\x08event_id\x18\x01\
    \x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12\x17\n\x07slot_id\x18\x02\
    \x20\x01(\rR\x06slotId\x12\x1f\n\x0bsequence_id\x18\x03\x20\x01(\rR\nseq\
    uenceId\x12\x17\n\x07hero_id\x18\x04\x20\x01(\rR\x06heroId\"=\n\x18CDOTA\
    ClientMsg_CoinWager\x12!\n\x0cwager_amount\x18\x01\x20\x01(\rR\x0bwagerA\
    mount\"N\n\x1dCDOTAClientMsg_CoinWagerToken\x12-\n\x13wager_token_item_i\
    d\x18\x01\x20\x01(\x04R\x10wagerTokenItemId\"A\n\x18CDOTAClientMsg_RankW\
    ager\x12%\n\x0eannounce_wager\x18\x01\x20\x01(\x08R\rannounceWager\":\n\
    \x1bCDOTAClientMsg_PlayerBounty\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\
    \x05R\x08playerId\"O\n\x1dCDOTAClientMsg_EventPointsTip\x12.\n\x13recipi\
    ent_player_id\x18\x01\x20\x01(\x05R\x11recipientPlayerId\"P\n\x1cCDOTACl\
    ientMsg_ExecuteOrders\x120\n\x06orders\x18\x01\x20\x03(\x0b2\x18.dota.CD\
    OTAMsg_UnitOrderR\x06orders\"d\n\x16CDOTAClientMsg_XPAlert\x12'\n\x0ftar\
    get_entindex\x18\x01\x20\x01(\x05R\x0etargetEntindex\x12!\n\x0cdamage_ta\
    ken\x18\x02\x20\x01(\rR\x0bdamageTaken\"\x96\x01\n\x1eCDOTAClientMsg_Tal\
    entTreeAlert\x12'\n\x0ftarget_entindex\x18\x01\x20\x01(\x05R\x0etargetEn\
    tindex\x12\x1d\n\nability_id\x18\x02\x20\x01(\x05R\tabilityId\x12\x12\n\
    \x04slot\x18\x03\x20\x01(\x05R\x04slot\x12\x18\n\x07learned\x18\x04\x20\
    \x01(\x08R\x07learned\"\xf4\x01\n!CDOTAClientMsg_KillcamDamageTaken\x12'\
    \n\x0ftarget_entindex\x18\x01\x20\x01(\x05R\x0etargetEntindex\x12!\n\x0c\
    damage_taken\x18\x02\x20\x01(\rR\x0bdamageTaken\x12\x1b\n\titem_type\x18\
    \x03\x20\x01(\rR\x08itemType\x12&\n\x0fitem_ability_id\x18\x04\x20\x01(\
    \x05R\ritemAbilityId\x12\x1b\n\thero_name\x18\x05\x20\x01(\tR\x08heroNam\
    e\x12!\n\x0cdamage_color\x18\x06\x20\x01(\tR\x0bdamageColor\"\x1b\n\x19C\
    DOTAClientMsg_KillMyHero\"\xed\x01\n\x1aCDOTAClientMsg_QuestStatus\x12\
    \x19\n\x08quest_id\x18\x01\x20\x01(\rR\x07questId\x12!\n\x0cchallenge_id\
    \x18\x02\x20\x01(\rR\x0bchallengeId\x12\x1a\n\x08progress\x18\x03\x20\
    \x01(\rR\x08progress\x12\x12\n\x04goal\x18\x04\x20\x01(\rR\x04goal\x12\
    \x14\n\x05query\x18\x05\x20\x01(\rR\x05query\x12#\n\rfail_gametime\x18\
    \x06\x20\x01(\x02R\x0cfailGametime\x12&\n\x0fitem_ability_id\x18\x07\x20\
    \x01(\x05R\ritemAbilityId\"X\n\x1fCDOTAClientMsg_ToggleAutoattack\x12\
    \x12\n\x04mode\x18\x01\x20\x01(\x05R\x04mode\x12!\n\x0cshow_message\x18\
    \x02\x20\x01(\x08R\x0bshowMessage\"m\n\x1dCDOTAClientMsg_SpecialAbility\
    \x12#\n\rability_index\x18\x01\x20\x01(\rR\x0cabilityIndex\x12'\n\x0ftar\
    get_entindex\x18\x02\x20\x01(\x05R\x0etargetEntindex\"\x89\x01\n'CDOTACl\
    ientMsg_SetEnemyStartingPosition\x12&\n\x0fenemy_player_id\x18\x01\x20\
    \x01(\x05R\renemyPlayerId\x126\n\x17enemy_starting_position\x18\x02\x20\
    \x01(\rR\x15enemyStartingPosition\"u\n&CDOTAClientMsg_SetDesiredWardPlac\
    ement\x12\x1d\n\nward_index\x18\x01\x20\x01(\rR\twardIndex\x12\x15\n\x06\
    ward_x\x18\x02\x20\x01(\x02R\x05wardX\x12\x15\n\x06ward_y\x18\x03\x20\
    \x01(\x02R\x05wardY\"r\n\x17CDOTAClientMsg_RollDice\x12!\n\x0cchannel_ty\
    pe\x18\x01\x20\x01(\rR\x0bchannelType\x12\x19\n\x08roll_min\x18\x02\x20\
    \x01(\rR\x07rollMin\x12\x19\n\x08roll_max\x18\x03\x20\x01(\rR\x07rollMax\
    \"<\n\x17CDOTAClientMsg_FlipCoin\x12!\n\x0cchannel_type\x18\x01\x20\x01(\
    \rR\x0bchannelType\"'\n%CDOTAClientMsg_RequestItemSuggestions\"=\n\x1eCD\
    OTAClientMsg_MakeTeamCaptain\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\
    \x08playerId\"O\n(CDOTAClientMsg_HelpTipSystemStateChanged\x12#\n\rtip_d\
    isplayed\x18\x01\x20\x01(\x08R\x0ctipDisplayed\"\xab\x01\n#CDOTAClientMs\
    g_RequestBulkCombatLog\x12\x1b\n\tgame_time\x18\x01\x20\x01(\x02R\x08gam\
    eTime\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08duration\x12.\n\x13\
    recent_player_death\x18\x03\x20\x01(\x08R\x11recentPlayerDeath\x12\x1b\n\
    \tplayer_id\x18\x04\x20\x01(\x05R\x08playerId\"\x7f\n)CDOTAClientMsg_Abi\
    lityDraftRequestAbility\x120\n\x14requested_ability_id\x18\x01\x20\x01(\
    \x05R\x12requestedAbilityId\x12\x20\n\x0cctrl_is_down\x18\x02\x20\x01(\
    \x08R\nctrlIsDown\"g\n\x20CDOTAClientMsg_GuideSelectOption\x12\x16\n\x06\
    option\x18\x01\x20\x01(\rR\x06option\x12+\n\x11force_recalculate\x18\x02\
    \x20\x01(\x08R\x10forceRecalculate\"n\n\x1cCDOTAClientMsg_GuideSelected\
    \x12*\n\x11guide_workshop_id\x18\x01\x20\x01(\x04R\x0fguideWorkshopId\
    \x12\"\n\ris_plus_guide\x18\x02\x20\x01(\x08R\x0bisPlusGuide\"\xac\x01\n\
    \x1bCDOTAClientMsg_DamageReport\x12$\n\x0etarget_hero_id\x18\x01\x20\x01\
    (\rR\x0ctargetHeroId\x12$\n\x0esource_hero_id\x18\x02\x20\x01(\rR\x0csou\
    rceHeroId\x12#\n\rdamage_amount\x18\x03\x20\x01(\x05R\x0cdamageAmount\
    \x12\x1c\n\tbroadcast\x18\x04\x20\x01(\x08R\tbroadcast\"b\n\x1bCDOTAClie\
    ntMsg_SalutePlayer\x12(\n\x10target_player_id\x18\x01\x20\x01(\x05R\x0et\
    argetPlayerId\x12\x19\n\x08event_id\x18\x02\x20\x01(\x05R\x07eventId\"4\
    \n\x17CDOTAClientMsg_TipAlert\x12\x19\n\x08tip_text\x18\x01\x20\x01(\tR\
    \x07tipText\"L\n!CDOTAClientMsg_EmptyTeleportAlert\x12'\n\x0ftarget_enti\
    ndex\x18\x01\x20\x01(\x05R\x0etargetEntindex\"E\n\"CDOTAClientMsg_SetCav\
    ernMapVariant\x12\x1f\n\x0bmap_variant\x18\x01\x20\x01(\rR\nmapVariant\"\
    N\n\x1dCDOTAClientMsg_PauseGameOrder\x12\x19\n\x08order_id\x18\x01\x20\
    \x01(\x05R\x07orderId\x12\x12\n\x04data\x18\x02\x20\x01(\x05R\x04data\"\
    \xb3\x02\n)CDOTAClientMsg_VersusScene_PlayerBehavior\x12@\n\x08behavior\
    \x18\x01\x20\x01(\x0e2$.dota.EDOTAVersusScenePlayerBehaviorR\x08behavior\
    \x12C\n\rplay_activity\x18\x02\x20\x01(\x0b2\x1e.dota.VersusScene_PlayAc\
    tivityR\x0cplayActivity\x12:\n\nchat_wheel\x18\x03\x20\x01(\x0b2\x1b.dot\
    a.VersusScene_ChatWheelR\tchatWheel\x12C\n\rplayback_rate\x18\x04\x20\
    \x01(\x0b2\x1e.dota.VersusScene_PlaybackRateR\x0cplaybackRate\"k\n!CDOTA\
    ClientMsg_EmptyItemSlotAlert\x12'\n\x0ftarget_entindex\x18\x01\x20\x01(\
    \x05R\x0etargetEntindex\x12\x1d\n\nslot_index\x18\x02\x20\x01(\x05R\tslo\
    tIndex\"\xaa\x01\n'CDOTAClientMsg_AddOverwatchReportMarker\x12(\n\x10tar\
    get_player_id\x18\x01\x20\x01(\x05R\x0etargetPlayerId\x124\n\x06reason\
    \x18\x02\x20\x01(\x0e2\x1c.dota.EOverwatchReportReasonR\x06reason\x12\
    \x1f\n\x0bseconds_ago\x18\x04\x20\x01(\rR\nsecondsAgo\"X\n,CDOTAClientMs\
    g_AddCommunicationsReportMarker\x12(\n\x10target_player_id\x18\x01\x20\
    \x01(\x05R\x0etargetPlayerId\"W\n+CDOTAClientMsg_AddCommunicationsBlockM\
    arker\x12(\n\x10target_player_id\x18\x01\x20\x01(\x05R\x0etargetPlayerId\
    \"\xbc\x01\n\x1eCDOTAClientMsg_AghsStatusAlert\x12(\n\x10source_player_i\
    d\x18\x01\x20\x01(\x05R\x0esourcePlayerId\x12(\n\x10target_player_id\x18\
    \x02\x20\x01(\x05R\x0etargetPlayerId\x12'\n\x0ftarget_entindex\x18\x03\
    \x20\x01(\x05R\x0etargetEntindex\x12\x1d\n\nalert_type\x18\x04\x20\x01(\
    \rR\talertType\"\xc3\x08\n\x19CDOTAClientMsg_PerfReport\x12,\n\x12averag\
    e_frame_time\x18\x01\x20\x01(\x02R\x10averageFrameTime\x12$\n\x0emax_fra\
    me_time\x18\x02\x20\x01(\x02R\x0cmaxFrameTime\x120\n\x14average_compute_\
    time\x18\x03\x20\x01(\x02R\x12averageComputeTime\x12(\n\x10max_compute_t\
    ime\x18\x04\x20\x01(\x02R\x0emaxComputeTime\x127\n\x18average_client_tic\
    k_time\x18\x05\x20\x01(\x02R\x15averageClientTickTime\x12/\n\x14max_clie\
    nt_tick_time\x18\x06\x20\x01(\x02R\x11maxClientTickTime\x12?\n\x1caverag\
    e_client_simulate_time\x18\x07\x20\x01(\x02R\x19averageClientSimulateTim\
    e\x127\n\x18max_client_simulate_time\x18\x08\x20\x01(\x02R\x15maxClientS\
    imulateTime\x12.\n\x13average_output_time\x18\t\x20\x01(\x02R\x11average\
    OutputTime\x12&\n\x0fmax_output_time\x18\n\x20\x01(\x02R\rmaxOutputTime\
    \x12Z\n+average_wait_for_rendering_to_complete_time\x18\x0b\x20\x01(\x02\
    R%averageWaitForRenderingToCompleteTime\x12R\n'max_wait_for_rendering_to\
    _complete_time\x18\x0c\x20\x01(\x02R!maxWaitForRenderingToCompleteTime\
    \x12*\n\x11average_swap_time\x18\r\x20\x01(\x02R\x0faverageSwapTime\x12\
    \"\n\rmax_swap_time\x18\x0e\x20\x01(\x02R\x0bmaxSwapTime\x129\n\x19avera\
    ge_frame_update_time\x18\x0f\x20\x01(\x02R\x16averageFrameUpdateTime\x12\
    1\n\x15max_frame_update_time\x18\x10\x20\x01(\x02R\x12maxFrameUpdateTime\
    \x12*\n\x11average_idle_time\x18\x11\x20\x01(\x02R\x0faverageIdleTime\
    \x12\"\n\rmax_idle_time\x18\x12\x20\x01(\x02R\x0bmaxIdleTime\x12A\n\x1da\
    verage_input_processing_time\x18\x13\x20\x01(\x02R\x1aaverageInputProces\
    singTime\x129\n\x19max_input_processing_time\x18\x14\x20\x01(\x02R\x16ma\
    xInputProcessingTime\"\xbd\x01\n-CDOTAClientMsg_ContextualTips_Subscribe\
    _Entry\x12\x20\n\x0bunsubscribe\x18\x01\x20\x01(\x08R\x0bunsubscribe\x12\
    \x15\n\x06tip_id\x18\x02\x20\x01(\x05R\x05tipId\x12.\n\x13prior_display_\
    count\x18\x03\x20\x01(\x05R\x11priorDisplayCount\x12#\n\rvariants_seen\
    \x18\x04\x20\x03(\x05R\x0cvariantsSeen\"r\n'CDOTAClientMsg_ContextualTip\
    s_Subscribe\x12G\n\x04tips\x18\x01\x20\x03(\x0b23.dota.CDOTAClientMsg_Co\
    ntextualTips_Subscribe_EntryR\x04tips\"b\n\x1aCDOTAClientMsg_ChatMessage\
    \x12!\n\x0cchannel_type\x18\x01\x20\x01(\rR\x0bchannelType\x12!\n\x0cmes\
    sage_text\x18\x02\x20\x01(\tR\x0bmessageText\"}\n\x1bCDOTAClientMsg_Duel\
    Accepted\x120\n\x14challenger_player_id\x18\x01\x20\x01(\x05R\x12challen\
    gerPlayerId\x12,\n\x12accepter_player_id\x18\x02\x20\x01(\x05R\x10accept\
    erPlayerId\"\x98\x01\n\x20CDOTAClientMsg_ChooseNeutralItem\x12,\n\x12neu\
    tral_item_index\x18\x01\x20\x01(\x05R\x10neutralItemIndex\x12'\n\x0ftarg\
    et_entindex\x18\x02\x20\x01(\x05R\x0etargetEntindex\x12\x1d\n\nslot_inde\
    x\x18\x03\x20\x01(\x05R\tslotIndex\"=\n\x1eCDOTAClientMsg_PlayerDraftPic\
    k\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\"@\n!CDOTAClien\
    tMsg_PlayerDraftSuggest\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08pl\
    ayerId\"[\n$CDOTAClientMsg_PlayerDraftPreferRole\x12\x19\n\x08role_idx\
    \x18\x01\x20\x01(\x05R\x07roleIdx\x12\x18\n\x07desired\x18\x02\x20\x01(\
    \x08R\x07desired\":\n$CDOTAClientMsg_PlayerDraftPreferTeam\x12\x12\n\x04\
    team\x18\x01\x20\x01(\x05R\x04team*\xa5\x17\n\x13EDotaClientMessages\x12\
    \x14\n\x0fDOTA_CM_MapLine\x10\xad\x02\x12\x18\n\x13DOTA_CM_AspectRatio\
    \x10\xae\x02\x12\x14\n\x0fDOTA_CM_MapPing\x10\xaf\x02\x12\x1c\n\x17DOTA_\
    CM_UnitsAutoAttack\x10\xb0\x02\x12\x19\n\x14DOTA_CM_SearchString\x10\xb3\
    \x02\x12\x12\n\rDOTA_CM_Pause\x10\xb4\x02\x12\x19\n\x14DOTA_CM_ShopViewM\
    ode\x10\xb5\x02\x12\x1d\n\x18DOTA_CM_SetUnitShareFlag\x10\xb6\x02\x12\
    \x18\n\x13DOTA_CM_SwapRequest\x10\xb7\x02\x12\x17\n\x12DOTA_CM_SwapAccep\
    t\x10\xb8\x02\x12\x16\n\x11DOTA_CM_WorldLine\x10\xb9\x02\x12\x1f\n\x1aDO\
    TA_CM_RequestGraphUpdate\x10\xba\x02\x12\x16\n\x11DOTA_CM_ItemAlert\x10\
    \xbb\x02\x12\x16\n\x11DOTA_CM_ChatWheel\x10\xbc\x02\x12\x1a\n\x15DOTA_CM\
    _SendStatPopup\x10\xbd\x02\x12\"\n\x1dDOTA_CM_BeginLastHitChallenge\x10\
    \xbe\x02\x12\x1b\n\x16DOTA_CM_UpdateQuickBuy\x10\xbf\x02\x12\x1e\n\x19DO\
    TA_CM_UpdateCoachListen\x10\xc0\x02\x12\x19\n\x14DOTA_CM_CoachHUDPing\
    \x10\xc1\x02\x12\x17\n\x12DOTA_CM_RecordVote\x10\xc2\x02\x12&\n!DOTA_CM_\
    UnitsAutoAttackAfterSpell\x10\xc3\x02\x12\x1e\n\x19DOTA_CM_WillPurchaseA\
    lert\x10\xc4\x02\x12\x1b\n\x16DOTA_CM_PlayerShowCase\x10\xc5\x02\x12!\n\
    \x1cDOTA_CM_TeleportRequiresHalt\x10\xc6\x02\x12\x1d\n\x18DOTA_CM_Camera\
    ZoomAmount\x10\xc7\x02\x12%\n\x20DOTA_CM_BroadcasterUsingCamerman\x10\
    \xc8\x02\x123\n.DOTA_CM_BroadcasterUsingAssistedCameraOperator\x10\xc9\
    \x02\x12\x1b\n\x16DOTA_CM_EnemyItemAlert\x10\xca\x02\x12\x1a\n\x15DOTA_C\
    M_FreeInventory\x10\xcb\x02\x12\x1e\n\x19DOTA_CM_BuyBackStateAlert\x10\
    \xcc\x02\x12\x1a\n\x15DOTA_CM_QuickBuyAlert\x10\xcd\x02\x12\x1b\n\x16DOT\
    A_CM_HeroStatueLike\x10\xce\x02\x12\x1a\n\x15DOTA_CM_ModifierAlert\x10\
    \xcf\x02\x12\x1f\n\x1aDOTA_CM_TeamShowcaseEditor\x10\xd0\x02\x12\x18\n\
    \x13DOTA_CM_HPManaAlert\x10\xd1\x02\x12\x17\n\x12DOTA_CM_GlyphAlert\x10\
    \xd2\x02\x12#\n\x1eDOTA_CM_TeamShowcaseClientData\x10\xd3\x02\x12\x1d\n\
    \x18DOTA_CM_PlayTeamShowcase\x10\xd4\x02\x12\x1c\n\x17DOTA_CM_EventCNY20\
    15Cmd\x10\xd5\x02\x12#\n\x1eDOTA_CM_FillEmptySlotsWithBots\x10\xd6\x02\
    \x12\x15\n\x10DOTA_CM_DemoHero\x10\xd7\x02\x12$\n\x1fDOTA_CM_AbilityLear\
    nModeToggled\x10\xd8\x02\x12\x1c\n\x17DOTA_CM_AbilityStartUse\x10\xd9\
    \x02\x12\x1c\n\x17DOTA_CM_ChallengeSelect\x10\xda\x02\x12\x1c\n\x17DOTA_\
    CM_ChallengeReroll\x10\xdb\x02\x12\x18\n\x13DOTA_CM_ClickedBuff\x10\xdc\
    \x02\x12\x16\n\x11DOTA_CM_CoinWager\x10\xdd\x02\x12\x1a\n\x15DOTA_CM_Exe\
    cuteOrders\x10\xde\x02\x12\x14\n\x0fDOTA_CM_XPAlert\x10\xdf\x02\x12\x1b\
    \n\x16DOTA_CM_EventPointsTip\x10\xe1\x02\x12\x17\n\x12DOTA_CM_KillMyHero\
    \x10\xe3\x02\x12\x18\n\x13DOTA_CM_QuestStatus\x10\xe4\x02\x12\x1d\n\x18D\
    OTA_CM_ToggleAutoattack\x10\xe5\x02\x12\x1b\n\x16DOTA_CM_SpecialAbility\
    \x10\xe6\x02\x12\x1f\n\x1aDOTA_CM_KillcamDamageTaken\x10\xe7\x02\x12%\n\
    \x20DOTA_CM_SetEnemyStartingPosition\x10\xe8\x02\x12$\n\x1fDOTA_CM_SetDe\
    siredWardPlacement\x10\xe9\x02\x12\x15\n\x10DOTA_CM_RollDice\x10\xea\x02\
    \x12\x15\n\x10DOTA_CM_FlipCoin\x10\xeb\x02\x12#\n\x1eDOTA_CM_RequestItem\
    Suggestions\x10\xec\x02\x12\x1c\n\x17DOTA_CM_MakeTeamCaptain\x10\xed\x02\
    \x12\x1b\n\x16DOTA_CM_CoinWagerToken\x10\xee\x02\x12\x16\n\x11DOTA_CM_Ra\
    nkWager\x10\xef\x02\x12!\n\x1cDOTA_CM_DismissAllStatPopups\x10\xf0\x02\
    \x12&\n!DOTA_CM_HelpTipSystemStateChanged\x10\xf1\x02\x12\x20\n\x1bDOTA_\
    CM_ChannelRequiresHalt\x10\xf2\x02\x12!\n\x1cDOTA_CM_RequestBulkCombatLo\
    g\x10\xf3\x02\x12'\n\"DOTA_CM_AbilityDraftRequestAbility\x10\xf4\x02\x12\
    \x1e\n\x19DOTA_CM_GuideSelectOption\x10\xf5\x02\x12\x1a\n\x15DOTA_CM_Gui\
    deSelected\x10\xf6\x02\x12\x19\n\x14DOTA_CM_DamageReport\x10\xf7\x02\x12\
    \x19\n\x14DOTA_CM_SalutePlayer\x10\xf8\x02\x12\x17\n\x12DOTA_CM_SprayWhe\
    el\x10\xf9\x02\x12\x15\n\x10DOTA_CM_TipAlert\x10\xfa\x02\x12\x1f\n\x1aDO\
    TA_CM_EmptyTeleportAlert\x10\xfb\x02\x12\x17\n\x12DOTA_CM_RadarAlert\x10\
    \xfc\x02\x12\x1c\n\x17DOTA_CM_TalentTreeAlert\x10\xfd\x02\x12\x20\n\x1bD\
    OTA_CM_SetCavernMapVariant\x10\xfe\x02\x12\x1b\n\x16DOTA_CM_PauseGameOrd\
    er\x10\xff\x02\x12'\n\"DOTA_CM_VersusScene_PlayerBehavior\x10\x80\x03\
    \x12\x19\n\x14DOTA_CM_PlayerBounty\x10\x81\x03\x12\x1f\n\x1aDOTA_CM_Play\
    erBountyCancel\x10\x82\x03\x12\x1f\n\x1aDOTA_CM_EmptyItemSlotAlert\x10\
    \x84\x03\x12%\n\x20DOTA_CM_AddOverwatchReportMarker\x10\x85\x03\x12\x1c\
    \n\x17DOTA_CM_AghsStatusAlert\x10\x86\x03\x12\x17\n\x12DOTA_CM_PerfRepor\
    t\x10\x87\x03\x12%\n\x20DOTA_CM_ContextualTips_Subscribe\x10\x89\x03\x12\
    \x18\n\x13DOTA_CM_ChatMessage\x10\x8a\x03\x12*\n%DOTA_CM_AddCommunicatio\
    nsReportMarker\x10\x8b\x03\x12)\n$DOTA_CM_AddCommunicationsBlockMarker\
    \x10\x8c\x03\x12\x1d\n\x18DOTA_CM_NeutralCampAlert\x10\x8d\x03\x12\x19\n\
    \x14DOTA_CM_DuelAccepted\x10\x8e\x03\x12\x1e\n\x19DOTA_CM_ChooseNeutralI\
    tem\x10\x8f\x03\x12\x1c\n\x17DOTA_CM_PlayerDraftPick\x10\xa0\x06\x12\x1f\
    \n\x1aDOTA_CM_PlayerDraftSuggest\x10\xa1\x06\x12\"\n\x1dDOTA_CM_PlayerDr\
    aftPreferRole\x10\xa2\x06\x12\"\n\x1dDOTA_CM_PlayerDraftPreferTeam\x10\
    \xa3\x06B%Z#github.com/dotabuff/manta/dota;dotaJ\xad\x9f\x01\n\x07\x12\
    \x05\0\0\xb9\x04\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\
    \x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\
    \x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\"\n\t\n\x02\x03\x01\x12\x03\
    \x06\x07\x20\n\n\n\x02\x05\0\x12\x04\x08\0j\x01\n\n\n\x03\x05\0\x01\x12\
    \x03\x08\x05\x18\n\x0b\n\x04\x05\0\x02\0\x12\x03\t\x08\x1e\n\x0c\n\x05\
    \x05\0\x02\0\x01\x12\x03\t\x08\x17\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t\
    \x1a\x1d\n\x0b\n\x04\x05\0\x02\x01\x12\x03\n\x08\"\n\x0c\n\x05\x05\0\x02\
    \x01\x01\x12\x03\n\x08\x1b\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\n\x1e!\
    \n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0b\x08\x1e\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03\x0b\x08\x17\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0b\x1a\
    \x1d\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x0c\x08&\n\x0c\n\x05\x05\0\x02\
    \x03\x01\x12\x03\x0c\x08\x1f\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x0c\"\
    %\n\x0b\n\x04\x05\0\x02\x04\x12\x03\r\x08#\n\x0c\n\x05\x05\0\x02\x04\x01\
    \x12\x03\r\x08\x1c\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\r\x1f\"\n\x0b\n\
    \x04\x05\0\x02\x05\x12\x03\x0e\x08\x1c\n\x0c\n\x05\x05\0\x02\x05\x01\x12\
    \x03\x0e\x08\x15\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0e\x18\x1b\n\x0b\
    \n\x04\x05\0\x02\x06\x12\x03\x0f\x08#\n\x0c\n\x05\x05\0\x02\x06\x01\x12\
    \x03\x0f\x08\x1c\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0f\x1f\"\n\x0b\n\
    \x04\x05\0\x02\x07\x12\x03\x10\x08'\n\x0c\n\x05\x05\0\x02\x07\x01\x12\
    \x03\x10\x08\x20\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x10#&\n\x0b\n\x04\
    \x05\0\x02\x08\x12\x03\x11\x08\"\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\
    \x11\x08\x1b\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x11\x1e!\n\x0b\n\x04\
    \x05\0\x02\t\x12\x03\x12\x08!\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x12\
    \x08\x1a\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x12\x1d\x20\n\x0b\n\x04\x05\
    \0\x02\n\x12\x03\x13\x08\x20\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x13\x08\
    \x19\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x13\x1c\x1f\n\x0b\n\x04\x05\0\
    \x02\x0b\x12\x03\x14\x08)\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x14\x08\
    \"\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x14%(\n\x0b\n\x04\x05\0\x02\x0c\
    \x12\x03\x15\x08\x20\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x15\x08\x19\n\
    \x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x15\x1c\x1f\n\x0b\n\x04\x05\0\x02\r\
    \x12\x03\x16\x08\x20\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x16\x08\x19\n\
    \x0c\n\x05\x05\0\x02\r\x02\x12\x03\x16\x1c\x1f\n\x0b\n\x04\x05\0\x02\x0e\
    \x12\x03\x17\x08$\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x17\x08\x1d\n\
    \x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x17\x20#\n\x0b\n\x04\x05\0\x02\x0f\
    \x12\x03\x18\x08,\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x18\x08%\n\x0c\n\
    \x05\x05\0\x02\x0f\x02\x12\x03\x18(+\n\x0b\n\x04\x05\0\x02\x10\x12\x03\
    \x19\x08%\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x19\x08\x1e\n\x0c\n\x05\
    \x05\0\x02\x10\x02\x12\x03\x19!$\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x1a\
    \x08(\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x1a\x08!\n\x0c\n\x05\x05\0\
    \x02\x11\x02\x12\x03\x1a$'\n\x0b\n\x04\x05\0\x02\x12\x12\x03\x1b\x08#\n\
    \x0c\n\x05\x05\0\x02\x12\x01\x12\x03\x1b\x08\x1c\n\x0c\n\x05\x05\0\x02\
    \x12\x02\x12\x03\x1b\x1f\"\n\x0b\n\x04\x05\0\x02\x13\x12\x03\x1c\x08!\n\
    \x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x1c\x08\x1a\n\x0c\n\x05\x05\0\x02\
    \x13\x02\x12\x03\x1c\x1d\x20\n\x0b\n\x04\x05\0\x02\x14\x12\x03\x1d\x080\
    \n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1d\x08)\n\x0c\n\x05\x05\0\x02\
    \x14\x02\x12\x03\x1d,/\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1e\x08(\n\x0c\
    \n\x05\x05\0\x02\x15\x01\x12\x03\x1e\x08!\n\x0c\n\x05\x05\0\x02\x15\x02\
    \x12\x03\x1e$'\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x1f\x08%\n\x0c\n\x05\
    \x05\0\x02\x16\x01\x12\x03\x1f\x08\x1e\n\x0c\n\x05\x05\0\x02\x16\x02\x12\
    \x03\x1f!$\n\x0b\n\x04\x05\0\x02\x17\x12\x03\x20\x08+\n\x0c\n\x05\x05\0\
    \x02\x17\x01\x12\x03\x20\x08$\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03\x20'\
    *\n\x0b\n\x04\x05\0\x02\x18\x12\x03!\x08'\n\x0c\n\x05\x05\0\x02\x18\x01\
    \x12\x03!\x08\x20\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03!#&\n\x0b\n\x04\
    \x05\0\x02\x19\x12\x03\"\x08/\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03\"\
    \x08(\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03\"+.\n\x0b\n\x04\x05\0\x02\
    \x1a\x12\x03#\x08=\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03#\x086\n\x0c\n\
    \x05\x05\0\x02\x1a\x02\x12\x03#9<\n\x0b\n\x04\x05\0\x02\x1b\x12\x03$\x08\
    %\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03$\x08\x1e\n\x0c\n\x05\x05\0\x02\
    \x1b\x02\x12\x03$!$\n\x0b\n\x04\x05\0\x02\x1c\x12\x03%\x08$\n\x0c\n\x05\
    \x05\0\x02\x1c\x01\x12\x03%\x08\x1d\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\
    \x03%\x20#\n\x0b\n\x04\x05\0\x02\x1d\x12\x03&\x08(\n\x0c\n\x05\x05\0\x02\
    \x1d\x01\x12\x03&\x08!\n\x0c\n\x05\x05\0\x02\x1d\x02\x12\x03&$'\n\x0b\n\
    \x04\x05\0\x02\x1e\x12\x03'\x08$\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x03'\
    \x08\x1d\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\x03'\x20#\n\x0b\n\x04\x05\0\
    \x02\x1f\x12\x03(\x08%\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\x03(\x08\x1e\n\
    \x0c\n\x05\x05\0\x02\x1f\x02\x12\x03(!$\n\x0b\n\x04\x05\0\x02\x20\x12\
    \x03)\x08$\n\x0c\n\x05\x05\0\x02\x20\x01\x12\x03)\x08\x1d\n\x0c\n\x05\
    \x05\0\x02\x20\x02\x12\x03)\x20#\n\x0b\n\x04\x05\0\x02!\x12\x03*\x08)\n\
    \x0c\n\x05\x05\0\x02!\x01\x12\x03*\x08\"\n\x0c\n\x05\x05\0\x02!\x02\x12\
    \x03*%(\n\x0b\n\x04\x05\0\x02\"\x12\x03+\x08\"\n\x0c\n\x05\x05\0\x02\"\
    \x01\x12\x03+\x08\x1b\n\x0c\n\x05\x05\0\x02\"\x02\x12\x03+\x1e!\n\x0b\n\
    \x04\x05\0\x02#\x12\x03,\x08!\n\x0c\n\x05\x05\0\x02#\x01\x12\x03,\x08\
    \x1a\n\x0c\n\x05\x05\0\x02#\x02\x12\x03,\x1d\x20\n\x0b\n\x04\x05\0\x02$\
    \x12\x03-\x08-\n\x0c\n\x05\x05\0\x02$\x01\x12\x03-\x08&\n\x0c\n\x05\x05\
    \0\x02$\x02\x12\x03-),\n\x0b\n\x04\x05\0\x02%\x12\x03.\x08'\n\x0c\n\x05\
    \x05\0\x02%\x01\x12\x03.\x08\x20\n\x0c\n\x05\x05\0\x02%\x02\x12\x03.#&\n\
    \x0b\n\x04\x05\0\x02&\x12\x03/\x08&\n\x0c\n\x05\x05\0\x02&\x01\x12\x03/\
    \x08\x1f\n\x0c\n\x05\x05\0\x02&\x02\x12\x03/\"%\n\x0b\n\x04\x05\0\x02'\
    \x12\x030\x08-\n\x0c\n\x05\x05\0\x02'\x01\x12\x030\x08&\n\x0c\n\x05\x05\
    \0\x02'\x02\x12\x030),\n\x0b\n\x04\x05\0\x02(\x12\x031\x08\x1f\n\x0c\n\
    \x05\x05\0\x02(\x01\x12\x031\x08\x18\n\x0c\n\x05\x05\0\x02(\x02\x12\x031\
    \x1b\x1e\n\x0b\n\x04\x05\0\x02)\x12\x032\x08.\n\x0c\n\x05\x05\0\x02)\x01\
    \x12\x032\x08'\n\x0c\n\x05\x05\0\x02)\x02\x12\x032*-\n\x0b\n\x04\x05\0\
    \x02*\x12\x033\x08&\n\x0c\n\x05\x05\0\x02*\x01\x12\x033\x08\x1f\n\x0c\n\
    \x05\x05\0\x02*\x02\x12\x033\"%\n\x0b\n\x04\x05\0\x02+\x12\x034\x08&\n\
    \x0c\n\x05\x05\0\x02+\x01\x12\x034\x08\x1f\n\x0c\n\x05\x05\0\x02+\x02\
    \x12\x034\"%\n\x0b\n\x04\x05\0\x02,\x12\x035\x08&\n\x0c\n\x05\x05\0\x02,\
    \x01\x12\x035\x08\x1f\n\x0c\n\x05\x05\0\x02,\x02\x12\x035\"%\n\x0b\n\x04\
    \x05\0\x02-\x12\x036\x08\"\n\x0c\n\x05\x05\0\x02-\x01\x12\x036\x08\x1b\n\
    \x0c\n\x05\x05\0\x02-\x02\x12\x036\x1e!\n\x0b\n\x04\x05\0\x02.\x12\x037\
    \x08\x20\n\x0c\n\x05\x05\0\x02.\x01\x12\x037\x08\x19\n\x0c\n\x05\x05\0\
    \x02.\x02\x12\x037\x1c\x1f\n\x0b\n\x04\x05\0\x02/\x12\x038\x08$\n\x0c\n\
    \x05\x05\0\x02/\x01\x12\x038\x08\x1d\n\x0c\n\x05\x05\0\x02/\x02\x12\x038\
    \x20#\n\x0b\n\x04\x05\0\x020\x12\x039\x08\x1e\n\x0c\n\x05\x05\0\x020\x01\
    \x12\x039\x08\x17\n\x0c\n\x05\x05\0\x020\x02\x12\x039\x1a\x1d\n\x0b\n\
    \x04\x05\0\x021\x12\x03:\x08%\n\x0c\n\x05\x05\0\x021\x01\x12\x03:\x08\
    \x1e\n\x0c\n\x05\x05\0\x021\x02\x12\x03:!$\n\x0b\n\x04\x05\0\x022\x12\
    \x03;\x08!\n\x0c\n\x05\x05\0\x022\x01\x12\x03;\x08\x1a\n\x0c\n\x05\x05\0\
    \x022\x02\x12\x03;\x1d\x20\n\x0b\n\x04\x05\0\x023\x12\x03<\x08\"\n\x0c\n\
    \x05\x05\0\x023\x01\x12\x03<\x08\x1b\n\x0c\n\x05\x05\0\x023\x02\x12\x03<\
    \x1e!\n\x0b\n\x04\x05\0\x024\x12\x03=\x08'\n\x0c\n\x05\x05\0\x024\x01\
    \x12\x03=\x08\x20\n\x0c\n\x05\x05\0\x024\x02\x12\x03=#&\n\x0b\n\x04\x05\
    \0\x025\x12\x03>\x08%\n\x0c\n\x05\x05\0\x025\x01\x12\x03>\x08\x1e\n\x0c\
    \n\x05\x05\0\x025\x02\x12\x03>!$\n\x0b\n\x04\x05\0\x026\x12\x03?\x08)\n\
    \x0c\n\x05\x05\0\x026\x01\x12\x03?\x08\"\n\x0c\n\x05\x05\0\x026\x02\x12\
    \x03?%(\n\x0b\n\x04\x05\0\x027\x12\x03@\x08/\n\x0c\n\x05\x05\0\x027\x01\
    \x12\x03@\x08(\n\x0c\n\x05\x05\0\x027\x02\x12\x03@+.\n\x0b\n\x04\x05\0\
    \x028\x12\x03A\x08.\n\x0c\n\x05\x05\0\x028\x01\x12\x03A\x08'\n\x0c\n\x05\
    \x05\0\x028\x02\x12\x03A*-\n\x0b\n\x04\x05\0\x029\x12\x03B\x08\x1f\n\x0c\
    \n\x05\x05\0\x029\x01\x12\x03B\x08\x18\n\x0c\n\x05\x05\0\x029\x02\x12\
    \x03B\x1b\x1e\n\x0b\n\x04\x05\0\x02:\x12\x03C\x08\x1f\n\x0c\n\x05\x05\0\
    \x02:\x01\x12\x03C\x08\x18\n\x0c\n\x05\x05\0\x02:\x02\x12\x03C\x1b\x1e\n\
    \x0b\n\x04\x05\0\x02;\x12\x03D\x08-\n\x0c\n\x05\x05\0\x02;\x01\x12\x03D\
    \x08&\n\x0c\n\x05\x05\0\x02;\x02\x12\x03D),\n\x0b\n\x04\x05\0\x02<\x12\
    \x03E\x08&\n\x0c\n\x05\x05\0\x02<\x01\x12\x03E\x08\x1f\n\x0c\n\x05\x05\0\
    \x02<\x02\x12\x03E\"%\n\x0b\n\x04\x05\0\x02=\x12\x03F\x08%\n\x0c\n\x05\
    \x05\0\x02=\x01\x12\x03F\x08\x1e\n\x0c\n\x05\x05\0\x02=\x02\x12\x03F!$\n\
    \x0b\n\x04\x05\0\x02>\x12\x03G\x08\x20\n\x0c\n\x05\x05\0\x02>\x01\x12\
    \x03G\x08\x19\n\x0c\n\x05\x05\0\x02>\x02\x12\x03G\x1c\x1f\n\x0b\n\x04\
    \x05\0\x02?\x12\x03H\x08+\n\x0c\n\x05\x05\0\x02?\x01\x12\x03H\x08$\n\x0c\
    \n\x05\x05\0\x02?\x02\x12\x03H'*\n\x0b\n\x04\x05\0\x02@\x12\x03I\x080\n\
    \x0c\n\x05\x05\0\x02@\x01\x12\x03I\x08)\n\x0c\n\x05\x05\0\x02@\x02\x12\
    \x03I,/\n\x0b\n\x04\x05\0\x02A\x12\x03J\x08*\n\x0c\n\x05\x05\0\x02A\x01\
    \x12\x03J\x08#\n\x0c\n\x05\x05\0\x02A\x02\x12\x03J&)\n\x0b\n\x04\x05\0\
    \x02B\x12\x03K\x08+\n\x0c\n\x05\x05\0\x02B\x01\x12\x03K\x08$\n\x0c\n\x05\
    \x05\0\x02B\x02\x12\x03K'*\n\x0b\n\x04\x05\0\x02C\x12\x03L\x081\n\x0c\n\
    \x05\x05\0\x02C\x01\x12\x03L\x08*\n\x0c\n\x05\x05\0\x02C\x02\x12\x03L-0\
    \n\x0b\n\x04\x05\0\x02D\x12\x03M\x08(\n\x0c\n\x05\x05\0\x02D\x01\x12\x03\
    M\x08!\n\x0c\n\x05\x05\0\x02D\x02\x12\x03M$'\n\x0b\n\x04\x05\0\x02E\x12\
    \x03N\x08$\n\x0c\n\x05\x05\0\x02E\x01\x12\x03N\x08\x1d\n\x0c\n\x05\x05\0\
    \x02E\x02\x12\x03N\x20#\n\x0b\n\x04\x05\0\x02F\x12\x03O\x08#\n\x0c\n\x05\
    \x05\0\x02F\x01\x12\x03O\x08\x1c\n\x0c\n\x05\x05\0\x02F\x02\x12\x03O\x1f\
    \"\n\x0b\n\x04\x05\0\x02G\x12\x03P\x08#\n\x0c\n\x05\x05\0\x02G\x01\x12\
    \x03P\x08\x1c\n\x0c\n\x05\x05\0\x02G\x02\x12\x03P\x1f\"\n\x0b\n\x04\x05\
    \0\x02H\x12\x03Q\x08!\n\x0c\n\x05\x05\0\x02H\x01\x12\x03Q\x08\x1a\n\x0c\
    \n\x05\x05\0\x02H\x02\x12\x03Q\x1d\x20\n\x0b\n\x04\x05\0\x02I\x12\x03R\
    \x08\x1f\n\x0c\n\x05\x05\0\x02I\x01\x12\x03R\x08\x18\n\x0c\n\x05\x05\0\
    \x02I\x02\x12\x03R\x1b\x1e\n\x0b\n\x04\x05\0\x02J\x12\x03S\x08)\n\x0c\n\
    \x05\x05\0\x02J\x01\x12\x03S\x08\"\n\x0c\n\x05\x05\0\x02J\x02\x12\x03S%(\
    \n\x0b\n\x04\x05\0\x02K\x12\x03T\x08!\n\x0c\n\x05\x05\0\x02K\x01\x12\x03\
    T\x08\x1a\n\x0c\n\x05\x05\0\x02K\x02\x12\x03T\x1d\x20\n\x0b\n\x04\x05\0\
    \x02L\x12\x03U\x08&\n\x0c\n\x05\x05\0\x02L\x01\x12\x03U\x08\x1f\n\x0c\n\
    \x05\x05\0\x02L\x02\x12\x03U\"%\n\x0b\n\x04\x05\0\x02M\x12\x03V\x08*\n\
    \x0c\n\x05\x05\0\x02M\x01\x12\x03V\x08#\n\x0c\n\x05\x05\0\x02M\x02\x12\
    \x03V&)\n\x0b\n\x04\x05\0\x02N\x12\x03W\x08%\n\x0c\n\x05\x05\0\x02N\x01\
    \x12\x03W\x08\x1e\n\x0c\n\x05\x05\0\x02N\x02\x12\x03W!$\n\x0b\n\x04\x05\
    \0\x02O\x12\x03X\x081\n\x0c\n\x05\x05\0\x02O\x01\x12\x03X\x08*\n\x0c\n\
    \x05\x05\0\x02O\x02\x12\x03X-0\n\x0b\n\x04\x05\0\x02P\x12\x03Y\x08#\n\
    \x0c\n\x05\x05\0\x02P\x01\x12\x03Y\x08\x1c\n\x0c\n\x05\x05\0\x02P\x02\
    \x12\x03Y\x1f\"\n\x0b\n\x04\x05\0\x02Q\x12\x03Z\x08)\n\x0c\n\x05\x05\0\
    \x02Q\x01\x12\x03Z\x08\"\n\x0c\n\x05\x05\0\x02Q\x02\x12\x03Z%(\n\x0b\n\
    \x04\x05\0\x02R\x12\x03[\x08)\n\x0c\n\x05\x05\0\x02R\x01\x12\x03[\x08\"\
    \n\x0c\n\x05\x05\0\x02R\x02\x12\x03[%(\n\x0b\n\x04\x05\0\x02S\x12\x03\\\
    \x08/\n\x0c\n\x05\x05\0\x02S\x01\x12\x03\\\x08(\n\x0c\n\x05\x05\0\x02S\
    \x02\x12\x03\\+.\n\x0b\n\x04\x05\0\x02T\x12\x03]\x08&\n\x0c\n\x05\x05\0\
    \x02T\x01\x12\x03]\x08\x1f\n\x0c\n\x05\x05\0\x02T\x02\x12\x03]\"%\n\x0b\
    \n\x04\x05\0\x02U\x12\x03^\x08!\n\x0c\n\x05\x05\0\x02U\x01\x12\x03^\x08\
    \x1a\n\x0c\n\x05\x05\0\x02U\x02\x12\x03^\x1d\x20\n\x0b\n\x04\x05\0\x02V\
    \x12\x03_\x08/\n\x0c\n\x05\x05\0\x02V\x01\x12\x03_\x08(\n\x0c\n\x05\x05\
    \0\x02V\x02\x12\x03_+.\n\x0b\n\x04\x05\0\x02W\x12\x03`\x08\"\n\x0c\n\x05\
    \x05\0\x02W\x01\x12\x03`\x08\x1b\n\x0c\n\x05\x05\0\x02W\x02\x12\x03`\x1e\
    !\n\x0b\n\x04\x05\0\x02X\x12\x03a\x084\n\x0c\n\x05\x05\0\x02X\x01\x12\
    \x03a\x08-\n\x0c\n\x05\x05\0\x02X\x02\x12\x03a03\n\x0b\n\x04\x05\0\x02Y\
    \x12\x03b\x083\n\x0c\n\x05\x05\0\x02Y\x01\x12\x03b\x08,\n\x0c\n\x05\x05\
    \0\x02Y\x02\x12\x03b/2\n\x0b\n\x04\x05\0\x02Z\x12\x03c\x08'\n\x0c\n\x05\
    \x05\0\x02Z\x01\x12\x03c\x08\x20\n\x0c\n\x05\x05\0\x02Z\x02\x12\x03c#&\n\
    \x0b\n\x04\x05\0\x02[\x12\x03d\x08#\n\x0c\n\x05\x05\0\x02[\x01\x12\x03d\
    \x08\x1c\n\x0c\n\x05\x05\0\x02[\x02\x12\x03d\x1f\"\n\x0b\n\x04\x05\0\x02\
    \\\x12\x03e\x08(\n\x0c\n\x05\x05\0\x02\\\x01\x12\x03e\x08!\n\x0c\n\x05\
    \x05\0\x02\\\x02\x12\x03e$'\n\x0b\n\x04\x05\0\x02]\x12\x03f\x08&\n\x0c\n\
    \x05\x05\0\x02]\x01\x12\x03f\x08\x1f\n\x0c\n\x05\x05\0\x02]\x02\x12\x03f\
    \"%\n\x0b\n\x04\x05\0\x02^\x12\x03g\x08)\n\x0c\n\x05\x05\0\x02^\x01\x12\
    \x03g\x08\"\n\x0c\n\x05\x05\0\x02^\x02\x12\x03g%(\n\x0b\n\x04\x05\0\x02_\
    \x12\x03h\x08,\n\x0c\n\x05\x05\0\x02_\x01\x12\x03h\x08%\n\x0c\n\x05\x05\
    \0\x02_\x02\x12\x03h(+\n\x0b\n\x04\x05\0\x02`\x12\x03i\x08,\n\x0c\n\x05\
    \x05\0\x02`\x01\x12\x03i\x08%\n\x0c\n\x05\x05\0\x02`\x02\x12\x03i(+\n\n\
    \n\x02\x04\0\x12\x04l\0n\x01\n\n\n\x03\x04\0\x01\x12\x03l\x08\x1e\n\x0b\
    \n\x04\x04\0\x02\0\x12\x03m\x089\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03m\
    \x08\x10\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03m\x11&\n\x0c\n\x05\x04\0\x02\
    \0\x01\x12\x03m'4\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03m78\n\n\n\x02\x04\
    \x01\x12\x04p\0r\x01\n\n\n\x03\x04\x01\x01\x12\x03p\x08\x20\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03q\x083\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03q\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03q\x11#\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03q$.\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03q12\n\n\n\x02\x04\
    \x02\x12\x04t\0z\x01\n\n\n\x03\x04\x02\x01\x12\x03t\x08%\n\x0b\n\x04\x04\
    \x02\x02\0\x12\x03u\x08)\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03u\x08\x10\
    \n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03u\x11\x16\n\x0c\n\x05\x04\x02\x02\
    \0\x01\x12\x03u\x17$\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03u'(\n\x0b\n\
    \x04\x04\x02\x02\x01\x12\x03v\x08%\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\
    \x03v\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03v\x11\x16\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x03v\x17\x20\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x03v#$\n\x0b\n\x04\x04\x02\x02\x02\x12\x03w\x08&\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03w\x11\x16\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03w\x17!\n\x0c\n\
    \x05\x04\x02\x02\x02\x03\x12\x03w$%\n\x0b\n\x04\x04\x02\x02\x03\x12\x03x\
    \x08+\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\
    \x02\x02\x03\x05\x12\x03x\x11\x16\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\
    \x03x\x17&\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03x)*\n\x0b\n\x04\x04\
    \x02\x02\x04\x12\x03y\x08-\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03y\x08\
    \x10\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03y\x11\x16\n\x0c\n\x05\x04\
    \x02\x02\x04\x01\x12\x03y\x17(\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03y+\
    ,\n\n\n\x02\x04\x03\x12\x04|\0\x7f\x01\n\n\n\x03\x04\x03\x01\x12\x03|\
    \x08$\n\x0b\n\x04\x04\x03\x02\0\x12\x03}\x08/\n\x0c\n\x05\x04\x03\x02\0\
    \x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03}\x11\x16\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03}\x17*\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03}-.\n\x0b\n\x04\x04\x03\x02\x01\x12\x03~\x08+\n\x0c\n\x05\x04\
    \x03\x02\x01\x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\
    \x03~\x11\x16\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03~\x17&\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x03~)*\n\x0c\n\x02\x04\x04\x12\x06\x81\x01\0\
    \x84\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x81\x01\x08\"\n\x0c\n\x04\
    \x04\x04\x02\0\x12\x04\x82\x01\x08/\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\
    \x82\x01\x08\x10\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x82\x01\x11\x16\n\r\
    \n\x05\x04\x04\x02\0\x01\x12\x04\x82\x01\x17*\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\x82\x01-.\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\x83\x01\x08+\
    \n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\x83\x01\x08\x10\n\r\n\x05\x04\x04\
    \x02\x01\x05\x12\x04\x83\x01\x11\x16\n\r\n\x05\x04\x04\x02\x01\x01\x12\
    \x04\x83\x01\x17&\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x83\x01)*\n\x0c\
    \n\x02\x04\x05\x12\x06\x86\x01\0\x89\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\
    \x04\x86\x01\x08\"\n\x0c\n\x04\x04\x05\x02\0\x12\x04\x87\x01\x08+\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\
    \x05\x12\x04\x87\x01\x11\x16\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x87\x01\
    \x17&\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x87\x01)*\n\x0c\n\x04\x04\x05\
    \x02\x01\x12\x04\x88\x01\x08*\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\x88\
    \x01\x08\x10\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x88\x01\x11\x15\n\r\n\
    \x05\x04\x05\x02\x01\x01\x12\x04\x88\x01\x16%\n\r\n\x05\x04\x05\x02\x01\
    \x03\x12\x04\x88\x01()\n\x0c\n\x02\x04\x06\x12\x06\x8b\x01\0\x8f\x01\x01\
    \n\x0b\n\x03\x04\x06\x01\x12\x04\x8b\x01\x08'\n\x0c\n\x04\x04\x06\x02\0\
    \x12\x04\x8c\x01\x08,\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\x8c\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x8c\x01\x11\x16\n\r\n\x05\x04\
    \x06\x02\0\x01\x12\x04\x8c\x01\x17'\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \x8c\x01*+\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\x8d\x01\x08)\n\r\n\x05\
    \x04\x06\x02\x01\x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x06\x02\x01\
    \x05\x12\x04\x8d\x01\x11\x16\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x8d\
    \x01\x17$\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x8d\x01'(\n\x0c\n\x04\
    \x04\x06\x02\x02\x12\x04\x8e\x01\x08(\n\r\n\x05\x04\x06\x02\x02\x04\x12\
    \x04\x8e\x01\x08\x10\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\x8e\x01\x11\
    \x15\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\x8e\x01\x16#\n\r\n\x05\x04\
    \x06\x02\x02\x03\x12\x04\x8e\x01&'\n\x0c\n\x02\x04\x07\x12\x06\x91\x01\0\
    \x93\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x91\x01\x08!\n\x0c\n\x04\
    \x04\x07\x02\0\x12\x04\x92\x01\x08#\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\
    \x92\x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x92\x01\x11\x15\n\r\
    \n\x05\x04\x07\x02\0\x01\x12\x04\x92\x01\x16\x1e\n\r\n\x05\x04\x07\x02\0\
    \x03\x12\x04\x92\x01!\"\n\x0c\n\x02\x04\x08\x12\x06\x95\x01\0\x97\x01\
    \x01\n\x0b\n\x03\x04\x08\x01\x12\x04\x95\x01\x08!\n\x0c\n\x04\x04\x08\
    \x02\0\x12\x04\x96\x01\x08#\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x96\x01\
    \x08\x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x96\x01\x11\x15\n\r\n\x05\
    \x04\x08\x02\0\x01\x12\x04\x96\x01\x16\x1e\n\r\n\x05\x04\x08\x02\0\x03\
    \x12\x04\x96\x01!\"\n\x0c\n\x02\x04\t\x12\x06\x99\x01\0\x9b\x01\x01\n\
    \x0b\n\x03\x04\t\x01\x12\x04\x99\x01\x08\x1e\n\x0c\n\x04\x04\t\x02\0\x12\
    \x04\x9a\x01\x08.\n\r\n\x05\x04\t\x02\0\x04\x12\x04\x9a\x01\x08\x10\n\r\
    \n\x05\x04\t\x02\0\x06\x12\x04\x9a\x01\x11!\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\x9a\x01\")\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x9a\x01,-\n\x0c\n\
    \x02\x04\n\x12\x06\x9d\x01\0\x9f\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \x9d\x01\x08\"\n\x0c\n\x04\x04\n\x02\0\x12\x04\x9e\x01\x08!\n\r\n\x05\
    \x04\n\x02\0\x04\x12\x04\x9e\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\
    \x04\x9e\x01\x11\x16\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x9e\x01\x17\x1c\n\
    \r\n\x05\x04\n\x02\0\x03\x12\x04\x9e\x01\x1f\x20\n\x0c\n\x02\x04\x0b\x12\
    \x06\xa1\x01\0\xb0\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xa1\x01\x08*\
    \n\x0e\n\x04\x04\x0b\x04\0\x12\x06\xa2\x01\x08\xa7\x01\t\n\r\n\x05\x04\
    \x0b\x04\0\x01\x12\x04\xa2\x01\r\x12\n\x0e\n\x06\x04\x0b\x04\0\x02\0\x12\
    \x04\xa3\x01\x10\x1d\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x01\x12\x04\xa3\x01\
    \x10\x17\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x02\x12\x04\xa3\x01\x1a\x1c\n\
    \x0e\n\x06\x04\x0b\x04\0\x02\x01\x12\x04\xa4\x01\x10\x1a\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\x01\x01\x12\x04\xa4\x01\x10\x15\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\x01\x02\x12\x04\xa4\x01\x18\x19\n\x0e\n\x06\x04\x0b\x04\0\x02\x02\
    \x12\x04\xa5\x01\x10$\n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x01\x12\x04\xa5\
    \x01\x10\x1f\n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x02\x12\x04\xa5\x01\"#\n\
    \x0e\n\x06\x04\x0b\x04\0\x02\x03\x12\x04\xa6\x01\x10\x1b\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\x03\x01\x12\x04\xa6\x01\x10\x16\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\x03\x02\x12\x04\xa6\x01\x19\x1a\n\x0e\n\x04\x04\x0b\x04\x01\x12\x06\
    \xa9\x01\x08\xac\x01\t\n\r\n\x05\x04\x0b\x04\x01\x01\x12\x04\xa9\x01\r\
    \x16\n\x0e\n\x06\x04\x0b\x04\x01\x02\0\x12\x04\xaa\x01\x10\x1b\n\x0f\n\
    \x07\x04\x0b\x04\x01\x02\0\x01\x12\x04\xaa\x01\x10\x16\n\x0f\n\x07\x04\
    \x0b\x04\x01\x02\0\x02\x12\x04\xaa\x01\x19\x1a\n\x0e\n\x06\x04\x0b\x04\
    \x01\x02\x01\x12\x04\xab\x01\x10\x1d\n\x0f\n\x07\x04\x0b\x04\x01\x02\x01\
    \x01\x12\x04\xab\x01\x10\x18\n\x0f\n\x07\x04\x0b\x04\x01\x02\x01\x02\x12\
    \x04\xab\x01\x1b\x1c\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xae\x01\x08C\n\r\
    \n\x05\x04\x0b\x02\0\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\
    \x06\x12\x04\xae\x01\x119\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xae\x01:>\
    \n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xae\x01AB\n\x0c\n\x04\x04\x0b\x02\
    \x01\x12\x04\xaf\x01\x08L\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xaf\x01\
    \x08\x10\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xaf\x01\x11=\n\r\n\x05\
    \x04\x0b\x02\x01\x01\x12\x04\xaf\x01>G\n\r\n\x05\x04\x0b\x02\x01\x03\x12\
    \x04\xaf\x01JK\n\x0c\n\x02\x04\x0c\x12\x06\xb2\x01\0\xb4\x01\x01\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\xb2\x01\x080\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\
    \xb3\x01\x08\"\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xb3\x01\x08\x10\n\r\n\
    \x05\x04\x0c\x02\0\x05\x12\x04\xb3\x01\x11\x15\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xb3\x01\x16\x1d\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xb3\x01\
    \x20!\n\x0c\n\x02\x04\r\x12\x06\xb6\x01\0\xb8\x01\x01\n\x0b\n\x03\x04\r\
    \x01\x12\x04\xb6\x01\x08+\n\x0c\n\x04\x04\r\x02\0\x12\x04\xb7\x01\x08\"\
    \n\r\n\x05\x04\r\x02\0\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\r\x02\0\
    \x05\x12\x04\xb7\x01\x11\x15\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xb7\x01\
    \x16\x1d\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb7\x01\x20!\n\x0c\n\x02\x04\
    \x0e\x12\x06\xba\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xba\
    \x01\x08*\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xbb\x01\x08\"\n\r\n\x05\x04\
    \x0e\x02\0\x04\x12\x04\xbb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\
    \x04\xbb\x01\x11\x15\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xbb\x01\x16\x1d\
    \n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xbb\x01\x20!\n\x0c\n\x02\x04\x0f\
    \x12\x06\xbe\x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xbe\x01\
    \x08#\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xbf\x01\x08#\n\r\n\x05\x04\x0f\
    \x02\0\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\
    \xbf\x01\x11\x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xbf\x01\x18\x1e\n\r\
    \n\x05\x04\x0f\x02\0\x03\x12\x04\xbf\x01!\"\n\x0c\n\x02\x04\x10\x12\x06\
    \xc2\x01\0\xc3\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xc2\x01\x08\x1c\n\
    \x0c\n\x02\x04\x11\x12\x06\xc5\x01\0\xc7\x01\x01\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\xc5\x01\x08#\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xc6\x01\x08!\n\r\
    \n\x05\x04\x11\x02\0\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xc6\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xc6\x01\
    \x18\x1c\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xc6\x01\x1f\x20\n\x0c\n\x02\
    \x04\x12\x12\x06\xc9\x01\0\xcd\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\
    \xc9\x01\x08'\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xca\x01\x08%\n\r\n\x05\
    \x04\x12\x02\0\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\
    \x12\x04\xca\x01\x11\x16\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xca\x01\x17\
    \x20\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xca\x01#$\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xcb\x01\x08!\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xcb\
    \x01\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xcb\x01\x11\x17\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xcb\x01\x18\x1c\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xcb\x01\x1f\x20\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xcc\
    \x01\x08\x20\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xcc\x01\x08\x10\n\r\n\
    \x05\x04\x12\x02\x02\x05\x12\x04\xcc\x01\x11\x15\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xcc\x01\x16\x1b\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\
    \xcc\x01\x1e\x1f\n\x0c\n\x02\x04\x13\x12\x06\xcf\x01\0\xd1\x01\x01\n\x0b\
    \n\x03\x04\x13\x01\x12\x04\xcf\x01\x08\"\n\x0c\n\x04\x04\x13\x02\0\x12\
    \x04\xd0\x01\x08%\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xd0\x01\x08\x10\n\
    \r\n\x05\x04\x13\x02\0\x05\x12\x04\xd0\x01\x11\x16\n\r\n\x05\x04\x13\x02\
    \0\x01\x12\x04\xd0\x01\x17\x20\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xd0\
    \x01#$\n\x0c\n\x02\x04\x14\x12\x06\xd3\x01\0\xd5\x01\x01\n\x0b\n\x03\x04\
    \x14\x01\x12\x04\xd3\x01\x08!\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xd4\x01\
    \x08%\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\
    \x14\x02\0\x05\x12\x04\xd4\x01\x11\x16\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\xd4\x01\x17\x20\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xd4\x01#$\n\x0c\
    \n\x02\x04\x15\x12\x06\xd7\x01\0\xd9\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xd7\x01\x08\x20\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xd8\x01\x082\n\r\
    \n\x05\x04\x15\x02\0\x04\x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\
    \x06\x12\x04\xd8\x01\x11#\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xd8\x01$-\
    \n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xd8\x0101\n\x0c\n\x02\x04\x16\x12\
    \x06\xdb\x01\0\xdc\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xdb\x01\x08)\
    \n\x0c\n\x02\x04\x17\x12\x06\xde\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x17\
    \x01\x12\x04\xde\x01\x08\x20\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xdf\x01\
    \x08,\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xdf\x01\x08\x10\n\r\n\x05\x04\
    \x17\x02\0\x05\x12\x04\xdf\x01\x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\
    \x04\xdf\x01\x18'\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xdf\x01*+\n\x0c\n\
    \x04\x04\x17\x02\x01\x12\x04\xe0\x01\x08*\n\r\n\x05\x04\x17\x02\x01\x04\
    \x12\x04\xe0\x01\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xe0\x01\
    \x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xe0\x01\x18%\n\r\n\x05\
    \x04\x17\x02\x01\x03\x12\x04\xe0\x01()\n\x0c\n\x04\x04\x17\x02\x02\x12\
    \x04\xe1\x01\x08(\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xe1\x01\x08\x10\
    \n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x17\
    \x02\x02\x01\x12\x04\xe1\x01\x18#\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\
    \xe1\x01&'\n\x0c\n\x02\x04\x18\x12\x06\xe4\x01\0\xe6\x01\x01\n\x0b\n\x03\
    \x04\x18\x01\x12\x04\xe4\x01\x08$\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xe5\
    \x01\x086\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\
    \x04\x18\x02\0\x06\x12\x04\xe5\x01\x11'\n\r\n\x05\x04\x18\x02\0\x01\x12\
    \x04\xe5\x01(1\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xe5\x0145\n\x0c\n\x02\
    \x04\x19\x12\x06\xe8\x01\0\xea\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\
    \xe8\x01\x08+\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xe9\x01\x08A\n\r\n\x05\
    \x04\x19\x02\0\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x19\x02\0\x06\
    \x12\x04\xe9\x01\x11.\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xe9\x01/<\n\r\
    \n\x05\x04\x19\x02\0\x03\x12\x04\xe9\x01?@\n\x0c\n\x02\x04\x1a\x12\x06\
    \xec\x01\0\xef\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xec\x01\x08,\n\
    \x0c\n\x04\x04\x1a\x02\0\x12\x04\xed\x01\x08(\n\r\n\x05\x04\x1a\x02\0\
    \x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xed\x01\
    \x11\x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xed\x01\x18#\n\r\n\x05\x04\
    \x1a\x02\0\x03\x12\x04\xed\x01&'\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xee\
    \x01\x08)\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xee\x01\x08\x10\n\r\n\
    \x05\x04\x1a\x02\x01\x05\x12\x04\xee\x01\x11\x15\n\r\n\x05\x04\x1a\x02\
    \x01\x01\x12\x04\xee\x01\x16$\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xee\
    \x01'(\n\x0c\n\x02\x04\x1b\x12\x06\xf1\x01\0\xf4\x01\x01\n\x0b\n\x03\x04\
    \x1b\x01\x12\x04\xf1\x01\x08)\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xf2\x01\
    \x08+\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xf2\x01\x08\x10\n\r\n\x05\x04\
    \x1b\x02\0\x05\x12\x04\xf2\x01\x11\x16\n\r\n\x05\x04\x1b\x02\0\x01\x12\
    \x04\xf2\x01\x17&\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xf2\x01)*\n\x0c\n\
    \x04\x04\x1b\x02\x01\x12\x04\xf3\x01\x08&\n\r\n\x05\x04\x1b\x02\x01\x04\
    \x12\x04\xf3\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xf3\x01\
    \x11\x15\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xf3\x01\x16!\n\r\n\x05\
    \x04\x1b\x02\x01\x03\x12\x04\xf3\x01$%\n\x0c\n\x02\x04\x1c\x12\x06\xf6\
    \x01\0\xf8\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xf6\x01\x08%\n\x0c\n\
    \x04\x04\x1c\x02\0\x12\x04\xf7\x01\x08=\n\r\n\x05\x04\x1c\x02\0\x04\x12\
    \x04\xf7\x01\x08\x10\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xf7\x01\x112\n\
    \r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf7\x0138\n\r\n\x05\x04\x1c\x02\0\x03\
    \x12\x04\xf7\x01;<\n\x0c\n\x02\x04\x1d\x12\x06\xfa\x01\0\xfc\x01\x01\n\
    \x0b\n\x03\x04\x1d\x01\x12\x04\xfa\x01\x08!\n\x0c\n\x04\x04\x1d\x02\0\
    \x12\x04\xfb\x01\x08(\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xfb\x01\x08\
    \x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xfb\x01\x11\x16\n\r\n\x05\x04\
    \x1d\x02\0\x01\x12\x04\xfb\x01\x17#\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\
    \xfb\x01&'\n\x0c\n\x02\x04\x1e\x12\x06\xfe\x01\0\x82\x02\x01\n\x0b\n\x03\
    \x04\x1e\x01\x12\x04\xfe\x01\x08(\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xff\
    \x01\x08+\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xff\x01\x08\x10\n\r\n\x05\
    \x04\x1e\x02\0\x05\x12\x04\xff\x01\x11\x16\n\r\n\x05\x04\x1e\x02\0\x01\
    \x12\x04\xff\x01\x17&\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xff\x01)*\n\
    \x0c\n\x04\x04\x1e\x02\x01\x12\x04\x80\x02\x08+\n\r\n\x05\x04\x1e\x02\
    \x01\x04\x12\x04\x80\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\
    \x80\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\x80\x02\x18&\n\r\
    \n\x05\x04\x1e\x02\x01\x03\x12\x04\x80\x02)*\n\x0c\n\x04\x04\x1e\x02\x02\
    \x12\x04\x81\x02\x080\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\x81\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\x81\x02\x11\x16\n\r\n\x05\x04\
    \x1e\x02\x02\x01\x12\x04\x81\x02\x17+\n\r\n\x05\x04\x1e\x02\x02\x03\x12\
    \x04\x81\x02./\n\x0c\n\x02\x04\x1f\x12\x06\x84\x02\0\x85\x02\x01\n\x0b\n\
    \x03\x04\x1f\x01\x12\x04\x84\x02\x08(\n\x0c\n\x02\x04\x20\x12\x06\x87\
    \x02\0\x8c\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x87\x02\x08$\n\x0c\n\
    \x04\x04\x20\x02\0\x12\x04\x88\x02\x08+\n\r\n\x05\x04\x20\x02\0\x04\x12\
    \x04\x88\x02\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x88\x02\x11\x16\
    \n\r\n\x05\x04\x20\x02\0\x01\x12\x04\x88\x02\x17&\n\r\n\x05\x04\x20\x02\
    \0\x03\x12\x04\x88\x02)*\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x89\x02\x08\
    %\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\x04\
    \x20\x02\x01\x05\x12\x04\x89\x02\x11\x16\n\r\n\x05\x04\x20\x02\x01\x01\
    \x12\x04\x89\x02\x17\x20\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x89\x02#$\
    \n\x0c\n\x04\x04\x20\x02\x02\x12\x04\x8a\x02\x081\n\r\n\x05\x04\x20\x02\
    \x02\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\
    \x8a\x02\x11\x16\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x8a\x02\x17,\n\r\
    \n\x05\x04\x20\x02\x02\x03\x12\x04\x8a\x02/0\n\x0c\n\x04\x04\x20\x02\x03\
    \x12\x04\x8b\x02\x08'\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x8b\x02\x08\
    \x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\x8b\x02\x11\x15\n\r\n\x05\x04\
    \x20\x02\x03\x01\x12\x04\x8b\x02\x16\"\n\r\n\x05\x04\x20\x02\x03\x03\x12\
    \x04\x8b\x02%&\n\x0c\n\x02\x04!\x12\x06\x8e\x02\0\x90\x02\x01\n\x0b\n\
    \x03\x04!\x01\x12\x04\x8e\x02\x08%\n\x0c\n\x04\x04!\x02\0\x12\x04\x8f\
    \x02\x08#\n\r\n\x05\x04!\x02\0\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\x04\
    !\x02\0\x05\x12\x04\x8f\x02\x11\x15\n\r\n\x05\x04!\x02\0\x01\x12\x04\x8f\
    \x02\x16\x1e\n\r\n\x05\x04!\x02\0\x03\x12\x04\x8f\x02!\"\n\x0c\n\x02\x04\
    \"\x12\x06\x92\x02\0\x94\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\x92\x02\
    \x08'\n\x0c\n\x04\x04\"\x02\0\x12\x04\x93\x02\x08'\n\r\n\x05\x04\"\x02\0\
    \x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\x93\x02\
    \x11\x16\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x93\x02\x17\"\n\r\n\x05\x04\"\
    \x02\0\x03\x12\x04\x93\x02%&\n\x0c\n\x02\x04#\x12\x06\x96\x02\0\x98\x02\
    \x01\n\x0b\n\x03\x04#\x01\x12\x04\x96\x02\x080\n\x0c\n\x04\x04#\x02\0\
    \x12\x04\x97\x02\x08$\n\r\n\x05\x04#\x02\0\x04\x12\x04\x97\x02\x08\x10\n\
    \r\n\x05\x04#\x02\0\x05\x12\x04\x97\x02\x11\x15\n\r\n\x05\x04#\x02\0\x01\
    \x12\x04\x97\x02\x16\x1f\n\r\n\x05\x04#\x02\0\x03\x12\x04\x97\x02\"#\n\
    \x0c\n\x02\x04$\x12\x06\x9a\x02\0\x9c\x02\x01\n\x0b\n\x03\x04$\x01\x12\
    \x04\x9a\x02\x08=\n\x0c\n\x04\x04$\x02\0\x12\x04\x9b\x02\x08\"\n\r\n\x05\
    \x04$\x02\0\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04$\x02\0\x05\x12\x04\
    \x9b\x02\x11\x15\n\r\n\x05\x04$\x02\0\x01\x12\x04\x9b\x02\x16\x1d\n\r\n\
    \x05\x04$\x02\0\x03\x12\x04\x9b\x02\x20!\n\x0c\n\x02\x04%\x12\x06\x9e\
    \x02\0\xa0\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\x9e\x02\x08-\n\x0c\n\x04\
    \x04%\x02\0\x12\x04\x9f\x02\x08'\n\r\n\x05\x04%\x02\0\x04\x12\x04\x9f\
    \x02\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\x9f\x02\x11\x15\n\r\n\x05\
    \x04%\x02\0\x01\x12\x04\x9f\x02\x16\"\n\r\n\x05\x04%\x02\0\x03\x12\x04\
    \x9f\x02%&\n\x0c\n\x02\x04&\x12\x06\xa2\x02\0\xa4\x02\x01\n\x0b\n\x03\
    \x04&\x01\x12\x04\xa2\x02\x08%\n\x0c\n\x04\x04&\x02\0\x12\x04\xa3\x02\
    \x08+\n\r\n\x05\x04&\x02\0\x04\x12\x04\xa3\x02\x08\x10\n\r\n\x05\x04&\
    \x02\0\x05\x12\x04\xa3\x02\x11\x16\n\r\n\x05\x04&\x02\0\x01\x12\x04\xa3\
    \x02\x17&\n\r\n\x05\x04&\x02\0\x03\x12\x04\xa3\x02)*\n\x0c\n\x02\x04'\
    \x12\x06\xa6\x02\0\xa8\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xa6\x02\x08&\
    \n\x0c\n\x04\x04'\x02\0\x12\x04\xa7\x02\x08\x20\n\r\n\x05\x04'\x02\0\x04\
    \x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xa7\x02\x11\
    \x16\n\r\n\x05\x04'\x02\0\x01\x12\x04\xa7\x02\x17\x1b\n\r\n\x05\x04'\x02\
    \0\x03\x12\x04\xa7\x02\x1e\x1f\n\x0c\n\x02\x04(\x12\x06\xaa\x02\0\xb1\
    \x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xaa\x02\x08\x1f\n\x0c\n\x04\x04(\
    \x02\0\x12\x04\xab\x02\x08#\n\r\n\x05\x04(\x02\0\x04\x12\x04\xab\x02\x08\
    \x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xab\x02\x11\x16\n\r\n\x05\x04(\x02\
    \0\x01\x12\x04\xab\x02\x17\x1e\n\r\n\x05\x04(\x02\0\x03\x12\x04\xab\x02!\
    \"\n\x0c\n\x04\x04(\x02\x01\x12\x04\xac\x02\x08,\n\r\n\x05\x04(\x02\x01\
    \x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xac\x02\
    \x11\x16\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xac\x02\x17'\n\r\n\x05\x04(\
    \x02\x01\x03\x12\x04\xac\x02*+\n\x0c\n\x04\x04(\x02\x02\x12\x04\xad\x02\
    \x08&\n\r\n\x05\x04(\x02\x02\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04(\
    \x02\x02\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04(\x02\x02\x01\x12\x04\
    \xad\x02\x18!\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xad\x02$%\n\x0c\n\x04\
    \x04(\x02\x03\x12\x04\xae\x02\x08%\n\r\n\x05\x04(\x02\x03\x04\x12\x04\
    \xae\x02\x08\x10\n\r\n\x05\x04(\x02\x03\x05\x12\x04\xae\x02\x11\x17\n\r\
    \n\x05\x04(\x02\x03\x01\x12\x04\xae\x02\x18\x20\n\r\n\x05\x04(\x02\x03\
    \x03\x12\x04\xae\x02#$\n\x0c\n\x04\x04(\x02\x04\x12\x04\xaf\x02\x08(\n\r\
    \n\x05\x04(\x02\x04\x04\x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04(\x02\x04\
    \x05\x12\x04\xaf\x02\x11\x17\n\r\n\x05\x04(\x02\x04\x01\x12\x04\xaf\x02\
    \x18#\n\r\n\x05\x04(\x02\x04\x03\x12\x04\xaf\x02&'\n\x0c\n\x04\x04(\x02\
    \x05\x12\x04\xb0\x02\x081\n\r\n\x05\x04(\x02\x05\x04\x12\x04\xb0\x02\x08\
    \x10\n\r\n\x05\x04(\x02\x05\x05\x12\x04\xb0\x02\x11\x15\n\r\n\x05\x04(\
    \x02\x05\x01\x12\x04\xb0\x02\x16,\n\r\n\x05\x04(\x02\x05\x03\x12\x04\xb0\
    \x02/0\n\x0c\n\x02\x04)\x12\x06\xb3\x02\0\xb7\x02\x01\n\x0b\n\x03\x04)\
    \x01\x12\x04\xb3\x02\x08&\n\x0c\n\x04\x04)\x02\0\x12\x04\xb4\x02\x08%\n\
    \r\n\x05\x04)\x02\0\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\x04)\x02\0\x05\
    \x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\x04\xb4\x02\x18\
    \x20\n\r\n\x05\x04)\x02\0\x03\x12\x04\xb4\x02#$\n\x0c\n\x04\x04)\x02\x01\
    \x12\x04\xb5\x02\x08$\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xb5\x02\x08\x10\
    \n\r\n\x05\x04)\x02\x01\x05\x12\x04\xb5\x02\x11\x17\n\r\n\x05\x04)\x02\
    \x01\x01\x12\x04\xb5\x02\x18\x1f\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xb5\
    \x02\"#\n\x0c\n\x04\x04)\x02\x02\x12\x04\xb6\x02\x08(\n\r\n\x05\x04)\x02\
    \x02\x04\x12\x04\xb6\x02\x08\x10\n\r\n\x05\x04)\x02\x02\x05\x12\x04\xb6\
    \x02\x11\x17\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xb6\x02\x18#\n\r\n\x05\
    \x04)\x02\x02\x03\x12\x04\xb6\x02&'\n\x0c\n\x02\x04*\x12\x06\xb9\x02\0\
    \xbe\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\xb9\x02\x08&\n\x0c\n\x04\x04*\
    \x02\0\x12\x04\xba\x02\x08%\n\r\n\x05\x04*\x02\0\x04\x12\x04\xba\x02\x08\
    \x10\n\r\n\x05\x04*\x02\0\x06\x12\x04\xba\x02\x11\x17\n\r\n\x05\x04*\x02\
    \0\x01\x12\x04\xba\x02\x18\x20\n\r\n\x05\x04*\x02\0\x03\x12\x04\xba\x02#\
    $\n\x0c\n\x04\x04*\x02\x01\x12\x04\xbb\x02\x08$\n\r\n\x05\x04*\x02\x01\
    \x04\x12\x04\xbb\x02\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xbb\x02\
    \x11\x17\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xbb\x02\x18\x1f\n\r\n\x05\
    \x04*\x02\x01\x03\x12\x04\xbb\x02\"#\n\x0c\n\x04\x04*\x02\x02\x12\x04\
    \xbc\x02\x08(\n\r\n\x05\x04*\x02\x02\x04\x12\x04\xbc\x02\x08\x10\n\r\n\
    \x05\x04*\x02\x02\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04*\x02\x02\x01\
    \x12\x04\xbc\x02\x18#\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xbc\x02&'\n\x0c\
    \n\x04\x04*\x02\x03\x12\x04\xbd\x02\x08$\n\r\n\x05\x04*\x02\x03\x04\x12\
    \x04\xbd\x02\x08\x10\n\r\n\x05\x04*\x02\x03\x05\x12\x04\xbd\x02\x11\x17\
    \n\r\n\x05\x04*\x02\x03\x01\x12\x04\xbd\x02\x18\x1f\n\r\n\x05\x04*\x02\
    \x03\x03\x12\x04\xbd\x02\"#\n\x0c\n\x02\x04+\x12\x06\xc0\x02\0\xc2\x02\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\xc0\x02\x08\x20\n\x0c\n\x04\x04+\x02\0\
    \x12\x04\xc1\x02\x08)\n\r\n\x05\x04+\x02\0\x04\x12\x04\xc1\x02\x08\x10\n\
    \r\n\x05\x04+\x02\0\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\xc1\x02\x18$\n\r\n\x05\x04+\x02\0\x03\x12\x04\xc1\x02'(\n\x0c\n\
    \x02\x04,\x12\x06\xc4\x02\0\xc6\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xc4\
    \x02\x08%\n\x0c\n\x04\x04,\x02\0\x12\x04\xc5\x02\x080\n\r\n\x05\x04,\x02\
    \0\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\xc5\x02\
    \x11\x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\xc5\x02\x18+\n\r\n\x05\x04,\
    \x02\0\x03\x12\x04\xc5\x02./\n\x0c\n\x02\x04-\x12\x06\xc8\x02\0\xca\x02\
    \x01\n\x0b\n\x03\x04-\x01\x12\x04\xc8\x02\x08\x20\n\x0c\n\x04\x04-\x02\0\
    \x12\x04\xc9\x02\x08)\n\r\n\x05\x04-\x02\0\x04\x12\x04\xc9\x02\x08\x10\n\
    \r\n\x05\x04-\x02\0\x05\x12\x04\xc9\x02\x11\x15\n\r\n\x05\x04-\x02\0\x01\
    \x12\x04\xc9\x02\x16$\n\r\n\x05\x04-\x02\0\x03\x12\x04\xc9\x02'(\n\x0c\n\
    \x02\x04.\x12\x06\xcc\x02\0\xce\x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\xcc\
    \x02\x08#\n\x0c\n\x04\x04.\x02\0\x12\x04\xcd\x02\x08%\n\r\n\x05\x04.\x02\
    \0\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\xcd\x02\
    \x11\x16\n\r\n\x05\x04.\x02\0\x01\x12\x04\xcd\x02\x17\x20\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\xcd\x02#$\n\x0c\n\x02\x04/\x12\x06\xd0\x02\0\xd2\x02\
    \x01\n\x0b\n\x03\x04/\x01\x12\x04\xd0\x02\x08%\n\x0c\n\x04\x04/\x02\0\
    \x12\x04\xd1\x02\x08/\n\r\n\x05\x04/\x02\0\x04\x12\x04\xd1\x02\x08\x10\n\
    \r\n\x05\x04/\x02\0\x05\x12\x04\xd1\x02\x11\x16\n\r\n\x05\x04/\x02\0\x01\
    \x12\x04\xd1\x02\x17*\n\r\n\x05\x04/\x02\0\x03\x12\x04\xd1\x02-.\n\x0c\n\
    \x02\x040\x12\x06\xd4\x02\0\xd6\x02\x01\n\x0b\n\x03\x040\x01\x12\x04\xd4\
    \x02\x08$\n\x0c\n\x04\x040\x02\0\x12\x04\xd5\x02\x08/\n\r\n\x05\x040\x02\
    \0\x04\x12\x04\xd5\x02\x08\x10\n\r\n\x05\x040\x02\0\x06\x12\x04\xd5\x02\
    \x11#\n\r\n\x05\x040\x02\0\x01\x12\x04\xd5\x02$*\n\r\n\x05\x040\x02\0\
    \x03\x12\x04\xd5\x02-.\n\x0c\n\x02\x041\x12\x06\xd8\x02\0\xdb\x02\x01\n\
    \x0b\n\x03\x041\x01\x12\x04\xd8\x02\x08\x1e\n\x0c\n\x04\x041\x02\0\x12\
    \x04\xd9\x02\x08+\n\r\n\x05\x041\x02\0\x04\x12\x04\xd9\x02\x08\x10\n\r\n\
    \x05\x041\x02\0\x05\x12\x04\xd9\x02\x11\x16\n\r\n\x05\x041\x02\0\x01\x12\
    \x04\xd9\x02\x17&\n\r\n\x05\x041\x02\0\x03\x12\x04\xd9\x02)*\n\x0c\n\x04\
    \x041\x02\x01\x12\x04\xda\x02\x08)\n\r\n\x05\x041\x02\x01\x04\x12\x04\
    \xda\x02\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\xda\x02\x11\x17\n\r\
    \n\x05\x041\x02\x01\x01\x12\x04\xda\x02\x18$\n\r\n\x05\x041\x02\x01\x03\
    \x12\x04\xda\x02'(\n\x0c\n\x02\x042\x12\x06\xdd\x02\0\xe2\x02\x01\n\x0b\
    \n\x03\x042\x01\x12\x04\xdd\x02\x08&\n\x0c\n\x04\x042\x02\0\x12\x04\xde\
    \x02\x08+\n\r\n\x05\x042\x02\0\x04\x12\x04\xde\x02\x08\x10\n\r\n\x05\x04\
    2\x02\0\x05\x12\x04\xde\x02\x11\x16\n\r\n\x05\x042\x02\0\x01\x12\x04\xde\
    \x02\x17&\n\r\n\x05\x042\x02\0\x03\x12\x04\xde\x02)*\n\x0c\n\x04\x042\
    \x02\x01\x12\x04\xdf\x02\x08&\n\r\n\x05\x042\x02\x01\x04\x12\x04\xdf\x02\
    \x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\xdf\x02\x11\x16\n\r\n\x05\
    \x042\x02\x01\x01\x12\x04\xdf\x02\x17!\n\r\n\x05\x042\x02\x01\x03\x12\
    \x04\xdf\x02$%\n\x0c\n\x04\x042\x02\x02\x12\x04\xe0\x02\x08\x20\n\r\n\
    \x05\x042\x02\x02\x04\x12\x04\xe0\x02\x08\x10\n\r\n\x05\x042\x02\x02\x05\
    \x12\x04\xe0\x02\x11\x16\n\r\n\x05\x042\x02\x02\x01\x12\x04\xe0\x02\x17\
    \x1b\n\r\n\x05\x042\x02\x02\x03\x12\x04\xe0\x02\x1e\x1f\n\x0c\n\x04\x042\
    \x02\x03\x12\x04\xe1\x02\x08\"\n\r\n\x05\x042\x02\x03\x04\x12\x04\xe1\
    \x02\x08\x10\n\r\n\x05\x042\x02\x03\x05\x12\x04\xe1\x02\x11\x15\n\r\n\
    \x05\x042\x02\x03\x01\x12\x04\xe1\x02\x16\x1d\n\r\n\x05\x042\x02\x03\x03\
    \x12\x04\xe1\x02\x20!\n\x0c\n\x02\x043\x12\x06\xe4\x02\0\xeb\x02\x01\n\
    \x0b\n\x03\x043\x01\x12\x04\xe4\x02\x08)\n\x0c\n\x04\x043\x02\0\x12\x04\
    \xe5\x02\x08+\n\r\n\x05\x043\x02\0\x04\x12\x04\xe5\x02\x08\x10\n\r\n\x05\
    \x043\x02\0\x05\x12\x04\xe5\x02\x11\x16\n\r\n\x05\x043\x02\0\x01\x12\x04\
    \xe5\x02\x17&\n\r\n\x05\x043\x02\0\x03\x12\x04\xe5\x02)*\n\x0c\n\x04\x04\
    3\x02\x01\x12\x04\xe6\x02\x08)\n\r\n\x05\x043\x02\x01\x04\x12\x04\xe6\
    \x02\x08\x10\n\r\n\x05\x043\x02\x01\x05\x12\x04\xe6\x02\x11\x17\n\r\n\
    \x05\x043\x02\x01\x01\x12\x04\xe6\x02\x18$\n\r\n\x05\x043\x02\x01\x03\
    \x12\x04\xe6\x02'(\n\x0c\n\x04\x043\x02\x02\x12\x04\xe7\x02\x08&\n\r\n\
    \x05\x043\x02\x02\x04\x12\x04\xe7\x02\x08\x10\n\r\n\x05\x043\x02\x02\x05\
    \x12\x04\xe7\x02\x11\x17\n\r\n\x05\x043\x02\x02\x01\x12\x04\xe7\x02\x18!\
    \n\r\n\x05\x043\x02\x02\x03\x12\x04\xe7\x02$%\n\x0c\n\x04\x043\x02\x03\
    \x12\x04\xe8\x02\x08+\n\r\n\x05\x043\x02\x03\x04\x12\x04\xe8\x02\x08\x10\
    \n\r\n\x05\x043\x02\x03\x05\x12\x04\xe8\x02\x11\x16\n\r\n\x05\x043\x02\
    \x03\x01\x12\x04\xe8\x02\x17&\n\r\n\x05\x043\x02\x03\x03\x12\x04\xe8\x02\
    )*\n\x0c\n\x04\x043\x02\x04\x12\x04\xe9\x02\x08&\n\r\n\x05\x043\x02\x04\
    \x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\x043\x02\x04\x05\x12\x04\xe9\x02\
    \x11\x17\n\r\n\x05\x043\x02\x04\x01\x12\x04\xe9\x02\x18!\n\r\n\x05\x043\
    \x02\x04\x03\x12\x04\xe9\x02$%\n\x0c\n\x04\x043\x02\x05\x12\x04\xea\x02\
    \x08)\n\r\n\x05\x043\x02\x05\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\x043\
    \x02\x05\x05\x12\x04\xea\x02\x11\x17\n\r\n\x05\x043\x02\x05\x01\x12\x04\
    \xea\x02\x18$\n\r\n\x05\x043\x02\x05\x03\x12\x04\xea\x02'(\n\x0c\n\x02\
    \x044\x12\x06\xed\x02\0\xee\x02\x01\n\x0b\n\x03\x044\x01\x12\x04\xed\x02\
    \x08!\n\x0c\n\x02\x045\x12\x06\xf0\x02\0\xf8\x02\x01\n\x0b\n\x03\x045\
    \x01\x12\x04\xf0\x02\x08\"\n\x0c\n\x04\x045\x02\0\x12\x04\xf1\x02\x08%\n\
    \r\n\x05\x045\x02\0\x04\x12\x04\xf1\x02\x08\x10\n\r\n\x05\x045\x02\0\x05\
    \x12\x04\xf1\x02\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xf1\x02\x18\
    \x20\n\r\n\x05\x045\x02\0\x03\x12\x04\xf1\x02#$\n\x0c\n\x04\x045\x02\x01\
    \x12\x04\xf2\x02\x08)\n\r\n\x05\x045\x02\x01\x04\x12\x04\xf2\x02\x08\x10\
    \n\r\n\x05\x045\x02\x01\x05\x12\x04\xf2\x02\x11\x17\n\r\n\x05\x045\x02\
    \x01\x01\x12\x04\xf2\x02\x18$\n\r\n\x05\x045\x02\x01\x03\x12\x04\xf2\x02\
    '(\n\x0c\n\x04\x045\x02\x02\x12\x04\xf3\x02\x08%\n\r\n\x05\x045\x02\x02\
    \x04\x12\x04\xf3\x02\x08\x10\n\r\n\x05\x045\x02\x02\x05\x12\x04\xf3\x02\
    \x11\x17\n\r\n\x05\x045\x02\x02\x01\x12\x04\xf3\x02\x18\x20\n\r\n\x05\
    \x045\x02\x02\x03\x12\x04\xf3\x02#$\n\x0c\n\x04\x045\x02\x03\x12\x04\xf4\
    \x02\x08!\n\r\n\x05\x045\x02\x03\x04\x12\x04\xf4\x02\x08\x10\n\r\n\x05\
    \x045\x02\x03\x05\x12\x04\xf4\x02\x11\x17\n\r\n\x05\x045\x02\x03\x01\x12\
    \x04\xf4\x02\x18\x1c\n\r\n\x05\x045\x02\x03\x03\x12\x04\xf4\x02\x1f\x20\
    \n\x0c\n\x04\x045\x02\x04\x12\x04\xf5\x02\x08\"\n\r\n\x05\x045\x02\x04\
    \x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\x045\x02\x04\x05\x12\x04\xf5\x02\
    \x11\x17\n\r\n\x05\x045\x02\x04\x01\x12\x04\xf5\x02\x18\x1d\n\r\n\x05\
    \x045\x02\x04\x03\x12\x04\xf5\x02\x20!\n\x0c\n\x04\x045\x02\x05\x12\x04\
    \xf6\x02\x08)\n\r\n\x05\x045\x02\x05\x04\x12\x04\xf6\x02\x08\x10\n\r\n\
    \x05\x045\x02\x05\x05\x12\x04\xf6\x02\x11\x16\n\r\n\x05\x045\x02\x05\x01\
    \x12\x04\xf6\x02\x17$\n\r\n\x05\x045\x02\x05\x03\x12\x04\xf6\x02'(\n\x0c\
    \n\x04\x045\x02\x06\x12\x04\xf7\x02\x08+\n\r\n\x05\x045\x02\x06\x04\x12\
    \x04\xf7\x02\x08\x10\n\r\n\x05\x045\x02\x06\x05\x12\x04\xf7\x02\x11\x16\
    \n\r\n\x05\x045\x02\x06\x01\x12\x04\xf7\x02\x17&\n\r\n\x05\x045\x02\x06\
    \x03\x12\x04\xf7\x02)*\n\x0c\n\x02\x046\x12\x06\xfa\x02\0\xfd\x02\x01\n\
    \x0b\n\x03\x046\x01\x12\x04\xfa\x02\x08'\n\x0c\n\x04\x046\x02\0\x12\x04\
    \xfb\x02\x08\x20\n\r\n\x05\x046\x02\0\x04\x12\x04\xfb\x02\x08\x10\n\r\n\
    \x05\x046\x02\0\x05\x12\x04\xfb\x02\x11\x16\n\r\n\x05\x046\x02\0\x01\x12\
    \x04\xfb\x02\x17\x1b\n\r\n\x05\x046\x02\0\x03\x12\x04\xfb\x02\x1e\x1f\n\
    \x0c\n\x04\x046\x02\x01\x12\x04\xfc\x02\x08'\n\r\n\x05\x046\x02\x01\x04\
    \x12\x04\xfc\x02\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\x04\xfc\x02\x11\
    \x15\n\r\n\x05\x046\x02\x01\x01\x12\x04\xfc\x02\x16\"\n\r\n\x05\x046\x02\
    \x01\x03\x12\x04\xfc\x02%&\n\x0c\n\x02\x047\x12\x06\xff\x02\0\x82\x03\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xff\x02\x08%\n\x0c\n\x04\x047\x02\0\
    \x12\x04\x80\x03\x08*\n\r\n\x05\x047\x02\0\x04\x12\x04\x80\x03\x08\x10\n\
    \r\n\x05\x047\x02\0\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\x047\x02\0\x01\
    \x12\x04\x80\x03\x18%\n\r\n\x05\x047\x02\0\x03\x12\x04\x80\x03()\n\x0c\n\
    \x04\x047\x02\x01\x12\x04\x81\x03\x08+\n\r\n\x05\x047\x02\x01\x04\x12\
    \x04\x81\x03\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\x81\x03\x11\x16\
    \n\r\n\x05\x047\x02\x01\x01\x12\x04\x81\x03\x17&\n\r\n\x05\x047\x02\x01\
    \x03\x12\x04\x81\x03)*\n\x0c\n\x02\x048\x12\x06\x84\x03\0\x87\x03\x01\n\
    \x0b\n\x03\x048\x01\x12\x04\x84\x03\x08/\n\x0c\n\x04\x048\x02\0\x12\x04\
    \x85\x03\x08+\n\r\n\x05\x048\x02\0\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\
    \x048\x02\0\x05\x12\x04\x85\x03\x11\x16\n\r\n\x05\x048\x02\0\x01\x12\x04\
    \x85\x03\x17&\n\r\n\x05\x048\x02\0\x03\x12\x04\x85\x03)*\n\x0c\n\x04\x04\
    8\x02\x01\x12\x04\x86\x03\x084\n\r\n\x05\x048\x02\x01\x04\x12\x04\x86\
    \x03\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\x04\x86\x03\x11\x17\n\r\n\
    \x05\x048\x02\x01\x01\x12\x04\x86\x03\x18/\n\r\n\x05\x048\x02\x01\x03\
    \x12\x04\x86\x0323\n\x0c\n\x02\x049\x12\x06\x89\x03\0\x8d\x03\x01\n\x0b\
    \n\x03\x049\x01\x12\x04\x89\x03\x08.\n\x0c\n\x04\x049\x02\0\x12\x04\x8a\
    \x03\x08'\n\r\n\x05\x049\x02\0\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\
    9\x02\0\x05\x12\x04\x8a\x03\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\x8a\
    \x03\x18\"\n\r\n\x05\x049\x02\0\x03\x12\x04\x8a\x03%&\n\x0c\n\x04\x049\
    \x02\x01\x12\x04\x8b\x03\x08\"\n\r\n\x05\x049\x02\x01\x04\x12\x04\x8b\
    \x03\x08\x10\n\r\n\x05\x049\x02\x01\x05\x12\x04\x8b\x03\x11\x16\n\r\n\
    \x05\x049\x02\x01\x01\x12\x04\x8b\x03\x17\x1d\n\r\n\x05\x049\x02\x01\x03\
    \x12\x04\x8b\x03\x20!\n\x0c\n\x04\x049\x02\x02\x12\x04\x8c\x03\x08\"\n\r\
    \n\x05\x049\x02\x02\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x049\x02\x02\
    \x05\x12\x04\x8c\x03\x11\x16\n\r\n\x05\x049\x02\x02\x01\x12\x04\x8c\x03\
    \x17\x1d\n\r\n\x05\x049\x02\x02\x03\x12\x04\x8c\x03\x20!\n\x0c\n\x02\x04\
    :\x12\x06\x8f\x03\0\x93\x03\x01\n\x0b\n\x03\x04:\x01\x12\x04\x8f\x03\x08\
    \x1f\n\x0c\n\x04\x04:\x02\0\x12\x04\x90\x03\x08)\n\r\n\x05\x04:\x02\0\
    \x04\x12\x04\x90\x03\x08\x10\n\r\n\x05\x04:\x02\0\x05\x12\x04\x90\x03\
    \x11\x17\n\r\n\x05\x04:\x02\0\x01\x12\x04\x90\x03\x18$\n\r\n\x05\x04:\
    \x02\0\x03\x12\x04\x90\x03'(\n\x0c\n\x04\x04:\x02\x01\x12\x04\x91\x03\
    \x08%\n\r\n\x05\x04:\x02\x01\x04\x12\x04\x91\x03\x08\x10\n\r\n\x05\x04:\
    \x02\x01\x05\x12\x04\x91\x03\x11\x17\n\r\n\x05\x04:\x02\x01\x01\x12\x04\
    \x91\x03\x18\x20\n\r\n\x05\x04:\x02\x01\x03\x12\x04\x91\x03#$\n\x0c\n\
    \x04\x04:\x02\x02\x12\x04\x92\x03\x08%\n\r\n\x05\x04:\x02\x02\x04\x12\
    \x04\x92\x03\x08\x10\n\r\n\x05\x04:\x02\x02\x05\x12\x04\x92\x03\x11\x17\
    \n\r\n\x05\x04:\x02\x02\x01\x12\x04\x92\x03\x18\x20\n\r\n\x05\x04:\x02\
    \x02\x03\x12\x04\x92\x03#$\n\x0c\n\x02\x04;\x12\x06\x95\x03\0\x97\x03\
    \x01\n\x0b\n\x03\x04;\x01\x12\x04\x95\x03\x08\x1f\n\x0c\n\x04\x04;\x02\0\
    \x12\x04\x96\x03\x08)\n\r\n\x05\x04;\x02\0\x04\x12\x04\x96\x03\x08\x10\n\
    \r\n\x05\x04;\x02\0\x05\x12\x04\x96\x03\x11\x17\n\r\n\x05\x04;\x02\0\x01\
    \x12\x04\x96\x03\x18$\n\r\n\x05\x04;\x02\0\x03\x12\x04\x96\x03'(\n\x0c\n\
    \x02\x04<\x12\x06\x99\x03\0\x9a\x03\x01\n\x0b\n\x03\x04<\x01\x12\x04\x99\
    \x03\x08-\n\x0c\n\x02\x04=\x12\x06\x9c\x03\0\x9e\x03\x01\n\x0b\n\x03\x04\
    =\x01\x12\x04\x9c\x03\x08&\n\x0c\n\x04\x04=\x02\0\x12\x04\x9d\x03\x08%\n\
    \r\n\x05\x04=\x02\0\x04\x12\x04\x9d\x03\x08\x10\n\r\n\x05\x04=\x02\0\x05\
    \x12\x04\x9d\x03\x11\x16\n\r\n\x05\x04=\x02\0\x01\x12\x04\x9d\x03\x17\
    \x20\n\r\n\x05\x04=\x02\0\x03\x12\x04\x9d\x03#$\n\x0c\n\x02\x04>\x12\x06\
    \xa0\x03\0\xa2\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\xa0\x03\x080\n\x0c\n\
    \x04\x04>\x02\0\x12\x04\xa1\x03\x08(\n\r\n\x05\x04>\x02\0\x04\x12\x04\
    \xa1\x03\x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\xa1\x03\x11\x15\n\r\n\
    \x05\x04>\x02\0\x01\x12\x04\xa1\x03\x16#\n\r\n\x05\x04>\x02\0\x03\x12\
    \x04\xa1\x03&'\n\x0c\n\x02\x04?\x12\x06\xa4\x03\0\xa9\x03\x01\n\x0b\n\
    \x03\x04?\x01\x12\x04\xa4\x03\x08+\n\x0c\n\x04\x04?\x02\0\x12\x04\xa5\
    \x03\x08%\n\r\n\x05\x04?\x02\0\x04\x12\x04\xa5\x03\x08\x10\n\r\n\x05\x04\
    ?\x02\0\x05\x12\x04\xa5\x03\x11\x16\n\r\n\x05\x04?\x02\0\x01\x12\x04\xa5\
    \x03\x17\x20\n\r\n\x05\x04?\x02\0\x03\x12\x04\xa5\x03#$\n\x0c\n\x04\x04?\
    \x02\x01\x12\x04\xa6\x03\x08$\n\r\n\x05\x04?\x02\x01\x04\x12\x04\xa6\x03\
    \x08\x10\n\r\n\x05\x04?\x02\x01\x05\x12\x04\xa6\x03\x11\x16\n\r\n\x05\
    \x04?\x02\x01\x01\x12\x04\xa6\x03\x17\x1f\n\r\n\x05\x04?\x02\x01\x03\x12\
    \x04\xa6\x03\"#\n\x0c\n\x04\x04?\x02\x02\x12\x04\xa7\x03\x08.\n\r\n\x05\
    \x04?\x02\x02\x04\x12\x04\xa7\x03\x08\x10\n\r\n\x05\x04?\x02\x02\x05\x12\
    \x04\xa7\x03\x11\x15\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xa7\x03\x16)\n\r\
    \n\x05\x04?\x02\x02\x03\x12\x04\xa7\x03,-\n\x0c\n\x04\x04?\x02\x03\x12\
    \x04\xa8\x03\x08%\n\r\n\x05\x04?\x02\x03\x04\x12\x04\xa8\x03\x08\x10\n\r\
    \n\x05\x04?\x02\x03\x05\x12\x04\xa8\x03\x11\x16\n\r\n\x05\x04?\x02\x03\
    \x01\x12\x04\xa8\x03\x17\x20\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xa8\x03#\
    $\n\x0c\n\x02\x04@\x12\x06\xab\x03\0\xae\x03\x01\n\x0b\n\x03\x04@\x01\
    \x12\x04\xab\x03\x081\n\x0c\n\x04\x04@\x02\0\x12\x04\xac\x03\x080\n\r\n\
    \x05\x04@\x02\0\x04\x12\x04\xac\x03\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\
    \x04\xac\x03\x11\x16\n\r\n\x05\x04@\x02\0\x01\x12\x04\xac\x03\x17+\n\r\n\
    \x05\x04@\x02\0\x03\x12\x04\xac\x03./\n\x0c\n\x04\x04@\x02\x01\x12\x04\
    \xad\x03\x08'\n\r\n\x05\x04@\x02\x01\x04\x12\x04\xad\x03\x08\x10\n\r\n\
    \x05\x04@\x02\x01\x05\x12\x04\xad\x03\x11\x15\n\r\n\x05\x04@\x02\x01\x01\
    \x12\x04\xad\x03\x16\"\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xad\x03%&\n\
    \x0c\n\x02\x04A\x12\x06\xb0\x03\0\xb3\x03\x01\n\x0b\n\x03\x04A\x01\x12\
    \x04\xb0\x03\x08(\n\x0c\n\x04\x04A\x02\0\x12\x04\xb1\x03\x08#\n\r\n\x05\
    \x04A\x02\0\x04\x12\x04\xb1\x03\x08\x10\n\r\n\x05\x04A\x02\0\x05\x12\x04\
    \xb1\x03\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\x04\xb1\x03\x18\x1e\n\r\n\
    \x05\x04A\x02\0\x03\x12\x04\xb1\x03!\"\n\x0c\n\x04\x04A\x02\x01\x12\x04\
    \xb2\x03\x08,\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xb2\x03\x08\x10\n\r\n\
    \x05\x04A\x02\x01\x05\x12\x04\xb2\x03\x11\x15\n\r\n\x05\x04A\x02\x01\x01\
    \x12\x04\xb2\x03\x16'\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xb2\x03*+\n\x0c\
    \n\x02\x04B\x12\x06\xb5\x03\0\xb8\x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\
    \xb5\x03\x08$\n\x0c\n\x04\x04B\x02\0\x12\x04\xb6\x03\x08.\n\r\n\x05\x04B\
    \x02\0\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\xb6\
    \x03\x11\x17\n\r\n\x05\x04B\x02\0\x01\x12\x04\xb6\x03\x18)\n\r\n\x05\x04\
    B\x02\0\x03\x12\x04\xb6\x03,-\n\x0c\n\x04\x04B\x02\x01\x12\x04\xb7\x03\
    \x08(\n\r\n\x05\x04B\x02\x01\x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x04B\
    \x02\x01\x05\x12\x04\xb7\x03\x11\x15\n\r\n\x05\x04B\x02\x01\x01\x12\x04\
    \xb7\x03\x16#\n\r\n\x05\x04B\x02\x01\x03\x12\x04\xb7\x03&'\n\x0c\n\x02\
    \x04C\x12\x06\xba\x03\0\xbf\x03\x01\n\x0b\n\x03\x04C\x01\x12\x04\xba\x03\
    \x08#\n\x0c\n\x04\x04C\x02\0\x12\x04\xbb\x03\x08+\n\r\n\x05\x04C\x02\0\
    \x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\xbb\x03\
    \x11\x17\n\r\n\x05\x04C\x02\0\x01\x12\x04\xbb\x03\x18&\n\r\n\x05\x04C\
    \x02\0\x03\x12\x04\xbb\x03)*\n\x0c\n\x04\x04C\x02\x01\x12\x04\xbc\x03\
    \x08+\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xbc\x03\x08\x10\n\r\n\x05\x04C\
    \x02\x01\x05\x12\x04\xbc\x03\x11\x17\n\r\n\x05\x04C\x02\x01\x01\x12\x04\
    \xbc\x03\x18&\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xbc\x03)*\n\x0c\n\x04\
    \x04C\x02\x02\x12\x04\xbd\x03\x08)\n\r\n\x05\x04C\x02\x02\x04\x12\x04\
    \xbd\x03\x08\x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xbd\x03\x11\x16\n\r\
    \n\x05\x04C\x02\x02\x01\x12\x04\xbd\x03\x17$\n\r\n\x05\x04C\x02\x02\x03\
    \x12\x04\xbd\x03'(\n\x0c\n\x04\x04C\x02\x03\x12\x04\xbe\x03\x08$\n\r\n\
    \x05\x04C\x02\x03\x04\x12\x04\xbe\x03\x08\x10\n\r\n\x05\x04C\x02\x03\x05\
    \x12\x04\xbe\x03\x11\x15\n\r\n\x05\x04C\x02\x03\x01\x12\x04\xbe\x03\x16\
    \x1f\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xbe\x03\"#\n\x0c\n\x02\x04D\x12\
    \x06\xc1\x03\0\xc4\x03\x01\n\x0b\n\x03\x04D\x01\x12\x04\xc1\x03\x08#\n\
    \x0c\n\x04\x04D\x02\0\x12\x04\xc2\x03\x08,\n\r\n\x05\x04D\x02\0\x04\x12\
    \x04\xc2\x03\x08\x10\n\r\n\x05\x04D\x02\0\x05\x12\x04\xc2\x03\x11\x16\n\
    \r\n\x05\x04D\x02\0\x01\x12\x04\xc2\x03\x17'\n\r\n\x05\x04D\x02\0\x03\
    \x12\x04\xc2\x03*+\n\x0c\n\x04\x04D\x02\x01\x12\x04\xc3\x03\x08$\n\r\n\
    \x05\x04D\x02\x01\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04D\x02\x01\x05\
    \x12\x04\xc3\x03\x11\x16\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xc3\x03\x17\
    \x1f\n\r\n\x05\x04D\x02\x01\x03\x12\x04\xc3\x03\"#\n\x0c\n\x02\x04E\x12\
    \x06\xc6\x03\0\xc8\x03\x01\n\x0b\n\x03\x04E\x01\x12\x04\xc6\x03\x08\x1f\
    \n\x0c\n\x04\x04E\x02\0\x12\x04\xc7\x03\x08%\n\r\n\x05\x04E\x02\0\x04\
    \x12\x04\xc7\x03\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\xc7\x03\x11\
    \x17\n\r\n\x05\x04E\x02\0\x01\x12\x04\xc7\x03\x18\x20\n\r\n\x05\x04E\x02\
    \0\x03\x12\x04\xc7\x03#$\n\x0c\n\x02\x04F\x12\x06\xca\x03\0\xcc\x03\x01\
    \n\x0b\n\x03\x04F\x01\x12\x04\xca\x03\x08)\n\x0c\n\x04\x04F\x02\0\x12\
    \x04\xcb\x03\x08+\n\r\n\x05\x04F\x02\0\x04\x12\x04\xcb\x03\x08\x10\n\r\n\
    \x05\x04F\x02\0\x05\x12\x04\xcb\x03\x11\x16\n\r\n\x05\x04F\x02\0\x01\x12\
    \x04\xcb\x03\x17&\n\r\n\x05\x04F\x02\0\x03\x12\x04\xcb\x03)*\n\x0c\n\x02\
    \x04G\x12\x06\xce\x03\0\xd0\x03\x01\n\x0b\n\x03\x04G\x01\x12\x04\xce\x03\
    \x08*\n\x0c\n\x04\x04G\x02\0\x12\x04\xcf\x03\x08(\n\r\n\x05\x04G\x02\0\
    \x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\xcf\x03\
    \x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xcf\x03\x18#\n\r\n\x05\x04G\
    \x02\0\x03\x12\x04\xcf\x03&'\n\x0c\n\x02\x04H\x12\x06\xd2\x03\0\xd5\x03\
    \x01\n\x0b\n\x03\x04H\x01\x12\x04\xd2\x03\x08%\n\x0c\n\x04\x04H\x02\0\
    \x12\x04\xd3\x03\x08$\n\r\n\x05\x04H\x02\0\x04\x12\x04\xd3\x03\x08\x10\n\
    \r\n\x05\x04H\x02\0\x05\x12\x04\xd3\x03\x11\x16\n\r\n\x05\x04H\x02\0\x01\
    \x12\x04\xd3\x03\x17\x1f\n\r\n\x05\x04H\x02\0\x03\x12\x04\xd3\x03\"#\n\
    \x0c\n\x04\x04H\x02\x01\x12\x04\xd4\x03\x08\x20\n\r\n\x05\x04H\x02\x01\
    \x04\x12\x04\xd4\x03\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\x04\xd4\x03\
    \x11\x16\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xd4\x03\x17\x1b\n\r\n\x05\
    \x04H\x02\x01\x03\x12\x04\xd4\x03\x1e\x1f\n\x0c\n\x02\x04I\x12\x06\xd7\
    \x03\0\xdc\x03\x01\n\x0b\n\x03\x04I\x01\x12\x04\xd7\x03\x081\n\x0c\n\x04\
    \x04I\x02\0\x12\x04\xd8\x03\x08=\n\r\n\x05\x04I\x02\0\x04\x12\x04\xd8\
    \x03\x08\x10\n\r\n\x05\x04I\x02\0\x06\x12\x04\xd8\x03\x11/\n\r\n\x05\x04\
    I\x02\0\x01\x12\x04\xd8\x0308\n\r\n\x05\x04I\x02\0\x03\x12\x04\xd8\x03;<\
    \n\x0c\n\x04\x04I\x02\x01\x12\x04\xd9\x03\x08<\n\r\n\x05\x04I\x02\x01\
    \x04\x12\x04\xd9\x03\x08\x10\n\r\n\x05\x04I\x02\x01\x06\x12\x04\xd9\x03\
    \x11)\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xd9\x03*7\n\r\n\x05\x04I\x02\
    \x01\x03\x12\x04\xd9\x03:;\n\x0c\n\x04\x04I\x02\x02\x12\x04\xda\x03\x086\
    \n\r\n\x05\x04I\x02\x02\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\x04I\x02\
    \x02\x06\x12\x04\xda\x03\x11&\n\r\n\x05\x04I\x02\x02\x01\x12\x04\xda\x03\
    '1\n\r\n\x05\x04I\x02\x02\x03\x12\x04\xda\x0345\n\x0c\n\x04\x04I\x02\x03\
    \x12\x04\xdb\x03\x08<\n\r\n\x05\x04I\x02\x03\x04\x12\x04\xdb\x03\x08\x10\
    \n\r\n\x05\x04I\x02\x03\x06\x12\x04\xdb\x03\x11)\n\r\n\x05\x04I\x02\x03\
    \x01\x12\x04\xdb\x03*7\n\r\n\x05\x04I\x02\x03\x03\x12\x04\xdb\x03:;\n\
    \x0c\n\x02\x04J\x12\x06\xde\x03\0\xe1\x03\x01\n\x0b\n\x03\x04J\x01\x12\
    \x04\xde\x03\x08)\n\x0c\n\x04\x04J\x02\0\x12\x04\xdf\x03\x08+\n\r\n\x05\
    \x04J\x02\0\x04\x12\x04\xdf\x03\x08\x10\n\r\n\x05\x04J\x02\0\x05\x12\x04\
    \xdf\x03\x11\x16\n\r\n\x05\x04J\x02\0\x01\x12\x04\xdf\x03\x17&\n\r\n\x05\
    \x04J\x02\0\x03\x12\x04\xdf\x03)*\n\x0c\n\x04\x04J\x02\x01\x12\x04\xe0\
    \x03\x08&\n\r\n\x05\x04J\x02\x01\x04\x12\x04\xe0\x03\x08\x10\n\r\n\x05\
    \x04J\x02\x01\x05\x12\x04\xe0\x03\x11\x16\n\r\n\x05\x04J\x02\x01\x01\x12\
    \x04\xe0\x03\x17!\n\r\n\x05\x04J\x02\x01\x03\x12\x04\xe0\x03$%\n\x0c\n\
    \x02\x04K\x12\x06\xe3\x03\0\xe7\x03\x01\n\x0b\n\x03\x04K\x01\x12\x04\xe3\
    \x03\x08/\n\x0c\n\x04\x04K\x02\0\x12\x04\xe4\x03\x08,\n\r\n\x05\x04K\x02\
    \0\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\xe4\x03\
    \x11\x16\n\r\n\x05\x04K\x02\0\x01\x12\x04\xe4\x03\x17'\n\r\n\x05\x04K\
    \x02\0\x03\x12\x04\xe4\x03*+\n\x0c\n\x04\x04K\x02\x01\x12\x04\xe5\x03\
    \x083\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04K\
    \x02\x01\x06\x12\x04\xe5\x03\x11'\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xe5\
    \x03(.\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xe5\x0312\n\x0c\n\x04\x04K\x02\
    \x02\x12\x04\xe6\x03\x08(\n\r\n\x05\x04K\x02\x02\x04\x12\x04\xe6\x03\x08\
    \x10\n\r\n\x05\x04K\x02\x02\x05\x12\x04\xe6\x03\x11\x17\n\r\n\x05\x04K\
    \x02\x02\x01\x12\x04\xe6\x03\x18#\n\r\n\x05\x04K\x02\x02\x03\x12\x04\xe6\
    \x03&'\n\x0c\n\x02\x04L\x12\x06\xe9\x03\0\xeb\x03\x01\n\x0b\n\x03\x04L\
    \x01\x12\x04\xe9\x03\x084\n\x0c\n\x04\x04L\x02\0\x12\x04\xea\x03\x08,\n\
    \r\n\x05\x04L\x02\0\x04\x12\x04\xea\x03\x08\x10\n\r\n\x05\x04L\x02\0\x05\
    \x12\x04\xea\x03\x11\x16\n\r\n\x05\x04L\x02\0\x01\x12\x04\xea\x03\x17'\n\
    \r\n\x05\x04L\x02\0\x03\x12\x04\xea\x03*+\n\x0c\n\x02\x04M\x12\x06\xed\
    \x03\0\xef\x03\x01\n\x0b\n\x03\x04M\x01\x12\x04\xed\x03\x083\n\x0c\n\x04\
    \x04M\x02\0\x12\x04\xee\x03\x08,\n\r\n\x05\x04M\x02\0\x04\x12\x04\xee\
    \x03\x08\x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\xee\x03\x11\x16\n\r\n\x05\
    \x04M\x02\0\x01\x12\x04\xee\x03\x17'\n\r\n\x05\x04M\x02\0\x03\x12\x04\
    \xee\x03*+\n\x0c\n\x02\x04N\x12\x06\xf1\x03\0\xf6\x03\x01\n\x0b\n\x03\
    \x04N\x01\x12\x04\xf1\x03\x08&\n\x0c\n\x04\x04N\x02\0\x12\x04\xf2\x03\
    \x08,\n\r\n\x05\x04N\x02\0\x04\x12\x04\xf2\x03\x08\x10\n\r\n\x05\x04N\
    \x02\0\x05\x12\x04\xf2\x03\x11\x16\n\r\n\x05\x04N\x02\0\x01\x12\x04\xf2\
    \x03\x17'\n\r\n\x05\x04N\x02\0\x03\x12\x04\xf2\x03*+\n\x0c\n\x04\x04N\
    \x02\x01\x12\x04\xf3\x03\x08,\n\r\n\x05\x04N\x02\x01\x04\x12\x04\xf3\x03\
    \x08\x10\n\r\n\x05\x04N\x02\x01\x05\x12\x04\xf3\x03\x11\x16\n\r\n\x05\
    \x04N\x02\x01\x01\x12\x04\xf3\x03\x17'\n\r\n\x05\x04N\x02\x01\x03\x12\
    \x04\xf3\x03*+\n\x0c\n\x04\x04N\x02\x02\x12\x04\xf4\x03\x08+\n\r\n\x05\
    \x04N\x02\x02\x04\x12\x04\xf4\x03\x08\x10\n\r\n\x05\x04N\x02\x02\x05\x12\
    \x04\xf4\x03\x11\x16\n\r\n\x05\x04N\x02\x02\x01\x12\x04\xf4\x03\x17&\n\r\
    \n\x05\x04N\x02\x02\x03\x12\x04\xf4\x03)*\n\x0c\n\x04\x04N\x02\x03\x12\
    \x04\xf5\x03\x08'\n\r\n\x05\x04N\x02\x03\x04\x12\x04\xf5\x03\x08\x10\n\r\
    \n\x05\x04N\x02\x03\x05\x12\x04\xf5\x03\x11\x17\n\r\n\x05\x04N\x02\x03\
    \x01\x12\x04\xf5\x03\x18\"\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xf5\x03%&\
    \n\x0c\n\x02\x04O\x12\x06\xf8\x03\0\x8d\x04\x01\n\x0b\n\x03\x04O\x01\x12\
    \x04\xf8\x03\x08!\n\x0c\n\x04\x04O\x02\0\x12\x04\xf9\x03\x08.\n\r\n\x05\
    \x04O\x02\0\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\
    \xf9\x03\x11\x16\n\r\n\x05\x04O\x02\0\x01\x12\x04\xf9\x03\x17)\n\r\n\x05\
    \x04O\x02\0\x03\x12\x04\xf9\x03,-\n\x0c\n\x04\x04O\x02\x01\x12\x04\xfa\
    \x03\x08*\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xfa\x03\x08\x10\n\r\n\x05\
    \x04O\x02\x01\x05\x12\x04\xfa\x03\x11\x16\n\r\n\x05\x04O\x02\x01\x01\x12\
    \x04\xfa\x03\x17%\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xfa\x03()\n\x0c\n\
    \x04\x04O\x02\x02\x12\x04\xfb\x03\x080\n\r\n\x05\x04O\x02\x02\x04\x12\
    \x04\xfb\x03\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xfb\x03\x11\x16\
    \n\r\n\x05\x04O\x02\x02\x01\x12\x04\xfb\x03\x17+\n\r\n\x05\x04O\x02\x02\
    \x03\x12\x04\xfb\x03./\n\x0c\n\x04\x04O\x02\x03\x12\x04\xfc\x03\x08,\n\r\
    \n\x05\x04O\x02\x03\x04\x12\x04\xfc\x03\x08\x10\n\r\n\x05\x04O\x02\x03\
    \x05\x12\x04\xfc\x03\x11\x16\n\r\n\x05\x04O\x02\x03\x01\x12\x04\xfc\x03\
    \x17'\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xfc\x03*+\n\x0c\n\x04\x04O\x02\
    \x04\x12\x04\xfd\x03\x084\n\r\n\x05\x04O\x02\x04\x04\x12\x04\xfd\x03\x08\
    \x10\n\r\n\x05\x04O\x02\x04\x05\x12\x04\xfd\x03\x11\x16\n\r\n\x05\x04O\
    \x02\x04\x01\x12\x04\xfd\x03\x17/\n\r\n\x05\x04O\x02\x04\x03\x12\x04\xfd\
    \x0323\n\x0c\n\x04\x04O\x02\x05\x12\x04\xfe\x03\x080\n\r\n\x05\x04O\x02\
    \x05\x04\x12\x04\xfe\x03\x08\x10\n\r\n\x05\x04O\x02\x05\x05\x12\x04\xfe\
    \x03\x11\x16\n\r\n\x05\x04O\x02\x05\x01\x12\x04\xfe\x03\x17+\n\r\n\x05\
    \x04O\x02\x05\x03\x12\x04\xfe\x03./\n\x0c\n\x04\x04O\x02\x06\x12\x04\xff\
    \x03\x088\n\r\n\x05\x04O\x02\x06\x04\x12\x04\xff\x03\x08\x10\n\r\n\x05\
    \x04O\x02\x06\x05\x12\x04\xff\x03\x11\x16\n\r\n\x05\x04O\x02\x06\x01\x12\
    \x04\xff\x03\x173\n\r\n\x05\x04O\x02\x06\x03\x12\x04\xff\x0367\n\x0c\n\
    \x04\x04O\x02\x07\x12\x04\x80\x04\x084\n\r\n\x05\x04O\x02\x07\x04\x12\
    \x04\x80\x04\x08\x10\n\r\n\x05\x04O\x02\x07\x05\x12\x04\x80\x04\x11\x16\
    \n\r\n\x05\x04O\x02\x07\x01\x12\x04\x80\x04\x17/\n\r\n\x05\x04O\x02\x07\
    \x03\x12\x04\x80\x0423\n\x0c\n\x04\x04O\x02\x08\x12\x04\x81\x04\x08/\n\r\
    \n\x05\x04O\x02\x08\x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x04O\x02\x08\
    \x05\x12\x04\x81\x04\x11\x16\n\r\n\x05\x04O\x02\x08\x01\x12\x04\x81\x04\
    \x17*\n\r\n\x05\x04O\x02\x08\x03\x12\x04\x81\x04-.\n\x0c\n\x04\x04O\x02\
    \t\x12\x04\x82\x04\x08,\n\r\n\x05\x04O\x02\t\x04\x12\x04\x82\x04\x08\x10\
    \n\r\n\x05\x04O\x02\t\x05\x12\x04\x82\x04\x11\x16\n\r\n\x05\x04O\x02\t\
    \x01\x12\x04\x82\x04\x17&\n\r\n\x05\x04O\x02\t\x03\x12\x04\x82\x04)+\n\
    \x0c\n\x04\x04O\x02\n\x12\x04\x83\x04\x08H\n\r\n\x05\x04O\x02\n\x04\x12\
    \x04\x83\x04\x08\x10\n\r\n\x05\x04O\x02\n\x05\x12\x04\x83\x04\x11\x16\n\
    \r\n\x05\x04O\x02\n\x01\x12\x04\x83\x04\x17B\n\r\n\x05\x04O\x02\n\x03\
    \x12\x04\x83\x04EG\n\x0c\n\x04\x04O\x02\x0b\x12\x04\x84\x04\x08D\n\r\n\
    \x05\x04O\x02\x0b\x04\x12\x04\x84\x04\x08\x10\n\r\n\x05\x04O\x02\x0b\x05\
    \x12\x04\x84\x04\x11\x16\n\r\n\x05\x04O\x02\x0b\x01\x12\x04\x84\x04\x17>\
    \n\r\n\x05\x04O\x02\x0b\x03\x12\x04\x84\x04AC\n\x0c\n\x04\x04O\x02\x0c\
    \x12\x04\x85\x04\x08.\n\r\n\x05\x04O\x02\x0c\x04\x12\x04\x85\x04\x08\x10\
    \n\r\n\x05\x04O\x02\x0c\x05\x12\x04\x85\x04\x11\x16\n\r\n\x05\x04O\x02\
    \x0c\x01\x12\x04\x85\x04\x17(\n\r\n\x05\x04O\x02\x0c\x03\x12\x04\x85\x04\
    +-\n\x0c\n\x04\x04O\x02\r\x12\x04\x86\x04\x08*\n\r\n\x05\x04O\x02\r\x04\
    \x12\x04\x86\x04\x08\x10\n\r\n\x05\x04O\x02\r\x05\x12\x04\x86\x04\x11\
    \x16\n\r\n\x05\x04O\x02\r\x01\x12\x04\x86\x04\x17$\n\r\n\x05\x04O\x02\r\
    \x03\x12\x04\x86\x04')\n\x0c\n\x04\x04O\x02\x0e\x12\x04\x87\x04\x086\n\r\
    \n\x05\x04O\x02\x0e\x04\x12\x04\x87\x04\x08\x10\n\r\n\x05\x04O\x02\x0e\
    \x05\x12\x04\x87\x04\x11\x16\n\r\n\x05\x04O\x02\x0e\x01\x12\x04\x87\x04\
    \x170\n\r\n\x05\x04O\x02\x0e\x03\x12\x04\x87\x0435\n\x0c\n\x04\x04O\x02\
    \x0f\x12\x04\x88\x04\x082\n\r\n\x05\x04O\x02\x0f\x04\x12\x04\x88\x04\x08\
    \x10\n\r\n\x05\x04O\x02\x0f\x05\x12\x04\x88\x04\x11\x16\n\r\n\x05\x04O\
    \x02\x0f\x01\x12\x04\x88\x04\x17,\n\r\n\x05\x04O\x02\x0f\x03\x12\x04\x88\
    \x04/1\n\x0c\n\x04\x04O\x02\x10\x12\x04\x89\x04\x08.\n\r\n\x05\x04O\x02\
    \x10\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04O\x02\x10\x05\x12\x04\x89\
    \x04\x11\x16\n\r\n\x05\x04O\x02\x10\x01\x12\x04\x89\x04\x17(\n\r\n\x05\
    \x04O\x02\x10\x03\x12\x04\x89\x04+-\n\x0c\n\x04\x04O\x02\x11\x12\x04\x8a\
    \x04\x08*\n\r\n\x05\x04O\x02\x11\x04\x12\x04\x8a\x04\x08\x10\n\r\n\x05\
    \x04O\x02\x11\x05\x12\x04\x8a\x04\x11\x16\n\r\n\x05\x04O\x02\x11\x01\x12\
    \x04\x8a\x04\x17$\n\r\n\x05\x04O\x02\x11\x03\x12\x04\x8a\x04')\n\x0c\n\
    \x04\x04O\x02\x12\x12\x04\x8b\x04\x08:\n\r\n\x05\x04O\x02\x12\x04\x12\
    \x04\x8b\x04\x08\x10\n\r\n\x05\x04O\x02\x12\x05\x12\x04\x8b\x04\x11\x16\
    \n\r\n\x05\x04O\x02\x12\x01\x12\x04\x8b\x04\x174\n\r\n\x05\x04O\x02\x12\
    \x03\x12\x04\x8b\x0479\n\x0c\n\x04\x04O\x02\x13\x12\x04\x8c\x04\x086\n\r\
    \n\x05\x04O\x02\x13\x04\x12\x04\x8c\x04\x08\x10\n\r\n\x05\x04O\x02\x13\
    \x05\x12\x04\x8c\x04\x11\x16\n\r\n\x05\x04O\x02\x13\x01\x12\x04\x8c\x04\
    \x170\n\r\n\x05\x04O\x02\x13\x03\x12\x04\x8c\x0435\n\x0c\n\x02\x04P\x12\
    \x06\x8f\x04\0\x94\x04\x01\n\x0b\n\x03\x04P\x01\x12\x04\x8f\x04\x085\n\
    \x0c\n\x04\x04P\x02\0\x12\x04\x90\x04\x08&\n\r\n\x05\x04P\x02\0\x04\x12\
    \x04\x90\x04\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\x90\x04\x11\x15\n\
    \r\n\x05\x04P\x02\0\x01\x12\x04\x90\x04\x16!\n\r\n\x05\x04P\x02\0\x03\
    \x12\x04\x90\x04$%\n\x0c\n\x04\x04P\x02\x01\x12\x04\x91\x04\x08\"\n\r\n\
    \x05\x04P\x02\x01\x04\x12\x04\x91\x04\x08\x10\n\r\n\x05\x04P\x02\x01\x05\
    \x12\x04\x91\x04\x11\x16\n\r\n\x05\x04P\x02\x01\x01\x12\x04\x91\x04\x17\
    \x1d\n\r\n\x05\x04P\x02\x01\x03\x12\x04\x91\x04\x20!\n\x0c\n\x04\x04P\
    \x02\x02\x12\x04\x92\x04\x08/\n\r\n\x05\x04P\x02\x02\x04\x12\x04\x92\x04\
    \x08\x10\n\r\n\x05\x04P\x02\x02\x05\x12\x04\x92\x04\x11\x16\n\r\n\x05\
    \x04P\x02\x02\x01\x12\x04\x92\x04\x17*\n\r\n\x05\x04P\x02\x02\x03\x12\
    \x04\x92\x04-.\n\x0c\n\x04\x04P\x02\x03\x12\x04\x93\x04\x08)\n\r\n\x05\
    \x04P\x02\x03\x04\x12\x04\x93\x04\x08\x10\n\r\n\x05\x04P\x02\x03\x05\x12\
    \x04\x93\x04\x11\x16\n\r\n\x05\x04P\x02\x03\x01\x12\x04\x93\x04\x17$\n\r\
    \n\x05\x04P\x02\x03\x03\x12\x04\x93\x04'(\n\x0c\n\x02\x04Q\x12\x06\x96\
    \x04\0\x98\x04\x01\n\x0b\n\x03\x04Q\x01\x12\x04\x96\x04\x08/\n\x0c\n\x04\
    \x04Q\x02\0\x12\x04\x97\x04\x08H\n\r\n\x05\x04Q\x02\0\x04\x12\x04\x97\
    \x04\x08\x10\n\r\n\x05\x04Q\x02\0\x06\x12\x04\x97\x04\x11>\n\r\n\x05\x04\
    Q\x02\0\x01\x12\x04\x97\x04?C\n\r\n\x05\x04Q\x02\0\x03\x12\x04\x97\x04FG\
    \n\x0c\n\x02\x04R\x12\x06\x9a\x04\0\x9d\x04\x01\n\x0b\n\x03\x04R\x01\x12\
    \x04\x9a\x04\x08\"\n\x0c\n\x04\x04R\x02\0\x12\x04\x9b\x04\x08)\n\r\n\x05\
    \x04R\x02\0\x04\x12\x04\x9b\x04\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\
    \x9b\x04\x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\x9b\x04\x18$\n\r\n\x05\
    \x04R\x02\0\x03\x12\x04\x9b\x04'(\n\x0c\n\x04\x04R\x02\x01\x12\x04\x9c\
    \x04\x08)\n\r\n\x05\x04R\x02\x01\x04\x12\x04\x9c\x04\x08\x10\n\r\n\x05\
    \x04R\x02\x01\x05\x12\x04\x9c\x04\x11\x17\n\r\n\x05\x04R\x02\x01\x01\x12\
    \x04\x9c\x04\x18$\n\r\n\x05\x04R\x02\x01\x03\x12\x04\x9c\x04'(\n\x0c\n\
    \x02\x04S\x12\x06\x9f\x04\0\xa2\x04\x01\n\x0b\n\x03\x04S\x01\x12\x04\x9f\
    \x04\x08#\n\x0c\n\x04\x04S\x02\0\x12\x04\xa0\x04\x080\n\r\n\x05\x04S\x02\
    \0\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04S\x02\0\x05\x12\x04\xa0\x04\
    \x11\x16\n\r\n\x05\x04S\x02\0\x01\x12\x04\xa0\x04\x17+\n\r\n\x05\x04S\
    \x02\0\x03\x12\x04\xa0\x04./\n\x0c\n\x04\x04S\x02\x01\x12\x04\xa1\x04\
    \x08.\n\r\n\x05\x04S\x02\x01\x04\x12\x04\xa1\x04\x08\x10\n\r\n\x05\x04S\
    \x02\x01\x05\x12\x04\xa1\x04\x11\x16\n\r\n\x05\x04S\x02\x01\x01\x12\x04\
    \xa1\x04\x17)\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xa1\x04,-\n\x0c\n\x02\
    \x04T\x12\x06\xa4\x04\0\xa8\x04\x01\n\x0b\n\x03\x04T\x01\x12\x04\xa4\x04\
    \x08(\n\x0c\n\x04\x04T\x02\0\x12\x04\xa5\x04\x08.\n\r\n\x05\x04T\x02\0\
    \x04\x12\x04\xa5\x04\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\xa5\x04\
    \x11\x16\n\r\n\x05\x04T\x02\0\x01\x12\x04\xa5\x04\x17)\n\r\n\x05\x04T\
    \x02\0\x03\x12\x04\xa5\x04,-\n\x0c\n\x04\x04T\x02\x01\x12\x04\xa6\x04\
    \x08+\n\r\n\x05\x04T\x02\x01\x04\x12\x04\xa6\x04\x08\x10\n\r\n\x05\x04T\
    \x02\x01\x05\x12\x04\xa6\x04\x11\x16\n\r\n\x05\x04T\x02\x01\x01\x12\x04\
    \xa6\x04\x17&\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xa6\x04)*\n\x0c\n\x04\
    \x04T\x02\x02\x12\x04\xa7\x04\x08&\n\r\n\x05\x04T\x02\x02\x04\x12\x04\
    \xa7\x04\x08\x10\n\r\n\x05\x04T\x02\x02\x05\x12\x04\xa7\x04\x11\x16\n\r\
    \n\x05\x04T\x02\x02\x01\x12\x04\xa7\x04\x17!\n\r\n\x05\x04T\x02\x02\x03\
    \x12\x04\xa7\x04$%\n\x0c\n\x02\x04U\x12\x06\xaa\x04\0\xac\x04\x01\n\x0b\
    \n\x03\x04U\x01\x12\x04\xaa\x04\x08&\n\x0c\n\x04\x04U\x02\0\x12\x04\xab\
    \x04\x08%\n\r\n\x05\x04U\x02\0\x04\x12\x04\xab\x04\x08\x10\n\r\n\x05\x04\
    U\x02\0\x05\x12\x04\xab\x04\x11\x16\n\r\n\x05\x04U\x02\0\x01\x12\x04\xab\
    \x04\x17\x20\n\r\n\x05\x04U\x02\0\x03\x12\x04\xab\x04#$\n\x0c\n\x02\x04V\
    \x12\x06\xae\x04\0\xb0\x04\x01\n\x0b\n\x03\x04V\x01\x12\x04\xae\x04\x08)\
    \n\x0c\n\x04\x04V\x02\0\x12\x04\xaf\x04\x08%\n\r\n\x05\x04V\x02\0\x04\
    \x12\x04\xaf\x04\x08\x10\n\r\n\x05\x04V\x02\0\x05\x12\x04\xaf\x04\x11\
    \x16\n\r\n\x05\x04V\x02\0\x01\x12\x04\xaf\x04\x17\x20\n\r\n\x05\x04V\x02\
    \0\x03\x12\x04\xaf\x04#$\n\x0c\n\x02\x04W\x12\x06\xb2\x04\0\xb5\x04\x01\
    \n\x0b\n\x03\x04W\x01\x12\x04\xb2\x04\x08,\n\x0c\n\x04\x04W\x02\0\x12\
    \x04\xb3\x04\x08$\n\r\n\x05\x04W\x02\0\x04\x12\x04\xb3\x04\x08\x10\n\r\n\
    \x05\x04W\x02\0\x05\x12\x04\xb3\x04\x11\x16\n\r\n\x05\x04W\x02\0\x01\x12\
    \x04\xb3\x04\x17\x1f\n\r\n\x05\x04W\x02\0\x03\x12\x04\xb3\x04\"#\n\x0c\n\
    \x04\x04W\x02\x01\x12\x04\xb4\x04\x08\"\n\r\n\x05\x04W\x02\x01\x04\x12\
    \x04\xb4\x04\x08\x10\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xb4\x04\x11\x15\
    \n\r\n\x05\x04W\x02\x01\x01\x12\x04\xb4\x04\x16\x1d\n\r\n\x05\x04W\x02\
    \x01\x03\x12\x04\xb4\x04\x20!\n\x0c\n\x02\x04X\x12\x06\xb7\x04\0\xb9\x04\
    \x01\n\x0b\n\x03\x04X\x01\x12\x04\xb7\x04\x08,\n\x0c\n\x04\x04X\x02\0\
    \x12\x04\xb8\x04\x08\x20\n\r\n\x05\x04X\x02\0\x04\x12\x04\xb8\x04\x08\
    \x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xb8\x04\x11\x16\n\r\n\x05\x04X\x02\
    \0\x01\x12\x04\xb8\x04\x17\x1b\n\r\n\x05\x04X\x02\0\x03\x12\x04\xb8\x04\
    \x1e\x1f\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::dota_commonmessages::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(89);
            messages.push(CDOTAClientMsg_MapPing::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ItemAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_EnemyItemAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ModifierAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ClickedBuff::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_HPManaAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_NeutralCampAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_GlyphAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_RadarAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_MapLine::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_AspectRatio::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_UnitsAutoAttackMode::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_UnitsAutoAttackAfterSpell::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_TeleportRequiresHalt::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ChannelRequiresHalt::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SearchString::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_Pause::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ShopViewMode::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SetUnitShareFlag::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SwapRequest::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SwapAccept::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_WorldLine::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_RequestGraphUpdate::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ChatWheel::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SendStatPopup::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_DismissAllStatPopups::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_BeginLastHitChallenge::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_UpdateQuickBuyItem::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_UpdateQuickBuy::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_RecordVote::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_WillPurchaseAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_BuyBackStateAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_QuickBuyAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PlayerShowCase::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_CameraZoomAmount::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_BroadcasterUsingCameraman::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_FillEmptySlotsWithBots::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_HeroStatueLike::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_EventCNY2015Cmd::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_DemoHero::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ChallengeSelect::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ChallengeReroll::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_CoinWager::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_CoinWagerToken::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_RankWager::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PlayerBounty::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_EventPointsTip::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ExecuteOrders::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_XPAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_TalentTreeAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_KillcamDamageTaken::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_KillMyHero::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_QuestStatus::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ToggleAutoattack::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SpecialAbility::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SetEnemyStartingPosition::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SetDesiredWardPlacement::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_RollDice::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_FlipCoin::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_RequestItemSuggestions::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_MakeTeamCaptain::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_HelpTipSystemStateChanged::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_RequestBulkCombatLog::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_AbilityDraftRequestAbility::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_GuideSelectOption::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_GuideSelected::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_DamageReport::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SalutePlayer::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_TipAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_EmptyTeleportAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_SetCavernMapVariant::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PauseGameOrder::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_VersusScene_PlayerBehavior::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_EmptyItemSlotAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_AddOverwatchReportMarker::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_AddCommunicationsReportMarker::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_AddCommunicationsBlockMarker::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_AghsStatusAlert::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PerfReport::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ContextualTips_Subscribe_Entry::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ContextualTips_Subscribe::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ChatMessage::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_DuelAccepted::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_ChooseNeutralItem::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PlayerDraftPick::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PlayerDraftSuggest::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PlayerDraftPreferRole::generated_message_descriptor_data());
            messages.push(CDOTAClientMsg_PlayerDraftPreferTeam::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(EDotaClientMessages::generated_enum_descriptor_data());
            enums.push(cdotaclient_msg_units_auto_attack_mode::EMode::generated_enum_descriptor_data());
            enums.push(cdotaclient_msg_units_auto_attack_mode::EUnitType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
