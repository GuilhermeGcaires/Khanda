// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_coaching.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgPlayerCoachMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerCoachMatch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerCoachMatch.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerCoachMatch.match_outcome)
    pub match_outcome: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerCoachMatch.coached_team)
    pub coached_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerCoachMatch.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerCoachMatch.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerCoachMatch.teammate_ratings)
    pub teammate_ratings: ::std::vec::Vec<::protobuf::EnumOrUnknown<ECoachTeammateRating>>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerCoachMatch.coach_flags)
    pub coach_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerCoachMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerCoachMatch {
    fn default() -> &'a CMsgPlayerCoachMatch {
        <CMsgPlayerCoachMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerCoachMatch {
    pub fn new() -> CMsgPlayerCoachMatch {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EMatchOutcome match_outcome = 2;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 coached_team = 3;

    pub fn coached_team(&self) -> u32 {
        self.coached_team.unwrap_or(0)
    }

    pub fn clear_coached_team(&mut self) {
        self.coached_team = ::std::option::Option::None;
    }

    pub fn has_coached_team(&self) -> bool {
        self.coached_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coached_team(&mut self, v: u32) {
        self.coached_team = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 4;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 5;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 coach_flags = 7;

    pub fn coach_flags(&self) -> u32 {
        self.coach_flags.unwrap_or(0)
    }

    pub fn clear_coach_flags(&mut self) {
        self.coach_flags = ::std::option::Option::None;
    }

    pub fn has_coach_flags(&self) -> bool {
        self.coach_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_flags(&mut self, v: u32) {
        self.coach_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgPlayerCoachMatch| { &m.match_id },
            |m: &mut CMsgPlayerCoachMatch| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_outcome",
            |m: &CMsgPlayerCoachMatch| { &m.match_outcome },
            |m: &mut CMsgPlayerCoachMatch| { &mut m.match_outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coached_team",
            |m: &CMsgPlayerCoachMatch| { &m.coached_team },
            |m: &mut CMsgPlayerCoachMatch| { &mut m.coached_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgPlayerCoachMatch| { &m.start_time },
            |m: &mut CMsgPlayerCoachMatch| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgPlayerCoachMatch| { &m.duration },
            |m: &mut CMsgPlayerCoachMatch| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teammate_ratings",
            |m: &CMsgPlayerCoachMatch| { &m.teammate_ratings },
            |m: &mut CMsgPlayerCoachMatch| { &mut m.teammate_ratings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_flags",
            |m: &CMsgPlayerCoachMatch| { &m.coach_flags },
            |m: &mut CMsgPlayerCoachMatch| { &mut m.coach_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerCoachMatch>(
            "CMsgPlayerCoachMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerCoachMatch {
    const NAME: &'static str = "CMsgPlayerCoachMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.coached_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.start_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.teammate_ratings.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.teammate_ratings)?
                },
                56 => {
                    self.coach_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.match_outcome {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.coached_team {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.teammate_ratings {
            my_size += ::protobuf::rt::int32_size(6, value.value());
        };
        if let Some(v) = self.coach_flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.coached_team {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(5, v)?;
        }
        for v in &self.teammate_ratings {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.coach_flags {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerCoachMatch {
        CMsgPlayerCoachMatch::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.coached_team = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.teammate_ratings.clear();
        self.coach_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerCoachMatch {
        static instance: CMsgPlayerCoachMatch = CMsgPlayerCoachMatch {
            match_id: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            coached_team: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            teammate_ratings: ::std::vec::Vec::new(),
            coach_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerCoachMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerCoachMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerCoachMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerCoachMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPrivateCoachingSessionMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPrivateCoachingSessionMember {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSessionMember.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSessionMember.member_flags)
    pub member_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSessionMember.member_session_rating)
    pub member_session_rating: ::std::option::Option<::protobuf::EnumOrUnknown<ECoachTeammateRating>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPrivateCoachingSessionMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPrivateCoachingSessionMember {
    fn default() -> &'a CMsgPrivateCoachingSessionMember {
        <CMsgPrivateCoachingSessionMember as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPrivateCoachingSessionMember {
    pub fn new() -> CMsgPrivateCoachingSessionMember {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 member_flags = 2;

    pub fn member_flags(&self) -> u32 {
        self.member_flags.unwrap_or(0)
    }

    pub fn clear_member_flags(&mut self) {
        self.member_flags = ::std::option::Option::None;
    }

    pub fn has_member_flags(&self) -> bool {
        self.member_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_flags(&mut self, v: u32) {
        self.member_flags = ::std::option::Option::Some(v);
    }

    // optional .dota.ECoachTeammateRating member_session_rating = 3;

    pub fn member_session_rating(&self) -> ECoachTeammateRating {
        match self.member_session_rating {
            Some(e) => e.enum_value_or(ECoachTeammateRating::k_ECoachTeammateRating_None),
            None => ECoachTeammateRating::k_ECoachTeammateRating_None,
        }
    }

    pub fn clear_member_session_rating(&mut self) {
        self.member_session_rating = ::std::option::Option::None;
    }

    pub fn has_member_session_rating(&self) -> bool {
        self.member_session_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_session_rating(&mut self, v: ECoachTeammateRating) {
        self.member_session_rating = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgPrivateCoachingSessionMember| { &m.account_id },
            |m: &mut CMsgPrivateCoachingSessionMember| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_flags",
            |m: &CMsgPrivateCoachingSessionMember| { &m.member_flags },
            |m: &mut CMsgPrivateCoachingSessionMember| { &mut m.member_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "member_session_rating",
            |m: &CMsgPrivateCoachingSessionMember| { &m.member_session_rating },
            |m: &mut CMsgPrivateCoachingSessionMember| { &mut m.member_session_rating },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPrivateCoachingSessionMember>(
            "CMsgPrivateCoachingSessionMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPrivateCoachingSessionMember {
    const NAME: &'static str = "CMsgPrivateCoachingSessionMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.member_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.member_session_rating = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.member_flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.member_session_rating {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.member_flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.member_session_rating {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPrivateCoachingSessionMember {
        CMsgPrivateCoachingSessionMember::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.member_flags = ::std::option::Option::None;
        self.member_session_rating = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPrivateCoachingSessionMember {
        static instance: CMsgPrivateCoachingSessionMember = CMsgPrivateCoachingSessionMember {
            account_id: ::std::option::Option::None,
            member_flags: ::std::option::Option::None,
            member_session_rating: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPrivateCoachingSessionMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPrivateCoachingSessionMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPrivateCoachingSessionMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPrivateCoachingSessionMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPrivateCoachingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPrivateCoachingSession {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.private_coaching_session_id)
    pub private_coaching_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.requested_timestamp)
    pub requested_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.requested_language)
    pub requested_language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.coaching_session_state)
    pub coaching_session_state: ::std::option::Option<::protobuf::EnumOrUnknown<EPrivateCoachingSessionState>>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.session_members)
    pub session_members: ::std::vec::Vec<CMsgPrivateCoachingSessionMember>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.current_lobby_id)
    pub current_lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.current_server_steam_id)
    pub current_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.accepted_timestamp)
    pub accepted_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSession.completed_timestamp)
    pub completed_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPrivateCoachingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPrivateCoachingSession {
    fn default() -> &'a CMsgPrivateCoachingSession {
        <CMsgPrivateCoachingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPrivateCoachingSession {
    pub fn new() -> CMsgPrivateCoachingSession {
        ::std::default::Default::default()
    }

    // optional uint64 private_coaching_session_id = 1;

    pub fn private_coaching_session_id(&self) -> u64 {
        self.private_coaching_session_id.unwrap_or(0)
    }

    pub fn clear_private_coaching_session_id(&mut self) {
        self.private_coaching_session_id = ::std::option::Option::None;
    }

    pub fn has_private_coaching_session_id(&self) -> bool {
        self.private_coaching_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_coaching_session_id(&mut self, v: u64) {
        self.private_coaching_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 requested_timestamp = 2;

    pub fn requested_timestamp(&self) -> u32 {
        self.requested_timestamp.unwrap_or(0)
    }

    pub fn clear_requested_timestamp(&mut self) {
        self.requested_timestamp = ::std::option::Option::None;
    }

    pub fn has_requested_timestamp(&self) -> bool {
        self.requested_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_timestamp(&mut self, v: u32) {
        self.requested_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 requested_language = 3;

    pub fn requested_language(&self) -> u32 {
        self.requested_language.unwrap_or(0)
    }

    pub fn clear_requested_language(&mut self) {
        self.requested_language = ::std::option::Option::None;
    }

    pub fn has_requested_language(&self) -> bool {
        self.requested_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_language(&mut self, v: u32) {
        self.requested_language = ::std::option::Option::Some(v);
    }

    // optional .dota.EPrivateCoachingSessionState coaching_session_state = 4;

    pub fn coaching_session_state(&self) -> EPrivateCoachingSessionState {
        match self.coaching_session_state {
            Some(e) => e.enum_value_or(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Invalid),
            None => EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Invalid,
        }
    }

    pub fn clear_coaching_session_state(&mut self) {
        self.coaching_session_state = ::std::option::Option::None;
    }

    pub fn has_coaching_session_state(&self) -> bool {
        self.coaching_session_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coaching_session_state(&mut self, v: EPrivateCoachingSessionState) {
        self.coaching_session_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 current_lobby_id = 6;

    pub fn current_lobby_id(&self) -> u64 {
        self.current_lobby_id.unwrap_or(0)
    }

    pub fn clear_current_lobby_id(&mut self) {
        self.current_lobby_id = ::std::option::Option::None;
    }

    pub fn has_current_lobby_id(&self) -> bool {
        self.current_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_lobby_id(&mut self, v: u64) {
        self.current_lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 current_server_steam_id = 7;

    pub fn current_server_steam_id(&self) -> u64 {
        self.current_server_steam_id.unwrap_or(0)
    }

    pub fn clear_current_server_steam_id(&mut self) {
        self.current_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_current_server_steam_id(&self) -> bool {
        self.current_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_server_steam_id(&mut self, v: u64) {
        self.current_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 accepted_timestamp = 8;

    pub fn accepted_timestamp(&self) -> u32 {
        self.accepted_timestamp.unwrap_or(0)
    }

    pub fn clear_accepted_timestamp(&mut self) {
        self.accepted_timestamp = ::std::option::Option::None;
    }

    pub fn has_accepted_timestamp(&self) -> bool {
        self.accepted_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accepted_timestamp(&mut self, v: u32) {
        self.accepted_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 completed_timestamp = 9;

    pub fn completed_timestamp(&self) -> u32 {
        self.completed_timestamp.unwrap_or(0)
    }

    pub fn clear_completed_timestamp(&mut self) {
        self.completed_timestamp = ::std::option::Option::None;
    }

    pub fn has_completed_timestamp(&self) -> bool {
        self.completed_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_timestamp(&mut self, v: u32) {
        self.completed_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "private_coaching_session_id",
            |m: &CMsgPrivateCoachingSession| { &m.private_coaching_session_id },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.private_coaching_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requested_timestamp",
            |m: &CMsgPrivateCoachingSession| { &m.requested_timestamp },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.requested_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requested_language",
            |m: &CMsgPrivateCoachingSession| { &m.requested_language },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.requested_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coaching_session_state",
            |m: &CMsgPrivateCoachingSession| { &m.coaching_session_state },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.coaching_session_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session_members",
            |m: &CMsgPrivateCoachingSession| { &m.session_members },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.session_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_lobby_id",
            |m: &CMsgPrivateCoachingSession| { &m.current_lobby_id },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.current_lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_server_steam_id",
            |m: &CMsgPrivateCoachingSession| { &m.current_server_steam_id },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.current_server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accepted_timestamp",
            |m: &CMsgPrivateCoachingSession| { &m.accepted_timestamp },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.accepted_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "completed_timestamp",
            |m: &CMsgPrivateCoachingSession| { &m.completed_timestamp },
            |m: &mut CMsgPrivateCoachingSession| { &mut m.completed_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPrivateCoachingSession>(
            "CMsgPrivateCoachingSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPrivateCoachingSession {
    const NAME: &'static str = "CMsgPrivateCoachingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.private_coaching_session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.requested_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.requested_language = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.coaching_session_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.session_members.push(is.read_message()?);
                },
                48 => {
                    self.current_lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.current_server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                69 => {
                    self.accepted_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                77 => {
                    self.completed_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.private_coaching_session_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.requested_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.requested_language {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.coaching_session_state {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.session_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.current_lobby_id {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.current_server_steam_id {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.accepted_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.completed_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.private_coaching_session_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requested_timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.requested_language {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.coaching_session_state {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.session_members {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.current_lobby_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.current_server_steam_id {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.accepted_timestamp {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.completed_timestamp {
            os.write_fixed32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPrivateCoachingSession {
        CMsgPrivateCoachingSession::new()
    }

    fn clear(&mut self) {
        self.private_coaching_session_id = ::std::option::Option::None;
        self.requested_timestamp = ::std::option::Option::None;
        self.requested_language = ::std::option::Option::None;
        self.coaching_session_state = ::std::option::Option::None;
        self.session_members.clear();
        self.current_lobby_id = ::std::option::Option::None;
        self.current_server_steam_id = ::std::option::Option::None;
        self.accepted_timestamp = ::std::option::Option::None;
        self.completed_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPrivateCoachingSession {
        static instance: CMsgPrivateCoachingSession = CMsgPrivateCoachingSession {
            private_coaching_session_id: ::std::option::Option::None,
            requested_timestamp: ::std::option::Option::None,
            requested_language: ::std::option::Option::None,
            coaching_session_state: ::std::option::Option::None,
            session_members: ::std::vec::Vec::new(),
            current_lobby_id: ::std::option::Option::None,
            current_server_steam_id: ::std::option::Option::None,
            accepted_timestamp: ::std::option::Option::None,
            completed_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPrivateCoachingSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPrivateCoachingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPrivateCoachingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPrivateCoachingSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPrivateCoachingSessionStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPrivateCoachingSessionStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSessionStatus.requester_competitive_rank_tier)
    pub requester_competitive_rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPrivateCoachingSessionStatus.requester_games_played)
    pub requester_games_played: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPrivateCoachingSessionStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPrivateCoachingSessionStatus {
    fn default() -> &'a CMsgPrivateCoachingSessionStatus {
        <CMsgPrivateCoachingSessionStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPrivateCoachingSessionStatus {
    pub fn new() -> CMsgPrivateCoachingSessionStatus {
        ::std::default::Default::default()
    }

    // optional uint32 requester_competitive_rank_tier = 1;

    pub fn requester_competitive_rank_tier(&self) -> u32 {
        self.requester_competitive_rank_tier.unwrap_or(0)
    }

    pub fn clear_requester_competitive_rank_tier(&mut self) {
        self.requester_competitive_rank_tier = ::std::option::Option::None;
    }

    pub fn has_requester_competitive_rank_tier(&self) -> bool {
        self.requester_competitive_rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_competitive_rank_tier(&mut self, v: u32) {
        self.requester_competitive_rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 requester_games_played = 2;

    pub fn requester_games_played(&self) -> u32 {
        self.requester_games_played.unwrap_or(0)
    }

    pub fn clear_requester_games_played(&mut self) {
        self.requester_games_played = ::std::option::Option::None;
    }

    pub fn has_requester_games_played(&self) -> bool {
        self.requester_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_games_played(&mut self, v: u32) {
        self.requester_games_played = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requester_competitive_rank_tier",
            |m: &CMsgPrivateCoachingSessionStatus| { &m.requester_competitive_rank_tier },
            |m: &mut CMsgPrivateCoachingSessionStatus| { &mut m.requester_competitive_rank_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requester_games_played",
            |m: &CMsgPrivateCoachingSessionStatus| { &m.requester_games_played },
            |m: &mut CMsgPrivateCoachingSessionStatus| { &mut m.requester_games_played },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPrivateCoachingSessionStatus>(
            "CMsgPrivateCoachingSessionStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPrivateCoachingSessionStatus {
    const NAME: &'static str = "CMsgPrivateCoachingSessionStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.requester_competitive_rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.requester_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requester_competitive_rank_tier {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.requester_games_played {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.requester_competitive_rank_tier {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.requester_games_played {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPrivateCoachingSessionStatus {
        CMsgPrivateCoachingSessionStatus::new()
    }

    fn clear(&mut self) {
        self.requester_competitive_rank_tier = ::std::option::Option::None;
        self.requester_games_played = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPrivateCoachingSessionStatus {
        static instance: CMsgPrivateCoachingSessionStatus = CMsgPrivateCoachingSessionStatus {
            requester_competitive_rank_tier: ::std::option::Option::None,
            requester_games_played: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPrivateCoachingSessionStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPrivateCoachingSessionStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPrivateCoachingSessionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPrivateCoachingSessionStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAvailablePrivateCoachingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAvailablePrivateCoachingSession {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAvailablePrivateCoachingSession.coaching_session)
    pub coaching_session: ::protobuf::MessageField<CMsgPrivateCoachingSession>,
    // @@protoc_insertion_point(field:dota.CMsgAvailablePrivateCoachingSession.coaching_session_status)
    pub coaching_session_status: ::protobuf::MessageField<CMsgPrivateCoachingSessionStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAvailablePrivateCoachingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAvailablePrivateCoachingSession {
    fn default() -> &'a CMsgAvailablePrivateCoachingSession {
        <CMsgAvailablePrivateCoachingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAvailablePrivateCoachingSession {
    pub fn new() -> CMsgAvailablePrivateCoachingSession {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPrivateCoachingSession>(
            "coaching_session",
            |m: &CMsgAvailablePrivateCoachingSession| { &m.coaching_session },
            |m: &mut CMsgAvailablePrivateCoachingSession| { &mut m.coaching_session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPrivateCoachingSessionStatus>(
            "coaching_session_status",
            |m: &CMsgAvailablePrivateCoachingSession| { &m.coaching_session_status },
            |m: &mut CMsgAvailablePrivateCoachingSession| { &mut m.coaching_session_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAvailablePrivateCoachingSession>(
            "CMsgAvailablePrivateCoachingSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAvailablePrivateCoachingSession {
    const NAME: &'static str = "CMsgAvailablePrivateCoachingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coaching_session)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coaching_session_status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coaching_session.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.coaching_session_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coaching_session.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.coaching_session_status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAvailablePrivateCoachingSession {
        CMsgAvailablePrivateCoachingSession::new()
    }

    fn clear(&mut self) {
        self.coaching_session.clear();
        self.coaching_session_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAvailablePrivateCoachingSession {
        static instance: CMsgAvailablePrivateCoachingSession = CMsgAvailablePrivateCoachingSession {
            coaching_session: ::protobuf::MessageField::none(),
            coaching_session_status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAvailablePrivateCoachingSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAvailablePrivateCoachingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAvailablePrivateCoachingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAvailablePrivateCoachingSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAvailablePrivateCoachingSessionList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAvailablePrivateCoachingSessionList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAvailablePrivateCoachingSessionList.available_coaching_sessions)
    pub available_coaching_sessions: ::std::vec::Vec<CMsgAvailablePrivateCoachingSession>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAvailablePrivateCoachingSessionList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAvailablePrivateCoachingSessionList {
    fn default() -> &'a CMsgAvailablePrivateCoachingSessionList {
        <CMsgAvailablePrivateCoachingSessionList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAvailablePrivateCoachingSessionList {
    pub fn new() -> CMsgAvailablePrivateCoachingSessionList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "available_coaching_sessions",
            |m: &CMsgAvailablePrivateCoachingSessionList| { &m.available_coaching_sessions },
            |m: &mut CMsgAvailablePrivateCoachingSessionList| { &mut m.available_coaching_sessions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAvailablePrivateCoachingSessionList>(
            "CMsgAvailablePrivateCoachingSessionList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAvailablePrivateCoachingSessionList {
    const NAME: &'static str = "CMsgAvailablePrivateCoachingSessionList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.available_coaching_sessions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.available_coaching_sessions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.available_coaching_sessions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAvailablePrivateCoachingSessionList {
        CMsgAvailablePrivateCoachingSessionList::new()
    }

    fn clear(&mut self) {
        self.available_coaching_sessions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAvailablePrivateCoachingSessionList {
        static instance: CMsgAvailablePrivateCoachingSessionList = CMsgAvailablePrivateCoachingSessionList {
            available_coaching_sessions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAvailablePrivateCoachingSessionList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAvailablePrivateCoachingSessionList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAvailablePrivateCoachingSessionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAvailablePrivateCoachingSessionList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAvailablePrivateCoachingSessionSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAvailablePrivateCoachingSessionSummary {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAvailablePrivateCoachingSessionSummary.coaching_session_count)
    pub coaching_session_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAvailablePrivateCoachingSessionSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAvailablePrivateCoachingSessionSummary {
    fn default() -> &'a CMsgAvailablePrivateCoachingSessionSummary {
        <CMsgAvailablePrivateCoachingSessionSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAvailablePrivateCoachingSessionSummary {
    pub fn new() -> CMsgAvailablePrivateCoachingSessionSummary {
        ::std::default::Default::default()
    }

    // optional uint32 coaching_session_count = 1;

    pub fn coaching_session_count(&self) -> u32 {
        self.coaching_session_count.unwrap_or(0)
    }

    pub fn clear_coaching_session_count(&mut self) {
        self.coaching_session_count = ::std::option::Option::None;
    }

    pub fn has_coaching_session_count(&self) -> bool {
        self.coaching_session_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coaching_session_count(&mut self, v: u32) {
        self.coaching_session_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coaching_session_count",
            |m: &CMsgAvailablePrivateCoachingSessionSummary| { &m.coaching_session_count },
            |m: &mut CMsgAvailablePrivateCoachingSessionSummary| { &mut m.coaching_session_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAvailablePrivateCoachingSessionSummary>(
            "CMsgAvailablePrivateCoachingSessionSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAvailablePrivateCoachingSessionSummary {
    const NAME: &'static str = "CMsgAvailablePrivateCoachingSessionSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coaching_session_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coaching_session_count {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coaching_session_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAvailablePrivateCoachingSessionSummary {
        CMsgAvailablePrivateCoachingSessionSummary::new()
    }

    fn clear(&mut self) {
        self.coaching_session_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAvailablePrivateCoachingSessionSummary {
        static instance: CMsgAvailablePrivateCoachingSessionSummary = CMsgAvailablePrivateCoachingSessionSummary {
            coaching_session_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAvailablePrivateCoachingSessionSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAvailablePrivateCoachingSessionSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAvailablePrivateCoachingSessionSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAvailablePrivateCoachingSessionSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestPlayerCoachMatches)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerCoachMatches {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestPlayerCoachMatches.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerCoachMatches {
    fn default() -> &'a CMsgClientToGCRequestPlayerCoachMatches {
        <CMsgClientToGCRequestPlayerCoachMatches as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerCoachMatches {
    pub fn new() -> CMsgClientToGCRequestPlayerCoachMatches {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestPlayerCoachMatches>(
            "CMsgClientToGCRequestPlayerCoachMatches",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestPlayerCoachMatches {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerCoachMatches";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerCoachMatches {
        CMsgClientToGCRequestPlayerCoachMatches::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerCoachMatches {
        static instance: CMsgClientToGCRequestPlayerCoachMatches = CMsgClientToGCRequestPlayerCoachMatches {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestPlayerCoachMatches {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestPlayerCoachMatches").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestPlayerCoachMatches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestPlayerCoachMatches {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerCoachMatchesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_player_coach_matches_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.coach_matches)
    pub coach_matches: ::std::vec::Vec<CMsgPlayerCoachMatch>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerCoachMatchesResponse {
    fn default() -> &'a CMsgClientToGCRequestPlayerCoachMatchesResponse {
        <CMsgClientToGCRequestPlayerCoachMatchesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerCoachMatchesResponse {
    pub fn new() -> CMsgClientToGCRequestPlayerCoachMatchesResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_player_coach_matches_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_player_coach_matches_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_player_coach_matches_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_player_coach_matches_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestPlayerCoachMatchesResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestPlayerCoachMatchesResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coach_matches",
            |m: &CMsgClientToGCRequestPlayerCoachMatchesResponse| { &m.coach_matches },
            |m: &mut CMsgClientToGCRequestPlayerCoachMatchesResponse| { &mut m.coach_matches },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestPlayerCoachMatchesResponse>(
            "CMsgClientToGCRequestPlayerCoachMatchesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestPlayerCoachMatchesResponse {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerCoachMatchesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.coach_matches.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.coach_matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.coach_matches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerCoachMatchesResponse {
        CMsgClientToGCRequestPlayerCoachMatchesResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.coach_matches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerCoachMatchesResponse {
        static instance: CMsgClientToGCRequestPlayerCoachMatchesResponse = CMsgClientToGCRequestPlayerCoachMatchesResponse {
            result: ::std::option::Option::None,
            coach_matches: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestPlayerCoachMatchesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestPlayerCoachMatchesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestPlayerCoachMatchesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestPlayerCoachMatchesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestPlayerCoachMatchesResponse`
pub mod cmsg_client_to_gcrequest_player_coach_matches_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestPlayerCoachMatchesResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestPlayerCoachMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerCoachMatch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPlayerCoachMatch.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestPlayerCoachMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerCoachMatch {
    fn default() -> &'a CMsgClientToGCRequestPlayerCoachMatch {
        <CMsgClientToGCRequestPlayerCoachMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerCoachMatch {
    pub fn new() -> CMsgClientToGCRequestPlayerCoachMatch {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgClientToGCRequestPlayerCoachMatch| { &m.match_id },
            |m: &mut CMsgClientToGCRequestPlayerCoachMatch| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestPlayerCoachMatch>(
            "CMsgClientToGCRequestPlayerCoachMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestPlayerCoachMatch {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerCoachMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerCoachMatch {
        CMsgClientToGCRequestPlayerCoachMatch::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerCoachMatch {
        static instance: CMsgClientToGCRequestPlayerCoachMatch = CMsgClientToGCRequestPlayerCoachMatch {
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestPlayerCoachMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestPlayerCoachMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestPlayerCoachMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestPlayerCoachMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestPlayerCoachMatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerCoachMatchResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_player_coach_match_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.coach_match)
    pub coach_match: ::protobuf::MessageField<CMsgPlayerCoachMatch>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerCoachMatchResponse {
    fn default() -> &'a CMsgClientToGCRequestPlayerCoachMatchResponse {
        <CMsgClientToGCRequestPlayerCoachMatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerCoachMatchResponse {
    pub fn new() -> CMsgClientToGCRequestPlayerCoachMatchResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_player_coach_match_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_player_coach_match_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_player_coach_match_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_player_coach_match_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestPlayerCoachMatchResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestPlayerCoachMatchResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerCoachMatch>(
            "coach_match",
            |m: &CMsgClientToGCRequestPlayerCoachMatchResponse| { &m.coach_match },
            |m: &mut CMsgClientToGCRequestPlayerCoachMatchResponse| { &mut m.coach_match },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestPlayerCoachMatchResponse>(
            "CMsgClientToGCRequestPlayerCoachMatchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestPlayerCoachMatchResponse {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerCoachMatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coach_match)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.coach_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.coach_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerCoachMatchResponse {
        CMsgClientToGCRequestPlayerCoachMatchResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.coach_match.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerCoachMatchResponse {
        static instance: CMsgClientToGCRequestPlayerCoachMatchResponse = CMsgClientToGCRequestPlayerCoachMatchResponse {
            result: ::std::option::Option::None,
            coach_match: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestPlayerCoachMatchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestPlayerCoachMatchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestPlayerCoachMatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestPlayerCoachMatchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestPlayerCoachMatchResponse`
pub mod cmsg_client_to_gcrequest_player_coach_match_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestPlayerCoachMatchResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSubmitCoachTeammateRating)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitCoachTeammateRating {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitCoachTeammateRating.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitCoachTeammateRating.coach_account_id)
    pub coach_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitCoachTeammateRating.rating)
    pub rating: ::std::option::Option<::protobuf::EnumOrUnknown<ECoachTeammateRating>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitCoachTeammateRating.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSubmitCoachTeammateRating.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitCoachTeammateRating {
    fn default() -> &'a CMsgClientToGCSubmitCoachTeammateRating {
        <CMsgClientToGCSubmitCoachTeammateRating as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitCoachTeammateRating {
    pub fn new() -> CMsgClientToGCSubmitCoachTeammateRating {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 coach_account_id = 2;

    pub fn coach_account_id(&self) -> u32 {
        self.coach_account_id.unwrap_or(0)
    }

    pub fn clear_coach_account_id(&mut self) {
        self.coach_account_id = ::std::option::Option::None;
    }

    pub fn has_coach_account_id(&self) -> bool {
        self.coach_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_account_id(&mut self, v: u32) {
        self.coach_account_id = ::std::option::Option::Some(v);
    }

    // optional .dota.ECoachTeammateRating rating = 3;

    pub fn rating(&self) -> ECoachTeammateRating {
        match self.rating {
            Some(e) => e.enum_value_or(ECoachTeammateRating::k_ECoachTeammateRating_None),
            None => ECoachTeammateRating::k_ECoachTeammateRating_None,
        }
    }

    pub fn clear_rating(&mut self) {
        self.rating = ::std::option::Option::None;
    }

    pub fn has_rating(&self) -> bool {
        self.rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating(&mut self, v: ECoachTeammateRating) {
        self.rating = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgClientToGCSubmitCoachTeammateRating| { &m.match_id },
            |m: &mut CMsgClientToGCSubmitCoachTeammateRating| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_account_id",
            |m: &CMsgClientToGCSubmitCoachTeammateRating| { &m.coach_account_id },
            |m: &mut CMsgClientToGCSubmitCoachTeammateRating| { &mut m.coach_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rating",
            |m: &CMsgClientToGCSubmitCoachTeammateRating| { &m.rating },
            |m: &mut CMsgClientToGCSubmitCoachTeammateRating| { &mut m.rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgClientToGCSubmitCoachTeammateRating| { &m.reason },
            |m: &mut CMsgClientToGCSubmitCoachTeammateRating| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSubmitCoachTeammateRating>(
            "CMsgClientToGCSubmitCoachTeammateRating",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSubmitCoachTeammateRating {
    const NAME: &'static str = "CMsgClientToGCSubmitCoachTeammateRating";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.coach_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rating = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.coach_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rating {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.coach_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rating {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitCoachTeammateRating {
        CMsgClientToGCSubmitCoachTeammateRating::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.coach_account_id = ::std::option::Option::None;
        self.rating = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitCoachTeammateRating {
        static instance: CMsgClientToGCSubmitCoachTeammateRating = CMsgClientToGCSubmitCoachTeammateRating {
            match_id: ::std::option::Option::None,
            coach_account_id: ::std::option::Option::None,
            rating: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSubmitCoachTeammateRating {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSubmitCoachTeammateRating").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSubmitCoachTeammateRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSubmitCoachTeammateRating {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitCoachTeammateRatingResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcsubmit_coach_teammate_rating_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitCoachTeammateRatingResponse {
    fn default() -> &'a CMsgClientToGCSubmitCoachTeammateRatingResponse {
        <CMsgClientToGCSubmitCoachTeammateRatingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitCoachTeammateRatingResponse {
    pub fn new() -> CMsgClientToGCSubmitCoachTeammateRatingResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcsubmit_coach_teammate_rating_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcsubmit_coach_teammate_rating_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcsubmit_coach_teammate_rating_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcsubmit_coach_teammate_rating_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCSubmitCoachTeammateRatingResponse| { &m.result },
            |m: &mut CMsgClientToGCSubmitCoachTeammateRatingResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSubmitCoachTeammateRatingResponse>(
            "CMsgClientToGCSubmitCoachTeammateRatingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSubmitCoachTeammateRatingResponse {
    const NAME: &'static str = "CMsgClientToGCSubmitCoachTeammateRatingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitCoachTeammateRatingResponse {
        CMsgClientToGCSubmitCoachTeammateRatingResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitCoachTeammateRatingResponse {
        static instance: CMsgClientToGCSubmitCoachTeammateRatingResponse = CMsgClientToGCSubmitCoachTeammateRatingResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSubmitCoachTeammateRatingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSubmitCoachTeammateRatingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSubmitCoachTeammateRatingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSubmitCoachTeammateRatingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCSubmitCoachTeammateRatingResponse`
pub mod cmsg_client_to_gcsubmit_coach_teammate_rating_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eInvalidInput)
        k_eInvalidInput = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eAlreadySubmitted)
        k_eAlreadySubmitted = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eVotingFinished)
        k_eVotingFinished = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_ePlayerNotInMatch)
        k_ePlayerNotInMatch = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eCoachNotInMatch)
        k_eCoachNotInMatch = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_ePlayerNotOnCoachTeam)
        k_ePlayerNotOnCoachTeam = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_ePlayerInSamePartyAsCoach)
        k_ePlayerInSamePartyAsCoach = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse.k_eMatchNotEligible)
        k_eMatchNotEligible = 11,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eInvalidInput),
                5 => ::std::option::Option::Some(EResponse::k_eAlreadySubmitted),
                6 => ::std::option::Option::Some(EResponse::k_eVotingFinished),
                7 => ::std::option::Option::Some(EResponse::k_ePlayerNotInMatch),
                8 => ::std::option::Option::Some(EResponse::k_eCoachNotInMatch),
                9 => ::std::option::Option::Some(EResponse::k_ePlayerNotOnCoachTeam),
                10 => ::std::option::Option::Some(EResponse::k_ePlayerInSamePartyAsCoach),
                11 => ::std::option::Option::Some(EResponse::k_eMatchNotEligible),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eInvalidInput" => ::std::option::Option::Some(EResponse::k_eInvalidInput),
                "k_eAlreadySubmitted" => ::std::option::Option::Some(EResponse::k_eAlreadySubmitted),
                "k_eVotingFinished" => ::std::option::Option::Some(EResponse::k_eVotingFinished),
                "k_ePlayerNotInMatch" => ::std::option::Option::Some(EResponse::k_ePlayerNotInMatch),
                "k_eCoachNotInMatch" => ::std::option::Option::Some(EResponse::k_eCoachNotInMatch),
                "k_ePlayerNotOnCoachTeam" => ::std::option::Option::Some(EResponse::k_ePlayerNotOnCoachTeam),
                "k_ePlayerInSamePartyAsCoach" => ::std::option::Option::Some(EResponse::k_ePlayerInSamePartyAsCoach),
                "k_eMatchNotEligible" => ::std::option::Option::Some(EResponse::k_eMatchNotEligible),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eInvalidInput,
            EResponse::k_eAlreadySubmitted,
            EResponse::k_eVotingFinished,
            EResponse::k_ePlayerNotInMatch,
            EResponse::k_eCoachNotInMatch,
            EResponse::k_ePlayerNotOnCoachTeam,
            EResponse::k_ePlayerInSamePartyAsCoach,
            EResponse::k_eMatchNotEligible,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCSubmitCoachTeammateRatingResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientCoachTeammateRatingsChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCoachTeammateRatingsChanged {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientCoachTeammateRatingsChanged.coach_match)
    pub coach_match: ::protobuf::MessageField<CMsgPlayerCoachMatch>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientCoachTeammateRatingsChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCoachTeammateRatingsChanged {
    fn default() -> &'a CMsgGCToClientCoachTeammateRatingsChanged {
        <CMsgGCToClientCoachTeammateRatingsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCoachTeammateRatingsChanged {
    pub fn new() -> CMsgGCToClientCoachTeammateRatingsChanged {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerCoachMatch>(
            "coach_match",
            |m: &CMsgGCToClientCoachTeammateRatingsChanged| { &m.coach_match },
            |m: &mut CMsgGCToClientCoachTeammateRatingsChanged| { &mut m.coach_match },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientCoachTeammateRatingsChanged>(
            "CMsgGCToClientCoachTeammateRatingsChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientCoachTeammateRatingsChanged {
    const NAME: &'static str = "CMsgGCToClientCoachTeammateRatingsChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coach_match)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coach_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coach_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCoachTeammateRatingsChanged {
        CMsgGCToClientCoachTeammateRatingsChanged::new()
    }

    fn clear(&mut self) {
        self.coach_match.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCoachTeammateRatingsChanged {
        static instance: CMsgGCToClientCoachTeammateRatingsChanged = CMsgGCToClientCoachTeammateRatingsChanged {
            coach_match: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientCoachTeammateRatingsChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientCoachTeammateRatingsChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientCoachTeammateRatingsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientCoachTeammateRatingsChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestPrivateCoachingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPrivateCoachingSession {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPrivateCoachingSession.language)
    pub language: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestPrivateCoachingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPrivateCoachingSession {
    fn default() -> &'a CMsgClientToGCRequestPrivateCoachingSession {
        <CMsgClientToGCRequestPrivateCoachingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPrivateCoachingSession {
    pub fn new() -> CMsgClientToGCRequestPrivateCoachingSession {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgClientToGCRequestPrivateCoachingSession| { &m.language },
            |m: &mut CMsgClientToGCRequestPrivateCoachingSession| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestPrivateCoachingSession>(
            "CMsgClientToGCRequestPrivateCoachingSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestPrivateCoachingSession {
    const NAME: &'static str = "CMsgClientToGCRequestPrivateCoachingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPrivateCoachingSession {
        CMsgClientToGCRequestPrivateCoachingSession::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPrivateCoachingSession {
        static instance: CMsgClientToGCRequestPrivateCoachingSession = CMsgClientToGCRequestPrivateCoachingSession {
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestPrivateCoachingSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestPrivateCoachingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestPrivateCoachingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestPrivateCoachingSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPrivateCoachingSessionResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_private_coaching_session_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.coaching_session)
    pub coaching_session: ::protobuf::MessageField<CMsgPrivateCoachingSession>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPrivateCoachingSessionResponse {
    fn default() -> &'a CMsgClientToGCRequestPrivateCoachingSessionResponse {
        <CMsgClientToGCRequestPrivateCoachingSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPrivateCoachingSessionResponse {
    pub fn new() -> CMsgClientToGCRequestPrivateCoachingSessionResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_private_coaching_session_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_private_coaching_session_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_private_coaching_session_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_private_coaching_session_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestPrivateCoachingSessionResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestPrivateCoachingSessionResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPrivateCoachingSession>(
            "coaching_session",
            |m: &CMsgClientToGCRequestPrivateCoachingSessionResponse| { &m.coaching_session },
            |m: &mut CMsgClientToGCRequestPrivateCoachingSessionResponse| { &mut m.coaching_session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestPrivateCoachingSessionResponse>(
            "CMsgClientToGCRequestPrivateCoachingSessionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestPrivateCoachingSessionResponse {
    const NAME: &'static str = "CMsgClientToGCRequestPrivateCoachingSessionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coaching_session)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.coaching_session.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.coaching_session.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPrivateCoachingSessionResponse {
        CMsgClientToGCRequestPrivateCoachingSessionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.coaching_session.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPrivateCoachingSessionResponse {
        static instance: CMsgClientToGCRequestPrivateCoachingSessionResponse = CMsgClientToGCRequestPrivateCoachingSessionResponse {
            result: ::std::option::Option::None,
            coaching_session: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestPrivateCoachingSessionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestPrivateCoachingSessionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestPrivateCoachingSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestPrivateCoachingSessionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestPrivateCoachingSessionResponse`
pub mod cmsg_client_to_gcrequest_private_coaching_session_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eAlreadyInSession)
        k_eAlreadyInSession = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eBehaviorScoreTooLow)
        k_eBehaviorScoreTooLow = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eInvalidLobbyType)
        k_eInvalidLobbyType = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eLowPriorityPlayer)
        k_eLowPriorityPlayer = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eLowPriorityLobby)
        k_eLowPriorityLobby = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eLowPriorityParty)
        k_eLowPriorityParty = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eTextChatBan)
        k_eTextChatBan = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eVoiceChatBan)
        k_eVoiceChatBan = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse.k_eMatchBan)
        k_eMatchBan = 13,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eAlreadyInSession),
                6 => ::std::option::Option::Some(EResponse::k_eBehaviorScoreTooLow),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                8 => ::std::option::Option::Some(EResponse::k_eLowPriorityPlayer),
                9 => ::std::option::Option::Some(EResponse::k_eLowPriorityLobby),
                10 => ::std::option::Option::Some(EResponse::k_eLowPriorityParty),
                11 => ::std::option::Option::Some(EResponse::k_eTextChatBan),
                12 => ::std::option::Option::Some(EResponse::k_eVoiceChatBan),
                13 => ::std::option::Option::Some(EResponse::k_eMatchBan),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eAlreadyInSession" => ::std::option::Option::Some(EResponse::k_eAlreadyInSession),
                "k_eBehaviorScoreTooLow" => ::std::option::Option::Some(EResponse::k_eBehaviorScoreTooLow),
                "k_eInvalidLobbyType" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                "k_eLowPriorityPlayer" => ::std::option::Option::Some(EResponse::k_eLowPriorityPlayer),
                "k_eLowPriorityLobby" => ::std::option::Option::Some(EResponse::k_eLowPriorityLobby),
                "k_eLowPriorityParty" => ::std::option::Option::Some(EResponse::k_eLowPriorityParty),
                "k_eTextChatBan" => ::std::option::Option::Some(EResponse::k_eTextChatBan),
                "k_eVoiceChatBan" => ::std::option::Option::Some(EResponse::k_eVoiceChatBan),
                "k_eMatchBan" => ::std::option::Option::Some(EResponse::k_eMatchBan),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eAlreadyInSession,
            EResponse::k_eBehaviorScoreTooLow,
            EResponse::k_eInvalidLobbyType,
            EResponse::k_eLowPriorityPlayer,
            EResponse::k_eLowPriorityLobby,
            EResponse::k_eLowPriorityParty,
            EResponse::k_eTextChatBan,
            EResponse::k_eVoiceChatBan,
            EResponse::k_eMatchBan,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestPrivateCoachingSessionResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAcceptPrivateCoachingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcceptPrivateCoachingSession {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcceptPrivateCoachingSession.coaching_session_id)
    pub coaching_session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAcceptPrivateCoachingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcceptPrivateCoachingSession {
    fn default() -> &'a CMsgClientToGCAcceptPrivateCoachingSession {
        <CMsgClientToGCAcceptPrivateCoachingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcceptPrivateCoachingSession {
    pub fn new() -> CMsgClientToGCAcceptPrivateCoachingSession {
        ::std::default::Default::default()
    }

    // optional uint64 coaching_session_id = 1;

    pub fn coaching_session_id(&self) -> u64 {
        self.coaching_session_id.unwrap_or(0)
    }

    pub fn clear_coaching_session_id(&mut self) {
        self.coaching_session_id = ::std::option::Option::None;
    }

    pub fn has_coaching_session_id(&self) -> bool {
        self.coaching_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coaching_session_id(&mut self, v: u64) {
        self.coaching_session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coaching_session_id",
            |m: &CMsgClientToGCAcceptPrivateCoachingSession| { &m.coaching_session_id },
            |m: &mut CMsgClientToGCAcceptPrivateCoachingSession| { &mut m.coaching_session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAcceptPrivateCoachingSession>(
            "CMsgClientToGCAcceptPrivateCoachingSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAcceptPrivateCoachingSession {
    const NAME: &'static str = "CMsgClientToGCAcceptPrivateCoachingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coaching_session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coaching_session_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coaching_session_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcceptPrivateCoachingSession {
        CMsgClientToGCAcceptPrivateCoachingSession::new()
    }

    fn clear(&mut self) {
        self.coaching_session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcceptPrivateCoachingSession {
        static instance: CMsgClientToGCAcceptPrivateCoachingSession = CMsgClientToGCAcceptPrivateCoachingSession {
            coaching_session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAcceptPrivateCoachingSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAcceptPrivateCoachingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAcceptPrivateCoachingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAcceptPrivateCoachingSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcceptPrivateCoachingSessionResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcaccept_private_coaching_session_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.coaching_session)
    pub coaching_session: ::protobuf::MessageField<CMsgPrivateCoachingSession>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcceptPrivateCoachingSessionResponse {
    fn default() -> &'a CMsgClientToGCAcceptPrivateCoachingSessionResponse {
        <CMsgClientToGCAcceptPrivateCoachingSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcceptPrivateCoachingSessionResponse {
    pub fn new() -> CMsgClientToGCAcceptPrivateCoachingSessionResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcaccept_private_coaching_session_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcaccept_private_coaching_session_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcaccept_private_coaching_session_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcaccept_private_coaching_session_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCAcceptPrivateCoachingSessionResponse| { &m.result },
            |m: &mut CMsgClientToGCAcceptPrivateCoachingSessionResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPrivateCoachingSession>(
            "coaching_session",
            |m: &CMsgClientToGCAcceptPrivateCoachingSessionResponse| { &m.coaching_session },
            |m: &mut CMsgClientToGCAcceptPrivateCoachingSessionResponse| { &mut m.coaching_session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAcceptPrivateCoachingSessionResponse>(
            "CMsgClientToGCAcceptPrivateCoachingSessionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAcceptPrivateCoachingSessionResponse {
    const NAME: &'static str = "CMsgClientToGCAcceptPrivateCoachingSessionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coaching_session)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.coaching_session.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.coaching_session.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcceptPrivateCoachingSessionResponse {
        CMsgClientToGCAcceptPrivateCoachingSessionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.coaching_session.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcceptPrivateCoachingSessionResponse {
        static instance: CMsgClientToGCAcceptPrivateCoachingSessionResponse = CMsgClientToGCAcceptPrivateCoachingSessionResponse {
            result: ::std::option::Option::None,
            coaching_session: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAcceptPrivateCoachingSessionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAcceptPrivateCoachingSessionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAcceptPrivateCoachingSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAcceptPrivateCoachingSessionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCAcceptPrivateCoachingSessionResponse`
pub mod cmsg_client_to_gcaccept_private_coaching_session_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eUnknownSession)
        k_eUnknownSession = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eAlreadyHasCoach)
        k_eAlreadyHasCoach = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eAlreadyHasSession)
        k_eAlreadyHasSession = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eInvalidUser)
        k_eInvalidUser = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eAlreadyFinished)
        k_eAlreadyFinished = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eInvalidLobbyType)
        k_eInvalidLobbyType = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eAlreadyInLobby)
        k_eAlreadyInLobby = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eLobbyIsLan)
        k_eLobbyIsLan = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eLobbyIsLeague)
        k_eLobbyIsLeague = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eInvalidLobbyState)
        k_eInvalidLobbyState = 14,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eRequesterIsNotPlayer)
        k_eRequesterIsNotPlayer = 15,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eTooManyCoaches)
        k_eTooManyCoaches = 16,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eCoachWasPlayer)
        k_eCoachWasPlayer = 17,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eCoachBehaviorScoreTooLow)
        k_eCoachBehaviorScoreTooLow = 18,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eCoachRankNotCalibrated)
        k_eCoachRankNotCalibrated = 19,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eCoachRankNotEligible)
        k_eCoachRankNotEligible = 20,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse.k_eCoachRankTooLow)
        k_eCoachRankTooLow = 21,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eUnknownSession),
                6 => ::std::option::Option::Some(EResponse::k_eAlreadyHasCoach),
                7 => ::std::option::Option::Some(EResponse::k_eAlreadyHasSession),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidUser),
                9 => ::std::option::Option::Some(EResponse::k_eAlreadyFinished),
                10 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                11 => ::std::option::Option::Some(EResponse::k_eAlreadyInLobby),
                12 => ::std::option::Option::Some(EResponse::k_eLobbyIsLan),
                13 => ::std::option::Option::Some(EResponse::k_eLobbyIsLeague),
                14 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                15 => ::std::option::Option::Some(EResponse::k_eRequesterIsNotPlayer),
                16 => ::std::option::Option::Some(EResponse::k_eTooManyCoaches),
                17 => ::std::option::Option::Some(EResponse::k_eCoachWasPlayer),
                18 => ::std::option::Option::Some(EResponse::k_eCoachBehaviorScoreTooLow),
                19 => ::std::option::Option::Some(EResponse::k_eCoachRankNotCalibrated),
                20 => ::std::option::Option::Some(EResponse::k_eCoachRankNotEligible),
                21 => ::std::option::Option::Some(EResponse::k_eCoachRankTooLow),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eUnknownSession" => ::std::option::Option::Some(EResponse::k_eUnknownSession),
                "k_eAlreadyHasCoach" => ::std::option::Option::Some(EResponse::k_eAlreadyHasCoach),
                "k_eAlreadyHasSession" => ::std::option::Option::Some(EResponse::k_eAlreadyHasSession),
                "k_eInvalidUser" => ::std::option::Option::Some(EResponse::k_eInvalidUser),
                "k_eAlreadyFinished" => ::std::option::Option::Some(EResponse::k_eAlreadyFinished),
                "k_eInvalidLobbyType" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                "k_eAlreadyInLobby" => ::std::option::Option::Some(EResponse::k_eAlreadyInLobby),
                "k_eLobbyIsLan" => ::std::option::Option::Some(EResponse::k_eLobbyIsLan),
                "k_eLobbyIsLeague" => ::std::option::Option::Some(EResponse::k_eLobbyIsLeague),
                "k_eInvalidLobbyState" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                "k_eRequesterIsNotPlayer" => ::std::option::Option::Some(EResponse::k_eRequesterIsNotPlayer),
                "k_eTooManyCoaches" => ::std::option::Option::Some(EResponse::k_eTooManyCoaches),
                "k_eCoachWasPlayer" => ::std::option::Option::Some(EResponse::k_eCoachWasPlayer),
                "k_eCoachBehaviorScoreTooLow" => ::std::option::Option::Some(EResponse::k_eCoachBehaviorScoreTooLow),
                "k_eCoachRankNotCalibrated" => ::std::option::Option::Some(EResponse::k_eCoachRankNotCalibrated),
                "k_eCoachRankNotEligible" => ::std::option::Option::Some(EResponse::k_eCoachRankNotEligible),
                "k_eCoachRankTooLow" => ::std::option::Option::Some(EResponse::k_eCoachRankTooLow),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eUnknownSession,
            EResponse::k_eAlreadyHasCoach,
            EResponse::k_eAlreadyHasSession,
            EResponse::k_eInvalidUser,
            EResponse::k_eAlreadyFinished,
            EResponse::k_eInvalidLobbyType,
            EResponse::k_eAlreadyInLobby,
            EResponse::k_eLobbyIsLan,
            EResponse::k_eLobbyIsLeague,
            EResponse::k_eInvalidLobbyState,
            EResponse::k_eRequesterIsNotPlayer,
            EResponse::k_eTooManyCoaches,
            EResponse::k_eCoachWasPlayer,
            EResponse::k_eCoachBehaviorScoreTooLow,
            EResponse::k_eCoachRankNotCalibrated,
            EResponse::k_eCoachRankNotEligible,
            EResponse::k_eCoachRankTooLow,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCAcceptPrivateCoachingSessionResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCLeavePrivateCoachingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLeavePrivateCoachingSession {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCLeavePrivateCoachingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLeavePrivateCoachingSession {
    fn default() -> &'a CMsgClientToGCLeavePrivateCoachingSession {
        <CMsgClientToGCLeavePrivateCoachingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLeavePrivateCoachingSession {
    pub fn new() -> CMsgClientToGCLeavePrivateCoachingSession {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCLeavePrivateCoachingSession>(
            "CMsgClientToGCLeavePrivateCoachingSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCLeavePrivateCoachingSession {
    const NAME: &'static str = "CMsgClientToGCLeavePrivateCoachingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLeavePrivateCoachingSession {
        CMsgClientToGCLeavePrivateCoachingSession::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLeavePrivateCoachingSession {
        static instance: CMsgClientToGCLeavePrivateCoachingSession = CMsgClientToGCLeavePrivateCoachingSession {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCLeavePrivateCoachingSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCLeavePrivateCoachingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCLeavePrivateCoachingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLeavePrivateCoachingSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLeavePrivateCoachingSessionResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcleave_private_coaching_session_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLeavePrivateCoachingSessionResponse {
    fn default() -> &'a CMsgClientToGCLeavePrivateCoachingSessionResponse {
        <CMsgClientToGCLeavePrivateCoachingSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLeavePrivateCoachingSessionResponse {
    pub fn new() -> CMsgClientToGCLeavePrivateCoachingSessionResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcleave_private_coaching_session_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcleave_private_coaching_session_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcleave_private_coaching_session_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcleave_private_coaching_session_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCLeavePrivateCoachingSessionResponse| { &m.result },
            |m: &mut CMsgClientToGCLeavePrivateCoachingSessionResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCLeavePrivateCoachingSessionResponse>(
            "CMsgClientToGCLeavePrivateCoachingSessionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCLeavePrivateCoachingSessionResponse {
    const NAME: &'static str = "CMsgClientToGCLeavePrivateCoachingSessionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLeavePrivateCoachingSessionResponse {
        CMsgClientToGCLeavePrivateCoachingSessionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLeavePrivateCoachingSessionResponse {
        static instance: CMsgClientToGCLeavePrivateCoachingSessionResponse = CMsgClientToGCLeavePrivateCoachingSessionResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCLeavePrivateCoachingSessionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCLeavePrivateCoachingSessionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCLeavePrivateCoachingSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLeavePrivateCoachingSessionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCLeavePrivateCoachingSessionResponse`
pub mod cmsg_client_to_gcleave_private_coaching_session_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse.k_eNoSession)
        k_eNoSession = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse.k_eAlreadyLeft)
        k_eAlreadyLeft = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoSession),
                6 => ::std::option::Option::Some(EResponse::k_eAlreadyLeft),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoSession" => ::std::option::Option::Some(EResponse::k_eNoSession),
                "k_eAlreadyLeft" => ::std::option::Option::Some(EResponse::k_eAlreadyLeft),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoSession,
            EResponse::k_eAlreadyLeft,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCLeavePrivateCoachingSessionResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetCurrentPrivateCoachingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetCurrentPrivateCoachingSession {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetCurrentPrivateCoachingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetCurrentPrivateCoachingSession {
    fn default() -> &'a CMsgClientToGCGetCurrentPrivateCoachingSession {
        <CMsgClientToGCGetCurrentPrivateCoachingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetCurrentPrivateCoachingSession {
    pub fn new() -> CMsgClientToGCGetCurrentPrivateCoachingSession {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetCurrentPrivateCoachingSession>(
            "CMsgClientToGCGetCurrentPrivateCoachingSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetCurrentPrivateCoachingSession {
    const NAME: &'static str = "CMsgClientToGCGetCurrentPrivateCoachingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetCurrentPrivateCoachingSession {
        CMsgClientToGCGetCurrentPrivateCoachingSession::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetCurrentPrivateCoachingSession {
        static instance: CMsgClientToGCGetCurrentPrivateCoachingSession = CMsgClientToGCGetCurrentPrivateCoachingSession {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetCurrentPrivateCoachingSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetCurrentPrivateCoachingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetCurrentPrivateCoachingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetCurrentPrivateCoachingSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_current_private_coaching_session_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.current_session)
    pub current_session: ::protobuf::MessageField<CMsgPrivateCoachingSession>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
    fn default() -> &'a CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
        <CMsgClientToGCGetCurrentPrivateCoachingSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
    pub fn new() -> CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_current_private_coaching_session_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_current_private_coaching_session_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_current_private_coaching_session_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_current_private_coaching_session_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCGetCurrentPrivateCoachingSessionResponse| { &m.result },
            |m: &mut CMsgClientToGCGetCurrentPrivateCoachingSessionResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPrivateCoachingSession>(
            "current_session",
            |m: &CMsgClientToGCGetCurrentPrivateCoachingSessionResponse| { &m.current_session },
            |m: &mut CMsgClientToGCGetCurrentPrivateCoachingSessionResponse| { &mut m.current_session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetCurrentPrivateCoachingSessionResponse>(
            "CMsgClientToGCGetCurrentPrivateCoachingSessionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
    const NAME: &'static str = "CMsgClientToGCGetCurrentPrivateCoachingSessionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.current_session)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.current_session.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.current_session.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
        CMsgClientToGCGetCurrentPrivateCoachingSessionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.current_session.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
        static instance: CMsgClientToGCGetCurrentPrivateCoachingSessionResponse = CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
            result: ::std::option::Option::None,
            current_session: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetCurrentPrivateCoachingSessionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetCurrentPrivateCoachingSessionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetCurrentPrivateCoachingSessionResponse`
pub mod cmsg_client_to_gcget_current_private_coaching_session_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientPrivateCoachingSessionUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPrivateCoachingSessionUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPrivateCoachingSessionUpdated.coaching_session)
    pub coaching_session: ::protobuf::MessageField<CMsgPrivateCoachingSession>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientPrivateCoachingSessionUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPrivateCoachingSessionUpdated {
    fn default() -> &'a CMsgGCToClientPrivateCoachingSessionUpdated {
        <CMsgGCToClientPrivateCoachingSessionUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPrivateCoachingSessionUpdated {
    pub fn new() -> CMsgGCToClientPrivateCoachingSessionUpdated {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPrivateCoachingSession>(
            "coaching_session",
            |m: &CMsgGCToClientPrivateCoachingSessionUpdated| { &m.coaching_session },
            |m: &mut CMsgGCToClientPrivateCoachingSessionUpdated| { &mut m.coaching_session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientPrivateCoachingSessionUpdated>(
            "CMsgGCToClientPrivateCoachingSessionUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientPrivateCoachingSessionUpdated {
    const NAME: &'static str = "CMsgGCToClientPrivateCoachingSessionUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coaching_session)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coaching_session.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coaching_session.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPrivateCoachingSessionUpdated {
        CMsgGCToClientPrivateCoachingSessionUpdated::new()
    }

    fn clear(&mut self) {
        self.coaching_session.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPrivateCoachingSessionUpdated {
        static instance: CMsgGCToClientPrivateCoachingSessionUpdated = CMsgGCToClientPrivateCoachingSessionUpdated {
            coaching_session: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientPrivateCoachingSessionUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientPrivateCoachingSessionUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientPrivateCoachingSessionUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientPrivateCoachingSessionUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSubmitPrivateCoachingSessionRating)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitPrivateCoachingSessionRating {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitPrivateCoachingSessionRating.coaching_session_id)
    pub coaching_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitPrivateCoachingSessionRating.session_rating)
    pub session_rating: ::std::option::Option<::protobuf::EnumOrUnknown<ECoachTeammateRating>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSubmitPrivateCoachingSessionRating.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitPrivateCoachingSessionRating {
    fn default() -> &'a CMsgClientToGCSubmitPrivateCoachingSessionRating {
        <CMsgClientToGCSubmitPrivateCoachingSessionRating as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitPrivateCoachingSessionRating {
    pub fn new() -> CMsgClientToGCSubmitPrivateCoachingSessionRating {
        ::std::default::Default::default()
    }

    // optional uint64 coaching_session_id = 1;

    pub fn coaching_session_id(&self) -> u64 {
        self.coaching_session_id.unwrap_or(0)
    }

    pub fn clear_coaching_session_id(&mut self) {
        self.coaching_session_id = ::std::option::Option::None;
    }

    pub fn has_coaching_session_id(&self) -> bool {
        self.coaching_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coaching_session_id(&mut self, v: u64) {
        self.coaching_session_id = ::std::option::Option::Some(v);
    }

    // optional .dota.ECoachTeammateRating session_rating = 2;

    pub fn session_rating(&self) -> ECoachTeammateRating {
        match self.session_rating {
            Some(e) => e.enum_value_or(ECoachTeammateRating::k_ECoachTeammateRating_None),
            None => ECoachTeammateRating::k_ECoachTeammateRating_None,
        }
    }

    pub fn clear_session_rating(&mut self) {
        self.session_rating = ::std::option::Option::None;
    }

    pub fn has_session_rating(&self) -> bool {
        self.session_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_rating(&mut self, v: ECoachTeammateRating) {
        self.session_rating = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coaching_session_id",
            |m: &CMsgClientToGCSubmitPrivateCoachingSessionRating| { &m.coaching_session_id },
            |m: &mut CMsgClientToGCSubmitPrivateCoachingSessionRating| { &mut m.coaching_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_rating",
            |m: &CMsgClientToGCSubmitPrivateCoachingSessionRating| { &m.session_rating },
            |m: &mut CMsgClientToGCSubmitPrivateCoachingSessionRating| { &mut m.session_rating },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSubmitPrivateCoachingSessionRating>(
            "CMsgClientToGCSubmitPrivateCoachingSessionRating",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSubmitPrivateCoachingSessionRating {
    const NAME: &'static str = "CMsgClientToGCSubmitPrivateCoachingSessionRating";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coaching_session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.session_rating = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coaching_session_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.session_rating {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coaching_session_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.session_rating {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitPrivateCoachingSessionRating {
        CMsgClientToGCSubmitPrivateCoachingSessionRating::new()
    }

    fn clear(&mut self) {
        self.coaching_session_id = ::std::option::Option::None;
        self.session_rating = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitPrivateCoachingSessionRating {
        static instance: CMsgClientToGCSubmitPrivateCoachingSessionRating = CMsgClientToGCSubmitPrivateCoachingSessionRating {
            coaching_session_id: ::std::option::Option::None,
            session_rating: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSubmitPrivateCoachingSessionRating {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSubmitPrivateCoachingSessionRating").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSubmitPrivateCoachingSessionRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSubmitPrivateCoachingSessionRating {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcsubmit_private_coaching_session_rating_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
    fn default() -> &'a CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
        <CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
    pub fn new() -> CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcsubmit_private_coaching_session_rating_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcsubmit_private_coaching_session_rating_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcsubmit_private_coaching_session_rating_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcsubmit_private_coaching_session_rating_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse| { &m.result },
            |m: &mut CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse>(
            "CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
    const NAME: &'static str = "CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
        CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
        static instance: CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse = CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse`
pub mod cmsg_client_to_gcsubmit_private_coaching_session_rating_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eUnknownSession)
        k_eUnknownSession = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eAlreadySubmitted)
        k_eAlreadySubmitted = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eSessionActive)
        k_eSessionActive = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eSessionTooShort)
        k_eSessionTooShort = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eNoCoach)
        k_eNoCoach = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse.k_eInvalidRating)
        k_eInvalidRating = 11,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eUnknownSession),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eAlreadySubmitted),
                8 => ::std::option::Option::Some(EResponse::k_eSessionActive),
                9 => ::std::option::Option::Some(EResponse::k_eSessionTooShort),
                10 => ::std::option::Option::Some(EResponse::k_eNoCoach),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidRating),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eUnknownSession" => ::std::option::Option::Some(EResponse::k_eUnknownSession),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eAlreadySubmitted" => ::std::option::Option::Some(EResponse::k_eAlreadySubmitted),
                "k_eSessionActive" => ::std::option::Option::Some(EResponse::k_eSessionActive),
                "k_eSessionTooShort" => ::std::option::Option::Some(EResponse::k_eSessionTooShort),
                "k_eNoCoach" => ::std::option::Option::Some(EResponse::k_eNoCoach),
                "k_eInvalidRating" => ::std::option::Option::Some(EResponse::k_eInvalidRating),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eUnknownSession,
            EResponse::k_eNotMember,
            EResponse::k_eAlreadySubmitted,
            EResponse::k_eSessionActive,
            EResponse::k_eSessionTooShort,
            EResponse::k_eNoCoach,
            EResponse::k_eInvalidRating,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetAvailablePrivateCoachingSessions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAvailablePrivateCoachingSessions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessions.language)
    pub language: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAvailablePrivateCoachingSessions {
    fn default() -> &'a CMsgClientToGCGetAvailablePrivateCoachingSessions {
        <CMsgClientToGCGetAvailablePrivateCoachingSessions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAvailablePrivateCoachingSessions {
    pub fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessions {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgClientToGCGetAvailablePrivateCoachingSessions| { &m.language },
            |m: &mut CMsgClientToGCGetAvailablePrivateCoachingSessions| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetAvailablePrivateCoachingSessions>(
            "CMsgClientToGCGetAvailablePrivateCoachingSessions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAvailablePrivateCoachingSessions {
    const NAME: &'static str = "CMsgClientToGCGetAvailablePrivateCoachingSessions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessions {
        CMsgClientToGCGetAvailablePrivateCoachingSessions::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAvailablePrivateCoachingSessions {
        static instance: CMsgClientToGCGetAvailablePrivateCoachingSessions = CMsgClientToGCGetAvailablePrivateCoachingSessions {
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetAvailablePrivateCoachingSessions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetAvailablePrivateCoachingSessions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetAvailablePrivateCoachingSessions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAvailablePrivateCoachingSessions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_available_private_coaching_sessions_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.available_sessions_list)
    pub available_sessions_list: ::protobuf::MessageField<CMsgAvailablePrivateCoachingSessionList>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
    fn default() -> &'a CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
        <CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
    pub fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_available_private_coaching_sessions_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_available_private_coaching_sessions_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_available_private_coaching_sessions_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_available_private_coaching_sessions_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse| { &m.result },
            |m: &mut CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAvailablePrivateCoachingSessionList>(
            "available_sessions_list",
            |m: &CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse| { &m.available_sessions_list },
            |m: &mut CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse| { &mut m.available_sessions_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse>(
            "CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
    const NAME: &'static str = "CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.available_sessions_list)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.available_sessions_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.available_sessions_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
        CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.available_sessions_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
        static instance: CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse = CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
            result: ::std::option::Option::None,
            available_sessions_list: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse`
pub mod cmsg_client_to_gcget_available_private_coaching_sessions_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
    fn default() -> &'a CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
        <CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
    pub fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary>(
            "CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
    const NAME: &'static str = "CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
        CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
        static instance: CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary = CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_available_private_coaching_sessions_summary_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.coaching_session_summary)
    pub coaching_session_summary: ::protobuf::MessageField<CMsgAvailablePrivateCoachingSessionSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
    fn default() -> &'a CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
        <CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
    pub fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_available_private_coaching_sessions_summary_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_available_private_coaching_sessions_summary_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_available_private_coaching_sessions_summary_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_available_private_coaching_sessions_summary_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse| { &m.result },
            |m: &mut CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAvailablePrivateCoachingSessionSummary>(
            "coaching_session_summary",
            |m: &CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse| { &m.coaching_session_summary },
            |m: &mut CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse| { &mut m.coaching_session_summary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse>(
            "CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
    const NAME: &'static str = "CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coaching_session_summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.coaching_session_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.coaching_session_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
        CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.coaching_session_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
        static instance: CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse = CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
            result: ::std::option::Option::None,
            coaching_session_summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse`
pub mod cmsg_client_to_gcget_available_private_coaching_sessions_summary_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCJoinPrivateCoachingSessionLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinPrivateCoachingSessionLobby {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCJoinPrivateCoachingSessionLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinPrivateCoachingSessionLobby {
    fn default() -> &'a CMsgClientToGCJoinPrivateCoachingSessionLobby {
        <CMsgClientToGCJoinPrivateCoachingSessionLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinPrivateCoachingSessionLobby {
    pub fn new() -> CMsgClientToGCJoinPrivateCoachingSessionLobby {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCJoinPrivateCoachingSessionLobby>(
            "CMsgClientToGCJoinPrivateCoachingSessionLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCJoinPrivateCoachingSessionLobby {
    const NAME: &'static str = "CMsgClientToGCJoinPrivateCoachingSessionLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinPrivateCoachingSessionLobby {
        CMsgClientToGCJoinPrivateCoachingSessionLobby::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinPrivateCoachingSessionLobby {
        static instance: CMsgClientToGCJoinPrivateCoachingSessionLobby = CMsgClientToGCJoinPrivateCoachingSessionLobby {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCJoinPrivateCoachingSessionLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCJoinPrivateCoachingSessionLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCJoinPrivateCoachingSessionLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCJoinPrivateCoachingSessionLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcjoin_private_coaching_session_lobby_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
    fn default() -> &'a CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
        <CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
    pub fn new() -> CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcjoin_private_coaching_session_lobby_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcjoin_private_coaching_session_lobby_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcjoin_private_coaching_session_lobby_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcjoin_private_coaching_session_lobby_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse| { &m.result },
            |m: &mut CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse>(
            "CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
    const NAME: &'static str = "CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
        CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
        static instance: CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse = CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse`
pub mod cmsg_client_to_gcjoin_private_coaching_session_lobby_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eNoSession)
        k_eNoSession = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eSessionFinished)
        k_eSessionFinished = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eAlreadyLeft)
        k_eAlreadyLeft = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eNotACoach)
        k_eNotACoach = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eNoLobby)
        k_eNoLobby = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eCoachInThisLobby)
        k_eCoachInThisLobby = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eCoachInALobby)
        k_eCoachInALobby = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eLobbyIsLan)
        k_eLobbyIsLan = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eLobbyIsLeague)
        k_eLobbyIsLeague = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eInvalidLobbyType)
        k_eInvalidLobbyType = 14,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eInvalidLobbyState)
        k_eInvalidLobbyState = 15,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eRequesterIsNotPlayer)
        k_eRequesterIsNotPlayer = 16,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eTooManyCoaches)
        k_eTooManyCoaches = 17,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eCoachWasPlayer)
        k_eCoachWasPlayer = 18,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse.k_eJoinFailed)
        k_eJoinFailed = 19,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoSession),
                6 => ::std::option::Option::Some(EResponse::k_eSessionFinished),
                7 => ::std::option::Option::Some(EResponse::k_eAlreadyLeft),
                8 => ::std::option::Option::Some(EResponse::k_eNotACoach),
                9 => ::std::option::Option::Some(EResponse::k_eNoLobby),
                10 => ::std::option::Option::Some(EResponse::k_eCoachInThisLobby),
                11 => ::std::option::Option::Some(EResponse::k_eCoachInALobby),
                12 => ::std::option::Option::Some(EResponse::k_eLobbyIsLan),
                13 => ::std::option::Option::Some(EResponse::k_eLobbyIsLeague),
                14 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                15 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                16 => ::std::option::Option::Some(EResponse::k_eRequesterIsNotPlayer),
                17 => ::std::option::Option::Some(EResponse::k_eTooManyCoaches),
                18 => ::std::option::Option::Some(EResponse::k_eCoachWasPlayer),
                19 => ::std::option::Option::Some(EResponse::k_eJoinFailed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoSession" => ::std::option::Option::Some(EResponse::k_eNoSession),
                "k_eSessionFinished" => ::std::option::Option::Some(EResponse::k_eSessionFinished),
                "k_eAlreadyLeft" => ::std::option::Option::Some(EResponse::k_eAlreadyLeft),
                "k_eNotACoach" => ::std::option::Option::Some(EResponse::k_eNotACoach),
                "k_eNoLobby" => ::std::option::Option::Some(EResponse::k_eNoLobby),
                "k_eCoachInThisLobby" => ::std::option::Option::Some(EResponse::k_eCoachInThisLobby),
                "k_eCoachInALobby" => ::std::option::Option::Some(EResponse::k_eCoachInALobby),
                "k_eLobbyIsLan" => ::std::option::Option::Some(EResponse::k_eLobbyIsLan),
                "k_eLobbyIsLeague" => ::std::option::Option::Some(EResponse::k_eLobbyIsLeague),
                "k_eInvalidLobbyType" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                "k_eInvalidLobbyState" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                "k_eRequesterIsNotPlayer" => ::std::option::Option::Some(EResponse::k_eRequesterIsNotPlayer),
                "k_eTooManyCoaches" => ::std::option::Option::Some(EResponse::k_eTooManyCoaches),
                "k_eCoachWasPlayer" => ::std::option::Option::Some(EResponse::k_eCoachWasPlayer),
                "k_eJoinFailed" => ::std::option::Option::Some(EResponse::k_eJoinFailed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoSession,
            EResponse::k_eSessionFinished,
            EResponse::k_eAlreadyLeft,
            EResponse::k_eNotACoach,
            EResponse::k_eNoLobby,
            EResponse::k_eCoachInThisLobby,
            EResponse::k_eCoachInALobby,
            EResponse::k_eLobbyIsLan,
            EResponse::k_eLobbyIsLeague,
            EResponse::k_eInvalidLobbyType,
            EResponse::k_eInvalidLobbyState,
            EResponse::k_eRequesterIsNotPlayer,
            EResponse::k_eTooManyCoaches,
            EResponse::k_eCoachWasPlayer,
            EResponse::k_eJoinFailed,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCoachFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCoachFriend {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCoachFriend.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCoachFriend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCoachFriend {
    fn default() -> &'a CMsgClientToGCCoachFriend {
        <CMsgClientToGCCoachFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCoachFriend {
    pub fn new() -> CMsgClientToGCCoachFriend {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_account_id",
            |m: &CMsgClientToGCCoachFriend| { &m.target_account_id },
            |m: &mut CMsgClientToGCCoachFriend| { &mut m.target_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCoachFriend>(
            "CMsgClientToGCCoachFriend",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCoachFriend {
    const NAME: &'static str = "CMsgClientToGCCoachFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCoachFriend {
        CMsgClientToGCCoachFriend::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCoachFriend {
        static instance: CMsgClientToGCCoachFriend = CMsgClientToGCCoachFriend {
            target_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCoachFriend {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCoachFriend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCoachFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCoachFriend {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCoachFriendResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCoachFriendResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCoachFriendResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccoach_friend_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCoachFriendResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCoachFriendResponse {
    fn default() -> &'a CMsgClientToGCCoachFriendResponse {
        <CMsgClientToGCCoachFriendResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCoachFriendResponse {
    pub fn new() -> CMsgClientToGCCoachFriendResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCoachFriendResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gccoach_friend_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccoach_friend_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccoach_friend_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccoach_friend_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCCoachFriendResponse| { &m.result },
            |m: &mut CMsgClientToGCCoachFriendResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCoachFriendResponse>(
            "CMsgClientToGCCoachFriendResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCoachFriendResponse {
    const NAME: &'static str = "CMsgClientToGCCoachFriendResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCoachFriendResponse {
        CMsgClientToGCCoachFriendResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCoachFriendResponse {
        static instance: CMsgClientToGCCoachFriendResponse = CMsgClientToGCCoachFriendResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCoachFriendResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCoachFriendResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCoachFriendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCoachFriendResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCoachFriendResponse`
pub mod cmsg_client_to_gccoach_friend_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCoachFriendResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eCoachNotSubscriber)
        k_eCoachNotSubscriber = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eLobbyNotFound)
        k_eLobbyNotFound = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eFriendsOnBothSides)
        k_eFriendsOnBothSides = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eNotFriends)
        k_eNotFriends = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eCoachInThisLobby)
        k_eCoachInThisLobby = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eCoachInALobby)
        k_eCoachInALobby = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eLobbyIsLan)
        k_eLobbyIsLan = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eInvalidLobbyType)
        k_eInvalidLobbyType = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eInvalidLobbyState)
        k_eInvalidLobbyState = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eFriendIsNotAPlayer)
        k_eFriendIsNotAPlayer = 14,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eTooManyCoaches)
        k_eTooManyCoaches = 15,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eCoachSwitchedTeams)
        k_eCoachSwitchedTeams = 16,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eLobbyIsLeague)
        k_eLobbyIsLeague = 17,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eCoachWasPlayer)
        k_eCoachWasPlayer = 18,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCoachFriendResponse.EResponse.k_eRequestRejected)
        k_eRequestRejected = 19,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eCoachNotSubscriber),
                6 => ::std::option::Option::Some(EResponse::k_eLobbyNotFound),
                7 => ::std::option::Option::Some(EResponse::k_eFriendsOnBothSides),
                8 => ::std::option::Option::Some(EResponse::k_eNotFriends),
                9 => ::std::option::Option::Some(EResponse::k_eCoachInThisLobby),
                10 => ::std::option::Option::Some(EResponse::k_eCoachInALobby),
                11 => ::std::option::Option::Some(EResponse::k_eLobbyIsLan),
                12 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                13 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                14 => ::std::option::Option::Some(EResponse::k_eFriendIsNotAPlayer),
                15 => ::std::option::Option::Some(EResponse::k_eTooManyCoaches),
                16 => ::std::option::Option::Some(EResponse::k_eCoachSwitchedTeams),
                17 => ::std::option::Option::Some(EResponse::k_eLobbyIsLeague),
                18 => ::std::option::Option::Some(EResponse::k_eCoachWasPlayer),
                19 => ::std::option::Option::Some(EResponse::k_eRequestRejected),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eCoachNotSubscriber" => ::std::option::Option::Some(EResponse::k_eCoachNotSubscriber),
                "k_eLobbyNotFound" => ::std::option::Option::Some(EResponse::k_eLobbyNotFound),
                "k_eFriendsOnBothSides" => ::std::option::Option::Some(EResponse::k_eFriendsOnBothSides),
                "k_eNotFriends" => ::std::option::Option::Some(EResponse::k_eNotFriends),
                "k_eCoachInThisLobby" => ::std::option::Option::Some(EResponse::k_eCoachInThisLobby),
                "k_eCoachInALobby" => ::std::option::Option::Some(EResponse::k_eCoachInALobby),
                "k_eLobbyIsLan" => ::std::option::Option::Some(EResponse::k_eLobbyIsLan),
                "k_eInvalidLobbyType" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyType),
                "k_eInvalidLobbyState" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                "k_eFriendIsNotAPlayer" => ::std::option::Option::Some(EResponse::k_eFriendIsNotAPlayer),
                "k_eTooManyCoaches" => ::std::option::Option::Some(EResponse::k_eTooManyCoaches),
                "k_eCoachSwitchedTeams" => ::std::option::Option::Some(EResponse::k_eCoachSwitchedTeams),
                "k_eLobbyIsLeague" => ::std::option::Option::Some(EResponse::k_eLobbyIsLeague),
                "k_eCoachWasPlayer" => ::std::option::Option::Some(EResponse::k_eCoachWasPlayer),
                "k_eRequestRejected" => ::std::option::Option::Some(EResponse::k_eRequestRejected),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eCoachNotSubscriber,
            EResponse::k_eLobbyNotFound,
            EResponse::k_eFriendsOnBothSides,
            EResponse::k_eNotFriends,
            EResponse::k_eCoachInThisLobby,
            EResponse::k_eCoachInALobby,
            EResponse::k_eLobbyIsLan,
            EResponse::k_eInvalidLobbyType,
            EResponse::k_eInvalidLobbyState,
            EResponse::k_eFriendIsNotAPlayer,
            EResponse::k_eTooManyCoaches,
            EResponse::k_eCoachSwitchedTeams,
            EResponse::k_eLobbyIsLeague,
            EResponse::k_eCoachWasPlayer,
            EResponse::k_eRequestRejected,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCoachFriendResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCoachFriendResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRespondToCoachFriendRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRespondToCoachFriendRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRespondToCoachFriendRequest.coach_account_id)
    pub coach_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRespondToCoachFriendRequest.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_gcmessages_common_lobby::ELobbyMemberCoachRequestState>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRespondToCoachFriendRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRespondToCoachFriendRequest {
    fn default() -> &'a CMsgClientToGCRespondToCoachFriendRequest {
        <CMsgClientToGCRespondToCoachFriendRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRespondToCoachFriendRequest {
    pub fn new() -> CMsgClientToGCRespondToCoachFriendRequest {
        ::std::default::Default::default()
    }

    // optional uint32 coach_account_id = 1;

    pub fn coach_account_id(&self) -> u32 {
        self.coach_account_id.unwrap_or(0)
    }

    pub fn clear_coach_account_id(&mut self) {
        self.coach_account_id = ::std::option::Option::None;
    }

    pub fn has_coach_account_id(&self) -> bool {
        self.coach_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_account_id(&mut self, v: u32) {
        self.coach_account_id = ::std::option::Option::Some(v);
    }

    // optional .dota.ELobbyMemberCoachRequestState response = 2;

    pub fn response(&self) -> super::dota_gcmessages_common_lobby::ELobbyMemberCoachRequestState {
        match self.response {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common_lobby::ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None),
            None => super::dota_gcmessages_common_lobby::ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: super::dota_gcmessages_common_lobby::ELobbyMemberCoachRequestState) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_account_id",
            |m: &CMsgClientToGCRespondToCoachFriendRequest| { &m.coach_account_id },
            |m: &mut CMsgClientToGCRespondToCoachFriendRequest| { &mut m.coach_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCRespondToCoachFriendRequest| { &m.response },
            |m: &mut CMsgClientToGCRespondToCoachFriendRequest| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRespondToCoachFriendRequest>(
            "CMsgClientToGCRespondToCoachFriendRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRespondToCoachFriendRequest {
    const NAME: &'static str = "CMsgClientToGCRespondToCoachFriendRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coach_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coach_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coach_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRespondToCoachFriendRequest {
        CMsgClientToGCRespondToCoachFriendRequest::new()
    }

    fn clear(&mut self) {
        self.coach_account_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRespondToCoachFriendRequest {
        static instance: CMsgClientToGCRespondToCoachFriendRequest = CMsgClientToGCRespondToCoachFriendRequest {
            coach_account_id: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRespondToCoachFriendRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRespondToCoachFriendRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRespondToCoachFriendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRespondToCoachFriendRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRespondToCoachFriendRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRespondToCoachFriendRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrespond_to_coach_friend_request_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRespondToCoachFriendRequestResponse {
    fn default() -> &'a CMsgClientToGCRespondToCoachFriendRequestResponse {
        <CMsgClientToGCRespondToCoachFriendRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRespondToCoachFriendRequestResponse {
    pub fn new() -> CMsgClientToGCRespondToCoachFriendRequestResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrespond_to_coach_friend_request_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrespond_to_coach_friend_request_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrespond_to_coach_friend_request_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrespond_to_coach_friend_request_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRespondToCoachFriendRequestResponse| { &m.result },
            |m: &mut CMsgClientToGCRespondToCoachFriendRequestResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRespondToCoachFriendRequestResponse>(
            "CMsgClientToGCRespondToCoachFriendRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRespondToCoachFriendRequestResponse {
    const NAME: &'static str = "CMsgClientToGCRespondToCoachFriendRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRespondToCoachFriendRequestResponse {
        CMsgClientToGCRespondToCoachFriendRequestResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRespondToCoachFriendRequestResponse {
        static instance: CMsgClientToGCRespondToCoachFriendRequestResponse = CMsgClientToGCRespondToCoachFriendRequestResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRespondToCoachFriendRequestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRespondToCoachFriendRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRespondToCoachFriendRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRespondToCoachFriendRequestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRespondToCoachFriendRequestResponse`
pub mod cmsg_client_to_gcrespond_to_coach_friend_request_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eLobbyNotFound)
        k_eLobbyNotFound = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eInvalidLobbyState)
        k_eInvalidLobbyState = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eCoachNotInLobby)
        k_eCoachNotInLobby = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_ePlayerInvalidTeam)
        k_ePlayerInvalidTeam = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eCoachInvalidTeam)
        k_eCoachInvalidTeam = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eNoRequest)
        k_eNoRequest = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eInvalidResponse)
        k_eInvalidResponse = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse.k_eAlreadyResponded)
        k_eAlreadyResponded = 12,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eLobbyNotFound),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                7 => ::std::option::Option::Some(EResponse::k_eCoachNotInLobby),
                8 => ::std::option::Option::Some(EResponse::k_ePlayerInvalidTeam),
                9 => ::std::option::Option::Some(EResponse::k_eCoachInvalidTeam),
                10 => ::std::option::Option::Some(EResponse::k_eNoRequest),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidResponse),
                12 => ::std::option::Option::Some(EResponse::k_eAlreadyResponded),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eLobbyNotFound" => ::std::option::Option::Some(EResponse::k_eLobbyNotFound),
                "k_eInvalidLobbyState" => ::std::option::Option::Some(EResponse::k_eInvalidLobbyState),
                "k_eCoachNotInLobby" => ::std::option::Option::Some(EResponse::k_eCoachNotInLobby),
                "k_ePlayerInvalidTeam" => ::std::option::Option::Some(EResponse::k_ePlayerInvalidTeam),
                "k_eCoachInvalidTeam" => ::std::option::Option::Some(EResponse::k_eCoachInvalidTeam),
                "k_eNoRequest" => ::std::option::Option::Some(EResponse::k_eNoRequest),
                "k_eInvalidResponse" => ::std::option::Option::Some(EResponse::k_eInvalidResponse),
                "k_eAlreadyResponded" => ::std::option::Option::Some(EResponse::k_eAlreadyResponded),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eLobbyNotFound,
            EResponse::k_eInvalidLobbyState,
            EResponse::k_eCoachNotInLobby,
            EResponse::k_ePlayerInvalidTeam,
            EResponse::k_eCoachInvalidTeam,
            EResponse::k_eNoRequest,
            EResponse::k_eInvalidResponse,
            EResponse::k_eAlreadyResponded,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRespondToCoachFriendRequestResponse.EResponse")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ECoachTeammateRating)
pub enum ECoachTeammateRating {
    // @@protoc_insertion_point(enum_value:dota.ECoachTeammateRating.k_ECoachTeammateRating_None)
    k_ECoachTeammateRating_None = 0,
    // @@protoc_insertion_point(enum_value:dota.ECoachTeammateRating.k_ECoachTeammateRating_Positive)
    k_ECoachTeammateRating_Positive = 1,
    // @@protoc_insertion_point(enum_value:dota.ECoachTeammateRating.k_ECoachTeammateRating_Negative)
    k_ECoachTeammateRating_Negative = 2,
    // @@protoc_insertion_point(enum_value:dota.ECoachTeammateRating.k_ECoachTeammateRating_Abusive)
    k_ECoachTeammateRating_Abusive = 3,
}

impl ::protobuf::Enum for ECoachTeammateRating {
    const NAME: &'static str = "ECoachTeammateRating";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECoachTeammateRating> {
        match value {
            0 => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_None),
            1 => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_Positive),
            2 => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_Negative),
            3 => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_Abusive),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECoachTeammateRating> {
        match str {
            "k_ECoachTeammateRating_None" => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_None),
            "k_ECoachTeammateRating_Positive" => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_Positive),
            "k_ECoachTeammateRating_Negative" => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_Negative),
            "k_ECoachTeammateRating_Abusive" => ::std::option::Option::Some(ECoachTeammateRating::k_ECoachTeammateRating_Abusive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECoachTeammateRating] = &[
        ECoachTeammateRating::k_ECoachTeammateRating_None,
        ECoachTeammateRating::k_ECoachTeammateRating_Positive,
        ECoachTeammateRating::k_ECoachTeammateRating_Negative,
        ECoachTeammateRating::k_ECoachTeammateRating_Abusive,
    ];
}

impl ::protobuf::EnumFull for ECoachTeammateRating {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECoachTeammateRating").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECoachTeammateRating {
    fn default() -> Self {
        ECoachTeammateRating::k_ECoachTeammateRating_None
    }
}

impl ECoachTeammateRating {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECoachTeammateRating>("ECoachTeammateRating")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EPrivateCoachingSessionState)
pub enum EPrivateCoachingSessionState {
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionState.k_ePrivateCoachingSessionState_Invalid)
    k_ePrivateCoachingSessionState_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionState.k_ePrivateCoachingSessionState_SearchingForCoach)
    k_ePrivateCoachingSessionState_SearchingForCoach = 1,
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionState.k_ePrivateCoachingSessionState_CoachAssigned)
    k_ePrivateCoachingSessionState_CoachAssigned = 2,
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionState.k_ePrivateCoachingSessionState_Finished)
    k_ePrivateCoachingSessionState_Finished = 3,
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionState.k_ePrivateCoachingSessionState_Expired)
    k_ePrivateCoachingSessionState_Expired = 4,
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionState.k_ePrivateCoachingSessionState_Abandoned)
    k_ePrivateCoachingSessionState_Abandoned = 5,
}

impl ::protobuf::Enum for EPrivateCoachingSessionState {
    const NAME: &'static str = "EPrivateCoachingSessionState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPrivateCoachingSessionState> {
        match value {
            0 => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Invalid),
            1 => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_SearchingForCoach),
            2 => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_CoachAssigned),
            3 => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Finished),
            4 => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Expired),
            5 => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Abandoned),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPrivateCoachingSessionState> {
        match str {
            "k_ePrivateCoachingSessionState_Invalid" => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Invalid),
            "k_ePrivateCoachingSessionState_SearchingForCoach" => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_SearchingForCoach),
            "k_ePrivateCoachingSessionState_CoachAssigned" => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_CoachAssigned),
            "k_ePrivateCoachingSessionState_Finished" => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Finished),
            "k_ePrivateCoachingSessionState_Expired" => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Expired),
            "k_ePrivateCoachingSessionState_Abandoned" => ::std::option::Option::Some(EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Abandoned),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPrivateCoachingSessionState] = &[
        EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Invalid,
        EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_SearchingForCoach,
        EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_CoachAssigned,
        EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Finished,
        EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Expired,
        EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Abandoned,
    ];
}

impl ::protobuf::EnumFull for EPrivateCoachingSessionState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPrivateCoachingSessionState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPrivateCoachingSessionState {
    fn default() -> Self {
        EPrivateCoachingSessionState::k_ePrivateCoachingSessionState_Invalid
    }
}

impl EPrivateCoachingSessionState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPrivateCoachingSessionState>("EPrivateCoachingSessionState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EPrivateCoachingSessionMemberFlag)
pub enum EPrivateCoachingSessionMemberFlag {
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionMemberFlag.k_EPrivateCoachingSessionMemberFlag_Requester)
    k_EPrivateCoachingSessionMemberFlag_Requester = 1,
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionMemberFlag.k_EPrivateCoachingSessionMemberFlag_Coach)
    k_EPrivateCoachingSessionMemberFlag_Coach = 2,
    // @@protoc_insertion_point(enum_value:dota.EPrivateCoachingSessionMemberFlag.k_EPrivateCoachingSessionMemberFlag_LeftSession)
    k_EPrivateCoachingSessionMemberFlag_LeftSession = 4,
}

impl ::protobuf::Enum for EPrivateCoachingSessionMemberFlag {
    const NAME: &'static str = "EPrivateCoachingSessionMemberFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPrivateCoachingSessionMemberFlag> {
        match value {
            1 => ::std::option::Option::Some(EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Requester),
            2 => ::std::option::Option::Some(EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Coach),
            4 => ::std::option::Option::Some(EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_LeftSession),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPrivateCoachingSessionMemberFlag> {
        match str {
            "k_EPrivateCoachingSessionMemberFlag_Requester" => ::std::option::Option::Some(EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Requester),
            "k_EPrivateCoachingSessionMemberFlag_Coach" => ::std::option::Option::Some(EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Coach),
            "k_EPrivateCoachingSessionMemberFlag_LeftSession" => ::std::option::Option::Some(EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_LeftSession),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPrivateCoachingSessionMemberFlag] = &[
        EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Requester,
        EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Coach,
        EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_LeftSession,
    ];
}

impl ::protobuf::EnumFull for EPrivateCoachingSessionMemberFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPrivateCoachingSessionMemberFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Requester => 0,
            EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Coach => 1,
            EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_LeftSession => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EPrivateCoachingSessionMemberFlag {
    fn default() -> Self {
        EPrivateCoachingSessionMemberFlag::k_EPrivateCoachingSessionMemberFlag_Requester
    }
}

impl EPrivateCoachingSessionMemberFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPrivateCoachingSessionMemberFlag>("EPrivateCoachingSessionMemberFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EPlayerCoachMatchFlag)
pub enum EPlayerCoachMatchFlag {
    // @@protoc_insertion_point(enum_value:dota.EPlayerCoachMatchFlag.k_EPlayerCoachMatchFlag_EligibleForRewards)
    k_EPlayerCoachMatchFlag_EligibleForRewards = 1,
    // @@protoc_insertion_point(enum_value:dota.EPlayerCoachMatchFlag.k_EPlayerCoachMatchFlag_PrivateCoach)
    k_EPlayerCoachMatchFlag_PrivateCoach = 2,
}

impl ::protobuf::Enum for EPlayerCoachMatchFlag {
    const NAME: &'static str = "EPlayerCoachMatchFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlayerCoachMatchFlag> {
        match value {
            1 => ::std::option::Option::Some(EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_EligibleForRewards),
            2 => ::std::option::Option::Some(EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_PrivateCoach),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPlayerCoachMatchFlag> {
        match str {
            "k_EPlayerCoachMatchFlag_EligibleForRewards" => ::std::option::Option::Some(EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_EligibleForRewards),
            "k_EPlayerCoachMatchFlag_PrivateCoach" => ::std::option::Option::Some(EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_PrivateCoach),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPlayerCoachMatchFlag] = &[
        EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_EligibleForRewards,
        EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_PrivateCoach,
    ];
}

impl ::protobuf::EnumFull for EPlayerCoachMatchFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPlayerCoachMatchFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_EligibleForRewards => 0,
            EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_PrivateCoach => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EPlayerCoachMatchFlag {
    fn default() -> Self {
        EPlayerCoachMatchFlag::k_EPlayerCoachMatchFlag_EligibleForRewards
    }
}

impl EPlayerCoachMatchFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPlayerCoachMatchFlag>("EPlayerCoachMatchFlag")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%dota_gcmessages_client_coaching.proto\x12\x04dota\x1a\x17dota_shared_\
    enums.proto\x1a\"dota_gcmessages_common_lobby.proto\"\xb1\x02\n\x14CMsgP\
    layerCoachMatch\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\
    \x128\n\rmatch_outcome\x18\x02\x20\x01(\x0e2\x13.dota.EMatchOutcomeR\x0c\
    matchOutcome\x12!\n\x0ccoached_team\x18\x03\x20\x01(\rR\x0bcoachedTeam\
    \x12\x1d\n\nstart_time\x18\x04\x20\x01(\x07R\tstartTime\x12\x1a\n\x08dur\
    ation\x18\x05\x20\x01(\rR\x08duration\x12E\n\x10teammate_ratings\x18\x06\
    \x20\x03(\x0e2\x1a.dota.ECoachTeammateRatingR\x0fteammateRatings\x12\x1f\
    \n\x0bcoach_flags\x18\x07\x20\x01(\rR\ncoachFlags\"\xb4\x01\n\x20CMsgPri\
    vateCoachingSessionMember\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tacc\
    ountId\x12!\n\x0cmember_flags\x18\x02\x20\x01(\rR\x0bmemberFlags\x12N\n\
    \x15member_session_rating\x18\x03\x20\x01(\x0e2\x1a.dota.ECoachTeammateR\
    atingR\x13memberSessionRating\"\xa7\x04\n\x1aCMsgPrivateCoachingSession\
    \x12=\n\x1bprivate_coaching_session_id\x18\x01\x20\x01(\x04R\x18privateC\
    oachingSessionId\x12/\n\x13requested_timestamp\x18\x02\x20\x01(\x07R\x12\
    requestedTimestamp\x12-\n\x12requested_language\x18\x03\x20\x01(\rR\x11r\
    equestedLanguage\x12X\n\x16coaching_session_state\x18\x04\x20\x01(\x0e2\
    \".dota.EPrivateCoachingSessionStateR\x14coachingSessionState\x12O\n\x0f\
    session_members\x18\x05\x20\x03(\x0b2&.dota.CMsgPrivateCoachingSessionMe\
    mberR\x0esessionMembers\x12(\n\x10current_lobby_id\x18\x06\x20\x01(\x04R\
    \x0ecurrentLobbyId\x125\n\x17current_server_steam_id\x18\x07\x20\x01(\
    \x04R\x14currentServerSteamId\x12-\n\x12accepted_timestamp\x18\x08\x20\
    \x01(\x07R\x11acceptedTimestamp\x12/\n\x13completed_timestamp\x18\t\x20\
    \x01(\x07R\x12completedTimestamp\"\x9f\x01\n\x20CMsgPrivateCoachingSessi\
    onStatus\x12E\n\x1frequester_competitive_rank_tier\x18\x01\x20\x01(\rR\
    \x1crequesterCompetitiveRankTier\x124\n\x16requester_games_played\x18\
    \x02\x20\x01(\rR\x14requesterGamesPlayed\"\xd2\x01\n#CMsgAvailablePrivat\
    eCoachingSession\x12K\n\x10coaching_session\x18\x01\x20\x01(\x0b2\x20.do\
    ta.CMsgPrivateCoachingSessionR\x0fcoachingSession\x12^\n\x17coaching_ses\
    sion_status\x18\x02\x20\x01(\x0b2&.dota.CMsgPrivateCoachingSessionStatus\
    R\x15coachingSessionStatus\"\x94\x01\n'CMsgAvailablePrivateCoachingSessi\
    onList\x12i\n\x1bavailable_coaching_sessions\x18\x01\x20\x03(\x0b2).dota\
    .CMsgAvailablePrivateCoachingSessionR\x19availableCoachingSessions\"b\n*\
    CMsgAvailablePrivateCoachingSessionSummary\x124\n\x16coaching_session_co\
    unt\x18\x01\x20\x01(\rR\x14coachingSessionCount\")\n'CMsgClientToGCReque\
    stPlayerCoachMatches\"\x9f\x02\n/CMsgClientToGCRequestPlayerCoachMatches\
    Response\x12W\n\x06result\x18\x01\x20\x01(\x0e2?.dota.CMsgClientToGCRequ\
    estPlayerCoachMatchesResponse.EResponseR\x06result\x12?\n\rcoach_matches\
    \x18\x02\x20\x03(\x0b2\x1a.dota.CMsgPlayerCoachMatchR\x0ccoachMatches\"R\
    \n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\
    \x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\
    \"B\n%CMsgClientToGCRequestPlayerCoachMatch\x12\x19\n\x08match_id\x18\
    \x01\x20\x01(\x04R\x07matchId\"\x97\x02\n-CMsgClientToGCRequestPlayerCoa\
    chMatchResponse\x12U\n\x06result\x18\x01\x20\x01(\x0e2=.dota.CMsgClientT\
    oGCRequestPlayerCoachMatchResponse.EResponseR\x06result\x12;\n\x0bcoach_\
    match\x18\x02\x20\x01(\x0b2\x1a.dota.CMsgPlayerCoachMatchR\ncoachMatch\"\
    R\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\
    \x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\
    \"\xba\x01\n'CMsgClientToGCSubmitCoachTeammateRating\x12\x19\n\x08match_\
    id\x18\x01\x20\x01(\x04R\x07matchId\x12(\n\x10coach_account_id\x18\x02\
    \x20\x01(\rR\x0ecoachAccountId\x122\n\x06rating\x18\x03\x20\x01(\x0e2\
    \x1a.dota.ECoachTeammateRatingR\x06rating\x12\x16\n\x06reason\x18\x04\
    \x20\x01(\tR\x06reason\"\xac\x03\n/CMsgClientToGCSubmitCoachTeammateRati\
    ngResponse\x12W\n\x06result\x18\x01\x20\x01(\x0e2?.dota.CMsgClientToGCSu\
    bmitCoachTeammateRatingResponse.EResponseR\x06result\"\x9f\x02\n\tERespo\
    nse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\
    \x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x13\
    \n\x0fk_eInvalidInput\x10\x04\x12\x17\n\x13k_eAlreadySubmitted\x10\x05\
    \x12\x15\n\x11k_eVotingFinished\x10\x06\x12\x17\n\x13k_ePlayerNotInMatch\
    \x10\x07\x12\x16\n\x12k_eCoachNotInMatch\x10\x08\x12\x1b\n\x17k_ePlayerN\
    otOnCoachTeam\x10\t\x12\x1f\n\x1bk_ePlayerInSamePartyAsCoach\x10\n\x12\
    \x17\n\x13k_eMatchNotEligible\x10\x0b\"h\n)CMsgGCToClientCoachTeammateRa\
    tingsChanged\x12;\n\x0bcoach_match\x18\x01\x20\x01(\x0b2\x1a.dota.CMsgPl\
    ayerCoachMatchR\ncoachMatch\"I\n+CMsgClientToGCRequestPrivateCoachingSes\
    sion\x12\x1a\n\x08language\x18\x01\x20\x01(\rR\x08language\"\x98\x04\n3C\
    MsgClientToGCRequestPrivateCoachingSessionResponse\x12[\n\x06result\x18\
    \x01\x20\x01(\x0e2C.dota.CMsgClientToGCRequestPrivateCoachingSessionResp\
    onse.EResponseR\x06result\x12K\n\x10coaching_session\x18\x02\x20\x01(\
    \x0b2\x20.dota.CMsgPrivateCoachingSessionR\x0fcoachingSession\"\xb6\x02\
    \n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\
    \x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\
    \x12\x0e\n\nk_eTimeout\x10\x04\x12\x17\n\x13k_eAlreadyInSession\x10\x05\
    \x12\x1a\n\x16k_eBehaviorScoreTooLow\x10\x06\x12\x17\n\x13k_eInvalidLobb\
    yType\x10\x07\x12\x18\n\x14k_eLowPriorityPlayer\x10\x08\x12\x17\n\x13k_e\
    LowPriorityLobby\x10\t\x12\x17\n\x13k_eLowPriorityParty\x10\n\x12\x12\n\
    \x0ek_eTextChatBan\x10\x0b\x12\x13\n\x0fk_eVoiceChatBan\x10\x0c\x12\x0f\
    \n\x0bk_eMatchBan\x10\r\"\\\n*CMsgClientToGCAcceptPrivateCoachingSession\
    \x12.\n\x13coaching_session_id\x18\x01\x20\x01(\x04R\x11coachingSessionI\
    d\"\xea\x05\n2CMsgClientToGCAcceptPrivateCoachingSessionResponse\x12Z\n\
    \x06result\x18\x01\x20\x01(\x0e2B.dota.CMsgClientToGCAcceptPrivateCoachi\
    ngSessionResponse.EResponseR\x06result\x12K\n\x10coaching_session\x18\
    \x02\x20\x01(\x0b2\x20.dota.CMsgPrivateCoachingSessionR\x0fcoachingSessi\
    on\"\x8a\x04\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\
    \nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisab\
    led\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x15\n\x11k_eUnknownSession\
    \x10\x05\x12\x16\n\x12k_eAlreadyHasCoach\x10\x06\x12\x18\n\x14k_eAlready\
    HasSession\x10\x07\x12\x12\n\x0ek_eInvalidUser\x10\x08\x12\x16\n\x12k_eA\
    lreadyFinished\x10\t\x12\x17\n\x13k_eInvalidLobbyType\x10\n\x12\x15\n\
    \x11k_eAlreadyInLobby\x10\x0b\x12\x11\n\rk_eLobbyIsLan\x10\x0c\x12\x14\n\
    \x10k_eLobbyIsLeague\x10\r\x12\x18\n\x14k_eInvalidLobbyState\x10\x0e\x12\
    \x1b\n\x17k_eRequesterIsNotPlayer\x10\x0f\x12\x15\n\x11k_eTooManyCoaches\
    \x10\x10\x12\x15\n\x11k_eCoachWasPlayer\x10\x11\x12\x1f\n\x1bk_eCoachBeh\
    aviorScoreTooLow\x10\x12\x12\x1d\n\x19k_eCoachRankNotCalibrated\x10\x13\
    \x12\x1b\n\x17k_eCoachRankNotEligible\x10\x14\x12\x16\n\x12k_eCoachRankT\
    ooLow\x10\x15\"+\n)CMsgClientToGCLeavePrivateCoachingSession\"\x99\x02\n\
    1CMsgClientToGCLeavePrivateCoachingSessionResponse\x12Y\n\x06result\x18\
    \x01\x20\x01(\x0e2A.dota.CMsgClientToGCLeavePrivateCoachingSessionRespon\
    se.EResponseR\x06result\"\x88\x01\n\tEResponse\x12\x14\n\x10k_eInternalE\
    rror\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\
    \x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x10\
    \n\x0ck_eNoSession\x10\x05\x12\x12\n\x0ek_eAlreadyLeft\x10\x06\"0\n.CMsg\
    ClientToGCGetCurrentPrivateCoachingSession\"\xc7\x02\n6CMsgClientToGCGet\
    CurrentPrivateCoachingSessionResponse\x12^\n\x06result\x18\x01\x20\x01(\
    \x0e2F.dota.CMsgClientToGCGetCurrentPrivateCoachingSessionResponse.EResp\
    onseR\x06result\x12I\n\x0fcurrent_session\x18\x02\x20\x01(\x0b2\x20.dota\
    .CMsgPrivateCoachingSessionR\x0ecurrentSession\"b\n\tEResponse\x12\x14\n\
    \x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eT\
    ooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\
    \x10\x04\"z\n+CMsgGCToClientPrivateCoachingSessionUpdated\x12K\n\x10coac\
    hing_session\x18\x01\x20\x01(\x0b2\x20.dota.CMsgPrivateCoachingSessionR\
    \x0fcoachingSession\"\xa5\x01\n0CMsgClientToGCSubmitPrivateCoachingSessi\
    onRating\x12.\n\x13coaching_session_id\x18\x01\x20\x01(\x04R\x11coaching\
    SessionId\x12A\n\x0esession_rating\x18\x02\x20\x01(\x0e2\x1a.dota.ECoach\
    TeammateRatingR\rsessionRating\"\x97\x03\n8CMsgClientToGCSubmitPrivateCo\
    achingSessionRatingResponse\x12`\n\x06result\x18\x01\x20\x01(\x0e2H.dota\
    .CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse.EResponseR\x06\
    result\"\xf8\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\
    \x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_\
    eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x15\n\x11k_eUnknownS\
    ession\x10\x05\x12\x10\n\x0ck_eNotMember\x10\x06\x12\x17\n\x13k_eAlready\
    Submitted\x10\x07\x12\x14\n\x10k_eSessionActive\x10\x08\x12\x16\n\x12k_e\
    SessionTooShort\x10\t\x12\x0e\n\nk_eNoCoach\x10\n\x12\x14\n\x10k_eInvali\
    dRating\x10\x0b\"O\n1CMsgClientToGCGetAvailablePrivateCoachingSessions\
    \x12\x1a\n\x08language\x18\x01\x20\x01(\rR\x08language\"\xe9\x02\n9CMsgC\
    lientToGCGetAvailablePrivateCoachingSessionsResponse\x12a\n\x06result\
    \x18\x01\x20\x01(\x0e2I.dota.CMsgClientToGCGetAvailablePrivateCoachingSe\
    ssionsResponse.EResponseR\x06result\x12e\n\x17available_sessions_list\
    \x18\x02\x20\x01(\x0b2-.dota.CMsgAvailablePrivateCoachingSessionListR\
    \x15availableSessionsList\"b\n\tEResponse\x12\x14\n\x10k_eInternalError\
    \x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\
    \x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\":\n8CMsgCli\
    entToGCGetAvailablePrivateCoachingSessionsSummary\"\xfc\x02\n@CMsgClient\
    ToGCGetAvailablePrivateCoachingSessionsSummaryResponse\x12h\n\x06result\
    \x18\x01\x20\x01(\x0e2P.dota.CMsgClientToGCGetAvailablePrivateCoachingSe\
    ssionsSummaryResponse.EResponseR\x06result\x12j\n\x18coaching_session_su\
    mmary\x18\x02\x20\x01(\x0b20.dota.CMsgAvailablePrivateCoachingSessionSum\
    maryR\x16coachingSessionSummary\"b\n\tEResponse\x12\x14\n\x10k_eInternal\
    Error\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\
    \x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\"/\n-CMs\
    gClientToGCJoinPrivateCoachingSessionLobby\"\xc4\x04\n5CMsgClientToGCJoi\
    nPrivateCoachingSessionLobbyResponse\x12]\n\x06result\x18\x01\x20\x01(\
    \x0e2E.dota.CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse.ERespo\
    nseR\x06result\"\xab\x03\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\
    \0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\
    \x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x10\n\x0ck_eNo\
    Session\x10\x05\x12\x16\n\x12k_eSessionFinished\x10\x06\x12\x12\n\x0ek_e\
    AlreadyLeft\x10\x07\x12\x10\n\x0ck_eNotACoach\x10\x08\x12\x0e\n\nk_eNoLo\
    bby\x10\t\x12\x17\n\x13k_eCoachInThisLobby\x10\n\x12\x14\n\x10k_eCoachIn\
    ALobby\x10\x0b\x12\x11\n\rk_eLobbyIsLan\x10\x0c\x12\x14\n\x10k_eLobbyIsL\
    eague\x10\r\x12\x17\n\x13k_eInvalidLobbyType\x10\x0e\x12\x18\n\x14k_eInv\
    alidLobbyState\x10\x0f\x12\x1b\n\x17k_eRequesterIsNotPlayer\x10\x10\x12\
    \x15\n\x11k_eTooManyCoaches\x10\x11\x12\x15\n\x11k_eCoachWasPlayer\x10\
    \x12\x12\x11\n\rk_eJoinFailed\x10\x13\"G\n\x19CMsgClientToGCCoachFriend\
    \x12*\n\x11target_account_id\x18\x01\x20\x01(\rR\x0ftargetAccountId\"\
    \xb9\x04\n!CMsgClientToGCCoachFriendResponse\x12I\n\x06result\x18\x01\
    \x20\x01(\x0e21.dota.CMsgClientToGCCoachFriendResponse.EResponseR\x06res\
    ult\"\xc8\x03\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\
    \nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisab\
    led\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x19\n\x15k_eCoachNotSubscr\
    iber\x10\x05\x12\x14\n\x10k_eLobbyNotFound\x10\x06\x12\x19\n\x15k_eFrien\
    dsOnBothSides\x10\x07\x12\x11\n\rk_eNotFriends\x10\x08\x12\x17\n\x13k_eC\
    oachInThisLobby\x10\t\x12\x14\n\x10k_eCoachInALobby\x10\n\x12\x11\n\rk_e\
    LobbyIsLan\x10\x0b\x12\x17\n\x13k_eInvalidLobbyType\x10\x0c\x12\x18\n\
    \x14k_eInvalidLobbyState\x10\r\x12\x19\n\x15k_eFriendIsNotAPlayer\x10\
    \x0e\x12\x15\n\x11k_eTooManyCoaches\x10\x0f\x12\x19\n\x15k_eCoachSwitche\
    dTeams\x10\x10\x12\x14\n\x10k_eLobbyIsLeague\x10\x11\x12\x15\n\x11k_eCoa\
    chWasPlayer\x10\x12\x12\x16\n\x12k_eRequestRejected\x10\x13\"\x96\x01\n)\
    CMsgClientToGCRespondToCoachFriendRequest\x12(\n\x10coach_account_id\x18\
    \x01\x20\x01(\rR\x0ecoachAccountId\x12?\n\x08response\x18\x02\x20\x01(\
    \x0e2#.dota.ELobbyMemberCoachRequestStateR\x08response\"\xb1\x03\n1CMsgC\
    lientToGCRespondToCoachFriendRequestResponse\x12Y\n\x06result\x18\x01\
    \x20\x01(\x0e2A.dota.CMsgClientToGCRespondToCoachFriendRequestResponse.E\
    ResponseR\x06result\"\xa0\x02\n\tEResponse\x12\x14\n\x10k_eInternalError\
    \x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\
    \x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x14\n\
    \x10k_eLobbyNotFound\x10\x05\x12\x18\n\x14k_eInvalidLobbyState\x10\x06\
    \x12\x16\n\x12k_eCoachNotInLobby\x10\x07\x12\x18\n\x14k_ePlayerInvalidTe\
    am\x10\x08\x12\x17\n\x13k_eCoachInvalidTeam\x10\t\x12\x10\n\x0ck_eNoRequ\
    est\x10\n\x12\x16\n\x12k_eInvalidResponse\x10\x0b\x12\x17\n\x13k_eAlread\
    yResponded\x10\x0c*\xa5\x01\n\x14ECoachTeammateRating\x12\x1f\n\x1bk_ECo\
    achTeammateRating_None\x10\0\x12#\n\x1fk_ECoachTeammateRating_Positive\
    \x10\x01\x12#\n\x1fk_ECoachTeammateRating_Negative\x10\x02\x12\"\n\x1ek_\
    ECoachTeammateRating_Abusive\x10\x03*\xb9\x02\n\x1cEPrivateCoachingSessi\
    onState\x12*\n&k_ePrivateCoachingSessionState_Invalid\x10\0\x124\n0k_ePr\
    ivateCoachingSessionState_SearchingForCoach\x10\x01\x120\n,k_ePrivateCoa\
    chingSessionState_CoachAssigned\x10\x02\x12+\n'k_ePrivateCoachingSession\
    State_Finished\x10\x03\x12*\n&k_ePrivateCoachingSessionState_Expired\x10\
    \x04\x12,\n(k_ePrivateCoachingSessionState_Abandoned\x10\x05*\xba\x01\n!\
    EPrivateCoachingSessionMemberFlag\x121\n-k_EPrivateCoachingSessionMember\
    Flag_Requester\x10\x01\x12-\n)k_EPrivateCoachingSessionMemberFlag_Coach\
    \x10\x02\x123\n/k_EPrivateCoachingSessionMemberFlag_LeftSession\x10\x04*\
    q\n\x15EPlayerCoachMatchFlag\x12.\n*k_EPlayerCoachMatchFlag_EligibleForR\
    ewards\x10\x01\x12(\n$k_EPlayerCoachMatchFlag_PrivateCoach\x10\x02B%Z#gi\
    thub.com/dotabuff/manta/dota;dotaJ\x94i\n\x07\x12\x05\0\0\xfc\x02\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\
    \n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\
    \0\x12\x03\x05\x07\x20\n\t\n\x02\x03\x01\x12\x03\x06\x07+\n\n\n\x02\x05\
    \0\x12\x04\x08\0\r\x01\n\n\n\x03\x05\0\x01\x12\x03\x08\x05\x19\n\x0b\n\
    \x04\x05\0\x02\0\x12\x03\t\x08(\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\t\
    \x08#\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t&'\n\x0b\n\x04\x05\0\x02\x01\
    \x12\x03\n\x08,\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\n\x08'\n\x0c\n\x05\
    \x05\0\x02\x01\x02\x12\x03\n*+\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0b\x08\
    ,\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0b\x08'\n\x0c\n\x05\x05\0\x02\
    \x02\x02\x12\x03\x0b*+\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x0c\x08+\n\x0c\
    \n\x05\x05\0\x02\x03\x01\x12\x03\x0c\x08&\n\x0c\n\x05\x05\0\x02\x03\x02\
    \x12\x03\x0c)*\n\n\n\x02\x05\x01\x12\x04\x0f\0\x16\x01\n\n\n\x03\x05\x01\
    \x01\x12\x03\x0f\x05!\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x10\x083\n\x0c\n\
    \x05\x05\x01\x02\0\x01\x12\x03\x10\x08.\n\x0c\n\x05\x05\x01\x02\0\x02\
    \x12\x03\x1012\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x11\x08=\n\x0c\n\x05\
    \x05\x01\x02\x01\x01\x12\x03\x11\x088\n\x0c\n\x05\x05\x01\x02\x01\x02\
    \x12\x03\x11;<\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x12\x089\n\x0c\n\x05\
    \x05\x01\x02\x02\x01\x12\x03\x12\x084\n\x0c\n\x05\x05\x01\x02\x02\x02\
    \x12\x03\x1278\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x13\x084\n\x0c\n\x05\
    \x05\x01\x02\x03\x01\x12\x03\x13\x08/\n\x0c\n\x05\x05\x01\x02\x03\x02\
    \x12\x03\x1323\n\x0b\n\x04\x05\x01\x02\x04\x12\x03\x14\x083\n\x0c\n\x05\
    \x05\x01\x02\x04\x01\x12\x03\x14\x08.\n\x0c\n\x05\x05\x01\x02\x04\x02\
    \x12\x03\x1412\n\x0b\n\x04\x05\x01\x02\x05\x12\x03\x15\x085\n\x0c\n\x05\
    \x05\x01\x02\x05\x01\x12\x03\x15\x080\n\x0c\n\x05\x05\x01\x02\x05\x02\
    \x12\x03\x1534\n\n\n\x02\x05\x02\x12\x04\x18\0\x1c\x01\n\n\n\x03\x05\x02\
    \x01\x12\x03\x18\x05&\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x19\x08:\n\x0c\n\
    \x05\x05\x02\x02\0\x01\x12\x03\x19\x085\n\x0c\n\x05\x05\x02\x02\0\x02\
    \x12\x03\x1989\n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x1a\x086\n\x0c\n\x05\
    \x05\x02\x02\x01\x01\x12\x03\x1a\x081\n\x0c\n\x05\x05\x02\x02\x01\x02\
    \x12\x03\x1a45\n\x0b\n\x04\x05\x02\x02\x02\x12\x03\x1b\x08<\n\x0c\n\x05\
    \x05\x02\x02\x02\x01\x12\x03\x1b\x087\n\x0c\n\x05\x05\x02\x02\x02\x02\
    \x12\x03\x1b:;\n\n\n\x02\x05\x03\x12\x04\x1e\0!\x01\n\n\n\x03\x05\x03\
    \x01\x12\x03\x1e\x05\x1a\n\x0b\n\x04\x05\x03\x02\0\x12\x03\x1f\x087\n\
    \x0c\n\x05\x05\x03\x02\0\x01\x12\x03\x1f\x082\n\x0c\n\x05\x05\x03\x02\0\
    \x02\x12\x03\x1f56\n\x0b\n\x04\x05\x03\x02\x01\x12\x03\x20\x081\n\x0c\n\
    \x05\x05\x03\x02\x01\x01\x12\x03\x20\x08,\n\x0c\n\x05\x05\x03\x02\x01\
    \x02\x12\x03\x20/0\n\n\n\x02\x04\0\x12\x04#\0+\x01\n\n\n\x03\x04\0\x01\
    \x12\x03#\x08\x1c\n\x0b\n\x04\x04\0\x02\0\x12\x03$\x08%\n\x0c\n\x05\x04\
    \0\x02\0\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03$\x11\
    \x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03$\x18\x20\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03$#$\n\x0b\n\x04\x04\0\x02\x01\x12\x03%\x081\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03%\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x06\x12\
    \x03%\x11\x1e\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03%\x1f,\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03%/0\n\x0b\n\x04\x04\0\x02\x02\x12\x03&\x08)\n\
    \x0c\n\x05\x04\0\x02\x02\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03&\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03&\x18$\n\x0c\
    \n\x05\x04\0\x02\x02\x03\x12\x03&'(\n\x0b\n\x04\x04\0\x02\x03\x12\x03'\
    \x08(\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\0\
    \x02\x03\x05\x12\x03'\x11\x18\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03'\x19\
    #\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03'&'\n\x0b\n\x04\x04\0\x02\x04\x12\
    \x03(\x08%\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03(\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x04\x05\x12\x03(\x11\x17\n\x0c\n\x05\x04\0\x02\x04\x01\x12\
    \x03(\x18\x20\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03(#$\n\x0b\n\x04\x04\0\
    \x02\x05\x12\x03)\x08;\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03)\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x05\x06\x12\x03)\x11%\n\x0c\n\x05\x04\0\x02\x05\x01\
    \x12\x03)&6\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03)9:\n\x0b\n\x04\x04\0\
    \x02\x06\x12\x03*\x08(\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03*\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x06\x05\x12\x03*\x11\x17\n\x0c\n\x05\x04\0\x02\x06\
    \x01\x12\x03*\x18#\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03*&'\n\n\n\x02\
    \x04\x01\x12\x04-\01\x01\n\n\n\x03\x04\x01\x01\x12\x03-\x08(\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03.\x08'\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03.\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03.\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03.\x18\"\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03.%&\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03/\x08)\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03/\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03/\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03/\x18$\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03/'(\n\x0b\n\x04\x04\x01\x02\x02\x12\x030\x08@\n\x0c\n\x05\x04\
    \x01\x02\x02\x04\x12\x030\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\
    \x030\x11%\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x030&;\n\x0c\n\x05\x04\
    \x01\x02\x02\x03\x12\x030>?\n\n\n\x02\x04\x02\x12\x043\0=\x01\n\n\n\x03\
    \x04\x02\x01\x12\x033\x08\"\n\x0b\n\x04\x04\x02\x02\0\x12\x034\x088\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x034\x08\x10\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x034\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x034\x183\n\x0c\
    \n\x05\x04\x02\x02\0\x03\x12\x03467\n\x0b\n\x04\x04\x02\x02\x01\x12\x035\
    \x081\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x035\x08\x10\n\x0c\n\x05\x04\
    \x02\x02\x01\x05\x12\x035\x11\x18\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x035\x19,\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x035/0\n\x0b\n\x04\x04\
    \x02\x02\x02\x12\x036\x08/\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x036\x08\
    \x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x036\x11\x17\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x036\x18*\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x036-\
    .\n\x0b\n\x04\x04\x02\x02\x03\x12\x037\x08I\n\x0c\n\x05\x04\x02\x02\x03\
    \x04\x12\x037\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x037\x11-\n\
    \x0c\n\x05\x04\x02\x02\x03\x01\x12\x037.D\n\x0c\n\x05\x04\x02\x02\x03\
    \x03\x12\x037GH\n\x0b\n\x04\x04\x02\x02\x04\x12\x038\x08F\n\x0c\n\x05\
    \x04\x02\x02\x04\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\x02\x02\x04\x06\
    \x12\x038\x111\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x0382A\n\x0c\n\x05\
    \x04\x02\x02\x04\x03\x12\x038DE\n\x0b\n\x04\x04\x02\x02\x05\x12\x039\x08\
    -\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x05\x05\x12\x039\x11\x17\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x039\
    \x18(\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x039+,\n\x0b\n\x04\x04\x02\x02\
    \x06\x12\x03:\x084\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\x03:\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x06\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\x02\x02\
    \x06\x01\x12\x03:\x18/\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03:23\n\x0b\
    \n\x04\x04\x02\x02\x07\x12\x03;\x080\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\
    \x03;\x08\x10\n\x0c\n\x05\x04\x02\x02\x07\x05\x12\x03;\x11\x18\n\x0c\n\
    \x05\x04\x02\x02\x07\x01\x12\x03;\x19+\n\x0c\n\x05\x04\x02\x02\x07\x03\
    \x12\x03;./\n\x0b\n\x04\x04\x02\x02\x08\x12\x03<\x081\n\x0c\n\x05\x04\
    \x02\x02\x08\x04\x12\x03<\x08\x10\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\
    \x03<\x11\x18\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03<\x19,\n\x0c\n\x05\
    \x04\x02\x02\x08\x03\x12\x03</0\n\n\n\x02\x04\x03\x12\x04?\0B\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03?\x08(\n\x0b\n\x04\x04\x03\x02\0\x12\x03@\x08<\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x03@\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03@\x187\n\x0c\
    \n\x05\x04\x03\x02\0\x03\x12\x03@:;\n\x0b\n\x04\x04\x03\x02\x01\x12\x03A\
    \x083\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x01\x05\x12\x03A\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\
    \x03A\x18.\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03A12\n\n\n\x02\x04\x04\
    \x12\x04D\0G\x01\n\n\n\x03\x04\x04\x01\x12\x03D\x08+\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03E\x08A\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03E\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\0\x06\x12\x03E\x11+\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03E,<\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03E?@\n\x0b\n\x04\x04\x04\
    \x02\x01\x12\x03F\x08N\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03F\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03F\x111\n\x0c\n\x05\x04\x04\x02\
    \x01\x01\x12\x03F2I\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03FLM\n\n\n\x02\
    \x04\x05\x12\x04I\0K\x01\n\n\n\x03\x04\x05\x01\x12\x03I\x08/\n\x0b\n\x04\
    \x04\x05\x02\0\x12\x03J\x08U\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03J\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03J\x114\n\x0c\n\x05\x04\x05\x02\
    \0\x01\x12\x03J5P\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03JST\n\n\n\x02\x04\
    \x06\x12\x04M\0O\x01\n\n\n\x03\x04\x06\x01\x12\x03M\x082\n\x0b\n\x04\x04\
    \x06\x02\0\x12\x03N\x083\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03N\x08\x10\
    \n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03N\x11\x17\n\x0c\n\x05\x04\x06\x02\
    \0\x01\x12\x03N\x18.\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03N12\n\n\n\x02\
    \x04\x07\x12\x04Q\0R\x01\n\n\n\x03\x04\x07\x01\x12\x03Q\x08/\n\n\n\x02\
    \x04\x08\x12\x04T\0^\x01\n\n\n\x03\x04\x08\x01\x12\x03T\x087\n\x0c\n\x04\
    \x04\x08\x04\0\x12\x04U\x08Z\t\n\x0c\n\x05\x04\x08\x04\0\x01\x12\x03U\r\
    \x16\n\r\n\x06\x04\x08\x04\0\x02\0\x12\x03V\x10%\n\x0e\n\x07\x04\x08\x04\
    \0\x02\0\x01\x12\x03V\x10\x20\n\x0e\n\x07\x04\x08\x04\0\x02\0\x02\x12\
    \x03V#$\n\r\n\x06\x04\x08\x04\0\x02\x01\x12\x03W\x10\x1f\n\x0e\n\x07\x04\
    \x08\x04\0\x02\x01\x01\x12\x03W\x10\x1a\n\x0e\n\x07\x04\x08\x04\0\x02\
    \x01\x02\x12\x03W\x1d\x1e\n\r\n\x06\x04\x08\x04\0\x02\x02\x12\x03X\x10\
    \x1f\n\x0e\n\x07\x04\x08\x04\0\x02\x02\x01\x12\x03X\x10\x1a\n\x0e\n\x07\
    \x04\x08\x04\0\x02\x02\x02\x12\x03X\x1d\x1e\n\r\n\x06\x04\x08\x04\0\x02\
    \x03\x12\x03Y\x10\x20\n\x0e\n\x07\x04\x08\x04\0\x02\x03\x01\x12\x03Y\x10\
    \x1b\n\x0e\n\x07\x04\x08\x04\0\x02\x03\x02\x12\x03Y\x1e\x1f\n\x0b\n\x04\
    \x04\x08\x02\0\x12\x03\\\x08V\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03\\\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03\\\x11J\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03\\KQ\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03\\TU\n\
    \x0b\n\x04\x04\x08\x02\x01\x12\x03]\x088\n\x0c\n\x05\x04\x08\x02\x01\x04\
    \x12\x03]\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03]\x11%\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03]&3\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\
    \x03]67\n\n\n\x02\x04\t\x12\x04`\0b\x01\n\n\n\x03\x04\t\x01\x12\x03`\x08\
    -\n\x0b\n\x04\x04\t\x02\0\x12\x03a\x08%\n\x0c\n\x05\x04\t\x02\0\x04\x12\
    \x03a\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03a\x11\x17\n\x0c\n\x05\
    \x04\t\x02\0\x01\x12\x03a\x18\x20\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03a#$\
    \n\n\n\x02\x04\n\x12\x04d\0n\x01\n\n\n\x03\x04\n\x01\x12\x03d\x085\n\x0c\
    \n\x04\x04\n\x04\0\x12\x04e\x08j\t\n\x0c\n\x05\x04\n\x04\0\x01\x12\x03e\
    \r\x16\n\r\n\x06\x04\n\x04\0\x02\0\x12\x03f\x10%\n\x0e\n\x07\x04\n\x04\0\
    \x02\0\x01\x12\x03f\x10\x20\n\x0e\n\x07\x04\n\x04\0\x02\0\x02\x12\x03f#$\
    \n\r\n\x06\x04\n\x04\0\x02\x01\x12\x03g\x10\x1f\n\x0e\n\x07\x04\n\x04\0\
    \x02\x01\x01\x12\x03g\x10\x1a\n\x0e\n\x07\x04\n\x04\0\x02\x01\x02\x12\
    \x03g\x1d\x1e\n\r\n\x06\x04\n\x04\0\x02\x02\x12\x03h\x10\x1f\n\x0e\n\x07\
    \x04\n\x04\0\x02\x02\x01\x12\x03h\x10\x1a\n\x0e\n\x07\x04\n\x04\0\x02\
    \x02\x02\x12\x03h\x1d\x1e\n\r\n\x06\x04\n\x04\0\x02\x03\x12\x03i\x10\x20\
    \n\x0e\n\x07\x04\n\x04\0\x02\x03\x01\x12\x03i\x10\x1b\n\x0e\n\x07\x04\n\
    \x04\0\x02\x03\x02\x12\x03i\x1e\x1f\n\x0b\n\x04\x04\n\x02\0\x12\x03l\x08\
    T\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\n\x02\0\
    \x06\x12\x03l\x11H\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03lIO\n\x0c\n\x05\
    \x04\n\x02\0\x03\x12\x03lRS\n\x0b\n\x04\x04\n\x02\x01\x12\x03m\x086\n\
    \x0c\n\x05\x04\n\x02\x01\x04\x12\x03m\x08\x10\n\x0c\n\x05\x04\n\x02\x01\
    \x06\x12\x03m\x11%\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03m&1\n\x0c\n\x05\
    \x04\n\x02\x01\x03\x12\x03m45\n\n\n\x02\x04\x0b\x12\x04p\0u\x01\n\n\n\
    \x03\x04\x0b\x01\x12\x03p\x08/\n\x0b\n\x04\x04\x0b\x02\0\x12\x03q\x08%\n\
    \x0c\n\x05\x04\x0b\x02\0\x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\
    \x05\x12\x03q\x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03q\x18\x20\n\
    \x0c\n\x05\x04\x0b\x02\0\x03\x12\x03q#$\n\x0b\n\x04\x04\x0b\x02\x01\x12\
    \x03r\x08-\n\x0c\n\x05\x04\x0b\x02\x01\x04\x12\x03r\x08\x10\n\x0c\n\x05\
    \x04\x0b\x02\x01\x05\x12\x03r\x11\x17\n\x0c\n\x05\x04\x0b\x02\x01\x01\
    \x12\x03r\x18(\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03r+,\n\x0b\n\x04\
    \x04\x0b\x02\x02\x12\x03s\x081\n\x0c\n\x05\x04\x0b\x02\x02\x04\x12\x03s\
    \x08\x10\n\x0c\n\x05\x04\x0b\x02\x02\x06\x12\x03s\x11%\n\x0c\n\x05\x04\
    \x0b\x02\x02\x01\x12\x03s&,\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03s/0\n\
    \x0b\n\x04\x04\x0b\x02\x03\x12\x03t\x08#\n\x0c\n\x05\x04\x0b\x02\x03\x04\
    \x12\x03t\x08\x10\n\x0c\n\x05\x04\x0b\x02\x03\x05\x12\x03t\x11\x17\n\x0c\
    \n\x05\x04\x0b\x02\x03\x01\x12\x03t\x18\x1e\n\x0c\n\x05\x04\x0b\x02\x03\
    \x03\x12\x03t!\"\n\x0b\n\x02\x04\x0c\x12\x05w\0\x88\x01\x01\n\n\n\x03\
    \x04\x0c\x01\x12\x03w\x087\n\r\n\x04\x04\x0c\x04\0\x12\x05x\x08\x85\x01\
    \t\n\x0c\n\x05\x04\x0c\x04\0\x01\x12\x03x\r\x16\n\r\n\x06\x04\x0c\x04\0\
    \x02\0\x12\x03y\x10%\n\x0e\n\x07\x04\x0c\x04\0\x02\0\x01\x12\x03y\x10\
    \x20\n\x0e\n\x07\x04\x0c\x04\0\x02\0\x02\x12\x03y#$\n\r\n\x06\x04\x0c\
    \x04\0\x02\x01\x12\x03z\x10\x1f\n\x0e\n\x07\x04\x0c\x04\0\x02\x01\x01\
    \x12\x03z\x10\x1a\n\x0e\n\x07\x04\x0c\x04\0\x02\x01\x02\x12\x03z\x1d\x1e\
    \n\r\n\x06\x04\x0c\x04\0\x02\x02\x12\x03{\x10\x1f\n\x0e\n\x07\x04\x0c\
    \x04\0\x02\x02\x01\x12\x03{\x10\x1a\n\x0e\n\x07\x04\x0c\x04\0\x02\x02\
    \x02\x12\x03{\x1d\x1e\n\r\n\x06\x04\x0c\x04\0\x02\x03\x12\x03|\x10\x20\n\
    \x0e\n\x07\x04\x0c\x04\0\x02\x03\x01\x12\x03|\x10\x1b\n\x0e\n\x07\x04\
    \x0c\x04\0\x02\x03\x02\x12\x03|\x1e\x1f\n\r\n\x06\x04\x0c\x04\0\x02\x04\
    \x12\x03}\x10$\n\x0e\n\x07\x04\x0c\x04\0\x02\x04\x01\x12\x03}\x10\x1f\n\
    \x0e\n\x07\x04\x0c\x04\0\x02\x04\x02\x12\x03}\"#\n\r\n\x06\x04\x0c\x04\0\
    \x02\x05\x12\x03~\x10(\n\x0e\n\x07\x04\x0c\x04\0\x02\x05\x01\x12\x03~\
    \x10#\n\x0e\n\x07\x04\x0c\x04\0\x02\x05\x02\x12\x03~&'\n\r\n\x06\x04\x0c\
    \x04\0\x02\x06\x12\x03\x7f\x10&\n\x0e\n\x07\x04\x0c\x04\0\x02\x06\x01\
    \x12\x03\x7f\x10!\n\x0e\n\x07\x04\x0c\x04\0\x02\x06\x02\x12\x03\x7f$%\n\
    \x0e\n\x06\x04\x0c\x04\0\x02\x07\x12\x04\x80\x01\x10(\n\x0f\n\x07\x04\
    \x0c\x04\0\x02\x07\x01\x12\x04\x80\x01\x10#\n\x0f\n\x07\x04\x0c\x04\0\
    \x02\x07\x02\x12\x04\x80\x01&'\n\x0e\n\x06\x04\x0c\x04\0\x02\x08\x12\x04\
    \x81\x01\x10'\n\x0f\n\x07\x04\x0c\x04\0\x02\x08\x01\x12\x04\x81\x01\x10\
    \"\n\x0f\n\x07\x04\x0c\x04\0\x02\x08\x02\x12\x04\x81\x01%&\n\x0e\n\x06\
    \x04\x0c\x04\0\x02\t\x12\x04\x82\x01\x10,\n\x0f\n\x07\x04\x0c\x04\0\x02\
    \t\x01\x12\x04\x82\x01\x10'\n\x0f\n\x07\x04\x0c\x04\0\x02\t\x02\x12\x04\
    \x82\x01*+\n\x0e\n\x06\x04\x0c\x04\0\x02\n\x12\x04\x83\x01\x101\n\x0f\n\
    \x07\x04\x0c\x04\0\x02\n\x01\x12\x04\x83\x01\x10+\n\x0f\n\x07\x04\x0c\
    \x04\0\x02\n\x02\x12\x04\x83\x01.0\n\x0e\n\x06\x04\x0c\x04\0\x02\x0b\x12\
    \x04\x84\x01\x10)\n\x0f\n\x07\x04\x0c\x04\0\x02\x0b\x01\x12\x04\x84\x01\
    \x10#\n\x0f\n\x07\x04\x0c\x04\0\x02\x0b\x02\x12\x04\x84\x01&(\n\x0c\n\
    \x04\x04\x0c\x02\0\x12\x04\x87\x01\x08V\n\r\n\x05\x04\x0c\x02\0\x04\x12\
    \x04\x87\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x87\x01\x11J\n\
    \r\n\x05\x04\x0c\x02\0\x01\x12\x04\x87\x01KQ\n\r\n\x05\x04\x0c\x02\0\x03\
    \x12\x04\x87\x01TU\n\x0c\n\x02\x04\r\x12\x06\x8a\x01\0\x8c\x01\x01\n\x0b\
    \n\x03\x04\r\x01\x12\x04\x8a\x01\x081\n\x0c\n\x04\x04\r\x02\0\x12\x04\
    \x8b\x01\x086\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x8b\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\0\x06\x12\x04\x8b\x01\x11%\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\x8b\x01&1\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x8b\x0145\n\x0c\n\x02\
    \x04\x0e\x12\x06\x8e\x01\0\x90\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\
    \x8e\x01\x083\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x8f\x01\x08%\n\r\n\x05\
    \x04\x0e\x02\0\x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\
    \x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x8f\x01\x18\
    \x20\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x8f\x01#$\n\x0c\n\x02\x04\x0f\
    \x12\x06\x92\x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x92\x01\
    \x08;\n\x0e\n\x04\x04\x0f\x04\0\x12\x06\x93\x01\x08\xa2\x01\t\n\r\n\x05\
    \x04\x0f\x04\0\x01\x12\x04\x93\x01\r\x16\n\x0e\n\x06\x04\x0f\x04\0\x02\0\
    \x12\x04\x94\x01\x10%\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x01\x12\x04\x94\
    \x01\x10\x20\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x02\x12\x04\x94\x01#$\n\x0e\
    \n\x06\x04\x0f\x04\0\x02\x01\x12\x04\x95\x01\x10\x1f\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\x01\x01\x12\x04\x95\x01\x10\x1a\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x01\x02\x12\x04\x95\x01\x1d\x1e\n\x0e\n\x06\x04\x0f\x04\0\x02\x02\x12\
    \x04\x96\x01\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x01\x12\x04\x96\
    \x01\x10\x1a\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x02\x12\x04\x96\x01\x1d\
    \x1e\n\x0e\n\x06\x04\x0f\x04\0\x02\x03\x12\x04\x97\x01\x10\x20\n\x0f\n\
    \x07\x04\x0f\x04\0\x02\x03\x01\x12\x04\x97\x01\x10\x1b\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x03\x02\x12\x04\x97\x01\x1e\x1f\n\x0e\n\x06\x04\x0f\x04\0\
    \x02\x04\x12\x04\x98\x01\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x04\x01\
    \x12\x04\x98\x01\x10\x1a\n\x0f\n\x07\x04\x0f\x04\0\x02\x04\x02\x12\x04\
    \x98\x01\x1d\x1e\n\x0e\n\x06\x04\x0f\x04\0\x02\x05\x12\x04\x99\x01\x10(\
    \n\x0f\n\x07\x04\x0f\x04\0\x02\x05\x01\x12\x04\x99\x01\x10#\n\x0f\n\x07\
    \x04\x0f\x04\0\x02\x05\x02\x12\x04\x99\x01&'\n\x0e\n\x06\x04\x0f\x04\0\
    \x02\x06\x12\x04\x9a\x01\x10+\n\x0f\n\x07\x04\x0f\x04\0\x02\x06\x01\x12\
    \x04\x9a\x01\x10&\n\x0f\n\x07\x04\x0f\x04\0\x02\x06\x02\x12\x04\x9a\x01)\
    *\n\x0e\n\x06\x04\x0f\x04\0\x02\x07\x12\x04\x9b\x01\x10(\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x07\x01\x12\x04\x9b\x01\x10#\n\x0f\n\x07\x04\x0f\x04\0\
    \x02\x07\x02\x12\x04\x9b\x01&'\n\x0e\n\x06\x04\x0f\x04\0\x02\x08\x12\x04\
    \x9c\x01\x10)\n\x0f\n\x07\x04\x0f\x04\0\x02\x08\x01\x12\x04\x9c\x01\x10$\
    \n\x0f\n\x07\x04\x0f\x04\0\x02\x08\x02\x12\x04\x9c\x01'(\n\x0e\n\x06\x04\
    \x0f\x04\0\x02\t\x12\x04\x9d\x01\x10(\n\x0f\n\x07\x04\x0f\x04\0\x02\t\
    \x01\x12\x04\x9d\x01\x10#\n\x0f\n\x07\x04\x0f\x04\0\x02\t\x02\x12\x04\
    \x9d\x01&'\n\x0e\n\x06\x04\x0f\x04\0\x02\n\x12\x04\x9e\x01\x10)\n\x0f\n\
    \x07\x04\x0f\x04\0\x02\n\x01\x12\x04\x9e\x01\x10#\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\n\x02\x12\x04\x9e\x01&(\n\x0e\n\x06\x04\x0f\x04\0\x02\x0b\x12\
    \x04\x9f\x01\x10$\n\x0f\n\x07\x04\x0f\x04\0\x02\x0b\x01\x12\x04\x9f\x01\
    \x10\x1e\n\x0f\n\x07\x04\x0f\x04\0\x02\x0b\x02\x12\x04\x9f\x01!#\n\x0e\n\
    \x06\x04\x0f\x04\0\x02\x0c\x12\x04\xa0\x01\x10%\n\x0f\n\x07\x04\x0f\x04\
    \0\x02\x0c\x01\x12\x04\xa0\x01\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x0c\
    \x02\x12\x04\xa0\x01\"$\n\x0e\n\x06\x04\x0f\x04\0\x02\r\x12\x04\xa1\x01\
    \x10!\n\x0f\n\x07\x04\x0f\x04\0\x02\r\x01\x12\x04\xa1\x01\x10\x1b\n\x0f\
    \n\x07\x04\x0f\x04\0\x02\r\x02\x12\x04\xa1\x01\x1e\x20\n\x0c\n\x04\x04\
    \x0f\x02\0\x12\x04\xa4\x01\x08Z\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xa4\
    \x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xa4\x01\x11N\n\r\n\x05\
    \x04\x0f\x02\0\x01\x12\x04\xa4\x01OU\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \xa4\x01XY\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xa5\x01\x08A\n\r\n\x05\
    \x04\x0f\x02\x01\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\
    \x06\x12\x04\xa5\x01\x11+\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xa5\x01,\
    <\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xa5\x01?@\n\x0c\n\x02\x04\x10\
    \x12\x06\xa8\x01\0\xaa\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xa8\x01\
    \x082\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xa9\x01\x080\n\r\n\x05\x04\x10\
    \x02\0\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\
    \xa9\x01\x11\x17\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa9\x01\x18+\n\r\n\
    \x05\x04\x10\x02\0\x03\x12\x04\xa9\x01./\n\x0c\n\x02\x04\x11\x12\x06\xac\
    \x01\0\xc8\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xac\x01\x08:\n\x0e\n\
    \x04\x04\x11\x04\0\x12\x06\xad\x01\x08\xc4\x01\t\n\r\n\x05\x04\x11\x04\0\
    \x01\x12\x04\xad\x01\r\x16\n\x0e\n\x06\x04\x11\x04\0\x02\0\x12\x04\xae\
    \x01\x10%\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\x04\xae\x01\x10\x20\n\
    \x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\xae\x01#$\n\x0e\n\x06\x04\x11\
    \x04\0\x02\x01\x12\x04\xaf\x01\x10\x1f\n\x0f\n\x07\x04\x11\x04\0\x02\x01\
    \x01\x12\x04\xaf\x01\x10\x1a\n\x0f\n\x07\x04\x11\x04\0\x02\x01\x02\x12\
    \x04\xaf\x01\x1d\x1e\n\x0e\n\x06\x04\x11\x04\0\x02\x02\x12\x04\xb0\x01\
    \x10\x1f\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x01\x12\x04\xb0\x01\x10\x1a\n\
    \x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\x04\xb0\x01\x1d\x1e\n\x0e\n\x06\
    \x04\x11\x04\0\x02\x03\x12\x04\xb1\x01\x10\x20\n\x0f\n\x07\x04\x11\x04\0\
    \x02\x03\x01\x12\x04\xb1\x01\x10\x1b\n\x0f\n\x07\x04\x11\x04\0\x02\x03\
    \x02\x12\x04\xb1\x01\x1e\x1f\n\x0e\n\x06\x04\x11\x04\0\x02\x04\x12\x04\
    \xb2\x01\x10\x1f\n\x0f\n\x07\x04\x11\x04\0\x02\x04\x01\x12\x04\xb2\x01\
    \x10\x1a\n\x0f\n\x07\x04\x11\x04\0\x02\x04\x02\x12\x04\xb2\x01\x1d\x1e\n\
    \x0e\n\x06\x04\x11\x04\0\x02\x05\x12\x04\xb3\x01\x10&\n\x0f\n\x07\x04\
    \x11\x04\0\x02\x05\x01\x12\x04\xb3\x01\x10!\n\x0f\n\x07\x04\x11\x04\0\
    \x02\x05\x02\x12\x04\xb3\x01$%\n\x0e\n\x06\x04\x11\x04\0\x02\x06\x12\x04\
    \xb4\x01\x10'\n\x0f\n\x07\x04\x11\x04\0\x02\x06\x01\x12\x04\xb4\x01\x10\
    \"\n\x0f\n\x07\x04\x11\x04\0\x02\x06\x02\x12\x04\xb4\x01%&\n\x0e\n\x06\
    \x04\x11\x04\0\x02\x07\x12\x04\xb5\x01\x10)\n\x0f\n\x07\x04\x11\x04\0\
    \x02\x07\x01\x12\x04\xb5\x01\x10$\n\x0f\n\x07\x04\x11\x04\0\x02\x07\x02\
    \x12\x04\xb5\x01'(\n\x0e\n\x06\x04\x11\x04\0\x02\x08\x12\x04\xb6\x01\x10\
    #\n\x0f\n\x07\x04\x11\x04\0\x02\x08\x01\x12\x04\xb6\x01\x10\x1e\n\x0f\n\
    \x07\x04\x11\x04\0\x02\x08\x02\x12\x04\xb6\x01!\"\n\x0e\n\x06\x04\x11\
    \x04\0\x02\t\x12\x04\xb7\x01\x10'\n\x0f\n\x07\x04\x11\x04\0\x02\t\x01\
    \x12\x04\xb7\x01\x10\"\n\x0f\n\x07\x04\x11\x04\0\x02\t\x02\x12\x04\xb7\
    \x01%&\n\x0e\n\x06\x04\x11\x04\0\x02\n\x12\x04\xb8\x01\x10)\n\x0f\n\x07\
    \x04\x11\x04\0\x02\n\x01\x12\x04\xb8\x01\x10#\n\x0f\n\x07\x04\x11\x04\0\
    \x02\n\x02\x12\x04\xb8\x01&(\n\x0e\n\x06\x04\x11\x04\0\x02\x0b\x12\x04\
    \xb9\x01\x10'\n\x0f\n\x07\x04\x11\x04\0\x02\x0b\x01\x12\x04\xb9\x01\x10!\
    \n\x0f\n\x07\x04\x11\x04\0\x02\x0b\x02\x12\x04\xb9\x01$&\n\x0e\n\x06\x04\
    \x11\x04\0\x02\x0c\x12\x04\xba\x01\x10#\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x0c\x01\x12\x04\xba\x01\x10\x1d\n\x0f\n\x07\x04\x11\x04\0\x02\x0c\x02\
    \x12\x04\xba\x01\x20\"\n\x0e\n\x06\x04\x11\x04\0\x02\r\x12\x04\xbb\x01\
    \x10&\n\x0f\n\x07\x04\x11\x04\0\x02\r\x01\x12\x04\xbb\x01\x10\x20\n\x0f\
    \n\x07\x04\x11\x04\0\x02\r\x02\x12\x04\xbb\x01#%\n\x0e\n\x06\x04\x11\x04\
    \0\x02\x0e\x12\x04\xbc\x01\x10*\n\x0f\n\x07\x04\x11\x04\0\x02\x0e\x01\
    \x12\x04\xbc\x01\x10$\n\x0f\n\x07\x04\x11\x04\0\x02\x0e\x02\x12\x04\xbc\
    \x01')\n\x0e\n\x06\x04\x11\x04\0\x02\x0f\x12\x04\xbd\x01\x10-\n\x0f\n\
    \x07\x04\x11\x04\0\x02\x0f\x01\x12\x04\xbd\x01\x10'\n\x0f\n\x07\x04\x11\
    \x04\0\x02\x0f\x02\x12\x04\xbd\x01*,\n\x0e\n\x06\x04\x11\x04\0\x02\x10\
    \x12\x04\xbe\x01\x10'\n\x0f\n\x07\x04\x11\x04\0\x02\x10\x01\x12\x04\xbe\
    \x01\x10!\n\x0f\n\x07\x04\x11\x04\0\x02\x10\x02\x12\x04\xbe\x01$&\n\x0e\
    \n\x06\x04\x11\x04\0\x02\x11\x12\x04\xbf\x01\x10'\n\x0f\n\x07\x04\x11\
    \x04\0\x02\x11\x01\x12\x04\xbf\x01\x10!\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x11\x02\x12\x04\xbf\x01$&\n\x0e\n\x06\x04\x11\x04\0\x02\x12\x12\x04\xc0\
    \x01\x101\n\x0f\n\x07\x04\x11\x04\0\x02\x12\x01\x12\x04\xc0\x01\x10+\n\
    \x0f\n\x07\x04\x11\x04\0\x02\x12\x02\x12\x04\xc0\x01.0\n\x0e\n\x06\x04\
    \x11\x04\0\x02\x13\x12\x04\xc1\x01\x10/\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x13\x01\x12\x04\xc1\x01\x10)\n\x0f\n\x07\x04\x11\x04\0\x02\x13\x02\x12\
    \x04\xc1\x01,.\n\x0e\n\x06\x04\x11\x04\0\x02\x14\x12\x04\xc2\x01\x10-\n\
    \x0f\n\x07\x04\x11\x04\0\x02\x14\x01\x12\x04\xc2\x01\x10'\n\x0f\n\x07\
    \x04\x11\x04\0\x02\x14\x02\x12\x04\xc2\x01*,\n\x0e\n\x06\x04\x11\x04\0\
    \x02\x15\x12\x04\xc3\x01\x10(\n\x0f\n\x07\x04\x11\x04\0\x02\x15\x01\x12\
    \x04\xc3\x01\x10\"\n\x0f\n\x07\x04\x11\x04\0\x02\x15\x02\x12\x04\xc3\x01\
    %'\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xc6\x01\x08Y\n\r\n\x05\x04\x11\x02\
    \0\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xc6\
    \x01\x11M\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xc6\x01NT\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xc6\x01WX\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xc7\
    \x01\x08A\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc7\x01\x08\x10\n\r\n\
    \x05\x04\x11\x02\x01\x06\x12\x04\xc7\x01\x11+\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xc7\x01,<\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xc7\x01?@\n\
    \x0c\n\x02\x04\x12\x12\x06\xca\x01\0\xcb\x01\x01\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xca\x01\x081\n\x0c\n\x02\x04\x13\x12\x06\xcd\x01\0\xd9\x01\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xcd\x01\x089\n\x0e\n\x04\x04\x13\x04\0\
    \x12\x06\xce\x01\x08\xd6\x01\t\n\r\n\x05\x04\x13\x04\0\x01\x12\x04\xce\
    \x01\r\x16\n\x0e\n\x06\x04\x13\x04\0\x02\0\x12\x04\xcf\x01\x10%\n\x0f\n\
    \x07\x04\x13\x04\0\x02\0\x01\x12\x04\xcf\x01\x10\x20\n\x0f\n\x07\x04\x13\
    \x04\0\x02\0\x02\x12\x04\xcf\x01#$\n\x0e\n\x06\x04\x13\x04\0\x02\x01\x12\
    \x04\xd0\x01\x10\x1f\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x01\x12\x04\xd0\
    \x01\x10\x1a\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x02\x12\x04\xd0\x01\x1d\
    \x1e\n\x0e\n\x06\x04\x13\x04\0\x02\x02\x12\x04\xd1\x01\x10\x1f\n\x0f\n\
    \x07\x04\x13\x04\0\x02\x02\x01\x12\x04\xd1\x01\x10\x1a\n\x0f\n\x07\x04\
    \x13\x04\0\x02\x02\x02\x12\x04\xd1\x01\x1d\x1e\n\x0e\n\x06\x04\x13\x04\0\
    \x02\x03\x12\x04\xd2\x01\x10\x20\n\x0f\n\x07\x04\x13\x04\0\x02\x03\x01\
    \x12\x04\xd2\x01\x10\x1b\n\x0f\n\x07\x04\x13\x04\0\x02\x03\x02\x12\x04\
    \xd2\x01\x1e\x1f\n\x0e\n\x06\x04\x13\x04\0\x02\x04\x12\x04\xd3\x01\x10\
    \x1f\n\x0f\n\x07\x04\x13\x04\0\x02\x04\x01\x12\x04\xd3\x01\x10\x1a\n\x0f\
    \n\x07\x04\x13\x04\0\x02\x04\x02\x12\x04\xd3\x01\x1d\x1e\n\x0e\n\x06\x04\
    \x13\x04\0\x02\x05\x12\x04\xd4\x01\x10!\n\x0f\n\x07\x04\x13\x04\0\x02\
    \x05\x01\x12\x04\xd4\x01\x10\x1c\n\x0f\n\x07\x04\x13\x04\0\x02\x05\x02\
    \x12\x04\xd4\x01\x1f\x20\n\x0e\n\x06\x04\x13\x04\0\x02\x06\x12\x04\xd5\
    \x01\x10#\n\x0f\n\x07\x04\x13\x04\0\x02\x06\x01\x12\x04\xd5\x01\x10\x1e\
    \n\x0f\n\x07\x04\x13\x04\0\x02\x06\x02\x12\x04\xd5\x01!\"\n\x0c\n\x04\
    \x04\x13\x02\0\x12\x04\xd8\x01\x08X\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\
    \xd8\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xd8\x01\x11L\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xd8\x01MS\n\r\n\x05\x04\x13\x02\0\x03\x12\
    \x04\xd8\x01VW\n\x0c\n\x02\x04\x14\x12\x06\xdb\x01\0\xdc\x01\x01\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xdb\x01\x086\n\x0c\n\x02\x04\x15\x12\x06\xde\
    \x01\0\xe9\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xde\x01\x08>\n\x0e\n\
    \x04\x04\x15\x04\0\x12\x06\xdf\x01\x08\xe5\x01\t\n\r\n\x05\x04\x15\x04\0\
    \x01\x12\x04\xdf\x01\r\x16\n\x0e\n\x06\x04\x15\x04\0\x02\0\x12\x04\xe0\
    \x01\x10%\n\x0f\n\x07\x04\x15\x04\0\x02\0\x01\x12\x04\xe0\x01\x10\x20\n\
    \x0f\n\x07\x04\x15\x04\0\x02\0\x02\x12\x04\xe0\x01#$\n\x0e\n\x06\x04\x15\
    \x04\0\x02\x01\x12\x04\xe1\x01\x10\x1f\n\x0f\n\x07\x04\x15\x04\0\x02\x01\
    \x01\x12\x04\xe1\x01\x10\x1a\n\x0f\n\x07\x04\x15\x04\0\x02\x01\x02\x12\
    \x04\xe1\x01\x1d\x1e\n\x0e\n\x06\x04\x15\x04\0\x02\x02\x12\x04\xe2\x01\
    \x10\x1f\n\x0f\n\x07\x04\x15\x04\0\x02\x02\x01\x12\x04\xe2\x01\x10\x1a\n\
    \x0f\n\x07\x04\x15\x04\0\x02\x02\x02\x12\x04\xe2\x01\x1d\x1e\n\x0e\n\x06\
    \x04\x15\x04\0\x02\x03\x12\x04\xe3\x01\x10\x20\n\x0f\n\x07\x04\x15\x04\0\
    \x02\x03\x01\x12\x04\xe3\x01\x10\x1b\n\x0f\n\x07\x04\x15\x04\0\x02\x03\
    \x02\x12\x04\xe3\x01\x1e\x1f\n\x0e\n\x06\x04\x15\x04\0\x02\x04\x12\x04\
    \xe4\x01\x10\x1f\n\x0f\n\x07\x04\x15\x04\0\x02\x04\x01\x12\x04\xe4\x01\
    \x10\x1a\n\x0f\n\x07\x04\x15\x04\0\x02\x04\x02\x12\x04\xe4\x01\x1d\x1e\n\
    \x0c\n\x04\x04\x15\x02\0\x12\x04\xe7\x01\x08]\n\r\n\x05\x04\x15\x02\0\
    \x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\xe7\x01\
    \x11Q\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xe7\x01RX\n\r\n\x05\x04\x15\
    \x02\0\x03\x12\x04\xe7\x01[\\\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xe8\
    \x01\x08@\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xe8\x01\x08\x10\n\r\n\
    \x05\x04\x15\x02\x01\x06\x12\x04\xe8\x01\x11+\n\r\n\x05\x04\x15\x02\x01\
    \x01\x12\x04\xe8\x01,;\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xe8\x01>?\n\
    \x0c\n\x02\x04\x16\x12\x06\xeb\x01\0\xed\x01\x01\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\xeb\x01\x083\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xec\x01\x08A\n\r\
    \n\x05\x04\x16\x02\0\x04\x12\x04\xec\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\
    \x06\x12\x04\xec\x01\x11+\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xec\x01,<\
    \n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xec\x01?@\n\x0c\n\x02\x04\x17\x12\
    \x06\xef\x01\0\xf2\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xef\x01\x088\
    \n\x0c\n\x04\x04\x17\x02\0\x12\x04\xf0\x01\x080\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xf0\x01\
    \x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xf0\x01\x18+\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xf0\x01./\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xf1\
    \x01\x089\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xf1\x01\x08\x10\n\r\n\
    \x05\x04\x17\x02\x01\x06\x12\x04\xf1\x01\x11%\n\r\n\x05\x04\x17\x02\x01\
    \x01\x12\x04\xf1\x01&4\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xf1\x0178\n\
    \x0c\n\x02\x04\x18\x12\x06\xf4\x01\0\x85\x02\x01\n\x0b\n\x03\x04\x18\x01\
    \x12\x04\xf4\x01\x08@\n\x0e\n\x04\x04\x18\x04\0\x12\x06\xf5\x01\x08\x82\
    \x02\t\n\r\n\x05\x04\x18\x04\0\x01\x12\x04\xf5\x01\r\x16\n\x0e\n\x06\x04\
    \x18\x04\0\x02\0\x12\x04\xf6\x01\x10%\n\x0f\n\x07\x04\x18\x04\0\x02\0\
    \x01\x12\x04\xf6\x01\x10\x20\n\x0f\n\x07\x04\x18\x04\0\x02\0\x02\x12\x04\
    \xf6\x01#$\n\x0e\n\x06\x04\x18\x04\0\x02\x01\x12\x04\xf7\x01\x10\x1f\n\
    \x0f\n\x07\x04\x18\x04\0\x02\x01\x01\x12\x04\xf7\x01\x10\x1a\n\x0f\n\x07\
    \x04\x18\x04\0\x02\x01\x02\x12\x04\xf7\x01\x1d\x1e\n\x0e\n\x06\x04\x18\
    \x04\0\x02\x02\x12\x04\xf8\x01\x10\x1f\n\x0f\n\x07\x04\x18\x04\0\x02\x02\
    \x01\x12\x04\xf8\x01\x10\x1a\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x02\x12\
    \x04\xf8\x01\x1d\x1e\n\x0e\n\x06\x04\x18\x04\0\x02\x03\x12\x04\xf9\x01\
    \x10\x20\n\x0f\n\x07\x04\x18\x04\0\x02\x03\x01\x12\x04\xf9\x01\x10\x1b\n\
    \x0f\n\x07\x04\x18\x04\0\x02\x03\x02\x12\x04\xf9\x01\x1e\x1f\n\x0e\n\x06\
    \x04\x18\x04\0\x02\x04\x12\x04\xfa\x01\x10\x1f\n\x0f\n\x07\x04\x18\x04\0\
    \x02\x04\x01\x12\x04\xfa\x01\x10\x1a\n\x0f\n\x07\x04\x18\x04\0\x02\x04\
    \x02\x12\x04\xfa\x01\x1d\x1e\n\x0e\n\x06\x04\x18\x04\0\x02\x05\x12\x04\
    \xfb\x01\x10&\n\x0f\n\x07\x04\x18\x04\0\x02\x05\x01\x12\x04\xfb\x01\x10!\
    \n\x0f\n\x07\x04\x18\x04\0\x02\x05\x02\x12\x04\xfb\x01$%\n\x0e\n\x06\x04\
    \x18\x04\0\x02\x06\x12\x04\xfc\x01\x10!\n\x0f\n\x07\x04\x18\x04\0\x02\
    \x06\x01\x12\x04\xfc\x01\x10\x1c\n\x0f\n\x07\x04\x18\x04\0\x02\x06\x02\
    \x12\x04\xfc\x01\x1f\x20\n\x0e\n\x06\x04\x18\x04\0\x02\x07\x12\x04\xfd\
    \x01\x10(\n\x0f\n\x07\x04\x18\x04\0\x02\x07\x01\x12\x04\xfd\x01\x10#\n\
    \x0f\n\x07\x04\x18\x04\0\x02\x07\x02\x12\x04\xfd\x01&'\n\x0e\n\x06\x04\
    \x18\x04\0\x02\x08\x12\x04\xfe\x01\x10%\n\x0f\n\x07\x04\x18\x04\0\x02\
    \x08\x01\x12\x04\xfe\x01\x10\x20\n\x0f\n\x07\x04\x18\x04\0\x02\x08\x02\
    \x12\x04\xfe\x01#$\n\x0e\n\x06\x04\x18\x04\0\x02\t\x12\x04\xff\x01\x10'\
    \n\x0f\n\x07\x04\x18\x04\0\x02\t\x01\x12\x04\xff\x01\x10\"\n\x0f\n\x07\
    \x04\x18\x04\0\x02\t\x02\x12\x04\xff\x01%&\n\x0e\n\x06\x04\x18\x04\0\x02\
    \n\x12\x04\x80\x02\x10\x20\n\x0f\n\x07\x04\x18\x04\0\x02\n\x01\x12\x04\
    \x80\x02\x10\x1a\n\x0f\n\x07\x04\x18\x04\0\x02\n\x02\x12\x04\x80\x02\x1d\
    \x1f\n\x0e\n\x06\x04\x18\x04\0\x02\x0b\x12\x04\x81\x02\x10&\n\x0f\n\x07\
    \x04\x18\x04\0\x02\x0b\x01\x12\x04\x81\x02\x10\x20\n\x0f\n\x07\x04\x18\
    \x04\0\x02\x0b\x02\x12\x04\x81\x02#%\n\x0c\n\x04\x04\x18\x02\0\x12\x04\
    \x84\x02\x08_\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\x84\x02\x08\x10\n\r\n\
    \x05\x04\x18\x02\0\x06\x12\x04\x84\x02\x11S\n\r\n\x05\x04\x18\x02\0\x01\
    \x12\x04\x84\x02TZ\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x84\x02]^\n\x0c\n\
    \x02\x04\x19\x12\x06\x87\x02\0\x89\x02\x01\n\x0b\n\x03\x04\x19\x01\x12\
    \x04\x87\x02\x089\n\x0c\n\x04\x04\x19\x02\0\x12\x04\x88\x02\x08%\n\r\n\
    \x05\x04\x19\x02\0\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\x19\x02\0\
    \x05\x12\x04\x88\x02\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x88\x02\
    \x18\x20\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x88\x02#$\n\x0c\n\x02\x04\
    \x1a\x12\x06\x8b\x02\0\x96\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x8b\
    \x02\x08A\n\x0e\n\x04\x04\x1a\x04\0\x12\x06\x8c\x02\x08\x92\x02\t\n\r\n\
    \x05\x04\x1a\x04\0\x01\x12\x04\x8c\x02\r\x16\n\x0e\n\x06\x04\x1a\x04\0\
    \x02\0\x12\x04\x8d\x02\x10%\n\x0f\n\x07\x04\x1a\x04\0\x02\0\x01\x12\x04\
    \x8d\x02\x10\x20\n\x0f\n\x07\x04\x1a\x04\0\x02\0\x02\x12\x04\x8d\x02#$\n\
    \x0e\n\x06\x04\x1a\x04\0\x02\x01\x12\x04\x8e\x02\x10\x1f\n\x0f\n\x07\x04\
    \x1a\x04\0\x02\x01\x01\x12\x04\x8e\x02\x10\x1a\n\x0f\n\x07\x04\x1a\x04\0\
    \x02\x01\x02\x12\x04\x8e\x02\x1d\x1e\n\x0e\n\x06\x04\x1a\x04\0\x02\x02\
    \x12\x04\x8f\x02\x10\x1f\n\x0f\n\x07\x04\x1a\x04\0\x02\x02\x01\x12\x04\
    \x8f\x02\x10\x1a\n\x0f\n\x07\x04\x1a\x04\0\x02\x02\x02\x12\x04\x8f\x02\
    \x1d\x1e\n\x0e\n\x06\x04\x1a\x04\0\x02\x03\x12\x04\x90\x02\x10\x20\n\x0f\
    \n\x07\x04\x1a\x04\0\x02\x03\x01\x12\x04\x90\x02\x10\x1b\n\x0f\n\x07\x04\
    \x1a\x04\0\x02\x03\x02\x12\x04\x90\x02\x1e\x1f\n\x0e\n\x06\x04\x1a\x04\0\
    \x02\x04\x12\x04\x91\x02\x10\x1f\n\x0f\n\x07\x04\x1a\x04\0\x02\x04\x01\
    \x12\x04\x91\x02\x10\x1a\n\x0f\n\x07\x04\x1a\x04\0\x02\x04\x02\x12\x04\
    \x91\x02\x1d\x1e\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x94\x02\x08`\n\r\n\
    \x05\x04\x1a\x02\0\x04\x12\x04\x94\x02\x08\x10\n\r\n\x05\x04\x1a\x02\0\
    \x06\x12\x04\x94\x02\x11T\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x94\x02U[\
    \n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x94\x02^_\n\x0c\n\x04\x04\x1a\x02\
    \x01\x12\x04\x95\x02\x08U\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\x95\x02\
    \x08\x10\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\x95\x02\x118\n\r\n\x05\
    \x04\x1a\x02\x01\x01\x12\x04\x95\x029P\n\r\n\x05\x04\x1a\x02\x01\x03\x12\
    \x04\x95\x02ST\n\x0c\n\x02\x04\x1b\x12\x06\x98\x02\0\x99\x02\x01\n\x0b\n\
    \x03\x04\x1b\x01\x12\x04\x98\x02\x08@\n\x0c\n\x02\x04\x1c\x12\x06\x9b\
    \x02\0\xa6\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x9b\x02\x08H\n\x0e\n\
    \x04\x04\x1c\x04\0\x12\x06\x9c\x02\x08\xa2\x02\t\n\r\n\x05\x04\x1c\x04\0\
    \x01\x12\x04\x9c\x02\r\x16\n\x0e\n\x06\x04\x1c\x04\0\x02\0\x12\x04\x9d\
    \x02\x10%\n\x0f\n\x07\x04\x1c\x04\0\x02\0\x01\x12\x04\x9d\x02\x10\x20\n\
    \x0f\n\x07\x04\x1c\x04\0\x02\0\x02\x12\x04\x9d\x02#$\n\x0e\n\x06\x04\x1c\
    \x04\0\x02\x01\x12\x04\x9e\x02\x10\x1f\n\x0f\n\x07\x04\x1c\x04\0\x02\x01\
    \x01\x12\x04\x9e\x02\x10\x1a\n\x0f\n\x07\x04\x1c\x04\0\x02\x01\x02\x12\
    \x04\x9e\x02\x1d\x1e\n\x0e\n\x06\x04\x1c\x04\0\x02\x02\x12\x04\x9f\x02\
    \x10\x1f\n\x0f\n\x07\x04\x1c\x04\0\x02\x02\x01\x12\x04\x9f\x02\x10\x1a\n\
    \x0f\n\x07\x04\x1c\x04\0\x02\x02\x02\x12\x04\x9f\x02\x1d\x1e\n\x0e\n\x06\
    \x04\x1c\x04\0\x02\x03\x12\x04\xa0\x02\x10\x20\n\x0f\n\x07\x04\x1c\x04\0\
    \x02\x03\x01\x12\x04\xa0\x02\x10\x1b\n\x0f\n\x07\x04\x1c\x04\0\x02\x03\
    \x02\x12\x04\xa0\x02\x1e\x1f\n\x0e\n\x06\x04\x1c\x04\0\x02\x04\x12\x04\
    \xa1\x02\x10\x1f\n\x0f\n\x07\x04\x1c\x04\0\x02\x04\x01\x12\x04\xa1\x02\
    \x10\x1a\n\x0f\n\x07\x04\x1c\x04\0\x02\x04\x02\x12\x04\xa1\x02\x1d\x1e\n\
    \x0c\n\x04\x04\x1c\x02\0\x12\x04\xa4\x02\x08g\n\r\n\x05\x04\x1c\x02\0\
    \x04\x12\x04\xa4\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xa4\x02\
    \x11[\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xa4\x02\\b\n\r\n\x05\x04\x1c\
    \x02\0\x03\x12\x04\xa4\x02ef\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xa5\x02\
    \x08Y\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\
    \x04\x1c\x02\x01\x06\x12\x04\xa5\x02\x11;\n\r\n\x05\x04\x1c\x02\x01\x01\
    \x12\x04\xa5\x02<T\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xa5\x02WX\n\x0c\
    \n\x02\x04\x1d\x12\x06\xa8\x02\0\xa9\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\
    \x04\xa8\x02\x085\n\x0c\n\x02\x04\x1e\x12\x06\xab\x02\0\xc4\x02\x01\n\
    \x0b\n\x03\x04\x1e\x01\x12\x04\xab\x02\x08=\n\x0e\n\x04\x04\x1e\x04\0\
    \x12\x06\xac\x02\x08\xc1\x02\t\n\r\n\x05\x04\x1e\x04\0\x01\x12\x04\xac\
    \x02\r\x16\n\x0e\n\x06\x04\x1e\x04\0\x02\0\x12\x04\xad\x02\x10%\n\x0f\n\
    \x07\x04\x1e\x04\0\x02\0\x01\x12\x04\xad\x02\x10\x20\n\x0f\n\x07\x04\x1e\
    \x04\0\x02\0\x02\x12\x04\xad\x02#$\n\x0e\n\x06\x04\x1e\x04\0\x02\x01\x12\
    \x04\xae\x02\x10\x1f\n\x0f\n\x07\x04\x1e\x04\0\x02\x01\x01\x12\x04\xae\
    \x02\x10\x1a\n\x0f\n\x07\x04\x1e\x04\0\x02\x01\x02\x12\x04\xae\x02\x1d\
    \x1e\n\x0e\n\x06\x04\x1e\x04\0\x02\x02\x12\x04\xaf\x02\x10\x1f\n\x0f\n\
    \x07\x04\x1e\x04\0\x02\x02\x01\x12\x04\xaf\x02\x10\x1a\n\x0f\n\x07\x04\
    \x1e\x04\0\x02\x02\x02\x12\x04\xaf\x02\x1d\x1e\n\x0e\n\x06\x04\x1e\x04\0\
    \x02\x03\x12\x04\xb0\x02\x10\x20\n\x0f\n\x07\x04\x1e\x04\0\x02\x03\x01\
    \x12\x04\xb0\x02\x10\x1b\n\x0f\n\x07\x04\x1e\x04\0\x02\x03\x02\x12\x04\
    \xb0\x02\x1e\x1f\n\x0e\n\x06\x04\x1e\x04\0\x02\x04\x12\x04\xb1\x02\x10\
    \x1f\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\x01\x12\x04\xb1\x02\x10\x1a\n\x0f\
    \n\x07\x04\x1e\x04\0\x02\x04\x02\x12\x04\xb1\x02\x1d\x1e\n\x0e\n\x06\x04\
    \x1e\x04\0\x02\x05\x12\x04\xb2\x02\x10!\n\x0f\n\x07\x04\x1e\x04\0\x02\
    \x05\x01\x12\x04\xb2\x02\x10\x1c\n\x0f\n\x07\x04\x1e\x04\0\x02\x05\x02\
    \x12\x04\xb2\x02\x1f\x20\n\x0e\n\x06\x04\x1e\x04\0\x02\x06\x12\x04\xb3\
    \x02\x10'\n\x0f\n\x07\x04\x1e\x04\0\x02\x06\x01\x12\x04\xb3\x02\x10\"\n\
    \x0f\n\x07\x04\x1e\x04\0\x02\x06\x02\x12\x04\xb3\x02%&\n\x0e\n\x06\x04\
    \x1e\x04\0\x02\x07\x12\x04\xb4\x02\x10#\n\x0f\n\x07\x04\x1e\x04\0\x02\
    \x07\x01\x12\x04\xb4\x02\x10\x1e\n\x0f\n\x07\x04\x1e\x04\0\x02\x07\x02\
    \x12\x04\xb4\x02!\"\n\x0e\n\x06\x04\x1e\x04\0\x02\x08\x12\x04\xb5\x02\
    \x10!\n\x0f\n\x07\x04\x1e\x04\0\x02\x08\x01\x12\x04\xb5\x02\x10\x1c\n\
    \x0f\n\x07\x04\x1e\x04\0\x02\x08\x02\x12\x04\xb5\x02\x1f\x20\n\x0e\n\x06\
    \x04\x1e\x04\0\x02\t\x12\x04\xb6\x02\x10\x1f\n\x0f\n\x07\x04\x1e\x04\0\
    \x02\t\x01\x12\x04\xb6\x02\x10\x1a\n\x0f\n\x07\x04\x1e\x04\0\x02\t\x02\
    \x12\x04\xb6\x02\x1d\x1e\n\x0e\n\x06\x04\x1e\x04\0\x02\n\x12\x04\xb7\x02\
    \x10)\n\x0f\n\x07\x04\x1e\x04\0\x02\n\x01\x12\x04\xb7\x02\x10#\n\x0f\n\
    \x07\x04\x1e\x04\0\x02\n\x02\x12\x04\xb7\x02&(\n\x0e\n\x06\x04\x1e\x04\0\
    \x02\x0b\x12\x04\xb8\x02\x10&\n\x0f\n\x07\x04\x1e\x04\0\x02\x0b\x01\x12\
    \x04\xb8\x02\x10\x20\n\x0f\n\x07\x04\x1e\x04\0\x02\x0b\x02\x12\x04\xb8\
    \x02#%\n\x0e\n\x06\x04\x1e\x04\0\x02\x0c\x12\x04\xb9\x02\x10#\n\x0f\n\
    \x07\x04\x1e\x04\0\x02\x0c\x01\x12\x04\xb9\x02\x10\x1d\n\x0f\n\x07\x04\
    \x1e\x04\0\x02\x0c\x02\x12\x04\xb9\x02\x20\"\n\x0e\n\x06\x04\x1e\x04\0\
    \x02\r\x12\x04\xba\x02\x10&\n\x0f\n\x07\x04\x1e\x04\0\x02\r\x01\x12\x04\
    \xba\x02\x10\x20\n\x0f\n\x07\x04\x1e\x04\0\x02\r\x02\x12\x04\xba\x02#%\n\
    \x0e\n\x06\x04\x1e\x04\0\x02\x0e\x12\x04\xbb\x02\x10)\n\x0f\n\x07\x04\
    \x1e\x04\0\x02\x0e\x01\x12\x04\xbb\x02\x10#\n\x0f\n\x07\x04\x1e\x04\0\
    \x02\x0e\x02\x12\x04\xbb\x02&(\n\x0e\n\x06\x04\x1e\x04\0\x02\x0f\x12\x04\
    \xbc\x02\x10*\n\x0f\n\x07\x04\x1e\x04\0\x02\x0f\x01\x12\x04\xbc\x02\x10$\
    \n\x0f\n\x07\x04\x1e\x04\0\x02\x0f\x02\x12\x04\xbc\x02')\n\x0e\n\x06\x04\
    \x1e\x04\0\x02\x10\x12\x04\xbd\x02\x10-\n\x0f\n\x07\x04\x1e\x04\0\x02\
    \x10\x01\x12\x04\xbd\x02\x10'\n\x0f\n\x07\x04\x1e\x04\0\x02\x10\x02\x12\
    \x04\xbd\x02*,\n\x0e\n\x06\x04\x1e\x04\0\x02\x11\x12\x04\xbe\x02\x10'\n\
    \x0f\n\x07\x04\x1e\x04\0\x02\x11\x01\x12\x04\xbe\x02\x10!\n\x0f\n\x07\
    \x04\x1e\x04\0\x02\x11\x02\x12\x04\xbe\x02$&\n\x0e\n\x06\x04\x1e\x04\0\
    \x02\x12\x12\x04\xbf\x02\x10'\n\x0f\n\x07\x04\x1e\x04\0\x02\x12\x01\x12\
    \x04\xbf\x02\x10!\n\x0f\n\x07\x04\x1e\x04\0\x02\x12\x02\x12\x04\xbf\x02$\
    &\n\x0e\n\x06\x04\x1e\x04\0\x02\x13\x12\x04\xc0\x02\x10#\n\x0f\n\x07\x04\
    \x1e\x04\0\x02\x13\x01\x12\x04\xc0\x02\x10\x1d\n\x0f\n\x07\x04\x1e\x04\0\
    \x02\x13\x02\x12\x04\xc0\x02\x20\"\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xc3\
    \x02\x08\\\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\
    \x04\x1e\x02\0\x06\x12\x04\xc3\x02\x11P\n\r\n\x05\x04\x1e\x02\0\x01\x12\
    \x04\xc3\x02QW\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xc3\x02Z[\n\x0c\n\x02\
    \x04\x1f\x12\x06\xc6\x02\0\xc8\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\
    \xc6\x02\x08!\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xc7\x02\x08.\n\r\n\x05\
    \x04\x1f\x02\0\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\
    \x12\x04\xc7\x02\x11\x17\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xc7\x02\x18\
    )\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xc7\x02,-\n\x0c\n\x02\x04\x20\x12\
    \x06\xca\x02\0\xe3\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xca\x02\x08)\
    \n\x0e\n\x04\x04\x20\x04\0\x12\x06\xcb\x02\x08\xe0\x02\t\n\r\n\x05\x04\
    \x20\x04\0\x01\x12\x04\xcb\x02\r\x16\n\x0e\n\x06\x04\x20\x04\0\x02\0\x12\
    \x04\xcc\x02\x10%\n\x0f\n\x07\x04\x20\x04\0\x02\0\x01\x12\x04\xcc\x02\
    \x10\x20\n\x0f\n\x07\x04\x20\x04\0\x02\0\x02\x12\x04\xcc\x02#$\n\x0e\n\
    \x06\x04\x20\x04\0\x02\x01\x12\x04\xcd\x02\x10\x1f\n\x0f\n\x07\x04\x20\
    \x04\0\x02\x01\x01\x12\x04\xcd\x02\x10\x1a\n\x0f\n\x07\x04\x20\x04\0\x02\
    \x01\x02\x12\x04\xcd\x02\x1d\x1e\n\x0e\n\x06\x04\x20\x04\0\x02\x02\x12\
    \x04\xce\x02\x10\x1f\n\x0f\n\x07\x04\x20\x04\0\x02\x02\x01\x12\x04\xce\
    \x02\x10\x1a\n\x0f\n\x07\x04\x20\x04\0\x02\x02\x02\x12\x04\xce\x02\x1d\
    \x1e\n\x0e\n\x06\x04\x20\x04\0\x02\x03\x12\x04\xcf\x02\x10\x20\n\x0f\n\
    \x07\x04\x20\x04\0\x02\x03\x01\x12\x04\xcf\x02\x10\x1b\n\x0f\n\x07\x04\
    \x20\x04\0\x02\x03\x02\x12\x04\xcf\x02\x1e\x1f\n\x0e\n\x06\x04\x20\x04\0\
    \x02\x04\x12\x04\xd0\x02\x10\x1f\n\x0f\n\x07\x04\x20\x04\0\x02\x04\x01\
    \x12\x04\xd0\x02\x10\x1a\n\x0f\n\x07\x04\x20\x04\0\x02\x04\x02\x12\x04\
    \xd0\x02\x1d\x1e\n\x0e\n\x06\x04\x20\x04\0\x02\x05\x12\x04\xd1\x02\x10*\
    \n\x0f\n\x07\x04\x20\x04\0\x02\x05\x01\x12\x04\xd1\x02\x10%\n\x0f\n\x07\
    \x04\x20\x04\0\x02\x05\x02\x12\x04\xd1\x02()\n\x0e\n\x06\x04\x20\x04\0\
    \x02\x06\x12\x04\xd2\x02\x10%\n\x0f\n\x07\x04\x20\x04\0\x02\x06\x01\x12\
    \x04\xd2\x02\x10\x20\n\x0f\n\x07\x04\x20\x04\0\x02\x06\x02\x12\x04\xd2\
    \x02#$\n\x0e\n\x06\x04\x20\x04\0\x02\x07\x12\x04\xd3\x02\x10*\n\x0f\n\
    \x07\x04\x20\x04\0\x02\x07\x01\x12\x04\xd3\x02\x10%\n\x0f\n\x07\x04\x20\
    \x04\0\x02\x07\x02\x12\x04\xd3\x02()\n\x0e\n\x06\x04\x20\x04\0\x02\x08\
    \x12\x04\xd4\x02\x10\"\n\x0f\n\x07\x04\x20\x04\0\x02\x08\x01\x12\x04\xd4\
    \x02\x10\x1d\n\x0f\n\x07\x04\x20\x04\0\x02\x08\x02\x12\x04\xd4\x02\x20!\
    \n\x0e\n\x06\x04\x20\x04\0\x02\t\x12\x04\xd5\x02\x10(\n\x0f\n\x07\x04\
    \x20\x04\0\x02\t\x01\x12\x04\xd5\x02\x10#\n\x0f\n\x07\x04\x20\x04\0\x02\
    \t\x02\x12\x04\xd5\x02&'\n\x0e\n\x06\x04\x20\x04\0\x02\n\x12\x04\xd6\x02\
    \x10&\n\x0f\n\x07\x04\x20\x04\0\x02\n\x01\x12\x04\xd6\x02\x10\x20\n\x0f\
    \n\x07\x04\x20\x04\0\x02\n\x02\x12\x04\xd6\x02#%\n\x0e\n\x06\x04\x20\x04\
    \0\x02\x0b\x12\x04\xd7\x02\x10#\n\x0f\n\x07\x04\x20\x04\0\x02\x0b\x01\
    \x12\x04\xd7\x02\x10\x1d\n\x0f\n\x07\x04\x20\x04\0\x02\x0b\x02\x12\x04\
    \xd7\x02\x20\"\n\x0e\n\x06\x04\x20\x04\0\x02\x0c\x12\x04\xd8\x02\x10)\n\
    \x0f\n\x07\x04\x20\x04\0\x02\x0c\x01\x12\x04\xd8\x02\x10#\n\x0f\n\x07\
    \x04\x20\x04\0\x02\x0c\x02\x12\x04\xd8\x02&(\n\x0e\n\x06\x04\x20\x04\0\
    \x02\r\x12\x04\xd9\x02\x10*\n\x0f\n\x07\x04\x20\x04\0\x02\r\x01\x12\x04\
    \xd9\x02\x10$\n\x0f\n\x07\x04\x20\x04\0\x02\r\x02\x12\x04\xd9\x02')\n\
    \x0e\n\x06\x04\x20\x04\0\x02\x0e\x12\x04\xda\x02\x10+\n\x0f\n\x07\x04\
    \x20\x04\0\x02\x0e\x01\x12\x04\xda\x02\x10%\n\x0f\n\x07\x04\x20\x04\0\
    \x02\x0e\x02\x12\x04\xda\x02(*\n\x0e\n\x06\x04\x20\x04\0\x02\x0f\x12\x04\
    \xdb\x02\x10'\n\x0f\n\x07\x04\x20\x04\0\x02\x0f\x01\x12\x04\xdb\x02\x10!\
    \n\x0f\n\x07\x04\x20\x04\0\x02\x0f\x02\x12\x04\xdb\x02$&\n\x0e\n\x06\x04\
    \x20\x04\0\x02\x10\x12\x04\xdc\x02\x10+\n\x0f\n\x07\x04\x20\x04\0\x02\
    \x10\x01\x12\x04\xdc\x02\x10%\n\x0f\n\x07\x04\x20\x04\0\x02\x10\x02\x12\
    \x04\xdc\x02(*\n\x0e\n\x06\x04\x20\x04\0\x02\x11\x12\x04\xdd\x02\x10&\n\
    \x0f\n\x07\x04\x20\x04\0\x02\x11\x01\x12\x04\xdd\x02\x10\x20\n\x0f\n\x07\
    \x04\x20\x04\0\x02\x11\x02\x12\x04\xdd\x02#%\n\x0e\n\x06\x04\x20\x04\0\
    \x02\x12\x12\x04\xde\x02\x10'\n\x0f\n\x07\x04\x20\x04\0\x02\x12\x01\x12\
    \x04\xde\x02\x10!\n\x0f\n\x07\x04\x20\x04\0\x02\x12\x02\x12\x04\xde\x02$\
    &\n\x0e\n\x06\x04\x20\x04\0\x02\x13\x12\x04\xdf\x02\x10(\n\x0f\n\x07\x04\
    \x20\x04\0\x02\x13\x01\x12\x04\xdf\x02\x10\"\n\x0f\n\x07\x04\x20\x04\0\
    \x02\x13\x02\x12\x04\xdf\x02%'\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xe2\x02\
    \x08H\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04\
    \x20\x02\0\x06\x12\x04\xe2\x02\x11<\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\
    \xe2\x02=C\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xe2\x02FG\n\x0c\n\x02\x04\
    !\x12\x06\xe5\x02\0\xe8\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\xe5\x02\x08\
    1\n\x0c\n\x04\x04!\x02\0\x12\x04\xe6\x02\x08-\n\r\n\x05\x04!\x02\0\x04\
    \x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\xe6\x02\x11\
    \x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\xe6\x02\x18(\n\r\n\x05\x04!\x02\0\
    \x03\x12\x04\xe6\x02+,\n\x0c\n\x04\x04!\x02\x01\x12\x04\xe7\x02\x08<\n\r\
    \n\x05\x04!\x02\x01\x04\x12\x04\xe7\x02\x08\x10\n\r\n\x05\x04!\x02\x01\
    \x06\x12\x04\xe7\x02\x11.\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xe7\x02/7\n\
    \r\n\x05\x04!\x02\x01\x03\x12\x04\xe7\x02:;\n\x0c\n\x02\x04\"\x12\x06\
    \xea\x02\0\xfc\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xea\x02\x089\n\x0e\
    \n\x04\x04\"\x04\0\x12\x06\xeb\x02\x08\xf9\x02\t\n\r\n\x05\x04\"\x04\0\
    \x01\x12\x04\xeb\x02\r\x16\n\x0e\n\x06\x04\"\x04\0\x02\0\x12\x04\xec\x02\
    \x10%\n\x0f\n\x07\x04\"\x04\0\x02\0\x01\x12\x04\xec\x02\x10\x20\n\x0f\n\
    \x07\x04\"\x04\0\x02\0\x02\x12\x04\xec\x02#$\n\x0e\n\x06\x04\"\x04\0\x02\
    \x01\x12\x04\xed\x02\x10\x1f\n\x0f\n\x07\x04\"\x04\0\x02\x01\x01\x12\x04\
    \xed\x02\x10\x1a\n\x0f\n\x07\x04\"\x04\0\x02\x01\x02\x12\x04\xed\x02\x1d\
    \x1e\n\x0e\n\x06\x04\"\x04\0\x02\x02\x12\x04\xee\x02\x10\x1f\n\x0f\n\x07\
    \x04\"\x04\0\x02\x02\x01\x12\x04\xee\x02\x10\x1a\n\x0f\n\x07\x04\"\x04\0\
    \x02\x02\x02\x12\x04\xee\x02\x1d\x1e\n\x0e\n\x06\x04\"\x04\0\x02\x03\x12\
    \x04\xef\x02\x10\x20\n\x0f\n\x07\x04\"\x04\0\x02\x03\x01\x12\x04\xef\x02\
    \x10\x1b\n\x0f\n\x07\x04\"\x04\0\x02\x03\x02\x12\x04\xef\x02\x1e\x1f\n\
    \x0e\n\x06\x04\"\x04\0\x02\x04\x12\x04\xf0\x02\x10\x1f\n\x0f\n\x07\x04\"\
    \x04\0\x02\x04\x01\x12\x04\xf0\x02\x10\x1a\n\x0f\n\x07\x04\"\x04\0\x02\
    \x04\x02\x12\x04\xf0\x02\x1d\x1e\n\x0e\n\x06\x04\"\x04\0\x02\x05\x12\x04\
    \xf1\x02\x10%\n\x0f\n\x07\x04\"\x04\0\x02\x05\x01\x12\x04\xf1\x02\x10\
    \x20\n\x0f\n\x07\x04\"\x04\0\x02\x05\x02\x12\x04\xf1\x02#$\n\x0e\n\x06\
    \x04\"\x04\0\x02\x06\x12\x04\xf2\x02\x10)\n\x0f\n\x07\x04\"\x04\0\x02\
    \x06\x01\x12\x04\xf2\x02\x10$\n\x0f\n\x07\x04\"\x04\0\x02\x06\x02\x12\
    \x04\xf2\x02'(\n\x0e\n\x06\x04\"\x04\0\x02\x07\x12\x04\xf3\x02\x10'\n\
    \x0f\n\x07\x04\"\x04\0\x02\x07\x01\x12\x04\xf3\x02\x10\"\n\x0f\n\x07\x04\
    \"\x04\0\x02\x07\x02\x12\x04\xf3\x02%&\n\x0e\n\x06\x04\"\x04\0\x02\x08\
    \x12\x04\xf4\x02\x10)\n\x0f\n\x07\x04\"\x04\0\x02\x08\x01\x12\x04\xf4\
    \x02\x10$\n\x0f\n\x07\x04\"\x04\0\x02\x08\x02\x12\x04\xf4\x02'(\n\x0e\n\
    \x06\x04\"\x04\0\x02\t\x12\x04\xf5\x02\x10(\n\x0f\n\x07\x04\"\x04\0\x02\
    \t\x01\x12\x04\xf5\x02\x10#\n\x0f\n\x07\x04\"\x04\0\x02\t\x02\x12\x04\
    \xf5\x02&'\n\x0e\n\x06\x04\"\x04\0\x02\n\x12\x04\xf6\x02\x10\"\n\x0f\n\
    \x07\x04\"\x04\0\x02\n\x01\x12\x04\xf6\x02\x10\x1c\n\x0f\n\x07\x04\"\x04\
    \0\x02\n\x02\x12\x04\xf6\x02\x1f!\n\x0e\n\x06\x04\"\x04\0\x02\x0b\x12\
    \x04\xf7\x02\x10(\n\x0f\n\x07\x04\"\x04\0\x02\x0b\x01\x12\x04\xf7\x02\
    \x10\"\n\x0f\n\x07\x04\"\x04\0\x02\x0b\x02\x12\x04\xf7\x02%'\n\x0e\n\x06\
    \x04\"\x04\0\x02\x0c\x12\x04\xf8\x02\x10)\n\x0f\n\x07\x04\"\x04\0\x02\
    \x0c\x01\x12\x04\xf8\x02\x10#\n\x0f\n\x07\x04\"\x04\0\x02\x0c\x02\x12\
    \x04\xf8\x02&(\n\x0c\n\x04\x04\"\x02\0\x12\x04\xfb\x02\x08X\n\r\n\x05\
    \x04\"\x02\0\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04\"\x02\0\x06\x12\
    \x04\xfb\x02\x11L\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xfb\x02MS\n\r\n\x05\
    \x04\"\x02\0\x03\x12\x04\xfb\x02VW\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common_lobby::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(35);
            messages.push(CMsgPlayerCoachMatch::generated_message_descriptor_data());
            messages.push(CMsgPrivateCoachingSessionMember::generated_message_descriptor_data());
            messages.push(CMsgPrivateCoachingSession::generated_message_descriptor_data());
            messages.push(CMsgPrivateCoachingSessionStatus::generated_message_descriptor_data());
            messages.push(CMsgAvailablePrivateCoachingSession::generated_message_descriptor_data());
            messages.push(CMsgAvailablePrivateCoachingSessionList::generated_message_descriptor_data());
            messages.push(CMsgAvailablePrivateCoachingSessionSummary::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestPlayerCoachMatches::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestPlayerCoachMatchesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestPlayerCoachMatch::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestPlayerCoachMatchResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSubmitCoachTeammateRating::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSubmitCoachTeammateRatingResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientCoachTeammateRatingsChanged::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestPrivateCoachingSession::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestPrivateCoachingSessionResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAcceptPrivateCoachingSession::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAcceptPrivateCoachingSessionResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCLeavePrivateCoachingSession::generated_message_descriptor_data());
            messages.push(CMsgClientToGCLeavePrivateCoachingSessionResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetCurrentPrivateCoachingSession::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetCurrentPrivateCoachingSessionResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientPrivateCoachingSessionUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSubmitPrivateCoachingSessionRating::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSubmitPrivateCoachingSessionRatingResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetAvailablePrivateCoachingSessions::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetAvailablePrivateCoachingSessionsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetAvailablePrivateCoachingSessionsSummary::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetAvailablePrivateCoachingSessionsSummaryResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCJoinPrivateCoachingSessionLobby::generated_message_descriptor_data());
            messages.push(CMsgClientToGCJoinPrivateCoachingSessionLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCoachFriend::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCoachFriendResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRespondToCoachFriendRequest::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRespondToCoachFriendRequestResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(17);
            enums.push(ECoachTeammateRating::generated_enum_descriptor_data());
            enums.push(EPrivateCoachingSessionState::generated_enum_descriptor_data());
            enums.push(EPrivateCoachingSessionMemberFlag::generated_enum_descriptor_data());
            enums.push(EPlayerCoachMatchFlag::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_player_coach_matches_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_player_coach_match_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcsubmit_coach_teammate_rating_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_private_coaching_session_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcaccept_private_coaching_session_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcleave_private_coaching_session_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_current_private_coaching_session_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcsubmit_private_coaching_session_rating_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_available_private_coaching_sessions_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_available_private_coaching_sessions_summary_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcjoin_private_coaching_session_lobby_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccoach_friend_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrespond_to_coach_friend_request_response::EResponse::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
