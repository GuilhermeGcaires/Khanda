// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `base_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CGCStorePurchaseInit_LineItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCStorePurchaseInit_LineItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCStorePurchaseInit_LineItem.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCStorePurchaseInit_LineItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCStorePurchaseInit_LineItem.cost_in_local_currency)
    pub cost_in_local_currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCStorePurchaseInit_LineItem.purchase_type)
    pub purchase_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCStorePurchaseInit_LineItem.source_reference_id)
    pub source_reference_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCStorePurchaseInit_LineItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCStorePurchaseInit_LineItem {
    fn default() -> &'a CGCStorePurchaseInit_LineItem {
        <CGCStorePurchaseInit_LineItem as ::protobuf::Message>::default_instance()
    }
}

impl CGCStorePurchaseInit_LineItem {
    pub fn new() -> CGCStorePurchaseInit_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 cost_in_local_currency = 3;

    pub fn cost_in_local_currency(&self) -> u32 {
        self.cost_in_local_currency.unwrap_or(0)
    }

    pub fn clear_cost_in_local_currency(&mut self) {
        self.cost_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_cost_in_local_currency(&self) -> bool {
        self.cost_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_in_local_currency(&mut self, v: u32) {
        self.cost_in_local_currency = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_type = 4;

    pub fn purchase_type(&self) -> u32 {
        self.purchase_type.unwrap_or(0)
    }

    pub fn clear_purchase_type(&mut self) {
        self.purchase_type = ::std::option::Option::None;
    }

    pub fn has_purchase_type(&self) -> bool {
        self.purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_type(&mut self, v: u32) {
        self.purchase_type = ::std::option::Option::Some(v);
    }

    // optional uint64 source_reference_id = 5;

    pub fn source_reference_id(&self) -> u64 {
        self.source_reference_id.unwrap_or(0)
    }

    pub fn clear_source_reference_id(&mut self) {
        self.source_reference_id = ::std::option::Option::None;
    }

    pub fn has_source_reference_id(&self) -> bool {
        self.source_reference_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_reference_id(&mut self, v: u64) {
        self.source_reference_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CGCStorePurchaseInit_LineItem| { &m.item_def_id },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.item_def_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CGCStorePurchaseInit_LineItem| { &m.quantity },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cost_in_local_currency",
            |m: &CGCStorePurchaseInit_LineItem| { &m.cost_in_local_currency },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.cost_in_local_currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_type",
            |m: &CGCStorePurchaseInit_LineItem| { &m.purchase_type },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.purchase_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_reference_id",
            |m: &CGCStorePurchaseInit_LineItem| { &m.source_reference_id },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.source_reference_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCStorePurchaseInit_LineItem>(
            "CGCStorePurchaseInit_LineItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCStorePurchaseInit_LineItem {
    const NAME: &'static str = "CGCStorePurchaseInit_LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cost_in_local_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.purchase_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.source_reference_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cost_in_local_currency {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.purchase_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.source_reference_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cost_in_local_currency {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.purchase_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.source_reference_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCStorePurchaseInit_LineItem {
        CGCStorePurchaseInit_LineItem::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.cost_in_local_currency = ::std::option::Option::None;
        self.purchase_type = ::std::option::Option::None;
        self.source_reference_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCStorePurchaseInit_LineItem {
        static instance: CGCStorePurchaseInit_LineItem = CGCStorePurchaseInit_LineItem {
            item_def_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            cost_in_local_currency: ::std::option::Option::None,
            purchase_type: ::std::option::Option::None,
            source_reference_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCStorePurchaseInit_LineItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCStorePurchaseInit_LineItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCStorePurchaseInit_LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCStorePurchaseInit_LineItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCStorePurchaseInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseInit {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseInit.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseInit.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseInit.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseInit.line_items)
    pub line_items: ::std::vec::Vec<CGCStorePurchaseInit_LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCStorePurchaseInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInit {
    fn default() -> &'a CMsgGCStorePurchaseInit {
        <CMsgGCStorePurchaseInit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInit {
    pub fn new() -> CMsgGCStorePurchaseInit {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &CMsgGCStorePurchaseInit| { &m.country },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgGCStorePurchaseInit| { &m.language },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgGCStorePurchaseInit| { &m.currency },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &CMsgGCStorePurchaseInit| { &m.line_items },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.line_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseInit>(
            "CMsgGCStorePurchaseInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInit {
    const NAME: &'static str = "CMsgGCStorePurchaseInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInit {
        CMsgGCStorePurchaseInit::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInit {
        static instance: CMsgGCStorePurchaseInit = CMsgGCStorePurchaseInit {
            country: ::std::option::Option::None,
            language: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCStorePurchaseInitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseInitResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseInitResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseInitResponse.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCStorePurchaseInitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInitResponse {
    fn default() -> &'a CMsgGCStorePurchaseInitResponse {
        <CMsgGCStorePurchaseInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInitResponse {
    pub fn new() -> CMsgGCStorePurchaseInitResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_id = 2;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseInitResponse>(
            "CMsgGCStorePurchaseInitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInitResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseInitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.txn_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInitResponse {
        CMsgGCStorePurchaseInitResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInitResponse {
        static instance: CMsgGCStorePurchaseInitResponse = CMsgGCStorePurchaseInitResponse {
            result: ::std::option::Option::None,
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseInitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseInitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientPingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPingData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientPingData.relay_codes)
    pub relay_codes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientPingData.relay_pings)
    pub relay_pings: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientPingData.region_codes)
    pub region_codes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientPingData.region_pings)
    pub region_pings: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientPingData.region_ping_failed_bitmask)
    pub region_ping_failed_bitmask: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientPingData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPingData {
    fn default() -> &'a CMsgClientPingData {
        <CMsgClientPingData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPingData {
    pub fn new() -> CMsgClientPingData {
        ::std::default::Default::default()
    }

    // optional uint32 region_ping_failed_bitmask = 10;

    pub fn region_ping_failed_bitmask(&self) -> u32 {
        self.region_ping_failed_bitmask.unwrap_or(0)
    }

    pub fn clear_region_ping_failed_bitmask(&mut self) {
        self.region_ping_failed_bitmask = ::std::option::Option::None;
    }

    pub fn has_region_ping_failed_bitmask(&self) -> bool {
        self.region_ping_failed_bitmask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_ping_failed_bitmask(&mut self, v: u32) {
        self.region_ping_failed_bitmask = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "relay_codes",
            |m: &CMsgClientPingData| { &m.relay_codes },
            |m: &mut CMsgClientPingData| { &mut m.relay_codes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "relay_pings",
            |m: &CMsgClientPingData| { &m.relay_pings },
            |m: &mut CMsgClientPingData| { &mut m.relay_pings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "region_codes",
            |m: &CMsgClientPingData| { &m.region_codes },
            |m: &mut CMsgClientPingData| { &mut m.region_codes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "region_pings",
            |m: &CMsgClientPingData| { &m.region_pings },
            |m: &mut CMsgClientPingData| { &mut m.region_pings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_ping_failed_bitmask",
            |m: &CMsgClientPingData| { &m.region_ping_failed_bitmask },
            |m: &mut CMsgClientPingData| { &mut m.region_ping_failed_bitmask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPingData>(
            "CMsgClientPingData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPingData {
    const NAME: &'static str = "CMsgClientPingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    is.read_repeated_packed_fixed32_into(&mut self.relay_codes)?;
                },
                37 => {
                    self.relay_codes.push(is.read_fixed32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.relay_pings)?;
                },
                40 => {
                    self.relay_pings.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.region_codes)?;
                },
                64 => {
                    self.region_codes.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.region_pings)?;
                },
                72 => {
                    self.region_pings.push(is.read_uint32()?);
                },
                80 => {
                    self.region_ping_failed_bitmask = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.relay_codes.len() as u64;
        for value in &self.relay_pings {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.region_codes {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.region_pings {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.region_ping_failed_bitmask {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.relay_codes {
            os.write_fixed32(4, *v)?;
        };
        for v in &self.relay_pings {
            os.write_uint32(5, *v)?;
        };
        for v in &self.region_codes {
            os.write_uint32(8, *v)?;
        };
        for v in &self.region_pings {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.region_ping_failed_bitmask {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPingData {
        CMsgClientPingData::new()
    }

    fn clear(&mut self) {
        self.relay_codes.clear();
        self.relay_pings.clear();
        self.region_codes.clear();
        self.region_pings.clear();
        self.region_ping_failed_bitmask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPingData {
        static instance: CMsgClientPingData = CMsgClientPingData {
            relay_codes: ::std::vec::Vec::new(),
            relay_pings: ::std::vec::Vec::new(),
            region_codes: ::std::vec::Vec::new(),
            region_pings: ::std::vec::Vec::new(),
            region_ping_failed_bitmask: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPingData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPingData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPingData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgInviteToParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInviteToParty {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgInviteToParty.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgInviteToParty.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgInviteToParty.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgInviteToParty.as_coach)
    pub as_coach: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgInviteToParty.ping_data)
    pub ping_data: ::protobuf::MessageField<CMsgClientPingData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgInviteToParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInviteToParty {
    fn default() -> &'a CMsgInviteToParty {
        <CMsgInviteToParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInviteToParty {
    pub fn new() -> CMsgInviteToParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 3;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional bool as_coach = 4;

    pub fn as_coach(&self) -> bool {
        self.as_coach.unwrap_or(false)
    }

    pub fn clear_as_coach(&mut self) {
        self.as_coach = ::std::option::Option::None;
    }

    pub fn has_as_coach(&self) -> bool {
        self.as_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_coach(&mut self, v: bool) {
        self.as_coach = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgInviteToParty| { &m.steam_id },
            |m: &mut CMsgInviteToParty| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgInviteToParty| { &m.client_version },
            |m: &mut CMsgInviteToParty| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CMsgInviteToParty| { &m.team_id },
            |m: &mut CMsgInviteToParty| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "as_coach",
            |m: &CMsgInviteToParty| { &m.as_coach },
            |m: &mut CMsgInviteToParty| { &mut m.as_coach },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgClientPingData>(
            "ping_data",
            |m: &CMsgInviteToParty| { &m.ping_data },
            |m: &mut CMsgInviteToParty| { &mut m.ping_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInviteToParty>(
            "CMsgInviteToParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgInviteToParty {
    const NAME: &'static str = "CMsgInviteToParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.as_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.as_coach {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.as_coach {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.ping_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInviteToParty {
        CMsgInviteToParty::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.as_coach = ::std::option::Option::None;
        self.ping_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInviteToParty {
        static instance: CMsgInviteToParty = CMsgInviteToParty {
            steam_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            as_coach: ::std::option::Option::None,
            ping_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgInviteToParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInviteToParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInviteToParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInviteToParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgInviteToLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInviteToLobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgInviteToLobby.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgInviteToLobby.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgInviteToLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInviteToLobby {
    fn default() -> &'a CMsgInviteToLobby {
        <CMsgInviteToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInviteToLobby {
    pub fn new() -> CMsgInviteToLobby {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgInviteToLobby| { &m.steam_id },
            |m: &mut CMsgInviteToLobby| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgInviteToLobby| { &m.client_version },
            |m: &mut CMsgInviteToLobby| { &mut m.client_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInviteToLobby>(
            "CMsgInviteToLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgInviteToLobby {
    const NAME: &'static str = "CMsgInviteToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInviteToLobby {
        CMsgInviteToLobby::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInviteToLobby {
        static instance: CMsgInviteToLobby = CMsgInviteToLobby {
            steam_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgInviteToLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInviteToLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInviteToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInviteToLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgInvitationCreated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInvitationCreated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgInvitationCreated.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgInvitationCreated.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgInvitationCreated.user_offline)
    pub user_offline: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgInvitationCreated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInvitationCreated {
    fn default() -> &'a CMsgInvitationCreated {
        <CMsgInvitationCreated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInvitationCreated {
    pub fn new() -> CMsgInvitationCreated {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id = 2;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional bool user_offline = 3;

    pub fn user_offline(&self) -> bool {
        self.user_offline.unwrap_or(false)
    }

    pub fn clear_user_offline(&mut self) {
        self.user_offline = ::std::option::Option::None;
    }

    pub fn has_user_offline(&self) -> bool {
        self.user_offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_offline(&mut self, v: bool) {
        self.user_offline = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CMsgInvitationCreated| { &m.group_id },
            |m: &mut CMsgInvitationCreated| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgInvitationCreated| { &m.steam_id },
            |m: &mut CMsgInvitationCreated| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_offline",
            |m: &CMsgInvitationCreated| { &m.user_offline },
            |m: &mut CMsgInvitationCreated| { &mut m.user_offline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInvitationCreated>(
            "CMsgInvitationCreated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgInvitationCreated {
    const NAME: &'static str = "CMsgInvitationCreated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.user_offline = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.user_offline {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.user_offline {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInvitationCreated {
        CMsgInvitationCreated::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.user_offline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInvitationCreated {
        static instance: CMsgInvitationCreated = CMsgInvitationCreated {
            group_id: ::std::option::Option::None,
            steam_id: ::std::option::Option::None,
            user_offline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgInvitationCreated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInvitationCreated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInvitationCreated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInvitationCreated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPartyInviteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyInviteResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPartyInviteResponse.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPartyInviteResponse.accept)
    pub accept: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPartyInviteResponse.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPartyInviteResponse.ping_data)
    pub ping_data: ::protobuf::MessageField<CMsgClientPingData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPartyInviteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyInviteResponse {
    fn default() -> &'a CMsgPartyInviteResponse {
        <CMsgPartyInviteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyInviteResponse {
    pub fn new() -> CMsgPartyInviteResponse {
        ::std::default::Default::default()
    }

    // optional uint64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;

    pub fn accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }

    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyInviteResponse| { &m.party_id },
            |m: &mut CMsgPartyInviteResponse| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accept",
            |m: &CMsgPartyInviteResponse| { &m.accept },
            |m: &mut CMsgPartyInviteResponse| { &mut m.accept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgPartyInviteResponse| { &m.client_version },
            |m: &mut CMsgPartyInviteResponse| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgClientPingData>(
            "ping_data",
            |m: &CMsgPartyInviteResponse| { &m.ping_data },
            |m: &mut CMsgPartyInviteResponse| { &mut m.ping_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyInviteResponse>(
            "CMsgPartyInviteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyInviteResponse {
    const NAME: &'static str = "CMsgPartyInviteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.accept = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.accept {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ping_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyInviteResponse {
        CMsgPartyInviteResponse::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.ping_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyInviteResponse {
        static instance: CMsgPartyInviteResponse = CMsgPartyInviteResponse {
            party_id: ::std::option::Option::None,
            accept: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            ping_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyInviteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyInviteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyInviteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyInviteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyInviteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyInviteResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyInviteResponse.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyInviteResponse.accept)
    pub accept: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyInviteResponse.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyInviteResponse.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyInviteResponse.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyInviteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyInviteResponse {
    fn default() -> &'a CMsgLobbyInviteResponse {
        <CMsgLobbyInviteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyInviteResponse {
    pub fn new() -> CMsgLobbyInviteResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;

    pub fn accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }

    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional fixed64 custom_game_crc = 6;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 7;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgLobbyInviteResponse| { &m.lobby_id },
            |m: &mut CMsgLobbyInviteResponse| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accept",
            |m: &CMsgLobbyInviteResponse| { &m.accept },
            |m: &mut CMsgLobbyInviteResponse| { &mut m.accept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgLobbyInviteResponse| { &m.client_version },
            |m: &mut CMsgLobbyInviteResponse| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_crc",
            |m: &CMsgLobbyInviteResponse| { &m.custom_game_crc },
            |m: &mut CMsgLobbyInviteResponse| { &mut m.custom_game_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_timestamp",
            |m: &CMsgLobbyInviteResponse| { &m.custom_game_timestamp },
            |m: &mut CMsgLobbyInviteResponse| { &mut m.custom_game_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyInviteResponse>(
            "CMsgLobbyInviteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyInviteResponse {
    const NAME: &'static str = "CMsgLobbyInviteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.accept = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                49 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                61 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accept {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyInviteResponse {
        CMsgLobbyInviteResponse::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyInviteResponse {
        static instance: CMsgLobbyInviteResponse = CMsgLobbyInviteResponse {
            lobby_id: ::std::option::Option::None,
            accept: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyInviteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyInviteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyInviteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyInviteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgKickFromParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKickFromParty {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgKickFromParty.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgKickFromParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKickFromParty {
    fn default() -> &'a CMsgKickFromParty {
        <CMsgKickFromParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKickFromParty {
    pub fn new() -> CMsgKickFromParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgKickFromParty| { &m.steam_id },
            |m: &mut CMsgKickFromParty| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKickFromParty>(
            "CMsgKickFromParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKickFromParty {
    const NAME: &'static str = "CMsgKickFromParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKickFromParty {
        CMsgKickFromParty::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKickFromParty {
        static instance: CMsgKickFromParty = CMsgKickFromParty {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKickFromParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKickFromParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKickFromParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKickFromParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLeaveParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaveParty {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLeaveParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaveParty {
    fn default() -> &'a CMsgLeaveParty {
        <CMsgLeaveParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaveParty {
    pub fn new() -> CMsgLeaveParty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLeaveParty>(
            "CMsgLeaveParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLeaveParty {
    const NAME: &'static str = "CMsgLeaveParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaveParty {
        CMsgLeaveParty::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaveParty {
        static instance: CMsgLeaveParty = CMsgLeaveParty {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLeaveParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLeaveParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLeaveParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaveParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCustomGameInstallStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCustomGameInstallStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCustomGameInstallStatus.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<ECustomGameInstallStatus>>,
    // @@protoc_insertion_point(field:dota.CMsgCustomGameInstallStatus.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgCustomGameInstallStatus.latest_timestamp_from_steam)
    pub latest_timestamp_from_steam: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCustomGameInstallStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCustomGameInstallStatus {
    fn default() -> &'a CMsgCustomGameInstallStatus {
        <CMsgCustomGameInstallStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCustomGameInstallStatus {
    pub fn new() -> CMsgCustomGameInstallStatus {
        ::std::default::Default::default()
    }

    // optional .dota.ECustomGameInstallStatus status = 1;

    pub fn status(&self) -> ECustomGameInstallStatus {
        match self.status {
            Some(e) => e.enum_value_or(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown),
            None => ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ECustomGameInstallStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 latest_timestamp_from_steam = 3;

    pub fn latest_timestamp_from_steam(&self) -> u32 {
        self.latest_timestamp_from_steam.unwrap_or(0)
    }

    pub fn clear_latest_timestamp_from_steam(&mut self) {
        self.latest_timestamp_from_steam = ::std::option::Option::None;
    }

    pub fn has_latest_timestamp_from_steam(&self) -> bool {
        self.latest_timestamp_from_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_timestamp_from_steam(&mut self, v: u32) {
        self.latest_timestamp_from_steam = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgCustomGameInstallStatus| { &m.status },
            |m: &mut CMsgCustomGameInstallStatus| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgCustomGameInstallStatus| { &m.message },
            |m: &mut CMsgCustomGameInstallStatus| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "latest_timestamp_from_steam",
            |m: &CMsgCustomGameInstallStatus| { &m.latest_timestamp_from_steam },
            |m: &mut CMsgCustomGameInstallStatus| { &mut m.latest_timestamp_from_steam },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCustomGameInstallStatus>(
            "CMsgCustomGameInstallStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCustomGameInstallStatus {
    const NAME: &'static str = "CMsgCustomGameInstallStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                29 => {
                    self.latest_timestamp_from_steam = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.latest_timestamp_from_steam {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.latest_timestamp_from_steam {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCustomGameInstallStatus {
        CMsgCustomGameInstallStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.latest_timestamp_from_steam = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCustomGameInstallStatus {
        static instance: CMsgCustomGameInstallStatus = CMsgCustomGameInstallStatus {
            status: ::std::option::Option::None,
            message: ::std::option::Option::None,
            latest_timestamp_from_steam: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCustomGameInstallStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCustomGameInstallStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCustomGameInstallStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCustomGameInstallStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerAvailable {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerAvailable.custom_game_install_status)
    pub custom_game_install_status: ::protobuf::MessageField<CMsgCustomGameInstallStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerAvailable {
    fn default() -> &'a CMsgServerAvailable {
        <CMsgServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerAvailable {
    pub fn new() -> CMsgServerAvailable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCustomGameInstallStatus>(
            "custom_game_install_status",
            |m: &CMsgServerAvailable| { &m.custom_game_install_status },
            |m: &mut CMsgServerAvailable| { &mut m.custom_game_install_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerAvailable>(
            "CMsgServerAvailable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerAvailable {
    const NAME: &'static str = "CMsgServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_install_status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_install_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.custom_game_install_status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerAvailable {
        CMsgServerAvailable::new()
    }

    fn clear(&mut self) {
        self.custom_game_install_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerAvailable {
        static instance: CMsgServerAvailable = CMsgServerAvailable {
            custom_game_install_status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerAvailable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerAvailable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLANServerAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLANServerAvailable {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLANServerAvailable.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLANServerAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLANServerAvailable {
    fn default() -> &'a CMsgLANServerAvailable {
        <CMsgLANServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLANServerAvailable {
    pub fn new() -> CMsgLANServerAvailable {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgLANServerAvailable| { &m.lobby_id },
            |m: &mut CMsgLANServerAvailable| { &mut m.lobby_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLANServerAvailable>(
            "CMsgLANServerAvailable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLANServerAvailable {
    const NAME: &'static str = "CMsgLANServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLANServerAvailable {
        CMsgLANServerAvailable::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLANServerAvailable {
        static instance: CMsgLANServerAvailable = CMsgLANServerAvailable {
            lobby_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLANServerAvailable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLANServerAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLANServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLANServerAvailable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSOEconGameAccountClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconGameAccountClient {
    // message fields
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.additional_backpack_slots)
    pub additional_backpack_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.trial_account)
    pub trial_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.eligible_for_online_play)
    pub eligible_for_online_play: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.need_to_choose_most_helpful_friend)
    pub need_to_choose_most_helpful_friend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.in_coaches_list)
    pub in_coaches_list: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.trade_ban_expiration)
    pub trade_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.duel_ban_expiration)
    pub duel_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconGameAccountClient.made_first_purchase)
    pub made_first_purchase: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSOEconGameAccountClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountClient {
    fn default() -> &'a CSOEconGameAccountClient {
        <CSOEconGameAccountClient as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountClient {
    pub fn new() -> CSOEconGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 additional_backpack_slots = 1;

    pub fn additional_backpack_slots(&self) -> u32 {
        self.additional_backpack_slots.unwrap_or(0)
    }

    pub fn clear_additional_backpack_slots(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
    }

    pub fn has_additional_backpack_slots(&self) -> bool {
        self.additional_backpack_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_backpack_slots(&mut self, v: u32) {
        self.additional_backpack_slots = ::std::option::Option::Some(v);
    }

    // optional bool trial_account = 2;

    pub fn trial_account(&self) -> bool {
        self.trial_account.unwrap_or(false)
    }

    pub fn clear_trial_account(&mut self) {
        self.trial_account = ::std::option::Option::None;
    }

    pub fn has_trial_account(&self) -> bool {
        self.trial_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trial_account(&mut self, v: bool) {
        self.trial_account = ::std::option::Option::Some(v);
    }

    // optional bool eligible_for_online_play = 3;

    pub fn eligible_for_online_play(&self) -> bool {
        self.eligible_for_online_play.unwrap_or(false)
    }

    pub fn clear_eligible_for_online_play(&mut self) {
        self.eligible_for_online_play = ::std::option::Option::None;
    }

    pub fn has_eligible_for_online_play(&self) -> bool {
        self.eligible_for_online_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eligible_for_online_play(&mut self, v: bool) {
        self.eligible_for_online_play = ::std::option::Option::Some(v);
    }

    // optional bool need_to_choose_most_helpful_friend = 4;

    pub fn need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.unwrap_or(false)
    }

    pub fn clear_need_to_choose_most_helpful_friend(&mut self) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
    }

    pub fn has_need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_to_choose_most_helpful_friend(&mut self, v: bool) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(v);
    }

    // optional bool in_coaches_list = 5;

    pub fn in_coaches_list(&self) -> bool {
        self.in_coaches_list.unwrap_or(false)
    }

    pub fn clear_in_coaches_list(&mut self) {
        self.in_coaches_list = ::std::option::Option::None;
    }

    pub fn has_in_coaches_list(&self) -> bool {
        self.in_coaches_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_coaches_list(&mut self, v: bool) {
        self.in_coaches_list = ::std::option::Option::Some(v);
    }

    // optional fixed32 trade_ban_expiration = 6;

    pub fn trade_ban_expiration(&self) -> u32 {
        self.trade_ban_expiration.unwrap_or(0)
    }

    pub fn clear_trade_ban_expiration(&mut self) {
        self.trade_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_trade_ban_expiration(&self) -> bool {
        self.trade_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_ban_expiration(&mut self, v: u32) {
        self.trade_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional fixed32 duel_ban_expiration = 7;

    pub fn duel_ban_expiration(&self) -> u32 {
        self.duel_ban_expiration.unwrap_or(0)
    }

    pub fn clear_duel_ban_expiration(&mut self) {
        self.duel_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_duel_ban_expiration(&self) -> bool {
        self.duel_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_ban_expiration(&mut self, v: u32) {
        self.duel_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional bool made_first_purchase = 9;

    pub fn made_first_purchase(&self) -> bool {
        self.made_first_purchase.unwrap_or(false)
    }

    pub fn clear_made_first_purchase(&mut self) {
        self.made_first_purchase = ::std::option::Option::None;
    }

    pub fn has_made_first_purchase(&self) -> bool {
        self.made_first_purchase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_made_first_purchase(&mut self, v: bool) {
        self.made_first_purchase = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_backpack_slots",
            |m: &CSOEconGameAccountClient| { &m.additional_backpack_slots },
            |m: &mut CSOEconGameAccountClient| { &mut m.additional_backpack_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trial_account",
            |m: &CSOEconGameAccountClient| { &m.trial_account },
            |m: &mut CSOEconGameAccountClient| { &mut m.trial_account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eligible_for_online_play",
            |m: &CSOEconGameAccountClient| { &m.eligible_for_online_play },
            |m: &mut CSOEconGameAccountClient| { &mut m.eligible_for_online_play },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "need_to_choose_most_helpful_friend",
            |m: &CSOEconGameAccountClient| { &m.need_to_choose_most_helpful_friend },
            |m: &mut CSOEconGameAccountClient| { &mut m.need_to_choose_most_helpful_friend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_coaches_list",
            |m: &CSOEconGameAccountClient| { &m.in_coaches_list },
            |m: &mut CSOEconGameAccountClient| { &mut m.in_coaches_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_ban_expiration",
            |m: &CSOEconGameAccountClient| { &m.trade_ban_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.trade_ban_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duel_ban_expiration",
            |m: &CSOEconGameAccountClient| { &m.duel_ban_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.duel_ban_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "made_first_purchase",
            |m: &CSOEconGameAccountClient| { &m.made_first_purchase },
            |m: &mut CSOEconGameAccountClient| { &mut m.made_first_purchase },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconGameAccountClient>(
            "CSOEconGameAccountClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconGameAccountClient {
    const NAME: &'static str = "CSOEconGameAccountClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_backpack_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trial_account = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.eligible_for_online_play = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.in_coaches_list = ::std::option::Option::Some(is.read_bool()?);
                },
                53 => {
                    self.trade_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.duel_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.made_first_purchase = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_backpack_slots {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trial_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.eligible_for_online_play {
            my_size += 1 + 1;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.in_coaches_list {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trade_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duel_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.made_first_purchase {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.additional_backpack_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trial_account {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.eligible_for_online_play {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.in_coaches_list {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.trade_ban_expiration {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.duel_ban_expiration {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.made_first_purchase {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconGameAccountClient {
        CSOEconGameAccountClient::new()
    }

    fn clear(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
        self.trial_account = ::std::option::Option::None;
        self.eligible_for_online_play = ::std::option::Option::None;
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
        self.in_coaches_list = ::std::option::Option::None;
        self.trade_ban_expiration = ::std::option::Option::None;
        self.duel_ban_expiration = ::std::option::Option::None;
        self.made_first_purchase = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconGameAccountClient {
        static instance: CSOEconGameAccountClient = CSOEconGameAccountClient {
            additional_backpack_slots: ::std::option::Option::None,
            trial_account: ::std::option::Option::None,
            eligible_for_online_play: ::std::option::Option::None,
            need_to_choose_most_helpful_friend: ::std::option::Option::None,
            in_coaches_list: ::std::option::Option::None,
            trade_ban_expiration: ::std::option::Option::None,
            duel_ban_expiration: ::std::option::Option::None,
            made_first_purchase: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconGameAccountClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconGameAccountClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconGameAccountClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconGameAccountClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgApplyStrangePart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyStrangePart {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgApplyStrangePart.strange_part_item_id)
    pub strange_part_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgApplyStrangePart.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgApplyStrangePart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangePart {
    fn default() -> &'a CMsgApplyStrangePart {
        <CMsgApplyStrangePart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangePart {
    pub fn new() -> CMsgApplyStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;

    pub fn strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }

    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_part_item_id",
            |m: &CMsgApplyStrangePart| { &m.strange_part_item_id },
            |m: &mut CMsgApplyStrangePart| { &mut m.strange_part_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgApplyStrangePart| { &m.item_item_id },
            |m: &mut CMsgApplyStrangePart| { &mut m.item_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyStrangePart>(
            "CMsgApplyStrangePart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyStrangePart {
    const NAME: &'static str = "CMsgApplyStrangePart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strange_part_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangePart {
        CMsgApplyStrangePart::new()
    }

    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangePart {
        static instance: CMsgApplyStrangePart = CMsgApplyStrangePart {
            strange_part_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyStrangePart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyStrangePart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyStrangePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangePart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgApplyPennantUpgrade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyPennantUpgrade {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgApplyPennantUpgrade.upgrade_item_id)
    pub upgrade_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgApplyPennantUpgrade.pennant_item_id)
    pub pennant_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgApplyPennantUpgrade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyPennantUpgrade {
    fn default() -> &'a CMsgApplyPennantUpgrade {
        <CMsgApplyPennantUpgrade as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyPennantUpgrade {
    pub fn new() -> CMsgApplyPennantUpgrade {
        ::std::default::Default::default()
    }

    // optional uint64 upgrade_item_id = 1;

    pub fn upgrade_item_id(&self) -> u64 {
        self.upgrade_item_id.unwrap_or(0)
    }

    pub fn clear_upgrade_item_id(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_item_id(&self) -> bool {
        self.upgrade_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_item_id(&mut self, v: u64) {
        self.upgrade_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 pennant_item_id = 2;

    pub fn pennant_item_id(&self) -> u64 {
        self.pennant_item_id.unwrap_or(0)
    }

    pub fn clear_pennant_item_id(&mut self) {
        self.pennant_item_id = ::std::option::Option::None;
    }

    pub fn has_pennant_item_id(&self) -> bool {
        self.pennant_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pennant_item_id(&mut self, v: u64) {
        self.pennant_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgrade_item_id",
            |m: &CMsgApplyPennantUpgrade| { &m.upgrade_item_id },
            |m: &mut CMsgApplyPennantUpgrade| { &mut m.upgrade_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pennant_item_id",
            |m: &CMsgApplyPennantUpgrade| { &m.pennant_item_id },
            |m: &mut CMsgApplyPennantUpgrade| { &mut m.pennant_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyPennantUpgrade>(
            "CMsgApplyPennantUpgrade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyPennantUpgrade {
    const NAME: &'static str = "CMsgApplyPennantUpgrade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upgrade_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.pennant_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pennant_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upgrade_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pennant_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyPennantUpgrade {
        CMsgApplyPennantUpgrade::new()
    }

    fn clear(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
        self.pennant_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyPennantUpgrade {
        static instance: CMsgApplyPennantUpgrade = CMsgApplyPennantUpgrade {
            upgrade_item_id: ::std::option::Option::None,
            pennant_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyPennantUpgrade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyPennantUpgrade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyPennantUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyPennantUpgrade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgApplyEggEssence)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyEggEssence {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgApplyEggEssence.essence_item_id)
    pub essence_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgApplyEggEssence.egg_item_id)
    pub egg_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgApplyEggEssence.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyEggEssence {
    fn default() -> &'a CMsgApplyEggEssence {
        <CMsgApplyEggEssence as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyEggEssence {
    pub fn new() -> CMsgApplyEggEssence {
        ::std::default::Default::default()
    }

    // optional uint64 essence_item_id = 1;

    pub fn essence_item_id(&self) -> u64 {
        self.essence_item_id.unwrap_or(0)
    }

    pub fn clear_essence_item_id(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
    }

    pub fn has_essence_item_id(&self) -> bool {
        self.essence_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essence_item_id(&mut self, v: u64) {
        self.essence_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 egg_item_id = 2;

    pub fn egg_item_id(&self) -> u64 {
        self.egg_item_id.unwrap_or(0)
    }

    pub fn clear_egg_item_id(&mut self) {
        self.egg_item_id = ::std::option::Option::None;
    }

    pub fn has_egg_item_id(&self) -> bool {
        self.egg_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_egg_item_id(&mut self, v: u64) {
        self.egg_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "essence_item_id",
            |m: &CMsgApplyEggEssence| { &m.essence_item_id },
            |m: &mut CMsgApplyEggEssence| { &mut m.essence_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "egg_item_id",
            |m: &CMsgApplyEggEssence| { &m.egg_item_id },
            |m: &mut CMsgApplyEggEssence| { &mut m.egg_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyEggEssence>(
            "CMsgApplyEggEssence",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyEggEssence {
    const NAME: &'static str = "CMsgApplyEggEssence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.essence_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.egg_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.essence_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.egg_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.essence_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.egg_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyEggEssence {
        CMsgApplyEggEssence::new()
    }

    fn clear(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
        self.egg_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyEggEssence {
        static instance: CMsgApplyEggEssence = CMsgApplyEggEssence {
            essence_item_id: ::std::option::Option::None,
            egg_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyEggEssence {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyEggEssence").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyEggEssence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyEggEssence {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSOEconItemAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:dota.CSOEconItemAttribute.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemAttribute.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemAttribute.value_bytes)
    pub value_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSOEconItemAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemAttribute {
    fn default() -> &'a CSOEconItemAttribute {
        <CSOEconItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemAttribute {
    pub fn new() -> CSOEconItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional bytes value_bytes = 3;

    pub fn value_bytes(&self) -> &[u8] {
        match self.value_bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value_bytes(&mut self) {
        self.value_bytes = ::std::option::Option::None;
    }

    pub fn has_value_bytes(&self) -> bool {
        self.value_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value_bytes.is_none() {
            self.value_bytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.value_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItemAttribute| { &m.def_index },
            |m: &mut CSOEconItemAttribute| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CSOEconItemAttribute| { &m.value },
            |m: &mut CSOEconItemAttribute| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_bytes",
            |m: &CSOEconItemAttribute| { &m.value_bytes },
            |m: &mut CSOEconItemAttribute| { &mut m.value_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemAttribute>(
            "CSOEconItemAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemAttribute {
    const NAME: &'static str = "CSOEconItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.value_bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value_bytes.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemAttribute {
        CSOEconItemAttribute::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value_bytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemAttribute {
        static instance: CSOEconItemAttribute = CSOEconItemAttribute {
            def_index: ::std::option::Option::None,
            value: ::std::option::Option::None,
            value_bytes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSOEconItemEquipped)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemEquipped {
    // message fields
    // @@protoc_insertion_point(field:dota.CSOEconItemEquipped.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemEquipped.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSOEconItemEquipped.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEquipped {
    fn default() -> &'a CSOEconItemEquipped {
        <CSOEconItemEquipped as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEquipped {
    pub fn new() -> CSOEconItemEquipped {
        ::std::default::Default::default()
    }

    // optional uint32 new_class = 1;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 2;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_class",
            |m: &CSOEconItemEquipped| { &m.new_class },
            |m: &mut CSOEconItemEquipped| { &mut m.new_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_slot",
            |m: &CSOEconItemEquipped| { &m.new_slot },
            |m: &mut CSOEconItemEquipped| { &mut m.new_slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemEquipped>(
            "CSOEconItemEquipped",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemEquipped {
    const NAME: &'static str = "CSOEconItemEquipped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_class {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemEquipped {
        CSOEconItemEquipped::new()
    }

    fn clear(&mut self) {
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemEquipped {
        static instance: CSOEconItemEquipped = CSOEconItemEquipped {
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemEquipped {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemEquipped").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemEquipped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemEquipped {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSOEconItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CSOEconItem.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.attribute)
    pub attribute: ::std::vec::Vec<CSOEconItemAttribute>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.interior_item)
    pub interior_item: ::protobuf::MessageField<CSOEconItem>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.style)
    pub style: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.original_id)
    pub original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSOEconItem.equipped_state)
    pub equipped_state: ::std::vec::Vec<CSOEconItemEquipped>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSOEconItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItem {
    fn default() -> &'a CSOEconItem {
        <CSOEconItem as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItem {
    pub fn new() -> CSOEconItem {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 3;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 4;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 5;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 6;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 7;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 8;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 9;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 style = 15;

    pub fn style(&self) -> u32 {
        self.style.unwrap_or(0)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: u32) {
        self.style = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 16;

    pub fn original_id(&self) -> u64 {
        self.original_id.unwrap_or(0)
    }

    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CSOEconItem| { &m.id },
            |m: &mut CSOEconItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItem| { &m.account_id },
            |m: &mut CSOEconItem| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CSOEconItem| { &m.inventory },
            |m: &mut CSOEconItem| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItem| { &m.def_index },
            |m: &mut CSOEconItem| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CSOEconItem| { &m.quantity },
            |m: &mut CSOEconItem| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &CSOEconItem| { &m.level },
            |m: &mut CSOEconItem| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CSOEconItem| { &m.quality },
            |m: &mut CSOEconItem| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSOEconItem| { &m.flags },
            |m: &mut CSOEconItem| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CSOEconItem| { &m.origin },
            |m: &mut CSOEconItem| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attribute",
            |m: &CSOEconItem| { &m.attribute },
            |m: &mut CSOEconItem| { &mut m.attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CSOEconItem>(
            "interior_item",
            |m: &CSOEconItem| { &m.interior_item },
            |m: &mut CSOEconItem| { &mut m.interior_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style",
            |m: &CSOEconItem| { &m.style },
            |m: &mut CSOEconItem| { &mut m.style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_id",
            |m: &CSOEconItem| { &m.original_id },
            |m: &mut CSOEconItem| { &mut m.original_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "equipped_state",
            |m: &CSOEconItem| { &m.equipped_state },
            |m: &mut CSOEconItem| { &mut m.equipped_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItem>(
            "CSOEconItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItem {
    const NAME: &'static str = "CSOEconItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.attribute.push(is.read_message()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.interior_item)?;
                },
                120 => {
                    self.style = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                146 => {
                    self.equipped_state.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.interior_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.original_id {
            my_size += ::protobuf::rt::uint64_size(16, v);
        }
        for value in &self.equipped_state {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(9, v)?;
        }
        for v in &self.attribute {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.interior_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.style {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(16, v)?;
        }
        for v in &self.equipped_state {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItem {
        CSOEconItem::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.attribute.clear();
        self.interior_item.clear();
        self.style = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.equipped_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItem {
        static instance: CSOEconItem = CSOEconItem {
            id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            level: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            interior_item: ::protobuf::MessageField::none(),
            style: ::std::option::Option::None,
            original_id: ::std::option::Option::None,
            equipped_state: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSortItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSortItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSortItems.sort_type)
    pub sort_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSortItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSortItems {
    fn default() -> &'a CMsgSortItems {
        <CMsgSortItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSortItems {
    pub fn new() -> CMsgSortItems {
        ::std::default::Default::default()
    }

    // optional uint32 sort_type = 1;

    pub fn sort_type(&self) -> u32 {
        self.sort_type.unwrap_or(0)
    }

    pub fn clear_sort_type(&mut self) {
        self.sort_type = ::std::option::Option::None;
    }

    pub fn has_sort_type(&self) -> bool {
        self.sort_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: u32) {
        self.sort_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sort_type",
            |m: &CMsgSortItems| { &m.sort_type },
            |m: &mut CMsgSortItems| { &mut m.sort_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSortItems>(
            "CMsgSortItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSortItems {
    const NAME: &'static str = "CMsgSortItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sort_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sort_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sort_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSortItems {
        CMsgSortItems::new()
    }

    fn clear(&mut self) {
        self.sort_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSortItems {
        static instance: CMsgSortItems = CMsgSortItems {
            sort_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSortItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSortItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSortItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSortItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgConVarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConVarValue {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgConVarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgConVarValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgConVarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConVarValue {
    fn default() -> &'a CMsgConVarValue {
        <CMsgConVarValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConVarValue {
    pub fn new() -> CMsgConVarValue {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgConVarValue| { &m.name },
            |m: &mut CMsgConVarValue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgConVarValue| { &m.value },
            |m: &mut CMsgConVarValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConVarValue>(
            "CMsgConVarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConVarValue {
    const NAME: &'static str = "CMsgConVarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConVarValue {
        CMsgConVarValue::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConVarValue {
        static instance: CMsgConVarValue = CMsgConVarValue {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConVarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConVarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConVarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConVarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgReplicateConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReplicateConVars {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgReplicateConVars.convars)
    pub convars: ::std::vec::Vec<CMsgConVarValue>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgReplicateConVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplicateConVars {
    fn default() -> &'a CMsgReplicateConVars {
        <CMsgReplicateConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplicateConVars {
    pub fn new() -> CMsgReplicateConVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "convars",
            |m: &CMsgReplicateConVars| { &m.convars },
            |m: &mut CMsgReplicateConVars| { &mut m.convars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReplicateConVars>(
            "CMsgReplicateConVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReplicateConVars {
    const NAME: &'static str = "CMsgReplicateConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.convars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.convars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.convars {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplicateConVars {
        CMsgReplicateConVars::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplicateConVars {
        static instance: CMsgReplicateConVars = CMsgReplicateConVars {
            convars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReplicateConVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReplicateConVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReplicateConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplicateConVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgItemAcknowledged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemAcknowledged {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgItemAcknowledged.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemAcknowledged.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemAcknowledged.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemAcknowledged.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemAcknowledged.rarity)
    pub rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgItemAcknowledged.origin)
    pub origin: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgItemAcknowledged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged {
    fn default() -> &'a CMsgItemAcknowledged {
        <CMsgItemAcknowledged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 2;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 3;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 4;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgItemAcknowledged| { &m.account_id },
            |m: &mut CMsgItemAcknowledged| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CMsgItemAcknowledged| { &m.inventory },
            |m: &mut CMsgItemAcknowledged| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CMsgItemAcknowledged| { &m.def_index },
            |m: &mut CMsgItemAcknowledged| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CMsgItemAcknowledged| { &m.quality },
            |m: &mut CMsgItemAcknowledged| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rarity",
            |m: &CMsgItemAcknowledged| { &m.rarity },
            |m: &mut CMsgItemAcknowledged| { &mut m.rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CMsgItemAcknowledged| { &m.origin },
            |m: &mut CMsgItemAcknowledged| { &mut m.origin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemAcknowledged>(
            "CMsgItemAcknowledged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged {
    const NAME: &'static str = "CMsgItemAcknowledged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAcknowledged {
        static instance: CMsgItemAcknowledged = CMsgItemAcknowledged {
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemAcknowledged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemAcknowledged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemAcknowledged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSetItemPositions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetItemPositions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSetItemPositions.item_positions)
    pub item_positions: ::std::vec::Vec<cmsg_set_item_positions::ItemPosition>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSetItemPositions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions {
    fn default() -> &'a CMsgSetItemPositions {
        <CMsgSetItemPositions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions {
    pub fn new() -> CMsgSetItemPositions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_positions",
            |m: &CMsgSetItemPositions| { &m.item_positions },
            |m: &mut CMsgSetItemPositions| { &mut m.item_positions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetItemPositions>(
            "CMsgSetItemPositions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetItemPositions {
    const NAME: &'static str = "CMsgSetItemPositions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item_positions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_positions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemPositions {
        CMsgSetItemPositions::new()
    }

    fn clear(&mut self) {
        self.item_positions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemPositions {
        static instance: CMsgSetItemPositions = CMsgSetItemPositions {
            item_positions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetItemPositions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetItemPositions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetItemPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemPositions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSetItemPositions`
pub mod cmsg_set_item_positions {
    // @@protoc_insertion_point(message:dota.CMsgSetItemPositions.ItemPosition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemPosition {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSetItemPositions.ItemPosition.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgSetItemPositions.ItemPosition.position)
        pub position: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSetItemPositions.ItemPosition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemPosition {
        fn default() -> &'a ItemPosition {
            <ItemPosition as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemPosition {
        pub fn new() -> ItemPosition {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 position = 2;

        pub fn position(&self) -> u32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: u32) {
            self.position = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &ItemPosition| { &m.item_id },
                |m: &mut ItemPosition| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position",
                |m: &ItemPosition| { &m.position },
                |m: &mut ItemPosition| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemPosition>(
                "CMsgSetItemPositions.ItemPosition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemPosition {
        const NAME: &'static str = "ItemPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.position {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.position {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemPosition {
            ItemPosition::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemPosition {
            static instance: ItemPosition = ItemPosition {
                item_id: ::std::option::Option::None,
                position: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemPosition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSetItemPositions.ItemPosition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemPosition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemPosition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCStorePurchaseCancel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseCancel {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseCancel.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCStorePurchaseCancel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancel {
    fn default() -> &'a CMsgGCStorePurchaseCancel {
        <CMsgGCStorePurchaseCancel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancel {
    pub fn new() -> CMsgGCStorePurchaseCancel {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseCancel| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseCancel| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseCancel>(
            "CMsgGCStorePurchaseCancel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancel {
    const NAME: &'static str = "CMsgGCStorePurchaseCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancel {
        CMsgGCStorePurchaseCancel::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancel {
        static instance: CMsgGCStorePurchaseCancel = CMsgGCStorePurchaseCancel {
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseCancel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseCancel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCStorePurchaseCancelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseCancelResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseCancelResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCStorePurchaseCancelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancelResponse {
    fn default() -> &'a CMsgGCStorePurchaseCancelResponse {
        <CMsgGCStorePurchaseCancelResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancelResponse {
    pub fn new() -> CMsgGCStorePurchaseCancelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseCancelResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseCancelResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseCancelResponse>(
            "CMsgGCStorePurchaseCancelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancelResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseCancelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancelResponse {
        CMsgGCStorePurchaseCancelResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancelResponse {
        static instance: CMsgGCStorePurchaseCancelResponse = CMsgGCStorePurchaseCancelResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseCancelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseCancelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseCancelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCStorePurchaseFinalize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseFinalize {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseFinalize.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCStorePurchaseFinalize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalize {
    fn default() -> &'a CMsgGCStorePurchaseFinalize {
        <CMsgGCStorePurchaseFinalize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalize {
    pub fn new() -> CMsgGCStorePurchaseFinalize {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseFinalize| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseFinalize| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseFinalize>(
            "CMsgGCStorePurchaseFinalize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalize {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalize {
        CMsgGCStorePurchaseFinalize::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalize {
        static instance: CMsgGCStorePurchaseFinalize = CMsgGCStorePurchaseFinalize {
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseFinalize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseFinalize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseFinalize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCStorePurchaseFinalizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseFinalizeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseFinalizeResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCStorePurchaseFinalizeResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCStorePurchaseFinalizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalizeResponse {
    fn default() -> &'a CMsgGCStorePurchaseFinalizeResponse {
        <CMsgGCStorePurchaseFinalizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalizeResponse {
    pub fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.item_ids },
            |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseFinalizeResponse>(
            "CMsgGCStorePurchaseFinalizeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalizeResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        CMsgGCStorePurchaseFinalizeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalizeResponse {
        static instance: CMsgGCStorePurchaseFinalizeResponse = CMsgGCStorePurchaseFinalizeResponse {
            result: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseFinalizeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseFinalizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseFinalizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalizeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCBannedWordListUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBannedWordListUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCBannedWordListUpdated.group_id)
    pub group_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCBannedWordListUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBannedWordListUpdated {
    fn default() -> &'a CMsgGCToGCBannedWordListUpdated {
        <CMsgGCToGCBannedWordListUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBannedWordListUpdated {
    pub fn new() -> CMsgGCToGCBannedWordListUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 group_id = 1;

    pub fn group_id(&self) -> u32 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CMsgGCToGCBannedWordListUpdated| { &m.group_id },
            |m: &mut CMsgGCToGCBannedWordListUpdated| { &mut m.group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCBannedWordListUpdated>(
            "CMsgGCToGCBannedWordListUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCBannedWordListUpdated {
    const NAME: &'static str = "CMsgGCToGCBannedWordListUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBannedWordListUpdated {
        CMsgGCToGCBannedWordListUpdated::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBannedWordListUpdated {
        static instance: CMsgGCToGCBannedWordListUpdated = CMsgGCToGCBannedWordListUpdated {
            group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCBannedWordListUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCBannedWordListUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCBannedWordListUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBannedWordListUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCDirtySDOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCDirtySDOCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCDirtySDOCache.sdo_type)
    pub sdo_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCDirtySDOCache.key_uint64)
    pub key_uint64: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCDirtySDOCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCDirtySDOCache {
    fn default() -> &'a CMsgGCToGCDirtySDOCache {
        <CMsgGCToGCDirtySDOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCDirtySDOCache {
    pub fn new() -> CMsgGCToGCDirtySDOCache {
        ::std::default::Default::default()
    }

    // optional uint32 sdo_type = 1;

    pub fn sdo_type(&self) -> u32 {
        self.sdo_type.unwrap_or(0)
    }

    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: u32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }

    // optional uint64 key_uint64 = 2;

    pub fn key_uint64(&self) -> u64 {
        self.key_uint64.unwrap_or(0)
    }

    pub fn clear_key_uint64(&mut self) {
        self.key_uint64 = ::std::option::Option::None;
    }

    pub fn has_key_uint64(&self) -> bool {
        self.key_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_uint64(&mut self, v: u64) {
        self.key_uint64 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdo_type",
            |m: &CMsgGCToGCDirtySDOCache| { &m.sdo_type },
            |m: &mut CMsgGCToGCDirtySDOCache| { &mut m.sdo_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_uint64",
            |m: &CMsgGCToGCDirtySDOCache| { &m.key_uint64 },
            |m: &mut CMsgGCToGCDirtySDOCache| { &mut m.key_uint64 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCDirtySDOCache>(
            "CMsgGCToGCDirtySDOCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCDirtySDOCache {
    const NAME: &'static str = "CMsgGCToGCDirtySDOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sdo_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.key_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.key_uint64 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sdo_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key_uint64 {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCDirtySDOCache {
        CMsgGCToGCDirtySDOCache::new()
    }

    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.key_uint64 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCDirtySDOCache {
        static instance: CMsgGCToGCDirtySDOCache = CMsgGCToGCDirtySDOCache {
            sdo_type: ::std::option::Option::None,
            key_uint64: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCDirtySDOCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCDirtySDOCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCDirtySDOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCDirtySDOCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSDONoMemcached)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSDONoMemcached {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSDONoMemcached.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSDONoMemcached {
    fn default() -> &'a CMsgSDONoMemcached {
        <CMsgSDONoMemcached as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSDONoMemcached {
    pub fn new() -> CMsgSDONoMemcached {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSDONoMemcached>(
            "CMsgSDONoMemcached",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSDONoMemcached {
    const NAME: &'static str = "CMsgSDONoMemcached";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSDONoMemcached {
        CMsgSDONoMemcached::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSDONoMemcached {
        static instance: CMsgSDONoMemcached = CMsgSDONoMemcached {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSDONoMemcached {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSDONoMemcached").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSDONoMemcached {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSDONoMemcached {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCUpdateSQLKeyValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateSQLKeyValue {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateSQLKeyValue.key_name)
    pub key_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCUpdateSQLKeyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSQLKeyValue {
    fn default() -> &'a CMsgGCToGCUpdateSQLKeyValue {
        <CMsgGCToGCUpdateSQLKeyValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSQLKeyValue {
    pub fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        ::std::default::Default::default()
    }

    // optional string key_name = 1;

    pub fn key_name(&self) -> &str {
        match self.key_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key_name(&mut self) {
        self.key_name = ::std::option::Option::None;
    }

    pub fn has_key_name(&self) -> bool {
        self.key_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_name(&mut self, v: ::std::string::String) {
        self.key_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_name(&mut self) -> &mut ::std::string::String {
        if self.key_name.is_none() {
            self.key_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_name(&mut self) -> ::std::string::String {
        self.key_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_name",
            |m: &CMsgGCToGCUpdateSQLKeyValue| { &m.key_name },
            |m: &mut CMsgGCToGCUpdateSQLKeyValue| { &mut m.key_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCUpdateSQLKeyValue>(
            "CMsgGCToGCUpdateSQLKeyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCUpdateSQLKeyValue {
    const NAME: &'static str = "CMsgGCToGCUpdateSQLKeyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        CMsgGCToGCUpdateSQLKeyValue::new()
    }

    fn clear(&mut self) {
        self.key_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSQLKeyValue {
        static instance: CMsgGCToGCUpdateSQLKeyValue = CMsgGCToGCUpdateSQLKeyValue {
            key_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCUpdateSQLKeyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCUpdateSQLKeyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCUpdateSQLKeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUpdateSQLKeyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCServerVersionUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCServerVersionUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCServerVersionUpdated.server_version)
    pub server_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCServerVersionUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCServerVersionUpdated {
    fn default() -> &'a CMsgGCServerVersionUpdated {
        <CMsgGCServerVersionUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCServerVersionUpdated {
    pub fn new() -> CMsgGCServerVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 1;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGCServerVersionUpdated| { &m.server_version },
            |m: &mut CMsgGCServerVersionUpdated| { &mut m.server_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCServerVersionUpdated>(
            "CMsgGCServerVersionUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCServerVersionUpdated {
    const NAME: &'static str = "CMsgGCServerVersionUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCServerVersionUpdated {
        CMsgGCServerVersionUpdated::new()
    }

    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCServerVersionUpdated {
        static instance: CMsgGCServerVersionUpdated = CMsgGCServerVersionUpdated {
            server_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCServerVersionUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCServerVersionUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCServerVersionUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCServerVersionUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCClientVersionUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientVersionUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCClientVersionUpdated.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCClientVersionUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientVersionUpdated {
    fn default() -> &'a CMsgGCClientVersionUpdated {
        <CMsgGCClientVersionUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientVersionUpdated {
    pub fn new() -> CMsgGCClientVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgGCClientVersionUpdated| { &m.client_version },
            |m: &mut CMsgGCClientVersionUpdated| { &mut m.client_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientVersionUpdated>(
            "CMsgGCClientVersionUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientVersionUpdated {
    const NAME: &'static str = "CMsgGCClientVersionUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientVersionUpdated {
        CMsgGCClientVersionUpdated::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientVersionUpdated {
        static instance: CMsgGCClientVersionUpdated = CMsgGCClientVersionUpdated {
            client_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientVersionUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientVersionUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientVersionUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientVersionUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCWebAPIAccountChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCWebAPIAccountChanged {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCWebAPIAccountChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCWebAPIAccountChanged {
    fn default() -> &'a CMsgGCToGCWebAPIAccountChanged {
        <CMsgGCToGCWebAPIAccountChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCWebAPIAccountChanged {
    pub fn new() -> CMsgGCToGCWebAPIAccountChanged {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCWebAPIAccountChanged>(
            "CMsgGCToGCWebAPIAccountChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCWebAPIAccountChanged {
    const NAME: &'static str = "CMsgGCToGCWebAPIAccountChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCWebAPIAccountChanged {
        CMsgGCToGCWebAPIAccountChanged::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCWebAPIAccountChanged {
        static instance: CMsgGCToGCWebAPIAccountChanged = CMsgGCToGCWebAPIAccountChanged {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCWebAPIAccountChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCWebAPIAccountChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCWebAPIAccountChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCWebAPIAccountChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgExtractGems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExtractGems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgExtractGems.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgExtractGems.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgExtractGems.item_socket_id)
    pub item_socket_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgExtractGems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExtractGems {
    fn default() -> &'a CMsgExtractGems {
        <CMsgExtractGems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExtractGems {
    pub fn new() -> CMsgExtractGems {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_socket_id = 3;

    pub fn item_socket_id(&self) -> u32 {
        self.item_socket_id.unwrap_or(0)
    }

    pub fn clear_item_socket_id(&mut self) {
        self.item_socket_id = ::std::option::Option::None;
    }

    pub fn has_item_socket_id(&self) -> bool {
        self.item_socket_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_socket_id(&mut self, v: u32) {
        self.item_socket_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgExtractGems| { &m.tool_item_id },
            |m: &mut CMsgExtractGems| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgExtractGems| { &m.item_item_id },
            |m: &mut CMsgExtractGems| { &mut m.item_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_socket_id",
            |m: &CMsgExtractGems| { &m.item_socket_id },
            |m: &mut CMsgExtractGems| { &mut m.item_socket_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgExtractGems>(
            "CMsgExtractGems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgExtractGems {
    const NAME: &'static str = "CMsgExtractGems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_socket_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_socket_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_socket_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExtractGems {
        CMsgExtractGems::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.item_socket_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExtractGems {
        static instance: CMsgExtractGems = CMsgExtractGems {
            tool_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            item_socket_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgExtractGems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgExtractGems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgExtractGems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExtractGems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgExtractGemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExtractGemsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgExtractGemsResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgExtractGemsResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_extract_gems_response::EExtractGems>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgExtractGemsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExtractGemsResponse {
    fn default() -> &'a CMsgExtractGemsResponse {
        <CMsgExtractGemsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExtractGemsResponse {
    pub fn new() -> CMsgExtractGemsResponse {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgExtractGemsResponse.EExtractGems response = 2;

    pub fn response(&self) -> cmsg_extract_gems_response::EExtractGems {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_extract_gems_response::EExtractGems::k_ExtractGems_Succeeded),
            None => cmsg_extract_gems_response::EExtractGems::k_ExtractGems_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_extract_gems_response::EExtractGems) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgExtractGemsResponse| { &m.item_id },
            |m: &mut CMsgExtractGemsResponse| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgExtractGemsResponse| { &m.response },
            |m: &mut CMsgExtractGemsResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgExtractGemsResponse>(
            "CMsgExtractGemsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgExtractGemsResponse {
    const NAME: &'static str = "CMsgExtractGemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExtractGemsResponse {
        CMsgExtractGemsResponse::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExtractGemsResponse {
        static instance: CMsgExtractGemsResponse = CMsgExtractGemsResponse {
            item_id: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgExtractGemsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgExtractGemsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgExtractGemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExtractGemsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgExtractGemsResponse`
pub mod cmsg_extract_gems_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgExtractGemsResponse.EExtractGems)
    pub enum EExtractGems {
        // @@protoc_insertion_point(enum_value:dota.CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Succeeded)
        k_ExtractGems_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_ToolIsInvalid)
        k_ExtractGems_Failed_ToolIsInvalid = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_ItemIsInvalid)
        k_ExtractGems_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_ToolCannotRemoveGem)
        k_ExtractGems_Failed_ToolCannotRemoveGem = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_FailedToRemoveGem)
        k_ExtractGems_Failed_FailedToRemoveGem = 4,
    }

    impl ::protobuf::Enum for EExtractGems {
        const NAME: &'static str = "EExtractGems";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EExtractGems> {
            match value {
                0 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Succeeded),
                1 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolIsInvalid),
                2 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolCannotRemoveGem),
                4 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_FailedToRemoveGem),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EExtractGems> {
            match str {
                "k_ExtractGems_Succeeded" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Succeeded),
                "k_ExtractGems_Failed_ToolIsInvalid" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolIsInvalid),
                "k_ExtractGems_Failed_ItemIsInvalid" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ItemIsInvalid),
                "k_ExtractGems_Failed_ToolCannotRemoveGem" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolCannotRemoveGem),
                "k_ExtractGems_Failed_FailedToRemoveGem" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_FailedToRemoveGem),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EExtractGems] = &[
            EExtractGems::k_ExtractGems_Succeeded,
            EExtractGems::k_ExtractGems_Failed_ToolIsInvalid,
            EExtractGems::k_ExtractGems_Failed_ItemIsInvalid,
            EExtractGems::k_ExtractGems_Failed_ToolCannotRemoveGem,
            EExtractGems::k_ExtractGems_Failed_FailedToRemoveGem,
        ];
    }

    impl ::protobuf::EnumFull for EExtractGems {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgExtractGemsResponse.EExtractGems").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EExtractGems {
        fn default() -> Self {
            EExtractGems::k_ExtractGems_Succeeded
        }
    }

    impl EExtractGems {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EExtractGems>("CMsgExtractGemsResponse.EExtractGems")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgAddSocket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddSocket {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAddSocket.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgAddSocket.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgAddSocket.unusual)
    pub unusual: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAddSocket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddSocket {
    fn default() -> &'a CMsgAddSocket {
        <CMsgAddSocket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddSocket {
    pub fn new() -> CMsgAddSocket {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional bool unusual = 3;

    pub fn unusual(&self) -> bool {
        self.unusual.unwrap_or(false)
    }

    pub fn clear_unusual(&mut self) {
        self.unusual = ::std::option::Option::None;
    }

    pub fn has_unusual(&self) -> bool {
        self.unusual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unusual(&mut self, v: bool) {
        self.unusual = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgAddSocket| { &m.tool_item_id },
            |m: &mut CMsgAddSocket| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgAddSocket| { &m.item_item_id },
            |m: &mut CMsgAddSocket| { &mut m.item_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unusual",
            |m: &CMsgAddSocket| { &m.unusual },
            |m: &mut CMsgAddSocket| { &mut m.unusual },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAddSocket>(
            "CMsgAddSocket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAddSocket {
    const NAME: &'static str = "CMsgAddSocket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.unusual = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.unusual {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.unusual {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddSocket {
        CMsgAddSocket::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.unusual = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddSocket {
        static instance: CMsgAddSocket = CMsgAddSocket {
            tool_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            unusual: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAddSocket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAddSocket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAddSocket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAddSocket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAddSocketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddSocketResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAddSocketResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgAddSocketResponse.updated_socket_index)
    pub updated_socket_index: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAddSocketResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_add_socket_response::EAddSocket>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAddSocketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddSocketResponse {
    fn default() -> &'a CMsgAddSocketResponse {
        <CMsgAddSocketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddSocketResponse {
    pub fn new() -> CMsgAddSocketResponse {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgAddSocketResponse.EAddSocket response = 3;

    pub fn response(&self) -> cmsg_add_socket_response::EAddSocket {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_add_socket_response::EAddSocket::k_AddSocket_Succeeded),
            None => cmsg_add_socket_response::EAddSocket::k_AddSocket_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_add_socket_response::EAddSocket) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgAddSocketResponse| { &m.item_id },
            |m: &mut CMsgAddSocketResponse| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "updated_socket_index",
            |m: &CMsgAddSocketResponse| { &m.updated_socket_index },
            |m: &mut CMsgAddSocketResponse| { &mut m.updated_socket_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgAddSocketResponse| { &m.response },
            |m: &mut CMsgAddSocketResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAddSocketResponse>(
            "CMsgAddSocketResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAddSocketResponse {
    const NAME: &'static str = "CMsgAddSocketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.updated_socket_index)?;
                },
                16 => {
                    self.updated_socket_index.push(is.read_uint32()?);
                },
                24 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.updated_socket_index {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.updated_socket_index {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.response {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddSocketResponse {
        CMsgAddSocketResponse::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.updated_socket_index.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddSocketResponse {
        static instance: CMsgAddSocketResponse = CMsgAddSocketResponse {
            item_id: ::std::option::Option::None,
            updated_socket_index: ::std::vec::Vec::new(),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAddSocketResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAddSocketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAddSocketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAddSocketResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgAddSocketResponse`
pub mod cmsg_add_socket_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgAddSocketResponse.EAddSocket)
    pub enum EAddSocket {
        // @@protoc_insertion_point(enum_value:dota.CMsgAddSocketResponse.EAddSocket.k_AddSocket_Succeeded)
        k_AddSocket_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddSocketResponse.EAddSocket.k_AddSocket_Failed_ToolIsInvalid)
        k_AddSocket_Failed_ToolIsInvalid = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddSocketResponse.EAddSocket.k_AddSocket_Failed_ItemCannotBeSocketed)
        k_AddSocket_Failed_ItemCannotBeSocketed = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddSocketResponse.EAddSocket.k_AddSocket_Failed_FailedToAddSocket)
        k_AddSocket_Failed_FailedToAddSocket = 3,
    }

    impl ::protobuf::Enum for EAddSocket {
        const NAME: &'static str = "EAddSocket";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EAddSocket> {
            match value {
                0 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Succeeded),
                1 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ToolIsInvalid),
                2 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ItemCannotBeSocketed),
                3 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_FailedToAddSocket),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EAddSocket> {
            match str {
                "k_AddSocket_Succeeded" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Succeeded),
                "k_AddSocket_Failed_ToolIsInvalid" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ToolIsInvalid),
                "k_AddSocket_Failed_ItemCannotBeSocketed" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ItemCannotBeSocketed),
                "k_AddSocket_Failed_FailedToAddSocket" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_FailedToAddSocket),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EAddSocket] = &[
            EAddSocket::k_AddSocket_Succeeded,
            EAddSocket::k_AddSocket_Failed_ToolIsInvalid,
            EAddSocket::k_AddSocket_Failed_ItemCannotBeSocketed,
            EAddSocket::k_AddSocket_Failed_FailedToAddSocket,
        ];
    }

    impl ::protobuf::EnumFull for EAddSocket {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgAddSocketResponse.EAddSocket").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EAddSocket {
        fn default() -> Self {
            EAddSocket::k_AddSocket_Succeeded
        }
    }

    impl EAddSocket {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EAddSocket>("CMsgAddSocketResponse.EAddSocket")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgAddItemToSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddItemToSocketData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAddItemToSocketData.gem_item_id)
    pub gem_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgAddItemToSocketData.socket_index)
    pub socket_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAddItemToSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddItemToSocketData {
    fn default() -> &'a CMsgAddItemToSocketData {
        <CMsgAddItemToSocketData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddItemToSocketData {
    pub fn new() -> CMsgAddItemToSocketData {
        ::std::default::Default::default()
    }

    // optional uint64 gem_item_id = 1;

    pub fn gem_item_id(&self) -> u64 {
        self.gem_item_id.unwrap_or(0)
    }

    pub fn clear_gem_item_id(&mut self) {
        self.gem_item_id = ::std::option::Option::None;
    }

    pub fn has_gem_item_id(&self) -> bool {
        self.gem_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gem_item_id(&mut self, v: u64) {
        self.gem_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 socket_index = 2;

    pub fn socket_index(&self) -> u32 {
        self.socket_index.unwrap_or(0)
    }

    pub fn clear_socket_index(&mut self) {
        self.socket_index = ::std::option::Option::None;
    }

    pub fn has_socket_index(&self) -> bool {
        self.socket_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket_index(&mut self, v: u32) {
        self.socket_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gem_item_id",
            |m: &CMsgAddItemToSocketData| { &m.gem_item_id },
            |m: &mut CMsgAddItemToSocketData| { &mut m.gem_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "socket_index",
            |m: &CMsgAddItemToSocketData| { &m.socket_index },
            |m: &mut CMsgAddItemToSocketData| { &mut m.socket_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAddItemToSocketData>(
            "CMsgAddItemToSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAddItemToSocketData {
    const NAME: &'static str = "CMsgAddItemToSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gem_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.socket_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gem_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.socket_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gem_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.socket_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddItemToSocketData {
        CMsgAddItemToSocketData::new()
    }

    fn clear(&mut self) {
        self.gem_item_id = ::std::option::Option::None;
        self.socket_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddItemToSocketData {
        static instance: CMsgAddItemToSocketData = CMsgAddItemToSocketData {
            gem_item_id: ::std::option::Option::None,
            socket_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAddItemToSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAddItemToSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAddItemToSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAddItemToSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAddItemToSocket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddItemToSocket {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAddItemToSocket.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgAddItemToSocket.gems_to_socket)
    pub gems_to_socket: ::std::vec::Vec<CMsgAddItemToSocketData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAddItemToSocket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddItemToSocket {
    fn default() -> &'a CMsgAddItemToSocket {
        <CMsgAddItemToSocket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddItemToSocket {
    pub fn new() -> CMsgAddItemToSocket {
        ::std::default::Default::default()
    }

    // optional uint64 item_item_id = 1;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgAddItemToSocket| { &m.item_item_id },
            |m: &mut CMsgAddItemToSocket| { &mut m.item_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gems_to_socket",
            |m: &CMsgAddItemToSocket| { &m.gems_to_socket },
            |m: &mut CMsgAddItemToSocket| { &mut m.gems_to_socket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAddItemToSocket>(
            "CMsgAddItemToSocket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAddItemToSocket {
    const NAME: &'static str = "CMsgAddItemToSocket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.gems_to_socket.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.gems_to_socket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.gems_to_socket {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddItemToSocket {
        CMsgAddItemToSocket::new()
    }

    fn clear(&mut self) {
        self.item_item_id = ::std::option::Option::None;
        self.gems_to_socket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddItemToSocket {
        static instance: CMsgAddItemToSocket = CMsgAddItemToSocket {
            item_item_id: ::std::option::Option::None,
            gems_to_socket: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAddItemToSocket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAddItemToSocket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAddItemToSocket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAddItemToSocket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAddItemToSocketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddItemToSocketResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAddItemToSocketResponse.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgAddItemToSocketResponse.updated_socket_index)
    pub updated_socket_index: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAddItemToSocketResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_add_item_to_socket_response::EAddGem>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAddItemToSocketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddItemToSocketResponse {
    fn default() -> &'a CMsgAddItemToSocketResponse {
        <CMsgAddItemToSocketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddItemToSocketResponse {
    pub fn new() -> CMsgAddItemToSocketResponse {
        ::std::default::Default::default()
    }

    // optional uint64 item_item_id = 1;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgAddItemToSocketResponse.EAddGem response = 3;

    pub fn response(&self) -> cmsg_add_item_to_socket_response::EAddGem {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_add_item_to_socket_response::EAddGem::k_AddGem_Succeeded),
            None => cmsg_add_item_to_socket_response::EAddGem::k_AddGem_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_add_item_to_socket_response::EAddGem) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgAddItemToSocketResponse| { &m.item_item_id },
            |m: &mut CMsgAddItemToSocketResponse| { &mut m.item_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "updated_socket_index",
            |m: &CMsgAddItemToSocketResponse| { &m.updated_socket_index },
            |m: &mut CMsgAddItemToSocketResponse| { &mut m.updated_socket_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgAddItemToSocketResponse| { &m.response },
            |m: &mut CMsgAddItemToSocketResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAddItemToSocketResponse>(
            "CMsgAddItemToSocketResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAddItemToSocketResponse {
    const NAME: &'static str = "CMsgAddItemToSocketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.updated_socket_index)?;
                },
                16 => {
                    self.updated_socket_index.push(is.read_uint32()?);
                },
                24 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.updated_socket_index {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.updated_socket_index {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.response {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddItemToSocketResponse {
        CMsgAddItemToSocketResponse::new()
    }

    fn clear(&mut self) {
        self.item_item_id = ::std::option::Option::None;
        self.updated_socket_index.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddItemToSocketResponse {
        static instance: CMsgAddItemToSocketResponse = CMsgAddItemToSocketResponse {
            item_item_id: ::std::option::Option::None,
            updated_socket_index: ::std::vec::Vec::new(),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAddItemToSocketResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAddItemToSocketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAddItemToSocketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAddItemToSocketResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgAddItemToSocketResponse`
pub mod cmsg_add_item_to_socket_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgAddItemToSocketResponse.EAddGem)
    pub enum EAddGem {
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Succeeded)
        k_AddGem_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_GemIsInvalid)
        k_AddGem_Failed_GemIsInvalid = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_ItemIsInvalid)
        k_AddGem_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_FailedToAddGem)
        k_AddGem_Failed_FailedToAddGem = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_InvalidGemTypeForSocket)
        k_AddGem_Failed_InvalidGemTypeForSocket = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_InvalidGemTypeForHero)
        k_AddGem_Failed_InvalidGemTypeForHero = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_InvalidGemTypeForSlot)
        k_AddGem_Failed_InvalidGemTypeForSlot = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_SocketContainsUnremovableGem)
        k_AddGem_Failed_SocketContainsUnremovableGem = 7,
    }

    impl ::protobuf::Enum for EAddGem {
        const NAME: &'static str = "EAddGem";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EAddGem> {
            match value {
                0 => ::std::option::Option::Some(EAddGem::k_AddGem_Succeeded),
                1 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_GemIsInvalid),
                2 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_FailedToAddGem),
                4 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSocket),
                5 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForHero),
                6 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSlot),
                7 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_SocketContainsUnremovableGem),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EAddGem> {
            match str {
                "k_AddGem_Succeeded" => ::std::option::Option::Some(EAddGem::k_AddGem_Succeeded),
                "k_AddGem_Failed_GemIsInvalid" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_GemIsInvalid),
                "k_AddGem_Failed_ItemIsInvalid" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_ItemIsInvalid),
                "k_AddGem_Failed_FailedToAddGem" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_FailedToAddGem),
                "k_AddGem_Failed_InvalidGemTypeForSocket" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSocket),
                "k_AddGem_Failed_InvalidGemTypeForHero" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForHero),
                "k_AddGem_Failed_InvalidGemTypeForSlot" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSlot),
                "k_AddGem_Failed_SocketContainsUnremovableGem" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_SocketContainsUnremovableGem),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EAddGem] = &[
            EAddGem::k_AddGem_Succeeded,
            EAddGem::k_AddGem_Failed_GemIsInvalid,
            EAddGem::k_AddGem_Failed_ItemIsInvalid,
            EAddGem::k_AddGem_Failed_FailedToAddGem,
            EAddGem::k_AddGem_Failed_InvalidGemTypeForSocket,
            EAddGem::k_AddGem_Failed_InvalidGemTypeForHero,
            EAddGem::k_AddGem_Failed_InvalidGemTypeForSlot,
            EAddGem::k_AddGem_Failed_SocketContainsUnremovableGem,
        ];
    }

    impl ::protobuf::EnumFull for EAddGem {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgAddItemToSocketResponse.EAddGem").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EAddGem {
        fn default() -> Self {
            EAddGem::k_AddGem_Succeeded
        }
    }

    impl EAddGem {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EAddGem>("CMsgAddItemToSocketResponse.EAddGem")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgResetStrangeGemCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResetStrangeGemCount {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgResetStrangeGemCount.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgResetStrangeGemCount.socket_index)
    pub socket_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgResetStrangeGemCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResetStrangeGemCount {
    fn default() -> &'a CMsgResetStrangeGemCount {
        <CMsgResetStrangeGemCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgResetStrangeGemCount {
    pub fn new() -> CMsgResetStrangeGemCount {
        ::std::default::Default::default()
    }

    // optional uint64 item_item_id = 1;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 socket_index = 2;

    pub fn socket_index(&self) -> u32 {
        self.socket_index.unwrap_or(0)
    }

    pub fn clear_socket_index(&mut self) {
        self.socket_index = ::std::option::Option::None;
    }

    pub fn has_socket_index(&self) -> bool {
        self.socket_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket_index(&mut self, v: u32) {
        self.socket_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgResetStrangeGemCount| { &m.item_item_id },
            |m: &mut CMsgResetStrangeGemCount| { &mut m.item_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "socket_index",
            |m: &CMsgResetStrangeGemCount| { &m.socket_index },
            |m: &mut CMsgResetStrangeGemCount| { &mut m.socket_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgResetStrangeGemCount>(
            "CMsgResetStrangeGemCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgResetStrangeGemCount {
    const NAME: &'static str = "CMsgResetStrangeGemCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.socket_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.socket_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.socket_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResetStrangeGemCount {
        CMsgResetStrangeGemCount::new()
    }

    fn clear(&mut self) {
        self.item_item_id = ::std::option::Option::None;
        self.socket_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResetStrangeGemCount {
        static instance: CMsgResetStrangeGemCount = CMsgResetStrangeGemCount {
            item_item_id: ::std::option::Option::None,
            socket_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgResetStrangeGemCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgResetStrangeGemCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgResetStrangeGemCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResetStrangeGemCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgResetStrangeGemCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResetStrangeGemCountResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgResetStrangeGemCountResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_reset_strange_gem_count_response::EResetGem>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgResetStrangeGemCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResetStrangeGemCountResponse {
    fn default() -> &'a CMsgResetStrangeGemCountResponse {
        <CMsgResetStrangeGemCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgResetStrangeGemCountResponse {
    pub fn new() -> CMsgResetStrangeGemCountResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgResetStrangeGemCountResponse.EResetGem response = 1;

    pub fn response(&self) -> cmsg_reset_strange_gem_count_response::EResetGem {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_reset_strange_gem_count_response::EResetGem::k_ResetGem_Succeeded),
            None => cmsg_reset_strange_gem_count_response::EResetGem::k_ResetGem_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_reset_strange_gem_count_response::EResetGem) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgResetStrangeGemCountResponse| { &m.response },
            |m: &mut CMsgResetStrangeGemCountResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgResetStrangeGemCountResponse>(
            "CMsgResetStrangeGemCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgResetStrangeGemCountResponse {
    const NAME: &'static str = "CMsgResetStrangeGemCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResetStrangeGemCountResponse {
        CMsgResetStrangeGemCountResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResetStrangeGemCountResponse {
        static instance: CMsgResetStrangeGemCountResponse = CMsgResetStrangeGemCountResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgResetStrangeGemCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgResetStrangeGemCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgResetStrangeGemCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResetStrangeGemCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgResetStrangeGemCountResponse`
pub mod cmsg_reset_strange_gem_count_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgResetStrangeGemCountResponse.EResetGem)
    pub enum EResetGem {
        // @@protoc_insertion_point(enum_value:dota.CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Succeeded)
        k_ResetGem_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_FailedToResetGem)
        k_ResetGem_Failed_FailedToResetGem = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_ItemIsInvalid)
        k_ResetGem_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_InvalidSocketId)
        k_ResetGem_Failed_InvalidSocketId = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_SocketCannotBeReset)
        k_ResetGem_Failed_SocketCannotBeReset = 4,
    }

    impl ::protobuf::Enum for EResetGem {
        const NAME: &'static str = "EResetGem";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResetGem> {
            match value {
                0 => ::std::option::Option::Some(EResetGem::k_ResetGem_Succeeded),
                1 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_FailedToResetGem),
                2 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_InvalidSocketId),
                4 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_SocketCannotBeReset),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResetGem> {
            match str {
                "k_ResetGem_Succeeded" => ::std::option::Option::Some(EResetGem::k_ResetGem_Succeeded),
                "k_ResetGem_Failed_FailedToResetGem" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_FailedToResetGem),
                "k_ResetGem_Failed_ItemIsInvalid" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_ItemIsInvalid),
                "k_ResetGem_Failed_InvalidSocketId" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_InvalidSocketId),
                "k_ResetGem_Failed_SocketCannotBeReset" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_SocketCannotBeReset),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResetGem] = &[
            EResetGem::k_ResetGem_Succeeded,
            EResetGem::k_ResetGem_Failed_FailedToResetGem,
            EResetGem::k_ResetGem_Failed_ItemIsInvalid,
            EResetGem::k_ResetGem_Failed_InvalidSocketId,
            EResetGem::k_ResetGem_Failed_SocketCannotBeReset,
        ];
    }

    impl ::protobuf::EnumFull for EResetGem {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgResetStrangeGemCountResponse.EResetGem").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResetGem {
        fn default() -> Self {
            EResetGem::k_ResetGem_Succeeded
        }
    }

    impl EResetGem {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResetGem>("CMsgResetStrangeGemCountResponse.EResetGem")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientPollFileRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollFileRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollFileRequest.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollFileRequest.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollFileRequest.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientPollFileRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollFileRequest {
    fn default() -> &'a CMsgGCToClientPollFileRequest {
        <CMsgGCToClientPollFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollFileRequest {
    pub fn new() -> CMsgGCToClientPollFileRequest {
        ::std::default::Default::default()
    }

    // optional string file_name = 1;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 poll_id = 3;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgGCToClientPollFileRequest| { &m.file_name },
            |m: &mut CMsgGCToClientPollFileRequest| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgGCToClientPollFileRequest| { &m.client_version },
            |m: &mut CMsgGCToClientPollFileRequest| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "poll_id",
            |m: &CMsgGCToClientPollFileRequest| { &m.poll_id },
            |m: &mut CMsgGCToClientPollFileRequest| { &mut m.poll_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientPollFileRequest>(
            "CMsgGCToClientPollFileRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientPollFileRequest {
    const NAME: &'static str = "CMsgGCToClientPollFileRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.poll_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.poll_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollFileRequest {
        CMsgGCToClientPollFileRequest::new()
    }

    fn clear(&mut self) {
        self.file_name = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.poll_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollFileRequest {
        static instance: CMsgGCToClientPollFileRequest = CMsgGCToClientPollFileRequest {
            file_name: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            poll_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientPollFileRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientPollFileRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientPollFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientPollFileRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientPollFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollFileResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollFileResponse.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollFileResponse.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollFileResponse.file_crc)
    pub file_crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientPollFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollFileResponse {
    fn default() -> &'a CMsgGCToClientPollFileResponse {
        <CMsgGCToClientPollFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollFileResponse {
    pub fn new() -> CMsgGCToClientPollFileResponse {
        ::std::default::Default::default()
    }

    // optional uint32 poll_id = 1;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 2;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 file_crc = 3;

    pub fn file_crc(&self) -> u32 {
        self.file_crc.unwrap_or(0)
    }

    pub fn clear_file_crc(&mut self) {
        self.file_crc = ::std::option::Option::None;
    }

    pub fn has_file_crc(&self) -> bool {
        self.file_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_crc(&mut self, v: u32) {
        self.file_crc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "poll_id",
            |m: &CMsgGCToClientPollFileResponse| { &m.poll_id },
            |m: &mut CMsgGCToClientPollFileResponse| { &mut m.poll_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CMsgGCToClientPollFileResponse| { &m.file_size },
            |m: &mut CMsgGCToClientPollFileResponse| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_crc",
            |m: &CMsgGCToClientPollFileResponse| { &m.file_crc },
            |m: &mut CMsgGCToClientPollFileResponse| { &mut m.file_crc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientPollFileResponse>(
            "CMsgGCToClientPollFileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientPollFileResponse {
    const NAME: &'static str = "CMsgGCToClientPollFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.file_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.poll_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.file_crc {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.poll_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_crc {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollFileResponse {
        CMsgGCToClientPollFileResponse::new()
    }

    fn clear(&mut self) {
        self.poll_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.file_crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollFileResponse {
        static instance: CMsgGCToClientPollFileResponse = CMsgGCToClientPollFileResponse {
            poll_id: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            file_crc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientPollFileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientPollFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientPollFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientPollFileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCPerformManualOp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPerformManualOp {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCPerformManualOp.op_id)
    pub op_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCPerformManualOp.group_code)
    pub group_code: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCPerformManualOp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPerformManualOp {
    fn default() -> &'a CMsgGCToGCPerformManualOp {
        <CMsgGCToGCPerformManualOp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPerformManualOp {
    pub fn new() -> CMsgGCToGCPerformManualOp {
        ::std::default::Default::default()
    }

    // optional uint64 op_id = 1;

    pub fn op_id(&self) -> u64 {
        self.op_id.unwrap_or(0)
    }

    pub fn clear_op_id(&mut self) {
        self.op_id = ::std::option::Option::None;
    }

    pub fn has_op_id(&self) -> bool {
        self.op_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_id(&mut self, v: u64) {
        self.op_id = ::std::option::Option::Some(v);
    }

    // optional uint32 group_code = 2;

    pub fn group_code(&self) -> u32 {
        self.group_code.unwrap_or(0)
    }

    pub fn clear_group_code(&mut self) {
        self.group_code = ::std::option::Option::None;
    }

    pub fn has_group_code(&self) -> bool {
        self.group_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_code(&mut self, v: u32) {
        self.group_code = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "op_id",
            |m: &CMsgGCToGCPerformManualOp| { &m.op_id },
            |m: &mut CMsgGCToGCPerformManualOp| { &mut m.op_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_code",
            |m: &CMsgGCToGCPerformManualOp| { &m.group_code },
            |m: &mut CMsgGCToGCPerformManualOp| { &mut m.group_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCPerformManualOp>(
            "CMsgGCToGCPerformManualOp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCPerformManualOp {
    const NAME: &'static str = "CMsgGCToGCPerformManualOp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.op_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.group_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.op_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.group_code {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.op_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.group_code {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPerformManualOp {
        CMsgGCToGCPerformManualOp::new()
    }

    fn clear(&mut self) {
        self.op_id = ::std::option::Option::None;
        self.group_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPerformManualOp {
        static instance: CMsgGCToGCPerformManualOp = CMsgGCToGCPerformManualOp {
            op_id: ::std::option::Option::None,
            group_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCPerformManualOp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCPerformManualOp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCPerformManualOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPerformManualOp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCPerformManualOpCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPerformManualOpCompleted {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCPerformManualOpCompleted.success)
    pub success: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCPerformManualOpCompleted.source_gc)
    pub source_gc: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCPerformManualOpCompleted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPerformManualOpCompleted {
    fn default() -> &'a CMsgGCToGCPerformManualOpCompleted {
        <CMsgGCToGCPerformManualOpCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPerformManualOpCompleted {
    pub fn new() -> CMsgGCToGCPerformManualOpCompleted {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional int32 source_gc = 2;

    pub fn source_gc(&self) -> i32 {
        self.source_gc.unwrap_or(0)
    }

    pub fn clear_source_gc(&mut self) {
        self.source_gc = ::std::option::Option::None;
    }

    pub fn has_source_gc(&self) -> bool {
        self.source_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_gc(&mut self, v: i32) {
        self.source_gc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCToGCPerformManualOpCompleted| { &m.success },
            |m: &mut CMsgGCToGCPerformManualOpCompleted| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_gc",
            |m: &CMsgGCToGCPerformManualOpCompleted| { &m.source_gc },
            |m: &mut CMsgGCToGCPerformManualOpCompleted| { &mut m.source_gc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCPerformManualOpCompleted>(
            "CMsgGCToGCPerformManualOpCompleted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCPerformManualOpCompleted {
    const NAME: &'static str = "CMsgGCToGCPerformManualOpCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.source_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        if let Some(v) = self.source_gc {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.source_gc {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPerformManualOpCompleted {
        CMsgGCToGCPerformManualOpCompleted::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.source_gc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPerformManualOpCompleted {
        static instance: CMsgGCToGCPerformManualOpCompleted = CMsgGCToGCPerformManualOpCompleted {
            success: ::std::option::Option::None,
            source_gc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCPerformManualOpCompleted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCPerformManualOpCompleted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCPerformManualOpCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPerformManualOpCompleted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCReloadServerRegionSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCReloadServerRegionSettings {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCReloadServerRegionSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCReloadServerRegionSettings {
    fn default() -> &'a CMsgGCToGCReloadServerRegionSettings {
        <CMsgGCToGCReloadServerRegionSettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCReloadServerRegionSettings {
    pub fn new() -> CMsgGCToGCReloadServerRegionSettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCReloadServerRegionSettings>(
            "CMsgGCToGCReloadServerRegionSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCReloadServerRegionSettings {
    const NAME: &'static str = "CMsgGCToGCReloadServerRegionSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCReloadServerRegionSettings {
        CMsgGCToGCReloadServerRegionSettings::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCReloadServerRegionSettings {
        static instance: CMsgGCToGCReloadServerRegionSettings = CMsgGCToGCReloadServerRegionSettings {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCReloadServerRegionSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCReloadServerRegionSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCReloadServerRegionSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCReloadServerRegionSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCAdditionalWelcomeMsgList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCAdditionalWelcomeMsgList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCAdditionalWelcomeMsgList.welcome_messages)
    pub welcome_messages: ::std::vec::Vec<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCAdditionalWelcomeMsgList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCAdditionalWelcomeMsgList {
    fn default() -> &'a CMsgGCAdditionalWelcomeMsgList {
        <CMsgGCAdditionalWelcomeMsgList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCAdditionalWelcomeMsgList {
    pub fn new() -> CMsgGCAdditionalWelcomeMsgList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "welcome_messages",
            |m: &CMsgGCAdditionalWelcomeMsgList| { &m.welcome_messages },
            |m: &mut CMsgGCAdditionalWelcomeMsgList| { &mut m.welcome_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCAdditionalWelcomeMsgList>(
            "CMsgGCAdditionalWelcomeMsgList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCAdditionalWelcomeMsgList {
    const NAME: &'static str = "CMsgGCAdditionalWelcomeMsgList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.welcome_messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.welcome_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.welcome_messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCAdditionalWelcomeMsgList {
        CMsgGCAdditionalWelcomeMsgList::new()
    }

    fn clear(&mut self) {
        self.welcome_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCAdditionalWelcomeMsgList {
        static instance: CMsgGCAdditionalWelcomeMsgList = CMsgGCAdditionalWelcomeMsgList {
            welcome_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCAdditionalWelcomeMsgList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCAdditionalWelcomeMsgList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCAdditionalWelcomeMsgList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCAdditionalWelcomeMsgList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgApplyRemoteConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyRemoteConVars {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgApplyRemoteConVars.con_vars)
    pub con_vars: ::std::vec::Vec<cmsg_apply_remote_con_vars::ConVar>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgApplyRemoteConVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyRemoteConVars {
    fn default() -> &'a CMsgApplyRemoteConVars {
        <CMsgApplyRemoteConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyRemoteConVars {
    pub fn new() -> CMsgApplyRemoteConVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "con_vars",
            |m: &CMsgApplyRemoteConVars| { &m.con_vars },
            |m: &mut CMsgApplyRemoteConVars| { &mut m.con_vars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyRemoteConVars>(
            "CMsgApplyRemoteConVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyRemoteConVars {
    const NAME: &'static str = "CMsgApplyRemoteConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.con_vars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.con_vars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.con_vars {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyRemoteConVars {
        CMsgApplyRemoteConVars::new()
    }

    fn clear(&mut self) {
        self.con_vars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyRemoteConVars {
        static instance: CMsgApplyRemoteConVars = CMsgApplyRemoteConVars {
            con_vars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyRemoteConVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyRemoteConVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyRemoteConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyRemoteConVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgApplyRemoteConVars`
pub mod cmsg_apply_remote_con_vars {
    // @@protoc_insertion_point(message:dota.CMsgApplyRemoteConVars.ConVar)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ConVar {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgApplyRemoteConVars.ConVar.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgApplyRemoteConVars.ConVar.value)
        pub value: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgApplyRemoteConVars.ConVar.version_min)
        pub version_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgApplyRemoteConVars.ConVar.version_max)
        pub version_max: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgApplyRemoteConVars.ConVar.platform)
        pub platform: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::steammessages::EGCPlatform>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgApplyRemoteConVars.ConVar.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConVar {
        fn default() -> &'a ConVar {
            <ConVar as ::protobuf::Message>::default_instance()
        }
    }

    impl ConVar {
        pub fn new() -> ConVar {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 version_min = 3;

        pub fn version_min(&self) -> u32 {
            self.version_min.unwrap_or(0)
        }

        pub fn clear_version_min(&mut self) {
            self.version_min = ::std::option::Option::None;
        }

        pub fn has_version_min(&self) -> bool {
            self.version_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_min(&mut self, v: u32) {
            self.version_min = ::std::option::Option::Some(v);
        }

        // optional uint32 version_max = 4;

        pub fn version_max(&self) -> u32 {
            self.version_max.unwrap_or(0)
        }

        pub fn clear_version_max(&mut self) {
            self.version_max = ::std::option::Option::None;
        }

        pub fn has_version_max(&self) -> bool {
            self.version_max.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_max(&mut self, v: u32) {
            self.version_max = ::std::option::Option::Some(v);
        }

        // optional .dota.EGCPlatform platform = 5;

        pub fn platform(&self) -> super::super::steammessages::EGCPlatform {
            match self.platform {
                Some(e) => e.enum_value_or(super::super::steammessages::EGCPlatform::k_eGCPlatform_None),
                None => super::super::steammessages::EGCPlatform::k_eGCPlatform_None,
            }
        }

        pub fn clear_platform(&mut self) {
            self.platform = ::std::option::Option::None;
        }

        pub fn has_platform(&self) -> bool {
            self.platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_platform(&mut self, v: super::super::steammessages::EGCPlatform) {
            self.platform = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &ConVar| { &m.name },
                |m: &mut ConVar| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &ConVar| { &m.value },
                |m: &mut ConVar| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version_min",
                |m: &ConVar| { &m.version_min },
                |m: &mut ConVar| { &mut m.version_min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version_max",
                |m: &ConVar| { &m.version_max },
                |m: &mut ConVar| { &mut m.version_max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "platform",
                |m: &ConVar| { &m.platform },
                |m: &mut ConVar| { &mut m.platform },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConVar>(
                "CMsgApplyRemoteConVars.ConVar",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ConVar {
        const NAME: &'static str = "ConVar";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.version_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.version_max = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.platform = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.version_min {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.version_max {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.platform {
                my_size += ::protobuf::rt::int32_size(5, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.version_min {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.version_max {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.platform {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConVar {
            ConVar::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.version_min = ::std::option::Option::None;
            self.version_max = ::std::option::Option::None;
            self.platform = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConVar {
            static instance: ConVar = ConVar {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                version_min: ::std::option::Option::None,
                version_max: ::std::option::Option::None,
                platform: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ConVar {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgApplyRemoteConVars.ConVar").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ConVar {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ConVar {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientApplyRemoteConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientApplyRemoteConVars {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientApplyRemoteConVars.msg)
    pub msg: ::protobuf::MessageField<CMsgApplyRemoteConVars>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientApplyRemoteConVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientApplyRemoteConVars {
    fn default() -> &'a CMsgGCToClientApplyRemoteConVars {
        <CMsgGCToClientApplyRemoteConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientApplyRemoteConVars {
    pub fn new() -> CMsgGCToClientApplyRemoteConVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgApplyRemoteConVars>(
            "msg",
            |m: &CMsgGCToClientApplyRemoteConVars| { &m.msg },
            |m: &mut CMsgGCToClientApplyRemoteConVars| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientApplyRemoteConVars>(
            "CMsgGCToClientApplyRemoteConVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientApplyRemoteConVars {
    const NAME: &'static str = "CMsgGCToClientApplyRemoteConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientApplyRemoteConVars {
        CMsgGCToClientApplyRemoteConVars::new()
    }

    fn clear(&mut self) {
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientApplyRemoteConVars {
        static instance: CMsgGCToClientApplyRemoteConVars = CMsgGCToClientApplyRemoteConVars {
            msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientApplyRemoteConVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientApplyRemoteConVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientApplyRemoteConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientApplyRemoteConVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToServerApplyRemoteConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerApplyRemoteConVars {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToServerApplyRemoteConVars.msg)
    pub msg: ::protobuf::MessageField<CMsgApplyRemoteConVars>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToServerApplyRemoteConVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerApplyRemoteConVars {
    fn default() -> &'a CMsgGCToServerApplyRemoteConVars {
        <CMsgGCToServerApplyRemoteConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerApplyRemoteConVars {
    pub fn new() -> CMsgGCToServerApplyRemoteConVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgApplyRemoteConVars>(
            "msg",
            |m: &CMsgGCToServerApplyRemoteConVars| { &m.msg },
            |m: &mut CMsgGCToServerApplyRemoteConVars| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToServerApplyRemoteConVars>(
            "CMsgGCToServerApplyRemoteConVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToServerApplyRemoteConVars {
    const NAME: &'static str = "CMsgGCToServerApplyRemoteConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerApplyRemoteConVars {
        CMsgGCToServerApplyRemoteConVars::new()
    }

    fn clear(&mut self) {
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerApplyRemoteConVars {
        static instance: CMsgGCToServerApplyRemoteConVars = CMsgGCToServerApplyRemoteConVars {
            msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToServerApplyRemoteConVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToServerApplyRemoteConVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToServerApplyRemoteConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerApplyRemoteConVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCIntegrityStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCIntegrityStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCIntegrityStatus.report)
    pub report: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCIntegrityStatus.secure_allowed)
    pub secure_allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCIntegrityStatus.diagnostics)
    pub diagnostics: ::std::vec::Vec<cmsg_client_to_gcintegrity_status::Keyvalue>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCIntegrityStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCIntegrityStatus {
    fn default() -> &'a CMsgClientToGCIntegrityStatus {
        <CMsgClientToGCIntegrityStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCIntegrityStatus {
    pub fn new() -> CMsgClientToGCIntegrityStatus {
        ::std::default::Default::default()
    }

    // optional string report = 1;

    pub fn report(&self) -> &str {
        match self.report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_report(&mut self) {
        self.report = ::std::option::Option::None;
    }

    pub fn has_report(&self) -> bool {
        self.report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::string::String) {
        self.report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::string::String {
        if self.report.is_none() {
            self.report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.report.as_mut().unwrap()
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::string::String {
        self.report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool secure_allowed = 2;

    pub fn secure_allowed(&self) -> bool {
        self.secure_allowed.unwrap_or(false)
    }

    pub fn clear_secure_allowed(&mut self) {
        self.secure_allowed = ::std::option::Option::None;
    }

    pub fn has_secure_allowed(&self) -> bool {
        self.secure_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure_allowed(&mut self, v: bool) {
        self.secure_allowed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "report",
            |m: &CMsgClientToGCIntegrityStatus| { &m.report },
            |m: &mut CMsgClientToGCIntegrityStatus| { &mut m.report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secure_allowed",
            |m: &CMsgClientToGCIntegrityStatus| { &m.secure_allowed },
            |m: &mut CMsgClientToGCIntegrityStatus| { &mut m.secure_allowed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "diagnostics",
            |m: &CMsgClientToGCIntegrityStatus| { &m.diagnostics },
            |m: &mut CMsgClientToGCIntegrityStatus| { &mut m.diagnostics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCIntegrityStatus>(
            "CMsgClientToGCIntegrityStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCIntegrityStatus {
    const NAME: &'static str = "CMsgClientToGCIntegrityStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.report = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.secure_allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.diagnostics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.report.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.secure_allowed {
            my_size += 1 + 1;
        }
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.report.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.secure_allowed {
            os.write_bool(2, v)?;
        }
        for v in &self.diagnostics {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCIntegrityStatus {
        CMsgClientToGCIntegrityStatus::new()
    }

    fn clear(&mut self) {
        self.report = ::std::option::Option::None;
        self.secure_allowed = ::std::option::Option::None;
        self.diagnostics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCIntegrityStatus {
        static instance: CMsgClientToGCIntegrityStatus = CMsgClientToGCIntegrityStatus {
            report: ::std::option::Option::None,
            secure_allowed: ::std::option::Option::None,
            diagnostics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCIntegrityStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCIntegrityStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCIntegrityStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCIntegrityStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCIntegrityStatus`
pub mod cmsg_client_to_gcintegrity_status {
    // @@protoc_insertion_point(message:dota.CMsgClientToGCIntegrityStatus.keyvalue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Keyvalue {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCIntegrityStatus.keyvalue.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCIntegrityStatus.keyvalue.extended)
        pub extended: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCIntegrityStatus.keyvalue.value)
        pub value: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCIntegrityStatus.keyvalue.string_value)
        pub string_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCIntegrityStatus.keyvalue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Keyvalue {
        fn default() -> &'a Keyvalue {
            <Keyvalue as ::protobuf::Message>::default_instance()
        }
    }

    impl Keyvalue {
        pub fn new() -> Keyvalue {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 extended = 2;

        pub fn extended(&self) -> u32 {
            self.extended.unwrap_or(0)
        }

        pub fn clear_extended(&mut self) {
            self.extended = ::std::option::Option::None;
        }

        pub fn has_extended(&self) -> bool {
            self.extended.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extended(&mut self, v: u32) {
            self.extended = ::std::option::Option::Some(v);
        }

        // optional uint64 value = 3;

        pub fn value(&self) -> u64 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u64) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional string string_value = 4;

        pub fn string_value(&self) -> &str {
            match self.string_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string_value(&mut self) {
            self.string_value = ::std::option::Option::None;
        }

        pub fn has_string_value(&self) -> bool {
            self.string_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string_value(&mut self, v: ::std::string::String) {
            self.string_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
            if self.string_value.is_none() {
                self.string_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_string_value(&mut self) -> ::std::string::String {
            self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Keyvalue| { &m.id },
                |m: &mut Keyvalue| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extended",
                |m: &Keyvalue| { &m.extended },
                |m: &mut Keyvalue| { &mut m.extended },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Keyvalue| { &m.value },
                |m: &mut Keyvalue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "string_value",
                |m: &Keyvalue| { &m.string_value },
                |m: &mut Keyvalue| { &mut m.string_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Keyvalue>(
                "CMsgClientToGCIntegrityStatus.keyvalue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Keyvalue {
        const NAME: &'static str = "keyvalue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.extended = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.string_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.extended {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.string_value.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extended {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.string_value.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Keyvalue {
            Keyvalue::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.extended = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.string_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Keyvalue {
            static instance: Keyvalue = Keyvalue {
                id: ::std::option::Option::None,
                extended: ::std::option::Option::None,
                value: ::std::option::Option::None,
                string_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Keyvalue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCIntegrityStatus.keyvalue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Keyvalue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Keyvalue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAggregateMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAggregateMetrics {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAggregateMetrics.metrics)
    pub metrics: ::std::vec::Vec<cmsg_client_to_gcaggregate_metrics::SingleMetric>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAggregateMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAggregateMetrics {
    fn default() -> &'a CMsgClientToGCAggregateMetrics {
        <CMsgClientToGCAggregateMetrics as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAggregateMetrics {
    pub fn new() -> CMsgClientToGCAggregateMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &CMsgClientToGCAggregateMetrics| { &m.metrics },
            |m: &mut CMsgClientToGCAggregateMetrics| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAggregateMetrics>(
            "CMsgClientToGCAggregateMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAggregateMetrics {
    const NAME: &'static str = "CMsgClientToGCAggregateMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAggregateMetrics {
        CMsgClientToGCAggregateMetrics::new()
    }

    fn clear(&mut self) {
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAggregateMetrics {
        static instance: CMsgClientToGCAggregateMetrics = CMsgClientToGCAggregateMetrics {
            metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAggregateMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAggregateMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAggregateMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAggregateMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCAggregateMetrics`
pub mod cmsg_client_to_gcaggregate_metrics {
    // @@protoc_insertion_point(message:dota.CMsgClientToGCAggregateMetrics.SingleMetric)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleMetric {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCAggregateMetrics.SingleMetric.metric_name)
        pub metric_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCAggregateMetrics.SingleMetric.metric_count)
        pub metric_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAggregateMetrics.SingleMetric.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleMetric {
        fn default() -> &'a SingleMetric {
            <SingleMetric as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleMetric {
        pub fn new() -> SingleMetric {
            ::std::default::Default::default()
        }

        // optional string metric_name = 1;

        pub fn metric_name(&self) -> &str {
            match self.metric_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_metric_name(&mut self) {
            self.metric_name = ::std::option::Option::None;
        }

        pub fn has_metric_name(&self) -> bool {
            self.metric_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metric_name(&mut self, v: ::std::string::String) {
            self.metric_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metric_name(&mut self) -> &mut ::std::string::String {
            if self.metric_name.is_none() {
                self.metric_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.metric_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_metric_name(&mut self) -> ::std::string::String {
            self.metric_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 metric_count = 2;

        pub fn metric_count(&self) -> u32 {
            self.metric_count.unwrap_or(0)
        }

        pub fn clear_metric_count(&mut self) {
            self.metric_count = ::std::option::Option::None;
        }

        pub fn has_metric_count(&self) -> bool {
            self.metric_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metric_count(&mut self, v: u32) {
            self.metric_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "metric_name",
                |m: &SingleMetric| { &m.metric_name },
                |m: &mut SingleMetric| { &mut m.metric_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "metric_count",
                |m: &SingleMetric| { &m.metric_count },
                |m: &mut SingleMetric| { &mut m.metric_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleMetric>(
                "CMsgClientToGCAggregateMetrics.SingleMetric",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleMetric {
        const NAME: &'static str = "SingleMetric";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.metric_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.metric_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.metric_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.metric_count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.metric_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.metric_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleMetric {
            SingleMetric::new()
        }

        fn clear(&mut self) {
            self.metric_name = ::std::option::Option::None;
            self.metric_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleMetric {
            static instance: SingleMetric = SingleMetric {
                metric_name: ::std::option::Option::None,
                metric_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleMetric {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCAggregateMetrics.SingleMetric").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleMetric {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleMetric {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientAggregateMetricsBackoff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientAggregateMetricsBackoff {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientAggregateMetricsBackoff.upload_rate_modifier)
    pub upload_rate_modifier: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientAggregateMetricsBackoff.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientAggregateMetricsBackoff {
    fn default() -> &'a CMsgGCToClientAggregateMetricsBackoff {
        <CMsgGCToClientAggregateMetricsBackoff as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientAggregateMetricsBackoff {
    pub fn new() -> CMsgGCToClientAggregateMetricsBackoff {
        ::std::default::Default::default()
    }

    // optional float upload_rate_modifier = 1;

    pub fn upload_rate_modifier(&self) -> f32 {
        self.upload_rate_modifier.unwrap_or(0.)
    }

    pub fn clear_upload_rate_modifier(&mut self) {
        self.upload_rate_modifier = ::std::option::Option::None;
    }

    pub fn has_upload_rate_modifier(&self) -> bool {
        self.upload_rate_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_rate_modifier(&mut self, v: f32) {
        self.upload_rate_modifier = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_rate_modifier",
            |m: &CMsgGCToClientAggregateMetricsBackoff| { &m.upload_rate_modifier },
            |m: &mut CMsgGCToClientAggregateMetricsBackoff| { &mut m.upload_rate_modifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientAggregateMetricsBackoff>(
            "CMsgGCToClientAggregateMetricsBackoff",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientAggregateMetricsBackoff {
    const NAME: &'static str = "CMsgGCToClientAggregateMetricsBackoff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.upload_rate_modifier = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upload_rate_modifier {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upload_rate_modifier {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientAggregateMetricsBackoff {
        CMsgGCToClientAggregateMetricsBackoff::new()
    }

    fn clear(&mut self) {
        self.upload_rate_modifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientAggregateMetricsBackoff {
        static instance: CMsgGCToClientAggregateMetricsBackoff = CMsgGCToClientAggregateMetricsBackoff {
            upload_rate_modifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientAggregateMetricsBackoff {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientAggregateMetricsBackoff").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientAggregateMetricsBackoff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientAggregateMetricsBackoff {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EGCBaseMsg)
pub enum EGCBaseMsg {
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCReplicateConVars)
    k_EMsgGCReplicateConVars = 4002,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCConVarUpdated)
    k_EMsgGCConVarUpdated = 4003,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCInviteToParty)
    k_EMsgGCInviteToParty = 4501,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCInvitationCreated)
    k_EMsgGCInvitationCreated = 4502,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCPartyInviteResponse)
    k_EMsgGCPartyInviteResponse = 4503,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCKickFromParty)
    k_EMsgGCKickFromParty = 4504,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCLeaveParty)
    k_EMsgGCLeaveParty = 4505,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCServerAvailable)
    k_EMsgGCServerAvailable = 4506,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCClientConnectToServer)
    k_EMsgGCClientConnectToServer = 4507,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCGameServerInfo)
    k_EMsgGCGameServerInfo = 4508,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCLANServerAvailable)
    k_EMsgGCLANServerAvailable = 4511,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCInviteToLobby)
    k_EMsgGCInviteToLobby = 4512,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCLobbyInviteResponse)
    k_EMsgGCLobbyInviteResponse = 4513,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToClientPollFileRequest)
    k_EMsgGCToClientPollFileRequest = 4514,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToClientPollFileResponse)
    k_EMsgGCToClientPollFileResponse = 4515,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToGCPerformManualOp)
    k_EMsgGCToGCPerformManualOp = 4516,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToGCPerformManualOpCompleted)
    k_EMsgGCToGCPerformManualOpCompleted = 4517,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToGCReloadServerRegionSettings)
    k_EMsgGCToGCReloadServerRegionSettings = 4518,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCAdditionalWelcomeMsgList)
    k_EMsgGCAdditionalWelcomeMsgList = 4519,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToClientApplyRemoteConVars)
    k_EMsgGCToClientApplyRemoteConVars = 4520,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToServerApplyRemoteConVars)
    k_EMsgGCToServerApplyRemoteConVars = 4521,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgClientToGCIntegrityStatus)
    k_EMsgClientToGCIntegrityStatus = 4522,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgClientToGCAggregateMetrics)
    k_EMsgClientToGCAggregateMetrics = 4523,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseMsg.k_EMsgGCToClientAggregateMetricsBackoff)
    k_EMsgGCToClientAggregateMetricsBackoff = 4524,
}

impl ::protobuf::Enum for EGCBaseMsg {
    const NAME: &'static str = "EGCBaseMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseMsg> {
        match value {
            4002 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            4003 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            4501 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToParty),
            4502 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInvitationCreated),
            4503 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCPartyInviteResponse),
            4504 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCKickFromParty),
            4505 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLeaveParty),
            4506 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            4507 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            4508 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            4511 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            4512 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToLobby),
            4513 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLobbyInviteResponse),
            4514 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileRequest),
            4515 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileResponse),
            4516 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOp),
            4517 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted),
            4518 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings),
            4519 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList),
            4520 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars),
            4521 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars),
            4522 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCIntegrityStatus),
            4523 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCAggregateMetrics),
            4524 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCBaseMsg> {
        match str {
            "k_EMsgGCReplicateConVars" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            "k_EMsgGCConVarUpdated" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            "k_EMsgGCInviteToParty" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToParty),
            "k_EMsgGCInvitationCreated" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInvitationCreated),
            "k_EMsgGCPartyInviteResponse" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCPartyInviteResponse),
            "k_EMsgGCKickFromParty" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCKickFromParty),
            "k_EMsgGCLeaveParty" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLeaveParty),
            "k_EMsgGCServerAvailable" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            "k_EMsgGCClientConnectToServer" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            "k_EMsgGCGameServerInfo" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            "k_EMsgGCLANServerAvailable" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            "k_EMsgGCInviteToLobby" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToLobby),
            "k_EMsgGCLobbyInviteResponse" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLobbyInviteResponse),
            "k_EMsgGCToClientPollFileRequest" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileRequest),
            "k_EMsgGCToClientPollFileResponse" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileResponse),
            "k_EMsgGCToGCPerformManualOp" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOp),
            "k_EMsgGCToGCPerformManualOpCompleted" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted),
            "k_EMsgGCToGCReloadServerRegionSettings" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings),
            "k_EMsgGCAdditionalWelcomeMsgList" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList),
            "k_EMsgGCToClientApplyRemoteConVars" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars),
            "k_EMsgGCToServerApplyRemoteConVars" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars),
            "k_EMsgClientToGCIntegrityStatus" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCIntegrityStatus),
            "k_EMsgClientToGCAggregateMetrics" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCAggregateMetrics),
            "k_EMsgGCToClientAggregateMetricsBackoff" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseMsg] = &[
        EGCBaseMsg::k_EMsgGCReplicateConVars,
        EGCBaseMsg::k_EMsgGCConVarUpdated,
        EGCBaseMsg::k_EMsgGCInviteToParty,
        EGCBaseMsg::k_EMsgGCInvitationCreated,
        EGCBaseMsg::k_EMsgGCPartyInviteResponse,
        EGCBaseMsg::k_EMsgGCKickFromParty,
        EGCBaseMsg::k_EMsgGCLeaveParty,
        EGCBaseMsg::k_EMsgGCServerAvailable,
        EGCBaseMsg::k_EMsgGCClientConnectToServer,
        EGCBaseMsg::k_EMsgGCGameServerInfo,
        EGCBaseMsg::k_EMsgGCLANServerAvailable,
        EGCBaseMsg::k_EMsgGCInviteToLobby,
        EGCBaseMsg::k_EMsgGCLobbyInviteResponse,
        EGCBaseMsg::k_EMsgGCToClientPollFileRequest,
        EGCBaseMsg::k_EMsgGCToClientPollFileResponse,
        EGCBaseMsg::k_EMsgGCToGCPerformManualOp,
        EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted,
        EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings,
        EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList,
        EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars,
        EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars,
        EGCBaseMsg::k_EMsgClientToGCIntegrityStatus,
        EGCBaseMsg::k_EMsgClientToGCAggregateMetrics,
        EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff,
    ];
}

impl ::protobuf::EnumFull for EGCBaseMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCBaseMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCBaseMsg::k_EMsgGCReplicateConVars => 0,
            EGCBaseMsg::k_EMsgGCConVarUpdated => 1,
            EGCBaseMsg::k_EMsgGCInviteToParty => 2,
            EGCBaseMsg::k_EMsgGCInvitationCreated => 3,
            EGCBaseMsg::k_EMsgGCPartyInviteResponse => 4,
            EGCBaseMsg::k_EMsgGCKickFromParty => 5,
            EGCBaseMsg::k_EMsgGCLeaveParty => 6,
            EGCBaseMsg::k_EMsgGCServerAvailable => 7,
            EGCBaseMsg::k_EMsgGCClientConnectToServer => 8,
            EGCBaseMsg::k_EMsgGCGameServerInfo => 9,
            EGCBaseMsg::k_EMsgGCLANServerAvailable => 10,
            EGCBaseMsg::k_EMsgGCInviteToLobby => 11,
            EGCBaseMsg::k_EMsgGCLobbyInviteResponse => 12,
            EGCBaseMsg::k_EMsgGCToClientPollFileRequest => 13,
            EGCBaseMsg::k_EMsgGCToClientPollFileResponse => 14,
            EGCBaseMsg::k_EMsgGCToGCPerformManualOp => 15,
            EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted => 16,
            EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings => 17,
            EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList => 18,
            EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars => 19,
            EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars => 20,
            EGCBaseMsg::k_EMsgClientToGCIntegrityStatus => 21,
            EGCBaseMsg::k_EMsgClientToGCAggregateMetrics => 22,
            EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff => 23,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseMsg {
    fn default() -> Self {
        EGCBaseMsg::k_EMsgGCReplicateConVars
    }
}

impl EGCBaseMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCBaseMsg>("EGCBaseMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ECustomGameInstallStatus)
pub enum ECustomGameInstallStatus {
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_Unknown)
    k_ECustomGameInstallStatus_Unknown = 0,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_Ready)
    k_ECustomGameInstallStatus_Ready = 1,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_Busy)
    k_ECustomGameInstallStatus_Busy = 2,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedGeneric)
    k_ECustomGameInstallStatus_FailedGeneric = 101,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedInternalError)
    k_ECustomGameInstallStatus_FailedInternalError = 102,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooOld)
    k_ECustomGameInstallStatus_RequestedTimestampTooOld = 103,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooNew)
    k_ECustomGameInstallStatus_RequestedTimestampTooNew = 104,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_CRCMismatch)
    k_ECustomGameInstallStatus_CRCMismatch = 105,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedSteam)
    k_ECustomGameInstallStatus_FailedSteam = 106,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedCanceled)
    k_ECustomGameInstallStatus_FailedCanceled = 107,
}

impl ::protobuf::Enum for ECustomGameInstallStatus {
    const NAME: &'static str = "ECustomGameInstallStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECustomGameInstallStatus> {
        match value {
            0 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown),
            1 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Ready),
            2 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Busy),
            101 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedGeneric),
            102 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedInternalError),
            103 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooOld),
            104 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooNew),
            105 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_CRCMismatch),
            106 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedSteam),
            107 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedCanceled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECustomGameInstallStatus> {
        match str {
            "k_ECustomGameInstallStatus_Unknown" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown),
            "k_ECustomGameInstallStatus_Ready" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Ready),
            "k_ECustomGameInstallStatus_Busy" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Busy),
            "k_ECustomGameInstallStatus_FailedGeneric" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedGeneric),
            "k_ECustomGameInstallStatus_FailedInternalError" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedInternalError),
            "k_ECustomGameInstallStatus_RequestedTimestampTooOld" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooOld),
            "k_ECustomGameInstallStatus_RequestedTimestampTooNew" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooNew),
            "k_ECustomGameInstallStatus_CRCMismatch" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_CRCMismatch),
            "k_ECustomGameInstallStatus_FailedSteam" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedSteam),
            "k_ECustomGameInstallStatus_FailedCanceled" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedCanceled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECustomGameInstallStatus] = &[
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Ready,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Busy,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedGeneric,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedInternalError,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooOld,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooNew,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_CRCMismatch,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedSteam,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedCanceled,
    ];
}

impl ::protobuf::EnumFull for ECustomGameInstallStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECustomGameInstallStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown => 0,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_Ready => 1,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_Busy => 2,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedGeneric => 3,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedInternalError => 4,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooOld => 5,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooNew => 6,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_CRCMismatch => 7,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedSteam => 8,
            ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedCanceled => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECustomGameInstallStatus {
    fn default() -> Self {
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown
    }
}

impl ECustomGameInstallStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECustomGameInstallStatus>("ECustomGameInstallStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15base_gcmessages.proto\x12\x04dota\x1a\x13steammessages.proto\x1a\
    \x16gcsdk_gcmessages.proto\"\xe5\x01\n\x1dCGCStorePurchaseInit_LineItem\
    \x12\x1e\n\x0bitem_def_id\x18\x01\x20\x01(\rR\titemDefId\x12\x1a\n\x08qu\
    antity\x18\x02\x20\x01(\rR\x08quantity\x123\n\x16cost_in_local_currency\
    \x18\x03\x20\x01(\rR\x13costInLocalCurrency\x12#\n\rpurchase_type\x18\
    \x04\x20\x01(\rR\x0cpurchaseType\x12.\n\x13source_reference_id\x18\x05\
    \x20\x01(\x04R\x11sourceReferenceId\"\xaf\x01\n\x17CMsgGCStorePurchaseIn\
    it\x12\x18\n\x07country\x18\x01\x20\x01(\tR\x07country\x12\x1a\n\x08lang\
    uage\x18\x02\x20\x01(\x05R\x08language\x12\x1a\n\x08currency\x18\x03\x20\
    \x01(\x05R\x08currency\x12B\n\nline_items\x18\x04\x20\x03(\x0b2#.dota.CG\
    CStorePurchaseInit_LineItemR\tlineItems\"P\n\x1fCMsgGCStorePurchaseInitR\
    esponse\x12\x16\n\x06result\x18\x01\x20\x01(\x05R\x06result\x12\x15\n\
    \x06txn_id\x18\x02\x20\x01(\x04R\x05txnId\"\xd9\x01\n\x12CMsgClientPingD\
    ata\x12\x1f\n\x0brelay_codes\x18\x04\x20\x03(\x07R\nrelayCodes\x12\x1f\n\
    \x0brelay_pings\x18\x05\x20\x03(\rR\nrelayPings\x12!\n\x0cregion_codes\
    \x18\x08\x20\x03(\rR\x0bregionCodes\x12!\n\x0cregion_pings\x18\t\x20\x03\
    (\rR\x0bregionPings\x12;\n\x1aregion_ping_failed_bitmask\x18\n\x20\x01(\
    \rR\x17regionPingFailedBitmask\"\xc0\x01\n\x11CMsgInviteToParty\x12\x19\
    \n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12%\n\x0eclient_version\
    \x18\x02\x20\x01(\rR\rclientVersion\x12\x17\n\x07team_id\x18\x03\x20\x01\
    (\rR\x06teamId\x12\x19\n\x08as_coach\x18\x04\x20\x01(\x08R\x07asCoach\
    \x125\n\tping_data\x18\x05\x20\x01(\x0b2\x18.dota.CMsgClientPingDataR\
    \x08pingData\"U\n\x11CMsgInviteToLobby\x12\x19\n\x08steam_id\x18\x01\x20\
    \x01(\x06R\x07steamId\x12%\n\x0eclient_version\x18\x02\x20\x01(\rR\rclie\
    ntVersion\"p\n\x15CMsgInvitationCreated\x12\x19\n\x08group_id\x18\x01\
    \x20\x01(\x04R\x07groupId\x12\x19\n\x08steam_id\x18\x02\x20\x01(\x06R\
    \x07steamId\x12!\n\x0cuser_offline\x18\x03\x20\x01(\x08R\x0buserOffline\
    \"\xaa\x01\n\x17CMsgPartyInviteResponse\x12\x19\n\x08party_id\x18\x01\
    \x20\x01(\x04R\x07partyId\x12\x16\n\x06accept\x18\x02\x20\x01(\x08R\x06a\
    ccept\x12%\n\x0eclient_version\x18\x03\x20\x01(\rR\rclientVersion\x125\n\
    \tping_data\x18\x08\x20\x01(\x0b2\x18.dota.CMsgClientPingDataR\x08pingDa\
    ta\"\xcf\x01\n\x17CMsgLobbyInviteResponse\x12\x19\n\x08lobby_id\x18\x01\
    \x20\x01(\x06R\x07lobbyId\x12\x16\n\x06accept\x18\x02\x20\x01(\x08R\x06a\
    ccept\x12%\n\x0eclient_version\x18\x03\x20\x01(\rR\rclientVersion\x12&\n\
    \x0fcustom_game_crc\x18\x06\x20\x01(\x06R\rcustomGameCrc\x122\n\x15custo\
    m_game_timestamp\x18\x07\x20\x01(\x07R\x13customGameTimestamp\".\n\x11CM\
    sgKickFromParty\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"\
    \x10\n\x0eCMsgLeaveParty\"\xae\x01\n\x1bCMsgCustomGameInstallStatus\x126\
    \n\x06status\x18\x01\x20\x01(\x0e2\x1e.dota.ECustomGameInstallStatusR\
    \x06status\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12=\n\
    \x1blatest_timestamp_from_steam\x18\x03\x20\x01(\x07R\x18latestTimestamp\
    FromSteam\"u\n\x13CMsgServerAvailable\x12^\n\x1acustom_game_install_stat\
    us\x18\x01\x20\x01(\x0b2!.dota.CMsgCustomGameInstallStatusR\x17customGam\
    eInstallStatus\"3\n\x16CMsgLANServerAvailable\x12\x19\n\x08lobby_id\x18\
    \x01\x20\x01(\x06R\x07lobbyId\"\xb9\x03\n\x18CSOEconGameAccountClient\
    \x12:\n\x19additional_backpack_slots\x18\x01\x20\x01(\rR\x17additionalBa\
    ckpackSlots\x12#\n\rtrial_account\x18\x02\x20\x01(\x08R\x0ctrialAccount\
    \x127\n\x18eligible_for_online_play\x18\x03\x20\x01(\x08R\x15eligibleFor\
    OnlinePlay\x12I\n\"need_to_choose_most_helpful_friend\x18\x04\x20\x01(\
    \x08R\x1dneedToChooseMostHelpfulFriend\x12&\n\x0fin_coaches_list\x18\x05\
    \x20\x01(\x08R\rinCoachesList\x120\n\x14trade_ban_expiration\x18\x06\x20\
    \x01(\x07R\x12tradeBanExpiration\x12.\n\x13duel_ban_expiration\x18\x07\
    \x20\x01(\x07R\x11duelBanExpiration\x12.\n\x13made_first_purchase\x18\t\
    \x20\x01(\x08R\x11madeFirstPurchase\"i\n\x14CMsgApplyStrangePart\x12/\n\
    \x14strange_part_item_id\x18\x01\x20\x01(\x04R\x11strangePartItemId\x12\
    \x20\n\x0citem_item_id\x18\x02\x20\x01(\x04R\nitemItemId\"i\n\x17CMsgApp\
    lyPennantUpgrade\x12&\n\x0fupgrade_item_id\x18\x01\x20\x01(\x04R\rupgrad\
    eItemId\x12&\n\x0fpennant_item_id\x18\x02\x20\x01(\x04R\rpennantItemId\"\
    ]\n\x13CMsgApplyEggEssence\x12&\n\x0fessence_item_id\x18\x01\x20\x01(\
    \x04R\ressenceItemId\x12\x1e\n\x0begg_item_id\x18\x02\x20\x01(\x04R\tegg\
    ItemId\"j\n\x14CSOEconItemAttribute\x12\x1b\n\tdef_index\x18\x01\x20\x01\
    (\rR\x08defIndex\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value\x12\x1f\
    \n\x0bvalue_bytes\x18\x03\x20\x01(\x0cR\nvalueBytes\"M\n\x13CSOEconItemE\
    quipped\x12\x1b\n\tnew_class\x18\x01\x20\x01(\rR\x08newClass\x12\x19\n\
    \x08new_slot\x18\x02\x20\x01(\rR\x07newSlot\"\xdc\x03\n\x0bCSOEconItem\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\x1d\n\naccount_id\x18\
    \x02\x20\x01(\rR\taccountId\x12\x1c\n\tinventory\x18\x03\x20\x01(\rR\tin\
    ventory\x12\x1b\n\tdef_index\x18\x04\x20\x01(\rR\x08defIndex\x12\x1a\n\
    \x08quantity\x18\x05\x20\x01(\rR\x08quantity\x12\x14\n\x05level\x18\x06\
    \x20\x01(\rR\x05level\x12\x18\n\x07quality\x18\x07\x20\x01(\rR\x07qualit\
    y\x12\x14\n\x05flags\x18\x08\x20\x01(\rR\x05flags\x12\x16\n\x06origin\
    \x18\t\x20\x01(\rR\x06origin\x128\n\tattribute\x18\x0c\x20\x03(\x0b2\x1a\
    .dota.CSOEconItemAttributeR\tattribute\x126\n\rinterior_item\x18\r\x20\
    \x01(\x0b2\x11.dota.CSOEconItemR\x0cinteriorItem\x12\x14\n\x05style\x18\
    \x0f\x20\x01(\rR\x05style\x12\x1f\n\x0boriginal_id\x18\x10\x20\x01(\x04R\
    \noriginalId\x12@\n\x0eequipped_state\x18\x12\x20\x03(\x0b2\x19.dota.CSO\
    EconItemEquippedR\requippedState\",\n\rCMsgSortItems\x12\x1b\n\tsort_typ\
    e\x18\x01\x20\x01(\rR\x08sortType\";\n\x0fCMsgConVarValue\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value\"G\n\x14CMsgReplicateConVars\x12/\n\x07convars\x18\x01\x20\x03\
    (\x0b2\x15.dota.CMsgConVarValueR\x07convars\"\xba\x01\n\x14CMsgItemAckno\
    wledged\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1c\n\t\
    inventory\x18\x02\x20\x01(\rR\tinventory\x12\x1b\n\tdef_index\x18\x03\
    \x20\x01(\rR\x08defIndex\x12\x18\n\x07quality\x18\x04\x20\x01(\rR\x07qua\
    lity\x12\x16\n\x06rarity\x18\x05\x20\x01(\rR\x06rarity\x12\x16\n\x06orig\
    in\x18\x06\x20\x01(\rR\x06origin\"\xab\x01\n\x14CMsgSetItemPositions\x12\
    N\n\x0eitem_positions\x18\x01\x20\x03(\x0b2'.dota.CMsgSetItemPositions.I\
    temPositionR\ritemPositions\x1aC\n\x0cItemPosition\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\x12\x1a\n\x08position\x18\x02\x20\x01(\
    \rR\x08position\"2\n\x19CMsgGCStorePurchaseCancel\x12\x15\n\x06txn_id\
    \x18\x01\x20\x01(\x04R\x05txnId\";\n!CMsgGCStorePurchaseCancelResponse\
    \x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"4\n\x1bCMsgGCStorePu\
    rchaseFinalize\x12\x15\n\x06txn_id\x18\x01\x20\x01(\x04R\x05txnId\"X\n#C\
    MsgGCStorePurchaseFinalizeResponse\x12\x16\n\x06result\x18\x01\x20\x01(\
    \rR\x06result\x12\x19\n\x08item_ids\x18\x02\x20\x03(\x04R\x07itemIds\"<\
    \n\x1fCMsgGCToGCBannedWordListUpdated\x12\x19\n\x08group_id\x18\x01\x20\
    \x01(\rR\x07groupId\"S\n\x17CMsgGCToGCDirtySDOCache\x12\x19\n\x08sdo_typ\
    e\x18\x01\x20\x01(\rR\x07sdoType\x12\x1d\n\nkey_uint64\x18\x02\x20\x01(\
    \x04R\tkeyUint64\"\x14\n\x12CMsgSDONoMemcached\"8\n\x1bCMsgGCToGCUpdateS\
    QLKeyValue\x12\x19\n\x08key_name\x18\x01\x20\x01(\tR\x07keyName\"C\n\x1a\
    CMsgGCServerVersionUpdated\x12%\n\x0eserver_version\x18\x01\x20\x01(\rR\
    \rserverVersion\"C\n\x1aCMsgGCClientVersionUpdated\x12%\n\x0eclient_vers\
    ion\x18\x01\x20\x01(\rR\rclientVersion\"\x20\n\x1eCMsgGCToGCWebAPIAccoun\
    tChanged\"{\n\x0fCMsgExtractGems\x12\x20\n\x0ctool_item_id\x18\x01\x20\
    \x01(\x04R\ntoolItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\x04R\n\
    itemItemId\x12$\n\x0eitem_socket_id\x18\x03\x20\x01(\rR\x0citemSocketId\
    \"\xd2\x02\n\x17CMsgExtractGemsResponse\x12\x17\n\x07item_id\x18\x01\x20\
    \x01(\x04R\x06itemId\x12F\n\x08response\x18\x02\x20\x01(\x0e2*.dota.CMsg\
    ExtractGemsResponse.EExtractGemsR\x08response\"\xd5\x01\n\x0cEExtractGem\
    s\x12\x1b\n\x17k_ExtractGems_Succeeded\x10\0\x12&\n\"k_ExtractGems_Faile\
    d_ToolIsInvalid\x10\x01\x12&\n\"k_ExtractGems_Failed_ItemIsInvalid\x10\
    \x02\x12,\n(k_ExtractGems_Failed_ToolCannotRemoveGem\x10\x03\x12*\n&k_Ex\
    tractGems_Failed_FailedToRemoveGem\x10\x04\"m\n\rCMsgAddSocket\x12\x20\n\
    \x0ctool_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\x12\x20\n\x0citem_ite\
    m_id\x18\x02\x20\x01(\x04R\nitemItemId\x12\x18\n\x07unusual\x18\x03\x20\
    \x01(\x08R\x07unusual\"\xcd\x02\n\x15CMsgAddSocketResponse\x12\x17\n\x07\
    item_id\x18\x01\x20\x01(\x04R\x06itemId\x120\n\x14updated_socket_index\
    \x18\x02\x20\x03(\rR\x12updatedSocketIndex\x12B\n\x08response\x18\x03\
    \x20\x01(\x0e2&.dota.CMsgAddSocketResponse.EAddSocketR\x08response\"\xa4\
    \x01\n\nEAddSocket\x12\x19\n\x15k_AddSocket_Succeeded\x10\0\x12$\n\x20k_\
    AddSocket_Failed_ToolIsInvalid\x10\x01\x12+\n'k_AddSocket_Failed_ItemCan\
    notBeSocketed\x10\x02\x12(\n$k_AddSocket_Failed_FailedToAddSocket\x10\
    \x03\"\\\n\x17CMsgAddItemToSocketData\x12\x1e\n\x0bgem_item_id\x18\x01\
    \x20\x01(\x04R\tgemItemId\x12!\n\x0csocket_index\x18\x02\x20\x01(\rR\x0b\
    socketIndex\"|\n\x13CMsgAddItemToSocket\x12\x20\n\x0citem_item_id\x18\
    \x01\x20\x01(\x04R\nitemItemId\x12C\n\x0egems_to_socket\x18\x02\x20\x03(\
    \x0b2\x1d.dota.CMsgAddItemToSocketDataR\x0cgemsToSocket\"\xfa\x03\n\x1bC\
    MsgAddItemToSocketResponse\x12\x20\n\x0citem_item_id\x18\x01\x20\x01(\
    \x04R\nitemItemId\x120\n\x14updated_socket_index\x18\x02\x20\x03(\rR\x12\
    updatedSocketIndex\x12E\n\x08response\x18\x03\x20\x01(\x0e2).dota.CMsgAd\
    dItemToSocketResponse.EAddGemR\x08response\"\xbf\x02\n\x07EAddGem\x12\
    \x16\n\x12k_AddGem_Succeeded\x10\0\x12\x20\n\x1ck_AddGem_Failed_GemIsInv\
    alid\x10\x01\x12!\n\x1dk_AddGem_Failed_ItemIsInvalid\x10\x02\x12\"\n\x1e\
    k_AddGem_Failed_FailedToAddGem\x10\x03\x12+\n'k_AddGem_Failed_InvalidGem\
    TypeForSocket\x10\x04\x12)\n%k_AddGem_Failed_InvalidGemTypeForHero\x10\
    \x05\x12)\n%k_AddGem_Failed_InvalidGemTypeForSlot\x10\x06\x120\n,k_AddGe\
    m_Failed_SocketContainsUnremovableGem\x10\x07\"_\n\x18CMsgResetStrangeGe\
    mCount\x12\x20\n\x0citem_item_id\x18\x01\x20\x01(\x04R\nitemItemId\x12!\
    \n\x0csocket_index\x18\x02\x20\x01(\rR\x0bsocketIndex\"\xb7\x02\n\x20CMs\
    gResetStrangeGemCountResponse\x12L\n\x08response\x18\x01\x20\x01(\x0e20.\
    dota.CMsgResetStrangeGemCountResponse.EResetGemR\x08response\"\xc4\x01\n\
    \tEResetGem\x12\x18\n\x14k_ResetGem_Succeeded\x10\0\x12&\n\"k_ResetGem_F\
    ailed_FailedToResetGem\x10\x01\x12#\n\x1fk_ResetGem_Failed_ItemIsInvalid\
    \x10\x02\x12%\n!k_ResetGem_Failed_InvalidSocketId\x10\x03\x12)\n%k_Reset\
    Gem_Failed_SocketCannotBeReset\x10\x04\"|\n\x1dCMsgGCToClientPollFileReq\
    uest\x12\x1b\n\tfile_name\x18\x01\x20\x01(\tR\x08fileName\x12%\n\x0eclie\
    nt_version\x18\x02\x20\x01(\rR\rclientVersion\x12\x17\n\x07poll_id\x18\
    \x03\x20\x01(\rR\x06pollId\"q\n\x1eCMsgGCToClientPollFileResponse\x12\
    \x17\n\x07poll_id\x18\x01\x20\x01(\rR\x06pollId\x12\x1b\n\tfile_size\x18\
    \x02\x20\x01(\rR\x08fileSize\x12\x19\n\x08file_crc\x18\x03\x20\x01(\rR\
    \x07fileCrc\"O\n\x19CMsgGCToGCPerformManualOp\x12\x13\n\x05op_id\x18\x01\
    \x20\x01(\x04R\x04opId\x12\x1d\n\ngroup_code\x18\x02\x20\x01(\rR\tgroupC\
    ode\"[\n\"CMsgGCToGCPerformManualOpCompleted\x12\x18\n\x07success\x18\
    \x01\x20\x01(\x08R\x07success\x12\x1b\n\tsource_gc\x18\x02\x20\x01(\x05R\
    \x08sourceGc\"&\n$CMsgGCToGCReloadServerRegionSettings\"a\n\x1eCMsgGCAdd\
    itionalWelcomeMsgList\x12?\n\x10welcome_messages\x18\x01\x20\x03(\x0b2\
    \x14.dota.CExtraMsgBlockR\x0fwelcomeMessages\"\xfe\x01\n\x16CMsgApplyRem\
    oteConVars\x12>\n\x08con_vars\x18\x01\x20\x03(\x0b2#.dota.CMsgApplyRemot\
    eConVars.ConVarR\x07conVars\x1a\xa3\x01\n\x06ConVar\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue\x12\x1f\n\x0bversion_min\x18\x03\x20\x01(\rR\nversionMin\x12\x1f\n\
    \x0bversion_max\x18\x04\x20\x01(\rR\nversionMax\x12-\n\x08platform\x18\
    \x05\x20\x01(\x0e2\x11.dota.EGCPlatformR\x08platform\"R\n\x20CMsgGCToCli\
    entApplyRemoteConVars\x12.\n\x03msg\x18\x01\x20\x01(\x0b2\x1c.dota.CMsgA\
    pplyRemoteConVarsR\x03msg\"R\n\x20CMsgGCToServerApplyRemoteConVars\x12.\
    \n\x03msg\x18\x01\x20\x01(\x0b2\x1c.dota.CMsgApplyRemoteConVarsR\x03msg\
    \"\x9f\x02\n\x1dCMsgClientToGCIntegrityStatus\x12\x16\n\x06report\x18\
    \x01\x20\x01(\tR\x06report\x12%\n\x0esecure_allowed\x18\x02\x20\x01(\x08\
    R\rsecureAllowed\x12N\n\x0bdiagnostics\x18\x03\x20\x03(\x0b2,.dota.CMsgC\
    lientToGCIntegrityStatus.keyvalueR\x0bdiagnostics\x1ao\n\x08keyvalue\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x1a\n\x08extended\x18\x02\x20\
    \x01(\rR\x08extended\x12\x14\n\x05value\x18\x03\x20\x01(\x04R\x05value\
    \x12!\n\x0cstring_value\x18\x04\x20\x01(\tR\x0bstringValue\"\xc1\x01\n\
    \x1eCMsgClientToGCAggregateMetrics\x12K\n\x07metrics\x18\x01\x20\x03(\
    \x0b21.dota.CMsgClientToGCAggregateMetrics.SingleMetricR\x07metrics\x1aR\
    \n\x0cSingleMetric\x12\x1f\n\x0bmetric_name\x18\x01\x20\x01(\tR\nmetricN\
    ame\x12!\n\x0cmetric_count\x18\x02\x20\x01(\rR\x0bmetricCount\"Y\n%CMsgG\
    CToClientAggregateMetricsBackoff\x120\n\x14upload_rate_modifier\x18\x01\
    \x20\x01(\x02R\x12uploadRateModifier*\xd3\x06\n\nEGCBaseMsg\x12\x1d\n\
    \x18k_EMsgGCReplicateConVars\x10\xa2\x1f\x12\x1a\n\x15k_EMsgGCConVarUpda\
    ted\x10\xa3\x1f\x12\x1a\n\x15k_EMsgGCInviteToParty\x10\x95#\x12\x1e\n\
    \x19k_EMsgGCInvitationCreated\x10\x96#\x12\x20\n\x1bk_EMsgGCPartyInviteR\
    esponse\x10\x97#\x12\x1a\n\x15k_EMsgGCKickFromParty\x10\x98#\x12\x17\n\
    \x12k_EMsgGCLeaveParty\x10\x99#\x12\x1c\n\x17k_EMsgGCServerAvailable\x10\
    \x9a#\x12\"\n\x1dk_EMsgGCClientConnectToServer\x10\x9b#\x12\x1b\n\x16k_E\
    MsgGCGameServerInfo\x10\x9c#\x12\x1f\n\x1ak_EMsgGCLANServerAvailable\x10\
    \x9f#\x12\x1a\n\x15k_EMsgGCInviteToLobby\x10\xa0#\x12\x20\n\x1bk_EMsgGCL\
    obbyInviteResponse\x10\xa1#\x12$\n\x1fk_EMsgGCToClientPollFileRequest\
    \x10\xa2#\x12%\n\x20k_EMsgGCToClientPollFileResponse\x10\xa3#\x12\x20\n\
    \x1bk_EMsgGCToGCPerformManualOp\x10\xa4#\x12)\n$k_EMsgGCToGCPerformManua\
    lOpCompleted\x10\xa5#\x12+\n&k_EMsgGCToGCReloadServerRegionSettings\x10\
    \xa6#\x12%\n\x20k_EMsgGCAdditionalWelcomeMsgList\x10\xa7#\x12'\n\"k_EMsg\
    GCToClientApplyRemoteConVars\x10\xa8#\x12'\n\"k_EMsgGCToServerApplyRemot\
    eConVars\x10\xa9#\x12$\n\x1fk_EMsgClientToGCIntegrityStatus\x10\xaa#\x12\
    %\n\x20k_EMsgClientToGCAggregateMetrics\x10\xab#\x12,\n'k_EMsgGCToClient\
    AggregateMetricsBackoff\x10\xac#*\xe8\x03\n\x18ECustomGameInstallStatus\
    \x12&\n\"k_ECustomGameInstallStatus_Unknown\x10\0\x12$\n\x20k_ECustomGam\
    eInstallStatus_Ready\x10\x01\x12#\n\x1fk_ECustomGameInstallStatus_Busy\
    \x10\x02\x12,\n(k_ECustomGameInstallStatus_FailedGeneric\x10e\x122\n.k_E\
    CustomGameInstallStatus_FailedInternalError\x10f\x127\n3k_ECustomGameIns\
    tallStatus_RequestedTimestampTooOld\x10g\x127\n3k_ECustomGameInstallStat\
    us_RequestedTimestampTooNew\x10h\x12*\n&k_ECustomGameInstallStatus_CRCMi\
    smatch\x10i\x12*\n&k_ECustomGameInstallStatus_FailedSteam\x10j\x12-\n)k_\
    ECustomGameInstallStatus_FailedCanceled\x10kB%Z#github.com/dotabuff/mant\
    a/dota;dotaJ\xefw\n\x07\x12\x05\0\0\x9f\x03\x01\n\x08\n\x01\x0c\x12\x03\
    \0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\
    \0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\
    \n\t\n\x02\x03\x01\x12\x03\x06\x07\x1f\n\n\n\x02\x05\0\x12\x04\x08\0!\
    \x01\n\n\n\x03\x05\0\x01\x12\x03\x08\x05\x0f\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03\t\x08(\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\t\x08\x20\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03\t#'\n\x0b\n\x04\x05\0\x02\x01\x12\x03\n\x08%\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\n\x08\x1d\n\x0c\n\x05\x05\0\x02\x01\
    \x02\x12\x03\n\x20$\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0b\x08%\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x0b\x08\x1d\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x0b\x20$\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x0c\x08)\n\x0c\n\x05\
    \x05\0\x02\x03\x01\x12\x03\x0c\x08!\n\x0c\n\x05\x05\0\x02\x03\x02\x12\
    \x03\x0c$(\n\x0b\n\x04\x05\0\x02\x04\x12\x03\r\x08+\n\x0c\n\x05\x05\0\
    \x02\x04\x01\x12\x03\r\x08#\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\r&*\n\
    \x0b\n\x04\x05\0\x02\x05\x12\x03\x0e\x08%\n\x0c\n\x05\x05\0\x02\x05\x01\
    \x12\x03\x0e\x08\x1d\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0e\x20$\n\
    \x0b\n\x04\x05\0\x02\x06\x12\x03\x0f\x08\"\n\x0c\n\x05\x05\0\x02\x06\x01\
    \x12\x03\x0f\x08\x1a\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0f\x1d!\n\
    \x0b\n\x04\x05\0\x02\x07\x12\x03\x10\x08'\n\x0c\n\x05\x05\0\x02\x07\x01\
    \x12\x03\x10\x08\x1f\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x10\"&\n\x0b\
    \n\x04\x05\0\x02\x08\x12\x03\x11\x08-\n\x0c\n\x05\x05\0\x02\x08\x01\x12\
    \x03\x11\x08%\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x11(,\n\x0b\n\x04\
    \x05\0\x02\t\x12\x03\x12\x08&\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x12\
    \x08\x1e\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x12!%\n\x0b\n\x04\x05\0\x02\
    \n\x12\x03\x13\x08*\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x13\x08\"\n\x0c\
    \n\x05\x05\0\x02\n\x02\x12\x03\x13%)\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\
    \x14\x08%\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x14\x08\x1d\n\x0c\n\x05\
    \x05\0\x02\x0b\x02\x12\x03\x14\x20$\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\
    \x15\x08+\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x15\x08#\n\x0c\n\x05\x05\
    \0\x02\x0c\x02\x12\x03\x15&*\n\x0b\n\x04\x05\0\x02\r\x12\x03\x16\x08/\n\
    \x0c\n\x05\x05\0\x02\r\x01\x12\x03\x16\x08'\n\x0c\n\x05\x05\0\x02\r\x02\
    \x12\x03\x16*.\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x17\x080\n\x0c\n\x05\
    \x05\0\x02\x0e\x01\x12\x03\x17\x08(\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\
    \x03\x17+/\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x18\x08+\n\x0c\n\x05\x05\0\
    \x02\x0f\x01\x12\x03\x18\x08#\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x18&\
    *\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x19\x084\n\x0c\n\x05\x05\0\x02\x10\
    \x01\x12\x03\x19\x08,\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x19/3\n\x0b\
    \n\x04\x05\0\x02\x11\x12\x03\x1a\x086\n\x0c\n\x05\x05\0\x02\x11\x01\x12\
    \x03\x1a\x08.\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x1a15\n\x0b\n\x04\
    \x05\0\x02\x12\x12\x03\x1b\x080\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\
    \x1b\x08(\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x1b+/\n\x0b\n\x04\x05\0\
    \x02\x13\x12\x03\x1c\x082\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x1c\x08*\
    \n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\x1c-1\n\x0b\n\x04\x05\0\x02\x14\
    \x12\x03\x1d\x082\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1d\x08*\n\x0c\n\
    \x05\x05\0\x02\x14\x02\x12\x03\x1d-1\n\x0b\n\x04\x05\0\x02\x15\x12\x03\
    \x1e\x08/\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1e\x08'\n\x0c\n\x05\x05\
    \0\x02\x15\x02\x12\x03\x1e*.\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x1f\x080\
    \n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x1f\x08(\n\x0c\n\x05\x05\0\x02\
    \x16\x02\x12\x03\x1f+/\n\x0b\n\x04\x05\0\x02\x17\x12\x03\x20\x087\n\x0c\
    \n\x05\x05\0\x02\x17\x01\x12\x03\x20\x08/\n\x0c\n\x05\x05\0\x02\x17\x02\
    \x12\x03\x2026\n\n\n\x02\x05\x01\x12\x04#\0.\x01\n\n\n\x03\x05\x01\x01\
    \x12\x03#\x05\x1d\n\x0b\n\x04\x05\x01\x02\0\x12\x03$\x08/\n\x0c\n\x05\
    \x05\x01\x02\0\x01\x12\x03$\x08*\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03$-\
    .\n\x0b\n\x04\x05\x01\x02\x01\x12\x03%\x08-\n\x0c\n\x05\x05\x01\x02\x01\
    \x01\x12\x03%\x08(\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03%+,\n\x0b\n\
    \x04\x05\x01\x02\x02\x12\x03&\x08,\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\
    \x03&\x08'\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03&*+\n\x0b\n\x04\x05\
    \x01\x02\x03\x12\x03'\x087\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03'\x080\
    \n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03'36\n\x0b\n\x04\x05\x01\x02\x04\
    \x12\x03(\x08=\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03(\x086\n\x0c\n\x05\
    \x05\x01\x02\x04\x02\x12\x03(9<\n\x0b\n\x04\x05\x01\x02\x05\x12\x03)\x08\
    B\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03)\x08;\n\x0c\n\x05\x05\x01\x02\
    \x05\x02\x12\x03)>A\n\x0b\n\x04\x05\x01\x02\x06\x12\x03*\x08B\n\x0c\n\
    \x05\x05\x01\x02\x06\x01\x12\x03*\x08;\n\x0c\n\x05\x05\x01\x02\x06\x02\
    \x12\x03*>A\n\x0b\n\x04\x05\x01\x02\x07\x12\x03+\x085\n\x0c\n\x05\x05\
    \x01\x02\x07\x01\x12\x03+\x08.\n\x0c\n\x05\x05\x01\x02\x07\x02\x12\x03+1\
    4\n\x0b\n\x04\x05\x01\x02\x08\x12\x03,\x085\n\x0c\n\x05\x05\x01\x02\x08\
    \x01\x12\x03,\x08.\n\x0c\n\x05\x05\x01\x02\x08\x02\x12\x03,14\n\x0b\n\
    \x04\x05\x01\x02\t\x12\x03-\x088\n\x0c\n\x05\x05\x01\x02\t\x01\x12\x03-\
    \x081\n\x0c\n\x05\x05\x01\x02\t\x02\x12\x03-47\n\n\n\x02\x04\0\x12\x040\
    \06\x01\n\n\n\x03\x04\0\x01\x12\x030\x08%\n\x0b\n\x04\x04\0\x02\0\x12\
    \x031\x08(\n\x0c\n\x05\x04\0\x02\0\x04\x12\x031\x08\x10\n\x0c\n\x05\x04\
    \0\x02\0\x05\x12\x031\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x031\x18#\
    \n\x0c\n\x05\x04\0\x02\0\x03\x12\x031&'\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x032\x08%\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x032\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x01\x05\x12\x032\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\
    \x032\x18\x20\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x032#$\n\x0b\n\x04\x04\0\
    \x02\x02\x12\x033\x083\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x033\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x033\x18.\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03312\n\x0b\n\x04\
    \x04\0\x02\x03\x12\x034\x08*\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x034\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x034\x11\x17\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x034\x18%\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x034()\n\
    \x0b\n\x04\x04\0\x02\x04\x12\x035\x080\n\x0c\n\x05\x04\0\x02\x04\x04\x12\
    \x035\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x035\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x04\x01\x12\x035\x18+\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x035.\
    /\n\n\n\x02\x04\x01\x12\x048\0=\x01\n\n\n\x03\x04\x01\x01\x12\x038\x08\
    \x1f\n\x0b\n\x04\x04\x01\x02\0\x12\x039\x08$\n\x0c\n\x05\x04\x01\x02\0\
    \x04\x12\x039\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x039\x11\x17\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x039\x18\x1f\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x039\"#\n\x0b\n\x04\x04\x01\x02\x01\x12\x03:\x08$\n\x0c\n\x05\
    \x04\x01\x02\x01\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03:\x11\x16\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03:\x17\x1f\n\x0c\
    \n\x05\x04\x01\x02\x01\x03\x12\x03:\"#\n\x0b\n\x04\x04\x01\x02\x02\x12\
    \x03;\x08$\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03;\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03;\x11\x16\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03;\x17\x1f\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03;\"#\n\x0b\n\
    \x04\x04\x01\x02\x03\x12\x03<\x08>\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\
    \x03<\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03<\x11.\n\x0c\n\x05\
    \x04\x01\x02\x03\x01\x12\x03</9\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03<\
    <=\n\n\n\x02\x04\x02\x12\x04?\0B\x01\n\n\n\x03\x04\x02\x01\x12\x03?\x08'\
    \n\x0b\n\x04\x04\x02\x02\0\x12\x03@\x08\"\n\x0c\n\x05\x04\x02\x02\0\x04\
    \x12\x03@\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03@\x11\x16\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03@\x17\x1d\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03@\x20!\n\x0b\n\x04\x04\x02\x02\x01\x12\x03A\x08#\n\x0c\n\x05\x04\
    \x02\x02\x01\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\
    \x03A\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03A\x18\x1e\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03A!\"\n\n\n\x02\x04\x03\x12\x04D\0J\x01\n\
    \n\n\x03\x04\x03\x01\x12\x03D\x08\x1a\n\x0b\n\x04\x04\x03\x02\0\x12\x03E\
    \x08)\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03E\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03E\x11\x18\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03E\x19$\
    \n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03E'(\n\x0b\n\x04\x04\x03\x02\x01\
    \x12\x03F\x08(\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03F\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\x01\x05\x12\x03F\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03F\x18#\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03F&'\n\x0b\n\
    \x04\x04\x03\x02\x02\x12\x03G\x08)\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\
    \x03G\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03G\x11\x17\n\x0c\n\
    \x05\x04\x03\x02\x02\x01\x12\x03G\x18$\n\x0c\n\x05\x04\x03\x02\x02\x03\
    \x12\x03G'(\n\x0b\n\x04\x04\x03\x02\x03\x12\x03H\x08)\n\x0c\n\x05\x04\
    \x03\x02\x03\x04\x12\x03H\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\
    \x03H\x11\x17\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03H\x18$\n\x0c\n\x05\
    \x04\x03\x02\x03\x03\x12\x03H'(\n\x0b\n\x04\x04\x03\x02\x04\x12\x03I\x08\
    8\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03I\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x04\x05\x12\x03I\x11\x17\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03I\
    \x182\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03I57\n\n\n\x02\x04\x04\x12\
    \x04L\0R\x01\n\n\n\x03\x04\x04\x01\x12\x03L\x08\x19\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03M\x08&\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03M\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03M\x11\x18\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03M\x19!\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03M$%\n\x0b\n\x04\
    \x04\x04\x02\x01\x12\x03N\x08+\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03N\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03N\x11\x17\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03N\x18&\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03N)*\n\x0b\n\x04\x04\x04\x02\x02\x12\x03O\x08$\n\x0c\n\x05\x04\x04\
    \x02\x02\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03O\
    \x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03O\x18\x1f\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03O\"#\n\x0b\n\x04\x04\x04\x02\x03\x12\x03P\
    \x08#\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03P\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x03\x05\x12\x03P\x11\x15\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\
    \x03P\x16\x1e\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03P!\"\n\x0b\n\x04\
    \x04\x04\x02\x04\x12\x03Q\x082\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03Q\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x06\x12\x03Q\x11#\n\x0c\n\x05\x04\
    \x04\x02\x04\x01\x12\x03Q$-\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03Q01\n\
    \n\n\x02\x04\x05\x12\x04T\0W\x01\n\n\n\x03\x04\x05\x01\x12\x03T\x08\x19\
    \n\x0b\n\x04\x04\x05\x02\0\x12\x03U\x08&\n\x0c\n\x05\x04\x05\x02\0\x04\
    \x12\x03U\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03U\x11\x18\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x03U\x19!\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03U$%\n\x0b\n\x04\x04\x05\x02\x01\x12\x03V\x08+\n\x0c\n\x05\x04\x05\
    \x02\x01\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03V\
    \x11\x17\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03V\x18&\n\x0c\n\x05\x04\
    \x05\x02\x01\x03\x12\x03V)*\n\n\n\x02\x04\x06\x12\x04Y\0]\x01\n\n\n\x03\
    \x04\x06\x01\x12\x03Y\x08\x1d\n\x0b\n\x04\x04\x06\x02\0\x12\x03Z\x08%\n\
    \x0c\n\x05\x04\x06\x02\0\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\x06\x02\0\
    \x05\x12\x03Z\x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03Z\x18\x20\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03Z#$\n\x0b\n\x04\x04\x06\x02\x01\x12\
    \x03[\x08&\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03[\x08\x10\n\x0c\n\x05\
    \x04\x06\x02\x01\x05\x12\x03[\x11\x18\n\x0c\n\x05\x04\x06\x02\x01\x01\
    \x12\x03[\x19!\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03[$%\n\x0b\n\x04\
    \x04\x06\x02\x02\x12\x03\\\x08'\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03\
    \\\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03\\\x11\x15\n\x0c\n\x05\
    \x04\x06\x02\x02\x01\x12\x03\\\x16\"\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\
    \x03\\%&\n\n\n\x02\x04\x07\x12\x04_\0d\x01\n\n\n\x03\x04\x07\x01\x12\x03\
    _\x08\x1f\n\x0b\n\x04\x04\x07\x02\0\x12\x03`\x08%\n\x0c\n\x05\x04\x07\
    \x02\0\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03`\x11\
    \x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03`\x18\x20\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03`#$\n\x0b\n\x04\x04\x07\x02\x01\x12\x03a\x08!\n\x0c\n\
    \x05\x04\x07\x02\x01\x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\
    \x05\x12\x03a\x11\x15\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03a\x16\x1c\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x03a\x1f\x20\n\x0b\n\x04\x04\x07\x02\
    \x02\x12\x03b\x08+\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03b\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x02\x05\x12\x03b\x11\x17\n\x0c\n\x05\x04\x07\x02\
    \x02\x01\x12\x03b\x18&\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03b)*\n\x0b\
    \n\x04\x04\x07\x02\x03\x12\x03c\x082\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\
    \x03c\x08\x10\n\x0c\n\x05\x04\x07\x02\x03\x06\x12\x03c\x11#\n\x0c\n\x05\
    \x04\x07\x02\x03\x01\x12\x03c$-\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03c\
    01\n\n\n\x02\x04\x08\x12\x04f\0l\x01\n\n\n\x03\x04\x08\x01\x12\x03f\x08\
    \x1f\n\x0b\n\x04\x04\x08\x02\0\x12\x03g\x08&\n\x0c\n\x05\x04\x08\x02\0\
    \x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03g\x11\x18\n\
    \x0c\n\x05\x04\x08\x02\0\x01\x12\x03g\x19!\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x03g$%\n\x0b\n\x04\x04\x08\x02\x01\x12\x03h\x08!\n\x0c\n\x05\x04\
    \x08\x02\x01\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\
    \x03h\x11\x15\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03h\x16\x1c\n\x0c\n\
    \x05\x04\x08\x02\x01\x03\x12\x03h\x1f\x20\n\x0b\n\x04\x04\x08\x02\x02\
    \x12\x03i\x08+\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03i\x08\x10\n\x0c\n\
    \x05\x04\x08\x02\x02\x05\x12\x03i\x11\x17\n\x0c\n\x05\x04\x08\x02\x02\
    \x01\x12\x03i\x18&\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03i)*\n\x0b\n\
    \x04\x04\x08\x02\x03\x12\x03j\x08-\n\x0c\n\x05\x04\x08\x02\x03\x04\x12\
    \x03j\x08\x10\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03j\x11\x18\n\x0c\n\
    \x05\x04\x08\x02\x03\x01\x12\x03j\x19(\n\x0c\n\x05\x04\x08\x02\x03\x03\
    \x12\x03j+,\n\x0b\n\x04\x04\x08\x02\x04\x12\x03k\x083\n\x0c\n\x05\x04\
    \x08\x02\x04\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\
    \x03k\x11\x18\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03k\x19.\n\x0c\n\x05\
    \x04\x08\x02\x04\x03\x12\x03k12\n\n\n\x02\x04\t\x12\x04n\0p\x01\n\n\n\
    \x03\x04\t\x01\x12\x03n\x08\x19\n\x0b\n\x04\x04\t\x02\0\x12\x03o\x08&\n\
    \x0c\n\x05\x04\t\x02\0\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\
    \x12\x03o\x11\x18\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03o\x19!\n\x0c\n\x05\
    \x04\t\x02\0\x03\x12\x03o$%\n\n\n\x02\x04\n\x12\x04r\0s\x01\n\n\n\x03\
    \x04\n\x01\x12\x03r\x08\x16\n\n\n\x02\x04\x0b\x12\x04u\0y\x01\n\n\n\x03\
    \x04\x0b\x01\x12\x03u\x08#\n\x0b\n\x04\x04\x0b\x02\0\x12\x03v\x085\n\x0c\
    \n\x05\x04\x0b\x02\0\x04\x12\x03v\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x06\
    \x12\x03v\x11)\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03v*0\n\x0c\n\x05\x04\
    \x0b\x02\0\x03\x12\x03v34\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03w\x08$\n\
    \x0c\n\x05\x04\x0b\x02\x01\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\x0b\x02\
    \x01\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03w\x18\
    \x1f\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03w\"#\n\x0b\n\x04\x04\x0b\x02\
    \x02\x12\x03x\x089\n\x0c\n\x05\x04\x0b\x02\x02\x04\x12\x03x\x08\x10\n\
    \x0c\n\x05\x04\x0b\x02\x02\x05\x12\x03x\x11\x18\n\x0c\n\x05\x04\x0b\x02\
    \x02\x01\x12\x03x\x194\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03x78\n\n\n\
    \x02\x04\x0c\x12\x04{\0}\x01\n\n\n\x03\x04\x0c\x01\x12\x03{\x08\x1b\n\
    \x0b\n\x04\x04\x0c\x02\0\x12\x03|\x08L\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\
    \x03|\x08\x10\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03|\x11,\n\x0c\n\x05\
    \x04\x0c\x02\0\x01\x12\x03|-G\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03|JK\n\
    \x0b\n\x02\x04\r\x12\x05\x7f\0\x81\x01\x01\n\n\n\x03\x04\r\x01\x12\x03\
    \x7f\x08\x1e\n\x0c\n\x04\x04\r\x02\0\x12\x04\x80\x01\x08&\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \x80\x01\x11\x18\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x80\x01\x19!\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\x80\x01$%\n\x0c\n\x02\x04\x0e\x12\x06\x83\
    \x01\0\x8c\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x83\x01\x08\x20\n\x0c\
    \n\x04\x04\x0e\x02\0\x12\x04\x84\x01\x086\n\r\n\x05\x04\x0e\x02\0\x04\
    \x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x84\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x84\x01\x181\n\r\n\x05\x04\x0e\
    \x02\0\x03\x12\x04\x84\x0145\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x85\x01\
    \x08(\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x01\x05\x12\x04\x85\x01\x11\x15\n\r\n\x05\x04\x0e\x02\x01\
    \x01\x12\x04\x85\x01\x16#\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x85\x01&\
    '\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\x86\x01\x083\n\r\n\x05\x04\x0e\x02\
    \x02\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\
    \x86\x01\x11\x15\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x86\x01\x16.\n\r\
    \n\x05\x04\x0e\x02\x02\x03\x12\x04\x86\x0112\n\x0c\n\x04\x04\x0e\x02\x03\
    \x12\x04\x87\x01\x08=\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\x87\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\x87\x01\x11\x15\n\r\n\x05\x04\
    \x0e\x02\x03\x01\x12\x04\x87\x01\x168\n\r\n\x05\x04\x0e\x02\x03\x03\x12\
    \x04\x87\x01;<\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\x88\x01\x08*\n\r\n\
    \x05\x04\x0e\x02\x04\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x04\x05\x12\x04\x88\x01\x11\x15\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \x88\x01\x16%\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x88\x01()\n\x0c\n\
    \x04\x04\x0e\x02\x05\x12\x04\x89\x01\x082\n\r\n\x05\x04\x0e\x02\x05\x04\
    \x12\x04\x89\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\x89\x01\
    \x11\x18\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\x89\x01\x19-\n\r\n\x05\
    \x04\x0e\x02\x05\x03\x12\x04\x89\x0101\n\x0c\n\x04\x04\x0e\x02\x06\x12\
    \x04\x8a\x01\x081\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\x8a\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\x8a\x01\x11\x18\n\r\n\x05\x04\x0e\
    \x02\x06\x01\x12\x04\x8a\x01\x19,\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\
    \x8a\x01/0\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\x8b\x01\x08.\n\r\n\x05\
    \x04\x0e\x02\x07\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x07\
    \x05\x12\x04\x8b\x01\x11\x15\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\x8b\
    \x01\x16)\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\x8b\x01,-\n\x0c\n\x02\
    \x04\x0f\x12\x06\x8e\x01\0\x91\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \x8e\x01\x08\x1c\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x8f\x01\x081\n\r\n\
    \x05\x04\x0f\x02\0\x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\
    \x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x8f\x01\
    \x18,\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x8f\x01/0\n\x0c\n\x04\x04\x0f\
    \x02\x01\x12\x04\x90\x01\x08)\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x90\
    \x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x90\x01\x11\x17\n\r\n\
    \x05\x04\x0f\x02\x01\x01\x12\x04\x90\x01\x18$\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\x90\x01'(\n\x0c\n\x02\x04\x10\x12\x06\x93\x01\0\x96\x01\x01\
    \n\x0b\n\x03\x04\x10\x01\x12\x04\x93\x01\x08\x1f\n\x0c\n\x04\x04\x10\x02\
    \0\x12\x04\x94\x01\x08,\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x94\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x94\x01\x11\x17\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\x94\x01\x18'\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \x94\x01*+\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x95\x01\x08,\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\
    \x05\x12\x04\x95\x01\x11\x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x95\
    \x01\x18'\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x95\x01*+\n\x0c\n\x02\
    \x04\x11\x12\x06\x98\x01\0\x9b\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \x98\x01\x08\x1b\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x99\x01\x08,\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\x99\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x99\x01\
    \x18'\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x99\x01*+\n\x0c\n\x04\x04\x11\
    \x02\x01\x12\x04\x9a\x01\x08(\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\x9a\
    \x01\x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\x9a\x01\x11\x17\n\r\n\
    \x05\x04\x11\x02\x01\x01\x12\x04\x9a\x01\x18#\n\r\n\x05\x04\x11\x02\x01\
    \x03\x12\x04\x9a\x01&'\n\x0c\n\x02\x04\x12\x12\x06\x9d\x01\0\xa1\x01\x01\
    \n\x0b\n\x03\x04\x12\x01\x12\x04\x9d\x01\x08\x1c\n\x0c\n\x04\x04\x12\x02\
    \0\x12\x04\x9e\x01\x08&\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\x9e\x01\x08\
    \x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x9e\x01\x11\x17\n\r\n\x05\x04\
    \x12\x02\0\x01\x12\x04\x9e\x01\x18!\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \x9e\x01$%\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\x9f\x01\x08\"\n\r\n\x05\
    \x04\x12\x02\x01\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\x12\x02\x01\
    \x05\x12\x04\x9f\x01\x11\x17\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\x9f\
    \x01\x18\x1d\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x9f\x01\x20!\n\x0c\n\
    \x04\x04\x12\x02\x02\x12\x04\xa0\x01\x08'\n\r\n\x05\x04\x12\x02\x02\x04\
    \x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xa0\x01\
    \x11\x16\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xa0\x01\x17\"\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\xa0\x01%&\n\x0c\n\x02\x04\x13\x12\x06\xa3\
    \x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xa3\x01\x08\x1b\n\x0c\
    \n\x04\x04\x13\x02\0\x12\x04\xa4\x01\x08&\n\r\n\x05\x04\x13\x02\0\x04\
    \x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xa4\x01\x11\
    \x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xa4\x01\x18!\n\r\n\x05\x04\x13\
    \x02\0\x03\x12\x04\xa4\x01$%\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xa5\x01\
    \x08%\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\
    \x04\x13\x02\x01\x05\x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\x13\x02\x01\
    \x01\x12\x04\xa5\x01\x18\x20\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xa5\
    \x01#$\n\x0c\n\x02\x04\x14\x12\x06\xa8\x01\0\xb7\x01\x01\n\x0b\n\x03\x04\
    \x14\x01\x12\x04\xa8\x01\x08\x13\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xa9\
    \x01\x08\x1f\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xa9\x01\x08\x10\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\xa9\x01\x11\x17\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\xa9\x01\x18\x1a\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xa9\x01\
    \x1d\x1e\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xaa\x01\x08'\n\r\n\x05\x04\
    \x14\x02\x01\x04\x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\
    \x12\x04\xaa\x01\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xaa\x01\
    \x18\"\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xaa\x01%&\n\x0c\n\x04\x04\
    \x14\x02\x02\x12\x04\xab\x01\x08&\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\
    \xab\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xab\x01\x11\x17\n\
    \r\n\x05\x04\x14\x02\x02\x01\x12\x04\xab\x01\x18!\n\r\n\x05\x04\x14\x02\
    \x02\x03\x12\x04\xab\x01$%\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xac\x01\
    \x08&\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xac\x01\x08\x10\n\r\n\x05\
    \x04\x14\x02\x03\x05\x12\x04\xac\x01\x11\x17\n\r\n\x05\x04\x14\x02\x03\
    \x01\x12\x04\xac\x01\x18!\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xac\x01$\
    %\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xad\x01\x08%\n\r\n\x05\x04\x14\x02\
    \x04\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\
    \xad\x01\x11\x17\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xad\x01\x18\x20\n\
    \r\n\x05\x04\x14\x02\x04\x03\x12\x04\xad\x01#$\n\x0c\n\x04\x04\x14\x02\
    \x05\x12\x04\xae\x01\x08\"\n\r\n\x05\x04\x14\x02\x05\x04\x12\x04\xae\x01\
    \x08\x10\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\xae\x01\x11\x17\n\r\n\x05\
    \x04\x14\x02\x05\x01\x12\x04\xae\x01\x18\x1d\n\r\n\x05\x04\x14\x02\x05\
    \x03\x12\x04\xae\x01\x20!\n\x0c\n\x04\x04\x14\x02\x06\x12\x04\xaf\x01\
    \x08$\n\r\n\x05\x04\x14\x02\x06\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\
    \x04\x14\x02\x06\x05\x12\x04\xaf\x01\x11\x17\n\r\n\x05\x04\x14\x02\x06\
    \x01\x12\x04\xaf\x01\x18\x1f\n\r\n\x05\x04\x14\x02\x06\x03\x12\x04\xaf\
    \x01\"#\n\x0c\n\x04\x04\x14\x02\x07\x12\x04\xb0\x01\x08\"\n\r\n\x05\x04\
    \x14\x02\x07\x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\x14\x02\x07\x05\
    \x12\x04\xb0\x01\x11\x17\n\r\n\x05\x04\x14\x02\x07\x01\x12\x04\xb0\x01\
    \x18\x1d\n\r\n\x05\x04\x14\x02\x07\x03\x12\x04\xb0\x01\x20!\n\x0c\n\x04\
    \x04\x14\x02\x08\x12\x04\xb1\x01\x08#\n\r\n\x05\x04\x14\x02\x08\x04\x12\
    \x04\xb1\x01\x08\x10\n\r\n\x05\x04\x14\x02\x08\x05\x12\x04\xb1\x01\x11\
    \x17\n\r\n\x05\x04\x14\x02\x08\x01\x12\x04\xb1\x01\x18\x1e\n\r\n\x05\x04\
    \x14\x02\x08\x03\x12\x04\xb1\x01!\"\n\x0c\n\x04\x04\x14\x02\t\x12\x04\
    \xb2\x01\x085\n\r\n\x05\x04\x14\x02\t\x04\x12\x04\xb2\x01\x08\x10\n\r\n\
    \x05\x04\x14\x02\t\x06\x12\x04\xb2\x01\x11%\n\r\n\x05\x04\x14\x02\t\x01\
    \x12\x04\xb2\x01&/\n\r\n\x05\x04\x14\x02\t\x03\x12\x04\xb2\x0124\n\x0c\n\
    \x04\x04\x14\x02\n\x12\x04\xb3\x01\x080\n\r\n\x05\x04\x14\x02\n\x04\x12\
    \x04\xb3\x01\x08\x10\n\r\n\x05\x04\x14\x02\n\x06\x12\x04\xb3\x01\x11\x1c\
    \n\r\n\x05\x04\x14\x02\n\x01\x12\x04\xb3\x01\x1d*\n\r\n\x05\x04\x14\x02\
    \n\x03\x12\x04\xb3\x01-/\n\x0c\n\x04\x04\x14\x02\x0b\x12\x04\xb4\x01\x08\
    #\n\r\n\x05\x04\x14\x02\x0b\x04\x12\x04\xb4\x01\x08\x10\n\r\n\x05\x04\
    \x14\x02\x0b\x05\x12\x04\xb4\x01\x11\x17\n\r\n\x05\x04\x14\x02\x0b\x01\
    \x12\x04\xb4\x01\x18\x1d\n\r\n\x05\x04\x14\x02\x0b\x03\x12\x04\xb4\x01\
    \x20\"\n\x0c\n\x04\x04\x14\x02\x0c\x12\x04\xb5\x01\x08)\n\r\n\x05\x04\
    \x14\x02\x0c\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x14\x02\x0c\x05\
    \x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x14\x02\x0c\x01\x12\x04\xb5\x01\
    \x18#\n\r\n\x05\x04\x14\x02\x0c\x03\x12\x04\xb5\x01&(\n\x0c\n\x04\x04\
    \x14\x02\r\x12\x04\xb6\x01\x089\n\r\n\x05\x04\x14\x02\r\x04\x12\x04\xb6\
    \x01\x08\x10\n\r\n\x05\x04\x14\x02\r\x06\x12\x04\xb6\x01\x11$\n\r\n\x05\
    \x04\x14\x02\r\x01\x12\x04\xb6\x01%3\n\r\n\x05\x04\x14\x02\r\x03\x12\x04\
    \xb6\x0168\n\x0c\n\x02\x04\x15\x12\x06\xb9\x01\0\xbb\x01\x01\n\x0b\n\x03\
    \x04\x15\x01\x12\x04\xb9\x01\x08\x15\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xba\x01\x08&\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xba\x01\x08\x10\n\r\n\
    \x05\x04\x15\x02\0\x05\x12\x04\xba\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xba\x01\x18!\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xba\x01$%\
    \n\x0c\n\x02\x04\x16\x12\x06\xbd\x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x16\
    \x01\x12\x04\xbd\x01\x08\x17\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xbe\x01\
    \x08!\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xbe\x01\x08\x10\n\r\n\x05\x04\
    \x16\x02\0\x05\x12\x04\xbe\x01\x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\
    \x04\xbe\x01\x18\x1c\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xbe\x01\x1f\x20\
    \n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xbf\x01\x08\"\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \xbf\x01\x11\x17\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xbf\x01\x18\x1d\n\
    \r\n\x05\x04\x16\x02\x01\x03\x12\x04\xbf\x01\x20!\n\x0c\n\x02\x04\x17\
    \x12\x06\xc2\x01\0\xc4\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xc2\x01\
    \x08\x1c\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xc3\x01\x08-\n\r\n\x05\x04\
    \x17\x02\0\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x06\x12\
    \x04\xc3\x01\x11\x20\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xc3\x01!(\n\r\n\
    \x05\x04\x17\x02\0\x03\x12\x04\xc3\x01+,\n\x0c\n\x02\x04\x18\x12\x06\xc6\
    \x01\0\xcd\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xc6\x01\x08\x1c\n\x0c\
    \n\x04\x04\x18\x02\0\x12\x04\xc7\x01\x08'\n\r\n\x05\x04\x18\x02\0\x04\
    \x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xc7\x01\x11\
    \x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xc7\x01\x18\"\n\r\n\x05\x04\x18\
    \x02\0\x03\x12\x04\xc7\x01%&\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xc8\x01\
    \x08&\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\
    \x04\x18\x02\x01\x05\x12\x04\xc8\x01\x11\x17\n\r\n\x05\x04\x18\x02\x01\
    \x01\x12\x04\xc8\x01\x18!\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc8\x01$\
    %\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xc9\x01\x08&\n\r\n\x05\x04\x18\x02\
    \x02\x04\x12\x04\xc9\x01\x08\x10\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\
    \xc9\x01\x11\x17\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xc9\x01\x18!\n\r\
    \n\x05\x04\x18\x02\x02\x03\x12\x04\xc9\x01$%\n\x0c\n\x04\x04\x18\x02\x03\
    \x12\x04\xca\x01\x08$\n\r\n\x05\x04\x18\x02\x03\x04\x12\x04\xca\x01\x08\
    \x10\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xca\x01\x11\x17\n\r\n\x05\x04\
    \x18\x02\x03\x01\x12\x04\xca\x01\x18\x1f\n\r\n\x05\x04\x18\x02\x03\x03\
    \x12\x04\xca\x01\"#\n\x0c\n\x04\x04\x18\x02\x04\x12\x04\xcb\x01\x08#\n\r\
    \n\x05\x04\x18\x02\x04\x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\x18\x02\
    \x04\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\
    \xcb\x01\x18\x1e\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xcb\x01!\"\n\x0c\
    \n\x04\x04\x18\x02\x05\x12\x04\xcc\x01\x08#\n\r\n\x05\x04\x18\x02\x05\
    \x04\x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x18\x02\x05\x05\x12\x04\xcc\
    \x01\x11\x17\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xcc\x01\x18\x1e\n\r\n\
    \x05\x04\x18\x02\x05\x03\x12\x04\xcc\x01!\"\n\x0c\n\x02\x04\x19\x12\x06\
    \xcf\x01\0\xd6\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xcf\x01\x08\x1c\n\
    \x0e\n\x04\x04\x19\x03\0\x12\x06\xd0\x01\x08\xd3\x01\t\n\r\n\x05\x04\x19\
    \x03\0\x01\x12\x04\xd0\x01\x10\x1c\n\x0e\n\x06\x04\x19\x03\0\x02\0\x12\
    \x04\xd1\x01\x10,\n\x0f\n\x07\x04\x19\x03\0\x02\0\x04\x12\x04\xd1\x01\
    \x10\x18\n\x0f\n\x07\x04\x19\x03\0\x02\0\x05\x12\x04\xd1\x01\x19\x1f\n\
    \x0f\n\x07\x04\x19\x03\0\x02\0\x01\x12\x04\xd1\x01\x20'\n\x0f\n\x07\x04\
    \x19\x03\0\x02\0\x03\x12\x04\xd1\x01*+\n\x0e\n\x06\x04\x19\x03\0\x02\x01\
    \x12\x04\xd2\x01\x10-\n\x0f\n\x07\x04\x19\x03\0\x02\x01\x04\x12\x04\xd2\
    \x01\x10\x18\n\x0f\n\x07\x04\x19\x03\0\x02\x01\x05\x12\x04\xd2\x01\x19\
    \x1f\n\x0f\n\x07\x04\x19\x03\0\x02\x01\x01\x12\x04\xd2\x01\x20(\n\x0f\n\
    \x07\x04\x19\x03\0\x02\x01\x03\x12\x04\xd2\x01+,\n\x0c\n\x04\x04\x19\x02\
    \0\x12\x04\xd5\x01\x08F\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xd5\x01\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xd5\x01\x112\n\r\n\x05\x04\x19\
    \x02\0\x01\x12\x04\xd5\x013A\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xd5\x01\
    DE\n\x0c\n\x02\x04\x1a\x12\x06\xd8\x01\0\xda\x01\x01\n\x0b\n\x03\x04\x1a\
    \x01\x12\x04\xd8\x01\x08!\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xd9\x01\x08#\
    \n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\x04\x1a\
    \x02\0\x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\
    \xd9\x01\x18\x1e\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd9\x01!\"\n\x0c\n\
    \x02\x04\x1b\x12\x06\xdc\x01\0\xde\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xdc\x01\x08)\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xdd\x01\x08#\n\r\n\
    \x05\x04\x1b\x02\0\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\xdd\x01\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xdd\x01\
    \x18\x1e\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xdd\x01!\"\n\x0c\n\x02\x04\
    \x1c\x12\x06\xe0\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xe0\
    \x01\x08#\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xe1\x01\x08#\n\r\n\x05\x04\
    \x1c\x02\0\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\
    \x04\xe1\x01\x11\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xe1\x01\x18\x1e\
    \n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xe1\x01!\"\n\x0c\n\x02\x04\x1d\x12\
    \x06\xe4\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xe4\x01\x08+\
    \n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xe5\x01\x08#\n\r\n\x05\x04\x1d\x02\0\
    \x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xe5\x01\
    \x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xe5\x01\x18\x1e\n\r\n\x05\
    \x04\x1d\x02\0\x03\x12\x04\xe5\x01!\"\n\x0c\n\x04\x04\x1d\x02\x01\x12\
    \x04\xe6\x01\x08%\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xe6\x01\x08\x10\
    \n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xe6\x01\x11\x17\n\r\n\x05\x04\x1d\
    \x02\x01\x01\x12\x04\xe6\x01\x18\x20\n\r\n\x05\x04\x1d\x02\x01\x03\x12\
    \x04\xe6\x01#$\n\x0c\n\x02\x04\x1e\x12\x06\xe9\x01\0\xeb\x01\x01\n\x0b\n\
    \x03\x04\x1e\x01\x12\x04\xe9\x01\x08'\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\
    \xea\x01\x08%\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xea\x01\x08\x10\n\r\n\
    \x05\x04\x1e\x02\0\x05\x12\x04\xea\x01\x11\x17\n\r\n\x05\x04\x1e\x02\0\
    \x01\x12\x04\xea\x01\x18\x20\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xea\x01\
    #$\n\x0c\n\x02\x04\x1f\x12\x06\xed\x01\0\xf0\x01\x01\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\xed\x01\x08\x1f\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xee\x01\
    \x08%\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\xee\x01\x08\x10\n\r\n\x05\x04\
    \x1f\x02\0\x05\x12\x04\xee\x01\x11\x17\n\r\n\x05\x04\x1f\x02\0\x01\x12\
    \x04\xee\x01\x18\x20\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xee\x01#$\n\x0c\
    \n\x04\x04\x1f\x02\x01\x12\x04\xef\x01\x08'\n\r\n\x05\x04\x1f\x02\x01\
    \x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xef\
    \x01\x11\x17\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xef\x01\x18\"\n\r\n\
    \x05\x04\x1f\x02\x01\x03\x12\x04\xef\x01%&\n\x0c\n\x02\x04\x20\x12\x06\
    \xf2\x01\0\xf3\x01\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xf2\x01\x08\x1a\n\
    \x0c\n\x02\x04!\x12\x06\xf5\x01\0\xf7\x01\x01\n\x0b\n\x03\x04!\x01\x12\
    \x04\xf5\x01\x08#\n\x0c\n\x04\x04!\x02\0\x12\x04\xf6\x01\x08%\n\r\n\x05\
    \x04!\x02\0\x04\x12\x04\xf6\x01\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\
    \xf6\x01\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\xf6\x01\x18\x20\n\r\n\
    \x05\x04!\x02\0\x03\x12\x04\xf6\x01#$\n\x0c\n\x02\x04\"\x12\x06\xf9\x01\
    \0\xfb\x01\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xf9\x01\x08\"\n\x0c\n\x04\
    \x04\"\x02\0\x12\x04\xfa\x01\x08+\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xfa\
    \x01\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xfa\x01\x11\x17\n\r\n\x05\
    \x04\"\x02\0\x01\x12\x04\xfa\x01\x18&\n\r\n\x05\x04\"\x02\0\x03\x12\x04\
    \xfa\x01)*\n\x0c\n\x02\x04#\x12\x06\xfd\x01\0\xff\x01\x01\n\x0b\n\x03\
    \x04#\x01\x12\x04\xfd\x01\x08\"\n\x0c\n\x04\x04#\x02\0\x12\x04\xfe\x01\
    \x08+\n\r\n\x05\x04#\x02\0\x04\x12\x04\xfe\x01\x08\x10\n\r\n\x05\x04#\
    \x02\0\x05\x12\x04\xfe\x01\x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\xfe\
    \x01\x18&\n\r\n\x05\x04#\x02\0\x03\x12\x04\xfe\x01)*\n\x0c\n\x02\x04$\
    \x12\x06\x81\x02\0\x82\x02\x01\n\x0b\n\x03\x04$\x01\x12\x04\x81\x02\x08&\
    \n\x0c\n\x02\x04%\x12\x06\x84\x02\0\x88\x02\x01\n\x0b\n\x03\x04%\x01\x12\
    \x04\x84\x02\x08\x17\n\x0c\n\x04\x04%\x02\0\x12\x04\x85\x02\x08)\n\r\n\
    \x05\x04%\x02\0\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\
    \x04\x85\x02\x11\x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\x85\x02\x18$\n\r\n\
    \x05\x04%\x02\0\x03\x12\x04\x85\x02'(\n\x0c\n\x04\x04%\x02\x01\x12\x04\
    \x86\x02\x08)\n\r\n\x05\x04%\x02\x01\x04\x12\x04\x86\x02\x08\x10\n\r\n\
    \x05\x04%\x02\x01\x05\x12\x04\x86\x02\x11\x17\n\r\n\x05\x04%\x02\x01\x01\
    \x12\x04\x86\x02\x18$\n\r\n\x05\x04%\x02\x01\x03\x12\x04\x86\x02'(\n\x0c\
    \n\x04\x04%\x02\x02\x12\x04\x87\x02\x08+\n\r\n\x05\x04%\x02\x02\x04\x12\
    \x04\x87\x02\x08\x10\n\r\n\x05\x04%\x02\x02\x05\x12\x04\x87\x02\x11\x17\
    \n\r\n\x05\x04%\x02\x02\x01\x12\x04\x87\x02\x18&\n\r\n\x05\x04%\x02\x02\
    \x03\x12\x04\x87\x02)*\n\x0c\n\x02\x04&\x12\x06\x8a\x02\0\x95\x02\x01\n\
    \x0b\n\x03\x04&\x01\x12\x04\x8a\x02\x08\x1f\n\x0e\n\x04\x04&\x04\0\x12\
    \x06\x8b\x02\x08\x91\x02\t\n\r\n\x05\x04&\x04\0\x01\x12\x04\x8b\x02\r\
    \x19\n\x0e\n\x06\x04&\x04\0\x02\0\x12\x04\x8c\x02\x10,\n\x0f\n\x07\x04&\
    \x04\0\x02\0\x01\x12\x04\x8c\x02\x10'\n\x0f\n\x07\x04&\x04\0\x02\0\x02\
    \x12\x04\x8c\x02*+\n\x0e\n\x06\x04&\x04\0\x02\x01\x12\x04\x8d\x02\x107\n\
    \x0f\n\x07\x04&\x04\0\x02\x01\x01\x12\x04\x8d\x02\x102\n\x0f\n\x07\x04&\
    \x04\0\x02\x01\x02\x12\x04\x8d\x0256\n\x0e\n\x06\x04&\x04\0\x02\x02\x12\
    \x04\x8e\x02\x107\n\x0f\n\x07\x04&\x04\0\x02\x02\x01\x12\x04\x8e\x02\x10\
    2\n\x0f\n\x07\x04&\x04\0\x02\x02\x02\x12\x04\x8e\x0256\n\x0e\n\x06\x04&\
    \x04\0\x02\x03\x12\x04\x8f\x02\x10=\n\x0f\n\x07\x04&\x04\0\x02\x03\x01\
    \x12\x04\x8f\x02\x108\n\x0f\n\x07\x04&\x04\0\x02\x03\x02\x12\x04\x8f\x02\
    ;<\n\x0e\n\x06\x04&\x04\0\x02\x04\x12\x04\x90\x02\x10;\n\x0f\n\x07\x04&\
    \x04\0\x02\x04\x01\x12\x04\x90\x02\x106\n\x0f\n\x07\x04&\x04\0\x02\x04\
    \x02\x12\x04\x90\x029:\n\x0c\n\x04\x04&\x02\0\x12\x04\x93\x02\x08$\n\r\n\
    \x05\x04&\x02\0\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\
    \x04\x93\x02\x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\x04\x93\x02\x18\x1f\n\
    \r\n\x05\x04&\x02\0\x03\x12\x04\x93\x02\"#\n\x0c\n\x04\x04&\x02\x01\x12\
    \x04\x94\x02\x08C\n\r\n\x05\x04&\x02\x01\x04\x12\x04\x94\x02\x08\x10\n\r\
    \n\x05\x04&\x02\x01\x06\x12\x04\x94\x02\x115\n\r\n\x05\x04&\x02\x01\x01\
    \x12\x04\x94\x026>\n\r\n\x05\x04&\x02\x01\x03\x12\x04\x94\x02AB\n\x0c\n\
    \x02\x04'\x12\x06\x97\x02\0\x9b\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\x97\
    \x02\x08\x15\n\x0c\n\x04\x04'\x02\0\x12\x04\x98\x02\x08)\n\r\n\x05\x04'\
    \x02\0\x04\x12\x04\x98\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\x98\
    \x02\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\x98\x02\x18$\n\r\n\x05\x04\
    '\x02\0\x03\x12\x04\x98\x02'(\n\x0c\n\x04\x04'\x02\x01\x12\x04\x99\x02\
    \x08)\n\r\n\x05\x04'\x02\x01\x04\x12\x04\x99\x02\x08\x10\n\r\n\x05\x04'\
    \x02\x01\x05\x12\x04\x99\x02\x11\x17\n\r\n\x05\x04'\x02\x01\x01\x12\x04\
    \x99\x02\x18$\n\r\n\x05\x04'\x02\x01\x03\x12\x04\x99\x02'(\n\x0c\n\x04\
    \x04'\x02\x02\x12\x04\x9a\x02\x08\"\n\r\n\x05\x04'\x02\x02\x04\x12\x04\
    \x9a\x02\x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\x9a\x02\x11\x15\n\r\
    \n\x05\x04'\x02\x02\x01\x12\x04\x9a\x02\x16\x1d\n\r\n\x05\x04'\x02\x02\
    \x03\x12\x04\x9a\x02\x20!\n\x0c\n\x02\x04(\x12\x06\x9d\x02\0\xa8\x02\x01\
    \n\x0b\n\x03\x04(\x01\x12\x04\x9d\x02\x08\x1d\n\x0e\n\x04\x04(\x04\0\x12\
    \x06\x9e\x02\x08\xa3\x02\t\n\r\n\x05\x04(\x04\0\x01\x12\x04\x9e\x02\r\
    \x17\n\x0e\n\x06\x04(\x04\0\x02\0\x12\x04\x9f\x02\x10*\n\x0f\n\x07\x04(\
    \x04\0\x02\0\x01\x12\x04\x9f\x02\x10%\n\x0f\n\x07\x04(\x04\0\x02\0\x02\
    \x12\x04\x9f\x02()\n\x0e\n\x06\x04(\x04\0\x02\x01\x12\x04\xa0\x02\x105\n\
    \x0f\n\x07\x04(\x04\0\x02\x01\x01\x12\x04\xa0\x02\x100\n\x0f\n\x07\x04(\
    \x04\0\x02\x01\x02\x12\x04\xa0\x0234\n\x0e\n\x06\x04(\x04\0\x02\x02\x12\
    \x04\xa1\x02\x10<\n\x0f\n\x07\x04(\x04\0\x02\x02\x01\x12\x04\xa1\x02\x10\
    7\n\x0f\n\x07\x04(\x04\0\x02\x02\x02\x12\x04\xa1\x02:;\n\x0e\n\x06\x04(\
    \x04\0\x02\x03\x12\x04\xa2\x02\x109\n\x0f\n\x07\x04(\x04\0\x02\x03\x01\
    \x12\x04\xa2\x02\x104\n\x0f\n\x07\x04(\x04\0\x02\x03\x02\x12\x04\xa2\x02\
    78\n\x0c\n\x04\x04(\x02\0\x12\x04\xa5\x02\x08$\n\r\n\x05\x04(\x02\0\x04\
    \x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xa5\x02\x11\
    \x17\n\r\n\x05\x04(\x02\0\x01\x12\x04\xa5\x02\x18\x1f\n\r\n\x05\x04(\x02\
    \0\x03\x12\x04\xa5\x02\"#\n\x0c\n\x04\x04(\x02\x01\x12\x04\xa6\x02\x081\
    \n\r\n\x05\x04(\x02\x01\x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04(\x02\
    \x01\x05\x12\x04\xa6\x02\x11\x17\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xa6\
    \x02\x18,\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xa6\x02/0\n\x0c\n\x04\x04(\
    \x02\x02\x12\x04\xa7\x02\x08?\n\r\n\x05\x04(\x02\x02\x04\x12\x04\xa7\x02\
    \x08\x10\n\r\n\x05\x04(\x02\x02\x06\x12\x04\xa7\x02\x111\n\r\n\x05\x04(\
    \x02\x02\x01\x12\x04\xa7\x022:\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xa7\
    \x02=>\n\x0c\n\x02\x04)\x12\x06\xaa\x02\0\xad\x02\x01\n\x0b\n\x03\x04)\
    \x01\x12\x04\xaa\x02\x08\x1f\n\x0c\n\x04\x04)\x02\0\x12\x04\xab\x02\x08(\
    \n\r\n\x05\x04)\x02\0\x04\x12\x04\xab\x02\x08\x10\n\r\n\x05\x04)\x02\0\
    \x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\x04\xab\x02\
    \x18#\n\r\n\x05\x04)\x02\0\x03\x12\x04\xab\x02&'\n\x0c\n\x04\x04)\x02\
    \x01\x12\x04\xac\x02\x08)\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xac\x02\x08\
    \x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xac\x02\x11\x17\n\r\n\x05\x04)\
    \x02\x01\x01\x12\x04\xac\x02\x18$\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xac\
    \x02'(\n\x0c\n\x02\x04*\x12\x06\xaf\x02\0\xb2\x02\x01\n\x0b\n\x03\x04*\
    \x01\x12\x04\xaf\x02\x08\x1b\n\x0c\n\x04\x04*\x02\0\x12\x04\xb0\x02\x08)\
    \n\r\n\x05\x04*\x02\0\x04\x12\x04\xb0\x02\x08\x10\n\r\n\x05\x04*\x02\0\
    \x05\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xb0\x02\
    \x18$\n\r\n\x05\x04*\x02\0\x03\x12\x04\xb0\x02'(\n\x0c\n\x04\x04*\x02\
    \x01\x12\x04\xb1\x02\x08<\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xb1\x02\x08\
    \x10\n\r\n\x05\x04*\x02\x01\x06\x12\x04\xb1\x02\x11(\n\r\n\x05\x04*\x02\
    \x01\x01\x12\x04\xb1\x02)7\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xb1\x02:;\
    \n\x0c\n\x02\x04+\x12\x06\xb4\x02\0\xc3\x02\x01\n\x0b\n\x03\x04+\x01\x12\
    \x04\xb4\x02\x08#\n\x0e\n\x04\x04+\x04\0\x12\x06\xb5\x02\x08\xbe\x02\t\n\
    \r\n\x05\x04+\x04\0\x01\x12\x04\xb5\x02\r\x14\n\x0e\n\x06\x04+\x04\0\x02\
    \0\x12\x04\xb6\x02\x10'\n\x0f\n\x07\x04+\x04\0\x02\0\x01\x12\x04\xb6\x02\
    \x10\"\n\x0f\n\x07\x04+\x04\0\x02\0\x02\x12\x04\xb6\x02%&\n\x0e\n\x06\
    \x04+\x04\0\x02\x01\x12\x04\xb7\x02\x101\n\x0f\n\x07\x04+\x04\0\x02\x01\
    \x01\x12\x04\xb7\x02\x10,\n\x0f\n\x07\x04+\x04\0\x02\x01\x02\x12\x04\xb7\
    \x02/0\n\x0e\n\x06\x04+\x04\0\x02\x02\x12\x04\xb8\x02\x102\n\x0f\n\x07\
    \x04+\x04\0\x02\x02\x01\x12\x04\xb8\x02\x10-\n\x0f\n\x07\x04+\x04\0\x02\
    \x02\x02\x12\x04\xb8\x0201\n\x0e\n\x06\x04+\x04\0\x02\x03\x12\x04\xb9\
    \x02\x103\n\x0f\n\x07\x04+\x04\0\x02\x03\x01\x12\x04\xb9\x02\x10.\n\x0f\
    \n\x07\x04+\x04\0\x02\x03\x02\x12\x04\xb9\x0212\n\x0e\n\x06\x04+\x04\0\
    \x02\x04\x12\x04\xba\x02\x10<\n\x0f\n\x07\x04+\x04\0\x02\x04\x01\x12\x04\
    \xba\x02\x107\n\x0f\n\x07\x04+\x04\0\x02\x04\x02\x12\x04\xba\x02:;\n\x0e\
    \n\x06\x04+\x04\0\x02\x05\x12\x04\xbb\x02\x10:\n\x0f\n\x07\x04+\x04\0\
    \x02\x05\x01\x12\x04\xbb\x02\x105\n\x0f\n\x07\x04+\x04\0\x02\x05\x02\x12\
    \x04\xbb\x0289\n\x0e\n\x06\x04+\x04\0\x02\x06\x12\x04\xbc\x02\x10:\n\x0f\
    \n\x07\x04+\x04\0\x02\x06\x01\x12\x04\xbc\x02\x105\n\x0f\n\x07\x04+\x04\
    \0\x02\x06\x02\x12\x04\xbc\x0289\n\x0e\n\x06\x04+\x04\0\x02\x07\x12\x04\
    \xbd\x02\x10A\n\x0f\n\x07\x04+\x04\0\x02\x07\x01\x12\x04\xbd\x02\x10<\n\
    \x0f\n\x07\x04+\x04\0\x02\x07\x02\x12\x04\xbd\x02?@\n\x0c\n\x04\x04+\x02\
    \0\x12\x04\xc0\x02\x08)\n\r\n\x05\x04+\x02\0\x04\x12\x04\xc0\x02\x08\x10\
    \n\r\n\x05\x04+\x02\0\x05\x12\x04\xc0\x02\x11\x17\n\r\n\x05\x04+\x02\0\
    \x01\x12\x04\xc0\x02\x18$\n\r\n\x05\x04+\x02\0\x03\x12\x04\xc0\x02'(\n\
    \x0c\n\x04\x04+\x02\x01\x12\x04\xc1\x02\x081\n\r\n\x05\x04+\x02\x01\x04\
    \x12\x04\xc1\x02\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xc1\x02\x11\
    \x17\n\r\n\x05\x04+\x02\x01\x01\x12\x04\xc1\x02\x18,\n\r\n\x05\x04+\x02\
    \x01\x03\x12\x04\xc1\x02/0\n\x0c\n\x04\x04+\x02\x02\x12\x04\xc2\x02\x08B\
    \n\r\n\x05\x04+\x02\x02\x04\x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04+\x02\
    \x02\x06\x12\x04\xc2\x02\x114\n\r\n\x05\x04+\x02\x02\x01\x12\x04\xc2\x02\
    5=\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xc2\x02@A\n\x0c\n\x02\x04,\x12\x06\
    \xc5\x02\0\xc8\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xc5\x02\x08\x20\n\
    \x0c\n\x04\x04,\x02\0\x12\x04\xc6\x02\x08)\n\r\n\x05\x04,\x02\0\x04\x12\
    \x04\xc6\x02\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\xc6\x02\x11\x17\n\
    \r\n\x05\x04,\x02\0\x01\x12\x04\xc6\x02\x18$\n\r\n\x05\x04,\x02\0\x03\
    \x12\x04\xc6\x02'(\n\x0c\n\x04\x04,\x02\x01\x12\x04\xc7\x02\x08)\n\r\n\
    \x05\x04,\x02\x01\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04,\x02\x01\x05\
    \x12\x04\xc7\x02\x11\x17\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xc7\x02\x18$\
    \n\r\n\x05\x04,\x02\x01\x03\x12\x04\xc7\x02'(\n\x0c\n\x02\x04-\x12\x06\
    \xca\x02\0\xd4\x02\x01\n\x0b\n\x03\x04-\x01\x12\x04\xca\x02\x08(\n\x0e\n\
    \x04\x04-\x04\0\x12\x06\xcb\x02\x08\xd1\x02\t\n\r\n\x05\x04-\x04\0\x01\
    \x12\x04\xcb\x02\r\x16\n\x0e\n\x06\x04-\x04\0\x02\0\x12\x04\xcc\x02\x10)\
    \n\x0f\n\x07\x04-\x04\0\x02\0\x01\x12\x04\xcc\x02\x10$\n\x0f\n\x07\x04-\
    \x04\0\x02\0\x02\x12\x04\xcc\x02'(\n\x0e\n\x06\x04-\x04\0\x02\x01\x12\
    \x04\xcd\x02\x107\n\x0f\n\x07\x04-\x04\0\x02\x01\x01\x12\x04\xcd\x02\x10\
    2\n\x0f\n\x07\x04-\x04\0\x02\x01\x02\x12\x04\xcd\x0256\n\x0e\n\x06\x04-\
    \x04\0\x02\x02\x12\x04\xce\x02\x104\n\x0f\n\x07\x04-\x04\0\x02\x02\x01\
    \x12\x04\xce\x02\x10/\n\x0f\n\x07\x04-\x04\0\x02\x02\x02\x12\x04\xce\x02\
    23\n\x0e\n\x06\x04-\x04\0\x02\x03\x12\x04\xcf\x02\x106\n\x0f\n\x07\x04-\
    \x04\0\x02\x03\x01\x12\x04\xcf\x02\x101\n\x0f\n\x07\x04-\x04\0\x02\x03\
    \x02\x12\x04\xcf\x0245\n\x0e\n\x06\x04-\x04\0\x02\x04\x12\x04\xd0\x02\
    \x10:\n\x0f\n\x07\x04-\x04\0\x02\x04\x01\x12\x04\xd0\x02\x105\n\x0f\n\
    \x07\x04-\x04\0\x02\x04\x02\x12\x04\xd0\x0289\n\x0c\n\x04\x04-\x02\0\x12\
    \x04\xd3\x02\x08I\n\r\n\x05\x04-\x02\0\x04\x12\x04\xd3\x02\x08\x10\n\r\n\
    \x05\x04-\x02\0\x06\x12\x04\xd3\x02\x11;\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\xd3\x02<D\n\r\n\x05\x04-\x02\0\x03\x12\x04\xd3\x02GH\n\x0c\n\x02\
    \x04.\x12\x06\xd6\x02\0\xda\x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\xd6\x02\
    \x08%\n\x0c\n\x04\x04.\x02\0\x12\x04\xd7\x02\x08&\n\r\n\x05\x04.\x02\0\
    \x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\xd7\x02\
    \x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xd7\x02\x18!\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\xd7\x02$%\n\x0c\n\x04\x04.\x02\x01\x12\x04\xd8\x02\
    \x08+\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04.\
    \x02\x01\x05\x12\x04\xd8\x02\x11\x17\n\r\n\x05\x04.\x02\x01\x01\x12\x04\
    \xd8\x02\x18&\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xd8\x02)*\n\x0c\n\x04\
    \x04.\x02\x02\x12\x04\xd9\x02\x08$\n\r\n\x05\x04.\x02\x02\x04\x12\x04\
    \xd9\x02\x08\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xd9\x02\x11\x17\n\r\
    \n\x05\x04.\x02\x02\x01\x12\x04\xd9\x02\x18\x1f\n\r\n\x05\x04.\x02\x02\
    \x03\x12\x04\xd9\x02\"#\n\x0c\n\x02\x04/\x12\x06\xdc\x02\0\xe0\x02\x01\n\
    \x0b\n\x03\x04/\x01\x12\x04\xdc\x02\x08&\n\x0c\n\x04\x04/\x02\0\x12\x04\
    \xdd\x02\x08$\n\r\n\x05\x04/\x02\0\x04\x12\x04\xdd\x02\x08\x10\n\r\n\x05\
    \x04/\x02\0\x05\x12\x04\xdd\x02\x11\x17\n\r\n\x05\x04/\x02\0\x01\x12\x04\
    \xdd\x02\x18\x1f\n\r\n\x05\x04/\x02\0\x03\x12\x04\xdd\x02\"#\n\x0c\n\x04\
    \x04/\x02\x01\x12\x04\xde\x02\x08&\n\r\n\x05\x04/\x02\x01\x04\x12\x04\
    \xde\x02\x08\x10\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xde\x02\x11\x17\n\r\
    \n\x05\x04/\x02\x01\x01\x12\x04\xde\x02\x18!\n\r\n\x05\x04/\x02\x01\x03\
    \x12\x04\xde\x02$%\n\x0c\n\x04\x04/\x02\x02\x12\x04\xdf\x02\x08%\n\r\n\
    \x05\x04/\x02\x02\x04\x12\x04\xdf\x02\x08\x10\n\r\n\x05\x04/\x02\x02\x05\
    \x12\x04\xdf\x02\x11\x17\n\r\n\x05\x04/\x02\x02\x01\x12\x04\xdf\x02\x18\
    \x20\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xdf\x02#$\n\x0c\n\x02\x040\x12\
    \x06\xe2\x02\0\xe5\x02\x01\n\x0b\n\x03\x040\x01\x12\x04\xe2\x02\x08!\n\
    \x0c\n\x04\x040\x02\0\x12\x04\xe3\x02\x08\"\n\r\n\x05\x040\x02\0\x04\x12\
    \x04\xe3\x02\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\xe3\x02\x11\x17\n\
    \r\n\x05\x040\x02\0\x01\x12\x04\xe3\x02\x18\x1d\n\r\n\x05\x040\x02\0\x03\
    \x12\x04\xe3\x02\x20!\n\x0c\n\x04\x040\x02\x01\x12\x04\xe4\x02\x08'\n\r\
    \n\x05\x040\x02\x01\x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x040\x02\x01\
    \x05\x12\x04\xe4\x02\x11\x17\n\r\n\x05\x040\x02\x01\x01\x12\x04\xe4\x02\
    \x18\"\n\r\n\x05\x040\x02\x01\x03\x12\x04\xe4\x02%&\n\x0c\n\x02\x041\x12\
    \x06\xe7\x02\0\xea\x02\x01\n\x0b\n\x03\x041\x01\x12\x04\xe7\x02\x08*\n\
    \x0c\n\x04\x041\x02\0\x12\x04\xe8\x02\x08\"\n\r\n\x05\x041\x02\0\x04\x12\
    \x04\xe8\x02\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xe8\x02\x11\x15\n\
    \r\n\x05\x041\x02\0\x01\x12\x04\xe8\x02\x16\x1d\n\r\n\x05\x041\x02\0\x03\
    \x12\x04\xe8\x02\x20!\n\x0c\n\x04\x041\x02\x01\x12\x04\xe9\x02\x08%\n\r\
    \n\x05\x041\x02\x01\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\x041\x02\x01\
    \x05\x12\x04\xe9\x02\x11\x16\n\r\n\x05\x041\x02\x01\x01\x12\x04\xe9\x02\
    \x17\x20\n\r\n\x05\x041\x02\x01\x03\x12\x04\xe9\x02#$\n\x0c\n\x02\x042\
    \x12\x06\xec\x02\0\xed\x02\x01\n\x0b\n\x03\x042\x01\x12\x04\xec\x02\x08,\
    \n\x0c\n\x02\x043\x12\x06\xef\x02\0\xf1\x02\x01\n\x0b\n\x03\x043\x01\x12\
    \x04\xef\x02\x08&\n\x0c\n\x04\x043\x02\0\x12\x04\xf0\x02\x085\n\r\n\x05\
    \x043\x02\0\x04\x12\x04\xf0\x02\x08\x10\n\r\n\x05\x043\x02\0\x06\x12\x04\
    \xf0\x02\x11\x1f\n\r\n\x05\x043\x02\0\x01\x12\x04\xf0\x02\x200\n\r\n\x05\
    \x043\x02\0\x03\x12\x04\xf0\x0234\n\x0c\n\x02\x044\x12\x06\xf3\x02\0\xfd\
    \x02\x01\n\x0b\n\x03\x044\x01\x12\x04\xf3\x02\x08\x1e\n\x0e\n\x04\x044\
    \x03\0\x12\x06\xf4\x02\x08\xfa\x02\t\n\r\n\x05\x044\x03\0\x01\x12\x04\
    \xf4\x02\x10\x16\n\x0e\n\x06\x044\x03\0\x02\0\x12\x04\xf5\x02\x10)\n\x0f\
    \n\x07\x044\x03\0\x02\0\x04\x12\x04\xf5\x02\x10\x18\n\x0f\n\x07\x044\x03\
    \0\x02\0\x05\x12\x04\xf5\x02\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\0\x01\
    \x12\x04\xf5\x02\x20$\n\x0f\n\x07\x044\x03\0\x02\0\x03\x12\x04\xf5\x02'(\
    \n\x0e\n\x06\x044\x03\0\x02\x01\x12\x04\xf6\x02\x10*\n\x0f\n\x07\x044\
    \x03\0\x02\x01\x04\x12\x04\xf6\x02\x10\x18\n\x0f\n\x07\x044\x03\0\x02\
    \x01\x05\x12\x04\xf6\x02\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\x01\x01\x12\
    \x04\xf6\x02\x20%\n\x0f\n\x07\x044\x03\0\x02\x01\x03\x12\x04\xf6\x02()\n\
    \x0e\n\x06\x044\x03\0\x02\x02\x12\x04\xf7\x02\x100\n\x0f\n\x07\x044\x03\
    \0\x02\x02\x04\x12\x04\xf7\x02\x10\x18\n\x0f\n\x07\x044\x03\0\x02\x02\
    \x05\x12\x04\xf7\x02\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\x02\x01\x12\x04\
    \xf7\x02\x20+\n\x0f\n\x07\x044\x03\0\x02\x02\x03\x12\x04\xf7\x02./\n\x0e\
    \n\x06\x044\x03\0\x02\x03\x12\x04\xf8\x02\x100\n\x0f\n\x07\x044\x03\0\
    \x02\x03\x04\x12\x04\xf8\x02\x10\x18\n\x0f\n\x07\x044\x03\0\x02\x03\x05\
    \x12\x04\xf8\x02\x19\x1f\n\x0f\n\x07\x044\x03\0\x02\x03\x01\x12\x04\xf8\
    \x02\x20+\n\x0f\n\x07\x044\x03\0\x02\x03\x03\x12\x04\xf8\x02./\n\x0e\n\
    \x06\x044\x03\0\x02\x04\x12\x04\xf9\x02\x102\n\x0f\n\x07\x044\x03\0\x02\
    \x04\x04\x12\x04\xf9\x02\x10\x18\n\x0f\n\x07\x044\x03\0\x02\x04\x06\x12\
    \x04\xf9\x02\x19$\n\x0f\n\x07\x044\x03\0\x02\x04\x01\x12\x04\xf9\x02%-\n\
    \x0f\n\x07\x044\x03\0\x02\x04\x03\x12\x04\xf9\x0201\n\x0c\n\x04\x044\x02\
    \0\x12\x04\xfc\x02\x08<\n\r\n\x05\x044\x02\0\x04\x12\x04\xfc\x02\x08\x10\
    \n\r\n\x05\x044\x02\0\x06\x12\x04\xfc\x02\x11.\n\r\n\x05\x044\x02\0\x01\
    \x12\x04\xfc\x02/7\n\r\n\x05\x044\x02\0\x03\x12\x04\xfc\x02:;\n\x0c\n\
    \x02\x045\x12\x06\xff\x02\0\x81\x03\x01\n\x0b\n\x03\x045\x01\x12\x04\xff\
    \x02\x08(\n\x0c\n\x04\x045\x02\0\x12\x04\x80\x03\x080\n\r\n\x05\x045\x02\
    \0\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\x045\x02\0\x06\x12\x04\x80\x03\
    \x11'\n\r\n\x05\x045\x02\0\x01\x12\x04\x80\x03(+\n\r\n\x05\x045\x02\0\
    \x03\x12\x04\x80\x03./\n\x0c\n\x02\x046\x12\x06\x83\x03\0\x85\x03\x01\n\
    \x0b\n\x03\x046\x01\x12\x04\x83\x03\x08(\n\x0c\n\x04\x046\x02\0\x12\x04\
    \x84\x03\x080\n\r\n\x05\x046\x02\0\x04\x12\x04\x84\x03\x08\x10\n\r\n\x05\
    \x046\x02\0\x06\x12\x04\x84\x03\x11'\n\r\n\x05\x046\x02\0\x01\x12\x04\
    \x84\x03(+\n\r\n\x05\x046\x02\0\x03\x12\x04\x84\x03./\n\x0c\n\x02\x047\
    \x12\x06\x87\x03\0\x92\x03\x01\n\x0b\n\x03\x047\x01\x12\x04\x87\x03\x08%\
    \n\x0e\n\x04\x047\x03\0\x12\x06\x88\x03\x08\x8d\x03\t\n\r\n\x05\x047\x03\
    \0\x01\x12\x04\x88\x03\x10\x18\n\x0e\n\x06\x047\x03\0\x02\0\x12\x04\x89\
    \x03\x10'\n\x0f\n\x07\x047\x03\0\x02\0\x04\x12\x04\x89\x03\x10\x18\n\x0f\
    \n\x07\x047\x03\0\x02\0\x05\x12\x04\x89\x03\x19\x1f\n\x0f\n\x07\x047\x03\
    \0\x02\0\x01\x12\x04\x89\x03\x20\"\n\x0f\n\x07\x047\x03\0\x02\0\x03\x12\
    \x04\x89\x03%&\n\x0e\n\x06\x047\x03\0\x02\x01\x12\x04\x8a\x03\x10-\n\x0f\
    \n\x07\x047\x03\0\x02\x01\x04\x12\x04\x8a\x03\x10\x18\n\x0f\n\x07\x047\
    \x03\0\x02\x01\x05\x12\x04\x8a\x03\x19\x1f\n\x0f\n\x07\x047\x03\0\x02\
    \x01\x01\x12\x04\x8a\x03\x20(\n\x0f\n\x07\x047\x03\0\x02\x01\x03\x12\x04\
    \x8a\x03+,\n\x0e\n\x06\x047\x03\0\x02\x02\x12\x04\x8b\x03\x10*\n\x0f\n\
    \x07\x047\x03\0\x02\x02\x04\x12\x04\x8b\x03\x10\x18\n\x0f\n\x07\x047\x03\
    \0\x02\x02\x05\x12\x04\x8b\x03\x19\x1f\n\x0f\n\x07\x047\x03\0\x02\x02\
    \x01\x12\x04\x8b\x03\x20%\n\x0f\n\x07\x047\x03\0\x02\x02\x03\x12\x04\x8b\
    \x03()\n\x0e\n\x06\x047\x03\0\x02\x03\x12\x04\x8c\x03\x101\n\x0f\n\x07\
    \x047\x03\0\x02\x03\x04\x12\x04\x8c\x03\x10\x18\n\x0f\n\x07\x047\x03\0\
    \x02\x03\x05\x12\x04\x8c\x03\x19\x1f\n\x0f\n\x07\x047\x03\0\x02\x03\x01\
    \x12\x04\x8c\x03\x20,\n\x0f\n\x07\x047\x03\0\x02\x03\x03\x12\x04\x8c\x03\
    /0\n\x0c\n\x04\x047\x02\0\x12\x04\x8f\x03\x08#\n\r\n\x05\x047\x02\0\x04\
    \x12\x04\x8f\x03\x08\x10\n\r\n\x05\x047\x02\0\x05\x12\x04\x8f\x03\x11\
    \x17\n\r\n\x05\x047\x02\0\x01\x12\x04\x8f\x03\x18\x1e\n\r\n\x05\x047\x02\
    \0\x03\x12\x04\x8f\x03!\"\n\x0c\n\x04\x047\x02\x01\x12\x04\x90\x03\x08)\
    \n\r\n\x05\x047\x02\x01\x04\x12\x04\x90\x03\x08\x10\n\r\n\x05\x047\x02\
    \x01\x05\x12\x04\x90\x03\x11\x15\n\r\n\x05\x047\x02\x01\x01\x12\x04\x90\
    \x03\x16$\n\r\n\x05\x047\x02\x01\x03\x12\x04\x90\x03'(\n\x0c\n\x04\x047\
    \x02\x02\x12\x04\x91\x03\x08H\n\r\n\x05\x047\x02\x02\x04\x12\x04\x91\x03\
    \x08\x10\n\r\n\x05\x047\x02\x02\x06\x12\x04\x91\x03\x117\n\r\n\x05\x047\
    \x02\x02\x01\x12\x04\x91\x038C\n\r\n\x05\x047\x02\x02\x03\x12\x04\x91\
    \x03FG\n\x0c\n\x02\x048\x12\x06\x94\x03\0\x9b\x03\x01\n\x0b\n\x03\x048\
    \x01\x12\x04\x94\x03\x08&\n\x0e\n\x04\x048\x03\0\x12\x06\x95\x03\x08\x98\
    \x03\t\n\r\n\x05\x048\x03\0\x01\x12\x04\x95\x03\x10\x1c\n\x0e\n\x06\x048\
    \x03\0\x02\0\x12\x04\x96\x03\x100\n\x0f\n\x07\x048\x03\0\x02\0\x04\x12\
    \x04\x96\x03\x10\x18\n\x0f\n\x07\x048\x03\0\x02\0\x05\x12\x04\x96\x03\
    \x19\x1f\n\x0f\n\x07\x048\x03\0\x02\0\x01\x12\x04\x96\x03\x20+\n\x0f\n\
    \x07\x048\x03\0\x02\0\x03\x12\x04\x96\x03./\n\x0e\n\x06\x048\x03\0\x02\
    \x01\x12\x04\x97\x03\x101\n\x0f\n\x07\x048\x03\0\x02\x01\x04\x12\x04\x97\
    \x03\x10\x18\n\x0f\n\x07\x048\x03\0\x02\x01\x05\x12\x04\x97\x03\x19\x1f\
    \n\x0f\n\x07\x048\x03\0\x02\x01\x01\x12\x04\x97\x03\x20,\n\x0f\n\x07\x04\
    8\x03\0\x02\x01\x03\x12\x04\x97\x03/0\n\x0c\n\x04\x048\x02\0\x12\x04\x9a\
    \x03\x08I\n\r\n\x05\x048\x02\0\x04\x12\x04\x9a\x03\x08\x10\n\r\n\x05\x04\
    8\x02\0\x06\x12\x04\x9a\x03\x11<\n\r\n\x05\x048\x02\0\x01\x12\x04\x9a\
    \x03=D\n\r\n\x05\x048\x02\0\x03\x12\x04\x9a\x03GH\n\x0c\n\x02\x049\x12\
    \x06\x9d\x03\0\x9f\x03\x01\n\x0b\n\x03\x049\x01\x12\x04\x9d\x03\x08-\n\
    \x0c\n\x04\x049\x02\0\x12\x04\x9e\x03\x080\n\r\n\x05\x049\x02\0\x04\x12\
    \x04\x9e\x03\x08\x10\n\r\n\x05\x049\x02\0\x05\x12\x04\x9e\x03\x11\x16\n\
    \r\n\x05\x049\x02\0\x01\x12\x04\x9e\x03\x17+\n\r\n\x05\x049\x02\0\x03\
    \x12\x04\x9e\x03./\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(62);
            messages.push(CGCStorePurchaseInit_LineItem::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseInit::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseInitResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPingData::generated_message_descriptor_data());
            messages.push(CMsgInviteToParty::generated_message_descriptor_data());
            messages.push(CMsgInviteToLobby::generated_message_descriptor_data());
            messages.push(CMsgInvitationCreated::generated_message_descriptor_data());
            messages.push(CMsgPartyInviteResponse::generated_message_descriptor_data());
            messages.push(CMsgLobbyInviteResponse::generated_message_descriptor_data());
            messages.push(CMsgKickFromParty::generated_message_descriptor_data());
            messages.push(CMsgLeaveParty::generated_message_descriptor_data());
            messages.push(CMsgCustomGameInstallStatus::generated_message_descriptor_data());
            messages.push(CMsgServerAvailable::generated_message_descriptor_data());
            messages.push(CMsgLANServerAvailable::generated_message_descriptor_data());
            messages.push(CSOEconGameAccountClient::generated_message_descriptor_data());
            messages.push(CMsgApplyStrangePart::generated_message_descriptor_data());
            messages.push(CMsgApplyPennantUpgrade::generated_message_descriptor_data());
            messages.push(CMsgApplyEggEssence::generated_message_descriptor_data());
            messages.push(CSOEconItemAttribute::generated_message_descriptor_data());
            messages.push(CSOEconItemEquipped::generated_message_descriptor_data());
            messages.push(CSOEconItem::generated_message_descriptor_data());
            messages.push(CMsgSortItems::generated_message_descriptor_data());
            messages.push(CMsgConVarValue::generated_message_descriptor_data());
            messages.push(CMsgReplicateConVars::generated_message_descriptor_data());
            messages.push(CMsgItemAcknowledged::generated_message_descriptor_data());
            messages.push(CMsgSetItemPositions::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseCancel::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseCancelResponse::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseFinalize::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseFinalizeResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCBannedWordListUpdated::generated_message_descriptor_data());
            messages.push(CMsgGCToGCDirtySDOCache::generated_message_descriptor_data());
            messages.push(CMsgSDONoMemcached::generated_message_descriptor_data());
            messages.push(CMsgGCToGCUpdateSQLKeyValue::generated_message_descriptor_data());
            messages.push(CMsgGCServerVersionUpdated::generated_message_descriptor_data());
            messages.push(CMsgGCClientVersionUpdated::generated_message_descriptor_data());
            messages.push(CMsgGCToGCWebAPIAccountChanged::generated_message_descriptor_data());
            messages.push(CMsgExtractGems::generated_message_descriptor_data());
            messages.push(CMsgExtractGemsResponse::generated_message_descriptor_data());
            messages.push(CMsgAddSocket::generated_message_descriptor_data());
            messages.push(CMsgAddSocketResponse::generated_message_descriptor_data());
            messages.push(CMsgAddItemToSocketData::generated_message_descriptor_data());
            messages.push(CMsgAddItemToSocket::generated_message_descriptor_data());
            messages.push(CMsgAddItemToSocketResponse::generated_message_descriptor_data());
            messages.push(CMsgResetStrangeGemCount::generated_message_descriptor_data());
            messages.push(CMsgResetStrangeGemCountResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientPollFileRequest::generated_message_descriptor_data());
            messages.push(CMsgGCToClientPollFileResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCPerformManualOp::generated_message_descriptor_data());
            messages.push(CMsgGCToGCPerformManualOpCompleted::generated_message_descriptor_data());
            messages.push(CMsgGCToGCReloadServerRegionSettings::generated_message_descriptor_data());
            messages.push(CMsgGCAdditionalWelcomeMsgList::generated_message_descriptor_data());
            messages.push(CMsgApplyRemoteConVars::generated_message_descriptor_data());
            messages.push(CMsgGCToClientApplyRemoteConVars::generated_message_descriptor_data());
            messages.push(CMsgGCToServerApplyRemoteConVars::generated_message_descriptor_data());
            messages.push(CMsgClientToGCIntegrityStatus::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAggregateMetrics::generated_message_descriptor_data());
            messages.push(CMsgGCToClientAggregateMetricsBackoff::generated_message_descriptor_data());
            messages.push(cmsg_set_item_positions::ItemPosition::generated_message_descriptor_data());
            messages.push(cmsg_apply_remote_con_vars::ConVar::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gcintegrity_status::Keyvalue::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gcaggregate_metrics::SingleMetric::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(EGCBaseMsg::generated_enum_descriptor_data());
            enums.push(ECustomGameInstallStatus::generated_enum_descriptor_data());
            enums.push(cmsg_extract_gems_response::EExtractGems::generated_enum_descriptor_data());
            enums.push(cmsg_add_socket_response::EAddSocket::generated_enum_descriptor_data());
            enums.push(cmsg_add_item_to_socket_response::EAddGem::generated_enum_descriptor_data());
            enums.push(cmsg_reset_strange_gem_count_response::EResetGem::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
