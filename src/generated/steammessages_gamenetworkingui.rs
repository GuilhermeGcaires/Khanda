// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_gamenetworkingui.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CGameNetworkingUI_GlobalState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_GlobalState {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGameNetworkingUI_GlobalState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_GlobalState {
    fn default() -> &'a CGameNetworkingUI_GlobalState {
        <CGameNetworkingUI_GlobalState as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_GlobalState {
    pub fn new() -> CGameNetworkingUI_GlobalState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_GlobalState>(
            "CGameNetworkingUI_GlobalState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_GlobalState {
    const NAME: &'static str = "CGameNetworkingUI_GlobalState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_GlobalState {
        CGameNetworkingUI_GlobalState::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_GlobalState {
        static instance: CGameNetworkingUI_GlobalState = CGameNetworkingUI_GlobalState {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_GlobalState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_GlobalState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_GlobalState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_GlobalState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CGameNetworkingUI_ConnectionState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_ConnectionState {
    // message fields
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.connection_key)
    pub connection_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.connection_id_local)
    pub connection_id_local: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.identity_local)
    pub identity_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.identity_remote)
    pub identity_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.connection_state)
    pub connection_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.close_time)
    pub close_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.close_reason)
    pub close_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.close_message)
    pub close_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.status_loc_token)
    pub status_loc_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.transport_kind)
    pub transport_kind: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.sdrpopid_local)
    pub sdrpopid_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.sdrpopid_remote)
    pub sdrpopid_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.address_remote)
    pub address_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.p2p_routing)
    pub p2p_routing: ::protobuf::MessageField<super::steamdatagram_messages_sdr::CMsgSteamDatagramP2PRoutingSummary>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.ping_interior)
    pub ping_interior: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.ping_remote_front)
    pub ping_remote_front: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.ping_default_internet_route)
    pub ping_default_internet_route: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.e2e_quality_local)
    pub e2e_quality_local: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.e2e_quality_remote)
    pub e2e_quality_remote: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.e2e_quality_remote_instantaneous_time)
    pub e2e_quality_remote_instantaneous_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.e2e_quality_remote_lifetime_time)
    pub e2e_quality_remote_lifetime_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.front_quality_local)
    pub front_quality_local: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.front_quality_remote)
    pub front_quality_remote: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.front_quality_remote_instantaneous_time)
    pub front_quality_remote_instantaneous_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_ConnectionState.front_quality_remote_lifetime_time)
    pub front_quality_remote_lifetime_time: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGameNetworkingUI_ConnectionState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_ConnectionState {
    fn default() -> &'a CGameNetworkingUI_ConnectionState {
        <CGameNetworkingUI_ConnectionState as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_ConnectionState {
    pub fn new() -> CGameNetworkingUI_ConnectionState {
        ::std::default::Default::default()
    }

    // optional string connection_key = 1;

    pub fn connection_key(&self) -> &str {
        match self.connection_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connection_key(&mut self) {
        self.connection_key = ::std::option::Option::None;
    }

    pub fn has_connection_key(&self) -> bool {
        self.connection_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_key(&mut self, v: ::std::string::String) {
        self.connection_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_key(&mut self) -> &mut ::std::string::String {
        if self.connection_key.is_none() {
            self.connection_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connection_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_key(&mut self) -> ::std::string::String {
        self.connection_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id_local = 3;

    pub fn connection_id_local(&self) -> u32 {
        self.connection_id_local.unwrap_or(0)
    }

    pub fn clear_connection_id_local(&mut self) {
        self.connection_id_local = ::std::option::Option::None;
    }

    pub fn has_connection_id_local(&self) -> bool {
        self.connection_id_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_local(&mut self, v: u32) {
        self.connection_id_local = ::std::option::Option::Some(v);
    }

    // optional string identity_local = 4;

    pub fn identity_local(&self) -> &str {
        match self.identity_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identity_local(&mut self) {
        self.identity_local = ::std::option::Option::None;
    }

    pub fn has_identity_local(&self) -> bool {
        self.identity_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_local(&mut self, v: ::std::string::String) {
        self.identity_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_local(&mut self) -> &mut ::std::string::String {
        if self.identity_local.is_none() {
            self.identity_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identity_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_local(&mut self) -> ::std::string::String {
        self.identity_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string identity_remote = 5;

    pub fn identity_remote(&self) -> &str {
        match self.identity_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identity_remote(&mut self) {
        self.identity_remote = ::std::option::Option::None;
    }

    pub fn has_identity_remote(&self) -> bool {
        self.identity_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_remote(&mut self, v: ::std::string::String) {
        self.identity_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_remote(&mut self) -> &mut ::std::string::String {
        if self.identity_remote.is_none() {
            self.identity_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identity_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_remote(&mut self) -> ::std::string::String {
        self.identity_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 connection_state = 10;

    pub fn connection_state(&self) -> u32 {
        self.connection_state.unwrap_or(0)
    }

    pub fn clear_connection_state(&mut self) {
        self.connection_state = ::std::option::Option::None;
    }

    pub fn has_connection_state(&self) -> bool {
        self.connection_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_state(&mut self, v: u32) {
        self.connection_state = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 12;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 close_time = 13;

    pub fn close_time(&self) -> u32 {
        self.close_time.unwrap_or(0)
    }

    pub fn clear_close_time(&mut self) {
        self.close_time = ::std::option::Option::None;
    }

    pub fn has_close_time(&self) -> bool {
        self.close_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_time(&mut self, v: u32) {
        self.close_time = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 14;

    pub fn close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }

    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 15;

    pub fn close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_close_message(&mut self) {
        self.close_message = ::std::option::Option::None;
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status_loc_token = 16;

    pub fn status_loc_token(&self) -> &str {
        match self.status_loc_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_loc_token(&mut self) {
        self.status_loc_token = ::std::option::Option::None;
    }

    pub fn has_status_loc_token(&self) -> bool {
        self.status_loc_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_loc_token(&mut self, v: ::std::string::String) {
        self.status_loc_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_loc_token(&mut self) -> &mut ::std::string::String {
        if self.status_loc_token.is_none() {
            self.status_loc_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status_loc_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_loc_token(&mut self) -> ::std::string::String {
        self.status_loc_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 transport_kind = 20;

    pub fn transport_kind(&self) -> u32 {
        self.transport_kind.unwrap_or(0)
    }

    pub fn clear_transport_kind(&mut self) {
        self.transport_kind = ::std::option::Option::None;
    }

    pub fn has_transport_kind(&self) -> bool {
        self.transport_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_kind(&mut self, v: u32) {
        self.transport_kind = ::std::option::Option::Some(v);
    }

    // optional string sdrpopid_local = 21;

    pub fn sdrpopid_local(&self) -> &str {
        match self.sdrpopid_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpopid_local(&mut self) {
        self.sdrpopid_local = ::std::option::Option::None;
    }

    pub fn has_sdrpopid_local(&self) -> bool {
        self.sdrpopid_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpopid_local(&mut self, v: ::std::string::String) {
        self.sdrpopid_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpopid_local(&mut self) -> &mut ::std::string::String {
        if self.sdrpopid_local.is_none() {
            self.sdrpopid_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpopid_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpopid_local(&mut self) -> ::std::string::String {
        self.sdrpopid_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sdrpopid_remote = 22;

    pub fn sdrpopid_remote(&self) -> &str {
        match self.sdrpopid_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpopid_remote(&mut self) {
        self.sdrpopid_remote = ::std::option::Option::None;
    }

    pub fn has_sdrpopid_remote(&self) -> bool {
        self.sdrpopid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpopid_remote(&mut self, v: ::std::string::String) {
        self.sdrpopid_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpopid_remote(&mut self) -> &mut ::std::string::String {
        if self.sdrpopid_remote.is_none() {
            self.sdrpopid_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpopid_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpopid_remote(&mut self) -> ::std::string::String {
        self.sdrpopid_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address_remote = 23;

    pub fn address_remote(&self) -> &str {
        match self.address_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address_remote(&mut self) {
        self.address_remote = ::std::option::Option::None;
    }

    pub fn has_address_remote(&self) -> bool {
        self.address_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address_remote(&mut self, v: ::std::string::String) {
        self.address_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address_remote(&mut self) -> &mut ::std::string::String {
        if self.address_remote.is_none() {
            self.address_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_address_remote(&mut self) -> ::std::string::String {
        self.address_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping_interior = 25;

    pub fn ping_interior(&self) -> u32 {
        self.ping_interior.unwrap_or(0)
    }

    pub fn clear_ping_interior(&mut self) {
        self.ping_interior = ::std::option::Option::None;
    }

    pub fn has_ping_interior(&self) -> bool {
        self.ping_interior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_interior(&mut self, v: u32) {
        self.ping_interior = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_remote_front = 26;

    pub fn ping_remote_front(&self) -> u32 {
        self.ping_remote_front.unwrap_or(0)
    }

    pub fn clear_ping_remote_front(&mut self) {
        self.ping_remote_front = ::std::option::Option::None;
    }

    pub fn has_ping_remote_front(&self) -> bool {
        self.ping_remote_front.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_remote_front(&mut self, v: u32) {
        self.ping_remote_front = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_default_internet_route = 27;

    pub fn ping_default_internet_route(&self) -> u32 {
        self.ping_default_internet_route.unwrap_or(0)
    }

    pub fn clear_ping_default_internet_route(&mut self) {
        self.ping_default_internet_route = ::std::option::Option::None;
    }

    pub fn has_ping_default_internet_route(&self) -> bool {
        self.ping_default_internet_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_default_internet_route(&mut self, v: u32) {
        self.ping_default_internet_route = ::std::option::Option::Some(v);
    }

    // optional uint64 e2e_quality_remote_instantaneous_time = 32;

    pub fn e2e_quality_remote_instantaneous_time(&self) -> u64 {
        self.e2e_quality_remote_instantaneous_time.unwrap_or(0)
    }

    pub fn clear_e2e_quality_remote_instantaneous_time(&mut self) {
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::None;
    }

    pub fn has_e2e_quality_remote_instantaneous_time(&self) -> bool {
        self.e2e_quality_remote_instantaneous_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_quality_remote_instantaneous_time(&mut self, v: u64) {
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::Some(v);
    }

    // optional uint64 e2e_quality_remote_lifetime_time = 33;

    pub fn e2e_quality_remote_lifetime_time(&self) -> u64 {
        self.e2e_quality_remote_lifetime_time.unwrap_or(0)
    }

    pub fn clear_e2e_quality_remote_lifetime_time(&mut self) {
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::None;
    }

    pub fn has_e2e_quality_remote_lifetime_time(&self) -> bool {
        self.e2e_quality_remote_lifetime_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_quality_remote_lifetime_time(&mut self, v: u64) {
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::Some(v);
    }

    // optional uint64 front_quality_remote_instantaneous_time = 42;

    pub fn front_quality_remote_instantaneous_time(&self) -> u64 {
        self.front_quality_remote_instantaneous_time.unwrap_or(0)
    }

    pub fn clear_front_quality_remote_instantaneous_time(&mut self) {
        self.front_quality_remote_instantaneous_time = ::std::option::Option::None;
    }

    pub fn has_front_quality_remote_instantaneous_time(&self) -> bool {
        self.front_quality_remote_instantaneous_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_quality_remote_instantaneous_time(&mut self, v: u64) {
        self.front_quality_remote_instantaneous_time = ::std::option::Option::Some(v);
    }

    // optional uint64 front_quality_remote_lifetime_time = 43;

    pub fn front_quality_remote_lifetime_time(&self) -> u64 {
        self.front_quality_remote_lifetime_time.unwrap_or(0)
    }

    pub fn clear_front_quality_remote_lifetime_time(&mut self) {
        self.front_quality_remote_lifetime_time = ::std::option::Option::None;
    }

    pub fn has_front_quality_remote_lifetime_time(&self) -> bool {
        self.front_quality_remote_lifetime_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_quality_remote_lifetime_time(&mut self, v: u64) {
        self.front_quality_remote_lifetime_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_key",
            |m: &CGameNetworkingUI_ConnectionState| { &m.connection_key },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.connection_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CGameNetworkingUI_ConnectionState| { &m.appid },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.connection_id_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.connection_id_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identity_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.identity_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.identity_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identity_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.identity_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.identity_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_state",
            |m: &CGameNetworkingUI_ConnectionState| { &m.connection_state },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.connection_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.start_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.close_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.close_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_reason",
            |m: &CGameNetworkingUI_ConnectionState| { &m.close_reason },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.close_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_message",
            |m: &CGameNetworkingUI_ConnectionState| { &m.close_message },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.close_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_loc_token",
            |m: &CGameNetworkingUI_ConnectionState| { &m.status_loc_token },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.status_loc_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport_kind",
            |m: &CGameNetworkingUI_ConnectionState| { &m.transport_kind },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.transport_kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdrpopid_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.sdrpopid_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.sdrpopid_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdrpopid_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.sdrpopid_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.sdrpopid_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.address_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.address_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamdatagram_messages_sdr::CMsgSteamDatagramP2PRoutingSummary>(
            "p2p_routing",
            |m: &CGameNetworkingUI_ConnectionState| { &m.p2p_routing },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.p2p_routing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_interior",
            |m: &CGameNetworkingUI_ConnectionState| { &m.ping_interior },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.ping_interior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_remote_front",
            |m: &CGameNetworkingUI_ConnectionState| { &m.ping_remote_front },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.ping_remote_front },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_default_internet_route",
            |m: &CGameNetworkingUI_ConnectionState| { &m.ping_default_internet_route },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.ping_default_internet_route },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "e2e_quality_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "e2e_quality_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "e2e_quality_remote_instantaneous_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_remote_instantaneous_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_remote_instantaneous_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "e2e_quality_remote_lifetime_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_remote_lifetime_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_remote_lifetime_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "front_quality_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "front_quality_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "front_quality_remote_instantaneous_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_remote_instantaneous_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_remote_instantaneous_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "front_quality_remote_lifetime_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_remote_lifetime_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_remote_lifetime_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_ConnectionState>(
            "CGameNetworkingUI_ConnectionState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_ConnectionState {
    const NAME: &'static str = "CGameNetworkingUI_ConnectionState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_key = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.connection_id_local = ::std::option::Option::Some(is.read_fixed32()?);
                },
                34 => {
                    self.identity_local = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.identity_remote = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.connection_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.close_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.close_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.close_message = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.status_loc_token = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.transport_kind = ::std::option::Option::Some(is.read_uint32()?);
                },
                170 => {
                    self.sdrpopid_local = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.sdrpopid_remote = ::std::option::Option::Some(is.read_string()?);
                },
                186 => {
                    self.address_remote = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p2p_routing)?;
                },
                200 => {
                    self.ping_interior = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.ping_remote_front = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.ping_default_internet_route = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.e2e_quality_local)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.e2e_quality_remote)?;
                },
                256 => {
                    self.e2e_quality_remote_instantaneous_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                264 => {
                    self.e2e_quality_remote_lifetime_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.front_quality_local)?;
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.front_quality_remote)?;
                },
                336 => {
                    self.front_quality_remote_instantaneous_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                344 => {
                    self.front_quality_remote_lifetime_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.connection_id_local {
            my_size += 1 + 4;
        }
        if let Some(v) = self.identity_local.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.identity_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.connection_state {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.close_time {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.close_reason {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.close_message.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.status_loc_token.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.transport_kind {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.sdrpopid_local.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.sdrpopid_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.address_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.p2p_routing.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ping_interior {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.ping_remote_front {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.ping_default_internet_route {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.e2e_quality_local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.e2e_quality_remote.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.e2e_quality_remote_instantaneous_time {
            my_size += ::protobuf::rt::uint64_size(32, v);
        }
        if let Some(v) = self.e2e_quality_remote_lifetime_time {
            my_size += ::protobuf::rt::uint64_size(33, v);
        }
        if let Some(v) = self.front_quality_local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.front_quality_remote.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.front_quality_remote_instantaneous_time {
            my_size += ::protobuf::rt::uint64_size(42, v);
        }
        if let Some(v) = self.front_quality_remote_lifetime_time {
            my_size += ::protobuf::rt::uint64_size(43, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.connection_id_local {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.identity_local.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.identity_remote.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.connection_state {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.close_time {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.close_message.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.status_loc_token.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.transport_kind {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.sdrpopid_local.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.sdrpopid_remote.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.address_remote.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.p2p_routing.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.ping_interior {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.ping_remote_front {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.ping_default_internet_route {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.e2e_quality_local.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.e2e_quality_remote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.e2e_quality_remote_instantaneous_time {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.e2e_quality_remote_lifetime_time {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.front_quality_local.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.front_quality_remote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.front_quality_remote_instantaneous_time {
            os.write_uint64(42, v)?;
        }
        if let Some(v) = self.front_quality_remote_lifetime_time {
            os.write_uint64(43, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_ConnectionState {
        CGameNetworkingUI_ConnectionState::new()
    }

    fn clear(&mut self) {
        self.connection_key = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.connection_id_local = ::std::option::Option::None;
        self.identity_local = ::std::option::Option::None;
        self.identity_remote = ::std::option::Option::None;
        self.connection_state = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.close_time = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message = ::std::option::Option::None;
        self.status_loc_token = ::std::option::Option::None;
        self.transport_kind = ::std::option::Option::None;
        self.sdrpopid_local = ::std::option::Option::None;
        self.sdrpopid_remote = ::std::option::Option::None;
        self.address_remote = ::std::option::Option::None;
        self.p2p_routing.clear();
        self.ping_interior = ::std::option::Option::None;
        self.ping_remote_front = ::std::option::Option::None;
        self.ping_default_internet_route = ::std::option::Option::None;
        self.e2e_quality_local.clear();
        self.e2e_quality_remote.clear();
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::None;
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::None;
        self.front_quality_local.clear();
        self.front_quality_remote.clear();
        self.front_quality_remote_instantaneous_time = ::std::option::Option::None;
        self.front_quality_remote_lifetime_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_ConnectionState {
        static instance: CGameNetworkingUI_ConnectionState = CGameNetworkingUI_ConnectionState {
            connection_key: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            connection_id_local: ::std::option::Option::None,
            identity_local: ::std::option::Option::None,
            identity_remote: ::std::option::Option::None,
            connection_state: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            close_time: ::std::option::Option::None,
            close_reason: ::std::option::Option::None,
            close_message: ::std::option::Option::None,
            status_loc_token: ::std::option::Option::None,
            transport_kind: ::std::option::Option::None,
            sdrpopid_local: ::std::option::Option::None,
            sdrpopid_remote: ::std::option::Option::None,
            address_remote: ::std::option::Option::None,
            p2p_routing: ::protobuf::MessageField::none(),
            ping_interior: ::std::option::Option::None,
            ping_remote_front: ::std::option::Option::None,
            ping_default_internet_route: ::std::option::Option::None,
            e2e_quality_local: ::protobuf::MessageField::none(),
            e2e_quality_remote: ::protobuf::MessageField::none(),
            e2e_quality_remote_instantaneous_time: ::std::option::Option::None,
            e2e_quality_remote_lifetime_time: ::std::option::Option::None,
            front_quality_local: ::protobuf::MessageField::none(),
            front_quality_remote: ::protobuf::MessageField::none(),
            front_quality_remote_instantaneous_time: ::std::option::Option::None,
            front_quality_remote_lifetime_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_ConnectionState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_ConnectionState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_ConnectionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_ConnectionState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CGameNetworkingUI_Message)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_Message {
    // message fields
    // @@protoc_insertion_point(field:dota.CGameNetworkingUI_Message.connection_state)
    pub connection_state: ::std::vec::Vec<CGameNetworkingUI_ConnectionState>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGameNetworkingUI_Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_Message {
    fn default() -> &'a CGameNetworkingUI_Message {
        <CGameNetworkingUI_Message as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_Message {
    pub fn new() -> CGameNetworkingUI_Message {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connection_state",
            |m: &CGameNetworkingUI_Message| { &m.connection_state },
            |m: &mut CGameNetworkingUI_Message| { &mut m.connection_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_Message>(
            "CGameNetworkingUI_Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_Message {
    const NAME: &'static str = "CGameNetworkingUI_Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_state.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.connection_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.connection_state {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_Message {
        CGameNetworkingUI_Message::new()
    }

    fn clear(&mut self) {
        self.connection_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_Message {
        static instance: CGameNetworkingUI_Message = CGameNetworkingUI_Message {
            connection_state: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_gamenetworkingui.proto\x12\x04dota\x1a%steamnetworkings\
    ockets_messages.proto\x1a\x20steamdatagram_messages_sdr.proto\"\x1f\n\
    \x1dCGameNetworkingUI_GlobalState\"\xd4\x0b\n!CGameNetworkingUI_Connecti\
    onState\x12%\n\x0econnection_key\x18\x01\x20\x01(\tR\rconnectionKey\x12\
    \x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12.\n\x13connection_id_loc\
    al\x18\x03\x20\x01(\x07R\x11connectionIdLocal\x12%\n\x0eidentity_local\
    \x18\x04\x20\x01(\tR\ridentityLocal\x12'\n\x0fidentity_remote\x18\x05\
    \x20\x01(\tR\x0eidentityRemote\x12)\n\x10connection_state\x18\n\x20\x01(\
    \rR\x0fconnectionState\x12\x1d\n\nstart_time\x18\x0c\x20\x01(\rR\tstartT\
    ime\x12\x1d\n\nclose_time\x18\r\x20\x01(\rR\tcloseTime\x12!\n\x0cclose_r\
    eason\x18\x0e\x20\x01(\rR\x0bcloseReason\x12#\n\rclose_message\x18\x0f\
    \x20\x01(\tR\x0ccloseMessage\x12(\n\x10status_loc_token\x18\x10\x20\x01(\
    \tR\x0estatusLocToken\x12%\n\x0etransport_kind\x18\x14\x20\x01(\rR\rtran\
    sportKind\x12%\n\x0esdrpopid_local\x18\x15\x20\x01(\tR\rsdrpopidLocal\
    \x12'\n\x0fsdrpopid_remote\x18\x16\x20\x01(\tR\x0esdrpopidRemote\x12%\n\
    \x0eaddress_remote\x18\x17\x20\x01(\tR\raddressRemote\x12I\n\x0bp2p_rout\
    ing\x18\x18\x20\x01(\x0b2(.dota.CMsgSteamDatagramP2PRoutingSummaryR\np2p\
    Routing\x12#\n\rping_interior\x18\x19\x20\x01(\rR\x0cpingInterior\x12*\n\
    \x11ping_remote_front\x18\x1a\x20\x01(\rR\x0fpingRemoteFront\x12=\n\x1bp\
    ing_default_internet_route\x18\x1b\x20\x01(\rR\x18pingDefaultInternetRou\
    te\x12T\n\x11e2e_quality_local\x18\x1e\x20\x01(\x0b2(.dota.CMsgSteamData\
    gramConnectionQualityR\x0fe2eQualityLocal\x12V\n\x12e2e_quality_remote\
    \x18\x1f\x20\x01(\x0b2(.dota.CMsgSteamDatagramConnectionQualityR\x10e2eQ\
    ualityRemote\x12P\n%e2e_quality_remote_instantaneous_time\x18\x20\x20\
    \x01(\x04R!e2eQualityRemoteInstantaneousTime\x12F\n\x20e2e_quality_remot\
    e_lifetime_time\x18!\x20\x01(\x04R\x1ce2eQualityRemoteLifetimeTime\x12X\
    \n\x13front_quality_local\x18(\x20\x01(\x0b2(.dota.CMsgSteamDatagramConn\
    ectionQualityR\x11frontQualityLocal\x12Z\n\x14front_quality_remote\x18)\
    \x20\x01(\x0b2(.dota.CMsgSteamDatagramConnectionQualityR\x12frontQuality\
    Remote\x12T\n'front_quality_remote_instantaneous_time\x18*\x20\x01(\x04R\
    #frontQualityRemoteInstantaneousTime\x12J\n\"front_quality_remote_lifeti\
    me_time\x18+\x20\x01(\x04R\x1efrontQualityRemoteLifetimeTime\"o\n\x19CGa\
    meNetworkingUI_Message\x12R\n\x10connection_state\x18\x01\x20\x03(\x0b2'\
    .dota.CGameNetworkingUI_ConnectionStateR\x0fconnectionStateB*H\x01Z#gith\
    ub.com/dotabuff/manta/dota;dota\x80\x01\x01J\xc5\x10\n\x06\x12\x04\0\0.\
    \x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\
    \n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\
    \x02\x03\0\x12\x03\x05\x07.\n\t\n\x02\x03\x01\x12\x03\x06\x07)\n\x08\n\
    \x01\x08\x12\x03\x08\0\x1c\n\t\n\x02\x08\t\x12\x03\x08\0\x1c\n\x08\n\x01\
    \x08\x12\x03\t\0\"\n\t\n\x02\x08\x10\x12\x03\t\0\"\n\n\n\x02\x04\0\x12\
    \x04\x0b\0\x0c\x01\n\n\n\x03\x04\0\x01\x12\x03\x0b\x08%\n\n\n\x02\x04\
    \x01\x12\x04\x0e\0*\x01\n\n\n\x03\x04\x01\x01\x12\x03\x0e\x08)\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03\x0f\x08+\n\x0c\n\x05\x04\x01\x02\0\x04\x12\
    \x03\x0f\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x0f\x11\x17\n\x0c\
    \n\x05\x04\x01\x02\0\x01\x12\x03\x0f\x18&\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x0f)*\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x10\x08\"\n\x0c\n\x05\
    \x04\x01\x02\x01\x04\x12\x03\x10\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03\x10\x11\x17\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x10\x18\x1d\
    \n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x10\x20!\n\x0b\n\x04\x04\x01\
    \x02\x02\x12\x03\x11\x081\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x11\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x11\x11\x18\n\x0c\n\x05\
    \x04\x01\x02\x02\x01\x12\x03\x11\x19,\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03\x11/0\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x12\x08+\n\x0c\n\x05\
    \x04\x01\x02\x03\x04\x12\x03\x12\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\
    \x12\x03\x12\x11\x17\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x12\x18&\n\
    \x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x12)*\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x03\x13\x08,\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03\x13\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x13\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\x04\x01\x12\x03\x13\x18'\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\
    \x13*+\n\x0b\n\x04\x04\x01\x02\x05\x12\x03\x14\x08.\n\x0c\n\x05\x04\x01\
    \x02\x05\x04\x12\x03\x14\x08\x10\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03\
    \x14\x11\x17\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x14\x18(\n\x0c\n\
    \x05\x04\x01\x02\x05\x03\x12\x03\x14+-\n\x0b\n\x04\x04\x01\x02\x06\x12\
    \x03\x15\x08(\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03\x15\x08\x10\n\x0c\
    \n\x05\x04\x01\x02\x06\x05\x12\x03\x15\x11\x17\n\x0c\n\x05\x04\x01\x02\
    \x06\x01\x12\x03\x15\x18\"\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03\x15%'\
    \n\x0b\n\x04\x04\x01\x02\x07\x12\x03\x16\x08(\n\x0c\n\x05\x04\x01\x02\
    \x07\x04\x12\x03\x16\x08\x10\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\x03\x16\
    \x11\x17\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03\x16\x18\"\n\x0c\n\x05\
    \x04\x01\x02\x07\x03\x12\x03\x16%'\n\x0b\n\x04\x04\x01\x02\x08\x12\x03\
    \x17\x08*\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03\x17\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x08\x05\x12\x03\x17\x11\x17\n\x0c\n\x05\x04\x01\x02\x08\
    \x01\x12\x03\x17\x18$\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03\x17')\n\
    \x0b\n\x04\x04\x01\x02\t\x12\x03\x18\x08+\n\x0c\n\x05\x04\x01\x02\t\x04\
    \x12\x03\x18\x08\x10\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03\x18\x11\x17\n\
    \x0c\n\x05\x04\x01\x02\t\x01\x12\x03\x18\x18%\n\x0c\n\x05\x04\x01\x02\t\
    \x03\x12\x03\x18(*\n\x0b\n\x04\x04\x01\x02\n\x12\x03\x19\x08.\n\x0c\n\
    \x05\x04\x01\x02\n\x04\x12\x03\x19\x08\x10\n\x0c\n\x05\x04\x01\x02\n\x05\
    \x12\x03\x19\x11\x17\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03\x19\x18(\n\
    \x0c\n\x05\x04\x01\x02\n\x03\x12\x03\x19+-\n\x0b\n\x04\x04\x01\x02\x0b\
    \x12\x03\x1a\x08,\n\x0c\n\x05\x04\x01\x02\x0b\x04\x12\x03\x1a\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03\x1a\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\x0b\x01\x12\x03\x1a\x18&\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x03\
    \x1a)+\n\x0b\n\x04\x04\x01\x02\x0c\x12\x03\x1b\x08,\n\x0c\n\x05\x04\x01\
    \x02\x0c\x04\x12\x03\x1b\x08\x10\n\x0c\n\x05\x04\x01\x02\x0c\x05\x12\x03\
    \x1b\x11\x17\n\x0c\n\x05\x04\x01\x02\x0c\x01\x12\x03\x1b\x18&\n\x0c\n\
    \x05\x04\x01\x02\x0c\x03\x12\x03\x1b)+\n\x0b\n\x04\x04\x01\x02\r\x12\x03\
    \x1c\x08-\n\x0c\n\x05\x04\x01\x02\r\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\r\x05\x12\x03\x1c\x11\x17\n\x0c\n\x05\x04\x01\x02\r\x01\x12\
    \x03\x1c\x18'\n\x0c\n\x05\x04\x01\x02\r\x03\x12\x03\x1c*,\n\x0b\n\x04\
    \x04\x01\x02\x0e\x12\x03\x1d\x08,\n\x0c\n\x05\x04\x01\x02\x0e\x04\x12\
    \x03\x1d\x08\x10\n\x0c\n\x05\x04\x01\x02\x0e\x05\x12\x03\x1d\x11\x17\n\
    \x0c\n\x05\x04\x01\x02\x0e\x01\x12\x03\x1d\x18&\n\x0c\n\x05\x04\x01\x02\
    \x0e\x03\x12\x03\x1d)+\n\x0b\n\x04\x04\x01\x02\x0f\x12\x03\x1e\x08E\n\
    \x0c\n\x05\x04\x01\x02\x0f\x04\x12\x03\x1e\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x0f\x06\x12\x03\x1e\x113\n\x0c\n\x05\x04\x01\x02\x0f\x01\x12\x03\
    \x1e4?\n\x0c\n\x05\x04\x01\x02\x0f\x03\x12\x03\x1eBD\n\x0b\n\x04\x04\x01\
    \x02\x10\x12\x03\x1f\x08+\n\x0c\n\x05\x04\x01\x02\x10\x04\x12\x03\x1f\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\x10\x05\x12\x03\x1f\x11\x17\n\x0c\n\x05\
    \x04\x01\x02\x10\x01\x12\x03\x1f\x18%\n\x0c\n\x05\x04\x01\x02\x10\x03\
    \x12\x03\x1f(*\n\x0b\n\x04\x04\x01\x02\x11\x12\x03\x20\x08/\n\x0c\n\x05\
    \x04\x01\x02\x11\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\x01\x02\x11\x05\
    \x12\x03\x20\x11\x17\n\x0c\n\x05\x04\x01\x02\x11\x01\x12\x03\x20\x18)\n\
    \x0c\n\x05\x04\x01\x02\x11\x03\x12\x03\x20,.\n\x0b\n\x04\x04\x01\x02\x12\
    \x12\x03!\x089\n\x0c\n\x05\x04\x01\x02\x12\x04\x12\x03!\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x12\x05\x12\x03!\x11\x17\n\x0c\n\x05\x04\x01\x02\x12\
    \x01\x12\x03!\x183\n\x0c\n\x05\x04\x01\x02\x12\x03\x12\x03!68\n\x0b\n\
    \x04\x04\x01\x02\x13\x12\x03\"\x08K\n\x0c\n\x05\x04\x01\x02\x13\x04\x12\
    \x03\"\x08\x10\n\x0c\n\x05\x04\x01\x02\x13\x06\x12\x03\"\x113\n\x0c\n\
    \x05\x04\x01\x02\x13\x01\x12\x03\"4E\n\x0c\n\x05\x04\x01\x02\x13\x03\x12\
    \x03\"HJ\n\x0b\n\x04\x04\x01\x02\x14\x12\x03#\x08L\n\x0c\n\x05\x04\x01\
    \x02\x14\x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\x01\x02\x14\x06\x12\x03#\
    \x113\n\x0c\n\x05\x04\x01\x02\x14\x01\x12\x03#4F\n\x0c\n\x05\x04\x01\x02\
    \x14\x03\x12\x03#IK\n\x0b\n\x04\x04\x01\x02\x15\x12\x03$\x08C\n\x0c\n\
    \x05\x04\x01\x02\x15\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x01\x02\x15\
    \x05\x12\x03$\x11\x17\n\x0c\n\x05\x04\x01\x02\x15\x01\x12\x03$\x18=\n\
    \x0c\n\x05\x04\x01\x02\x15\x03\x12\x03$@B\n\x0b\n\x04\x04\x01\x02\x16\
    \x12\x03%\x08>\n\x0c\n\x05\x04\x01\x02\x16\x04\x12\x03%\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x16\x05\x12\x03%\x11\x17\n\x0c\n\x05\x04\x01\x02\x16\
    \x01\x12\x03%\x188\n\x0c\n\x05\x04\x01\x02\x16\x03\x12\x03%;=\n\x0b\n\
    \x04\x04\x01\x02\x17\x12\x03&\x08M\n\x0c\n\x05\x04\x01\x02\x17\x04\x12\
    \x03&\x08\x10\n\x0c\n\x05\x04\x01\x02\x17\x06\x12\x03&\x113\n\x0c\n\x05\
    \x04\x01\x02\x17\x01\x12\x03&4G\n\x0c\n\x05\x04\x01\x02\x17\x03\x12\x03&\
    JL\n\x0b\n\x04\x04\x01\x02\x18\x12\x03'\x08N\n\x0c\n\x05\x04\x01\x02\x18\
    \x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\x01\x02\x18\x06\x12\x03'\x113\n\
    \x0c\n\x05\x04\x01\x02\x18\x01\x12\x03'4H\n\x0c\n\x05\x04\x01\x02\x18\
    \x03\x12\x03'KM\n\x0b\n\x04\x04\x01\x02\x19\x12\x03(\x08E\n\x0c\n\x05\
    \x04\x01\x02\x19\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x01\x02\x19\x05\
    \x12\x03(\x11\x17\n\x0c\n\x05\x04\x01\x02\x19\x01\x12\x03(\x18?\n\x0c\n\
    \x05\x04\x01\x02\x19\x03\x12\x03(BD\n\x0b\n\x04\x04\x01\x02\x1a\x12\x03)\
    \x08@\n\x0c\n\x05\x04\x01\x02\x1a\x04\x12\x03)\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x1a\x05\x12\x03)\x11\x17\n\x0c\n\x05\x04\x01\x02\x1a\x01\x12\
    \x03)\x18:\n\x0c\n\x05\x04\x01\x02\x1a\x03\x12\x03)=?\n\n\n\x02\x04\x02\
    \x12\x04,\0.\x01\n\n\n\x03\x04\x02\x01\x12\x03,\x08!\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x03-\x08H\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03-\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\0\x06\x12\x03-\x112\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03-3C\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03-FG\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steamnetworkingsockets_messages::file_descriptor().clone());
            deps.push(super::steamdatagram_messages_sdr::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(3);
            messages.push(CGameNetworkingUI_GlobalState::generated_message_descriptor_data());
            messages.push(CGameNetworkingUI_ConnectionState::generated_message_descriptor_data());
            messages.push(CGameNetworkingUI_Message::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
